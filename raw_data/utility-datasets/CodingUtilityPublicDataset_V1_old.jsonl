{"task_id": "revision1a_problem746", "prompt": "from typing import List\n\ndef longest_substring(s: str) -> int:\n    \"\"\"\n    You're working on a text analysis project for a linguistics professor.\n    Your task is to find the length of the longest substring without repeating characters in a given string.\n    Take a string as input from the user and return the length of the longest substring without repeating characters.\n    Try to solve this problem with a time complexity of O(n) where n is the length of the string.\n\n    Example 1:\n    Input: \"abcabcbb\"\n    Output: 3 # The longest substring without repeating characters is \"abc\"\n\n    Example 2:\n    Input: \"bbbbb\"\n    Output: 1 # The longest substring without repeating characters is \"b\"\n\n    Example 3:\n    Input: \"pwwkew\"\n    Output: 3 # The longest substring without repeating characters is \"wke\"\n    \"\"\"\n", "entry_point": "longest_substring", "solution": "    char_index = {}  # Dictionary to store the last seen index of each character\n    start = 0  # Start index of the current substring\n    max_length = 0  # Length of the longest substring without repeating characters\n\n    for end, char in enumerate(s):\n        # If the character is already in the current substring,\n        # move the start pointer to the right of its last occurrence\n        if char in char_index and char_index[char] >= start:\n            start = char_index[char] + 1\n        else:\n            # Update max_length if the current substring is longer\n            max_length = max(max_length, end - start + 1)\n\n        # Update the last seen index of the current character\n        char_index[char] = end\n\n    return max_length\n", "test": "def check(candidate):\n    assert candidate(\"dvdf\") == 3\n    assert candidate(\"pwwkew\") == 3\n    assert candidate(\"bbbbb\") == 1\n    assert candidate(\"a\") == 1\n    assert candidate(\"ab\") == 2\n    assert candidate(\"abc\") == 3\n    assert candidate(\"tmmzuxt\") == 5\n    assert candidate(\"abcabcbb\") == 3\n    assert candidate(\"aa\") == 1\n    assert candidate(\"\") == 0\n", "language": "python"}
{"task_id": "revision1a_problem118", "prompt": "from typing import List\n\ndef longest_increasing_path(matrix: List[List[int]]) -> int:\n    \"\"\"\n    Given an m x n integers matrix, return the length of the longest increasing path in the matrix.\n    \n    This problem can be seen as finding the longest hiking trail in a mountainous region, \n    where each cell represents the altitude at that point.\n    \n    Use depth-first search (DFS) with memoization to solve this problem efficiently.\n    Take a 2D matrix as input from the user and return the length of the longest increasing path.\n\n    Example:\n    Input: [[9,9,4],[6,6,8],[2,1,1]]\n    Output: 4\n    Input: [[3,4,5],[3,2,6],[2,2,1]]\n    Output: 4\n    Input: [[1]]\n    Output: 1\n    \"\"\"\n", "entry_point": "longest_increasing_path", "solution": "    if not matrix or not matrix[0]:\n        return 0\n\n    m, n = len(matrix), len(matrix[0])\n    memo = [[0] * n for _ in range(m)]\n    \n    def dfs(i: int, j: int) -> int:\n        if memo[i][j] != 0:\n            return memo[i][j]\n        \n        directions = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n        max_length = 1\n        \n        for di, dj in directions:\n            ni, nj = i + di, j + dj\n            if 0 <= ni < m and 0 <= nj < n and matrix[ni][nj] > matrix[i][j]:\n                max_length = max(max_length, 1 + dfs(ni, nj))\n        \n        memo[i][j] = max_length\n        return max_length\n    \n    max_path = 0\n    for i in range(m):\n        for j in range(n):\n            max_path = max(max_path, dfs(i, j))\n    \n    return max_path\n", "test": "def check(candidate):\n    assert candidate([[1,2],[3,4]]) == 3\n    assert candidate([[5,4,3],[6,7,8],[9,10,11]]) == 7\n    assert candidate([[1]]) == 1\n    assert candidate([[1,2],[2,3]]) == 3\n    assert candidate([[1,2,3],[8,9,4],[7,6,5]]) == 9\n    assert candidate([[9,8,7],[6,5,4],[3,2,1]]) == 5\n    assert candidate([[10]]) == 1\n    assert candidate([[1,1,1],[1,1,1],[1,1,1]]) == 1\n    assert candidate([[3,4,5],[3,2,6],[2,2,1]]) == 4\n    assert candidate([[9,9,4],[6,6,8],[2,1,1]]) == 4\n", "language": "python"}
{"task_id": "revision1a_problem708", "prompt": "def longest_palindrome_substring(s: str) -> str:\n    \"\"\"\n    You are developing a text analysis tool for a literary website. One of the features\n    is to find the longest palindromic substring in a given text. A palindrome is a word,\n    phrase, number, or other sequence of characters that reads the same forward and backward.\n    Write a function that takes a string as input and returns the longest palindromic substring.\n    If there are multiple palindromic substrings with the same maximum length, return the first one.\n\n    Example:\n    Input: 'babad'\n    Output: 'bab'\n    Input: 'cbbd'\n    Output: 'bb'\n    \"\"\"\n", "entry_point": "longest_palindrome_substring", "solution": "    def expand_around_center(left: int, right: int) -> str:\n        while left >= 0 and right < len(s) and s[left] == s[right]:\n            left -= 1\n            right += 1\n        return s[left + 1:right]\n\n    if len(s) < 2:\n        return s\n\n    longest = \"\"\n    for i in range(len(s)):\n        # Check for odd-length palindromes\n        palindrome1 = expand_around_center(i, i)\n        if len(palindrome1) > len(longest):\n            longest = palindrome1\n\n        # Check for even-length palindromes\n        palindrome2 = expand_around_center(i, i + 1)\n        if len(palindrome2) > len(longest):\n            longest = palindrome2\n\n    return longest\n", "test": "def check(candidate):\n    assert candidate(\"abba\") == 'abba'\n    assert candidate(\"abcde\") == 'a'\n    assert candidate(\"babad\") == 'bab'\n    assert candidate(\"abb\") == 'bb'\n    assert candidate(\"a\") == 'a'\n    assert candidate(\"cbbd\") == 'bb'\n    assert candidate(\"racecar\") == 'racecar'\n    assert candidate(\"abcdefgfedcba\") == 'abcdefgfedcba'\n    assert candidate(\"aa\") == 'aa'\n    assert candidate(\"aaa\") == 'aaa'\n", "language": "python"}
{"task_id": "revision1a_problem133", "prompt": "from typing import List\n\ndef maximize_profit(prices: List[int], k: int) -> int:\n    \"\"\"\n    You are a day trader in the stock market. You have a list of stock prices for n consecutive days, and you want to maximize your profit by making at most k transactions.\n\n    A transaction consists of buying a stock on one day and selling it on a later day. You cannot engage in multiple transactions simultaneously (i.e., you must sell the stock before you buy again).\n\n    Write a function that takes the list of stock prices and the maximum number of transactions k as input, and returns the maximum profit you can achieve.\n\n    Example:\n    Input: prices = [3,2,6,5,0,3], k = 2\n    Output: 7\n    Explanation: Buy on day 2 (price = 2) and sell on day 3 (price = 6), profit = 6-2 = 4.\n                 Then buy on day 5 (price = 0) and sell on day 6 (price = 3), profit = 3-0 = 3.\n    \n    Input: prices = [1,2,3,4,5], k = 2\n    Output: 4\n    Explanation: Buy on day 1 (price = 1) and sell on day 5 (price = 5), profit = 5-1 = 4.\n                 Note that you cannot buy on day 1, buy on day 2 and sell them later, as you are engaging in multiple transactions at the same time. You must sell before buying again.\n    \"\"\"\n", "entry_point": "maximize_profit", "solution": "    if not prices or k == 0:\n        return 0\n\n    n = len(prices)\n    \n    # If k is larger than or equal to n/2, we can make maximum profit by making transactions on every profitable opportunity\n    if k >= n // 2:\n        return sum(max(0, prices[i] - prices[i-1]) for i in range(1, n))\n\n    # dp[i][j] represents the maximum profit on day i with at most j transactions\n    dp = [[0] * (k + 1) for _ in range(n)]\n\n    for j in range(1, k + 1):\n        max_diff = -prices[0]\n        for i in range(1, n):\n            dp[i][j] = max(dp[i-1][j], prices[i] + max_diff)\n            max_diff = max(max_diff, dp[i][j-1] - prices[i])\n\n    return dp[n-1][k]\n", "test": "def check(candidate):\n    assert candidate([3,3,5,0,0,3,1,4], 2) == 6\n    assert candidate([1,1,1,1,1], 5) == 0\n    assert candidate([1,2,3,4,5,4,3,2,1,0], 4) == 4\n    assert candidate([1,2,4,2,5,7,2,4,9,0], 3) == 15\n    assert candidate([7,1,5,3,6,4], 2) == 7\n    assert candidate([1,2,3,4,5], 2) == 4\n    assert candidate([10,9,8,7,6,5,4,3,2,1], 3) == 0\n    assert candidate([1,2,3,4,5], 1) == 4\n    assert candidate([3,2,6,5,0,3], 2) == 7\n    assert candidate([7,6,4,3,1], 2) == 0\n", "language": "python"}
{"task_id": "revision1a_problem269", "prompt": "from typing import List, Dict\nfrom collections import defaultdict, deque\n\ndef social_network_influence(connections: List[List[int]], initial_adopters: List[int], threshold: float) -> Dict[int, int]:\n    \"\"\"\n    We're studying the spread of a new technology in a social network. Each person adopts the technology if a certain \npercentage of their connections have already adopted it.\n\nGiven a list of connections between people, a list of initial adopters, and an adoption threshold:\n1. Model the spread of technology adoption through the network\n2. For each person, determine in which round they adopt the technology (if at all)\n3. Use a queue-based approach for efficient propagation\n\nTake input for connections, initial_adopters, and threshold from the user. Return a dictionary where keys are person IDs \nand values are the round in which they adopted (or -1 if they never adopt).\n\nExample:\n\nInput: connections = [[0,1], [0,2], [1,2], [2,3]], initial_adopters = [0], threshold = 0.5\nOutput: {0: 0, 1: 1, 2: 1, 3: 2}\nInput: connections = [[0,1], [1,2], [2,3], [3,4]], initial_adopters = [0, 4], threshold = 0.6\nOutput: {0: 0, 1: 1, 2: -1, 3: 1, 4: 0}\n    \"\"\"\n", "entry_point": "social_network_influence", "solution": "    # Build the graph\n    graph = defaultdict(set)\n    for a, b in connections:\n        graph[a].add(b)\n        graph[b].add(a)\n    \n    # Initialize adoption status\n    adoption_round = {person: -1 for person in graph}\n    for adopter in initial_adopters:\n        adoption_round[adopter] = 0\n    \n    # Queue for BFS\n    queue = deque(initial_adopters)\n    current_round = 0\n    \n    while queue:\n        level_size = len(queue)\n        current_round += 1\n        \n        for _ in range(level_size):\n            person = queue.popleft()\n            \n            for neighbor in graph[person]:\n                if adoption_round[neighbor] == -1:\n                    adopted_neighbors = sum(1 for p in graph[neighbor] if adoption_round[p] != -1)\n                    if adopted_neighbors / len(graph[neighbor]) >= threshold:\n                        adoption_round[neighbor] = current_round\n                        queue.append(neighbor)\n    \n    return adoption_round\n\n", "test": "def check(candidate):\n    assert candidate([[0,1], [1,2], [2,3], [3,4]], [0, 4], 0.6) == {0: 0, 1: -1, 2: -1, 3: -1, 4: 0}\n    assert candidate([[0,1], [1,2], [2,3], [3,4], [4,5], [5,6], [6,7]], [3, 5], 0.5) == {0: 3, 1: 2, 2: 1, 3: 0, 4: 1, 5: 0, 6: 1, 7: 2}\n    assert candidate([[0,1], [0,2], [1,2], [2,3]], [0], 0.5) == {0: 0, 1: 1, 2: 1, 3: 2}\n    assert candidate([[0,1], [0,2], [0,3], [1,2], [1,3], [2,3]], [0], 0.7) == {0: 0, 1: -1, 2: -1, 3: -1}\n    assert candidate([[0,1], [1,2], [2,3], [3,4], [4,5]], [5], 0.2) == {0: 5, 1: 4, 2: 3, 3: 2, 4: 1, 5: 0}\n    assert candidate([[0,1], [1,2], [2,0]], [1], 1.0) == {0: -1, 1: 0, 2: -1}\n    assert candidate([[0,1], [1,2], [2,3], [3,4], [4,0]], [], 0.5) == {0: -1, 1: -1, 2: -1, 3: -1, 4: -1}\n    assert candidate([[0,1]], [0], 0.1) == {0: 0, 1: 1}\n    assert candidate([[0,1], [1,2], [2,3], [3,4], [4,5], [5,0]], [0, 3], 0.3) == {0: 0, 1: 1, 2: 1, 3: 0, 4: 1, 5: 1}\n    assert candidate([[0,1], [1,2], [2,3], [3,4], [4,0]], [2], 0.4) == {0: 2, 1: 1, 2: 0, 3: 1, 4: 2}\n", "language": "python"}
{"task_id": "revision1a_problem139", "prompt": "import random\nfrom typing import List\n\ndef stock_simulator(transactions: List[List[str]]) -> float:\n    \"\"\"\n    You're developing a stock market simulator game. Players can buy, sell, or check the price of stocks.\n    Write a function that processes a list of transactions and returns the final portfolio value.\n    \n    Each transaction is a list containing the action ('buy', 'sell', or 'price'), stock symbol, and quantity (for buy/sell) or None (for price check).\n    The function should generate random price fluctuations between transactions.\n    \n    Start with an initial balance of $10,000. Buy transactions deduct from the balance, sell transactions add to it.\n    If a player tries to buy more than they can afford or sell more than they own, skip the transaction.\n    \n    Return the final portfolio value (cash balance + value of owned stocks) rounded to 2 decimal places.\n    \n    Example:\n    Input: [['buy', 'AAPL', 10], ['price', 'AAPL', None], ['sell', 'AAPL', 5], ['buy', 'GOOGL', 2]]\n    Output: 10254.32\n    \"\"\"\n", "entry_point": "stock_simulator", "solution": "    balance = 10000\n    portfolio = {}\n    stock_prices = {}\n\n    def generate_price(symbol):\n        if symbol not in stock_prices:\n            stock_prices[symbol] = random.uniform(50, 500)\n        else:\n            current_price = stock_prices[symbol]\n            fluctuation = random.uniform(-0.05, 0.05)  # 5% max fluctuation\n            new_price = current_price * (1 + fluctuation)\n            stock_prices[symbol] = max(0.01, new_price)  # Ensure price doesn't go negative\n        return stock_prices[symbol]\n\n    for action, symbol, quantity in transactions:\n        price = generate_price(symbol)\n        \n        if action == 'buy':\n            cost = price * quantity\n            if cost <= balance:\n                balance -= cost\n                portfolio[symbol] = portfolio.get(symbol, 0) + quantity\n            # If cost > balance, skip the transaction\n        \n        elif action == 'sell':\n            if symbol in portfolio and portfolio[symbol] >= quantity:\n                balance += price * quantity\n                portfolio[symbol] -= quantity\n                if portfolio[symbol] == 0:\n                    del portfolio[symbol]\n            # If not enough stocks owned, skip the transaction\n        \n        # For 'price' action, we don't need to do anything as we've already updated the price\n\n    # Calculate final portfolio value\n    portfolio_value = balance\n    for symbol, quantity in portfolio.items():\n        portfolio_value += stock_prices[symbol] * quantity\n\n    return round(portfolio_value, 2)\n", "test": "def check(candidate):\n    assert candidate([['buy', 'AAPL', 1000000]]) == 10000\n    assert candidate([['price', 'FB', None], ['price', 'AMZN', None], ['price', 'AAPL', None]]) == 10000\n", "language": "python"}
{"task_id": "revision1a_problem38", "prompt": "import math\nfrom typing import List, Tuple\nimport heapq\n\ndef optimize_delivery_route(n: int, warehouse: Tuple[int, int], customers: List[Tuple[int, int]]) -> List[int]:\n    \"\"\"\n    A delivery company wants to optimize their route for a fleet of drones. Given a 2D grid representing a city,\n    find the optimal order to visit all customers starting from the warehouse location.\n    \n    The city is represented as an n x n grid where the warehouse and customers are located at specific coordinates.\n    The drone can move horizontally, vertically, or diagonally to adjacent cells.\n    \n    Take input from the user for the size of the grid (n), the warehouse location, and a list of customer locations.\n    Return the optimal order to visit customers as a list of indices (0-based) from the input customer list.\n    \n    Example:\n    Input: 5, (0, 0), [(1, 2), (3, 1), (4, 4), (2, 3)]\n    Output: [0, 3, 1, 2]\n    \n    This problem involves graph theory, pathfinding algorithms (like A* or Dijkstra's), and optimization techniques.\n    \"\"\"\n", "entry_point": "optimize_delivery_route", "solution": "    def distance(p1: Tuple[int, int], p2: Tuple[int, int]) -> float:\n        return math.sqrt((p1[0] - p2[0])**2 + (p1[1] - p2[1])**2)\n\n    def nearest_neighbor(start: Tuple[int, int], unvisited: List[Tuple[int, int]]) -> Tuple[int, Tuple[int, int]]:\n        distances = [(i, distance(start, customer)) for i, customer in enumerate(unvisited)]\n        return min(distances, key=lambda x: x[1])\n\n    route = []\n    unvisited = customers.copy()\n    current = warehouse\n\n    while unvisited:\n        index, _ = nearest_neighbor(current, unvisited)\n        route.append(customers.index(unvisited[index]))\n        current = unvisited.pop(index)\n\n    return route\n\n", "test": "def check(candidate):\n    assert candidate(4, (0, 0), [(1, 1), (2, 2), (3, 3)]) == [0, 1, 2]\n    assert candidate(9, (4, 4), [(0, 0), (8, 8), (0, 8), (8, 0), (2, 6), (6, 2)]) == [4, 2, 0, 5, 3, 1]\n    assert candidate(5, (0, 0), [(1, 2), (3, 1), (4, 4), (2, 3)]) == [0, 3, 1, 2]\n    assert candidate(5, (2, 2), [(0, 0), (4, 4), (0, 4), (4, 0)]) == [0, 2, 1, 3]\n    assert candidate(3, (1, 1), [(0, 0), (2, 2), (0, 2), (2, 0)]) == [0, 2, 1, 3]\n    assert candidate(7, (3, 3), [(0, 0), (6, 6), (1, 5), (5, 1), (2, 2)]) == [4, 0, 2, 1, 3]\n    assert candidate(8, (7, 7), [(0, 0), (1, 1), (2, 2), (3, 3), (4, 4), (5, 5), (6, 6)]) == [6, 5, 4, 3, 2, 1, 0]\n    assert candidate(6, (2, 2), [(0, 0), (5, 5), (3, 3), (1, 4), (4, 1)]) == [2, 3, 0, 4, 1]\n    assert candidate(3, (0, 0), [(1, 1), (2, 2)]) == [0, 1]\n    assert candidate(10, (5, 5), [(0, 0), (9, 9), (3, 7), (6, 2)]) == [2, 3, 0, 1]\n", "language": "python"}
{"task_id": "revision1a_problem81", "prompt": "import itertools\nfrom typing import List, Tuple\n\ndef network_reliability(nodes: int, connections: List[Tuple[int, int, float]]) -> float:\n    \"\"\"\n    We are analyzing the reliability of a computer network.\n    The network consists of nodes (computers) connected by edges (network links).\n    Each link has a reliability score between 0 and 1, where 1 is perfectly reliable.\n    The overall network reliability is defined as the probability that all nodes can communicate with each other.\n\n    Your task is to calculate the overall reliability of the network.\n\n    Parameters:\n    nodes (int): The number of nodes in the network\n    connections (List[Tuple[int, int, float]]): A list of tuples, each containing (node1, node2, reliability)\n\n    Returns:\n    float: The overall reliability of the network\n\n    Example 1:\n    Input: \n    nodes = 3\n    connections = [(0, 1, 0.9), (1, 2, 0.8), (0, 2, 0.7)]\n    Output: 0.972\n\n    Example 2:\n    Input:\n    nodes = 4\n    connections = [(0, 1, 0.95), (1, 2, 0.9), (2, 3, 0.85), (0, 3, 0.8)]\n    Output: 0.9265\n    \"\"\"\n", "entry_point": "network_reliability", "solution": "    def is_connected(graph):\n        visited = set()\n        def dfs(node):\n            visited.add(node)\n            for neighbor in graph[node]:\n                if neighbor not in visited:\n                    dfs(neighbor)\n        \n        dfs(0)\n        return len(visited) == nodes\n\n    def calculate_probability(state):\n        prob = 1\n        for i, connection in enumerate(connections):\n            if state[i]:\n                prob *= connection[2]\n            else:\n                prob *= (1 - connection[2])\n        return prob\n\n    graph = {i: set() for i in range(nodes)}\n    for connection in connections:\n        graph[connection[0]].add(connection[1])\n        graph[connection[1]].add(connection[0])\n\n    total_probability = 0\n    for state in itertools.product([True, False], repeat=len(connections)):\n        current_graph = {i: set() for i in range(nodes)}\n        for i, connection in enumerate(connections):\n            if state[i]:\n                current_graph[connection[0]].add(connection[1])\n                current_graph[connection[1]].add(connection[0])\n        \n        if is_connected(current_graph):\n            total_probability += calculate_probability(state)\n\n    return total_probability\n", "test": "def check(candidate):\n    assert candidate(5, [(0, 1, 1.0), (1, 2, 1.0), (2, 3, 1.0), (3, 4, 1.0), (4, 0, 1.0)]) == 1.0\n    assert candidate(4, [(0, 1, 0.95), (1, 2, 0.9), (2, 3, 0.85), (0, 3, 0.8)]) == 0.9245500000000001\n    assert candidate(6, [(0, 1, 0.8), (1, 2, 0.8), (2, 3, 0.8), (3, 4, 0.8), (4, 5, 0.8), (5, 0, 0.8)]) == 0.6553600000000003\n    assert candidate(3, [(0, 1, 0.5), (1, 2, 0.5), (0, 2, 0.5)]) == 0.5\n    assert candidate(3, [(0, 1, 0.1), (1, 2, 0.1), (0, 2, 0.1)]) == 0.028000000000000004\n    assert candidate(4, [(0, 1, 0.99), (1, 2, 0.99), (2, 3, 0.99), (3, 0, 0.99)]) == 0.9994079699999998\n    assert candidate(5, [(0, 1, 0.9), (1, 2, 0.8), (2, 3, 0.7), (3, 4, 0.6), (0, 4, 0.5)]) == 0.5226000000000001\n    assert candidate(4, [(0, 1, 0.75), (1, 2, 0.75), (2, 3, 0.75), (3, 0, 0.75), (0, 2, 0.75), (1, 3, 0.75)]) == 0.93603515625\n    assert candidate(2, [(0, 1, 1.0)]) == 1.0\n    assert candidate(3, [(0, 1, 0.9), (1, 2, 0.8), (0, 2, 0.7)]) == 0.902\n", "language": "python"}
{"task_id": "revision1a_problem418", "prompt": "from functools import lru_cache\nfrom itertools import permutations\nimport itertools\nfrom typing import List, Tuple\n\ndef optimize_delivery_route(cities: int, distances: List[List[int]], packages: List[Tuple[int, int]]) -> int:\n    \"\"\"\n    You are a logistics manager for a delivery company operating in N cities numbered from 1 to N. \n    You have a 2D array 'distances' where distances[i][j] represents the distance between city i and city j. \n    You also have a list of packages to deliver, where each package is represented by a tuple (origin, destination).\n    Your task is to find the most efficient route to deliver all packages while minimizing the total distance traveled.\n\n    Parameters:\n    - cities (int): The number of cities in your network\n    - distances (List[List[int]]): A 2D array representing distances between cities\n    - packages (List[Tuple[int, int]]): A list of packages, each represented as (origin, destination)\n\n    Returns:\n    - int: The minimum total distance required to deliver all packages\n\n    Example:\n    Input: 4, [[0,10,15,20],[10,0,35,25],[15,35,0,30],[20,25,30,0]], [(1,3), (2,4), (3,2)]\n    Output: 80\n\n    Explanation: The optimal route might be: 1 -> 3 (15) -> 2 (35) -> 4 (25) -> 1 (20), total distance = 95\n    \"\"\"\n", "entry_point": "optimize_delivery_route", "solution": "    def calculate_route_distance(route):\n        total_distance = 0\n        current_city = 1  # Start from city 1\n        for city in route:\n            total_distance += distances[current_city - 1][city - 1]\n            current_city = city\n        total_distance += distances[current_city - 1][0]  # Return to city 1\n        return total_distance\n\n    # Extract all unique cities from packages\n    unique_cities = set()\n    for origin, destination in packages:\n        unique_cities.add(origin)\n        unique_cities.add(destination)\n    \n    # Generate all possible permutations of cities to visit\n    all_routes = permutations(unique_cities)\n    \n    min_distance = float('inf')\n    for route in all_routes:\n        distance = calculate_route_distance(route)\n        min_distance = min(min_distance, distance)\n    \n    return min_distance\n", "test": "def check(candidate):\n    assert candidate(2, [[0, 10], [10, 0]], [(1, 2)]) == 20\n    assert candidate(4, [[0, 10, 15, 20], [10, 0, 35, 25], [15, 35, 0, 30], [20, 25, 30, 0]], [(1, 3), (2, 4), (3, 2)]) == 80\n    assert candidate(5, [[0, 10, 20, 30, 40], [10, 0, 15, 25, 35], [20, 15, 0, 10, 20], [30, 25, 10, 0, 15], [40, 35, 20, 15, 0]], [(1, 5), (3, 2), (4, 1)]) == 90\n    assert candidate(5, [[0, 10, 20, 30, 40], [10, 0, 15, 25, 35], [20, 15, 0, 10, 20], [30, 25, 10, 0, 15], [40, 35, 20, 15, 0]], [(1, 2), (2, 3), (3, 4), (4, 5), (5, 1)]) == 90\n    assert candidate(3, [[0, 100, 200], [100, 0, 50], [200, 50, 0]], [(1, 2), (2, 3), (3, 1)]) == 350\n    assert candidate(2, [[0, 1000], [1000, 0]], [(1, 2), (2, 1)]) == 2000\n    assert candidate(3, [[0, 5, 10], [5, 0, 15], [10, 15, 0]], [(1, 2), (2, 3)]) == 30\n    assert candidate(4, [[0, 1, 1, 1], [1, 0, 1, 1], [1, 1, 0, 1], [1, 1, 1, 0]], [(1, 2), (2, 3), (3, 4), (4, 1)]) == 4\n    assert candidate(3, [[0, 5, 5], [5, 0, 5], [5, 5, 0]], [(1, 2), (1, 3), (2, 3)]) == 15\n    assert candidate(4, [[0, 10, 20, 30], [10, 0, 15, 25], [20, 15, 0, 10], [30, 25, 10, 0]], [(1, 4), (4, 2), (2, 3), (3, 1)]) == 65\n", "language": "python"}
{"task_id": "revision1a_problem613", "prompt": "import datetime\n\ndef next_leap_year(year: int) -> tuple:\n    \"\"\"\n    As part of a calendar application, you need to implement a function that finds the next leap year.\n    A leap year is divisible by 4, but century years are leap years only if they are perfectly divisible by 400.\n\n    Take the current year as input from the user.\n    Use a while loop to find the next leap year.\n    Calculate and return a tuple containing:\n    1. The next leap year\n    2. The number of days until the next leap year\n    3. The day of the week (0-6, where 0 is Monday) on which January 1st of the next leap year falls\n\n    Use the datetime module to perform date calculations.\n\n    Example 1: If input is 2023, return (2024, 366, 1)\n    Explanation: 2024 is the next leap year, it's 366 days away, and January 1st, 2024 is a Monday (1)\n\n    Example 2: If input is 2100, return (2104, 1461, 4)\n    Explanation: 2100 is not a leap year (century year not divisible by 400), so the next leap year is 2104\n    \"\"\"\n", "entry_point": "next_leap_year", "solution": "    def is_leap_year(y):\n        return y % 4 == 0 and (y % 100 != 0 or y % 400 == 0)\n\n    current_date = datetime.date(year, 1, 1)\n    next_year = year + 1\n\n    while not is_leap_year(next_year):\n        next_year += 1\n\n    next_leap_date = datetime.date(next_year, 1, 1)\n    days_until = (next_leap_date - current_date).days\n    day_of_week = next_leap_date.weekday()\n\n    return (next_year, days_until, day_of_week)\n", "test": "def check(candidate):\n    assert candidate(2000) == (2004, 1461, 3)\n    assert candidate(1999) == (2000, 365, 5)\n    assert candidate(2020) == (2024, 1461, 0)\n    assert candidate(2300) == (2304, 1460, 4)\n    assert candidate(2200) == (2204, 1460, 6)\n    assert candidate(2400) == (2404, 1461, 3)\n    assert candidate(2100) == (2104, 1460, 1)\n    assert candidate(2023) == (2024, 365, 0)\n    assert candidate(2022) == (2024, 730, 0)\n    assert candidate(2024) == (2028, 1461, 5)\n", "language": "python"}
{"task_id": "revision1a_problem501", "prompt": "from itertools import permutations\nimport itertools\nfrom typing import List, Tuple\n\ndef optimize_delivery_route(n: int, distances: List[Tuple[int, int, int]]) -> List[int]:\n    \"\"\"\n    As a logistics manager, you need to optimize the delivery route for a courier. \n    You are given the number of locations (n) and a list of tuples representing the distances between locations.\n    Each tuple contains (start_location, end_location, distance).\n    Your task is to find the shortest path that visits all locations exactly once and returns to the starting point (location 0).\n    \n    Take input from the user for the number of locations and the list of distances, and return the optimal route as a list of location indices.\n    \n    Example:\n    Input: 4, [(0,1,10), (0,2,15), (0,3,20), (1,2,35), (1,3,25), (2,3,30)]\n    Output: [0, 1, 3, 2, 0]\n    \n    Input: 3, [(0,1,10), (0,2,15), (1,2,20)]\n    Output: [0, 1, 2, 0]\n    \"\"\"\n", "entry_point": "optimize_delivery_route", "solution": "    def get_distance(start: int, end: int) -> int:\n        for s, e, d in distances:\n            if (s == start and e == end) or (s == end and e == start):\n                return d\n        return float('inf')\n\n    def calculate_total_distance(route: List[int]) -> int:\n        total_distance = 0\n        for i in range(len(route) - 1):\n            total_distance += get_distance(route[i], route[i + 1])\n        return total_distance\n\n    locations = list(range(1, n))\n    shortest_route = None\n    shortest_distance = float('inf')\n\n    for perm in permutations(locations):\n        route = [0] + list(perm) + [0]\n        distance = calculate_total_distance(route)\n        if distance < shortest_distance:\n            shortest_distance = distance\n            shortest_route = route\n\n    return shortest_route\n", "test": "def check(candidate):\n    assert candidate(5, [(0,1,10), (1,2,20), (2,3,30), (3,4,40), (4,0,50)]) == [0, 1, 2, 3, 4, 0]\n    assert candidate(6, [(0,1,10), (0,2,20), (0,3,30), (0,4,40), (0,5,50), (1,2,15), (1,3,25), (1,4,35), (1,5,45), (2,3,5), (2,4,15), (2,5,25), (3,4,10), (3,5,20), (4,5,30)]) == [0, 1, 2, 3, 4, 5, 0]\n    assert candidate(4, [(0,1,10), (0,2,20), (0,3,30), (1,2,40), (1,3,50), (2,3,60)]) == [0, 1, 2, 3, 0]\n    assert candidate(4, [(0,1,1), (0,2,1), (0,3,1), (1,2,1), (1,3,1), (2,3,1)]) == [0, 1, 2, 3, 0]\n    assert candidate(3, [(0,1,10), (0,2,15), (1,2,20)]) == [0, 1, 2, 0]\n    assert candidate(3, [(0,1,100), (0,2,200), (1,2,50)]) == [0, 1, 2, 0]\n    assert candidate(3, [(0,1,1), (1,2,1), (2,0,1)]) == [0, 1, 2, 0]\n    assert candidate(2, [(0,1,10)]) == [0, 1, 0]\n    assert candidate(4, [(0,1,10), (0,2,15), (0,3,20), (1,2,35), (1,3,25), (2,3,30)]) == [0, 1, 3, 2, 0]\n    assert candidate(5, [(0,1,10), (0,2,15), (0,3,20), (0,4,25), (1,2,30), (1,3,35), (1,4,40), (2,3,45), (2,4,50), (3,4,55)]) == [0, 2, 1, 3, 4, 0]\n", "language": "python"}
{"task_id": "revision1a_problem439", "prompt": "from typing import List, Tuple\n\ndef schedule_tasks(tasks: List[Tuple[int, int, int]]) -> List[int]:\n    \"\"\"\n    You are developing a task scheduling system for a multi-core processor. \n    Each task is represented by a tuple (start_time, duration, core_requirement).\n\n    Implement a function that takes a list of tasks and returns a list of core allocations. \n    The goal is to maximize processor utilization while ensuring that:\n    1. No task starts before its start_time\n    2. Each task runs for its entire duration without interruption\n    3. At any given time, the sum of core_requirements for running tasks doesn't exceed the total number of cores (assumed to be 8)\n\n    The function should return a list where the i-th element represents the core allocation for the i-th task. \n    If a task cannot be scheduled, its allocation should be -1.\n\n    Example:\n    Input: [(0, 3, 2), (1, 4, 3), (3, 2, 1), (4, 1, 4), (5, 2, 2)]\n    Output: [0, 2, 5, -1, 0]\n\n    Explanation:\n    - Task 0 starts at time 0, uses 2 cores (0-1) for 3 time units\n    - Task 1 starts at time 1, uses 3 cores (2-4) for 4 time units\n    - Task 2 starts at time 3, uses 1 core (5) for 2 time units\n    - Task 3 cannot be scheduled (not enough free cores at time 4)\n    - Task 4 starts at time 5, uses 2 cores (0-1) for 2 time units\n    \"\"\"\n", "entry_point": "schedule_tasks", "solution": "    total_cores = 8\n    core_usage = [0] * total_cores\n    end_times = [0] * total_cores\n    allocations = [-1] * len(tasks)\n\n    def can_allocate(start_time, duration, core_requirement):\n        free_cores = []\n        for core in range(total_cores):\n            if end_times[core] <= start_time:\n                free_cores.append(core)\n            if len(free_cores) == core_requirement:\n                return free_cores\n        return []\n\n    sorted_tasks = sorted(enumerate(tasks), key=lambda x: x[1][0])\n\n    for index, (start_time, duration, core_requirement) in sorted_tasks:\n        allocated_cores = can_allocate(start_time, duration, core_requirement)\n        if allocated_cores:\n            allocations[index] = allocated_cores[0]\n            for core in allocated_cores:\n                end_times[core] = start_time + duration\n\n    return allocations\n", "test": "def check(candidate):\n    assert candidate([]) == []\n    assert candidate([(0, 10, 1), (1, 9, 1), (2, 8, 1), (3, 7, 1), (4, 6, 1), (5, 5, 1), (6, 4, 1), (7, 3, 1)]) == [0, 1, 2, 3, 4, 5, 6, 7]\n    assert candidate([(0, 5, 8), (1, 3, 4), (2, 2, 2), (3, 1, 1)]) == [0, -1, -1, -1]\n    assert candidate([(0, 1, 1), (0, 1, 1), (0, 1, 1), (0, 1, 1), (0, 1, 1), (0, 1, 1), (0, 1, 1), (0, 1, 1)]) == [0, 1, 2, 3, 4, 5, 6, 7]\n    assert candidate([(0, 1, 1)]) == [0]\n    assert candidate([(0, 3, 2), (1, 4, 3), (3, 2, 1), (4, 1, 4), (5, 2, 2)]) == [0, 2, 0, 1, 0]\n    assert candidate([(0, 100, 1), (0, 100, 1), (0, 100, 1), (0, 100, 1), (0, 100, 1), (0, 100, 1), (0, 100, 1), (0, 100, 1)]) == [0, 1, 2, 3, 4, 5, 6, 7]\n    assert candidate([(0, 1, 8), (1, 1, 8), (2, 1, 8)]) == [0, 0, 0]\n    assert candidate([(i, 1, 1) for i in range(20)]) == [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]\n    assert candidate([(0, 5, 4), (0, 5, 4)]) == [0, 4]\n", "language": "python"}
{"task_id": "revision1a_problem372", "prompt": "from typing import List, Tuple\n\ndef schedule_tasks(tasks: List[Tuple[int, int, int]]) -> List[int]:\n    \"\"\"\n    As a project manager, you're given a list of tasks to schedule. Each task has a start time, \n    end time, and a priority value. Your goal is to schedule as many high-priority tasks as possible \n    without any overlaps.\n    \n    Use a greedy algorithm approach to solve this problem efficiently. The function should take a list \n    of tasks (where each task is a tuple of (start_time, end_time, priority)) and return a list of \n    indices of the tasks that should be scheduled, in the order they should be executed.\n    \n    Expected Time Complexity: O(n log n), where n is the number of tasks.\n    \n    Example:\n    Input: [(1,4,3), (2,5,4), (3,6,5), (5,7,2), (6,8,1)]\n    Output: [2, 3]  # Schedule tasks with index 2 and 3\n    \n    Input: [(1,3,5), (2,4,3), (3,5,1), (4,6,2), (5,7,4)]\n    Output: [0, 4]  # Schedule tasks with index 0 and 4\n    \"\"\"\n", "entry_point": "schedule_tasks", "solution": "    # Sort tasks based on priority (highest to lowest) and then by end time (earliest to latest)\n    sorted_tasks = sorted(enumerate(tasks), key=lambda x: (-x[1][2], x[1][1]))\n    \n    scheduled = []\n    last_end_time = 0\n    \n    for index, (start_time, end_time, priority) in sorted_tasks:\n        if start_time >= last_end_time:\n            scheduled.append(index)\n            last_end_time = end_time\n    \n    # Sort scheduled tasks by start time to return them in execution order\n    return sorted(scheduled, key=lambda x: tasks[x][0])\n", "test": "def check(candidate):\n    assert candidate([(1, 3, 5), (2, 4, 3), (3, 5, 1), (4, 6, 2), (5, 7, 4)]) == [0, 4]\n    assert candidate([(1, 2, 5), (2, 3, 5), (3, 4, 5), (4, 5, 5), (5, 6, 5)]) == [0, 1, 2, 3, 4]\n    assert candidate([(1, 5, 1), (2, 6, 2), (3, 7, 3), (4, 8, 4), (5, 9, 5)]) == [4]\n    assert candidate([(1, 2, 1), (1, 3, 2), (1, 4, 3), (1, 5, 4), (1, 6, 5)]) == [4]\n    assert candidate([(1, 10, 1), (2, 3, 5), (4, 5, 4), (6, 7, 3), (8, 9, 2)]) == [1, 2, 3, 4]\n    assert candidate([(1, 5, 10), (1, 5, 20), (1, 5, 30), (6, 10, 40), (6, 10, 50)]) == [4]\n    assert candidate([(1, 100, 1), (2, 3, 100), (4, 5, 100), (6, 7, 100), (8, 9, 100)]) == [1, 2, 3, 4]\n    assert candidate([(1, 2, 1), (2, 3, 2), (3, 4, 3), (4, 5, 4), (5, 6, 5)]) == [4]\n    assert candidate([(1, 4, 3), (2, 5, 4), (3, 6, 5), (5, 7, 2), (6, 8, 1)]) == [2, 4]\n    assert candidate([(1, 3, 3), (2, 4, 2), (3, 5, 1), (4, 6, 4), (5, 7, 5)]) == [4]\n", "language": "python"}
{"task_id": "revision1a_problem290", "prompt": "from typing import List\nimport math\n\ndef optimize_delivery_route(packages: List[tuple]) -> List[int]:\n    \"\"\"\n    You are a delivery driver for an e-commerce company, and you need to optimize your delivery route.\n    Given a list of tuples representing packages, where each tuple contains (package_id, x_coordinate, y_coordinate),\n    find the optimal order to deliver the packages to minimize the total distance traveled.\n    Use the nearest neighbor algorithm to solve this problem.\n    Take the list of package tuples as input and return the optimal order of package_ids for delivery.\n\n    Example:\n    Input: [(1, 0, 0), (2, 3, 4), (3, 1, 2), (4, 5, 1)]\n    Output: [1, 3, 2, 4]\n\n    Input: [(1, 2, 3), (2, 5, 1), (3, 1, 7), (4, 3, 3), (5, 6, 4)]\n    Output: [1, 4, 2, 5, 3]\n    \"\"\"\n", "entry_point": "optimize_delivery_route", "solution": "    def distance(p1, p2):\n        return math.sqrt((p1[1] - p2[1])**2 + (p1[2] - p2[2])**2)\n\n    unvisited = packages.copy()\n    current = unvisited.pop(0)  # Start from the first package\n    optimal_route = [current[0]]\n\n    while unvisited:\n        nearest = min(unvisited, key=lambda x: distance(current, x))\n        optimal_route.append(nearest[0])\n        current = nearest\n        unvisited.remove(nearest)\n\n    return optimal_route\n", "test": "def check(candidate):\n    assert candidate([(1, 10, 10), (2, 20, 20), (3, 30, 30), (4, 40, 40), (5, 50, 50)]) == [1, 2, 3, 4, 5]\n    assert candidate([(1, 0, 0)]) == [1]\n    assert candidate([(1, 0, 0), (2, 3, 4), (3, 1, 2), (4, 5, 1)]) == [1, 3, 2, 4]\n    assert candidate([(1, 0, 0), (2, 0, 1), (3, 1, 0), (4, 1, 1)]) == [1, 2, 4, 3]\n    assert candidate([(1, 2, 3), (2, 5, 1), (3, 1, 7), (4, 3, 3), (5, 6, 4)]) == [1, 4, 2, 5, 3]\n    assert candidate([(1, 0, 0), (2, 100, 100), (3, 200, 200), (4, 300, 300)]) == [1, 2, 3, 4]\n    assert candidate([(1, 1, 1), (2, 2, 2), (3, 3, 3), (4, 4, 4), (5, 5, 5), (6, 6, 6)]) == [1, 2, 3, 4, 5, 6]\n    assert candidate([(1, -1, -1), (2, 1, 1), (3, -1, 1), (4, 1, -1)]) == [1, 3, 2, 4]\n    assert candidate([(1, 1, 1), (2, 2, 2)]) == [1, 2]\n    assert candidate([(1, 0, 0), (2, 0, 0), (3, 0, 0), (4, 0, 0)]) == [1, 2, 3, 4]\n", "language": "python"}
{"task_id": "revision1a_problem641", "prompt": "def decode_secret_message(encoded: str, key: str) -> str:\n    \"\"\"\n    You've intercepted an encoded message and its corresponding encryption key. Your task is to decode the message.\n    The encoding process works as follows:\n    1. Each character in the original message is replaced by another character according to the key.\n    2. The key is a string where even-indexed characters map to odd-indexed characters and vice versa.\n    3. If a character in the message isn't in the key, it remains unchanged.\n    4. The encoding is case-sensitive.\n\n    Write a program to decode the message given the encoded message and the key.\n    Take both the encoded message and the key as input from the user.\n\n    Example:\n    Input: Enter encoded message: Uifsf jt b tfdsfu nffujoh bu njeojhiu\n           Enter key: abcdefghijklmnopqrstuvwxyz\n    Output: There is a secret meeting at midnight\n\n    Input: Enter encoded message: Xn qnbm snbcc!\n           Enter key: XYZabcdefghijklmnopqrstuvw\n    Output: We love pizza!\n    \"\"\"\n", "entry_point": "decode_secret_message", "solution": "    # Create a decoding dictionary\n    decode_dict = {}\n    for i in range(0, len(key) - 1, 2):\n        decode_dict[key[i]] = key[i + 1]\n        decode_dict[key[i + 1]] = key[i]\n    \n    # Decode the message\n    decoded = []\n    for char in encoded:\n        if char in decode_dict:\n            decoded.append(decode_dict[char])\n        else:\n            decoded.append(char)\n    \n    return ''.join(decoded)\n", "test": "def check(candidate):\n    assert candidate(\"Hello, World!\", \"\") == 'Hello, World!'\n    assert candidate(\"Uijt jt b uftu.\", \"abcdefghijklmnopqrstuvwxyz\") == 'Ujis is a vesv.'\n    assert candidate(\"!@#$%^&*()\", \"abcdefghijklmnopqrstuvwxyz\") == '!@#$%^&*()'\n    assert candidate(\"Uifsf jt b tfdsfu nffujoh bu njeojhiu\", \"abcdefghijklmnopqrstuvwxyz\") == 'Ujete is a sectev meevipg av mifpigjv'\n    assert candidate(\"Xn qnbm snbcc!\", \"XYZabcdefghijklmnopqrstuvw\") == 'Yo pocl rocbb!'\n    assert candidate(\"\", \"abcdefghijklmnopqrstuvwxyz\") == ''\n    assert candidate(\"lower case\", \"abcdefghijklmnopqrstuvwxyz\") == 'kpxfq dbtf'\n    assert candidate(\"MiXeD CaSe\", \"AbCdEfGhIjKlMnOpQrStUvWxYz\") == 'niXeD date'\n    assert candidate(\"UPPER CASE\", \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\") == 'VOOFQ DBTF'\n    assert candidate(\"123 456 789\", \"abcdefghijklmnopqrstuvwxyz\") == '123 456 789'\n", "language": "python"}
{"task_id": "revision1a_problem237", "prompt": "from typing import List, Tuple\nimport math\n\ndef optimize_delivery_route(locations: List[Tuple[float, float]], start: Tuple[float, float]) -> List[Tuple[float, float]]:\n    \"\"\"\n    A food delivery service wants to optimize their delivery route to minimize travel time.\n    Given a list of delivery locations (as latitude-longitude pairs) and a starting point,\n    find the optimal route that visits all locations exactly once and returns to the start.\n\n    This is known as the Traveling Salesman Problem (TSP). Implement a solution using\n    dynamic programming or a heuristic algorithm like nearest neighbor or 2-opt.\n\n    Input: \n    - locations: List of tuples representing (latitude, longitude) of delivery points\n    - start: Tuple representing (latitude, longitude) of the starting point\n\n    Output: \n    - Optimized list of locations in the order they should be visited\n\n    Example:\n    Input: \n    locations = [(40.7128, -74.0060), (34.0522, -118.2437), (41.8781, -87.6298)]\n    start = (37.7749, -122.4194)\n\n    Output:\n    [(37.7749, -122.4194), (34.0522, -118.2437), (41.8781, -87.6298), \n     (40.7128, -74.0060), (37.7749, -122.4194)]\n\n    Note: The actual optimal route may vary depending on the specific algorithm used.\n    \"\"\"\n", "entry_point": "optimize_delivery_route", "solution": "    def haversine_distance(point1: Tuple[float, float], point2: Tuple[float, float]) -> float:\n        \"\"\"Calculate the great circle distance between two points on the earth.\"\"\"\n        lat1, lon1 = point1\n        lat2, lon2 = point2\n        \n        # Convert decimal degrees to radians\n        lat1, lon1, lat2, lon2 = map(math.radians, [lat1, lon1, lat2, lon2])\n        \n        # Haversine formula\n        dlat = lat2 - lat1\n        dlon = lon2 - lon1\n        a = math.sin(dlat/2)**2 + math.cos(lat1) * math.cos(lat2) * math.sin(dlon/2)**2\n        c = 2 * math.asin(math.sqrt(a))\n        r = 6371  # Radius of earth in kilometers\n        return c * r\n\n    def nearest_neighbor(current: Tuple[float, float], unvisited: List[Tuple[float, float]]) -> Tuple[float, float]:\n        \"\"\"Find the nearest unvisited location.\"\"\"\n        return min(unvisited, key=lambda x: haversine_distance(current, x))\n\n    # Initialize the route with the starting point\n    route = [start]\n    unvisited = locations.copy()\n\n    # Find the nearest neighbor for each point\n    current = start\n    while unvisited:\n        next_point = nearest_neighbor(current, unvisited)\n        route.append(next_point)\n        unvisited.remove(next_point)\n        current = next_point\n\n    # Return to the starting point\n    route.append(start)\n\n    return route\n", "test": "def check(candidate):\n    assert candidate([(-90.0, -180.0), (90.0, 180.0)], (0.0, 0.0)) == [(0.0, 0.0), (-90.0, -180.0), (90.0, 180.0), (0.0, 0.0)]\n    assert candidate([(x, x) for x in range(10)], (0.0, 0.0)) == [(0.0, 0.0), (0, 0), (1, 1), (2, 2), (3, 3), (4, 4), (5, 5), (6, 6), (7, 7), (8, 8), (9, 9), (0.0, 0.0)]\n    assert candidate([(0.0, 0.0), (1.0, 1.0), (2.0, 2.0), (3.0, 3.0), (4.0, 4.0)], (0.0, 0.0)) == [(0.0, 0.0), (0.0, 0.0), (1.0, 1.0), (2.0, 2.0), (3.0, 3.0), (4.0, 4.0), (0.0, 0.0)]\n    assert candidate([(0.0, 0.0)] * 5, (1.0, 1.0)) == [(1.0, 1.0), (0.0, 0.0), (0.0, 0.0), (0.0, 0.0), (0.0, 0.0), (0.0, 0.0), (1.0, 1.0)]\n    assert candidate([(1.0, 1.0)], (0.0, 0.0)) == [(0.0, 0.0), (1.0, 1.0), (0.0, 0.0)]\n    assert candidate([(0.0001, 0.0001), (0.0002, 0.0002), (0.0003, 0.0003)], (0.0, 0.0)) == [(0.0, 0.0), (0.0001, 0.0001), (0.0002, 0.0002), (0.0003, 0.0003), (0.0, 0.0)]\n    assert candidate([(0.0, 0.0), (0.0, 1.0), (1.0, 0.0), (1.0, 1.0)], (0.5, 0.5)) == [(0.5, 0.5), (1.0, 0.0), (1.0, 1.0), (0.0, 1.0), (0.0, 0.0), (0.5, 0.5)]\n    assert candidate([(40.7128, -74.0060), (34.0522, -118.2437), (41.8781, -87.6298)], (37.7749, -122.4194)) == [(37.7749, -122.4194), (34.0522, -118.2437), (41.8781, -87.6298), (40.7128, -74.006), (37.7749, -122.4194)]\n    assert candidate([(90.0, 0.0), (0.0, 180.0), (-90.0, 0.0), (0.0, -180.0)], (0.0, 0.0)) == [(0.0, 0.0), (90.0, 0.0), (0.0, 180.0), (0.0, -180.0), (-90.0, 0.0), (0.0, 0.0)]\n    assert candidate([], (0.0, 0.0)) == [(0.0, 0.0), (0.0, 0.0)]\n", "language": "python"}
{"task_id": "revision1a_problem378", "prompt": "from typing import List, Dict\n\ndef inventory_management(items: List[List[str]]) -> Dict[str, Dict[str, int]]:\n    \"\"\"\n    You're managing a warehouse inventory system. Create a function that organizes items\n    by category and tracks their quantity and price.\n\n    The inventory should be a nested dictionary where:\n    - The outer key is the category of the item\n    - The inner dictionary contains item names as keys\n    - Each item has a dictionary with 'quantity' and 'price' as keys\n\n    Take input from the user for each item's details in the following format:\n    [category, item_name, quantity, price]\n\n    Example:\n    Input: [\n        ['Electronics', 'Laptop', '10', '1000'],\n        ['Clothing', 'T-shirt', '50', '20'],\n        ['Electronics', 'Smartphone', '20', '500'],\n        ['Clothing', 'Jeans', '30', '50']\n    ]\n    Output: {\n        'Electronics': {\n            'Laptop': {'quantity': 10, 'price': 1000},\n            'Smartphone': {'quantity': 20, 'price': 500}\n        },\n        'Clothing': {\n            'T-shirt': {'quantity': 50, 'price': 20},\n            'Jeans': {'quantity': 30, 'price': 50}\n        }\n    }\n    \"\"\"\n", "entry_point": "inventory_management", "solution": "    inventory = {}\n    \n    for item in items:\n        category, item_name, quantity, price = item\n        \n        if category not in inventory:\n            inventory[category] = {}\n        \n        inventory[category][item_name] = {\n            'quantity': int(quantity),\n            'price': int(price)\n        }\n    \n    return inventory\n", "test": "def check(candidate):\n    assert candidate([['Electronics', 'Laptop', '10', '1000'], ['Clothing', 'T-shirt', '50', '20'], ['Electronics', 'Smartphone', '20', '500'], ['Clothing', 'Jeans', '30', '50']]) == {'Electronics': {'Laptop': {'quantity': 10, 'price': 1000}, 'Smartphone': {'quantity': 20, 'price': 500}}, 'Clothing': {'T-shirt': {'quantity': 50, 'price': 20}, 'Jeans': {'quantity': 30, 'price': 50}}}\n    assert candidate([['Books', 'Novel', '100', '15'], ['Books', 'Textbook', '50', '80'], ['Stationery', 'Pen', '200', '2'], ['Stationery', 'Notebook', '150', '5']]) == {'Books': {'Novel': {'quantity': 100, 'price': 15}, 'Textbook': {'quantity': 50, 'price': 80}}, 'Stationery': {'Pen': {'quantity': 200, 'price': 2}, 'Notebook': {'quantity': 150, 'price': 5}}}\n    assert candidate([['Kitchen', 'Blender', '15', '80'], ['Kitchen', 'Toaster', '25', '40'], ['Kitchen', 'Coffee Maker', '20', '100']]) == {'Kitchen': {'Blender': {'quantity': 15, 'price': 80}, 'Toaster': {'quantity': 25, 'price': 40}, 'Coffee Maker': {'quantity': 20, 'price': 100}}}\n    assert candidate([['Sports', 'Basketball', '10', '30'], ['Sports', 'Tennis Racket', '15', '100'], ['Sports', 'Football', '20', '25']]) == {'Sports': {'Basketball': {'quantity': 10, 'price': 30}, 'Tennis Racket': {'quantity': 15, 'price': 100}, 'Football': {'quantity': 20, 'price': 25}}}\n    assert candidate([['Toys', 'Lego Set', '50', '50'], ['Toys', 'Doll', '100', '20'], ['Toys', 'Board Game', '30', '40']]) == {'Toys': {'Lego Set': {'quantity': 50, 'price': 50}, 'Doll': {'quantity': 100, 'price': 20}, 'Board Game': {'quantity': 30, 'price': 40}}}\n    assert candidate([['Gardening', 'Shovel', '30', '25'], ['Gardening', 'Plant Pot', '100', '10'], ['Gardening', 'Seeds', '500', '2']]) == {'Gardening': {'Shovel': {'quantity': 30, 'price': 25}, 'Plant Pot': {'quantity': 100, 'price': 10}, 'Seeds': {'quantity': 500, 'price': 2}}}\n    assert candidate([['Electronics', 'Headphones', '30', '100'], ['Electronics', 'Tablet', '15', '300'], ['Electronics', 'Smartwatch', '25', '200']]) == {'Electronics': {'Headphones': {'quantity': 30, 'price': 100}, 'Tablet': {'quantity': 15, 'price': 300}, 'Smartwatch': {'quantity': 25, 'price': 200}}}\n    assert candidate([['Food', 'Apple', '500', '1'], ['Food', 'Bread', '100', '3'], ['Beverages', 'Water', '1000', '1'], ['Beverages', 'Soda', '500', '2']]) == {'Food': {'Apple': {'quantity': 500, 'price': 1}, 'Bread': {'quantity': 100, 'price': 3}}, 'Beverages': {'Water': {'quantity': 1000, 'price': 1}, 'Soda': {'quantity': 500, 'price': 2}}}\n    assert candidate([['Beauty', 'Lipstick', '200', '15'], ['Beauty', 'Perfume', '50', '80'], ['Beauty', 'Face Cream', '100', '30']]) == {'Beauty': {'Lipstick': {'quantity': 200, 'price': 15}, 'Perfume': {'quantity': 50, 'price': 80}, 'Face Cream': {'quantity': 100, 'price': 30}}}\n", "language": "python"}
{"task_id": "revision1a_problem468", "prompt": "from typing import List, Tuple\n\ndef optimal_study_schedule(courses: List[Tuple[str, int, int]], hours_per_day: int) -> List[str]:\n    \"\"\"\n    Given a list of courses and available study hours per day, determine the optimal study schedule.\n    Each course is represented by a tuple (name, difficulty, time_to_complete).\n    The function should return a list of course names in the order they should be studied.\n    \n    The schedule should prioritize difficult courses early in the day and ensure all courses are completed.\n    Take input from the user for the number of courses, course details, and available study hours per day.\n    \n    Example:\n    Input: [(\"Math\", 5, 10), (\"History\", 3, 8), (\"Physics\", 4, 12)], 4\n    Output: [\"Math\", \"Physics\", \"History\"]\n    Input: [(\"English\", 2, 6), (\"Chemistry\", 5, 15), (\"Computer Science\", 4, 10)], 5\n    Output: [\"Chemistry\", \"Computer Science\", \"English\"]\n    \"\"\"\n", "entry_point": "optimal_study_schedule", "solution": "    def get_user_input():\n        num_courses = int(input(\"Enter the number of courses: \"))\n        courses = []\n        for i in range(num_courses):\n            name = input(f\"Enter name of course {i+1}: \")\n            difficulty = int(input(f\"Enter difficulty of course {i+1} (1-5): \"))\n            time_to_complete = int(input(f\"Enter time to complete course {i+1} (in hours): \"))\n            courses.append((name, difficulty, time_to_complete))\n        hours_per_day = int(input(\"Enter available study hours per day: \"))\n        return courses, hours_per_day\n\n    if not courses:\n        courses, hours_per_day = get_user_input()\n\n    # Sort courses by difficulty (descending) and then by time to complete (descending)\n    sorted_courses = sorted(courses, key=lambda x: (-x[1], -x[2]))\n\n    # Calculate total study time required\n    total_study_time = sum(course[2] for course in sorted_courses)\n\n    # Calculate number of days required to complete all courses\n    days_required = -(-total_study_time // hours_per_day)  # Ceiling division\n\n    # Create the optimal schedule\n    schedule = []\n    remaining_time = [hours_per_day] * days_required\n    \n    for course in sorted_courses:\n        course_name, _, course_time = course\n        days_needed = -(-course_time // hours_per_day)  # Ceiling division\n        \n        for day in range(days_required):\n            if remaining_time[day] > 0 and days_needed > 0:\n                schedule.append(course_name)\n                remaining_time[day] -= min(remaining_time[day], course_time)\n                course_time -= min(remaining_time[day], course_time)\n                days_needed -= 1\n            \n            if course_time <= 0:\n                break\n\n    return schedule\n", "test": "def check(candidate):\n    assert candidate([(\"Astronomy\", 4, 14), (\"Philosophy\", 3, 9), (\"Statistics\", 5, 16), (\"Geology\", 2, 7)], 6) == ['Statistics', 'Statistics', 'Statistics', 'Astronomy', 'Astronomy', 'Astronomy', 'Philosophy', 'Philosophy']\n    assert candidate([(\"Algebra\", 4, 10), (\"History\", 2, 8), (\"Biology\", 3, 12), (\"French\", 3, 9), (\"Art\", 1, 4)], 5) == ['Algebra', 'Algebra', 'Biology', 'Biology', 'Biology', 'French', 'French', 'History', 'History']\n    assert candidate([(\"Computer Science\", 5, 25), (\"English Literature\", 3, 15), (\"Physics\", 4, 20), (\"Psychology\", 2, 10)], 10) == ['Computer Science', 'Computer Science', 'Computer Science', 'Physics', 'Physics', 'English Literature', 'English Literature']\n    assert candidate([(\"English\", 2, 6), (\"Chemistry\", 5, 15), (\"Computer Science\", 4, 10)], 5) == ['Chemistry', 'Chemistry', 'Chemistry', 'Computer Science', 'Computer Science', 'English', 'English']\n    assert candidate([(\"Math\", 5, 10), (\"History\", 3, 8), (\"Physics\", 4, 12)], 4) == ['Math', 'Math', 'Math', 'Physics', 'Physics', 'Physics', 'History', 'History']\n    assert candidate([(\"Calculus\", 5, 20), (\"Literature\", 3, 10), (\"Programming\", 4, 15)], 8) == ['Calculus', 'Calculus', 'Calculus', 'Programming', 'Programming', 'Literature']\n    assert candidate([(\"Organic Chemistry\", 5, 30), (\"World History\", 3, 18), (\"Calculus II\", 4, 24)], 12) == ['Organic Chemistry', 'Organic Chemistry', 'Organic Chemistry', 'Calculus II', 'Calculus II', 'World History']\n    assert candidate([(\"Geometry\", 3, 7), (\"Spanish\", 2, 6), (\"Economics\", 4, 11)], 3) == ['Economics', 'Economics', 'Economics', 'Economics', 'Geometry', 'Geometry', 'Geometry', 'Spanish']\n    assert candidate([(\"Geography\", 2, 5), (\"Physics\", 5, 18), (\"Music\", 1, 3), (\"Chemistry\", 4, 12)], 7) == ['Physics', 'Physics', 'Physics', 'Chemistry', 'Chemistry', 'Geography', 'Music']\n    assert candidate([(\"Biology\", 3, 8), (\"Economics\", 4, 12), (\"Art\", 1, 4), (\"Psychology\", 2, 6)], 6) == ['Economics', 'Economics', 'Biology', 'Biology', 'Psychology']\n", "language": "python"}
{"task_id": "revision1a_problem578", "prompt": "import itertools\nfrom typing import List\n\ndef optimize_wind_farm(grid_size: int, turbines: int, wind_speeds: List[List[int]]) -> float:\n    \"\"\"\n    An energy company is planning to build a wind farm. They have a square grid of size N x N representing \n    potential turbine locations, and they want to place T turbines to maximize energy production.\n\n    Each cell in the grid has a wind speed value. However, when a turbine is placed in a cell, it reduces \n    the wind speed in the 8 adjacent cells by 1 (not going below 0).\n\n    Your task is to write a function that determines the maximum possible total wind speed for the placed turbines.\n\n    Take input from the user for the grid size (N), number of turbines to place (T), and the initial wind speeds for each cell.\n    Return the maximum possible total wind speed as a float.\n\n    Example 1:\n    Input: 3, 2, [[1,2,3], [4,5,6], [7,8,9]]\n    Output: 14.0\n\n    Example 2:\n    Input: 4, 3, [[3,3,3,3], [3,3,3,3], [3,3,3,3], [3,3,3,3]]\n    Output: 9.0\n\n    Note: The turbines do not affect each other's output, only the wind speeds of adjacent cells.\n    \"\"\"\n", "entry_point": "optimize_wind_farm", "solution": "    def calculate_total_wind_speed(turbine_positions):\n        total_wind_speed = 0\n        affected_cells = set()\n\n        for x, y in turbine_positions:\n            total_wind_speed += wind_speeds[x][y]\n            for dx in [-1, 0, 1]:\n                for dy in [-1, 0, 1]:\n                    nx, ny = x + dx, y + dy\n                    if 0 <= nx < grid_size and 0 <= ny < grid_size and (nx, ny) not in turbine_positions:\n                        affected_cells.add((nx, ny))\n\n        for x, y in affected_cells:\n            wind_speeds[x][y] = max(0, wind_speeds[x][y] - 1)\n\n        return total_wind_speed\n\n    all_positions = list(itertools.product(range(grid_size), repeat=2))\n    max_wind_speed = 0\n\n    for turbine_combination in itertools.combinations(all_positions, turbines):\n        wind_speeds_copy = [row[:] for row in wind_speeds]\n        current_wind_speed = calculate_total_wind_speed(turbine_combination)\n        max_wind_speed = max(max_wind_speed, current_wind_speed)\n        wind_speeds = wind_speeds_copy\n\n    return float(max_wind_speed)\n", "test": "def check(candidate):\n    assert candidate(3, 1, [[0,0,0], [0,1,0], [0,0,0]]) == 1.0\n    assert candidate(3, 3, [[5,5,5], [5,5,5], [5,5,5]]) == 15.0\n    assert candidate(4, 3, [[3,3,3,3], [3,3,3,3], [3,3,3,3], [3,3,3,3]]) == 9.0\n    assert candidate(5, 3, [[0,1,0,1,0], [1,0,1,0,1], [0,1,0,1,0], [1,0,1,0,1], [0,1,0,1,0]]) == 3.0\n    assert candidate(2, 2, [[10,10], [10,10]]) == 20.0\n    assert candidate(4, 2, [[1,2,3,4], [5,6,7,8], [9,10,11,12], [13,14,15,16]]) == 31.0\n    assert candidate(3, 2, [[1,2,3], [4,5,6], [7,8,9]]) == 17.0\n    assert candidate(5, 4, [[1,2,3,4,5], [6,7,8,9,10], [11,12,13,14,15], [16,17,18,19,20], [21,22,23,24,25]]) == 94.0\n    assert candidate(4, 4, [[1,1,1,1], [1,1,1,1], [1,1,1,1], [1,1,1,1]]) == 4.0\n    assert candidate(2, 1, [[1,2], [3,4]]) == 4.0\n", "language": "python"}
{"task_id": "revision1a_problem715", "prompt": "from typing import List, Dict\n\ndef recipe_scaling(ingredients: Dict[str, float], servings: int, allergies: List[str]) -> Dict[str, float]:\n    \"\"\"\n    A chef wants to scale a recipe for a different number of servings and accommodate allergies.\n\n    Create a function that takes:\n    1. A dictionary of ingredients and their quantities (in grams).\n    2. The number of servings the recipe should be scaled to.\n    3. A list of allergies to be avoided.\n\n    The function should:\n    1. Scale the recipe to the desired number of servings.\n    2. Remove any ingredients that match the allergies list.\n    3. If an ingredient is removed, increase other ingredients proportionally to maintain the total volume.\n\n    Return the modified recipe as a dictionary of ingredients and their new quantities.\n\n    Assume:\n    - The original recipe is for 4 servings.\n    - Allergies are case-insensitive.\n    - If all ingredients are removed due to allergies, return an empty dictionary.\n\n    Example:\n    Input:\n    ingredients = {\"flour\": 200, \"sugar\": 100, \"eggs\": 50, \"milk\": 100, \"butter\": 50}\n    servings = 6\n    allergies = [\"eggs\", \"milk\"]\n\n    Output: {\"flour\": 360, \"sugar\": 180, \"butter\": 90}\n    \"\"\"\n", "entry_point": "recipe_scaling", "solution": "    # Step 1: Scale the recipe\n    scaling_factor = servings / 4\n    scaled_ingredients = {ingredient: quantity * scaling_factor for ingredient, quantity in ingredients.items()}\n\n    # Step 2: Remove allergic ingredients\n    allergies_lower = [allergy.lower() for allergy in allergies]\n    non_allergic_ingredients = {\n        ingredient: quantity\n        for ingredient, quantity in scaled_ingredients.items()\n        if ingredient.lower() not in allergies_lower\n    }\n\n    # If all ingredients are removed, return an empty dictionary\n    if not non_allergic_ingredients:\n        return {}\n\n    # Step 3: Increase remaining ingredients proportionally\n    total_original = sum(scaled_ingredients.values())\n    total_remaining = sum(non_allergic_ingredients.values())\n    increase_factor = total_original / total_remaining\n\n    final_ingredients = {\n        ingredient: quantity * increase_factor\n        for ingredient, quantity in non_allergic_ingredients.items()\n    }\n\n    return final_ingredients\n", "test": "def check(candidate):\n    assert candidate({\"flour\": 200, \"sugar\": 100, \"eggs\": 50, \"milk\": 100, \"butter\": 50}, 3, [\"milk\", \"eggs\", \"flour\"]) == {'sugar': 250.0, 'butter': 125.0}\n    assert candidate({\"flour\": 200, \"sugar\": 100, \"eggs\": 50, \"milk\": 100, \"butter\": 50}, 8, [\"FLOUR\", \"SUGAR\"]) == {'eggs': 250.0, 'milk': 500.0, 'butter': 250.0}\n    assert candidate({\"flour\": 200, \"sugar\": 100, \"eggs\": 50, \"milk\": 100, \"butter\": 50}, 4, [\"flour\", \"sugar\", \"eggs\", \"milk\", \"butter\"]) == {}\n    assert candidate({\"flour\": 200, \"sugar\": 100, \"eggs\": 50, \"milk\": 100, \"butter\": 50}, 1, [\"butter\"]) == {'flour': 55.55555555555556, 'sugar': 27.77777777777778, 'eggs': 13.88888888888889, 'milk': 27.77777777777778}\n    assert candidate({\"flour\": 200}, 4, [\"flour\"]) == {}\n    assert candidate({\"flour\": 1000, \"sugar\": 500}, 2, []) == {'flour': 500.0, 'sugar': 250.0}\n    assert candidate({\"flour\": 200, \"sugar\": 100, \"eggs\": 50, \"milk\": 100, \"butter\": 50}, 6, [\"eggs\", \"milk\"]) == {'flour': 428.57142857142856, 'sugar': 214.28571428571428, 'butter': 107.14285714285714}\n    assert candidate({\"flour\": 200, \"sugar\": 100, \"eggs\": 50, \"milk\": 100, \"butter\": 50}, 2, []) == {'flour': 100.0, 'sugar': 50.0, 'eggs': 25.0, 'milk': 50.0, 'butter': 25.0}\n    assert candidate({\"flour\": 200, \"sugar\": 100, \"eggs\": 50, \"milk\": 100, \"butter\": 50}, 10, [\"Sugar\"]) == {'flour': 625.0, 'eggs': 156.25, 'milk': 312.5, 'butter': 156.25}\n    assert candidate({}, 4, []) == {}\n", "language": "python"}
{"task_id": "revision1a_problem433", "prompt": "from typing import List, Tuple\nfrom collections import defaultdict\n\ndef book_club_meeting(n: int, preferences: List[Tuple[str, str, int]]) -> int:\n    \"\"\"\n    Imagine a book club scenario where there are n members, each with their preferred book genre and meeting time.\n    The club wants to organize meetings based on these preferences. Each member has a primary genre preference,\n    a secondary genre preference, and a preferred meeting time (represented by an integer from 1 to 24).\n\n    A meeting can be scheduled if:\n    1. At least 3 members have matching primary or secondary genre preferences\n    2. The difference between the earliest and latest preferred meeting times of these members is no more than 3 hours\n\n    Your task is to determine the maximum number of meetings that can be scheduled.\n\n    Take input from the user for the number of members (n) and their preferences.\n    Each member's preferences are represented as a tuple (primary_genre, secondary_genre, preferred_time).\n\n    Example:\n    Input: 5, [(\"Fiction\", \"Mystery\", 14), (\"Mystery\", \"Sci-Fi\", 16), (\"Romance\", \"Fiction\", 13), (\"Sci-Fi\", \"Mystery\", 15), (\"Fiction\", \"Romance\", 17)]\n    Output: 1\n\n    Input: 6, [(\"History\", \"Biography\", 10), (\"Science\", \"History\", 11), (\"Biography\", \"Science\", 9), (\"Fiction\", \"Mystery\", 18), (\"Mystery\", \"Fiction\", 20), (\"Sci-Fi\", \"Fantasy\", 19)]\n    Output: 2\n    \"\"\"\n", "entry_point": "book_club_meeting", "solution": "    def can_schedule_meeting(group):\n        if len(group) < 3:\n            return False\n        times = [pref[2] for pref in group]\n        return max(times) - min(times) <= 3\n\n    genre_groups = defaultdict(list)\n    for pref in preferences:\n        genre_groups[pref[0]].append(pref)\n        genre_groups[pref[1]].append(pref)\n\n    meetings = 0\n    scheduled_members = set()\n\n    for genre, group in genre_groups.items():\n        if can_schedule_meeting(group):\n            new_members = set(pref for pref in group if pref not in scheduled_members)\n            if len(new_members) >= 3:\n                meetings += 1\n                scheduled_members.update(new_members)\n\n    return meetings\n", "test": "def check(candidate):\n    assert candidate(4, [(\"Mystery\", \"Thriller\", 20), (\"Thriller\", \"Mystery\", 21), (\"Horror\", \"Sci-Fi\", 22), (\"Sci-Fi\", \"Horror\", 23)]) == 0\n    assert candidate(6, [(\"History\", \"Biography\", 10), (\"Science\", \"History\", 11), (\"Biography\", \"Science\", 9), (\"Fiction\", \"Mystery\", 18), (\"Mystery\", \"Fiction\", 20), (\"Sci-Fi\", \"Fantasy\", 19)]) == 0\n    assert candidate(5, [(\"Fiction\", \"Fiction\", 12), (\"Fiction\", \"Fiction\", 13), (\"Fiction\", \"Fiction\", 14), (\"Non-fiction\", \"Non-fiction\", 15), (\"Non-fiction\", \"Non-fiction\", 16)]) == 1\n    assert candidate(7, [(\"Comedy\", \"Drama\", 10), (\"Drama\", \"Comedy\", 11), (\"Action\", \"Adventure\", 12), (\"Adventure\", \"Action\", 13), (\"Romance\", \"Comedy\", 14), (\"Thriller\", \"Horror\", 15), (\"Horror\", \"Thriller\", 16)]) == 0\n    assert candidate(6, [(\"Romance\", \"Comedy\", 1), (\"Comedy\", \"Romance\", 2), (\"Drama\", \"Action\", 3), (\"Action\", \"Drama\", 4), (\"Fantasy\", \"Sci-Fi\", 5), (\"Sci-Fi\", \"Fantasy\", 6)]) == 0\n    assert candidate(4, [(\"Sci-Fi\", \"Fantasy\", 15), (\"Fantasy\", \"Sci-Fi\", 16), (\"Horror\", \"Mystery\", 17), (\"Mystery\", \"Horror\", 18)]) == 0\n    assert candidate(2, [(\"Fiction\", \"Non-fiction\", 9), (\"Non-fiction\", \"Fiction\", 10)]) == 0\n    assert candidate(5, [(\"Fiction\", \"Mystery\", 14), (\"Mystery\", \"Sci-Fi\", 16), (\"Romance\", \"Fiction\", 13), (\"Sci-Fi\", \"Mystery\", 15), (\"Fiction\", \"Romance\", 17)]) == 1\n    assert candidate(3, [(\"Fiction\", \"Romance\", 12), (\"Romance\", \"Fiction\", 13), (\"Mystery\", \"Thriller\", 14)]) == 0\n    assert candidate(8, [(\"History\", \"Biography\", 8), (\"Biography\", \"History\", 9), (\"Science\", \"Philosophy\", 10), (\"Philosophy\", \"Science\", 11), (\"Art\", \"Music\", 12), (\"Music\", \"Art\", 13), (\"Travel\", \"Cooking\", 14), (\"Cooking\", \"Travel\", 15)]) == 0\n", "language": "python"}
{"task_id": "revision1a_problem701", "prompt": "import itertools\nfrom typing import List\n\ndef optimize_delivery_route(distances: List[List[int]]) -> List[int]:\n    \"\"\"\n    A delivery company wants to optimize their route for a driver delivering packages to multiple locations.\n    Write a program to find the shortest possible route that visits each location exactly once and returns to the starting point.\n    This is known as the Traveling Salesman Problem.\n\n    Use dynamic programming to solve this NP-hard problem efficiently for small to medium-sized inputs.\n    Take input as a 2D list representing distances between each pair of locations.\n\n    Example:\n    Input: [[0, 10, 15, 20], [10, 0, 35, 25], [15, 35, 0, 30], [20, 25, 30, 0]]\n    Output: [0, 1, 3, 2, 0]  # This represents the optimal route: 0 -> 1 -> 3 -> 2 -> 0\n    \"\"\"\n", "entry_point": "optimize_delivery_route", "solution": "    n = len(distances)\n    all_points = set(range(n))\n    \n    # Initialize the DP table\n    dp = {}\n    \n    # Base case: distance from 0 to itself is 0\n    for i in range(1, n):\n        dp[(1 << i, i)] = (distances[0][i], 0)\n    \n    # Iterate through all subsets of points\n    for size in range(2, n):\n        for subset in itertools.combinations(range(1, n), size):\n            bits = 0\n            for bit in subset:\n                bits |= 1 << bit\n            \n            # Try to find the best path for this subset\n            for last in subset:\n                subsets_without_last = bits ^ (1 << last)\n                min_distance = float('inf')\n                parent = None\n                \n                for j in subset:\n                    if j == last:\n                        continue\n                    new_distance = dp[(subsets_without_last, j)][0] + distances[j][last]\n                    if new_distance < min_distance:\n                        min_distance = new_distance\n                        parent = j\n                \n                dp[(bits, last)] = (min_distance, parent)\n    \n    # Find the optimal solution\n    bits = (2**n - 1) - 1  # All bits except 0 are set\n    min_distance = float('inf')\n    parent = None\n    for i in range(1, n):\n        if dp[(bits, i)][0] + distances[i][0] < min_distance:\n            min_distance = dp[(bits, i)][0] + distances[i][0]\n            parent = i\n    \n    # Reconstruct the path\n    path = [0]\n    for i in range(n - 1):\n        path.append(parent)\n        new_bits = bits ^ (1 << parent)\n        _, parent = dp[(bits, parent)]\n        bits = new_bits\n    \n    # Add the starting point to complete the cycle\n    path.append(0)\n    \n    return path\n", "test": "def check(candidate):\n    assert candidate([[0, 100, 200], [100, 0, 50], [200, 50, 0]]) == [0, 1, 2, 0]\n    assert candidate([[0, 1, 1, 1], [1, 0, 1, 1], [1, 1, 0, 1], [1, 1, 1, 0]]) == [0, 1, 2, 3, 0]\n    assert candidate([[0]]) == [0, 0]\n    assert candidate([[0, 10, 15, 20], [10, 0, 35, 25], [15, 35, 0, 30], [20, 25, 30, 0]]) == [0, 1, 3, 2, 0]\n    assert candidate([[0, 1, 2, 3], [1, 0, 4, 5], [2, 4, 0, 6], [3, 5, 6, 0]]) == [0, 1, 2, 3, 0]\n    assert candidate([[0, 10, 20, 30], [10, 0, 40, 50], [20, 40, 0, 60], [30, 50, 60, 0]]) == [0, 1, 2, 3, 0]\n    assert candidate([[0, 5, 10], [5, 0, 15], [10, 15, 0]]) == [0, 1, 2, 0]\n    assert candidate([[0, 1], [1, 0]]) == [0, 1, 0]\n    assert candidate([[0, 1000, 2000], [1000, 0, 3000], [2000, 3000, 0]]) == [0, 1, 2, 0]\n    assert candidate([[0, 10, 20, 30, 40], [10, 0, 15, 25, 35], [20, 15, 0, 18, 22], [30, 25, 18, 0, 12], [40, 35, 22, 12, 0]]) == [0, 1, 2, 4, 3, 0]\n", "language": "python"}
{"task_id": "revision1a_problem559", "prompt": "from typing import List, Tuple\nimport heapq\n\ndef network_latency(connections: List[Tuple[str, str, int]], start: str, end: str) -> int:\n    \"\"\"\n    You're a network engineer tasked with finding the path with the least latency between two servers in a complex network.\n    \n    Write a function that takes:\n    1. A list of connections, where each connection is a tuple (server1, server2, latency)\n    2. A start server\n    3. An end server\n\n    The function should return the minimum total latency between the start and end servers.\n    If there's no path between the servers, return -1.\n\n    Use Dijkstra's algorithm with a priority queue (heap) for efficient pathfinding.\n\n    Example:\n    Input: \n    connections = [(\"A\", \"B\", 5), (\"B\", \"C\", 2), (\"A\", \"C\", 10), (\"C\", \"D\", 1), (\"D\", \"E\", 4)]\n    start = \"A\"\n    end = \"E\"\n    Output: 8 (Path: A -> B -> C -> D -> E)\n\n    Input:\n    connections = [(\"X\", \"Y\", 2), (\"Y\", \"Z\", 3), (\"X\", \"Z\", 10)]\n    start = \"X\"\n    end = \"W\"\n    Output: -1 (No path to W)\n    \"\"\"\n", "entry_point": "network_latency", "solution": "    # Build the graph\n    graph = {}\n    for server1, server2, latency in connections:\n        if server1 not in graph:\n            graph[server1] = {}\n        if server2 not in graph:\n            graph[server2] = {}\n        graph[server1][server2] = latency\n        graph[server2][server1] = latency\n\n    # Initialize distances and priority queue\n    distances = {server: float('inf') for server in graph}\n    distances[start] = 0\n    pq = [(0, start)]\n\n    # Dijkstra's algorithm\n    while pq:\n        current_distance, current_server = heapq.heappop(pq)\n\n        if current_server == end:\n            return current_distance\n\n        if current_distance > distances[current_server]:\n            continue\n\n        for neighbor, latency in graph[current_server].items():\n            distance = current_distance + latency\n            if distance < distances[neighbor]:\n                distances[neighbor] = distance\n                heapq.heappush(pq, (distance, neighbor))\n\n    # If we can't reach the end server\n    return -1\n", "test": "def check(candidate):\n    assert candidate([(\"A\", \"B\", 1), (\"B\", \"C\", 1), (\"C\", \"A\", 1)], \"A\", \"C\") == 1\n    assert candidate([(\"A\", \"B\", 1)], \"A\", \"B\") == 1\n    assert candidate([(\"A\", \"B\", 5), (\"B\", \"C\", 5), (\"A\", \"C\", 10)], \"A\", \"C\") == 10\n    assert candidate([(\"A\", \"B\", 1)], \"B\", \"A\") == 1\n    assert candidate([(\"A\", \"B\", 1), (\"B\", \"C\", 1), (\"C\", \"D\", 1)], \"D\", \"A\") == 3\n    assert candidate([(\"A\", \"B\", 100), (\"A\", \"C\", 1), (\"C\", \"B\", 1)], \"A\", \"B\") == 2\n    assert candidate([(\"A\", \"B\", 5), (\"B\", \"C\", 2), (\"A\", \"C\", 10), (\"C\", \"D\", 1), (\"D\", \"E\", 4)], \"A\", \"E\") == 12\n    assert candidate([(\"A\", \"A\", 0)], \"A\", \"A\") == 0\n    assert candidate([(\"A\", \"B\", 1), (\"B\", \"C\", 1), (\"C\", \"D\", 1)], \"A\", \"D\") == 3\n    assert candidate([(\"X\", \"Y\", 2), (\"Y\", \"Z\", 3), (\"X\", \"Z\", 10)], \"X\", \"Z\") == 5\n", "language": "python"}
{"task_id": "revision1a_problem675", "prompt": "from typing import List, Dict, Tuple\nfrom collections import deque\n\ndef network_packet_routing(network: Dict[str, List[str]], packets: List[Tuple[str, str, int]], time_limit: int) -> List[int]:\n    \"\"\"\n    A network engineer needs to simulate packet routing in a computer network to identify bottlenecks.\n    Implement a packet routing simulation where packets travel through nodes in a network.\n    \n    The function should:\n    1. Process packets in order of arrival\n    2. Route each packet through the network from source to destination\n    3. Track the time taken for each packet to reach its destination\n    4. Handle packet drops if the time limit is exceeded\n    \n    Parameters:\n    - network: A dictionary representing the network topology, where keys are node names and values are lists of connected nodes\n    - packets: A list of tuples (source, destination, arrival_time) representing packets to be routed\n    - time_limit: The maximum time allowed for a packet to reach its destination before being dropped\n    \n    Returns:\n    - A list of integers representing the time taken for each packet to reach its destination, or -1 if the packet was dropped\n    \n    Example:\n    Input: \n    network = {'A': ['B', 'C'], 'B': ['A', 'D'], 'C': ['A', 'D'], 'D': ['B', 'C']}\n    packets = [('A', 'D', 0), ('C', 'B', 2), ('B', 'C', 4)]\n    time_limit = 5\n    \n    Output: [2, 3, -1]\n    \"\"\"\n", "entry_point": "network_packet_routing", "solution": "    def bfs(start: str, end: str, current_time: int) -> int:\n        queue = deque([(start, current_time)])\n        visited = set()\n        \n        while queue:\n            node, time = queue.popleft()\n            \n            if time > time_limit:\n                return -1\n            \n            if node == end:\n                return time - current_time\n            \n            if node not in visited:\n                visited.add(node)\n                for neighbor in network[node]:\n                    queue.append((neighbor, time + 1))\n        \n        return -1\n\n    results = []\n    for source, destination, arrival_time in packets:\n        time_taken = bfs(source, destination, arrival_time)\n        results.append(time_taken)\n\n    return results\n", "test": "def check(candidate):\n    assert candidate({}, [], 5) == []\n    assert candidate({'X': ['Y'], 'Y': ['X', 'Z'], 'Z': ['Y']}, [('X', 'Z', 0)], 3) == [2]\n    assert candidate({'A': ['B'], 'B': ['A', 'C'], 'C': ['B']}, [('A', 'C', 0), ('C', 'A', 1)], 10) == [2, 2]\n    assert candidate({'A': ['B', 'C'], 'B': ['A', 'C'], 'C': ['A', 'B']}, [('A', 'C', 0), ('B', 'A', 1), ('C', 'B', 2)], 2) == [1, 1, -1]\n    assert candidate({'A': ['B']}, [('A', 'B', 0)], 1) == [1]\n    assert candidate({'A': ['B'], 'B': ['A', 'C'], 'C': ['B', 'D'], 'D': ['C']}, [('A', 'D', 0)], 3) == [3]\n    assert candidate({'A': ['B', 'C'], 'B': ['A', 'D'], 'C': ['A', 'D'], 'D': ['B', 'C']}, [('A', 'D', 0), ('C', 'B', 2), ('B', 'C', 4)], 5) == [2, 2, -1]\n    assert candidate({'A': ['B'], 'B': ['A', 'C'], 'C': ['B', 'D'], 'D': ['C']}, [('A', 'D', 0)], 4) == [3]\n    assert candidate({'1': ['2', '3', '4'], '2': ['1', '3'], '3': ['1', '2', '4'], '4': ['1', '3']}, [('1', '4', 0), ('2', '3', 1), ('3', '1', 2), ('4', '2', 3)], 5) == [1, 1, 1, 2]\n", "language": "python"}
{"task_id": "revision1a_problem438", "prompt": "from typing import List, Dict, Tuple\n\ndef design_network_topology(connections: List[Tuple[str, str, int]]) -> Dict[str, List[str]]:\n    \"\"\"\n    You are a network engineer tasked with designing an optimal network topology for a company.\n    Given a list of possible connections between network nodes and their associated costs,\n    your goal is to create a minimum spanning tree that connects all nodes with the least total cost.\n\n    Implement a class called NetworkDesigner that does the following:\n    1. Initializes the network with the given connections\n    2. Implements Kruskal's algorithm to find the minimum spanning tree\n    3. Returns the optimal network topology\n\n    Take input from the user as a list of tuples, where each tuple represents a connection:\n    (node1: str, node2: str, cost: int)\n\n    Return a dictionary representing the optimal network topology, where keys are nodes and\n    values are lists of connected nodes.\n\n    Example:\n    Input: [(\"A\", \"B\", 5), (\"B\", \"C\", 3), (\"A\", \"C\", 7), (\"C\", \"D\", 4), (\"B\", \"D\", 6)]\n    Output: {'A': ['B'], 'B': ['A', 'C'], 'C': ['B', 'D'], 'D': ['C']}\n\n    Input: [(\"X\", \"Y\", 2), (\"Y\", \"Z\", 1), (\"X\", \"Z\", 3), (\"Z\", \"W\", 4), (\"W\", \"V\", 2), (\"X\", \"V\", 5)]\n    Output: {'X': ['Y'], 'Y': ['X', 'Z'], 'Z': ['Y', 'W'], 'W': ['Z', 'V'], 'V': ['W']}\n    \"\"\"\n", "entry_point": "design_network_topology", "solution": "    class NetworkDesigner:\n        def __init__(self, connections):\n            self.connections = sorted(connections, key=lambda x: x[2])\n            self.nodes = set()\n            for connection in connections:\n                self.nodes.update(connection[:2])\n            self.parent = {node: node for node in self.nodes}\n            self.rank = {node: 0 for node in self.nodes}\n\n        def find(self, node):\n            if self.parent[node] != node:\n                self.parent[node] = self.find(self.parent[node])\n            return self.parent[node]\n\n        def union(self, node1, node2):\n            root1, root2 = self.find(node1), self.find(node2)\n            if root1 != root2:\n                if self.rank[root1] < self.rank[root2]:\n                    self.parent[root1] = root2\n                elif self.rank[root1] > self.rank[root2]:\n                    self.parent[root2] = root1\n                else:\n                    self.parent[root2] = root1\n                    self.rank[root1] += 1\n\n        def kruskal(self):\n            mst = []\n            for node1, node2, cost in self.connections:\n                if self.find(node1) != self.find(node2):\n                    self.union(node1, node2)\n                    mst.append((node1, node2))\n            return mst\n\n        def get_optimal_topology(self):\n            mst = self.kruskal()\n            topology = {node: [] for node in self.nodes}\n            for node1, node2 in mst:\n                topology[node1].append(node2)\n                topology[node2].append(node1)\n            return topology\n\n    network = NetworkDesigner(connections)\n    return network.get_optimal_topology()\n", "test": "def check(candidate):\n    assert candidate([(\"A\", \"B\", 5), (\"B\", \"C\", 3), (\"A\", \"C\", 7), (\"C\", \"D\", 4), (\"B\", \"D\", 6)]) == {'A': ['B'], 'C': ['B', 'D'], 'B': ['C', 'A'], 'D': ['C']}\n    assert candidate([(\"X\", \"Y\", 100), (\"Y\", \"Z\", 200), (\"Z\", \"X\", 300)]) == {'X': ['Y'], 'Y': ['X', 'Z'], 'Z': ['Y']}\n    assert candidate([(\"A\", \"B\", 10), (\"B\", \"C\", 20), (\"C\", \"D\", 30), (\"D\", \"E\", 40), (\"E\", \"A\", 50)]) == {'A': ['B'], 'B': ['A', 'C'], 'D': ['C', 'E'], 'E': ['D'], 'C': ['B', 'D']}\n    assert candidate([(\"X\", \"Y\", 2), (\"Y\", \"Z\", 1), (\"X\", \"Z\", 3), (\"Z\", \"W\", 4), (\"W\", \"V\", 2), (\"X\", \"V\", 5)]) == {'X': ['Y'], 'Y': ['Z', 'X'], 'W': ['V', 'Z'], 'V': ['W'], 'Z': ['Y', 'W']}\n    assert candidate([(\"1\", \"2\", 1), (\"2\", \"3\", 2), (\"3\", \"4\", 3), (\"4\", \"5\", 4), (\"5\", \"1\", 5)]) == {'3': ['2', '4'], '5': ['4'], '1': ['2'], '4': ['3', '5'], '2': ['1', '3']}\n    assert candidate([(\"A\", \"B\", 1), (\"B\", \"C\", 1), (\"C\", \"D\", 1), (\"D\", \"E\", 1), (\"E\", \"A\", 1)]) == {'A': ['B'], 'B': ['A', 'C'], 'D': ['C', 'E'], 'E': ['D'], 'C': ['B', 'D']}\n    assert candidate([(\"A\", \"B\", 1), (\"B\", \"C\", 2), (\"C\", \"D\", 3), (\"D\", \"E\", 4), (\"E\", \"F\", 5), (\"F\", \"A\", 6)]) == {'A': ['B'], 'B': ['A', 'C'], 'F': ['E'], 'D': ['C', 'E'], 'E': ['D', 'F'], 'C': ['B', 'D']}\n    assert candidate([(\"1\", \"2\", 10), (\"2\", \"3\", 10), (\"3\", \"4\", 10), (\"4\", \"5\", 10), (\"5\", \"1\", 10), (\"1\", \"3\", 15), (\"2\", \"4\", 15), (\"3\", \"5\", 15)]) == {'3': ['2', '4'], '5': ['4'], '1': ['2'], '4': ['3', '5'], '2': ['1', '3']}\n    assert candidate([(\"Node1\", \"Node2\", 5), (\"Node2\", \"Node3\", 3), (\"Node3\", \"Node4\", 7), (\"Node4\", \"Node1\", 2)]) == {'Node3': ['Node2'], 'Node1': ['Node4', 'Node2'], 'Node4': ['Node1'], 'Node2': ['Node3', 'Node1']}\n    assert candidate([(\"A\", \"B\", 1), (\"B\", \"C\", 1), (\"C\", \"A\", 1)]) == {'A': ['B'], 'C': ['B'], 'B': ['A', 'C']}\n", "language": "python"}
{"task_id": "revision1a_problem188", "prompt": "def decode_alien_message(message: str) -> int:\n    \"\"\"\n    You've intercepted a coded message from an alien civilization! The message is a string of digits, \n    and you've figured out that it can be decoded into a sequence of positive integers.\n\n    However, the decoding isn't straightforward. Each number in the sequence could be represented by either one or two digits in the string. \n    For example, '12' could be decoded as [1,2] or as [12].\n\n    Your task is to determine how many different ways the entire message could be decoded, assuming:\n    1. No number starts with a 0 (so '01' is not a valid number)\n    2. Only numbers from 1 to 26 are used in the encoding (representing the 26 letters of the English alphabet)\n\n    Implement a function that takes the coded message as a string and returns the number of possible decodings. \n    Since the number of decodings can be very large, return the result modulo 10^9 + 7.\n\n    This problem is similar to climbing stairs with variable step sizes and involves dynamic programming for an efficient solution.\n\n    Example:\n    Input: '11106'\n    Output: 2\n\n    Explanation: \n    The message '11106' can be decoded as:\n    [1,1,10,6] -> AAJF\n    [11,10,6] -> KJF\n    Thus, there are 2 possible decodings.\n    \"\"\"\n", "entry_point": "decode_alien_message", "solution": "    MOD = 10**9 + 7\n    n = len(message)\n    \n    # Initialize dp array\n    dp = [0] * (n + 1)\n    dp[0] = 1\n    dp[1] = 1 if message[0] != '0' else 0\n    \n    for i in range(2, n + 1):\n        # Check if the current digit is valid (not '0')\n        if message[i-1] != '0':\n            dp[i] = dp[i-1]\n        \n        # Check if the last two digits form a valid number (10-26)\n        two_digit = int(message[i-2:i])\n        if 10 <= two_digit <= 26:\n            dp[i] = (dp[i] + dp[i-2]) % MOD\n    \n    return dp[n]\n", "test": "def check(candidate):\n    assert candidate(\"100\") == 0\n    assert candidate(\"27\") == 1\n    assert candidate(\"10\") == 1\n    assert candidate(\"0\") == 0\n    assert candidate(\"1\") == 1\n    assert candidate(\"01\") == 0\n    assert candidate(\"226\") == 3\n    assert candidate(\"99999\") == 1\n    assert candidate(\"11106\") == 2\n    assert candidate(\"12\") == 2\n", "language": "python"}
{"task_id": "revision1a_problem260", "prompt": "from typing import List, Dict, Tuple\nimport heapq\nfrom collections import defaultdict\nimport heapq\n\ndef analyze_social_network(connections: List[Tuple[str, str]], k: int) -> Dict[str, int]:\n    \"\"\"\n    You are given data about connections in a social network. Each connection is represented\n    by a tuple of two names. Your task is to implement a function that analyzes the network\n    and identifies the top k most influential people based on their number of connections.\n\n    The function should:\n    1. Build a graph representation of the social network\n    2. Calculate the degree (number of connections) for each person\n    3. Return a dictionary of the top k people with the highest degrees\n\n    Take input from the user for the list of connections and the value of k.\n    Use a priority queue (heap) to efficiently find the top k influential people.\n\n    Example:\n    Input: \n    connections = [(\"Alice\", \"Bob\"), (\"Bob\", \"Charlie\"), (\"Alice\", \"David\"), (\"Eve\", \"Alice\"), (\"Frank\", \"Bob\")]\n    k = 2\n    Output: {\"Alice\": 3, \"Bob\": 3}\n    \"\"\"\n", "entry_point": "analyze_social_network", "solution": "    # Build a graph representation of the social network\n    graph = defaultdict(set)\n    for person1, person2 in connections:\n        graph[person1].add(person2)\n        graph[person2].add(person1)\n    \n    # Calculate the degree (number of connections) for each person\n    degree_count = {person: len(connections) for person, connections in graph.items()}\n    \n    # Use a min heap to efficiently find the top k influential people\n    min_heap = []\n    for person, degree in degree_count.items():\n        if len(min_heap) < k:\n            heapq.heappush(min_heap, (degree, person))\n        elif degree > min_heap[0][0]:\n            heapq.heappop(min_heap)\n            heapq.heappush(min_heap, (degree, person))\n    \n    # Create a dictionary of the top k people with the highest degrees\n    result = {person: degree for degree, person in min_heap}\n    \n    return result\n", "test": "def check(candidate):\n    assert candidate([(\"X\", \"Y\"), (\"Y\", \"Z\"), (\"Z\", \"X\")], 1) == {'X': 2}\n    assert candidate([(\"A\", \"B\"), (\"B\", \"C\"), (\"C\", \"D\"), (\"D\", \"E\"), (\"E\", \"F\"), (\"F\", \"G\")], 2) == {'B': 2, 'C': 2}\n    assert candidate([(\"A\", str(i)) for i in range(100)], 5) == {'0': 1, '2': 1, '1': 1, 'A': 100, '3': 1}\n    assert candidate([(\"A\", \"B\")], 1) == {'A': 1}\n    assert candidate([(\"A\", \"B\"), (\"C\", \"D\"), (\"E\", \"F\"), (\"G\", \"H\")], 4) == {'A': 1, 'B': 1, 'C': 1, 'D': 1}\n    assert candidate([(\"John\", \"Mary\"), (\"Mary\", \"Peter\"), (\"Peter\", \"John\")], 3) == {'John': 2, 'Mary': 2, 'Peter': 2}\n    assert candidate([(\"A\", \"B\"), (\"B\", \"C\"), (\"C\", \"D\"), (\"D\", \"E\"), (\"E\", \"A\")], 3) == {'A': 2, 'B': 2, 'C': 2}\n    assert candidate([(\"A\", \"B\"), (\"A\", \"C\"), (\"A\", \"D\"), (\"B\", \"C\"), (\"B\", \"D\"), (\"C\", \"D\")], 4) == {'A': 3, 'B': 3, 'C': 3, 'D': 3}\n    assert candidate([(\"Alice\", \"Bob\"), (\"Bob\", \"Charlie\"), (\"Alice\", \"David\"), (\"Eve\", \"Alice\"), (\"Frank\", \"Bob\")], 2) == {'Alice': 3, 'Bob': 3}\n    assert candidate([(\"X\", \"Y\")] * 10, 1) == {'X': 1}\n", "language": "python"}
{"task_id": "revision1a_problem491", "prompt": "from typing import List\nfrom collections import defaultdict\n\ndef network_reliability(n: int, connections: List[List[int]], critical: List[int]) -> bool:\n    \"\"\"\n    You are a network engineer tasked with analyzing the reliability of a computer network. \n    The network consists of n nodes (numbered from 0 to n-1) and a set of connections between them. \n    Some nodes are designated as critical, meaning the network must maintain connectivity to these nodes.\n\n    Your task is to determine if the network is reliable. A network is considered reliable if:\n    1. All nodes are connected (there's a path between any two nodes).\n    2. If any single non-critical node fails, all critical nodes remain connected to each other.\n\n    Parameters:\n    n: The number of nodes in the network.\n    connections: A list of lists, where each inner list [a, b] represents a connection between nodes a and b.\n    critical: A list of node numbers that are designated as critical.\n\n    Return True if the network is reliable, False otherwise.\n\n    Example:\n    Input: n = 5, connections = [[0,1], [0,2], [1,2], [2,3], [3,4]], critical = [0, 4]\n    Output: True\n    Explanation: All nodes are connected, and if any single non-critical node (1, 2, or 3) fails, \n                 there's still a path between the critical nodes 0 and 4.\n\n    Input: n = 4, connections = [[0,1], [1,2], [2,3]], critical = [0, 3]\n    Output: False\n    Explanation: If node 1 or 2 fails, the critical nodes 0 and 3 will be disconnected.\n    \"\"\"\n", "entry_point": "network_reliability", "solution": "    def build_graph(connections):\n        graph = defaultdict(list)\n        for a, b in connections:\n            graph[a].append(b)\n            graph[b].append(a)\n        return graph\n\n    def dfs(node, visited, graph):\n        visited.add(node)\n        for neighbor in graph[node]:\n            if neighbor not in visited:\n                dfs(neighbor, visited, graph)\n\n    def is_connected(graph):\n        visited = set()\n        dfs(0, visited, graph)\n        return len(visited) == n\n\n    def are_critical_nodes_connected(graph, critical, excluded_node):\n        if not critical:\n            return True\n        visited = set()\n        dfs(critical[0], visited, graph)\n        return all(node in visited for node in critical if node != excluded_node)\n\n    graph = build_graph(connections)\n\n    # Check if all nodes are connected\n    if not is_connected(graph):\n        return False\n\n    # Check connectivity after removing each non-critical node\n    for node in range(n):\n        if node not in critical:\n            temp_graph = {k: v.copy() for k, v in graph.items()}\n            for neighbor in temp_graph[node]:\n                temp_graph[neighbor].remove(node)\n            del temp_graph[node]\n            if not are_critical_nodes_connected(temp_graph, critical, node):\n                return False\n\n    return True\n", "test": "def check(candidate):\n    assert candidate(4, [[0,1], [1,2], [2,3], [3,0]], [0, 2]) == True\n    assert candidate(5, [[0,1], [1,2], [2,3], [3,4]], [1, 3]) == False\n    assert candidate(5, [[0,1], [1,2], [2,3], [3,4], [4,0]], [0, 2, 4]) == True\n    assert candidate(3, [[0,1], [1,2]], [0, 2]) == False\n    assert candidate(4, [[0,1], [0,2], [0,3], [1,2], [1,3], [2,3]], [0, 1, 2, 3]) == True\n    assert candidate(7, [[0,1], [1,2], [2,3], [3,4], [4,5], [5,6]], [0, 6]) == False\n    assert candidate(6, [[0,1], [1,2], [2,3], [3,4], [4,5]], [0, 5]) == False\n    assert candidate(3, [[0,1], [1,2], [2,0]], [0]) == True\n    assert candidate(4, [[0,1], [1,2], [2,3]], [0, 3]) == False\n    assert candidate(5, [[0,1], [0,2], [1,2], [2,3], [3,4]], [0, 4]) == False\n", "language": "python"}
{"task_id": "revision1a_problem593", "prompt": "from typing import List, Tuple\n\ndef optimize_wind_farm(n: int, wind_speeds: List[List[int]]) -> List[Tuple[int, int]]:\n    \"\"\"\n    A renewable energy company is planning to build a wind farm. They have a grid of potential\n    turbine locations, each with different average wind speeds throughout the year.\n    The goal is to place turbines to maximize energy production while adhering to placement rules.\n\n    Rules for turbine placement:\n    1. No two turbines can be adjacent (horizontally, vertically, or diagonally)\n    2. There must be at least one empty cell between any two turbines\n\n    Input:\n    - n: The size of the square grid (n x n)\n    - wind_speeds: A 2D list where wind_speeds[i][j] represents the average wind speed at location (i, j)\n\n    Return a list of tuples, where each tuple (i, j) represents the coordinates of a placed turbine.\n    The placement should maximize the total wind speed (as a proxy for energy production).\n\n    Use dynamic programming or a greedy algorithm with backtracking to solve this optimization problem.\n\n    Example:\n    Input: 4, [\n        [1, 3, 4, 1],\n        [2, 5, 3, 4],\n        [1, 5, 2, 3],\n        [2, 4, 1, 3]\n    ]\n    Output: [(0, 2), (2, 0), (3, 3)]\n    \"\"\"\n", "entry_point": "optimize_wind_farm", "solution": "    def is_valid(i: int, j: int, turbines: List[Tuple[int, int]]) -> bool:\n        for x, y in turbines:\n            if abs(i - x) <= 2 and abs(j - y) <= 2:\n                return False\n        return True\n\n    def backtrack(i: int, j: int, turbines: List[Tuple[int, int]]) -> List[Tuple[int, int]]:\n        if i == n:\n            return turbines\n\n        next_i, next_j = (i, j + 1) if j < n - 1 else (i + 1, 0)\n\n        # Try placing a turbine at the current position\n        if is_valid(i, j, turbines):\n            result = backtrack(next_i, next_j, turbines + [(i, j)])\n            if result:\n                return result\n\n        # Try not placing a turbine at the current position\n        return backtrack(next_i, next_j, turbines)\n\n    # Sort positions by wind speed in descending order\n    positions = [(i, j) for i in range(n) for j in range(n)]\n    positions.sort(key=lambda pos: wind_speeds[pos[0]][pos[1]], reverse=True)\n\n    best_turbines = []\n    best_total_speed = 0\n\n    for start_pos in positions:\n        turbines = backtrack(start_pos[0], start_pos[1], [])\n        if turbines:\n            total_speed = sum(wind_speeds[i][j] for i, j in turbines)\n            if total_speed > best_total_speed:\n                best_turbines = turbines\n                best_total_speed = total_speed\n\n    return best_turbines\n", "test": "def check(candidate):\n    assert candidate(4, [[1, 2, 3, 4], [5, 6, 7, 8], [9, 10, 11, 12], [13, 14, 15, 16]]) == [(0, 0), (0, 3), (3, 0), (3, 3)]\n    assert candidate(3, [[1, 2, 3], [4, 5, 6], [7, 8, 9]]) == [(2, 2)]\n    assert candidate(4, [[10, 10, 10, 10], [10, 10, 10, 10], [10, 10, 10, 10], [10, 10, 10, 10]]) == [(0, 0), (0, 3), (3, 0), (3, 3)]\n    assert candidate(4, [[1, 9, 1, 9], [9, 1, 9, 1], [1, 9, 1, 9], [9, 1, 9, 1]]) == [(0, 0), (0, 3), (3, 0), (3, 3)]\n    assert candidate(1, [[5]]) == [(0, 0)]\n    assert candidate(5, [[1, 2, 3, 4, 5], [5, 4, 3, 2, 1], [1, 2, 3, 4, 5], [5, 4, 3, 2, 1], [1, 2, 3, 4, 5]]) == [(0, 1), (0, 4), (3, 0), (3, 3)]\n    assert candidate(5, [[1, 2, 3, 4, 5], [6, 7, 8, 9, 10], [11, 12, 13, 14, 15], [16, 17, 18, 19, 20], [21, 22, 23, 24, 25]]) == [(1, 1), (1, 4), (4, 0), (4, 3)]\n    assert candidate(2, [[1, 2], [3, 4]]) == [(1, 1)]\n    assert candidate(3, [[0, 0, 0], [0, 0, 0], [0, 0, 0]]) == []\n    assert candidate(3, [[1, 1, 1], [1, 9, 1], [1, 1, 1]]) == [(1, 1)]\n", "language": "python"}
{"task_id": "revision1a_problem134", "prompt": "import heapq\nfrom typing import List, Tuple\n\ndef network_latency(nodes: int, connections: List[Tuple[int, int, int]], source: int) -> List[int]:\n    \"\"\"\n    I'm a network engineer tasked with analyzing the latency in a computer network.\n    The network consists of N nodes (numbered from 0 to N-1) connected by various links.\n    Each link has a certain latency (in milliseconds) associated with it.\n\n    Your job is to calculate the minimum latency from a given source node to all other nodes in the network.\n    If a node is unreachable from the source, its latency should be reported as -1.\n\n    The function should handle the following scenarios:\n    1. The network may not be fully connected.\n    2. There might be multiple links between the same pair of nodes (consider the one with minimum latency).\n    3. The latency is always non-negative.\n    4. There are no self-loops (a node connected to itself).\n\n    Take input for the number of nodes, the list of connections (each connection is a tuple of (from_node, to_node, latency)),\n    and the source node. Return a list of minimum latencies from the source to all nodes.\n\n    Example:\n    Input: 4, [(0,1,10), (0,2,5), (1,2,2), (1,3,1), (2,3,4)], 0\n    Output: [0, 7, 5, 8]\n    Input: 3, [(0,1,5), (1,2,5)], 2\n    Output: [-1, -1, 0]\n    \"\"\"\n", "entry_point": "network_latency", "solution": "    # Create an adjacency list to represent the network\n    graph = [[] for _ in range(nodes)]\n    for from_node, to_node, latency in connections:\n        graph[from_node].append((to_node, latency))\n        graph[to_node].append((from_node, latency))  # Add reverse connection for undirected graph\n\n    # Initialize distances array with infinity for all nodes except the source\n    distances = [float('inf')] * nodes\n    distances[source] = 0\n\n    # Use a min-heap to store (latency, node) pairs\n    pq = [(0, source)]\n\n    while pq:\n        current_latency, current_node = heapq.heappop(pq)\n\n        # If we've found a longer path, skip\n        if current_latency > distances[current_node]:\n            continue\n\n        # Explore neighbors\n        for neighbor, latency in graph[current_node]:\n            new_latency = current_latency + latency\n\n            # If we've found a shorter path, update and add to the queue\n            if new_latency < distances[neighbor]:\n                distances[neighbor] = new_latency\n                heapq.heappush(pq, (new_latency, neighbor))\n\n    # Replace unreachable nodes (still at infinity) with -1\n    return [d if d != float('inf') else -1 for d in distances]\n", "test": "def check(candidate):\n    assert candidate(4, [(0,1,1), (1,2,1), (2,3,1)], 3) == [3, 2, 1, 0]\n    assert candidate(4, [(0,1,1), (1,2,1), (2,3,1), (3,0,1)], 2) == [2, 1, 0, 1]\n    assert candidate(2, [(0,1,100)], 0) == [0, 100]\n    assert candidate(5, [(0,1,1), (1,2,2), (2,3,3), (3,4,4)], 0) == [0, 1, 3, 6, 10]\n    assert candidate(1, [], 0) == [0]\n    assert candidate(6, [(0,1,1), (1,2,1), (2,3,1), (3,4,1), (4,5,1), (0,5,10)], 0) == [0, 1, 2, 3, 4, 5]\n    assert candidate(4, [(0,1,10), (0,2,5), (1,2,2), (1,3,1), (2,3,4)], 0) == [0, 7, 5, 8]\n    assert candidate(5, [(0,1,1), (0,2,2), (0,3,3), (0,4,4)], 0) == [0, 1, 2, 3, 4]\n    assert candidate(3, [(0,1,5), (1,2,5)], 2) == [10, 5, 0]\n    assert candidate(3, [(0,1,5), (0,1,2), (1,2,1)], 0) == [0, 2, 3]\n", "language": "python"}
{"task_id": "revision1a_problem680", "prompt": "from typing import List, Tuple\nfrom math import radians, sin, cos, sqrt, atan2\nimport math\n\ndef optimize_delivery_route(addresses: List[Tuple[float, float]], max_packages: int) -> List[List[int]]:\n    \"\"\"\n    A delivery company wants to optimize their routes for package delivery. Given a list of delivery addresses \n    (represented as latitude and longitude coordinates) and the maximum number of packages a driver can carry, \n    determine the most efficient grouping of addresses for multiple trips.\n\n    The function should return a list of lists, where each inner list represents a trip and contains the indices \n    of the addresses to visit on that trip. The goal is to minimize the total number of trips while ensuring that \n    no trip exceeds the maximum number of packages.\n\n    Parameters:\n    addresses (List[Tuple[float, float]]): A list of (latitude, longitude) tuples representing delivery addresses.\n    max_packages (int): The maximum number of packages a driver can carry in one trip.\n\n    Returns:\n    List[List[int]]: A list of lists, where each inner list contains the indices of addresses for a single trip.\n\n    Example:\n    Input: \n    addresses = [(40.7128, -74.0060), (34.0522, -118.2437), (41.8781, -87.6298), (29.7604, -95.3698), (33.7490, -84.3880)]\n    max_packages = 2\n\n    Output: \n    [[0, 1], [2, 3], [4]]\n\n    This output suggests three trips:\n    1. Deliver to addresses at indices 0 and 1\n    2. Deliver to addresses at indices 2 and 3\n    3. Deliver to the address at index 4\n\n    Note: The actual implementation would involve complex algorithms for route optimization and clustering.\n    \"\"\"\n", "entry_point": "optimize_delivery_route", "solution": "    def distance(addr1, addr2):\n        \"\"\"Calculate the Haversine distance between two points.\"\"\"\n        lat1, lon1 = addr1\n        lat2, lon2 = addr2\n        R = 6371  # Earth's radius in kilometers\n\n        dlat = math.radians(lat2 - lat1)\n        dlon = math.radians(lon2 - lon1)\n        a = (math.sin(dlat/2) * math.sin(dlat/2) +\n             math.cos(math.radians(lat1)) * math.cos(math.radians(lat2)) *\n             math.sin(dlon/2) * math.sin(dlon/2))\n        c = 2 * math.atan2(math.sqrt(a), math.sqrt(1-a))\n        return R * c\n\n    def find_nearest_neighbor(curr_idx, unvisited):\n        \"\"\"Find the nearest unvisited address.\"\"\"\n        min_dist = float('inf')\n        nearest = None\n        for idx in unvisited:\n            dist = distance(addresses[curr_idx], addresses[idx])\n            if dist < min_dist:\n                min_dist = dist\n                nearest = idx\n        return nearest\n\n    routes = []\n    unvisited = set(range(len(addresses)))\n\n    while unvisited:\n        route = []\n        start = unvisited.pop()\n        route.append(start)\n        current = start\n\n        while len(route) < max_packages and unvisited:\n            nearest = find_nearest_neighbor(current, unvisited)\n            if nearest is None:\n                break\n            route.append(nearest)\n            unvisited.remove(nearest)\n            current = nearest\n\n        routes.append(route)\n\n    return routes\n", "test": "def check(candidate):\n    assert candidate([(1, 1), (1, 2), (1, 3), (2, 1), (2, 2), (2, 3)], 2) == [[0, 1], [2, 5], [3, 4]]\n    assert candidate([(0, 0), (0, 1), (0, 2), (0, 3), (0, 4)], 5) == [[0, 1, 2, 3, 4]]\n    assert candidate([(45.4215, -75.6972), (43.6532, -79.3832), (45.5017, -73.5673)], 2) == [[0, 2], [1]]\n    assert candidate([(40.7128, -74.0060), (34.0522, -118.2437), (41.8781, -87.6298), (29.7604, -95.3698), (33.7490, -84.3880)], 2) == [[0, 2], [1, 3], [4]]\n    assert candidate([(0, 0)], 1) == [[0]]\n    assert candidate([(90, 180), (-90, -180), (0, 0)], 1) == [[0], [1], [2]]\n    assert candidate([(0, 0), (1, 1), (2, 2), (3, 3), (4, 4), (5, 5)], 3) == [[0, 1, 2], [3, 4, 5]]\n    assert candidate([], 5) == []\n    assert candidate([(i, i) for i in range(10)], 1) == [[0], [1], [2], [3], [4], [5], [6], [7], [8], [9]]\n    assert candidate([(i, i) for i in range(100)], 10) == [[0, 1, 2, 3, 4, 5, 6, 7, 8, 9], [10, 11, 12, 13, 14, 15, 16, 17, 18, 19], [20, 21, 22, 23, 24, 25, 26, 27, 28, 29], [30, 31, 32, 33, 34, 35, 36, 37, 38, 39], [40, 41, 42, 43, 44, 45, 46, 47, 48, 49], [50, 51, 52, 53, 54, 55, 56, 57, 58, 59], [60, 61, 62, 63, 64, 65, 66, 67, 68, 69], [70, 71, 72, 73, 74, 75, 76, 77, 78, 79], [80, 81, 82, 83, 84, 85, 86, 87, 88, 89], [90, 91, 92, 93, 94, 95, 96, 97, 98, 99]]\n", "language": "python"}
{"task_id": "revision1a_problem646", "prompt": "from typing import List, Tuple\nimport math\n\ndef optimize_delivery_route(locations: List[Tuple[float, float]], start: Tuple[float, float]) -> List[Tuple[float, float]]:\n    \"\"\"\n    A delivery company wants to optimize their route for package delivery.\n    Given a list of customer locations (as latitude and longitude coordinates) and the starting point,\n    determine the most efficient route that visits all locations and returns to the start.\n    \n    Use the nearest neighbor algorithm to find an approximate solution to the Traveling Salesman Problem.\n    Return the optimized route as a list of coordinates.\n\n    Example:\n    Input: locations=[(40.7128, -74.0060), (34.0522, -118.2437), (41.8781, -87.6298)], start=(42.3601, -71.0589)\n    Output: [(42.3601, -71.0589), (40.7128, -74.0060), (41.8781, -87.6298), (34.0522, -118.2437), (42.3601, -71.0589)]\n\n    Input: locations=[(48.8566, 2.3522), (51.5074, -0.1278), (41.9028, 12.4964)], start=(52.5200, 13.4050)\n    Output: [(52.5200, 13.4050), (51.5074, -0.1278), (48.8566, 2.3522), (41.9028, 12.4964), (52.5200, 13.4050)]\n    \"\"\"\n", "entry_point": "optimize_delivery_route", "solution": "    def calculate_distance(point1: Tuple[float, float], point2: Tuple[float, float]) -> float:\n        \"\"\"Calculate the Euclidean distance between two points.\"\"\"\n        return math.sqrt((point1[0] - point2[0])**2 + (point1[1] - point2[1])**2)\n\n    unvisited = locations.copy()\n    route = [start]\n    current_location = start\n\n    while unvisited:\n        nearest_location = min(unvisited, key=lambda x: calculate_distance(current_location, x))\n        route.append(nearest_location)\n        current_location = nearest_location\n        unvisited.remove(nearest_location)\n\n    route.append(start)  # Return to the starting point\n    return route\n", "test": "def check(candidate):\n    assert candidate([(1.0, 1.0)], (0.0, 0.0)) == [(0.0, 0.0), (1.0, 1.0), (0.0, 0.0)]\n    assert candidate([(90.0, 0.0), (-90.0, 0.0), (0.0, 180.0), (0.0, -180.0)], (0.0, 0.0)) == [(0.0, 0.0), (90.0, 0.0), (-90.0, 0.0), (0.0, 180.0), (0.0, -180.0), (0.0, 0.0)]\n    assert candidate([(48.8566, 2.3522), (51.5074, -0.1278), (41.9028, 12.4964)], (52.5200, 13.4050)) == [(52.52, 13.405), (41.9028, 12.4964), (48.8566, 2.3522), (51.5074, -0.1278), (52.52, 13.405)]\n    assert candidate([(40.7128, -74.0060), (34.0522, -118.2437), (41.8781, -87.6298)], (42.3601, -71.0589)) == [(42.3601, -71.0589), (40.7128, -74.006), (41.8781, -87.6298), (34.0522, -118.2437), (42.3601, -71.0589)]\n    assert candidate([(0.0, 0.0), (1.0, 1.0), (2.0, 2.0), (3.0, 3.0), (4.0, 4.0)], (0.0, 0.0)) == [(0.0, 0.0), (0.0, 0.0), (1.0, 1.0), (2.0, 2.0), (3.0, 3.0), (4.0, 4.0), (0.0, 0.0)]\n    assert candidate([(0.0001, 0.0001), (0.0002, 0.0002), (0.0003, 0.0003)], (0.0, 0.0)) == [(0.0, 0.0), (0.0001, 0.0001), (0.0002, 0.0002), (0.0003, 0.0003), (0.0, 0.0)]\n    assert candidate([(0.0, 0.0), (0.0, 180.0), (0.0, -180.0)], (90.0, 0.0)) == [(90.0, 0.0), (0.0, 0.0), (0.0, 180.0), (0.0, -180.0), (90.0, 0.0)]\n    assert candidate([(1.0, 1.0), (1.0, 1.0), (1.0, 1.0)], (0.0, 0.0)) == [(0.0, 0.0), (1.0, 1.0), (1.0, 1.0), (1.0, 1.0), (0.0, 0.0)]\n    assert candidate([(-1.0, -1.0), (-2.0, -2.0), (-3.0, -3.0)], (0.0, 0.0)) == [(0.0, 0.0), (-1.0, -1.0), (-2.0, -2.0), (-3.0, -3.0), (0.0, 0.0)]\n    assert candidate([], (0.0, 0.0)) == [(0.0, 0.0), (0.0, 0.0)]\n", "language": "python"}
{"task_id": "revision1a_problem440", "prompt": "import heapq\nfrom typing import List, Tuple\n\ndef network_latency(nodes: int, connections: List[Tuple[int, int, int]], start: int) -> List[int]:\n    \"\"\"\n    You are a network engineer tasked with analyzing the latency in a computer network.\n    The network consists of 'nodes' number of computers, numbered from 0 to nodes-1.\n    Connections between computers are given as a list of tuples (source, destination, latency).\n    Your goal is to find the minimum latency from the start node to every other node in the network.\n\n    Implement the following features:\n    1. Build the network graph\n    2. Calculate minimum latencies using Dijkstra's algorithm\n    3. Handle unreachable nodes\n    4. Optimize for large networks\n\n    Take input from the user for the number of nodes, list of connections, and the start node.\n    Return a list where the i-th element represents the minimum latency to reach node i from the start node.\n    If a node is unreachable, its latency should be represented as float('inf').\n\n    Example:\n    Input: \n    nodes = 4\n    connections = [(0, 1, 10), (0, 2, 5), (1, 2, 2), (1, 3, 1), (2, 3, 4)]\n    start = 0\n    Output: [0, 7, 5, 8]\n    \"\"\"\n", "entry_point": "network_latency", "solution": "    # Build the network graph\n    graph = {i: {} for i in range(nodes)}\n    for source, dest, latency in connections:\n        graph[source][dest] = latency\n        graph[dest][source] = latency  # Assuming bidirectional connections\n\n    # Initialize distances\n    distances = [float('inf')] * nodes\n    distances[start] = 0\n\n    # Priority queue for Dijkstra's algorithm\n    pq = [(0, start)]\n\n    while pq:\n        current_dist, current_node = heapq.heappop(pq)\n\n        # If we've found a longer path, skip\n        if current_dist > distances[current_node]:\n            continue\n\n        # Check neighbors\n        for neighbor, weight in graph[current_node].items():\n            distance = current_dist + weight\n\n            # If we've found a shorter path, update\n            if distance < distances[neighbor]:\n                distances[neighbor] = distance\n                heapq.heappush(pq, (distance, neighbor))\n\n    return distances\n", "test": "def check(candidate):\n    assert candidate(5, [(0, 1, 10), (0, 2, 5), (1, 3, 1), (2, 3, 8), (3, 4, 4)], 2) == [5, 9, 0, 8, 12]\n    assert candidate(6, [(0, 1, 5), (1, 2, 5), (2, 3, 5), (3, 4, 5), (4, 5, 5)], 0) == [0, 5, 10, 15, 20, 25]\n    assert candidate(3, [(0, 1, 1), (1, 2, 1), (2, 0, 1)], 1) == [1, 0, 1]\n    assert candidate(4, [(0, 1, 1), (1, 2, 2), (2, 3, 3)], 3) == [6, 5, 3, 0]\n    assert candidate(6, [(0, 1, 2), (1, 2, 3), (2, 3, 4), (3, 4, 5), (4, 5, 6)], 0) == [0, 2, 5, 9, 14, 20]\n    assert candidate(4, [(0, 1, 1), (1, 2, 1), (2, 3, 1), (3, 0, 1)], 0) == [0, 1, 2, 1]\n    assert candidate(5, [(0, 1, 1), (1, 2, 2), (2, 3, 3), (3, 4, 4)], 0) == [0, 1, 3, 6, 10]\n    assert candidate(4, [(0, 1, 10), (0, 2, 5), (1, 2, 2), (1, 3, 1), (2, 3, 4)], 0) == [0, 7, 5, 8]\n    assert candidate(3, [(0, 1, 1), (1, 2, 2)], 2) == [3, 2, 0]\n    assert candidate(3, [(0, 1, 5), (1, 2, 5)], 0) == [0, 5, 10]\n", "language": "python"}
{"task_id": "revision1a_problem424", "prompt": "from typing import List, Tuple\n\ndef optimize_network(connections: List[Tuple[int, int, int]], nodes: int) -> List[Tuple[int, int, int]]:\n    \"\"\"\n    As a network engineer, you're tasked with optimizing a computer network. \n    The network consists of nodes and connections between them, each with a certain bandwidth.\n    Your goal is to find the minimum spanning tree of the network, which represents the most efficient way to connect all nodes.\n    \n    Use Kruskal's algorithm to solve this problem efficiently. The function should take a list of connections \n    (where each connection is a tuple of (node1, node2, bandwidth)) and the total number of nodes, \n    and return the list of connections that form the minimum spanning tree.\n    \n    Expected Time Complexity: O(E log E), where E is the number of connections.\n    \n    Example:\n    Input: [(0,1,10), (0,2,6), (0,3,5), (1,3,15), (2,3,4)], 4\n    Output: [(2,3,4), (0,3,5), (0,1,10)]\n    \n    Input: [(0,1,1), (1,2,2), (2,3,3), (3,4,4), (4,0,5), (1,4,6)], 5\n    Output: [(0,1,1), (1,2,2), (2,3,3), (3,4,4)]\n    \"\"\"\n", "entry_point": "optimize_network", "solution": "    \n    def find(parent, i):\n        if parent[i] == i:\n            return i\n        return find(parent, parent[i])\n    \n    def union(parent, rank, x, y):\n        xroot = find(parent, x)\n        yroot = find(parent, y)\n        \n        if rank[xroot] < rank[yroot]:\n            parent[xroot] = yroot\n        elif rank[xroot] > rank[yroot]:\n            parent[yroot] = xroot\n        else:\n            parent[yroot] = xroot\n            rank[xroot] += 1\n    \n    # Sort connections based on bandwidth (ascending order)\n    connections.sort(key=lambda x: x[2])\n    \n    parent = list(range(nodes))\n    rank = [0] * nodes\n    \n    mst = []\n    for connection in connections:\n        node1, node2, bandwidth = connection\n        x = find(parent, node1)\n        y = find(parent, node2)\n        \n        if x != y:\n            mst.append(connection)\n            union(parent, rank, x, y)\n    \n    return mst\n", "test": "def check(candidate):\n    assert candidate([(0,1,1), (1,2,2), (2,3,3), (3,4,4), (4,5,5)], 6) == [(0, 1, 1), (1, 2, 2), (2, 3, 3), (3, 4, 4), (4, 5, 5)]\n    assert candidate([(0,1,100), (1,2,200), (2,0,300)], 3) == [(0, 1, 100), (1, 2, 200)]\n    assert candidate([(0,1,1), (0,2,1), (0,3,1), (1,2,1), (1,3,1), (2,3,1)], 4) == [(0, 1, 1), (0, 2, 1), (0, 3, 1)]\n    assert candidate([(0,1,10), (1,2,20), (2,3,30), (3,4,40), (4,0,50)], 5) == [(0, 1, 10), (1, 2, 20), (2, 3, 30), (3, 4, 40)]\n    assert candidate([(0,1,1), (1,2,2), (2,3,3), (3,4,4), (4,0,5), (1,4,6)], 5) == [(0, 1, 1), (1, 2, 2), (2, 3, 3), (3, 4, 4)]\n    assert candidate([(0,1,1), (1,2,1), (2,0,1)], 3) == [(0, 1, 1), (1, 2, 1)]\n    assert candidate([(0,1,10), (0,2,6), (0,3,5), (1,3,15), (2,3,4)], 4) == [(2, 3, 4), (0, 3, 5), (0, 1, 10)]\n    assert candidate([(0,1,5), (1,2,5), (2,3,5), (3,4,5), (4,0,5), (0,2,5), (1,3,5), (2,4,5)], 5) == [(0, 1, 5), (1, 2, 5), (2, 3, 5), (3, 4, 5)]\n    assert candidate([(0,1,1), (1,2,2), (2,3,3), (3,0,4)], 4) == [(0, 1, 1), (1, 2, 2), (2, 3, 3)]\n    assert candidate([(0,1,5), (1,2,5), (2,3,5), (3,0,5)], 4) == [(0, 1, 5), (1, 2, 5), (2, 3, 5)]\n", "language": "python"}
{"task_id": "revision1a_problem502", "prompt": "import math\nfrom typing import List, Tuple\n\ndef optimize_delivery_route(locations: List[Tuple[float, float]]) -> List[int]:\n    \"\"\"\n    You are tasked with optimizing a delivery route for a logistics company.\n    Given a list of customer locations represented as (x, y) coordinates, find the most efficient route\n    that visits all locations exactly once and returns to the starting point (depot).\n    This is known as the Traveling Salesman Problem (TSP).\n    Implement a function that takes a list of coordinate tuples and returns the optimal route as a list of indices.\n    \n    Note: For simplicity, use a nearest neighbor heuristic approach. Start from the depot (first location),\n    and always move to the nearest unvisited location until all locations are visited.\n    \n    Example:\n    Input: [(0, 0), (1, 5), (2, 2), (5, 3), (6, 1)]\n    Output: [0, 2, 1, 3, 4, 0]\n    \n    Input: [(0, 0), (2, 4), (3, 1), (5, 3)]\n    Output: [0, 2, 3, 1, 0]\n    \n    The function should handle cases with at least 2 locations (including the depot).\n    \"\"\"\n", "entry_point": "optimize_delivery_route", "solution": "    def distance(loc1: Tuple[float, float], loc2: Tuple[float, float]) -> float:\n        return math.sqrt((loc1[0] - loc2[0])**2 + (loc1[1] - loc2[1])**2)\n\n    n = len(locations)\n    if n < 2:\n        return []\n\n    unvisited = set(range(1, n))  # Exclude depot (index 0)\n    route = [0]  # Start from the depot\n    current = 0\n\n    while unvisited:\n        nearest = min(unvisited, key=lambda x: distance(locations[current], locations[x]))\n        route.append(nearest)\n        unvisited.remove(nearest)\n        current = nearest\n\n    route.append(0)  # Return to the depot\n    return route\n", "test": "def check(candidate):\n    assert candidate([(0, 0), (0.1, 0.1), (0.2, 0.2), (0.3, 0.3)]) == [0, 1, 2, 3, 0]\n    assert candidate([(0, 0), (1, 1)]) == [0, 1, 0]\n    assert candidate([(0, 0), (1, 5), (2, 2), (5, 3), (6, 1)]) == [0, 2, 1, 3, 4, 0]\n    assert candidate([(0, 0), (-1, -1), (-2, -2), (-3, -3), (-4, -4)]) == [0, 1, 2, 3, 4, 0]\n    assert candidate([(0, 0), (1, 0), (2, 0), (3, 0), (4, 0)]) == [0, 1, 2, 3, 4, 0]\n    assert candidate([(-1, -1), (1, 1), (2, 2), (3, 3), (4, 4)]) == [0, 1, 2, 3, 4, 0]\n    assert candidate([(0, 0), (1, 1), (2, 2), (3, 3), (4, 4), (5, 5)]) == [0, 1, 2, 3, 4, 5, 0]\n    assert candidate([(0, 0), (10, 10), (20, 20), (30, 30), (40, 40)]) == [0, 1, 2, 3, 4, 0]\n    assert candidate([(0, 0), (0, 1), (0, 2), (0, 3), (0, 4)]) == [0, 1, 2, 3, 4, 0]\n    assert candidate([(0, 0), (2, 4), (3, 1), (5, 3)]) == [0, 2, 3, 1, 0]\n", "language": "python"}
{"task_id": "revision1a_problem395", "prompt": "from typing import List, Tuple\nimport heapq\n\ndef optimize_delivery_routes(warehouses: int, connections: List[Tuple[int, int, int]], start: int, end: int) -> Tuple[int, List[int]]:\n    \"\"\"\n    A logistics company wants to optimize its delivery routes between warehouses. \n    Given a network of warehouses and the roads connecting them, find the shortest path \n    and the total distance from a start warehouse to an end warehouse.\n\n    Parameters:\n    warehouses (int): The number of warehouses in the network.\n    connections (List[Tuple[int, int, int]]): A list of tuples representing roads. \n                                              Each tuple contains (from_warehouse, to_warehouse, distance).\n    start (int): The starting warehouse number.\n    end (int): The destination warehouse number.\n\n    Returns:\n    Tuple[int, List[int]]: A tuple containing the total distance and the list of warehouses in the shortest path.\n\n    Example:\n    Input: 5, [(0,1,10), (0,2,5), (1,2,2), (1,3,1), (2,1,3), (2,3,9), (2,4,2), (3,4,4), (4,3,6), (4,0,7)], 0, 4\n    Output: (7, [0, 2, 4])\n\n    This function uses Dijkstra's algorithm with a priority queue to find the shortest path.\n    \"\"\"\n", "entry_point": "optimize_delivery_routes", "solution": "    # Create an adjacency list to represent the graph\n    graph = [[] for _ in range(warehouses)]\n    for from_w, to_w, distance in connections:\n        graph[from_w].append((to_w, distance))\n\n    # Initialize distances and previous nodes\n    distances = [float('inf')] * warehouses\n    distances[start] = 0\n    previous = [-1] * warehouses\n\n    # Priority queue to store (distance, node) pairs\n    pq = [(0, start)]\n\n    while pq:\n        current_distance, current_node = heapq.heappop(pq)\n\n        # If we've reached the end node, we're done\n        if current_node == end:\n            break\n\n        # If we've found a longer path, skip\n        if current_distance > distances[current_node]:\n            continue\n\n        # Check all neighboring nodes\n        for neighbor, weight in graph[current_node]:\n            distance = current_distance + weight\n\n            # If we've found a shorter path, update it\n            if distance < distances[neighbor]:\n                distances[neighbor] = distance\n                previous[neighbor] = current_node\n                heapq.heappush(pq, (distance, neighbor))\n\n    # Reconstruct the path\n    path = []\n    current = end\n    while current != -1:\n        path.append(current)\n        current = previous[current]\n    path.reverse()\n\n    # Check if a path was found\n    if distances[end] == float('inf'):\n        return (-1, [])  # No path found\n\n    return (distances[end], path)\n", "test": "def check(candidate):\n    assert candidate(6, [(0,1,2), (1,2,3), (2,3,4), (3,4,5), (4,5,6)], 0, 5) == (20, [0, 1, 2, 3, 4, 5])\n    assert candidate(2, [(0,1,5)], 0, 1) == (5, [0, 1])\n    assert candidate(4, [(0,1,1), (1,2,1), (2,3,1), (3,0,1)], 0, 3) == (3, [0, 1, 2, 3])\n    assert candidate(5, [(0,1,10), (1,2,20), (2,3,30), (3,4,40), (0,4,50)], 0, 4) == (50, [0, 4])\n    assert candidate(3, [(0,1,5), (1,2,5), (0,2,15)], 0, 2) == (10, [0, 1, 2])\n    assert candidate(5, [(0,1,10), (0,2,5), (1,2,2), (1,3,1), (2,1,3), (2,3,9), (2,4,2), (3,4,4), (4,3,6), (4,0,7)], 0, 4) == (7, [0, 2, 4])\n    assert candidate(4, [(0,1,3), (1,2,1), (2,3,4), (0,3,10)], 0, 3) == (8, [0, 1, 2, 3])\n    assert candidate(3, [(0,1,1), (1,2,2), (0,2,4)], 0, 2) == (3, [0, 1, 2])\n    assert candidate(6, [(0,1,1), (1,2,2), (2,3,3), (3,4,4), (4,5,5), (0,5,20)], 0, 5) == (15, [0, 1, 2, 3, 4, 5])\n    assert candidate(7, [(0,1,1), (1,2,1), (2,3,1), (3,4,1), (4,5,1), (5,6,1)], 0, 6) == (6, [0, 1, 2, 3, 4, 5, 6])\n", "language": "python"}
{"task_id": "revision1a_problem246", "prompt": "from typing import List\nimport random\n\ndef cipher_generator(message: str, shift: int) -> str:\n    \"\"\"\n    Create a Caesar cipher encryption function that shifts each letter in the message by a specified number of positions in the alphabet.\n\n    The function should:\n    1. Accept lowercase and uppercase letters\n    2. Preserve spaces and punctuation\n    3. Wrap around the alphabet (e.g., 'z' shifted by 1 becomes 'a')\n    4. Handle shifts greater than 26 by taking the modulo 26\n\n    Also, create a decryption function that reverses the process.\n\n    Example:\n    Input: (\"Hello, World!\", 3)\n    Output: \"Khoor, Zruog!\"\n\n    Input: (\"Khoor, Zruog!\", -3)\n    Output: \"Hello, World!\"\n\n    This cipher could be used for basic message encryption in a secure communication app.\n    \"\"\"\n", "entry_point": "cipher_generator", "solution": "    def shift_char(char: str, shift: int) -> str:\n        if not char.isalpha():\n            return char\n        \n        ascii_offset = 65 if char.isupper() else 97\n        shifted = (ord(char) - ascii_offset + shift) % 26\n        return chr(shifted + ascii_offset)\n\n    def encrypt(text: str, shift: int) -> str:\n        return ''.join(shift_char(char, shift) for char in text)\n\n    def decrypt(text: str, shift: int) -> str:\n        return encrypt(text, -shift)\n\n    if shift >= 0:\n        return encrypt(message, shift)\n    else:\n        return decrypt(message, -shift)\n", "test": "def check(candidate):\n    assert candidate(\"Python is awesome!\", 26) == 'Python is awesome!'\n    assert candidate(\"Edge case\", 100) == 'Azca ywoa'\n    assert candidate(\"abcdefghijklmnopqrstuvwxyz\", 1) == 'bcdefghijklmnopqrstuvwxyza'\n    assert candidate(\"ABCDEFGHIJKLMNOPQRSTUVWXYZ\", 1) == 'BCDEFGHIJKLMNOPQRSTUVWXYZA'\n    assert candidate(\"Khoor, Zruog!\", -3) == 'Hello, World!'\n    assert candidate(\"Mixed Case Test\", 13) == 'Zvkrq Pnfr Grfg'\n    assert candidate(\"Negative shift\", -5) == 'Izbvodqz ncdao'\n    assert candidate(\"Hello, World!\", 3) == 'Khoor, Zruog!'\n    assert candidate(\"Cipher test\", 0) == 'Cipher test'\n    assert candidate(\"The quick brown fox jumps over the lazy dog.\", 5) == 'Ymj vznhp gwtbs ktc ozrux tajw ymj qfed itl.'\n", "language": "python"}
{"task_id": "revision1a_problem264", "prompt": "from typing import List\n\ndef optimize_delivery_route(addresses: List[str], max_stops: int) -> List[str]:\n    \"\"\"\n    A delivery driver needs to optimize their route to maximize the number of packages delivered within a limited number of stops.\n\n    Given a list of delivery addresses and the maximum number of stops allowed, return the optimal subset of addresses that maximizes the number of deliveries while staying within the stop limit.\n\n    Example:\n    Input: addresses = ['123 Main St', '456 Elm St', '789 Oak St', '321 Pine St', '654 Maple St'], max_stops = 3\n    Output: ['123 Main St', '456 Elm St', '321 Pine St']\n\n    Input: addresses = ['10 First Ave', '20 Second Ave', '30 Third Ave'], max_stops = 4\n    Output: ['10 First Ave', '20 Second Ave', '30 Third Ave']\n    \"\"\"\n", "entry_point": "optimize_delivery_route", "solution": "    # If max_stops is greater than or equal to the number of addresses,\n    # return all addresses as they can all be visited\n    if max_stops >= len(addresses):\n        return addresses\n    \n    # Otherwise, return the first max_stops addresses\n    return addresses[:max_stops]\n", "test": "def check(candidate):\n    assert candidate([], 3) == []\n", "language": "python"}
{"task_id": "revision1a_problem59", "prompt": "import heapq\nfrom typing import List, Tuple\nfrom collections import defaultdict\n\ndef schedule_tasks(tasks: List[Tuple[str, int, List[str]]]) -> List[str]:\n    \"\"\"\n    You are developing a task scheduler for a complex project management system. \n    Given a list of tasks, each with a name, duration, and list of prerequisite tasks, \n    determine a valid schedule that completes all tasks as quickly as possible.\n\n    Use topological sorting and a priority queue to solve this problem efficiently.\n\n    Parameters:\n    tasks (List[Tuple[str, int, List[str]]]): List of tasks, each represented by a tuple containing:\n        - task name (str)\n        - duration in days (int)\n        - list of prerequisite task names (List[str])\n\n    Returns:\n    List[str]: A list of task names in the order they should be completed\n\n    Example:\n    Input:\n    tasks = [\n        (\"Write proposal\", 3, []),\n        (\"Develop prototype\", 5, [\"Write proposal\"]),\n        (\"Test prototype\", 2, [\"Develop prototype\"]),\n        (\"Gather feedback\", 3, [\"Test prototype\"]),\n        (\"Refine product\", 4, [\"Gather feedback\"]),\n        (\"Launch product\", 1, [\"Refine product\"])\n    ]\n\n    Output: [\"Write proposal\", \"Develop prototype\", \"Test prototype\", \"Gather feedback\", \"Refine product\", \"Launch product\"]\n    \"\"\"\n", "entry_point": "schedule_tasks", "solution": "    # Create a graph representation of the tasks\n    graph = defaultdict(list)\n    in_degree = defaultdict(int)\n    duration = {}\n\n    for task, dur, prereqs in tasks:\n        duration[task] = dur\n        for prereq in prereqs:\n            graph[prereq].append(task)\n            in_degree[task] += 1\n\n    # Initialize the priority queue with tasks that have no prerequisites\n    pq = [(0, task) for task, dur, prereqs in tasks if not prereqs]\n    heapq.heapify(pq)\n\n    schedule = []\n    time = 0\n\n    while pq:\n        task_time, task = heapq.heappop(pq)\n        time = max(time, task_time)\n        schedule.append(task)\n\n        for next_task in graph[task]:\n            in_degree[next_task] -= 1\n            if in_degree[next_task] == 0:\n                heapq.heappush(pq, (time + duration[task], next_task))\n\n    return schedule\n", "test": "def check(candidate):\n    assert candidate([(\"Task1\", 1, []), (\"Task2\", 2, []), (\"Task3\", 3, []), (\"Task4\", 4, [\"Task1\", \"Task2\", \"Task3\"])]) == ['Task1', 'Task2', 'Task3', 'Task4']\n    assert candidate([(\"Task1\", 3, []), (\"Task2\", 2, [\"Task1\"]), (\"Task3\", 1, [\"Task2\"])]) == ['Task1', 'Task2', 'Task3']\n    assert candidate([(\"A\", 1, []), (\"B\", 2, []), (\"C\", 3, [])]) == ['A', 'B', 'C']\n    assert candidate([(\"Write\", 2, []), (\"Code\", 5, [\"Write\"]), (\"Test\", 3, [\"Code\"]), (\"Deploy\", 1, [\"Test\"])]) == ['Write', 'Code', 'Test', 'Deploy']\n    assert candidate([(\"Start\", 1, []), (\"Middle\", 2, [\"Start\"]), (\"End\", 1, [\"Middle\", \"Start\"])]) == ['Start', 'Middle', 'End']\n    assert candidate([(\"Task1\", 1, []), (\"Task2\", 1, []), (\"Task3\", 1, [\"Task1\", \"Task2\"])]) == ['Task1', 'Task2', 'Task3']\n    assert candidate([(\"A\", 1, []), (\"B\", 1, [\"A\"]), (\"C\", 1, [\"B\"]), (\"D\", 1, [\"C\"]), (\"E\", 1, [\"D\"])]) == ['A', 'B', 'C', 'D', 'E']\n    assert candidate([(\"A\", 1, []), (\"B\", 2, [\"A\"]), (\"C\", 3, [\"A\"]), (\"D\", 4, [\"B\", \"C\"])]) == ['A', 'B', 'C', 'D']\n    assert candidate([(\"Design\", 3, []), (\"Implement\", 5, [\"Design\"]), (\"Test\", 2, [\"Implement\"]), (\"Document\", 2, [\"Design\"])]) == ['Design', 'Document', 'Implement', 'Test']\n    assert candidate([(\"A\", 5, []), (\"B\", 3, [\"A\"]), (\"C\", 2, [\"A\"]), (\"D\", 1, [\"B\", \"C\"])]) == ['A', 'B', 'C', 'D']\n", "language": "python"}
{"task_id": "revision1a_problem322", "prompt": "from typing import List\n\ndef traffic_flow(cars: List[int]) -> int:\n    \"\"\"\n    Imagine you are a traffic controller at a busy intersection. Cars are lined up at a traffic light, represented by a list of integers 'cars', where each integer is the speed of the car.\n    Your task is to maximize the flow of traffic by allowing cars to pass in a specific order:\n    1. If the first car in line has the highest speed, let it pass and remove it from the queue.\n    2. Otherwise, move the first car to the end of the queue.\n    The goal is to determine how many operations (letting a car pass or moving it to the end) it takes to clear the entire queue.\n    \n    Take a list 'cars' as input from the user and return the number of operations needed to clear the queue.\n    \n    Example 1:\n    Input: [5,3,7,4]\n    Output: 6\n    \n    Example 2:\n    Input: [3,3,3,3,3]\n    Output: 5\n    \"\"\"\n", "entry_point": "traffic_flow", "solution": "    operations = 0\n    queue = cars.copy()  # Create a copy of the input list to avoid modifying the original\n\n    while queue:\n        if queue[0] == max(queue):\n            queue.pop(0)  # Let the car pass\n        else:\n            queue.append(queue.pop(0))  # Move the first car to the end\n        operations += 1\n\n    return operations\n", "test": "def check(candidate):\n    assert candidate([100,99,98,97,96,95]) == 6\n    assert candidate([5,4,3,2,1]) == 5\n    assert candidate([10]) == 1\n    assert candidate([1,1,1,1,1,2]) == 11\n    assert candidate([1,2,3,4,5]) == 15\n    assert candidate([1,2,1,2,1,2,1,2]) == 12\n    assert candidate([1,10,2,9,3,8,4,7,5,6]) == 25\n    assert candidate([5,3,7,4]) == 8\n    assert candidate([3,3,3,3,3]) == 5\n    assert candidate([5,5,5,5,5,4]) == 6\n", "language": "python"}
{"task_id": "revision1a_problem381", "prompt": "from typing import List, Tuple\nimport math\n\ndef optimize_delivery_route(locations: List[Tuple[float, float]], start: Tuple[float, float]) -> List[int]:\n    \"\"\"\n    A food delivery company wants to optimize their delivery route to minimize travel time and fuel consumption.\n    Given a list of customer locations (as latitude and longitude coordinates) and the starting point of the delivery driver,\n    determine the optimal order to visit all locations.\n\n    This problem is a variation of the Traveling Salesman Problem, which is NP-hard. Implement a heuristic algorithm\n    (such as Nearest Neighbor or 2-opt) to find a good approximation of the optimal route.\n\n    Args:\n    locations (List[Tuple[float, float]]): List of (latitude, longitude) tuples representing customer locations\n    start (Tuple[float, float]): (latitude, longitude) tuple representing the starting point\n\n    Returns:\n    List[int]: A list of indices representing the optimal order to visit the locations\n\n    Example:\n    Input: [(40.7128, -74.0060), (34.0522, -118.2437), (41.8781, -87.6298)], (42.3601, -71.0589)\n    Output: [2, 0, 1]  # Visit Chicago, then New York, then Los Angeles\n    \"\"\"\n", "entry_point": "optimize_delivery_route", "solution": "    def haversine_distance(loc1: Tuple[float, float], loc2: Tuple[float, float]) -> float:\n        \"\"\"Calculate the great circle distance between two points on the Earth\"\"\"\n        lat1, lon1 = math.radians(loc1[0]), math.radians(loc1[1])\n        lat2, lon2 = math.radians(loc2[0]), math.radians(loc2[1])\n        \n        dlat = lat2 - lat1\n        dlon = lon2 - lon1\n        \n        a = math.sin(dlat/2)**2 + math.cos(lat1) * math.cos(lat2) * math.sin(dlon/2)**2\n        c = 2 * math.asin(math.sqrt(a))\n        r = 6371  # Radius of Earth in kilometers\n        \n        return c * r\n\n    unvisited = set(range(len(locations)))\n    route = []\n    current = start\n\n    while unvisited:\n        nearest = min(unvisited, key=lambda x: haversine_distance(current, locations[x]))\n        route.append(nearest)\n        unvisited.remove(nearest)\n        current = locations[nearest]\n\n    return route\n", "test": "def check(candidate):\n    assert candidate([(0.1, 0.1), (0.2, 0.2), (0.3, 0.3)], (0.0, 0.0)) == [0, 1, 2]\n    assert candidate([(40.7128, -74.0060), (34.0522, -118.2437), (41.8781, -87.6298)], (42.3601, -71.0589)) == [0, 2, 1]\n    assert candidate([(0.0, 0.0)], (0.0, 0.0)) == [0]\n    assert candidate([(1.0, 1.0)] * 10, (0.0, 0.0)) == [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]\n    assert candidate([(1.0, 1.0), (2.0, 2.0), (3.0, 3.0), (4.0, 4.0), (5.0, 5.0)], (0.0, 0.0)) == [0, 1, 2, 3, 4]\n    assert candidate([(-90.0, -180.0), (90.0, 180.0)], (0.0, 0.0)) == [0, 1]\n    assert candidate([(1.0, 1.0), (2.0, 2.0), (3.0, 3.0)], (0.0, 0.0)) == [0, 1, 2]\n    assert candidate([(0.0, 0.0), (0.0, 0.0), (0.0, 0.0)], (1.0, 1.0)) == [0, 1, 2]\n    assert candidate([], (0.0, 0.0)) == []\n    assert candidate([(90.0, 0.0), (0.0, 180.0), (-90.0, 0.0), (0.0, -180.0)], (0.0, 0.0)) == [0, 1, 3, 2]\n", "language": "python"}
{"task_id": "revision1a_problem432", "prompt": "import math\nfrom typing import List, Tuple\n\ndef optimize_delivery_route(packages: List[Tuple[int, int]], fuel_capacity: int) -> List[int]:\n    \"\"\"\n    You are a delivery driver for an e-commerce company. You need to deliver packages to various locations,\n    represented by (x, y) coordinates. Your task is to implement a function that determines the optimal\n    order of deliveries to maximize the number of packages delivered before running out of fuel.\n\n    The function should:\n    1. Sort the packages based on their distance from the origin (0, 0)\n    2. Calculate the cumulative fuel consumption for each delivery\n    3. Return the indices of packages that can be delivered within the fuel capacity\n\n    Take input from the user for the list of package coordinates and the fuel capacity.\n    Use dynamic programming to solve this problem efficiently.\n\n    Example:\n    Input: packages = [(1, 2), (3, 4), (5, 6), (7, 8)], fuel_capacity = 20\n    Output: [0, 1, 2]  # Indices of packages that can be delivered\n    \"\"\"\n", "entry_point": "optimize_delivery_route", "solution": "    def calculate_distance(x: int, y: int) -> float:\n        return math.sqrt(x**2 + y**2)\n\n    # Sort packages based on distance from origin\n    sorted_packages = sorted(enumerate(packages), key=lambda p: calculate_distance(p[1][0], p[1][1]))\n\n    # Initialize dynamic programming table\n    dp = [[0] * (fuel_capacity + 1) for _ in range(len(packages) + 1)]\n\n    # Fill the dynamic programming table\n    for i in range(1, len(packages) + 1):\n        for j in range(fuel_capacity + 1):\n            prev_max = dp[i-1][j]\n            curr_distance = int(calculate_distance(sorted_packages[i-1][1][0], sorted_packages[i-1][1][1]))\n            \n            if j >= curr_distance:\n                dp[i][j] = max(prev_max, dp[i-1][j-curr_distance] + 1)\n            else:\n                dp[i][j] = prev_max\n\n    # Backtrack to find the optimal route\n    optimal_route = []\n    i, j = len(packages), fuel_capacity\n    while i > 0 and j > 0:\n        if dp[i][j] != dp[i-1][j]:\n            optimal_route.append(sorted_packages[i-1][0])\n            j -= int(calculate_distance(sorted_packages[i-1][1][0], sorted_packages[i-1][1][1]))\n        i -= 1\n\n    return sorted(optimal_route)\n", "test": "def check(candidate):\n    assert candidate([], 100) == []\n    assert candidate([(10, 10)], 15) == [0]\n    assert candidate([(1, 1), (2, 2), (3, 3), (4, 4), (5, 5)], 30) == [0, 1, 2, 3, 4]\n    assert candidate([(100, 100), (200, 200), (300, 300)], 1000) == [0, 1, 2]\n    assert candidate([(0, 0), (1, 1), (2, 2), (3, 3)], 10) == [0, 1, 2, 3]\n    assert candidate([(1, 1)] * 10, 50) == [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]\n    assert candidate([(0, 1), (1, 0), (1, 1), (2, 2)], 5) == [0, 1, 2, 3]\n    assert candidate([(1, 2), (3, 4), (5, 6), (7, 8)], 20) == [0, 1, 2]\n    assert candidate([(i, i) for i in range(20)], 100) == [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]\n    assert candidate([(3, 4), (5, 12), (8, 15), (7, 24)], 60) == [0, 1, 2, 3]\n", "language": "python"}
{"task_id": "revision1a_problem379", "prompt": "def encode_message(message: str, key: int) -> str:\n    \"\"\"\n    Implement a simple Caesar cipher encryption. Each letter in the message should be shifted \n    by the given key value. If shifting goes beyond 'z', it should wrap around to 'a'.\n    Only encrypt alphabetic characters, leaving numbers and special characters unchanged.\n    This function could be used in a secure communication system for beginners.\n\n    Take a string message and an integer key as input from the user, return the encoded message as a string.\n\n    Example:\n    Input: message = \"Hello, World!\", key = 3\n    Output: \"Khoor, Zruog!\"\n\n    Input: message = \"Python3.9\", key = 7\n    Output: \"Wfaovu3.9\"\n    \"\"\"\n", "entry_point": "encode_message", "solution": "    def shift_char(char: str, shift: int) -> str:\n        if not char.isalpha():\n            return char\n        \n        ascii_offset = ord('A') if char.isupper() else ord('a')\n        shifted = (ord(char) - ascii_offset + shift) % 26\n        return chr(shifted + ascii_offset)\n\n    encoded_message = ''.join(shift_char(char, key) for char in message)\n    return encoded_message\n", "test": "def check(candidate):\n    assert candidate(\"a\", 0) == 'a'\n    assert candidate(\"Python3.9\", 7) == 'Wfaovu3.9'\n    assert candidate(\"ZzYyXx\", 2) == 'BbAaZz'\n    assert candidate(\"\", 5) == ''\n    assert candidate(\"Mixed Case 123\", 15) == 'Bxmts Rpht 123'\n    assert candidate(\"ABCDEFGHIJKLMNOPQRSTUVWXYZ\", 26) == 'ABCDEFGHIJKLMNOPQRSTUVWXYZ'\n    assert candidate(\"1234567890!@#$%^&*()\", 10) == '1234567890!@#$%^&*()'\n    assert candidate(\"Wrap around test\", 30) == 'Avet evsyrh xiwx'\n    assert candidate(\"Hello, World!\", 3) == 'Khoor, Zruog!'\n    assert candidate(\"abcdefghijklmnopqrstuvwxyz\", 1) == 'bcdefghijklmnopqrstuvwxyza'\n", "language": "python"}
{"task_id": "revision1a_problem355", "prompt": "from typing import List\nimport heapq\n\ndef optimize_wind_farm(grid: List[List[int]], turbine_radius: int) -> int:\n    \"\"\"\n    An energy company wants to build a wind farm on a rectangular plot of land. The land is represented\n    by a grid where each cell contains an integer representing the wind speed at that location.\n\n    Wind turbines can be placed on any cell, but they interfere with each other if placed too close.\n    Each turbine has an interference radius, within which no other turbine can be placed.\n\n    Your task is to determine the maximum number of turbines that can be placed on the grid\n    while respecting the interference constraint and maximizing the total wind speed captured.\n\n    Use a greedy approach with a priority queue to solve this problem efficiently.\n\n    Parameters:\n    grid (List[List[int]]): 2D grid representing wind speeds at each location\n    turbine_radius (int): Interference radius of each turbine\n\n    Returns:\n    int: Maximum number of turbines that can be placed\n\n    Example:\n    Input: [[3,5,4],[2,7,6],[1,8,9]], 1\n    Output: 3\n    \"\"\"\n", "entry_point": "optimize_wind_farm", "solution": "    rows, cols = len(grid), len(grid[0])\n    turbines_placed = 0\n    heap = [(-grid[i][j], i, j) for i in range(rows) for j in range(cols)]\n    heapq.heapify(heap)\n    \n    def is_valid(x, y):\n        return 0 <= x < rows and 0 <= y < cols\n    \n    def place_turbine(x, y):\n        for dx in range(-turbine_radius, turbine_radius + 1):\n            for dy in range(-turbine_radius, turbine_radius + 1):\n                if dx * dx + dy * dy <= turbine_radius * turbine_radius:\n                    nx, ny = x + dx, y + dy\n                    if is_valid(nx, ny):\n                        grid[nx][ny] = 0\n    \n    while heap:\n        _, x, y = heapq.heappop(heap)\n        if grid[x][y] > 0:\n            turbines_placed += 1\n            place_turbine(x, y)\n    \n    return turbines_placed\n", "test": "def check(candidate):\n    assert candidate([[1,1,1],[1,9,1],[1,1,1]], 1) == 5\n    assert candidate([[1,2],[3,4],[5,6]], 0) == 6\n    assert candidate([[5,5,5,5],[5,5,5,5],[5,5,5,5]], 2) == 3\n    assert candidate([[10,20,30],[40,50,60],[70,80,90]], 2) == 2\n    assert candidate([[100]], 5) == 1\n    assert candidate([[3,5,4],[2,7,6],[1,8,9]], 1) == 5\n    assert candidate([[1,2],[3,4]], 1) == 2\n    assert candidate([[1,2,3,4,5],[6,7,8,9,10],[11,12,13,14,15],[16,17,18,19,20],[21,22,23,24,25]], 1) == 13\n    assert candidate([[1,1,1],[1,1,1],[1,1,1]], 1) == 5\n    assert candidate([[1]], 0) == 1\n", "language": "python"}
{"task_id": "revision1a_problem692", "prompt": "import math\nfrom typing import List, Tuple\n\ndef optimize_delivery_route(locations: List[Tuple[float, float]], capacity: int) -> List[int]:\n    \"\"\"\n    A delivery company needs to optimize their route for a truck with limited capacity.\n    Given a list of customer locations as (x, y) coordinates and the truck's capacity,\n    determine the optimal order to visit customers to minimize total distance traveled.\n\n    The truck must return to the depot (0, 0) when full and can make multiple trips.\n    Use a greedy approach with nearest neighbor heuristic and consider capacity constraints.\n\n    Input: \n    - locations: List of tuples representing (x, y) coordinates of customer locations\n    - capacity: Integer representing the truck's maximum capacity (number of deliveries)\n\n    Output: List of integers representing the optimal order to visit customers\n\n    Example:\n    Input: [(1, 2), (3, 4), (5, 6), (7, 8)], 2\n    Output: [0, 1, 0, 2, 3]\n    \n    Explanation: The truck visits customer 0, then 1, returns to depot, visits 2, then 3.\n    \"\"\"\n", "entry_point": "optimize_delivery_route", "solution": "    def distance(loc1, loc2):\n        return math.sqrt((loc1[0] - loc2[0])**2 + (loc1[1] - loc2[1])**2)\n\n    unvisited = set(range(len(locations)))\n    route = []\n    current_location = (0, 0)  # Depot\n    current_capacity = capacity\n\n    while unvisited:\n        if current_capacity == 0:\n            route.append(0)  # Return to depot\n            current_location = (0, 0)\n            current_capacity = capacity\n\n        nearest = min(unvisited, key=lambda x: distance(current_location, locations[x]))\n        route.append(nearest)\n        unvisited.remove(nearest)\n        current_location = locations[nearest]\n        current_capacity -= 1\n\n    if current_location != (0, 0):\n        route.append(0)  # Return to depot at the end\n\n    return route\n", "test": "def check(candidate):\n    assert candidate([(1, 1), (-1, -1), (2, 2), (-2, -2)], 2) == [0, 2, 0, 1, 3, 0]\n    assert candidate([(10, 10), (20, 20), (30, 30), (40, 40)], 3) == [0, 1, 2, 0, 3, 0]\n    assert candidate([(1, 1), (2, 2), (3, 3), (4, 4), (5, 5)], 3) == [0, 1, 2, 0, 3, 4, 0]\n    assert candidate([(0, 1), (0, 2), (0, 3), (0, 4), (0, 5)], 5) == [0, 1, 2, 3, 4, 0]\n    assert candidate([(1, 0), (2, 0), (3, 0), (4, 0), (5, 0)], 4) == [0, 1, 2, 3, 0, 4, 0]\n    assert candidate([(0.5, 0.5), (1.5, 1.5), (2.5, 2.5)], 1) == [0, 0, 1, 0, 2, 0]\n    assert candidate([(1, 2), (3, 4), (5, 6), (7, 8)], 2) == [0, 1, 0, 2, 3, 0]\n    assert candidate([], 5) == []\n    assert candidate([(1, 1)], 1) == [0, 0]\n    assert candidate([(1, 1), (2, 2), (3, 3)], 10) == [0, 1, 2, 0]\n", "language": "python"}
{"task_id": "revision1a_problem353", "prompt": "from itertools import permutations\nfrom typing import List\n\ndef optimize_delivery_route(locations: List[List[int]], fuel: int) -> int:\n    \"\"\"\n    As a logistics manager for an e-commerce company, you need to optimize the delivery route for a drone.\n    The drone starts at the origin (0, 0) and needs to visit all given locations exactly once before returning\n    to the origin. However, the drone has a limited amount of fuel.\n\n    You are given a list of locations, where each location is represented by its x and y coordinates [x, y].\n    You are also given the amount of fuel the drone has. The drone uses 1 unit of fuel to move 1 unit in any direction.\n\n    Your task is to determine the maximum number of locations the drone can visit before running out of fuel and \n    returning to the origin. If the drone cannot return to the origin after visiting a location, that location \n    is not counted.\n\n    Example 1:\n    Input: locations = [[1, 2], [3, 4], [-1, -2]], fuel = 20\n    Output: 3\n\n    Example 2:\n    Input: locations = [[2, 3], [-4, -5], [6, -7], [1, 1]], fuel = 25\n    Output: 2\n\n    Take the list of locations and the amount of fuel as input from the user and return the maximum number of \n    locations that can be visited.\n    \"\"\"\n", "entry_point": "optimize_delivery_route", "solution": "    def calculate_distance(point1, point2):\n        return abs(point1[0] - point2[0]) + abs(point1[1] - point2[1])\n\n    def can_visit_locations(route):\n        fuel_left = fuel\n        current_location = [0, 0]\n        \n        for location in route:\n            distance = calculate_distance(current_location, location)\n            if fuel_left < distance:\n                return False\n            fuel_left -= distance\n            current_location = location\n        \n        return_distance = calculate_distance(current_location, [0, 0])\n        return fuel_left >= return_distance\n\n    max_locations = 0\n    \n    for i in range(1, len(locations) + 1):\n        for route in permutations(locations, i):\n            if can_visit_locations(route):\n                max_locations = max(max_locations, len(route))\n            else:\n                break\n    \n    return max_locations\n", "test": "def check(candidate):\n    assert candidate([[3, 4], [-3, -4], [5, 12], [-5, -12]], 50) == 2\n    assert candidate([[10, 10]], 39) == 0\n    assert candidate([[0, 1], [1, 0], [-1, 0], [0, -1]], 10) == 4\n    assert candidate([], 10) == 0\n    assert candidate([[1, 1], [-1, -1], [2, -2], [-2, 2]], 15) == 3\n    assert candidate([[1, 1], [2, 2], [3, 3]], 20) == 3\n    assert candidate([[5, 5], [-5, -5]], 40) == 2\n    assert candidate([[i, i] for i in range(1, 6)], 50) == 5\n    assert candidate([[0, 0]], 5) == 1\n    assert candidate([[1, 1], [2, 2], [3, 3], [4, 4], [5, 5]], 30) == 5\n", "language": "python"}
{"task_id": "revision1a_problem417", "prompt": "from typing import List, Tuple\nimport math\nimport itertools\n\ndef optimize_delivery_route(packages: List[Tuple[float, float]], fuel_capacity: float) -> List[int]:\n    \"\"\"\n    You're a delivery drone operator for an e-commerce company. Your task is to optimize the delivery route\n    for maximum efficiency. You have a list of package coordinates (x, y) and a limited fuel capacity.\n\n    The drone starts at (0, 0) and must return to this point after delivering all packages. It can carry\n    any number of packages but must deliver them in the order they appear in the input list.\n\n    Your goal is to find the optimal order to deliver the packages while minimizing fuel consumption.\n    The drone consumes 1 unit of fuel per unit of distance traveled.\n\n    Parameters:\n    packages (List[Tuple[float, float]]): A list of (x, y) coordinates representing package locations.\n    fuel_capacity (float): The maximum amount of fuel the drone can carry.\n\n    Returns:\n    List[int]: The optimal order of package indices to deliver, or an empty list if it's impossible\n               to deliver all packages with the given fuel capacity.\n\n    Example:\n    Input: packages = [(1.0, 1.0), (2.0, 2.0), (3.0, 3.0)], fuel_capacity = 20.0\n    Output: [0, 1, 2]\n\n    Input: packages = [(5.0, 5.0), (2.0, 3.0), (4.0, 1.0)], fuel_capacity = 15.0\n    Output: [1, 2, 0]\n\n    Note: This problem combines concepts of path optimization, constraint satisfaction, and possibly\n    dynamic programming or greedy algorithms, making it more complex than the provided examples.\n    \"\"\"\n", "entry_point": "optimize_delivery_route", "solution": "    def calculate_distance(point1, point2):\n        return math.sqrt((point1[0] - point2[0])**2 + (point1[1] - point2[1])**2)\n\n    def calculate_total_distance(route):\n        total_distance = 0\n        current_point = (0, 0)\n        for i in route:\n            total_distance += calculate_distance(current_point, packages[i])\n            current_point = packages[i]\n        total_distance += calculate_distance(current_point, (0, 0))\n        return total_distance\n\n    n = len(packages)\n    best_route = []\n    min_distance = float('inf')\n\n    for perm in itertools.permutations(range(n)):\n        distance = calculate_total_distance(perm)\n        if distance <= fuel_capacity and distance < min_distance:\n            min_distance = distance\n            best_route = list(perm)\n\n    return best_route\n", "test": "def check(candidate):\n    assert candidate([(10.0, 10.0)], 20.0) == []\n    assert candidate([(5.0, 5.0), (2.0, 3.0), (4.0, 1.0)], 15.0) == []\n    assert candidate([(1.0, 1.0), (2.0, 2.0), (3.0, 3.0)], 20.0) == [2, 1, 0]\n    assert candidate([(1.0, 1.0)], 5.0) == [0]\n    assert candidate([(1.0, 0.0), (0.0, 1.0), (-1.0, 0.0), (0.0, -1.0)], 8.0) == [0, 1, 2, 3]\n    assert candidate([(0.5, 0.5), (1.0, 1.0), (1.5, 1.5)], 10.0) == [2, 1, 0]\n    assert candidate([], 10.0) == []\n    assert candidate([(-1.0, -1.0), (-2.0, -2.0), (-3.0, -3.0)], 20.0) == [2, 1, 0]\n    assert candidate([(1.0, 1.0), (2.0, 2.0), (3.0, 3.0), (4.0, 4.0), (5.0, 5.0)], 50.0) == [0, 2, 3, 4, 1]\n    assert candidate([(3.0, 4.0), (6.0, 8.0), (9.0, 12.0)], 100.0) == [0, 1, 2]\n", "language": "python"}
{"task_id": "revision1a_problem5", "prompt": "import heapq\nimport math\nfrom typing import List, Tuple\n\ndef optimize_delivery_route(locations: List[Tuple[float, float]], k: int) -> List[Tuple[float, float]]:\n    \"\"\"\n    A food delivery company wants to optimize its delivery routes by selecting the k closest restaurants to its central hub.\n    Given a list of restaurant locations as (x, y) coordinates and an integer k, return the k closest locations to the origin (0, 0).\n\n    The distance between two points (x1, y1) and (x2, y2) is the Euclidean distance: sqrt((x1 - x2)^2 + (y1 - y2)^2).\n\n    Use a max heap to solve this problem efficiently.\n\n    Example:\n    Input: locations = [(1, 3), (-2, 2), (5, -1), (0, 1), (3, 4)], k = 3\n    Output: [(0, 1), (1, 3), (-2, 2)]\n\n    Note: The order of the output doesn't matter as long as it contains the k closest locations.\n    \"\"\"\n", "entry_point": "optimize_delivery_route", "solution": "    def calculate_distance(point):\n        return point[0]**2 + point[1]**2\n\n    max_heap = []\n\n    for location in locations:\n        distance = calculate_distance(location)\n        \n        if len(max_heap) < k:\n            heapq.heappush(max_heap, (-distance, location))\n        elif -distance > max_heap[0][0]:\n            heapq.heappop(max_heap)\n            heapq.heappush(max_heap, (-distance, location))\n\n    return [location for _, location in max_heap]\n", "test": "def check(candidate):\n    assert candidate([(1, 1), (2, 2), (3, 3)], 2) == [(2, 2), (1, 1)]\n    assert candidate([(0, 1), (1, 0), (-1, 0), (0, -1)], 4) == [(-1, 0), (0, -1), (0, 1), (1, 0)]\n    assert candidate([(1, 1)], 1) == [(1, 1)]\n    assert candidate([(0, 0), (0, 0), (0, 0), (1, 1)], 3) == [(0, 0), (0, 0), (0, 0)]\n    assert candidate([(-1, -1), (-2, -2), (-3, -3), (-4, -4)], 2) == [(-2, -2), (-1, -1)]\n    assert candidate([(100, 100), (-100, -100), (50, -50), (-50, 50)], 3) == [(100, 100), (50, -50), (-50, 50)]\n    assert candidate([(0, 0), (0, 1), (1, 0), (1, 1)], 2) == [(0, 1), (0, 0)]\n    assert candidate([(1.5, 2.5), (-3.2, 4.1), (0.5, -1.0), (2.0, 2.0)], 3) == [(1.5, 2.5), (0.5, -1.0), (2.0, 2.0)]\n    assert candidate([(10, 10), (20, 20), (30, 30)], 1) == [(10, 10)]\n    assert candidate([(0, 0), (1, 1), (2, 2), (3, 3), (4, 4)], 3) == [(2, 2), (0, 0), (1, 1)]\n", "language": "python"}
{"task_id": "revision1a_problem535", "prompt": "from collections import deque\nfrom typing import Dict, List, Tuple\n\ndef analyze_social_network(connections: Dict[str, List[str]], start_user: str, target_user: str) -> Tuple[int, List[str]]:\n    \"\"\"\n    A social media platform wants to analyze the connections between users to find the shortest path\n    and degree of separation between any two users in the network.\n\n    Given a dictionary representing user connections, a starting user, and a target user,\n    find the shortest path between them and the degree of separation.\n\n    Use a graph traversal algorithm like Breadth-First Search (BFS) to find the shortest path.\n\n    Parameters:\n    connections (Dict[str, List[str]]): Dictionary where keys are usernames and values are lists of their connections\n    start_user (str): Username of the starting user\n    target_user (str): Username of the target user\n\n    Returns:\n    Tuple[int, List[str]]: A tuple containing the degree of separation (int) and the path of usernames (List[str])\n    If no path exists, return (-1, [])\n\n    Example:\n    Input:\n    connections = {\n        \"Alice\": [\"Bob\", \"Charlie\"],\n        \"Bob\": [\"Alice\", \"David\"],\n        \"Charlie\": [\"Alice\", \"Eve\"],\n        \"David\": [\"Bob\", \"Eve\"],\n        \"Eve\": [\"Charlie\", \"David\"]\n    }\n    start_user = \"Alice\"\n    target_user = \"Eve\"\n\n    Output:\n    (2, [\"Alice\", \"Charlie\", \"Eve\"])\n    \"\"\"\n", "entry_point": "analyze_social_network", "solution": "    if start_user not in connections or target_user not in connections:\n        return (-1, [])\n\n    queue = deque([(start_user, [start_user])])\n    visited = set([start_user])\n\n    while queue:\n        current_user, path = queue.popleft()\n\n        if current_user == target_user:\n            return (len(path) - 1, path)\n\n        for friend in connections[current_user]:\n            if friend not in visited:\n                visited.add(friend)\n                new_path = path + [friend]\n                queue.append((friend, new_path))\n\n    return (-1, [])\n", "test": "def check(candidate):\n    assert candidate({\"A\": [\"B\", \"C\"], \"B\": [\"A\", \"D\"], \"C\": [\"A\", \"D\"], \"D\": [\"B\", \"C\"]}, \"A\", \"D\") == (2, ['A', 'B', 'D'])\n    assert candidate({\"User1\": [\"User2\", \"User3\"], \"User2\": [\"User1\"], \"User3\": [\"User1\"]}, \"User1\", \"User4\") == (-1, [])\n    assert candidate({\"X\": [\"Y\"], \"Y\": [\"Z\"], \"Z\": []}, \"X\", \"Z\") == (2, ['X', 'Y', 'Z'])\n    assert candidate({\"Alice\": [\"Bob\", \"Charlie\"], \"Bob\": [\"Alice\", \"David\"], \"Charlie\": [\"Alice\", \"Eve\"], \"David\": [\"Bob\", \"Eve\"], \"Eve\": [\"Charlie\", \"David\"]}, \"Alice\", \"Eve\") == (2, ['Alice', 'Charlie', 'Eve'])\n    assert candidate({\"User1\": [\"User2\"], \"User2\": [\"User3\"], \"User3\": [\"User4\"], \"User4\": []}, \"User1\", \"User4\") == (3, ['User1', 'User2', 'User3', 'User4'])\n    assert candidate({\"A\": [\"B\"], \"B\": [\"C\"], \"C\": [\"D\"], \"D\": [\"E\"], \"E\": []}, \"A\", \"E\") == (4, ['A', 'B', 'C', 'D', 'E'])\n    assert candidate({\"Solo\": []}, \"Solo\", \"Solo\") == (0, ['Solo'])\n    assert candidate({\"1\": [\"2\", \"3\", \"4\"], \"2\": [\"1\"], \"3\": [\"1\"], \"4\": [\"1\", \"5\"], \"5\": [\"4\"]}, \"1\", \"5\") == (2, ['1', '4', '5'])\n    assert candidate({}, \"NonExistent\", \"AlsoNonExistent\") == (-1, [])\n    assert candidate({\"A\": [\"B\", \"C\"], \"B\": [\"A\", \"D\", \"E\"], \"C\": [\"A\", \"F\"], \"D\": [\"B\"], \"E\": [\"B\"], \"F\": [\"C\"]}, \"A\", \"F\") == (2, ['A', 'C', 'F'])\n", "language": "python"}
{"task_id": "revision1a_problem666", "prompt": "from typing import List\n\ndef decode_alien_message(message: str, dictionary: List[str]) -> List[str]:\n    \"\"\"\n    You've intercepted a message from an alien civilization, but it's in their language.\n    Fortunately, you have a dictionary of all possible alien words.\n\n    The alien message is a string of lowercase letters without any spaces.\n    Your task is to find all possible ways to decode the message into a sequence of valid alien words.\n\n    The decoding should be done in a way that the entire message is consumed, and each decoded word\n    must be present in the given dictionary.\n\n    Take the alien message as a string and the dictionary as a list of strings.\n    Return a list of all possible decodings, where each decoding is represented as a list of words.\n\n    Example:\n    Input: message = \"owoztneoer\", dictionary = [\"on\",\"zone\",\"one\",\"two\",\"er\",\"ow\"]\n    Output: [['ow', 'one', 'er'], ['ow', 'zone', 'er']]\n\n    Example:\n    Input: message = \"abcd\", dictionary = [\"a\",\"b\",\"c\",\"d\",\"ab\",\"cd\",\"abcd\"]\n    Output: [['a', 'b', 'c', 'd'], ['ab', 'cd'], ['abcd']]\n\n    Constraints:\n    1 <= len(message) <= 100\n    1 <= len(dictionary) <= 1000\n    1 <= len(word) <= 100 for each word in dictionary\n    \"\"\"\n", "entry_point": "decode_alien_message", "solution": "    def backtrack(start: int, current_decoding: List[str]) -> None:\n        if start == len(message):\n            result.append(current_decoding[:])\n            return\n\n        for end in range(start + 1, len(message) + 1):\n            word = message[start:end]\n            if word in word_set:\n                current_decoding.append(word)\n                backtrack(end, current_decoding)\n                current_decoding.pop()\n\n    result = []\n    word_set = set(dictionary)\n    backtrack(0, [])\n    return result\n", "test": "def check(candidate):\n    assert candidate(\"abcd\", [\"a\",\"b\",\"c\",\"d\",\"ab\",\"cd\",\"abcd\"]) == [['a', 'b', 'c', 'd'], ['a', 'b', 'cd'], ['ab', 'c', 'd'], ['ab', 'cd'], ['abcd']]\n    assert candidate(\"aaaaa\", [\"a\",\"aa\",\"aaa\",\"aaaa\",\"aaaaa\"]) == [['a', 'a', 'a', 'a', 'a'], ['a', 'a', 'a', 'aa'], ['a', 'a', 'aa', 'a'], ['a', 'a', 'aaa'], ['a', 'aa', 'a', 'a'], ['a', 'aa', 'aa'], ['a', 'aaa', 'a'], ['a', 'aaaa'], ['aa', 'a', 'a', 'a'], ['aa', 'a', 'aa'], ['aa', 'aa', 'a'], ['aa', 'aaa'], ['aaa', 'a', 'a'], ['aaa', 'aa'], ['aaaa', 'a'], ['aaaaa']]\n    assert candidate(\"test\", [\"t\",\"e\",\"s\",\"te\",\"st\",\"tes\",\"test\"]) == [['t', 'e', 's', 't'], ['t', 'e', 'st'], ['te', 's', 't'], ['te', 'st'], ['tes', 't'], ['test']]\n    assert candidate(\"owoztneoer\", [\"on\",\"zone\",\"one\",\"two\",\"er\",\"ow\"]) == []\n    assert candidate(\"\", []) == [[]]\n    assert candidate(\"hello\", [\"he\",\"ll\",\"o\",\"hello\"]) == [['he', 'll', 'o'], ['hello']]\n    assert candidate(\"123456\", [\"1\",\"2\",\"3\",\"4\",\"5\",\"6\",\"12\",\"23\",\"34\",\"45\",\"56\",\"123\",\"456\"]) == [['1', '2', '3', '4', '5', '6'], ['1', '2', '3', '4', '56'], ['1', '2', '3', '45', '6'], ['1', '2', '3', '456'], ['1', '2', '34', '5', '6'], ['1', '2', '34', '56'], ['1', '23', '4', '5', '6'], ['1', '23', '4', '56'], ['1', '23', '45', '6'], ['1', '23', '456'], ['12', '3', '4', '5', '6'], ['12', '3', '4', '56'], ['12', '3', '45', '6'], ['12', '3', '456'], ['12', '34', '5', '6'], ['12', '34', '56'], ['123', '4', '5', '6'], ['123', '4', '56'], ['123', '45', '6'], ['123', '456']]\n    assert candidate(\"xyz\", [\"x\",\"y\",\"z\",\"xy\",\"yz\",\"xyz\"]) == [['x', 'y', 'z'], ['x', 'yz'], ['xy', 'z'], ['xyz']]\n    assert candidate(\"catsanddog\", [\"cat\",\"cats\",\"and\",\"sand\",\"dog\"]) == [['cat', 'sand', 'dog'], ['cats', 'and', 'dog']]\n    assert candidate(\"pineapplepenapple\", [\"apple\",\"pen\",\"applepen\",\"pine\",\"pineapple\"]) == [['pine', 'apple', 'pen', 'apple'], ['pine', 'applepen', 'apple'], ['pineapple', 'pen', 'apple']]\n", "language": "python"}
{"task_id": "revision1a_problem98", "prompt": "def decrypt_caesar_cipher(message: str, shift: int) -> str:\n    \"\"\"\n    As a cryptography enthusiast, I've encountered an ancient Caesar cipher.\n    The Caesar cipher is a simple encryption technique where each letter in the plaintext\n    is shifted a certain number of places down the alphabet.\n\n    Your task is to create a function that decrypts a message encrypted with the Caesar cipher.\n    The function should take two inputs: the encrypted message and the shift value used for encryption.\n    It should return the decrypted message.\n\n    Note: The cipher wraps around the alphabet, and it preserves spaces and punctuation.\n    Assume the input will only contain lowercase letters, spaces, and basic punctuation.\n\n    Take the encrypted message and shift value as input from the user, and return the decrypted message.\n\n    Example:\n    Input: \"khoor zruog!\", 3\n    Output: \"hello world!\n    \"\"\"\n", "entry_point": "decrypt_caesar_cipher", "solution": "    decrypted_message = \"\"\n    for char in message:\n        if char.isalpha():\n            # Shift the character back by the given shift value\n            decrypted_char = chr((ord(char) - ord('a') - shift) % 26 + ord('a'))\n            decrypted_message += decrypted_char\n        else:\n            # Preserve non-alphabetic characters\n            decrypted_message += char\n    \n    return decrypted_message\n", "test": "def check(candidate):\n    assert candidate(\"zzz\", 1) == 'yyy'\n    assert candidate(\"abcdefghijklmnopqrstuvwxyz\", 26) == 'abcdefghijklmnopqrstuvwxyz'\n    assert candidate(\"hello world\", 0) == 'hello world'\n    assert candidate(\"xyz\", 3) == 'uvw'\n    assert candidate(\"\", 5) == ''\n    assert candidate(\"abc\", 1) == 'zab'\n    assert candidate(\"aaa\", 25) == 'bbb'\n    assert candidate(\"a b c\", 1) == 'z a b'\n    assert candidate(\"khoor zruog!\", 3) == 'hello world!'\n    assert candidate(\"qeb nrfzh yoltk clu grjmp lsbo qeb ixwv ald\", 3) == 'nby kocwe vliqh zir dogjm ipyl nby futs xia'\n", "language": "python"}
{"task_id": "revision1a_problem720", "prompt": "from typing import List, Dict\n\ndef inventory_management(transactions: List[List[str]]) -> Dict[str, Dict[str, int]]:\n    \"\"\"\n    Implement an inventory management system for a warehouse.\n    The system should process a list of transactions and update the inventory accordingly.\n    Each transaction is a list containing the following information:\n    [transaction_type, item_name, quantity, location]\n\n    transaction_type can be 'add', 'remove', or 'transfer'\n    quantity is always a positive integer\n    location is the warehouse section (e.g., 'A1', 'B2', etc.)\n\n    For 'transfer' transactions, the list will have 5 elements:\n    [transaction_type, item_name, quantity, from_location, to_location]\n\n    The function should return a nested dictionary representing the final inventory state.\n    The outer dictionary keys are item names, and the inner dictionary keys are locations.\n\n    Example:\n    Input: [\n        ['add', 'apple', '100', 'A1'],\n        ['add', 'banana', '50', 'B2'],\n        ['remove', 'apple', '20', 'A1'],\n        ['transfer', 'banana', '10', 'B2', 'C3'],\n        ['add', 'cherry', '75', 'D4']\n    ]\n    Output: {\n        'apple': {'A1': 80},\n        'banana': {'B2': 40, 'C3': 10},\n        'cherry': {'D4': 75}\n    }\n\n    Note: If the quantity of an item at a location becomes 0, remove that location from the item's inner dictionary.\n    If an item's inner dictionary becomes empty, remove the item from the outer dictionary.\n    \"\"\"\n", "entry_point": "inventory_management", "solution": "    inventory = {}\n\n    def update_inventory(item, location, quantity):\n        if item not in inventory:\n            inventory[item] = {}\n        if location not in inventory[item]:\n            inventory[item][location] = 0\n        inventory[item][location] += quantity\n        if inventory[item][location] == 0:\n            del inventory[item][location]\n        if not inventory[item]:\n            del inventory[item]\n\n    for transaction in transactions:\n        transaction_type = transaction[0]\n        item = transaction[1]\n        quantity = int(transaction[2])\n\n        if transaction_type == 'add':\n            location = transaction[3]\n            update_inventory(item, location, quantity)\n        elif transaction_type == 'remove':\n            location = transaction[3]\n            update_inventory(item, location, -quantity)\n        elif transaction_type == 'transfer':\n            from_location = transaction[3]\n            to_location = transaction[4]\n            update_inventory(item, from_location, -quantity)\n            update_inventory(item, to_location, quantity)\n\n    return inventory\n", "test": "def check(candidate):\n    assert candidate([['add', 'pen', '100', 'S1'], ['remove', 'pen', '30', 'S1'], ['add', 'pencil', '50', 'S2'], ['transfer', 'pen', '20', 'S1', 'S2']]) == {'pen': {'S1': 50, 'S2': 20}, 'pencil': {'S2': 50}}\n    assert candidate([['add', 'milk', '100', 'D1'], ['add', 'cheese', '50', 'D2'], ['transfer', 'milk', '30', 'D1', 'D3'], ['transfer', 'cheese', '20', 'D2', 'D3']]) == {'milk': {'D1': 70, 'D3': 30}, 'cheese': {'D2': 30, 'D3': 20}}\n    assert candidate([['add', 'book', '10', 'X1'], ['add', 'book', '5', 'X2'], ['transfer', 'book', '3', 'X1', 'X3']]) == {'book': {'X1': 7, 'X2': 5, 'X3': 3}}\n    assert candidate([['add', 'apple', '100', 'A1'], ['add', 'banana', '50', 'B2'], ['remove', 'apple', '20', 'A1'], ['transfer', 'banana', '10', 'B2', 'C3'], ['add', 'cherry', '75', 'D4']]) == {'apple': {'A1': 80}, 'banana': {'B2': 40, 'C3': 10}, 'cherry': {'D4': 75}}\n    assert candidate([['add', 'shirt', '200', 'C1'], ['remove', 'shirt', '50', 'C1'], ['transfer', 'shirt', '75', 'C1', 'C2'], ['add', 'shirt', '100', 'C3']]) == {'shirt': {'C1': 75, 'C2': 75, 'C3': 100}}\n    assert candidate([['add', 'phone', '50', 'P1'], ['remove', 'phone', '50', 'P1']]) == {}\n    assert candidate([['add', 'laptop', '20', 'L1'], ['add', 'laptop', '30', 'L2'], ['transfer', 'laptop', '20', 'L1', 'L2']]) == {'laptop': {'L2': 50}}\n    assert candidate([['add', 'toy', '500', 'T1'], ['remove', 'toy', '100', 'T1'], ['transfer', 'toy', '200', 'T1', 'T2'], ['transfer', 'toy', '150', 'T2', 'T3']]) == {'toy': {'T1': 200, 'T2': 50, 'T3': 150}}\n    assert candidate([['add', 'chair', '50', 'F1'], ['add', 'table', '30', 'F2'], ['transfer', 'chair', '10', 'F1', 'F3'], ['remove', 'table', '15', 'F2']]) == {'chair': {'F1': 40, 'F3': 10}, 'table': {'F2': 15}}\n", "language": "python"}
{"task_id": "revision1a_problem534", "prompt": "import math\nfrom typing import List, Tuple\nimport itertools\n\ndef optimize_delivery_route(locations: List[Tuple[float, float]], start: Tuple[float, float]) -> List[int]:\n    \"\"\"\n    A food delivery service wants to optimize their delivery route to minimize travel time and fuel consumption.\n    Given a list of customer locations (as latitude and longitude coordinates) and the starting point of the delivery driver,\n    implement the Travelling Salesman Problem using dynamic programming to find the optimal route.\n\n    The function should return the order of locations to visit (as indices of the input list) that minimizes the total distance traveled.\n\n    Example:\n    Input: locations=[(40.7128, -74.0060), (34.0522, -118.2437), (41.8781, -87.6298), (29.7604, -95.3698)], start=(37.7749, -122.4194)\n    Output: [2, 0, 3, 1]\n\n    This output means the optimal route is: start -> location 2 -> location 0 -> location 3 -> location 1\n    \"\"\"\n", "entry_point": "optimize_delivery_route", "solution": "    def calculate_distance(point1: Tuple[float, float], point2: Tuple[float, float]) -> float:\n        lat1, lon1 = point1\n        lat2, lon2 = point2\n        return math.sqrt((lat2 - lat1) ** 2 + (lon2 - lon1) ** 2)\n\n    n = len(locations)\n    all_points = [start] + locations\n    \n    # Create distance matrix\n    dist = [[calculate_distance(all_points[i], all_points[j]) for j in range(n + 1)] for i in range(n + 1)]\n    \n    # Initialize DP table\n    dp = {}\n    \n    # Helper function for recursive DP\n    def tsp(mask: int, pos: int) -> Tuple[float, List[int]]:\n        if mask == ((1 << n) - 1):\n            return dist[pos][0], []\n        \n        if (mask, pos) in dp:\n            return dp[(mask, pos)]\n        \n        ans = float('inf')\n        best_path = []\n        \n        for city in range(1, n + 1):\n            if (mask & (1 << (city - 1))) == 0:\n                new_mask = mask | (1 << (city - 1))\n                distance, path = tsp(new_mask, city)\n                distance += dist[pos][city]\n                \n                if distance < ans:\n                    ans = distance\n                    best_path = [city - 1] + path\n        \n        dp[(mask, pos)] = (ans, best_path)\n        return ans, best_path\n    \n    # Call the helper function\n    _, optimal_path = tsp(0, 0)\n    \n    return optimal_path\n\n", "test": "def check(candidate):\n    assert candidate([], (0, 0)) == []\n    assert candidate([(40.7128, -74.0060), (34.0522, -118.2437), (41.8781, -87.6298), (29.7604, -95.3698)], (37.7749, -122.4194)) == [2, 0, 3, 1]\n    assert candidate([(0, 0), (10, 10), (20, 20), (30, 30), (40, 40)], (50, 50)) == [0, 1, 2, 3, 4]\n    assert candidate([(0, 0), (0, 1), (1, 0), (1, 1)], (0.5, 0.5)) == [0, 1, 3, 2]\n    assert candidate([(90, 0), (-90, 0), (0, 180), (0, -180)], (0, 0)) == [0, 2, 1, 3]\n    assert candidate([(1, 1)], (0, 0)) == [0]\n    assert candidate([(0, 0), (0, 0), (0, 0), (0, 0)], (1, 1)) == [0, 1, 2, 3]\n    assert candidate([(0, 0), (1, 1), (2, 2), (3, 3)], (0, 0)) == [0, 1, 2, 3]\n", "language": "python"}
{"task_id": "revision1a_problem126", "prompt": "def decode_alien_message(encoded_message: str) -> str:\n    \"\"\"\n    You've intercepted an encoded message from an alien civilization. The message is a string of digits, where each digit\n    represents a letter in the alien alphabet (1 = A, 2 = B, ..., 26 = Z). However, the message has no spaces, and you need to\n    figure out how to decode it.\n\n    Write a function that takes the encoded message as input and returns the number of possible decodings of the message.\n    A valid decoding must map every digit in the input to a letter.\n\n    For example:\n    - \"12\" could be decoded as \"AB\" (1 2) or \"L\" (12)\n    - \"226\" could be decoded as \"BZ\" (2 26), \"VF\" (22 6), or \"BBF\" (2 2 6)\n\n    Take the encoded message as input from the user and return the number of possible decodings.\n\n    Example:\n    Input: \"12\"\n    Output: 2\n    Explanation: It could be decoded as \"AB\" (1 2) or \"L\" (12)\n\n    Input: \"226\"\n    Output: 3\n    Explanation: It could be decoded as \"BZ\" (2 26), \"VF\" (22 6), or \"BBF\" (2 2 6)\n\n    Note: Assume that the input is always valid and contains only digits from 1 to 9.\n    \"\"\"\n", "entry_point": "decode_alien_message", "solution": "    def count_decodings(index, memo):\n        if index == len(encoded_message):\n            return 1\n        if index in memo:\n            return memo[index]\n        if encoded_message[index] == '0':\n            return 0\n        \n        ways = count_decodings(index + 1, memo)\n        \n        if index + 1 < len(encoded_message) and int(encoded_message[index:index+2]) <= 26:\n            ways += count_decodings(index + 2, memo)\n        \n        memo[index] = ways\n        return ways\n\n    memo = {}\n    return str(count_decodings(0, memo))\n", "test": "def check(candidate):\n    assert candidate(\"111\") == '3'\n    assert candidate(\"123\") == '3'\n    assert candidate(\"27\") == '1'\n    assert candidate(\"9\") == '1'\n    assert candidate(\"1234\") == '3'\n    assert candidate(\"10\") == '1'\n    assert candidate(\"1\") == '1'\n    assert candidate(\"226\") == '3'\n    assert candidate(\"26\") == '2'\n    assert candidate(\"12\") == '2'\n", "language": "python"}
{"task_id": "revision1a_problem714", "prompt": "def input_for_restaurant_menu(cuisine: str) -> str:\n    \"\"\"\n    I want to create a restaurant menu system using classes and polymorphism.\n    We have a base class Restaurant with description \"Welcome to our multi-cuisine restaurant!\"\n    Let's say we have classes for different cuisines: Italian, Chinese, Mexican, Indian, and American.\n    1. Italian class displays \"Enjoy our authentic Italian dishes with fresh pasta and wood-fired pizzas.\"\n    2. Chinese class displays \"Savor our traditional Chinese flavors with a variety of dim sum and stir-fries.\"\n    3. Mexican class displays \"Experience the vibrant tastes of Mexico with our tacos, burritos, and quesadillas.\"\n    4. Indian class displays \"Indulge in the rich spices of India with our curries, tandoori, and biryanis.\"\n    5. American class displays \"Relish classic American comfort food with our burgers, steaks, and apple pies.\"\n    When the user inputs the cuisine type, it will display the description of the Restaurant class and the specific cuisine.\n    Take input from the user and display the description of the cuisine type.\n    \n    Example:\n    Input: Italian\n    Output: Welcome to our multi-cuisine restaurant! Enjoy our authentic Italian dishes with fresh pasta and wood-fired pizzas.\n    Input: Chinese\n    Output: Welcome to our multi-cuisine restaurant! Savor our traditional Chinese flavors with a variety of dim sum and stir-fries.\n    \"\"\"\n", "entry_point": "input_for_restaurant_menu", "solution": "    class Restaurant:\n        def __init__(self):\n            self.description = \"Welcome to our multi-cuisine restaurant!\"\n\n        def get_description(self):\n            return self.description\n\n    class Italian(Restaurant):\n        def __init__(self):\n            super().__init__()\n            self.cuisine_description = \"Enjoy our authentic Italian dishes with fresh pasta and wood-fired pizzas.\"\n\n    class Chinese(Restaurant):\n        def __init__(self):\n            super().__init__()\n            self.cuisine_description = \"Savor our traditional Chinese flavors with a variety of dim sum and stir-fries.\"\n\n    class Mexican(Restaurant):\n        def __init__(self):\n            super().__init__()\n            self.cuisine_description = \"Experience the vibrant tastes of Mexico with our tacos, burritos, and quesadillas.\"\n\n    class Indian(Restaurant):\n        def __init__(self):\n            super().__init__()\n            self.cuisine_description = \"Indulge in the rich spices of India with our curries, tandoori, and biryanis.\"\n\n    class American(Restaurant):\n        def __init__(self):\n            super().__init__()\n            self.cuisine_description = \"Relish classic American comfort food with our burgers, steaks, and apple pies.\"\n\n    cuisine_map = {\n        \"italian\": Italian,\n        \"chinese\": Chinese,\n        \"mexican\": Mexican,\n        \"indian\": Indian,\n        \"american\": American\n    }\n\n    cuisine = cuisine.lower()\n    if cuisine in cuisine_map:\n        restaurant = cuisine_map[cuisine]()\n        return f\"{restaurant.get_description()} {restaurant.cuisine_description}\"\n    else:\n        return \"Sorry, we don't have that cuisine type in our restaurant.\"\n", "test": "def check(candidate):\n    assert candidate(\"MeXiCaN\") == 'Welcome to our multi-cuisine restaurant! Experience the vibrant tastes of Mexico with our tacos, burritos, and quesadillas.'\n    assert candidate(\"Italian\") == 'Welcome to our multi-cuisine restaurant! Enjoy our authentic Italian dishes with fresh pasta and wood-fired pizzas.'\n    assert candidate(\"american\") == 'Welcome to our multi-cuisine restaurant! Relish classic American comfort food with our burgers, steaks, and apple pies.'\n    assert candidate(\"INDIAN\") == 'Welcome to our multi-cuisine restaurant! Indulge in the rich spices of India with our curries, tandoori, and biryanis.'\n    assert candidate(\"Indian\") == 'Welcome to our multi-cuisine restaurant! Indulge in the rich spices of India with our curries, tandoori, and biryanis.'\n    assert candidate(\"italian\") == 'Welcome to our multi-cuisine restaurant! Enjoy our authentic Italian dishes with fresh pasta and wood-fired pizzas.'\n    assert candidate(\"American\") == 'Welcome to our multi-cuisine restaurant! Relish classic American comfort food with our burgers, steaks, and apple pies.'\n    assert candidate(\"Chinese\") == 'Welcome to our multi-cuisine restaurant! Savor our traditional Chinese flavors with a variety of dim sum and stir-fries.'\n    assert candidate(\"CHINESE\") == 'Welcome to our multi-cuisine restaurant! Savor our traditional Chinese flavors with a variety of dim sum and stir-fries.'\n    assert candidate(\"Mexican\") == 'Welcome to our multi-cuisine restaurant! Experience the vibrant tastes of Mexico with our tacos, burritos, and quesadillas.'\n", "language": "python"}
{"task_id": "revision1a_problem552", "prompt": "from typing import List\n\ndef restaurant_orders(orders: List[List[str]]) -> List[str]:\n    \"\"\"\n    You're managing a restaurant's order system. Given a list of orders, each containing a command and relevant information,\n    perform the following operations:\n    a. 'add dish price': Add a new dish to the menu with its price, and print 'Added to menu'.\n    b. 'remove dish': Remove a dish from the menu and print 'Removed from menu' if successful, else print 'Dish not found'.\n    c. 'order dish quantity': Place an order for a dish, print 'Order placed: $total_price' if successful, else print 'Dish not available'.\n    d. 'revenue': Print the total revenue so far as 'Total revenue: $amount'.\n\n    Process the orders in the given sequence and return a list of outputs.\n\n    Example:\n    Input: [['add', 'pizza', '10'], ['add', 'burger', '5'], ['order', 'pizza', '2'], ['remove', 'sandwich'], ['revenue']]\n    Output: ['Added to menu', 'Added to menu', 'Order placed: $20', 'Dish not found', 'Total revenue: $20']\n    Input: [['add', 'salad', '7'], ['order', 'pasta', '1'], ['remove', 'salad'], ['revenue']]\n    Output: ['Added to menu', 'Dish not available', 'Removed from menu', 'Total revenue: $0']\n    \"\"\"\n", "entry_point": "restaurant_orders", "solution": "    menu = {}\n    revenue = 0\n    output = []\n\n    for order in orders:\n        command = order[0]\n\n        if command == 'add':\n            dish, price = order[1], float(order[2])\n            menu[dish] = price\n            output.append('Added to menu')\n\n        elif command == 'remove':\n            dish = order[1]\n            if dish in menu:\n                del menu[dish]\n                output.append('Removed from menu')\n            else:\n                output.append('Dish not found')\n\n        elif command == 'order':\n            dish, quantity = order[1], int(order[2])\n            if dish in menu:\n                total_price = menu[dish] * quantity\n                revenue += total_price\n                output.append(f'Order placed: ${total_price}')\n            else:\n                output.append('Dish not available')\n\n        elif command == 'revenue':\n            output.append(f'Total revenue: ${revenue}')\n\n    return output\n", "test": "def check(candidate):\n    assert candidate([]) == []\n", "language": "python"}
{"task_id": "revision1a_problem400", "prompt": "from typing import List\n\ndef jump_game(nums: List[int]) -> bool:\n    \"\"\"\n    You are playing a game where you are given an array of non-negative integers. Each integer represents your maximum jump length at that position.\n    Your initial position is the first index of the array. Your goal is to reach the last index in the minimum number of jumps.\n    You want to determine if you can reach the last index.\n\n    Write a function that takes a list of integers as input and returns a boolean indicating whether you can reach the last index.\n\n    Example 1:\n    Input: [2,3,1,1,4]\n    Output: True\n    Explanation: Jump 1 step from index 0 to 1, then 3 steps to the last index.\n\n    Example 2:\n    Input: [3,2,1,0,4]\n    Output: False\n    Explanation: You will always arrive at index 3 no matter what. Its maximum jump length is 0, which makes it impossible to reach the last index.\n    \"\"\"\n", "entry_point": "jump_game", "solution": "    max_reach = 0\n    n = len(nums)\n    \n    for i in range(n):\n        if i > max_reach:\n            return False\n        \n        max_reach = max(max_reach, i + nums[i])\n        \n        if max_reach >= n - 1:\n            return True\n    \n    return False\n", "test": "def check(candidate):\n    assert candidate([1,2,3]) == True\n    assert candidate([1]) == True\n    assert candidate([4,2,0,0,1,1,4,4,4,0,4,0]) == True\n    assert candidate([0]) == True\n    assert candidate([3,2,1,0,4]) == False\n    assert candidate([3,2,1]) == True\n    assert candidate([2,0,0]) == True\n    assert candidate([2,5,0,0]) == True\n    assert candidate([1,1,1,1]) == True\n    assert candidate([2,3,1,1,4]) == True\n", "language": "python"}
{"task_id": "revision1a_problem633", "prompt": "from typing import List, Dict, Tuple\nimport heapq\n\ndef optimize_warehouse_layout(items: List[Dict[str, int]], warehouse_size: Tuple[int, int, int]) -> List[Tuple[int, int, int]]:\n    \"\"\"\n    You are tasked with optimizing the layout of a warehouse. Given a list of items, each represented\n    by a dictionary containing their dimensions (length, width, height) and frequency of access,\n    determine the most efficient arrangement of items in the warehouse.\n\n    The warehouse size is given as a tuple (length, width, height). The goal is to minimize the time\n    needed to retrieve items by placing frequently accessed items closer to the entrance and\n    considering the physical constraints of the warehouse.\n\n    Return a list of (x, y, z) coordinates representing the optimal position for each item in the warehouse.\n\n    Example:\n    Input:\n    items = [\n        {'id': 1, 'length': 2, 'width': 2, 'height': 3, 'frequency': 10},\n        {'id': 2, 'length': 1, 'width': 1, 'height': 2, 'frequency': 5},\n        {'id': 3, 'length': 3, 'width': 2, 'height': 2, 'frequency': 8}\n    ]\n    warehouse_size = (10, 8, 5)\n\n    Output: [(0, 0, 0), (2, 0, 0), (3, 0, 0)]\n\n    Note: The actual implementation would require advanced algorithms for 3D bin packing\n    and optimization techniques.\n    \"\"\"\n", "entry_point": "optimize_warehouse_layout", "solution": "    \n    def calculate_distance(x: int, y: int, z: int) -> float:\n        return (x**2 + y**2 + z**2)**0.5\n\n    def find_available_space(item: Dict[str, int], occupied_spaces: List[Tuple[int, int, int, int, int, int]]) -> Tuple[int, int, int]:\n        wl, ww, wh = warehouse_size\n        for x in range(wl - item['length'] + 1):\n            for y in range(ww - item['width'] + 1):\n                for z in range(wh - item['height'] + 1):\n                    if all(not (x < ox + ol and ox < x + item['length'] and\n                                y < oy + ow and oy < y + item['width'] and\n                                z < oz + oh and oz < z + item['height'])\n                           for ox, oy, oz, ol, ow, oh in occupied_spaces):\n                        return x, y, z\n        return None\n\n    # Sort items by frequency in descending order\n    sorted_items = sorted(items, key=lambda x: x['frequency'], reverse=True)\n    \n    result = []\n    occupied_spaces = []\n    \n    for item in sorted_items:\n        position = find_available_space(item, occupied_spaces)\n        if position:\n            x, y, z = position\n            result.append((x, y, z))\n            occupied_spaces.append((x, y, z, item['length'], item['width'], item['height']))\n        else:\n            # If no space is available, place the item at (0, 0, 0) as a fallback\n            result.append((0, 0, 0))\n    \n    return result\n", "test": "def check(candidate):\n    assert candidate([{'id': 1, 'length': 10, 'width': 10, 'height': 10, 'frequency': 1}], (10, 10, 10)) == [(0, 0, 0)]\n    assert candidate([{'id': i, 'length': i, 'width': i, 'height': i, 'frequency': 10-i} for i in range(1, 6)], (15, 15, 15)) == [(0, 0, 0), (0, 0, 1), (0, 0, 3), (0, 0, 6), (0, 0, 10)]\n    assert candidate([{'id': 1, 'length': 1, 'width': 1, 'height': 1, 'frequency': 100}, {'id': 2, 'length': 10, 'width': 10, 'height': 10, 'frequency': 1}], (10, 10, 10)) == [(0, 0, 0), (0, 0, 0)]\n    assert candidate([{'id': i, 'length': 1, 'width': 1, 'height': 1, 'frequency': i} for i in range(1, 11)], (10, 10, 10)) == [(0, 0, 0), (0, 0, 1), (0, 0, 2), (0, 0, 3), (0, 0, 4), (0, 0, 5), (0, 0, 6), (0, 0, 7), (0, 0, 8), (0, 0, 9)]\n    assert candidate([{'id': 1, 'length': 1, 'width': 1, 'height': 10, 'frequency': 1}], (1, 1, 10)) == [(0, 0, 0)]\n    assert candidate([{'id': i, 'length': 1, 'width': 1, 'height': 1, 'frequency': 1} for i in range(1, 101)], (10, 10, 1)) == [(0, 0, 0), (0, 1, 0), (0, 2, 0), (0, 3, 0), (0, 4, 0), (0, 5, 0), (0, 6, 0), (0, 7, 0), (0, 8, 0), (0, 9, 0), (1, 0, 0), (1, 1, 0), (1, 2, 0), (1, 3, 0), (1, 4, 0), (1, 5, 0), (1, 6, 0), (1, 7, 0), (1, 8, 0), (1, 9, 0), (2, 0, 0), (2, 1, 0), (2, 2, 0), (2, 3, 0), (2, 4, 0), (2, 5, 0), (2, 6, 0), (2, 7, 0), (2, 8, 0), (2, 9, 0), (3, 0, 0), (3, 1, 0), (3, 2, 0), (3, 3, 0), (3, 4, 0), (3, 5, 0), (3, 6, 0), (3, 7, 0), (3, 8, 0), (3, 9, 0), (4, 0, 0), (4, 1, 0), (4, 2, 0), (4, 3, 0), (4, 4, 0), (4, 5, 0), (4, 6, 0), (4, 7, 0), (4, 8, 0), (4, 9, 0), (5, 0, 0), (5, 1, 0), (5, 2, 0), (5, 3, 0), (5, 4, 0), (5, 5, 0), (5, 6, 0), (5, 7, 0), (5, 8, 0), (5, 9, 0), (6, 0, 0), (6, 1, 0), (6, 2, 0), (6, 3, 0), (6, 4, 0), (6, 5, 0), (6, 6, 0), (6, 7, 0), (6, 8, 0), (6, 9, 0), (7, 0, 0), (7, 1, 0), (7, 2, 0), (7, 3, 0), (7, 4, 0), (7, 5, 0), (7, 6, 0), (7, 7, 0), (7, 8, 0), (7, 9, 0), (8, 0, 0), (8, 1, 0), (8, 2, 0), (8, 3, 0), (8, 4, 0), (8, 5, 0), (8, 6, 0), (8, 7, 0), (8, 8, 0), (8, 9, 0), (9, 0, 0), (9, 1, 0), (9, 2, 0), (9, 3, 0), (9, 4, 0), (9, 5, 0), (9, 6, 0), (9, 7, 0), (9, 8, 0), (9, 9, 0)]\n    assert candidate([{'id': 1, 'length': 5, 'width': 5, 'height': 5, 'frequency': 1}], (5, 5, 5)) == [(0, 0, 0)]\n    assert candidate([{'id': 1, 'length': 1, 'width': 1, 'height': 1, 'frequency': 1}, {'id': 2, 'length': 1, 'width': 1, 'height': 1, 'frequency': 2}], (2, 2, 2)) == [(0, 0, 0), (0, 0, 1)]\n    assert candidate([{'id': 1, 'length': 3, 'width': 3, 'height': 3, 'frequency': 5}, {'id': 2, 'length': 2, 'width': 2, 'height': 2, 'frequency': 10}], (5, 5, 5)) == [(0, 0, 0), (0, 0, 2)]\n", "language": "python"}
{"task_id": "revision1a_problem662", "prompt": "import datetime\n\ndef calculate_compound_interest(principal: float, rate: float, time: int, compound_frequency: str) -> float:\n    \"\"\"\n    A financial advisor needs to calculate the compound interest for various investment scenarios.\n    \n    Given the principal amount, annual interest rate (as a percentage), time period (in years),\n    and compounding frequency (daily, monthly, quarterly, or annually), calculate the final amount\n    after compound interest.\n    \n    The function should return the final amount rounded to two decimal places.\n    \n    Use the datetime module to handle date calculations for accurate day counting,\n    especially for daily compounding.\n    \n    Take principal, rate, time, and compound_frequency as input, and print the final amount.\n    \n    Example:\n    Input:\n    principal = 1000\n    rate = 5.0\n    time = 2\n    compound_frequency = \"monthly\"\n    \n    Output: 1104.94\n    \n    Explanation: The investment grows to $1,104.94 after 2 years with monthly compounding at 5% annual rate.\n    \"\"\"\n", "entry_point": "calculate_compound_interest", "solution": "    rate = rate / 100  # Convert percentage to decimal\n\n    if compound_frequency == \"annually\":\n        n = 1\n    elif compound_frequency == \"quarterly\":\n        n = 4\n    elif compound_frequency == \"monthly\":\n        n = 12\n    elif compound_frequency == \"daily\":\n        n = 365\n    else:\n        raise ValueError(\"Invalid compound_frequency. Use 'annually', 'quarterly', 'monthly', or 'daily'.\")\n\n    if compound_frequency != \"daily\":\n        amount = principal * (1 + rate / n) ** (n * time)\n    else:\n        start_date = datetime.date.today()\n        end_date = start_date + datetime.timedelta(days=time * 365)\n        days = (end_date - start_date).days\n        amount = principal * (1 + rate / n) ** days\n\n    return round(amount, 2)\n", "test": "def check(candidate):\n    assert candidate(100000, 8.0, 20, \"annually\") == 466095.71\n    assert candidate(10000, 3.25, 10, \"quarterly\") == 13822.14\n    assert candidate(750, 6.0, 7, \"quarterly\") == 1137.92\n    assert candidate(500, 2.0, 1, \"daily\") == 510.1\n    assert candidate(5000, 7.5, 5, \"annually\") == 7178.15\n    assert candidate(15000, 3.75, 4, \"daily\") == 17427.38\n    assert candidate(1000, 5.0, 2, \"monthly\") == 1104.94\n    assert candidate(2500, 4.5, 3, \"monthly\") == 2860.62\n    assert candidate(50000, 5.5, 15, \"annually\") == 111623.82\n    assert candidate(1200, 3.0, 2, \"monthly\") == 1274.11\n", "language": "python"}
{"task_id": "revision1a_problem462", "prompt": "from typing import List\n\ndef optimize_study_schedule(subjects: List[str], hours: List[int], total_time: int) -> List[str]:\n    \"\"\"\n    A student wants to optimize their study schedule to maximize the number of subjects they can cover\n    within a given total study time. Each subject requires a certain number of hours to complete.\n    \n    Your task is to help the student determine the best combination of subjects to study that will\n    fit within the total available time and maximize the number of subjects covered.\n    \n    Parameters:\n    subjects (List[str]): A list of subject names\n    hours (List[int]): A list of hours required for each subject (corresponding to the subjects list)\n    total_time (int): The total number of hours available for studying\n    \n    Returns:\n    List[str]: A list of subject names that can be studied within the given time, maximizing the number of subjects\n    \n    Constraints:\n    1 <= len(subjects) == len(hours) <= 20\n    1 <= hours[i] <= 10\n    1 <= total_time <= 100\n    \n    Example:\n    Input: \n    subjects = [\"Math\", \"Science\", \"History\", \"English\", \"Art\"]\n    hours = [3, 4, 2, 5, 1]\n    total_time = 10\n    \n    Output: [\"Math\", \"History\", \"Art\", \"Science\"]\n    \n    Explanation: This combination allows the student to study 4 subjects within 10 hours (3 + 2 + 1 + 4 = 10).\n    \"\"\"\n", "entry_point": "optimize_study_schedule", "solution": "    def knapsack(n, W, weights, values):\n        dp = [[0 for _ in range(W + 1)] for _ in range(n + 1)]\n        \n        for i in range(1, n + 1):\n            for w in range(1, W + 1):\n                if weights[i-1] <= w:\n                    dp[i][w] = max(values[i-1] + dp[i-1][w-weights[i-1]], dp[i-1][w])\n                else:\n                    dp[i][w] = dp[i-1][w]\n        \n        # Backtrack to find the selected items\n        selected = []\n        i, w = n, W\n        while i > 0 and w > 0:\n            if dp[i][w] != dp[i-1][w]:\n                selected.append(i-1)\n                w -= weights[i-1]\n            i -= 1\n        \n        return selected[::-1]\n\n    n = len(subjects)\n    values = [1] * n  # Each subject has a value of 1 (we want to maximize the number of subjects)\n    selected_indices = knapsack(n, total_time, hours, values)\n    \n    return [subjects[i] for i in selected_indices]\n", "test": "def check(candidate):\n    assert candidate([\"Subject1\"], [5], 5) == ['Subject1']\n    assert candidate([\"X\", \"Y\"], [10, 10], 20) == ['X', 'Y']\n    assert candidate([\"Hard\", \"VeryHard\", \"ExtremlyHard\"], [10, 10, 10], 15) == ['Hard']\n    assert candidate([\"Subject1\", \"Subject2\", \"Subject3\"], [1, 1, 1], 1) == ['Subject1']\n    assert candidate([\"Math\", \"English\", \"Science\"], [3, 3, 3], 100) == ['Math', 'English', 'Science']\n    assert candidate([\"A\", \"B\", \"C\", \"D\", \"E\"], [2, 2, 2, 2, 2], 9) == ['A', 'B', 'C', 'D']\n    assert candidate([\"Math\", \"Science\", \"History\", \"English\", \"Art\"], [3, 4, 2, 5, 1], 10) == ['Math', 'Science', 'History', 'Art']\n    assert candidate([\"A\", \"B\", \"C\", \"D\", \"E\", \"F\", \"G\", \"H\", \"I\", \"J\", \"K\", \"L\", \"M\", \"N\", \"O\", \"P\", \"Q\", \"R\", \"S\", \"T\"], [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10], 50) == ['A', 'B', 'C', 'D', 'E', 'F', 'G', 'K', 'L', 'M', 'N', 'O', 'P']\n    assert candidate([\"Physics\", \"Chemistry\", \"Biology\"], [5, 4, 3], 7) == ['Chemistry', 'Biology']\n    assert candidate([\"A\", \"B\", \"C\", \"D\", \"E\", \"F\", \"G\", \"H\", \"I\", \"J\"], [1, 1, 1, 1, 1, 1, 1, 1, 1, 1], 5) == ['A', 'B', 'C', 'D', 'E']\n", "language": "python"}
{"task_id": "revision1a_problem277", "prompt": "def calculate_tax(income: float, country: str) -> float:\n    \"\"\"\n    You are developing a tax calculation system for an international accounting firm. The system needs to calculate taxes for individuals \n    based on their income and country of residence. Different countries have different tax brackets and rates.\n\n    Write a function that takes an individual's annual income and country of residence as input, and returns the calculated tax amount.\n    Implement tax calculations for at least three different countries with progressive tax systems.\n\n    For example:\n    - USA: 10% for first $10,000, 15% for next $30,000, 25% for amount above $40,000\n    - UK: 0% for first \u00a312,500, 20% for \u00a312,501 to \u00a350,000, 40% for \u00a350,001 to \u00a3150,000, 45% for amount above \u00a3150,000\n    - Canada: 15% for first C$49,020, 20.5% for C$49,021 to C$98,040, 26% for C$98,041 to C$151,978, 29% for C$151,979 to C$216,511, 33% for amount above C$216,511\n\n    Round the calculated tax to two decimal places.\n\n    Example:\n    Input: 75000, \"USA\"\n    Output: 14107.50\n\n    Input: 100000, \"UK\"\n    Output: 27500.00\n    \"\"\"\n", "entry_point": "calculate_tax", "solution": "    \n    def usa_tax(income):\n        if income <= 10000:\n            return income * 0.10\n        elif income <= 40000:\n            return 10000 * 0.10 + (income - 10000) * 0.15\n        else:\n            return 10000 * 0.10 + 30000 * 0.15 + (income - 40000) * 0.25\n\n    def uk_tax(income):\n        if income <= 12500:\n            return 0\n        elif income <= 50000:\n            return (income - 12500) * 0.20\n        elif income <= 150000:\n            return (50000 - 12500) * 0.20 + (income - 50000) * 0.40\n        else:\n            return (50000 - 12500) * 0.20 + (150000 - 50000) * 0.40 + (income - 150000) * 0.45\n\n    def canada_tax(income):\n        if income <= 49020:\n            return income * 0.15\n        elif income <= 98040:\n            return 49020 * 0.15 + (income - 49020) * 0.205\n        elif income <= 151978:\n            return 49020 * 0.15 + (98040 - 49020) * 0.205 + (income - 98040) * 0.26\n        elif income <= 216511:\n            return 49020 * 0.15 + (98040 - 49020) * 0.205 + (151978 - 98040) * 0.26 + (income - 151978) * 0.29\n        else:\n            return 49020 * 0.15 + (98040 - 49020) * 0.205 + (151978 - 98040) * 0.26 + (216511 - 151978) * 0.29 + (income - 216511) * 0.33\n\n    country = country.lower()\n    if country == \"usa\":\n        tax = usa_tax(income)\n    elif country == \"uk\":\n        tax = uk_tax(income)\n    elif country == \"canada\":\n        tax = canada_tax(income)\n    else:\n        raise ValueError(\"Unsupported country\")\n\n    return round(tax, 2)\n", "test": "def check(candidate):\n    assert candidate(150000, \"UK\") == 47500.0\n    assert candidate(0, \"USA\") == 0.0\n    assert candidate(75000, \"USA\") == 14250.0\n    assert candidate(50000, \"Canada\") == 7553.9\n    assert candidate(216511, \"Canada\") == 50140.55\n    assert candidate(12500, \"UK\") == 0\n    assert candidate(49020, \"Canada\") == 7353.0\n    assert candidate(10000, \"USA\") == 1000.0\n    assert candidate(200000, \"USA\") == 45500.0\n    assert candidate(100000, \"UK\") == 27500.0\n", "language": "python"}
{"task_id": "revision1a_problem341", "prompt": "import random\nimport math\nfrom typing import List, Tuple\n\ndef optimize_wind_farm(grid_size: Tuple[int, int], wind_data: List[List[float]], turbine_cost: float, budget: float) -> List[Tuple[int, int]]:\n    \"\"\"\n    An energy company wants to optimize the placement of wind turbines in a potential wind farm site.\n    The goal is to maximize energy output while staying within a given budget.\n\n    Parameters:\n    grid_size (Tuple[int, int]): The dimensions of the site grid (rows, columns)\n    wind_data (List[List[float]]): A 2D list representing the average wind speed at each grid point\n    turbine_cost (float): The cost of installing a single wind turbine\n    budget (float): The total available budget for turbine installation\n\n    Returns:\n    List[Tuple[int, int]]: A list of (row, column) coordinates where turbines should be placed\n\n    This problem involves elements of resource allocation, constraint satisfaction, and optimization.\n    Consider using a combination of greedy algorithms and local search techniques like simulated annealing.\n\n    Example:\n    Input:\n    grid_size = (5, 5)\n    wind_data = [\n        [2.1, 2.3, 2.5, 2.4, 2.2],\n        [2.2, 2.4, 2.6, 2.5, 2.3],\n        [2.3, 2.5, 2.7, 2.6, 2.4],\n        [2.2, 2.4, 2.6, 2.5, 2.3],\n        [2.1, 2.3, 2.5, 2.4, 2.2]\n    ]\n    turbine_cost = 1000000\n    budget = 5000000\n\n    Output: [(2, 2), (1, 3), (3, 1), (0, 4), (4, 0)]  # Coordinates for 5 turbines within budget\n    \"\"\"\n", "entry_point": "optimize_wind_farm", "solution": "    def calculate_energy_output(turbines):\n        return sum(wind_data[r][c] for r, c in turbines)\n\n    def get_neighbors(turbines):\n        neighbors = []\n        for i, (r, c) in enumerate(turbines):\n            for dr, dc in [(-1, 0), (1, 0), (0, -1), (0, 1)]:\n                new_r, new_c = r + dr, c + dc\n                if 0 <= new_r < grid_size[0] and 0 <= new_c < grid_size[1]:\n                    new_turbines = turbines[:i] + [(new_r, new_c)] + turbines[i+1:]\n                    neighbors.append(new_turbines)\n        return neighbors\n\n    # Initialize with a greedy solution\n    flattened = [(r, c) for r in range(grid_size[0]) for c in range(grid_size[1])]\n    sorted_positions = sorted(flattened, key=lambda pos: wind_data[pos[0]][pos[1]], reverse=True)\n    max_turbines = int(budget // turbine_cost)\n    current_solution = sorted_positions[:max_turbines]\n\n    # Simulated annealing\n    temperature = 1.0\n    cooling_rate = 0.995\n    iterations = 1000\n\n    for _ in range(iterations):\n        neighbors = get_neighbors(current_solution)\n        if not neighbors:\n            break\n\n        new_solution = random.choice(neighbors)\n        \n        current_energy = calculate_energy_output(current_solution)\n        new_energy = calculate_energy_output(new_solution)\n        \n        if new_energy > current_energy or random.random() < math.exp((new_energy - current_energy) / temperature):\n            current_solution = new_solution\n        \n        temperature *= cooling_rate\n\n    return current_solution\n", "test": "def check(candidate):\n    assert candidate((3, 3), [[1.0, 1.5, 2.0], [1.5, 2.0, 2.5], [2.0, 2.5, 3.0]], 500000, 1000000) == [(2, 2), (2, 2)]\n    assert candidate((2, 2), [[1.0, 2.0], [2.0, 3.0]], 500000, 1000000) == [(1, 1), (1, 1)]\n    assert candidate((4, 4), [[1.0, 1.5, 2.0, 2.5], [1.5, 2.0, 2.5, 3.0], [2.0, 2.5, 3.0, 3.5], [2.5, 3.0, 3.5, 4.0]], 750000, 3000000) == [(3, 3), (3, 3), (3, 3), (3, 3)]\n    assert candidate((5, 5), [[2.1, 2.3, 2.5, 2.4, 2.2], [2.2, 2.4, 2.6, 2.5, 2.3], [2.3, 2.5, 2.7, 2.6, 2.4], [2.2, 2.4, 2.6, 2.5, 2.3], [2.1, 2.3, 2.5, 2.4, 2.2]], 1000000, 5000000) == [(2, 2), (2, 2), (2, 2), (2, 2), (2, 2)]\n    assert candidate((1, 1), [[3.0]], 100000, 100000) == [(0, 0)]\n", "language": "python"}
{"task_id": "revision1a_problem567", "prompt": "from typing import List, Tuple\nimport math\n\ndef optimize_delivery_route(locations: List[Tuple[float, float]], fuel_capacity: float) -> List[int]:\n    \"\"\"\n    A delivery company wants to optimize its route for a fleet of drones. Each drone has a limited fuel capacity.\n    \n    Given a list of (x, y) coordinates representing delivery locations and the fuel capacity of each drone,\n    determine the optimal order to visit the locations while minimizing the number of drones used.\n    \n    The function should return a list of integers representing the order in which locations should be visited.\n    \n    Assume that:\n    1. The drones start and end at (0, 0)\n    2. The fuel consumed is directly proportional to the Euclidean distance traveled\n    3. Each location must be visited exactly once\n    \n    Take the list of locations and fuel capacity as input, and print the optimal visitation order.\n    \n    Example:\n    Input: \n    locations = [(1, 1), (2, 2), (3, 3), (4, 4)]\n    fuel_capacity = 15.0\n    \n    Output: [0, 1, 2, 3]\n    \n    Explanation: The optimal route is to visit the locations in order, which requires only one drone.\n    \"\"\"\n", "entry_point": "optimize_delivery_route", "solution": "    def distance(p1, p2):\n        return math.sqrt((p1[0] - p2[0])**2 + (p1[1] - p2[1])**2)\n\n    def total_distance(route):\n        total = distance((0, 0), locations[route[0]])\n        for i in range(len(route) - 1):\n            total += distance(locations[route[i]], locations[route[i+1]])\n        total += distance(locations[route[-1]], (0, 0))\n        return total\n\n    def nearest_neighbor():\n        unvisited = set(range(len(locations)))\n        route = []\n        current = (0, 0)\n        while unvisited:\n            nearest = min(unvisited, key=lambda x: distance(current, locations[x]))\n            route.append(nearest)\n            current = locations[nearest]\n            unvisited.remove(nearest)\n        return route\n\n    def two_opt(route):\n        improved = True\n        while improved:\n            improved = False\n            for i in range(1, len(route) - 2):\n                for j in range(i + 1, len(route)):\n                    if j - i == 1:\n                        continue\n                    new_route = route[:i] + route[i:j][::-1] + route[j:]\n                    if total_distance(new_route) < total_distance(route):\n                        route = new_route\n                        improved = True\n            if total_distance(route) <= fuel_capacity:\n                return route\n        return route\n\n    initial_route = nearest_neighbor()\n    optimized_route = two_opt(initial_route)\n\n    if total_distance(optimized_route) <= fuel_capacity:\n        return optimized_route\n    else:\n        # If a single drone can't cover all locations, we need to split the route\n        # This is a simplification and may not be optimal for all cases\n        result = []\n        current_route = []\n        current_distance = 0\n        for location in optimized_route:\n            if current_route:\n                new_distance = current_distance + distance(locations[current_route[-1]], locations[location])\n            else:\n                new_distance = distance((0, 0), locations[location])\n            \n            if new_distance + distance(locations[location], (0, 0)) <= fuel_capacity:\n                current_route.append(location)\n                current_distance = new_distance\n            else:\n                result.extend(current_route)\n                current_route = [location]\n                current_distance = distance((0, 0), locations[location])\n        \n        result.extend(current_route)\n        return result\n", "test": "def check(candidate):\n    assert candidate([(1, 1), (-1, -1), (2, -2), (-2, 2)], 12.0) == [0, 2, 1, 3]\n    assert candidate([(1, 1), (2, 2), (3, 3), (4, 4)], 15.0) == [0, 1, 2, 3]\n    assert candidate([(10, 10), (20, 20), (30, 30)], 100.0) == [0, 1, 2]\n    assert candidate([(0.1, 0.1), (0.2, 0.2), (0.3, 0.3)], 1.0) == [0, 1, 2]\n    assert candidate([(5, 5), (3, 3), (1, 1)], 20.0) == [2, 1, 0]\n    assert candidate([(1, 0), (0, 1), (1, 1), (2, 0), (0, 2)], 7.0) == [0, 1, 4, 2, 3]\n    assert candidate([(100, 100), (200, 200), (300, 300)], 1000.0) == [0, 1, 2]\n    assert candidate([(0.5, 0.5), (1.5, 1.5), (2.5, 2.5)], 8.0) == [0, 1, 2]\n    assert candidate([(3, 4), (5, 12), (8, 15), (7, 24)], 50.0) == [0, 1, 2, 3]\n    assert candidate([(0, 1), (1, 0), (2, 2), (3, 3), (4, 4)], 10.0) == [0, 1, 2, 3, 4]\n", "language": "python"}
{"task_id": "revision1a_problem539", "prompt": "from typing import List, Dict, Tuple\nfrom collections import defaultdict\n\ndef analyze_social_network(connections: List[Tuple[str, str]], queries: List[str]) -> Dict[str, List[str]]:\n    \"\"\"\n    Analyze a social network to find mutual friends and suggest new connections.\n    Implement a graph data structure using adjacency lists and perform depth-first search (DFS) for analysis.\n\n    Parameters:\n    connections (List[Tuple[str, str]]): A list of tuples representing friendships between two people.\n    queries (List[str]): A list of usernames for which to perform the analysis.\n\n    Returns:\n    Dict[str, List[str]]: A dictionary where each key is a queried username, and the value is a list of suggested new connections.\n\n    Example:\n    Input:\n    connections = [(\"Alice\", \"Bob\"), (\"Bob\", \"Charlie\"), (\"Charlie\", \"David\"), (\"David\", \"Alice\"), (\"Eve\", \"Alice\"), (\"Eve\", \"Bob\")]\n    queries = [\"Alice\", \"Eve\"]\n    Output:\n    {\n        \"Alice\": [\"Charlie\"],\n        \"Eve\": [\"Charlie\", \"David\"]\n    }\n\n    Note: Suggestions are based on friends of friends who are not already direct friends.\n    \"\"\"\n", "entry_point": "analyze_social_network", "solution": "    # Create adjacency list\n    graph = defaultdict(set)\n    for person1, person2 in connections:\n        graph[person1].add(person2)\n        graph[person2].add(person1)\n\n    def dfs(person, visited, depth):\n        if depth > 2:\n            return set()\n        \n        suggestions = set()\n        visited.add(person)\n        \n        for friend in graph[person]:\n            if friend not in visited:\n                if depth == 2:\n                    suggestions.add(friend)\n                suggestions.update(dfs(friend, visited, depth + 1))\n        \n        return suggestions\n\n    result = {}\n    for query in queries:\n        visited = set()\n        suggestions = dfs(query, visited, 1)\n        suggestions -= graph[query]  # Remove direct friends\n        suggestions.discard(query)  # Remove self\n        result[query] = sorted(list(suggestions))\n\n    return result\n", "test": "def check(candidate):\n    assert candidate([(\"A\", \"B\"), (\"B\", \"C\"), (\"C\", \"D\"), (\"D\", \"E\"), (\"E\", \"A\")], [\"A\", \"C\", \"E\"]) == {'A': ['C', 'D'], 'C': ['A', 'E'], 'E': ['B', 'C']}\n    assert candidate([(\"X\", \"Y\"), (\"Y\", \"Z\")], [\"X\", \"Y\", \"Z\"]) == {'X': ['Z'], 'Y': [], 'Z': ['X']}\n    assert candidate([(\"A\", \"B\")], [\"A\", \"B\", \"C\"]) == {'A': [], 'B': [], 'C': []}\n    assert candidate([(\"Alice\", \"Bob\"), (\"Bob\", \"Charlie\"), (\"Charlie\", \"Alice\")], [\"Alice\", \"Bob\", \"Charlie\"]) == {'Alice': [], 'Bob': [], 'Charlie': []}\n    assert candidate([], [\"Alice\", \"Bob\"]) == {'Alice': [], 'Bob': []}\n    assert candidate([(\"1\", \"2\"), (\"2\", \"3\"), (\"3\", \"4\"), (\"4\", \"5\"), (\"5\", \"1\")], [\"1\", \"2\", \"3\", \"4\", \"5\"]) == {'1': ['3', '4'], '2': ['4', '5'], '3': ['1', '5'], '4': ['1', '2'], '5': ['2', '3']}\n    assert candidate([(\"John\", \"Jane\"), (\"Jane\", \"Bob\"), (\"Bob\", \"Alice\")], [\"John\", \"Alice\"]) == {'John': ['Bob'], 'Alice': ['Jane']}\n    assert candidate([(\"A\", \"B\"), (\"B\", \"C\"), (\"C\", \"D\")], []) == {}\n    assert candidate([(\"X\", \"Y\")], [\"Z\"]) == {'Z': []}\n    assert candidate([(\"Alice\", \"Bob\"), (\"Bob\", \"Charlie\"), (\"Charlie\", \"David\")], [\"Alice\", \"David\"]) == {'Alice': ['Charlie'], 'David': ['Bob']}\n", "language": "python"}
{"task_id": "revision1a_problem671", "prompt": "from typing import List, Tuple\n\ndef design_seating_arrangement(rows: int, seats_per_row: int, reserved: List[Tuple[int, int]]) -> List[List[str]]:\n    \"\"\"\n    You are tasked with designing a seating arrangement system for a theater. The theater has a certain number\n    of rows and seats per row. Some seats are already reserved. Your goal is to create a visual representation\n    of the seating arrangement.\n\n    Parameters:\n    rows (int): The number of rows in the theater.\n    seats_per_row (int): The number of seats in each row.\n    reserved (List[Tuple[int, int]]): A list of tuples representing the reserved seats. Each tuple contains\n                                      the row number and seat number (both 1-indexed).\n\n    Returns:\n    List[List[str]]: A 2D list representing the seating arrangement. Use 'O' for available seats and 'X' for\n                     reserved seats.\n\n    Example:\n    Input: \n    rows = 3\n    seats_per_row = 4\n    reserved = [(1, 2), (2, 3), (3, 1)]\n\n    Output:\n    [['O', 'X', 'O', 'O'],\n     ['O', 'O', 'X', 'O'],\n     ['X', 'O', 'O', 'O']]\n\n    Note: Ensure that your implementation handles edge cases, such as invalid inputs or out-of-bounds reservations.\n    \"\"\"\n", "entry_point": "design_seating_arrangement", "solution": "    # Check for invalid inputs\n    if rows <= 0 or seats_per_row <= 0:\n        raise ValueError(\"Number of rows and seats per row must be positive integers.\")\n\n    # Initialize the seating arrangement with all seats available\n    seating = [['O' for _ in range(seats_per_row)] for _ in range(rows)]\n\n    # Mark reserved seats\n    for row, seat in reserved:\n        # Check if the reservation is within bounds\n        if 1 <= row <= rows and 1 <= seat <= seats_per_row:\n            # Convert 1-indexed to 0-indexed\n            seating[row-1][seat-1] = 'X'\n        else:\n            print(f\"Warning: Invalid reservation ({row}, {seat}) ignored.\")\n\n    return seating\n", "test": "def check(candidate):\n    assert candidate(4, 6, [(1, 1), (1, 6), (4, 1), (4, 6)]) == [['X', 'O', 'O', 'O', 'O', 'X'], ['O', 'O', 'O', 'O', 'O', 'O'], ['O', 'O', 'O', 'O', 'O', 'O'], ['X', 'O', 'O', 'O', 'O', 'X']]\n    assert candidate(3, 3, [(1, 1), (1, 2), (1, 3), (2, 1), (2, 2), (2, 3), (3, 1), (3, 2), (3, 3)]) == [['X', 'X', 'X'], ['X', 'X', 'X'], ['X', 'X', 'X']]\n    assert candidate(3, 4, [(1, 2), (2, 3), (3, 1)]) == [['O', 'X', 'O', 'O'], ['O', 'O', 'X', 'O'], ['X', 'O', 'O', 'O']]\n    assert candidate(4, 4, [(1, 1), (1, 4), (4, 1), (4, 4)]) == [['X', 'O', 'O', 'X'], ['O', 'O', 'O', 'O'], ['O', 'O', 'O', 'O'], ['X', 'O', 'O', 'X']]\n    assert candidate(2, 3, []) == [['O', 'O', 'O'], ['O', 'O', 'O']]\n    assert candidate(3, 5, [(1, 3), (2, 2), (2, 4), (3, 1), (3, 5)]) == [['O', 'O', 'X', 'O', 'O'], ['O', 'X', 'O', 'X', 'O'], ['X', 'O', 'O', 'O', 'X']]\n    assert candidate(5, 5, [(1, 1), (2, 2), (3, 3), (4, 4), (5, 5)]) == [['X', 'O', 'O', 'O', 'O'], ['O', 'X', 'O', 'O', 'O'], ['O', 'O', 'X', 'O', 'O'], ['O', 'O', 'O', 'X', 'O'], ['O', 'O', 'O', 'O', 'X']]\n    assert candidate(5, 3, [(2, 2), (4, 1), (5, 3)]) == [['O', 'O', 'O'], ['O', 'X', 'O'], ['O', 'O', 'O'], ['X', 'O', 'O'], ['O', 'O', 'X']]\n    assert candidate(1, 1, [(1, 1)]) == [['X']]\n", "language": "python"}
{"task_id": "revision1a_problem380", "prompt": "from typing import List, Dict, Tuple\nfrom collections import deque\n\ndef network_packet_router(network: Dict[str, List[str]], packets: List[Tuple[str, str, str]], max_hops: int) -> List[str]:\n    \"\"\"\n    You are designing a network packet routing system for a large-scale computer network.\n    The network consists of multiple nodes, and each node is connected to one or more other nodes.\n    Packets need to be routed from a source node to a destination node, potentially through intermediate nodes.\n\n    Write a program to simulate the routing of packets through the network. Use a graph data structure\n    to represent the network and implement a breadth-first search algorithm to find the shortest path\n    for each packet. If a packet cannot reach its destination within the maximum number of hops, it should be dropped.\n\n    Take input for the network structure (as an adjacency list), a list of packets (each containing source,\n    destination, and packet ID), and the maximum number of hops allowed. Return a list of successfully routed packet IDs.\n\n    Example:\n    Input:\n    network = {\n        \"A\": [\"B\", \"C\"],\n        \"B\": [\"A\", \"D\", \"E\"],\n        \"C\": [\"A\", \"F\"],\n        \"D\": [\"B\"],\n        \"E\": [\"B\", \"F\"],\n        \"F\": [\"C\", \"E\"]\n    }\n    packets = [(\"A\", \"F\", \"P1\"), (\"B\", \"F\", \"P2\"), (\"D\", \"C\", \"P3\"), (\"E\", \"A\", \"P4\")]\n    max_hops = 3\n    Output: [\"P1\", \"P2\", \"P4\"]\n\n    Input:\n    network = {\n        \"X\": [\"Y\", \"Z\"],\n        \"Y\": [\"X\", \"W\"],\n        \"Z\": [\"X\", \"W\"],\n        \"W\": [\"Y\", \"Z\"]\n    }\n    packets = [(\"X\", \"W\", \"P1\"), (\"Y\", \"Z\", \"P2\"), (\"W\", \"X\", \"P3\")]\n    max_hops = 1\n    Output: [\"P1\", \"P3\"]\n    \"\"\"\n", "entry_point": "network_packet_router", "solution": "    def bfs(start: str, end: str) -> bool:\n        queue = deque([(start, 0)])\n        visited = set()\n\n        while queue:\n            node, hops = queue.popleft()\n            \n            if node == end:\n                return True\n            \n            if hops >= max_hops:\n                continue\n            \n            if node not in visited:\n                visited.add(node)\n                for neighbor in network.get(node, []):\n                    if neighbor not in visited:\n                        queue.append((neighbor, hops + 1))\n        \n        return False\n\n    routed_packets = []\n\n    for source, destination, packet_id in packets:\n        if bfs(source, destination):\n            routed_packets.append(packet_id)\n\n    return routed_packets\n", "test": "def check(candidate):\n    assert candidate({\"A\": []}, [(\"A\", \"A\", \"P1\")], 1) == ['P1']\n    assert candidate({\"A\": [\"B\"], \"B\": [\"A\"]}, [(\"A\", \"B\", \"P1\")], 1) == ['P1']\n    assert candidate({\"A\": [\"B\"], \"B\": [\"C\"], \"C\": [\"A\"]}, [(\"A\", \"C\", \"P1\"), (\"B\", \"A\", \"P2\"), (\"C\", \"B\", \"P3\")], 2) == ['P1', 'P2', 'P3']\n    assert candidate({\"X\": [\"Y\"], \"Y\": [\"Z\"], \"Z\": []}, [(\"X\", \"Z\", \"P1\")], 3) == ['P1']\n    assert candidate({\"1\": [\"2\"], \"2\": [\"3\"], \"3\": [\"4\"], \"4\": [\"5\"], \"5\": [\"1\"]}, [(\"1\", \"4\", \"P1\"), (\"2\", \"5\", \"P2\"), (\"3\", \"1\", \"P3\")], 3) == ['P1', 'P2', 'P3']\n    assert candidate({\"S\": [\"A\", \"B\"], \"A\": [\"S\", \"C\"], \"B\": [\"S\", \"D\"], \"C\": [\"A\", \"D\"], \"D\": [\"B\", \"C\"]}, [(\"S\", \"D\", \"P1\"), (\"A\", \"B\", \"P2\")], 2) == ['P1', 'P2']\n    assert candidate({\"1\": [\"2\", \"3\"], \"2\": [\"1\", \"4\"], \"3\": [\"1\"], \"4\": [\"2\"]}, [(\"1\", \"4\", \"P1\"), (\"3\", \"2\", \"P2\")], 2) == ['P1', 'P2']\n    assert candidate({\"A\": [\"B\"], \"B\": [\"C\"], \"C\": [\"D\"], \"D\": [\"E\"], \"E\": []}, [(\"A\", \"E\", \"P1\")], 4) == ['P1']\n    assert candidate({\"A\": [\"B\"], \"B\": [\"C\"], \"C\": [\"D\"], \"D\": [\"E\"], \"E\": []}, [(\"A\", \"E\", \"P1\")], 5) == ['P1']\n    assert candidate({\"A\": [\"B\", \"C\"], \"B\": [\"A\"], \"C\": [\"A\"]}, [(\"A\", \"C\", \"P1\"), (\"B\", \"C\", \"P2\")], 2) == ['P1', 'P2']\n", "language": "python"}
{"task_id": "revision1a_problem319", "prompt": "from typing import List\n\ndef longest_increasing_path(matrix: List[List[int]]) -> int:\n    \"\"\"\n    As a geologist, you're studying a 2D elevation map of a mountainous region. \n    The map is represented as a matrix where each cell contains the elevation at that point.\n    Your task is to find the length of the longest increasing path in this matrix.\n    \n    An increasing path is defined as a path where each cell has a higher elevation than the previous cell.\n    You can move up, down, left, or right from each cell, but you can't move diagonally.\n    \n    Use dynamic programming with memoization to solve this problem efficiently.\n    The function should take the matrix as input and return the length of the longest increasing path.\n    \n    Expected Time Complexity: O(m*n), where m and n are the dimensions of the matrix.\n    \n    Example:\n    Input: [[9,9,4],[6,6,8],[2,1,1]]\n    Output: 4  # The longest increasing path is [1,2,6,9]\n    \n    Input: [[3,4,5],[3,2,6],[2,2,1]]\n    Output: 4  # The longest increasing path is [3,4,5,6]\n    \"\"\"\n", "entry_point": "longest_increasing_path", "solution": "    if not matrix or not matrix[0]:\n        return 0\n\n    m, n = len(matrix), len(matrix[0])\n    memo = [[0] * n for _ in range(m)]\n    \n    def dfs(i, j):\n        if memo[i][j] != 0:\n            return memo[i][j]\n        \n        directions = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n        max_path = 1\n        \n        for di, dj in directions:\n            ni, nj = i + di, j + dj\n            if 0 <= ni < m and 0 <= nj < n and matrix[ni][nj] > matrix[i][j]:\n                max_path = max(max_path, 1 + dfs(ni, nj))\n        \n        memo[i][j] = max_path\n        return max_path\n    \n    max_length = 0\n    for i in range(m):\n        for j in range(n):\n            max_length = max(max_length, dfs(i, j))\n    \n    return max_length\n", "test": "def check(candidate):\n    assert candidate([[5,4,3],[6,7,8],[1,2,3]]) == 6\n    assert candidate([[1,2],[3,4]]) == 3\n    assert candidate([[10,20,30],[40,50,60]]) == 4\n    assert candidate([[1]]) == 1\n    assert candidate([[1,2],[2,3]]) == 3\n    assert candidate([[9,9,4],[6,6,8],[2,1,1]]) == 4\n    assert candidate([[1,1,1],[1,1,1],[1,1,1]]) == 1\n    assert candidate([[3,4,5],[3,2,6],[2,2,1]]) == 4\n    assert candidate([[1,2,3,4,5],[16,17,18,19,6],[15,24,25,20,7],[14,23,22,21,8],[13,12,11,10,9]]) == 25\n    assert candidate([[9,8,7],[8,7,6],[7,6,5]]) == 5\n", "language": "python"}
{"task_id": "revision1a_problem280", "prompt": "from typing import List\n\ndef valid_sudoku(board: List[List[int]]) -> bool:\n    \"\"\"\n    You are developing a Sudoku game and need to validate whether a given Sudoku board is valid.\n    A Sudoku board is valid if:\n    1. Each row contains digits 1-9 without repetition.\n    2. Each column contains digits 1-9 without repetition.\n    3. Each of the nine 3x3 sub-boxes contains digits 1-9 without repetition.\n\n    Take a 9x9 board as input, where each cell is represented by an integer from 1 to 9,\n    or 0 if the cell is empty. Return True if the board is valid, False otherwise.\n\n    Example 1:\n    Input: [\n        [5,3,0,0,7,0,0,0,0],\n        [6,0,0,1,9,5,0,0,0],\n        [0,9,8,0,0,0,0,6,0],\n        [8,0,0,0,6,0,0,0,3],\n        [4,0,0,8,0,3,0,0,1],\n        [7,0,0,0,2,0,0,0,6],\n        [0,6,0,0,0,0,2,8,0],\n        [0,0,0,4,1,9,0,0,5],\n        [0,0,0,0,8,0,0,7,9]\n    ]\n    Output: True\n\n    Example 2:\n    Input: [\n        [8,3,0,0,7,0,0,0,0],\n        [6,0,0,1,9,5,0,0,0],\n        [0,9,8,0,0,0,0,6,0],\n        [8,0,0,0,6,0,0,0,3],\n        [4,0,0,8,0,3,0,0,1],\n        [7,0,0,0,2,0,0,0,6],\n        [0,6,0,0,0,0,2,8,0],\n        [0,0,0,4,1,9,0,0,5],\n        [0,0,0,0,8,0,0,7,9]\n    ]\n    Output: False\n    \"\"\"\n", "entry_point": "valid_sudoku", "solution": "    def is_valid_unit(unit):\n        seen = set()\n        for num in unit:\n            if num != 0:\n                if num in seen:\n                    return False\n                seen.add(num)\n        return True\n\n    # Check rows\n    for row in board:\n        if not is_valid_unit(row):\n            return False\n\n    # Check columns\n    for col in zip(*board):\n        if not is_valid_unit(col):\n            return False\n\n    # Check 3x3 sub-boxes\n    for i in range(0, 9, 3):\n        for j in range(0, 9, 3):\n            sub_box = [board[x][y] for x in range(i, i+3) for y in range(j, j+3)]\n            if not is_valid_unit(sub_box):\n                return False\n\n    return True\n", "test": "def check(candidate):\n    assert candidate([[0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0]]) == True\n    assert candidate([[1,1,1,1,1,1,1,1,1],[2,2,2,2,2,2,2,2,2],[3,3,3,3,3,3,3,3,3],[4,4,4,4,4,4,4,4,4],[5,5,5,5,5,5,5,5,5],[6,6,6,6,6,6,6,6,6],[7,7,7,7,7,7,7,7,7],[8,8,8,8,8,8,8,8,8],[9,9,9,9,9,9,9,9,9]]) == False\n    assert candidate([[5,3,0,0,7,0,0,0,0],[6,0,0,1,9,5,0,0,0],[0,9,8,0,0,0,0,6,0],[8,0,0,0,6,0,0,0,3],[4,0,0,8,0,3,0,0,1],[7,0,0,0,2,0,0,0,6],[0,6,0,0,0,0,2,8,0],[0,0,0,4,1,9,0,0,5],[0,0,0,0,8,0,0,7,9]]) == True\n    assert candidate([[8,3,0,0,7,0,0,0,0],[6,0,0,1,9,5,0,0,0],[0,9,8,0,0,0,0,6,0],[8,0,0,0,6,0,0,0,3],[4,0,0,8,0,3,0,0,1],[7,0,0,0,2,0,0,0,6],[0,6,0,0,0,0,2,8,0],[0,0,0,4,1,9,0,0,5],[0,0,0,0,8,0,0,7,9]]) == False\n    assert candidate([[1,2,3,4,5,6,7,8,9],[4,5,6,7,8,9,1,2,3],[7,8,9,1,2,3,4,5,6],[2,3,4,5,6,7,8,9,1],[5,6,7,8,9,1,2,3,4],[8,9,1,2,3,4,5,6,7],[3,4,5,6,7,8,9,1,2],[6,7,8,9,1,2,3,4,5],[9,1,2,3,4,5,6,7,8]]) == True\n", "language": "python"}
{"task_id": "revision1a_problem673", "prompt": "from typing import List\n\ndef optimize_production(machines: List[int], target: int) -> int:\n    \"\"\"\n    You are managing a factory with several machines, each with different production rates.\n    The machines are represented by a list 'machines', where each value is the number of units a machine can produce per hour.\n    Your goal is to reach a target production of 'target' units in the least amount of time.\n\n    You can only use one machine at a time, but you can switch between machines instantly.\n    The task is to determine the minimum number of hours needed to reach or exceed the target production.\n\n    Take a list 'machines' and an integer 'target' as input, and return the minimum number of hours required.\n\n    Example 1:\n    Input: machines = [3, 1, 2], target = 10\n    Output: 4\n\n    Example 2:\n    Input: machines = [5, 2, 4], target = 15\n    Output: 3\n\n    Constraints:\n    1 <= len(machines) <= 10^5\n    1 <= machines[i] <= 10^9\n    1 <= target <= 10^9\n    \"\"\"\n", "entry_point": "optimize_production", "solution": "    \n    def can_produce(hours: int) -> bool:\n        return sum(min(m * hours, target) for m in machines) >= target\n\n    left, right = 0, target\n    while left < right:\n        mid = (left + right) // 2\n        if can_produce(mid):\n            right = mid\n        else:\n            left = mid + 1\n\n    return left\n", "test": "def check(candidate):\n    assert candidate([1], 5) == 5\n    assert candidate([1, 1, 1, 1, 1], 10) == 2\n    assert candidate([2, 3, 5, 7, 11], 100) == 4\n    assert candidate([1, 10, 100, 1000], 1111) == 1\n    assert candidate([1, 2, 3, 4, 5], 1) == 1\n    assert candidate([3, 1, 2], 10) == 2\n    assert candidate([10, 20, 30], 100) == 2\n    assert candidate([7, 7, 7], 50) == 3\n    assert candidate([5, 2, 4], 15) == 2\n    assert candidate([1000000000], 1000000000) == 1\n", "language": "python"}
{"task_id": "revision1a_problem383", "prompt": "import datetime\n\ndef calculate_age(data: str) -> str:\n    \"\"\"\n    You are developing a health tracking application that needs to calculate a user's exact age.\n\n    Create a function that calculates a person's age precisely, including years, months, and days.\n    The function should:\n    1. Take input from the user in the format \"YYYY-MM-DD\" (birth date)\n    2. Calculate the age as of today's date\n    3. Return a string with the age in years, months, and days\n\n    Use the datetime module to perform date calculations accurately, accounting for leap years\n    and varying month lengths.\n\n    Example:\n    Input: \"1990-05-15\"\n    Output: \"33 years, 0 months, 12 days\"\n\n    Note: The output will vary depending on the current date when the function is run.\n    \"\"\"\n", "entry_point": "calculate_age", "solution": "    # Parse the input date string\n    birth_date = datetime.datetime.strptime(data, \"%Y-%m-%d\").date()\n    \n    # Get today's date\n    today = datetime.date.today()\n    \n    # Calculate the difference between today and birth date\n    age = today - birth_date\n    \n    # Extract years, remaining days\n    years = age.days // 365\n    remaining_days = age.days % 365\n    \n    # Calculate months and days\n    temp_date = birth_date.replace(year=today.year)\n    if temp_date > today:\n        temp_date = temp_date.replace(year=today.year - 1)\n    \n    months = (today.month - temp_date.month) % 12\n    if today.day < temp_date.day:\n        months = (months - 1) % 12\n    \n    days = (today - temp_date.replace(month=today.month, year=today.year)).days\n    if days < 0:\n        days += (temp_date.replace(month=today.month, year=today.year) - temp_date.replace(day=1, month=today.month, year=today.year)).days\n    \n    # Format the result string\n    result = f\"{years} years, {months} months, {days} days\"\n    \n    return result\n", "test": "def check(candidate):\n    assert candidate(\"2005-09-11\") == '19 years, 3 months, 0 days'\n    assert candidate(\"2010-02-28\") == '14 years, 9 months, 10 days'\n    assert candidate(\"1960-03-17\") == '64 years, 8 months, 10 days'\n    assert candidate(\"2023-05-27\") == '1 years, 6 months, 10 days'\n    assert candidate(\"1985-11-30\") == '39 years, 0 months, 10 days'\n    assert candidate(\"1950-06-15\") == '74 years, 5 months, 10 days'\n    assert candidate(\"1990-01-01\") == '34 years, 11 months, 10 days'\n    assert candidate(\"1975-07-04\") == '49 years, 5 months, 7 days'\n    assert candidate(\"2000-12-31\") == '23 years, 11 months, 10 days'\n    assert candidate(\"1999-12-25\") == '24 years, 11 months, 10 days'\n", "language": "python"}
{"task_id": "revision1a_problem651", "prompt": "import heapq\nfrom typing import List, Tuple\n\ndef schedule_tasks(tasks: List[Tuple[int, int, int]], processors: int) -> List[List[int]]:\n    \"\"\"\n    In a high-performance computing environment, you need to schedule a set of tasks across multiple processors. Each task has a start time, duration, and priority. The goal is to maximize the utilization of processors while prioritizing high-priority tasks.\n\n    Parameters:\n    tasks (List[Tuple[int, int, int]]): A list of tuples, each containing (start_time, duration, priority) for a task.\n    processors (int): The number of available processors.\n\n    Returns:\n    List[List[int]]: A list of lists, where each inner list represents a processor's schedule. \n                     Each element in the inner list is the index of the task in the original task list.\n\n    Rules:\n    1. Tasks with higher priority (higher number) should be scheduled first.\n    2. If a processor is free and multiple tasks are available, choose the one with the earliest start time.\n    3. A task can only start at or after its start time.\n    4. Processors can have idle time between tasks.\n\n    Example:\n    Input:\n    tasks = [(0, 3, 2), (1, 2, 1), (3, 4, 3), (4, 2, 2), (5, 3, 1)]\n    processors = 2\n\n    Output: [[0, 3], [2, 4]]\n\n    Explanation:\n    Processor 0: Task 0 (0-3), Task 3 (4-6)\n    Processor 1: Task 2 (3-7), Task 4 (7-10)\n    Task 1 is not scheduled due to lower priority and conflict with higher priority tasks.\n    \"\"\"\n", "entry_point": "schedule_tasks", "solution": "    # Sort tasks by priority (descending) and start time (ascending)\n    sorted_tasks = sorted(enumerate(tasks), key=lambda x: (-x[1][2], x[1][0]))\n    \n    # Initialize processor schedules and their current time\n    schedules = [[] for _ in range(processors)]\n    processor_times = [0] * processors\n    \n    # Priority queue to keep track of available processors\n    available_processors = [(0, i) for i in range(processors)]\n    heapq.heapify(available_processors)\n    \n    for task_index, (start_time, duration, priority) in sorted_tasks:\n        # Find the earliest available processor\n        while available_processors and available_processors[0][0] < start_time:\n            _, proc = heapq.heappop(available_processors)\n            heapq.heappush(available_processors, (start_time, proc))\n        \n        if available_processors:\n            # Schedule the task on the earliest available processor\n            current_time, proc = heapq.heappop(available_processors)\n            start_time = max(current_time, start_time)\n            end_time = start_time + duration\n            schedules[proc].append(task_index)\n            heapq.heappush(available_processors, (end_time, proc))\n    \n    return schedules\n", "test": "def check(candidate):\n    assert candidate([(0, 1, 1)], 5) == [[0], [], [], [], []]\n    assert candidate([(0, 1, 1), (0, 1, 2)], 1) == [[1, 0]]\n    assert candidate([(0, 10, 5), (0, 5, 3), (0, 3, 1)], 1) == [[0, 1, 2]]\n    assert candidate([(0, 1, 1), (0, 1, 2), (0, 1, 3)], 3) == [[2], [1], [0]]\n    assert candidate([(0, 1, 1), (1, 1, 1), (2, 1, 1), (3, 1, 1)], 2) == [[0, 1, 2, 3], []]\n    assert candidate([(i, 1, 1) for i in range(10)], 3) == [[0, 1, 2, 3, 4, 5, 6, 7, 8, 9], [], []]\n    assert candidate([(0, 1, 1), (1, 1, 2), (2, 1, 3)], 3) == [[2], [1], [0]]\n    assert candidate([(0, 5, 1), (1, 4, 2), (2, 3, 3), (3, 2, 4), (4, 1, 5)], 2) == [[4, 2, 0], [3, 1]]\n    assert candidate([(0, 5, 1)], 1) == [[0]]\n    assert candidate([(0, 3, 2), (1, 2, 1), (3, 4, 3), (4, 2, 2), (5, 3, 1)], 2) == [[2, 1], [0, 3, 4]]\n", "language": "python"}
{"task_id": "revision1a_problem73", "prompt": "def encrypt_message(message: str, shift: int) -> str:\n    \"\"\"\n    You're a secret agent tasked with encrypting sensitive information. Your agency uses a modified Caesar cipher where each letter is shifted by a given number of positions in the alphabet.\n\n    Write a function that takes a message (string) and a shift value (integer) as input. The function should return the encrypted message.\n\n    Rules:\n    1. Shift each letter in the message by the given number of positions.\n    2. Wrap around the alphabet if necessary (e.g., 'z' shifted by 1 becomes 'a').\n    3. Preserve spaces and punctuation.\n    4. Maintain the case of the original letters.\n\n    Example:\n    Input: \"Hello, World!\", 3\n    Output: \"Khoor, Zruog!\"\n\n    Input: \"Secret Mission\", 7\n    Output: \"Zljyla Tpzzpvu\"\n\n    Note: The function should handle both positive and negative shift values.\n    \"\"\"\n", "entry_point": "encrypt_message", "solution": "    def shift_char(char: str, shift: int) -> str:\n        if not char.isalpha():\n            return char\n        \n        ascii_offset = ord('A') if char.isupper() else ord('a')\n        shifted = (ord(char) - ascii_offset + shift) % 26\n        return chr(shifted + ascii_offset)\n\n    encrypted_message = ''\n    for char in message:\n        encrypted_message += shift_char(char, shift)\n    \n    return encrypted_message\n", "test": "def check(candidate):\n    assert candidate(\"Test123!\", 0) == 'Test123!'\n    assert candidate(\"!@#$%^&*()\", 10) == '!@#$%^&*()'\n    assert candidate(\"AbCdEf\", 1) == 'BcDeFg'\n    assert candidate(\"Caesar Cipher\", -3) == 'Zxbpxo Zfmebo'\n    assert candidate(\"\", 5) == ''\n    assert candidate(\"XyZ\", 2) == 'ZaB'\n    assert candidate(\"Secret Mission\", 7) == 'Zljyla Tpzzpvu'\n    assert candidate(\"A B C\", -1) == 'Z A B'\n    assert candidate(\"Hello, World!\", 3) == 'Khoor, Zruog!'\n    assert candidate(\"Zebra\", 26) == 'Zebra'\n", "language": "python"}
{"task_id": "revision1a_problem183", "prompt": "from collections import deque, Counter\nfrom typing import List\n\ndef optimize_schedule(tasks: List[str], cooldown: int) -> int:\n    \"\"\"\n    I have a list of tasks to complete on my computer.\n    Each task is represented by a single character.\n    After completing a task, I need to wait for a cooldown period before I can do the same task again.\n    Your goal is to find the minimum number of units of time needed to complete all tasks.\n    Take the list of tasks and cooldown period as input from the user.\n    Use a queue and dictionary to solve this problem efficiently.\n\n    Example 1:\n    Input: ['A','A','A','B','B','B'], 2\n    Output: 8\n    Explanation: A -> B -> idle -> A -> B -> idle -> A -> B\n\n    Example 2:\n    Input: ['A','A','A','B','B','B'], 0\n    Output: 6\n    Explanation: A -> A -> A -> B -> B -> B\n    \"\"\"\n", "entry_point": "optimize_schedule", "solution": "    if not tasks:\n        return 0\n\n    task_counts = Counter(tasks)\n    queue = deque([(task, count) for task, count in task_counts.items()])\n    time = 0\n    cooldown_queue = deque()\n\n    while queue or cooldown_queue:\n        time += 1\n\n        if cooldown_queue and cooldown_queue[0][1] <= time:\n            queue.append(cooldown_queue.popleft()[0])\n\n        if queue:\n            task, count = queue.popleft()\n            count -= 1\n            if count > 0:\n                cooldown_queue.append(((task, count), time + cooldown + 1))\n\n    return time\n", "test": "def check(candidate):\n    assert candidate(['A', 'A', 'A', 'A'], 3) == 13\n    assert candidate(['A', 'A', 'A', 'B', 'B', 'B'], 0) == 6\n    assert candidate(['A', 'A', 'B', 'B', 'C', 'C'], 1) == 6\n    assert candidate(['A', 'B', 'C', 'A', 'B', 'C'], 2) == 6\n    assert candidate(['A', 'B'], 100) == 2\n    assert candidate(['A'], 0) == 1\n    assert candidate(['A', 'A', 'A', 'B', 'B', 'B'], 2) == 8\n    assert candidate(['A', 'B', 'A', 'B'], 1) == 4\n    assert candidate(['Z', 'Y', 'X', 'W', 'V', 'U'], 0) == 6\n", "language": "python"}
{"task_id": "revision1a_problem155", "prompt": "from typing import List, Tuple\n\ndef optimize_study_schedule(subjects: List[str], difficulties: List[int], time_slots: List[int]) -> List[Tuple[str, int]]:\n    \"\"\"\n    As a student preparing for final exams, I need to create an optimal study schedule.\n    I have a list of subjects to study, their difficulty levels, and available time slots.\n    The goal is to assign subjects to time slots in a way that maximizes learning efficiency.\n\n    Rules for optimization:\n    1. More difficult subjects should be assigned to longer time slots when possible.\n    2. No subject should be studied for more than 2 hours at a stretch.\n    3. Try to distribute subjects evenly throughout the schedule.\n\n    The function should take three inputs:\n    - A list of subject names\n    - A list of corresponding difficulty levels (1-10, 10 being most difficult)\n    - A list of available time slots in minutes\n\n    It should return a list of tuples, each containing a subject name and its assigned time slot.\n    If it's impossible to create a valid schedule, return an empty list.\n\n    Example:\n    Input: \n    subjects = [\"Math\", \"History\", \"Physics\", \"Literature\"]\n    difficulties = [8, 5, 9, 6]\n    time_slots = [60, 45, 90, 30, 120]\n    Output: \n    [(\"Physics\", 120), (\"Math\", 90), (\"Literature\", 60), (\"History\", 45)]\n    \"\"\"\n", "entry_point": "optimize_study_schedule", "solution": "    \n    # Check if inputs are valid\n    if len(subjects) != len(difficulties) or len(subjects) > len(time_slots):\n        return []\n\n    # Create a list of tuples with (subject, difficulty)\n    subject_difficulty = list(zip(subjects, difficulties))\n    \n    # Sort subjects by difficulty (descending) and time slots by duration (descending)\n    subject_difficulty.sort(key=lambda x: x[1], reverse=True)\n    time_slots.sort(reverse=True)\n\n    schedule = []\n    used_slots = set()\n\n    for subject, difficulty in subject_difficulty:\n        assigned = False\n        for slot in time_slots:\n            if slot <= 120 and slot not in used_slots:  # Rule 2: No more than 2 hours\n                schedule.append((subject, slot))\n                used_slots.add(slot)\n                assigned = True\n                break\n        \n        if not assigned:\n            return []  # Unable to create a valid schedule\n\n    # Try to improve distribution (Rule 3)\n    schedule.sort(key=lambda x: x[1], reverse=True)\n    \n    # Swap subjects if it improves distribution without violating difficulty order\n    for i in range(len(schedule) - 1):\n        for j in range(i + 1, len(schedule)):\n            if (subject_difficulty.index((schedule[i][0], difficulties[subjects.index(schedule[i][0])])) >\n                subject_difficulty.index((schedule[j][0], difficulties[subjects.index(schedule[j][0])]))):\n                schedule[i], schedule[j] = schedule[j], schedule[i]\n\n    return schedule\n", "test": "def check(candidate):\n    assert candidate([\"Computer Science\"], [10], [120]) == [('Computer Science', 120)]\n    assert candidate([\"French\", \"Spanish\", \"German\", \"Italian\", \"Chinese\"], [6, 5, 7, 6, 8], [60, 60, 60, 60, 60]) == []\n    assert candidate([\"Physics\", \"Chemistry\", \"Biology\", \"Math\"], [9, 8, 7, 10], [30, 45, 60, 90]) == [('Math', 90), ('Physics', 60), ('Chemistry', 45), ('Biology', 30)]\n    assert candidate([\"Geography\", \"Economics\"], [5, 7], [45, 60, 75]) == [('Economics', 75), ('Geography', 60)]\n    assert candidate([\"Algebra\", \"Geometry\", \"Trigonometry\"], [8, 7, 9], [120, 120, 120]) == []\n    assert candidate([\"Psychology\", \"Sociology\"], [5, 6], [150]) == []\n    assert candidate([], [], []) == []\n    assert candidate([\"Chemistry\", \"Biology\", \"English\"], [7, 6, 4], [120, 90, 60]) == [('Chemistry', 120), ('Biology', 90), ('English', 60)]\n    assert candidate([\"Art\", \"Music\", \"PE\"], [3, 2, 1], [30, 30, 30]) == []\n    assert candidate([\"Math\", \"History\", \"Physics\", \"Literature\"], [8, 5, 9, 6], [60, 45, 90, 30, 120]) == [('Physics', 120), ('Math', 90), ('Literature', 60), ('History', 45)]\n", "language": "python"}
{"task_id": "revision1a_problem602", "prompt": "from typing import List, Tuple\n\ndef calculate_carbon_footprint(activities: List[Tuple[str, float]]) -> float:\n    \"\"\"\n    Calculate an individual's carbon footprint based on their daily activities.\n    Each activity has an associated carbon emission factor.\n\n    Use a dictionary to store emission factors and implement error handling for invalid activities.\n\n    Parameters:\n    activities (List[Tuple[str, float]]): A list of tuples, where each tuple contains an activity name and its duration in hours.\n\n    Returns:\n    float: The total carbon footprint in kg CO2e.\n\n    Example:\n    Input: [(\"driving\", 2.5), (\"cooking\", 1.0), (\"watching_tv\", 3.0), (\"sleeping\", 8.0)]\n    Output: 28.75  # Assuming emission factors: driving=10, cooking=2, watching_tv=0.5, sleeping=0.1 kg CO2e per hour\n\n    Raises:\n    ValueError: If an invalid activity is provided.\n    \"\"\"\n", "entry_point": "calculate_carbon_footprint", "solution": "    # Define emission factors for different activities (kg CO2e per hour)\n    emission_factors = {\n        \"driving\": 10.0,\n        \"cooking\": 2.0,\n        \"watching_tv\": 0.5,\n        \"sleeping\": 0.1,\n        # Add more activities and their emission factors as needed\n    }\n\n    total_carbon_footprint = 0.0\n\n    for activity, duration in activities:\n        if activity not in emission_factors:\n            raise ValueError(f\"Invalid activity: {activity}\")\n        \n        carbon_emission = emission_factors[activity] * duration\n        total_carbon_footprint += carbon_emission\n\n    return round(total_carbon_footprint, 2)\n", "test": "def check(candidate):\n    assert candidate([(\"driving\", 1.5), (\"cooking\", 0.75), (\"watching_tv\", 2.25), (\"sleeping\", 7.5)]) == 18.38\n    assert candidate([(\"driving\", -1.0)]) == -10.0\n    assert candidate([(\"driving\", 0.01), (\"cooking\", 0.01), (\"sleeping\", 0.01)]) == 0.12\n    assert candidate([(\"sleeping\", 24.0)]) == 2.4\n    assert candidate([]) == 0.0\n    assert candidate([(\"cooking\", 0.0)]) == 0.0\n    assert candidate([(\"driving\", 24.0)]) == 240.0\n    assert candidate([(\"driving\", 1.0), (\"driving\", 2.0), (\"driving\", 3.0)]) == 60.0\n    assert candidate([(\"driving\", 2.5), (\"cooking\", 1.0), (\"watching_tv\", 3.0), (\"sleeping\", 8.0)]) == 29.3\n", "language": "python"}
{"task_id": "revision1a_problem200", "prompt": "from typing import List, Tuple\n\ndef network_stability(connections: List[Tuple[int, int]], n: int) -> float:\n    \"\"\"\n    You are analyzing the stability of a computer network with n nodes (numbered from 0 to n-1).\n    The network connections are represented as a list of tuples, where each tuple (a, b) indicates\n    a connection between node a and node b.\n\n    The stability of the network is defined as the probability that the network remains functional\n    if any single node fails. A network is functional if all remaining nodes can still communicate\n    with each other (directly or indirectly).\n\n    Calculate and return the stability of the network as a float between 0 and 1.\n\n    Use graph theory concepts and implement a depth-first search (DFS) algorithm to solve this problem.\n\n    Example:\n    Input: connections = [(0,1), (1,2), (2,3)], n = 4\n    Output: 0.5\n    Input: connections = [(0,1), (1,2), (2,3), (3,0), (0,2)], n = 4\n    Output: 1.0\n    Input: connections = [(0,1), (2,3)], n = 4\n    Output: 0.0\n    \"\"\"\n", "entry_point": "network_stability", "solution": "    def build_graph(connections: List[Tuple[int, int]], n: int) -> List[List[int]]:\n        graph = [[] for _ in range(n)]\n        for a, b in connections:\n            graph[a].append(b)\n            graph[b].append(a)\n        return graph\n\n    def dfs(graph: List[List[int]], start: int, excluded: int, visited: set) -> None:\n        visited.add(start)\n        for neighbor in graph[start]:\n            if neighbor != excluded and neighbor not in visited:\n                dfs(graph, neighbor, excluded, visited)\n\n    graph = build_graph(connections, n)\n    functional_count = 0\n\n    for excluded in range(n):\n        visited = set()\n        start = next((i for i in range(n) if i != excluded), None)\n        \n        if start is not None:\n            dfs(graph, start, excluded, visited)\n            \n            if len(visited) == n - 1:\n                functional_count += 1\n\n    return functional_count / n\n", "test": "def check(candidate):\n    assert candidate([(0,1), (0,2), (0,3), (0,4)], 5) == 0.8\n    assert candidate([(0,1), (1,2), (2,0)], 3) == 1.0\n    assert candidate([(0,1), (1,2), (2,3), (3,4), (4,0)], 5) == 1.0\n    assert candidate([(0,1), (1,2), (2,3), (3,0), (0,2)], 4) == 1.0\n    assert candidate([], 1) == 0.0\n    assert candidate([(0,1), (1,2), (2,3)], 4) == 0.5\n    assert candidate([(0,1), (1,2), (2,3), (3,4), (4,5), (5,0)], 6) == 1.0\n    assert candidate([(0,1), (2,3)], 4) == 0.0\n    assert candidate([], 5) == 0.0\n    assert candidate([(0,1)], 2) == 1.0\n", "language": "python"}
{"task_id": "revision1a_problem516", "prompt": "import itertools\n\ndef decode_message(encoded: str, key: str) -> str:\n    \"\"\"\n    You are a cryptographer working for a secret agency. You've intercepted an encoded message and its corresponding key.\n    The message is encoded using a simple substitution cipher where each letter in the original message is replaced by another letter.\n    Your task is to decode the message using the provided key.\n\n    The key is a string where each character represents the encoded version of the corresponding letter in the alphabet (a-z).\n    The encoded message consists only of lowercase letters and spaces.\n\n    Example:\n    Input: encoded = \"uijt jt b tfdsfu nfttbhf\", key = \"bcdefghijklmnopqrstuvwxyz\"\n    Output: \"this is a secret message\"\n\n    Input: encoded = \"dszquphsbqiz jt gvo\", key = \"bcdefghijklmnopqrstuvwxyz\"\n    Output: \"cryptography is fun\"\n    \"\"\"\n", "entry_point": "decode_message", "solution": "    # Create a decoding dictionary using the key\n    alphabet = 'abcdefghijklmnopqrstuvwxyz'\n    decoding_dict = dict(zip(key, alphabet))\n    \n    # Decode the message\n    decoded = ''\n    for char in encoded:\n        if char == ' ':\n            decoded += ' '\n        else:\n            decoded += decoding_dict[char]\n    \n    return decoded\n", "test": "def check(candidate):\n    assert candidate(\"aaaaaa\", \"bcdefghijklmnopqrstuvwxyza\") == 'zzzzzz'\n    assert candidate(\"dszquphsbqiz jt gvo\", \"bcdefghijklmnopqrstuvwxyz\") == 'cryptography is fun'\n    assert candidate(\"abc\", \"cbafedghijklmnopqrstuvwxyz\") == 'cba'\n    assert candidate(\"a\", \"abcdefghijklmnopqrstuvwxyz\") == 'a'\n    assert candidate(\"\", \"abcdefghijklmnopqrstuvwxyz\") == ''\n    assert candidate(\"uijt jt b tfdsfu nfttbhf\", \"bcdefghijklmnopqrstuvwxyz\") == 'this is a secret message'\n    assert candidate(\"abcdefghijklmnopqrstuvwxyz\", \"zyxwvutsrqponmlkjihgfedcba\") == 'zyxwvutsrqponmlkjihgfedcba'\n    assert candidate(\" \", \"abcdefghijklmnopqrstuvwxyz\") == ' '\n    assert candidate(\"z\", \"abcdefghijklmnopqrstuvwxyz\") == 'z'\n    assert candidate(\"zyxwvutsrqponmlkjihgfedcba\", \"zyxwvutsrqponmlkjihgfedcba\") == 'abcdefghijklmnopqrstuvwxyz'\n", "language": "python"}
{"task_id": "revision1a_problem719", "prompt": "from typing import List, Tuple\n\ndef traffic_flow_simulation(grid_size: Tuple[int, int], cars: List[Tuple[int, int, str]], time_steps: int) -> List[List[str]]:\n    \"\"\"\n    A city planner needs to simulate traffic flow in a grid-like city to optimize traffic light patterns.\n    Implement a traffic simulation on a 2D grid where cars move according to their initial directions.\n    \n    The function should:\n    1. Initialize the grid with cars in their starting positions\n    2. Update car positions for each time step\n    3. Handle collisions by removing colliding cars\n    4. Return the final state of the grid after all time steps\n    \n    Parameters:\n    - grid_size: A tuple (rows, cols) representing the size of the city grid\n    - cars: A list of tuples (row, col, direction) representing initial car positions and directions\n             Direction can be 'N', 'S', 'E', or 'W'\n    - time_steps: The number of time steps to simulate\n    \n    Returns:\n    - A 2D list representing the final state of the grid, where:\n      '.' represents an empty cell\n      'C' represents a car\n    \n    Example:\n    Input: (3, 3), [(0, 0, 'E'), (1, 1, 'N'), (2, 2, 'W')], 2\n    Output: [['.','.','C'],\n             ['C','.',''],\n             ['.','.','.']]\n    \"\"\"\n", "entry_point": "traffic_flow_simulation", "solution": "    rows, cols = grid_size\n    grid = [['.' for _ in range(cols)] for _ in range(rows)]\n    \n    def move_car(row, col, direction):\n        if direction == 'N':\n            return (row - 1, col) if row > 0 else None\n        elif direction == 'S':\n            return (row + 1, col) if row < rows - 1 else None\n        elif direction == 'E':\n            return (row, col + 1) if col < cols - 1 else None\n        elif direction == 'W':\n            return (row, col - 1) if col > 0 else None\n    \n    for _ in range(time_steps):\n        new_cars = []\n        car_positions = set()\n        \n        for row, col, direction in cars:\n            new_position = move_car(row, col, direction)\n            if new_position:\n                new_row, new_col = new_position\n                if (new_row, new_col) not in car_positions:\n                    new_cars.append((new_row, new_col, direction))\n                    car_positions.add((new_row, new_col))\n        \n        cars = new_cars\n    \n    for row, col, _ in cars:\n        grid[row][col] = 'C'\n    \n    return grid\n", "test": "def check(candidate):\n    assert candidate((10, 10), [(0, 0, 'E'), (9, 9, 'W'), (5, 5, 'N'), (4, 4, 'S')], 20) == [['.', '.', '.', '.', '.', '.', '.', '.', '.', '.'], ['.', '.', '.', '.', '.', '.', '.', '.', '.', '.'], ['.', '.', '.', '.', '.', '.', '.', '.', '.', '.'], ['.', '.', '.', '.', '.', '.', '.', '.', '.', '.'], ['.', '.', '.', '.', '.', '.', '.', '.', '.', '.'], ['.', '.', '.', '.', '.', '.', '.', '.', '.', '.'], ['.', '.', '.', '.', '.', '.', '.', '.', '.', '.'], ['.', '.', '.', '.', '.', '.', '.', '.', '.', '.'], ['.', '.', '.', '.', '.', '.', '.', '.', '.', '.'], ['.', '.', '.', '.', '.', '.', '.', '.', '.', '.']]\n    assert candidate((4, 4), [(0, 0, 'E'), (0, 3, 'W')], 3) == [['C', '.', '.', 'C'], ['.', '.', '.', '.'], ['.', '.', '.', '.'], ['.', '.', '.', '.']]\n    assert candidate((5, 5), [(0, 0, 'E'), (0, 1, 'E'), (0, 2, 'E'), (0, 3, 'E'), (0, 4, 'E')], 5) == [['.', '.', '.', '.', '.'], ['.', '.', '.', '.', '.'], ['.', '.', '.', '.', '.'], ['.', '.', '.', '.', '.'], ['.', '.', '.', '.', '.']]\n    assert candidate((2, 2), [(0, 0, 'E'), (1, 1, 'W')], 1) == [['.', 'C'], ['C', '.']]\n    assert candidate((3, 3), [(0, 0, 'E'), (1, 1, 'N'), (2, 2, 'W')], 2) == [['.', '.', 'C'], ['.', '.', '.'], ['C', '.', '.']]\n    assert candidate((5, 5), [(0, 0, 'E'), (4, 4, 'W'), (2, 2, 'N'), (3, 3, 'S')], 5) == [['.', '.', '.', '.', '.'], ['.', '.', '.', '.', '.'], ['.', '.', '.', '.', '.'], ['.', '.', '.', '.', '.'], ['.', '.', '.', '.', '.']]\n    assert candidate((6, 6), [(0, 0, 'S'), (5, 5, 'N'), (2, 2, 'E'), (3, 3, 'W')], 10) == [['.', '.', '.', '.', '.', '.'], ['.', '.', '.', '.', '.', '.'], ['.', '.', '.', '.', '.', '.'], ['.', '.', '.', '.', '.', '.'], ['.', '.', '.', '.', '.', '.'], ['.', '.', '.', '.', '.', '.']]\n    assert candidate((1, 1), [(0, 0, 'N')], 1) == [['.']]\n    assert candidate((4, 4), [(0, 0, 'E'), (1, 1, 'S'), (2, 2, 'W'), (3, 3, 'N')], 4) == [['.', '.', '.', '.'], ['.', '.', '.', '.'], ['.', '.', '.', '.'], ['.', '.', '.', '.']]\n", "language": "python"}
{"task_id": "revision1a_problem241", "prompt": "from typing import List, Tuple\nimport math\n\ndef optimize_delivery_route(locations: List[Tuple[float, float]], start: Tuple[float, float]) -> List[Tuple[float, float]]:\n    \"\"\"\n    Given a list of delivery locations (as latitude-longitude pairs) and a starting point,\n    determine the most efficient route to visit all locations and return to the start.\n    \n    This function uses the Traveling Salesman Problem (TSP) approach to optimize the delivery route\n    for a courier service. It takes into account the distances between locations and aims to minimize\n    the total distance traveled.\n    \n    Args:\n    locations (List[Tuple[float, float]]): A list of tuples representing latitude and longitude of delivery points\n    start (Tuple[float, float]): The starting point (latitude, longitude) for the courier\n    \n    Returns:\n    List[Tuple[float, float]]: An ordered list of locations representing the optimized route\n    \n    Example:\n    Input: locations = [(40.7128, -74.0060), (34.0522, -118.2437), (41.8781, -87.6298)], start = (42.3601, -71.0589)\n    Output: [(42.3601, -71.0589), (40.7128, -74.0060), (41.8781, -87.6298), (34.0522, -118.2437), (42.3601, -71.0589)]\n    \n    Input: locations = [(48.8566, 2.3522), (51.5074, -0.1278), (41.9028, 12.4964)], start = (52.5200, 13.4050)\n    Output: [(52.5200, 13.4050), (51.5074, -0.1278), (48.8566, 2.3522), (41.9028, 12.4964), (52.5200, 13.4050)]\n    \"\"\"\n", "entry_point": "optimize_delivery_route", "solution": "    def calculate_distance(point1: Tuple[float, float], point2: Tuple[float, float]) -> float:\n        \"\"\"Calculate the Haversine distance between two points on the Earth's surface.\"\"\"\n        lat1, lon1 = point1\n        lat2, lon2 = point2\n        R = 6371  # Earth's radius in kilometers\n\n        dlat = math.radians(lat2 - lat1)\n        dlon = math.radians(lon2 - lon1)\n        a = (math.sin(dlat/2) ** 2 +\n             math.cos(math.radians(lat1)) * math.cos(math.radians(lat2)) *\n             math.sin(dlon/2) ** 2)\n        c = 2 * math.atan2(math.sqrt(a), math.sqrt(1-a))\n        return R * c\n\n    unvisited = locations.copy()\n    route = [start]\n    current = start\n\n    while unvisited:\n        nearest = min(unvisited, key=lambda x: calculate_distance(current, x))\n        route.append(nearest)\n        current = nearest\n        unvisited.remove(nearest)\n\n    route.append(start)  # Return to the starting point\n    return route\n", "test": "def check(candidate):\n    assert candidate([(48.8566, 2.3522), (51.5074, -0.1278), (41.9028, 12.4964)], (52.5200, 13.4050)) == [(52.52, 13.405), (48.8566, 2.3522), (51.5074, -0.1278), (41.9028, 12.4964), (52.52, 13.405)]\n    assert candidate([(-90.0, -180.0), (90.0, 180.0)], (0.0, 0.0)) == [(0.0, 0.0), (-90.0, -180.0), (90.0, 180.0), (0.0, 0.0)]\n    assert candidate([(0.0, 0.0), (1.0, 1.0), (2.0, 2.0), (3.0, 3.0), (4.0, 4.0)], (0.0, 0.0)) == [(0.0, 0.0), (0.0, 0.0), (1.0, 1.0), (2.0, 2.0), (3.0, 3.0), (4.0, 4.0), (0.0, 0.0)]\n    assert candidate([(40.7128, -74.0060), (34.0522, -118.2437), (41.8781, -87.6298)], (42.3601, -71.0589)) == [(42.3601, -71.0589), (40.7128, -74.006), (41.8781, -87.6298), (34.0522, -118.2437), (42.3601, -71.0589)]\n    assert candidate([(1.0, 1.0)], (0.0, 0.0)) == [(0.0, 0.0), (1.0, 1.0), (0.0, 0.0)]\n    assert candidate([(0.1, 0.1), (0.2, 0.2), (0.3, 0.3)], (0.0, 0.0)) == [(0.0, 0.0), (0.1, 0.1), (0.2, 0.2), (0.3, 0.3), (0.0, 0.0)]\n    assert candidate([(90.0, 0.0), (0.0, 180.0), (-90.0, 0.0), (0.0, -180.0)], (45.0, 45.0)) == [(45.0, 45.0), (90.0, 0.0), (0.0, 180.0), (0.0, -180.0), (-90.0, 0.0), (45.0, 45.0)]\n    assert candidate([(0.0, 0.0), (0.0, 0.0), (0.0, 0.0)], (0.0, 0.0)) == [(0.0, 0.0), (0.0, 0.0), (0.0, 0.0), (0.0, 0.0), (0.0, 0.0)]\n    assert candidate([], (0.0, 0.0)) == [(0.0, 0.0), (0.0, 0.0)]\n    assert candidate([(1.0, 1.0), (2.0, 2.0), (3.0, 3.0)], (1.0, 1.0)) == [(1.0, 1.0), (1.0, 1.0), (2.0, 2.0), (3.0, 3.0), (1.0, 1.0)]\n", "language": "python"}
{"task_id": "revision1a_problem518", "prompt": "from math import radians, sin, cos, sqrt, atan2\nfrom typing import List, Tuple\nimport math\n\ndef optimize_delivery_route(locations: List[Tuple[float, float]], fuel_capacity: float, fuel_consumption: float) -> List[int]:\n    \"\"\"\n    A delivery company wants to optimize their route to minimize fuel consumption.\n    They have a list of locations represented by (latitude, longitude) coordinates,\n    a vehicle with a certain fuel capacity (in liters), and known fuel consumption (liters per km).\n    \n    Your task is to determine the best order to visit all locations, starting and ending at the first location (0),\n    while ensuring the vehicle doesn't run out of fuel. If it's impossible to visit all locations, return an empty list.\n    \n    Use a nearest neighbor algorithm with backtracking when fuel constraints are violated.\n    Calculate distances using the Haversine formula for accuracy.\n    \n    Input:\n    - locations: List of (latitude, longitude) tuples\n    - fuel_capacity: Maximum fuel the vehicle can carry (in liters)\n    - fuel_consumption: Fuel consumed per km (in liters)\n    \n    Output: List of indices representing the optimized route, or an empty list if not possible\n    \n    Example:\n    Input: [(0, 0), (1, 1), (2, 2), (3, 3)], 100.0, 0.1\n    Output: [0, 1, 2, 3, 0]\n    \n    Input: [(0, 0), (10, 10), (20, 20), (30, 30)], 50.0, 0.5\n    Output: []\n    \"\"\"\n", "entry_point": "optimize_delivery_route", "solution": "    def haversine_distance(loc1, loc2):\n        lat1, lon1 = map(math.radians, loc1)\n        lat2, lon2 = map(math.radians, loc2)\n        dlat = lat2 - lat1\n        dlon = lon2 - lon1\n        a = math.sin(dlat/2)**2 + math.cos(lat1) * math.cos(lat2) * math.sin(dlon/2)**2\n        c = 2 * math.atan2(math.sqrt(a), math.sqrt(1-a))\n        return 6371 * c  # Earth's radius in km\n\n    def nearest_neighbor_with_backtracking(current, unvisited, route, fuel_left):\n        if not unvisited:\n            route.append(0)  # Return to start\n            return route if haversine_distance(locations[current], locations[0]) * fuel_consumption <= fuel_left else None\n\n        for next_location in sorted(unvisited, key=lambda x: haversine_distance(locations[current], locations[x])):\n            distance = haversine_distance(locations[current], locations[next_location])\n            fuel_needed = distance * fuel_consumption\n            \n            if fuel_needed <= fuel_left:\n                new_route = route + [next_location]\n                new_unvisited = unvisited - {next_location}\n                result = nearest_neighbor_with_backtracking(next_location, new_unvisited, new_route, fuel_left - fuel_needed)\n                \n                if result:\n                    return result\n\n        return None\n\n    unvisited = set(range(1, len(locations)))\n    optimal_route = nearest_neighbor_with_backtracking(0, unvisited, [0], fuel_capacity)\n    return optimal_route if optimal_route else []\n", "test": "def check(candidate):\n    assert candidate([(0, 0), (10, 10), (20, 20), (30, 30)], 50.0, 0.5) == []\n    assert candidate([(0, 0), (1, 1), (2, 2), (3, 3), (4, 4)], 50.0, 0.2) == []\n    assert candidate([(0, 0), (90, 0), (0, 180), (-90, 0)], 10000.0, 0.1) == [0, 1, 2, 3, 0]\n    assert candidate([(40.7128, -74.0060), (34.0522, -118.2437), (41.8781, -87.6298)], 1000.0, 0.05) == [0, 2, 1, 0]\n    assert candidate([(0, 0), (1, 1)], 50.0, 0.2) == []\n    assert candidate([(0, 0), (1, 1), (2, 2), (3, 3)], 100.0, 0.1) == [0, 1, 2, 3, 0]\n    assert candidate([(0, 0), (0.1, 0.1), (0.2, 0.2), (0.3, 0.3)], 1.0, 0.01) == [0, 1, 2, 3, 0]\n    assert candidate([(45, 0), (45, 90), (45, 180), (45, -90)], 5000.0, 0.05) == [0, 1, 2, 3, 0]\n    assert candidate([(0, 0), (0, 1), (1, 0), (1, 1)], 10.0, 0.1) == []\n    assert candidate([(0, 0)], 100.0, 0.1) == [0, 0]\n", "language": "python"}
{"task_id": "revision1a_problem723", "prompt": "from typing import List, Tuple\n\ndef optimize_wind_farm(grid: List[List[int]], n: int) -> Tuple[int, List[Tuple[int, int]]]:\n    \"\"\"\n    As an environmental engineer, you're tasked with optimizing the placement of wind turbines in a wind farm.\n    The wind farm is represented as a grid where each cell contains an integer representing the wind power at that location.\n\n    Your goal is to place n wind turbines on the grid to maximize the total wind power harnessed. However, due to \n    interference, no two turbines can be placed in adjacent cells (including diagonally adjacent).\n\n    The function takes two parameters:\n    1. A 2D list representing the wind power grid\n    2. An integer n representing the number of turbines to place\n\n    Return a tuple containing:\n    1. The maximum total wind power that can be harnessed\n    2. A list of (row, column) tuples representing the optimal placement of turbines\n\n    If it's not possible to place n turbines following the rules, return (0, []).\n\n    Example:\n    Input: \n    grid = [\n        [1, 3, 5, 2],\n        [4, 2, 6, 1],\n        [2, 1, 3, 4],\n        [5, 3, 2, 1]\n    ]\n    n = 3\n    Output: (16, [(0, 2), (2, 0), (3, 3)])\n\n    Note: This is a complex optimization problem. Consider using dynamic programming or backtracking for an efficient solution.\n    \"\"\"\n", "entry_point": "optimize_wind_farm", "solution": "    rows, cols = len(grid), len(grid[0])\n    max_power = [0]\n    best_placement = []\n\n    def is_valid(row: int, col: int, placement: List[Tuple[int, int]]) -> bool:\n        for r, c in placement:\n            if abs(row - r) <= 1 and abs(col - c) <= 1:\n                return False\n        return True\n\n    def backtrack(row: int, col: int, remaining: int, power: int, placement: List[Tuple[int, int]]):\n        if remaining == 0:\n            if power > max_power[0]:\n                max_power[0] = power\n                best_placement[:] = placement\n            return\n\n        for i in range(row, rows):\n            for j in range(cols):\n                if i == row and j < col:\n                    continue\n                if is_valid(i, j, placement):\n                    placement.append((i, j))\n                    backtrack(i, j + 1, remaining - 1, power + grid[i][j], placement)\n                    placement.pop()\n\n    backtrack(0, 0, n, 0, [])\n\n    if max_power[0] == 0:\n        return (0, [])\n    else:\n        return (max_power[0], best_placement)\n", "test": "def check(candidate):\n    assert candidate([[5, 4, 3], [2, 1, 6], [7, 8, 9]], 3) == (21, [(0, 0), (2, 0), (2, 2)])\n    assert candidate([[1]], 1) == (1, [(0, 0)])\n    assert candidate([[1, 2, 3], [4, 5, 6], [7, 8, 9]], 1) == (9, [(2, 2)])\n    assert candidate([[1, 1, 1], [1, 1, 1], [1, 1, 1]], 5) == (0, [])\n    assert candidate([[1, 2, 3, 4], [5, 6, 7, 8], [9, 10, 11, 12], [13, 14, 15, 16]], 4) == (44, [(1, 1), (1, 3), (3, 1), (3, 3)])\n    assert candidate([[1, 2], [3, 4]], 1) == (4, [(1, 1)])\n    assert candidate([[1, 1, 1], [1, 1, 1], [1, 1, 1]], 2) == (2, [(0, 0), (0, 2)])\n    assert candidate([[0, 0, 0], [0, 0, 0], [0, 0, 0]], 1) == (0, [])\n    assert candidate([[1, 2], [3, 4]], 2) == (0, [])\n    assert candidate([[10, 20, 30], [40, 50, 60], [70, 80, 90]], 2) == (160, [(2, 0), (2, 2)])\n", "language": "python"}
{"task_id": "revision1a_problem224", "prompt": "from typing import List\n\ndef airport_security(passengers: List[int]) -> int:\n    \"\"\"\n    You are managing security checks at an airport. Passengers are in a queue, represented by a list of integers where each integer is the time (in minutes) it takes for that passenger to complete the security check.\n    You have two security lanes. You can perform the following operations:\n    1. If a lane is free, the next passenger in the queue enters that lane.\n    2. When a passenger finishes their security check, they leave the lane and the next passenger in the queue (if any) enters that lane immediately.\n    Your task is to determine the minimum time it takes for all passengers to complete their security checks.\n    Take a list of integers as input from the user, representing the time each passenger needs for their security check, and return the minimum time to process all passengers.\n    \n    Example 1:\n    Input: [5,3,4,2,1]\n    Output: 8\n    \n    Example 2:\n    Input: [10,2,3,3]\n    Output: 10\n    \"\"\"\n", "entry_point": "airport_security", "solution": "    if not passengers:\n        return 0\n\n    lane1 = lane2 = 0\n    \n    for passenger_time in passengers:\n        if lane1 <= lane2:\n            lane1 += passenger_time\n        else:\n            lane2 += passenger_time\n    \n    return max(lane1, lane2)\n", "test": "def check(candidate):\n    assert candidate([7,7,7,7]) == 14\n    assert candidate([10,2,3,3]) == 10\n    assert candidate([5,5,5,5,5,5]) == 15\n    assert candidate([1,1,1,1,1]) == 3\n    assert candidate([50,50]) == 50\n    assert candidate([1,2,3,4,5,6,7,8,9,10]) == 30\n    assert candidate([10,9,8,7,6,5,4,3,2,1]) == 28\n    assert candidate([1,10,1,10,1]) == 12\n    assert candidate([100]) == 100\n    assert candidate([5,3,4,2,1]) == 8\n", "language": "python"}
{"task_id": "revision1a_problem62", "prompt": "import re\nfrom typing import Dict\n\ndef analyze_social_media_post(post: str) -> Dict[str, int]:\n    \"\"\"\n    A social media analyst wants to extract meaningful insights from user posts.\n    Your task is to create a function that analyzes a given social media post and\n    returns various metrics.\n\n    The function should return a dictionary with the following metrics:\n    1. Word count\n    2. Character count (excluding whitespace)\n    3. Hashtag count\n    4. Mention count (@username)\n    5. URL count\n    6. Emoji count\n\n    Use regular expressions to identify hashtags, mentions, and URLs.\n    Implement a simple emoji detection algorithm for common emoji patterns.\n\n    Take a social media post as input and return a dictionary with the analyzed metrics.\n\n    Example:\n\n    Input: \"Just had an amazing time at the beach! \ud83c\udf0a\u2600\ufe0f #summer #vacation @johndoe Check out my pics: https://example.com/photos\"\n    Output: {\n        'word_count': 13,\n        'char_count': 95,\n        'hashtag_count': 2,\n        'mention_count': 1,\n        'url_count': 1,\n        'emoji_count': 2\n    }\n\n    Input: \"Programming is fun! \ud83d\udcbb\ud83e\udd13 #coding #python @codeacademy\"\n    Output: {\n        'word_count': 4,\n        'char_count': 39,\n        'hashtag_count': 2,\n        'mention_count': 1,\n        'url_count': 0,\n        'emoji_count': 2\n    }\n    \"\"\"\n", "entry_point": "analyze_social_media_post", "solution": "    # Initialize the metrics dictionary\n    metrics = {\n        'word_count': 0,\n        'char_count': 0,\n        'hashtag_count': 0,\n        'mention_count': 0,\n        'url_count': 0,\n        'emoji_count': 0\n    }\n\n    # Word count\n    metrics['word_count'] = len(post.split())\n\n    # Character count (excluding whitespace)\n    metrics['char_count'] = len(re.sub(r'\\s', '', post))\n\n    # Hashtag count\n    metrics['hashtag_count'] = len(re.findall(r'#\\w+', post))\n\n    # Mention count\n    metrics['mention_count'] = len(re.findall(r'@\\w+', post))\n\n    # URL count\n    url_pattern = r'http[s]?://(?:[a-zA-Z]|[0-9]|[$-_@.&+]|[!*\\\\(\\\\),]|(?:%[0-9a-fA-F][0-9a-fA-F]))+'\n    metrics['url_count'] = len(re.findall(url_pattern, post))\n\n    # Emoji count (simple detection for common patterns)\n    emoji_pattern = r'[\\U0001F600-\\U0001F64F\\U0001F300-\\U0001F5FF\\U0001F680-\\U0001F6FF\\U0001F1E0-\\U0001F1FF]'\n    metrics['emoji_count'] = len(re.findall(emoji_pattern, post))\n\n    return metrics\n", "test": "def check(candidate):\n    assert candidate(\"https://example1.com https://example2.com https://example3.com\") == {'word_count': 3, 'char_count': 60, 'hashtag_count': 0, 'mention_count': 0, 'url_count': 3, 'emoji_count': 0}\n    assert candidate(\"This is a #test post with @mention and https://example.com\") == {'word_count': 9, 'char_count': 50, 'hashtag_count': 1, 'mention_count': 1, 'url_count': 1, 'emoji_count': 0}\n    assert candidate(\"Just one word\") == {'word_count': 3, 'char_count': 11, 'hashtag_count': 0, 'mention_count': 0, 'url_count': 0, 'emoji_count': 0}\n    assert candidate(\"Hello, world!\") == {'word_count': 2, 'char_count': 12, 'hashtag_count': 0, 'mention_count': 0, 'url_count': 0, 'emoji_count': 0}\n    assert candidate(\"\ud83d\ude42\ud83d\ude0a\ud83d\ude00\ud83d\ude03\ud83d\ude04\ud83d\ude01\") == {'word_count': 1, 'char_count': 6, 'hashtag_count': 0, 'mention_count': 0, 'url_count': 0, 'emoji_count': 6}\n    assert candidate(\"\") == {'word_count': 0, 'char_count': 0, 'hashtag_count': 0, 'mention_count': 0, 'url_count': 0, 'emoji_count': 0}\n    assert candidate(\"@mention @mention @mention\") == {'word_count': 3, 'char_count': 24, 'hashtag_count': 0, 'mention_count': 3, 'url_count': 0, 'emoji_count': 0}\n    assert candidate(\"No special characters here\") == {'word_count': 4, 'char_count': 23, 'hashtag_count': 0, 'mention_count': 0, 'url_count': 0, 'emoji_count': 0}\n    assert candidate(\"This is a very long post with many words but no special characters or emojis it just goes on and on and on to test the word count and character count functionality of the analyze social media post function\") == {'word_count': 39, 'char_count': 167, 'hashtag_count': 0, 'mention_count': 0, 'url_count': 0, 'emoji_count': 0}\n    assert candidate(\"#hashtag #hashtag #hashtag\") == {'word_count': 3, 'char_count': 24, 'hashtag_count': 3, 'mention_count': 0, 'url_count': 0, 'emoji_count': 0}\n", "language": "python"}
{"task_id": "revision1a_problem584", "prompt": "from typing import List, Tuple\nfrom collections import deque\n\ndef maze_solver(maze: List[List[int]], start: Tuple[int, int], end: Tuple[int, int]) -> List[Tuple[int, int]]:\n    \"\"\"\n    You are a robot in a maze trying to find the shortest path from start to end. The maze is represented as a 2D grid\n    where 0 represents an open path and 1 represents a wall. You can move in four directions: up, down, left, and right.\n\n    Write a function that takes the maze, start position, and end position as input and returns the shortest path from\n    start to end. If no path exists, return an empty list.\n\n    Example:\n    Input: \n    maze = [\n        [0, 0, 0, 0],\n        [1, 1, 0, 1],\n        [0, 0, 0, 0],\n        [0, 1, 1, 0]\n    ]\n    start = (0, 0)\n    end = (3, 3)\n\n    Output: [(0, 0), (0, 1), (0, 2), (0, 3), (1, 3), (2, 3), (3, 3)]\n\n    Input:\n    maze = [\n        [0, 1, 0],\n        [0, 1, 0],\n        [0, 1, 0]\n    ]\n    start = (0, 0)\n    end = (0, 2)\n\n    Output: []\n    \"\"\"\n", "entry_point": "maze_solver", "solution": "    def is_valid(x, y):\n        return 0 <= x < len(maze) and 0 <= y < len(maze[0]) and maze[x][y] == 0\n\n    directions = [(0, 1), (1, 0), (0, -1), (-1, 0)]  # right, down, left, up\n    queue = deque([(start, [start])])\n    visited = set([start])\n\n    while queue:\n        (x, y), path = queue.popleft()\n\n        if (x, y) == end:\n            return path\n\n        for dx, dy in directions:\n            nx, ny = x + dx, y + dy\n            if is_valid(nx, ny) and (nx, ny) not in visited:\n                visited.add((nx, ny))\n                new_path = path + [(nx, ny)]\n                queue.append(((nx, ny), new_path))\n\n    return []  # No path found\n", "test": "def check(candidate):\n    assert candidate([[0, 0, 0], [0, 0, 0], [0, 0, 0]], (0, 0), (2, 2)) == [(0, 0), (0, 1), (0, 2), (1, 2), (2, 2)]\n    assert candidate([[0, 0], [0, 0]], (0, 0), (1, 1)) == [(0, 0), (0, 1), (1, 1)]\n    assert candidate([[0, 0, 0], [0, 1, 0], [0, 0, 0]], (0, 0), (2, 2)) == [(0, 0), (0, 1), (0, 2), (1, 2), (2, 2)]\n    assert candidate([[1, 1, 1], [1, 0, 1], [1, 1, 1]], (1, 1), (1, 1)) == [(1, 1)]\n    assert candidate([[0]], (0, 0), (0, 0)) == [(0, 0)]\n    assert candidate([[0, 1], [0, 0]], (0, 0), (1, 1)) == [(0, 0), (1, 0), (1, 1)]\n    assert candidate([[0, 0, 0, 0], [1, 1, 1, 0], [0, 0, 0, 0]], (0, 0), (2, 3)) == [(0, 0), (0, 1), (0, 2), (0, 3), (1, 3), (2, 3)]\n    assert candidate([[0, 1, 0], [0, 1, 0], [0, 0, 0]], (0, 0), (2, 2)) == [(0, 0), (1, 0), (2, 0), (2, 1), (2, 2)]\n    assert candidate([[0, 1, 0], [0, 1, 0], [0, 1, 0]], (0, 0), (2, 0)) == [(0, 0), (1, 0), (2, 0)]\n    assert candidate([[0, 0, 0], [1, 1, 0], [0, 0, 0]], (0, 0), (2, 2)) == [(0, 0), (0, 1), (0, 2), (1, 2), (2, 2)]\n", "language": "python"}
{"task_id": "revision1a_problem419", "prompt": "from typing import List, Tuple\n\ndef optimize_delivery_route(packages: List[Tuple[str, float]], max_weight: float) -> List[List[str]]:\n    \"\"\"\n    A delivery driver needs to optimize their route based on package weights and vehicle capacity.\n    Each package has a destination and weight. The driver's vehicle has a maximum weight capacity.\n    \n    Create an optimal delivery schedule that minimizes the number of trips while respecting the weight limit.\n    Return a list of lists, where each inner list represents a trip and contains the destinations for that trip.\n    \n    Example:\n    Input: packages=[(\"A\", 2.5), (\"B\", 3.0), (\"C\", 1.5), (\"D\", 4.0), (\"E\", 2.0)], max_weight=7.0\n    Output: [[\"A\", \"B\", \"C\"], [\"D\", \"E\"]]\n    \n    Input: packages=[(\"X\", 6.0), (\"Y\", 5.5), (\"Z\", 4.5)], max_weight=10.0\n    Output: [[\"X\"], [\"Y\", \"Z\"]]\n    \"\"\"\n", "entry_point": "optimize_delivery_route", "solution": "    # Sort packages by weight in descending order\n    sorted_packages = sorted(packages, key=lambda x: x[1], reverse=True)\n    \n    delivery_schedule = []\n    current_trip = []\n    current_weight = 0\n    \n    for destination, weight in sorted_packages:\n        if current_weight + weight <= max_weight:\n            current_trip.append(destination)\n            current_weight += weight\n        else:\n            if current_trip:\n                delivery_schedule.append(current_trip)\n            current_trip = [destination]\n            current_weight = weight\n    \n    # Add the last trip if there are remaining packages\n    if current_trip:\n        delivery_schedule.append(current_trip)\n    \n    return delivery_schedule\n", "test": "def check(candidate):\n    assert candidate([(\"X\", 6.0), (\"Y\", 5.5), (\"Z\", 4.5)], 10.0) == [['X'], ['Y', 'Z']]\n    assert candidate([(\"P\", 1.0), (\"Q\", 1.0), (\"R\", 1.0), (\"S\", 1.0), (\"T\", 1.0)], 5.0) == [['P', 'Q', 'R', 'S', 'T']]\n    assert candidate([(\"A\", 0.1), (\"B\", 0.2), (\"C\", 0.3), (\"D\", 0.4)], 1.0) == [['D', 'C', 'B', 'A']]\n    assert candidate([(\"A\", 2.5), (\"B\", 3.0), (\"C\", 1.5), (\"D\", 4.0), (\"E\", 2.0)], 7.0) == [['D', 'B'], ['A', 'E', 'C']]\n    assert candidate([(\"P\", 9.9), (\"Q\", 9.9), (\"R\", 9.9)], 10.0) == [['P'], ['Q'], ['R']]\n    assert candidate([(\"A\", 1.5), (\"B\", 1.5), (\"C\", 1.5), (\"D\", 1.5), (\"E\", 1.5)], 4.5) == [['A', 'B', 'C'], ['D', 'E']]\n    assert candidate([(\"A\", 10.0)], 10.0) == [['A']]\n    assert candidate([(\"X\", 3.3), (\"Y\", 3.3), (\"Z\", 3.3), (\"W\", 3.3)], 10.0) == [['X', 'Y', 'Z'], ['W']]\n    assert candidate([(\"A\", 1.0), (\"B\", 2.0), (\"C\", 3.0), (\"D\", 4.0)], 10.0) == [['D', 'C', 'B', 'A']]\n    assert candidate([(\"X\", 5.0), (\"Y\", 5.0), (\"Z\", 5.0)], 15.0) == [['X', 'Y', 'Z']]\n", "language": "python"}
{"task_id": "revision1a_problem334", "prompt": "import random\nfrom typing import List, Tuple\n\ndef simulate_epidemic(population: int, initial_infected: int, infection_rate: float, recovery_rate: float, days: int) -> List[Tuple[int, int, int]]:\n    \"\"\"\n    As an epidemiologist, I need to simulate the spread of an infectious disease in a population over time.\n    Create a simple SIR (Susceptible, Infected, Recovered) model to simulate the progression of an epidemic.\n\n    Use object-oriented programming to create a Population class with methods for updating the status of individuals\n    each day based on the infection and recovery rates.\n\n    Take input from the user for the population size, initial number of infected individuals, infection rate,\n    recovery rate, and number of days to simulate. Return a list of tuples containing the counts of susceptible,\n    infected, and recovered individuals for each day.\n\n    Example:\n    Input: 10000, 10, 0.3, 0.1, 30\n    Output: [\n        (9990, 10, 0),      # Day 0\n        (9987, 13, 0),      # Day 1\n        (9982, 17, 1),      # Day 2\n        ...\n        (5432, 2345, 2223)  # Day 30\n    ]\n\n    Each tuple represents (susceptible, infected, recovered) counts for a given day.\n    \"\"\"\n", "entry_point": "simulate_epidemic", "solution": "    class Population:\n        def __init__(self, total, initial_infected):\n            self.susceptible = total - initial_infected\n            self.infected = initial_infected\n            self.recovered = 0\n\n        def update(self, infection_rate, recovery_rate):\n            new_infections = min(\n                self.susceptible,\n                int(self.infected * infection_rate * (self.susceptible / (self.susceptible + self.infected + self.recovered)))\n            )\n            new_recoveries = int(self.infected * recovery_rate)\n\n            self.susceptible -= new_infections\n            self.infected += new_infections - new_recoveries\n            self.recovered += new_recoveries\n\n        def get_status(self):\n            return (self.susceptible, self.infected, self.recovered)\n\n    pop = Population(population, initial_infected)\n    results = [pop.get_status()]\n\n    for _ in range(days):\n        pop.update(infection_rate, recovery_rate)\n        results.append(pop.get_status())\n\n    return results\n", "test": "def check(candidate):\n    assert candidate(5000, 20, 0.5, 0.2, 15) == [(4980, 20, 0), (4971, 25, 4), (4959, 32, 9), (4944, 41, 15), (4924, 53, 23), (4898, 69, 33), (4865, 89, 46), (4822, 115, 63), (4767, 147, 86), (4697, 188, 115), (4609, 239, 152), (4499, 302, 199), (4364, 377, 259), (4200, 466, 334), (4005, 568, 427), (3778, 682, 540)]\n    assert candidate(500, 2, 0.35, 0.12, 20) == [(498, 2, 0), (498, 2, 0), (498, 2, 0), (498, 2, 0), (498, 2, 0), (498, 2, 0), (498, 2, 0), (498, 2, 0), (498, 2, 0), (498, 2, 0), (498, 2, 0), (498, 2, 0), (498, 2, 0), (498, 2, 0), (498, 2, 0), (498, 2, 0), (498, 2, 0), (498, 2, 0), (498, 2, 0), (498, 2, 0), (498, 2, 0)]\n    assert candidate(1000000, 1000, 0.15, 0.03, 120) == [(999000, 1000, 0), (998851, 1119, 30), (998684, 1253, 63), (998497, 1403, 100), (998287, 1571, 142), (998052, 1759, 189), (997789, 1970, 241), (997495, 2205, 300), (997166, 2468, 366), (996797, 2763, 440), (996384, 3094, 522), (995922, 3464, 614), (995405, 3878, 717), (994826, 4341, 833), (994179, 4858, 963), (993455, 5437, 1108), (992645, 6084, 1271), (991740, 6807, 1453), (990728, 7615, 1657), (989597, 8518, 1885), (988333, 9527, 2140), (986921, 10654, 2425), (985344, 11912, 2744), (983584, 13315, 3101), (981620, 14880, 3500), (979430, 16624, 3946), (976988, 18568, 4444), (974267, 20732, 5001), (971238, 23140, 5622), (967867, 25817, 6316), (964119, 28791, 7090), (959956, 32091, 7953), (955336, 35749, 8915), (950214, 39799, 9987), (944542, 44278, 11180), (938269, 49223, 12508), (931342, 54674, 13984), (923704, 60672, 15624), (915298, 67258, 17444), (906064, 74475, 19461), (895943, 82362, 21695), (884875, 90960, 24165), (872802, 100305, 26893), (859671, 110427, 29902), (845432, 121354, 33214), (830043, 133103, 36854), (813471, 145682, 40847), (795695, 159088, 45217), (776708, 173303, 49989), (756518, 188294, 55188), (735151, 204013, 60836), (712654, 220390, 66956), (689095, 237338, 73567), (664563, 254750, 80687), (639169, 272502, 88329), (613043, 290453, 96504), (586334, 308449, 105217), (559206, 326324, 114470), (531834, 343907, 124259), (504399, 361025, 134576), (477084, 377510, 145406), (450069, 393200, 156731), (423524, 407949, 168527), (397608, 421627, 180765), (372462, 434125, 193413), (348208, 445356, 206436), (324947, 455257, 219796), (302757, 463790, 233453), (281695, 470939, 247366), (261796, 476710, 261494), (243076, 481129, 275795), (225534, 484238, 290228), (209153, 486092, 304755), (193903, 486760, 319337), (179746, 486315, 333939), (166635, 484837, 348528), (154517, 482410, 363073), (143336, 479119, 377545), (133035, 475047, 391918), (123556, 470275, 406169), (114841, 464882, 420277), (106833, 458944, 434223), (99479, 452530, 447991), (92727, 445707, 461566), (86528, 438535, 474937), (80837, 431070, 488093), (75611, 423364, 501025), (70810, 415465, 513725), (66398, 407414, 526188), (62341, 399249, 538410), (58608, 391005, 550387), (55171, 382712, 562117), (52004, 374398, 573598), (49084, 366087, 584829), (46389, 357800, 595811), (43900, 349555, 606545), (41599, 341370, 617031), (39469, 333259, 627272), (37496, 325235, 637269), (35667, 317307, 647026), (33970, 309485, 656545), (32394, 301777, 665829), (30928, 294190, 674882), (29564, 286729, 683707), (28293, 279399, 692308), (27108, 272203, 700689), (26002, 265143, 708855), (24968, 258223, 716809), (24001, 251444, 724555), (23096, 244806, 732098), (22248, 238310, 739442), (21453, 231956, 746591), (20707, 225744, 753549), (20006, 219673, 760321), (19347, 213742, 766911), (18727, 207950, 773323), (18143, 202296, 779561), (17593, 196778, 785629), (17074, 191394, 791532), (16584, 186143, 797273), (16121, 181022, 802857)]\n    assert candidate(100, 1, 0.6, 0.25, 10) == [(99, 1, 0), (99, 1, 0), (99, 1, 0), (99, 1, 0), (99, 1, 0), (99, 1, 0), (99, 1, 0), (99, 1, 0), (99, 1, 0), (99, 1, 0), (99, 1, 0)]\n    assert candidate(10000, 10, 0.3, 0.1, 30) == [(9990, 10, 0), (9988, 11, 1), (9985, 13, 2), (9982, 15, 3), (9978, 18, 4), (9973, 22, 5), (9967, 26, 7), (9960, 31, 9), (9951, 37, 12), (9940, 45, 15), (9927, 54, 19), (9911, 65, 24), (9892, 78, 30), (9869, 94, 37), (9842, 112, 46), (9809, 134, 57), (9770, 160, 70), (9724, 190, 86), (9669, 226, 105), (9604, 269, 127), (9527, 320, 153), (9436, 379, 185), (9329, 449, 222), (9204, 530, 266), (9058, 623, 319), (8889, 730, 381), (8695, 851, 454), (8474, 987, 539), (8224, 1139, 637), (7943, 1307, 750), (7632, 1488, 880)]\n    assert candidate(50000, 50, 0.25, 0.08, 90) == [(49950, 50, 0), (49938, 58, 4), (49924, 68, 8), (49908, 79, 13), (49889, 92, 19), (49867, 107, 26), (49841, 125, 34), (49810, 146, 44), (49774, 171, 55), (49732, 200, 68), (49683, 233, 84), (49626, 272, 102), (49559, 318, 123), (49481, 371, 148), (49390, 433, 177), (49284, 505, 211), (49160, 589, 251), (49016, 686, 298), (48848, 800, 352), (48653, 931, 416), (48427, 1083, 490), (48165, 1259, 576), (47862, 1462, 676), (47513, 1695, 792), (47111, 1962, 927), (46649, 2268, 1083), (46121, 2615, 1264), (45518, 3009, 1473), (44834, 3453, 1713), (44060, 3951, 1989), (43190, 4505, 2305), (42218, 5117, 2665), (41138, 5788, 3074), (39948, 6515, 3537), (38647, 7295, 4058), (37238, 8121, 4641), (35726, 8984, 5290), (34122, 9870, 6008), (32439, 10764, 6797), (30694, 11648, 7658), (28907, 12504, 8589), (27100, 13311, 9589), (25297, 14050, 10653), (23520, 14703, 11777), (21791, 15256, 12953), (20129, 15698, 14173), (18550, 16022, 15428), (17064, 16227, 16709), (15680, 16313, 18007), (14402, 16286, 19312), (13230, 16156, 20614), (12162, 15932, 21906), (11194, 15626, 23180), (10320, 15250, 24430), (9534, 14816, 25650), (8828, 14337, 26835), (8196, 13823, 27981), (7630, 13284, 29086), (7124, 12728, 30148), (6671, 12163, 31166), (6266, 11595, 32139), (5903, 11031, 33066), (5578, 10474, 33948), (5286, 9929, 34785), (5024, 9397, 35579), (4788, 8882, 36330), (4576, 8384, 37040), (4385, 7905, 37710), (4212, 7446, 38342), (4056, 7007, 38937), (3914, 6589, 39497), (3786, 6190, 40024), (3669, 5812, 40519), (3563, 5454, 40983), (3466, 5115, 41419), (3378, 4794, 41828), (3298, 4491, 42211), (3224, 4206, 42570), (3157, 3937, 42906), (3095, 3685, 43220), (3038, 3448, 43514), (2986, 3225, 43789), (2938, 3015, 44047), (2894, 2818, 44288), (2854, 2633, 44513), (2817, 2460, 44723), (2783, 2298, 44919), (2752, 2146, 45102), (2723, 2004, 45273), (2696, 1871, 45433), (2671, 1747, 45582)]\n    assert candidate(10000, 1, 0.3, 0.1, 50) == [(9999, 1, 0), (9999, 1, 0), (9999, 1, 0), (9999, 1, 0), (9999, 1, 0), (9999, 1, 0), (9999, 1, 0), (9999, 1, 0), (9999, 1, 0), (9999, 1, 0), (9999, 1, 0), (9999, 1, 0), (9999, 1, 0), (9999, 1, 0), (9999, 1, 0), (9999, 1, 0), (9999, 1, 0), (9999, 1, 0), (9999, 1, 0), (9999, 1, 0), (9999, 1, 0), (9999, 1, 0), (9999, 1, 0), (9999, 1, 0), (9999, 1, 0), (9999, 1, 0), (9999, 1, 0), (9999, 1, 0), (9999, 1, 0), (9999, 1, 0), (9999, 1, 0), (9999, 1, 0), (9999, 1, 0), (9999, 1, 0), (9999, 1, 0), (9999, 1, 0), (9999, 1, 0), (9999, 1, 0), (9999, 1, 0), (9999, 1, 0), (9999, 1, 0), (9999, 1, 0), (9999, 1, 0), (9999, 1, 0), (9999, 1, 0), (9999, 1, 0), (9999, 1, 0), (9999, 1, 0), (9999, 1, 0), (9999, 1, 0), (9999, 1, 0)]\n    assert candidate(1000, 5, 0.4, 0.15, 45) == [(995, 5, 0), (994, 6, 0), (992, 8, 0), (989, 10, 1), (986, 12, 2), (982, 15, 3), (977, 18, 5), (970, 23, 7), (962, 28, 10), (952, 34, 14), (940, 41, 19), (925, 50, 25), (907, 61, 32), (885, 74, 41), (859, 89, 52), (829, 106, 65), (794, 126, 80), (754, 148, 98), (710, 170, 120), (662, 193, 145), (611, 216, 173), (559, 236, 205), (507, 253, 240), (456, 267, 277), (408, 275, 317), (364, 278, 358), (324, 277, 399), (289, 271, 440), (258, 262, 480), (231, 250, 519), (208, 236, 556), (189, 220, 591), (173, 203, 624), (159, 187, 654), (148, 170, 682), (138, 155, 707), (130, 140, 730), (123, 126, 751), (117, 114, 769), (112, 102, 786), (108, 91, 801), (105, 81, 814), (102, 72, 826), (100, 64, 836), (98, 57, 845), (96, 51, 853)]\n    assert candidate(100000, 100, 0.2, 0.05, 60) == [(99900, 100, 0), (99881, 114, 5), (99859, 131, 10), (99833, 151, 16), (99803, 174, 23), (99769, 200, 31), (99730, 229, 41), (99685, 263, 52), (99633, 302, 65), (99573, 347, 80), (99504, 399, 97), (99425, 459, 116), (99334, 528, 138), (99230, 606, 164), (99110, 696, 194), (98973, 799, 228), (98815, 918, 267), (98634, 1054, 312), (98427, 1209, 364), (98190, 1386, 424), (97918, 1589, 493), (97607, 1821, 572), (97252, 2085, 663), (96847, 2386, 767), (96385, 2729, 886), (95859, 3119, 1022), (95262, 3561, 1177), (94584, 4061, 1355), (93816, 4626, 1558), (92949, 5262, 1789), (91971, 5977, 2052), (90872, 6778, 2350), (89641, 7671, 2688), (88266, 8663, 3071), (86737, 9759, 3504), (85045, 10964, 3991), (83181, 12280, 4539), (81139, 13708, 5153), (78915, 15247, 5838), (76509, 16891, 6600), (73925, 18631, 7444), (71171, 20454, 8375), (68260, 22343, 9397), (65210, 24276, 10514), (62044, 26229, 11727), (58790, 28172, 13038), (55478, 30076, 14446), (52141, 31910, 15949), (48814, 33642, 17544), (45530, 35244, 19226), (42321, 36691, 20988), (39216, 37962, 22822), (36239, 39041, 24720), (33410, 39918, 26672), (30743, 40590, 28667), (28248, 41056, 30696), (25929, 41323, 32748), (23787, 41399, 34814), (21818, 41299, 36883), (20016, 41037, 38947), (18374, 40628, 40998)]\n    assert candidate(200000, 200, 0.18, 0.06, 75) == [(199800, 200, 0), (199765, 223, 12), (199725, 250, 25), (199681, 279, 40), (199631, 313, 56), (199575, 351, 74), (199512, 393, 95), (199442, 440, 118), (199364, 492, 144), (199276, 551, 173), (199178, 616, 206), (199068, 690, 242), (198945, 772, 283), (198807, 864, 329), (198653, 967, 380), (198481, 1081, 438), (198288, 1210, 502), (198073, 1353, 574), (197832, 1513, 655), (197563, 1692, 745), (197263, 1891, 846), (196928, 2113, 959), (196554, 2361, 1085), (196137, 2637, 1226), (195672, 2944, 1384), (195154, 3286, 1560), (194577, 3666, 1757), (193936, 4088, 1976), (193223, 4556, 2221), (192431, 5075, 2494), (191553, 5649, 2798), (190580, 6284, 3136), (189503, 6984, 3513), (188312, 7756, 3932), (186998, 8605, 4397), (185550, 9537, 4913), (183958, 10557, 5485), (182211, 11671, 6118), (180298, 12884, 6818), (178208, 14201, 7591), (175931, 15626, 8443), (173457, 17163, 9380), (170778, 18813, 10409), (167887, 20576, 11537), (164779, 22450, 12771), (161450, 24432, 14118), (157900, 26517, 15583), (154132, 28694, 17174), (150152, 30953, 18895), (145970, 33278, 20752), (141599, 35653, 22748), (137056, 38057, 24887), (132362, 40468, 27170), (127542, 42860, 29598), (122623, 45208, 32169), (117634, 47485, 34881), (112607, 49663, 37730), (107574, 51717, 40709), (102567, 53621, 43812), (97618, 55353, 47029), (92755, 56895, 50350), (88006, 58231, 53763), (83394, 59350, 57256), (78940, 60243, 60817), (74660, 60909, 64431), (70568, 61347, 68085), (66672, 61563, 71765), (62978, 61564, 75458), (59489, 61360, 79151), (56204, 60964, 82832), (53121, 60390, 86489), (50234, 59654, 90112), (47538, 58771, 93691), (45024, 57759, 97217), (42684, 56634, 100682), (40509, 55411, 104080)]\n", "language": "python"}
{"task_id": "revision1a_problem479", "prompt": "def encrypt_message(message: str, key: int) -> str:\n    \"\"\"\n    You are a secret agent tasked with encrypting sensitive information. Your mission is to create a Caesar cipher encryption function.\n    The function should take a message string and a key (shift value) as input.\n    Each letter in the message should be shifted forward in the alphabet by the number specified by the key.\n    Non-alphabetic characters should remain unchanged.\n    The function should wrap around to the beginning of the alphabet if necessary.\n    Return the encrypted message.\n    Take the message and key as input from the user.\n    Example:\n    Input: \"Hello, World!\", 3\n    Output: \"Khoor, Zruog!\"\n    Input: \"ZeBrA CrOsSiNg\", 1\n    Output: \"AfCsB DsPtTjOh\"\n    \"\"\"\n", "entry_point": "encrypt_message", "solution": "    encrypted_message = \"\"\n    for char in message:\n        if char.isalpha():\n            ascii_offset = ord('A') if char.isupper() else ord('a')\n            shifted_char = chr((ord(char) - ascii_offset + key) % 26 + ascii_offset)\n            encrypted_message += shifted_char\n        else:\n            encrypted_message += char\n    return encrypted_message\n", "test": "def check(candidate):\n    assert candidate(\"123!@#\", 10) == '123!@#'\n    assert candidate(\"ZeBrA CrOsSiNg\", 1) == 'AfCsB DsPtTjOh'\n    assert candidate(\"\", 5) == ''\n    assert candidate(\"ABC\", 26) == 'ABC'\n    assert candidate(\"XYZ\", 3) == 'ABC'\n    assert candidate(\"Hello, World!\", 3) == 'Khoor, Zruog!'\n", "language": "python"}
{"task_id": "revision1a_problem46", "prompt": "from typing import List, Dict\n\ndef social_network_growth(initial_users: int, growth_rates: List[float], months: int) -> Dict[str, List[int]]:\n    \"\"\"\n    You're analyzing the growth of a new social network platform. Given an initial number of users and monthly growth rates,\n    calculate the user base for each month and categorize the growth.\n\n    The function should:\n    1. Calculate the number of users for each month based on the previous month's user count and the growth rate.\n    2. Categorize each month's growth as:\n       - \"Slow\" if growth is less than 5%\n       - \"Moderate\" if growth is between 5% and 10%\n       - \"Fast\" if growth is more than 10%\n\n    Round the number of users to the nearest integer for each month.\n    Return a dictionary with two keys: \"users\" (list of user counts) and \"growth_categories\" (list of growth categories).\n\n    Example:\n    Input: 1000, [0.05, 0.08, 0.12, 0.03, 0.06], 5\n    Output: {\n        \"users\": [1000, 1050, 1134, 1270, 1308, 1386],\n        \"growth_categories\": [\"Moderate\", \"Moderate\", \"Fast\", \"Slow\", \"Moderate\"]\n    }\n\n    Input: 500, [0.1, 0.15, 0.2], 3\n    Output: {\n        \"users\": [500, 550, 633, 759],\n        \"growth_categories\": [\"Fast\", \"Fast\", \"Fast\"]\n    }\n    \"\"\"\n", "entry_point": "social_network_growth", "solution": "    def categorize_growth(growth_rate: float) -> str:\n        if growth_rate < 0.05:\n            return \"Slow\"\n        elif growth_rate <= 0.10:\n            return \"Moderate\"\n        else:\n            return \"Fast\"\n\n    users = [initial_users]\n    growth_categories = []\n\n    for i in range(months):\n        if i < len(growth_rates):\n            growth_rate = growth_rates[i]\n        else:\n            growth_rate = growth_rates[-1]  # Use the last growth rate if not enough rates provided\n\n        new_users = round(users[-1] * (1 + growth_rate))\n        users.append(new_users)\n        growth_categories.append(categorize_growth(growth_rate))\n\n    return {\n        \"users\": users,\n        \"growth_categories\": growth_categories\n    }\n", "test": "def check(candidate):\n    assert candidate(5000, [0.05, 0.05, 0.05, 0.05, 0.05], 5) == {'users': [5000, 5250, 5512, 5788, 6077, 6381], 'growth_categories': ['Moderate', 'Moderate', 'Moderate', 'Moderate', 'Moderate']}\n    assert candidate(1000, [0.05, 0.08, 0.12, 0.03, 0.06], 5) == {'users': [1000, 1050, 1134, 1270, 1308, 1386], 'growth_categories': ['Moderate', 'Moderate', 'Fast', 'Slow', 'Moderate']}\n    assert candidate(10, [0.5, 0.4, 0.3, 0.2, 0.1], 5) == {'users': [10, 15, 21, 27, 32, 35], 'growth_categories': ['Fast', 'Fast', 'Fast', 'Fast', 'Moderate']}\n    assert candidate(1000000, [0.001, 0.002, 0.003], 3) == {'users': [1000000, 1001000, 1003002, 1006011], 'growth_categories': ['Slow', 'Slow', 'Slow']}\n    assert candidate(100, [0.01, 0.02, 0.03, 0.04, 0.05], 5) == {'users': [100, 101, 103, 106, 110, 116], 'growth_categories': ['Slow', 'Slow', 'Slow', 'Slow', 'Moderate']}\n    assert candidate(1, [1.0, 1.0, 1.0, 1.0], 4) == {'users': [1, 2, 4, 8, 16], 'growth_categories': ['Fast', 'Fast', 'Fast', 'Fast']}\n    assert candidate(10000, [0.2, 0.3, 0.4, 0.5], 4) == {'users': [10000, 12000, 15600, 21840, 32760], 'growth_categories': ['Fast', 'Fast', 'Fast', 'Fast']}\n    assert candidate(500, [0.1, 0.15, 0.2], 3) == {'users': [500, 550, 632, 758], 'growth_categories': ['Moderate', 'Fast', 'Fast']}\n    assert candidate(999, [0.001, 0.001, 0.001], 3) == {'users': [999, 1000, 1001, 1002], 'growth_categories': ['Slow', 'Slow', 'Slow']}\n", "language": "python"}
{"task_id": "revision1a_problem4", "prompt": "from collections import deque\nfrom typing import List\n\ndef escape_room(grid: List[List[int]]) -> int:\n    \"\"\"\n    You are trapped in an escape room filled with puzzles. The room is represented as a grid where each cell contains\n    a number indicating the difficulty of the puzzle in that location. You can move up, down, left, or right, but only\n    to cells with a lower or equal difficulty level. Your goal is to reach the exit at the bottom-right corner of the grid.\n\n    Write a function that takes a 2D list representing the grid and returns the minimum number of moves required to\n    reach the exit. If it's impossible to reach the exit, return -1.\n\n    Example 1:\n    Input: [[2,2,1],[1,1,0],[0,1,0]]\n    Output: 4\n\n    Example 2:\n    Input: [[1,1,3],[3,2,2],[1,1,1]]\n    Output: -1\n\n    Note: The top-left corner is always accessible (you start there), and the bottom-right corner is the exit.\n    \"\"\"\n", "entry_point": "escape_room", "solution": "    if not grid or not grid[0]:\n        return -1\n\n    rows, cols = len(grid), len(grid[0])\n    directions = [(0, 1), (1, 0), (0, -1), (-1, 0)]  # right, down, left, up\n    visited = set()\n    queue = deque([(0, 0, 0)])  # (row, col, moves)\n\n    while queue:\n        row, col, moves = queue.popleft()\n\n        if row == rows - 1 and col == cols - 1:\n            return moves\n\n        for dr, dc in directions:\n            new_row, new_col = row + dr, col + dc\n\n            if (0 <= new_row < rows and 0 <= new_col < cols and\n                (new_row, new_col) not in visited and\n                grid[new_row][new_col] <= grid[row][col]):\n                \n                visited.add((new_row, new_col))\n                queue.append((new_row, new_col, moves + 1))\n\n    return -1\n", "test": "def check(candidate):\n    assert candidate([[1,2,3],[4,5,6],[7,8,9]]) == -1\n    assert candidate([[1]]) == 0\n    assert candidate([[2,1],[1,0]]) == 2\n    assert candidate([[0,0],[0,0]]) == 2\n    assert candidate([[5,4,3],[4,3,2],[3,2,1]]) == 4\n    assert candidate([[1,1,1,1],[1,1,1,1],[1,1,1,1],[1,1,1,1]]) == 6\n    assert candidate([[3,2,1],[2,1,0],[1,0,0]]) == 4\n    assert candidate([[1,1],[1,1]]) == 2\n    assert candidate([[9,8,7],[6,5,4],[3,2,1]]) == 4\n    assert candidate([[0,0,0],[1,1,0],[2,2,0]]) == 4\n", "language": "python"}
{"task_id": "revision1a_problem286", "prompt": "def calculate_shipping_cost(weight: float, distance: int) -> float:\n    \"\"\"\n    Calculate the shipping cost based on the weight of the package and the distance to be shipped.\n    If the weight is less than 2 kg, the base cost is $5.\n    If the weight is between 2 kg and 5 kg (inclusive), the base cost is $10.\n    If the weight is more than 5 kg, the base cost is $15.\n\n    For every 100 km of distance:\n    - Add $1 if the weight is less than 2 kg\n    - Add $2 if the weight is between 2 kg and 5 kg (inclusive)\n    - Add $3 if the weight is more than 5 kg\n\n    Take weight (in kg) and distance (in km) as input and return the final shipping cost.\n\n    Example:\n    Input: 1.5, 250\n    Output: 7.5\n    Input: 4.0, 500\n    Output: 20.0\n    \"\"\"\n", "entry_point": "calculate_shipping_cost", "solution": "    # Determine base cost based on weight\n    if weight < 2:\n        base_cost = 5\n        distance_cost_per_100km = 1\n    elif 2 <= weight <= 5:\n        base_cost = 10\n        distance_cost_per_100km = 2\n    else:\n        base_cost = 15\n        distance_cost_per_100km = 3\n\n    # Calculate additional cost based on distance\n    distance_cost = (distance // 100) * distance_cost_per_100km\n\n    # Calculate and return total shipping cost\n    total_cost = base_cost + distance_cost\n    return total_cost\n", "test": "def check(candidate):\n    assert candidate(10.0, 750) == 36\n    assert candidate(1.5, 250) == 7\n    assert candidate(5.0, 1000) == 30\n    assert candidate(0.5, 100) == 6\n    assert candidate(1.99, 99) == 5\n    assert candidate(7.2, 1500) == 60\n    assert candidate(4.0, 500) == 20\n    assert candidate(3.5, 50) == 10\n    assert candidate(2.01, 101) == 12\n    assert candidate(2.0, 300) == 16\n", "language": "python"}
{"task_id": "revision1a_problem375", "prompt": "from collections import Counter\nfrom typing import List, Tuple\n\ndef optimize_delivery_route(addresses: List[str], max_packages: int) -> List[Tuple[str, int]]:\n    \"\"\"\n    A delivery company wants to optimize their routes based on the number of packages they can carry.\n    \n    Write a function that takes a list of delivery addresses and the maximum number of packages\n    the delivery vehicle can carry. The function should return an optimized route as a list of tuples,\n    where each tuple contains an address and the number of packages to be delivered there.\n    \n    The optimization should prioritize delivering more packages to addresses that appear more frequently\n    in the input list, while ensuring the total number of packages doesn't exceed the maximum capacity.\n    \n    Use a dictionary to count address frequencies, then sort and allocate packages accordingly.\n    Implement a greedy algorithm to maximize the number of packages delivered in a single trip.\n    \n    Example:\n    \n    Input: [\"123 Main St\", \"456 Elm St\", \"123 Main St\", \"789 Oak St\", \"456 Elm St\"], 10\n    Output: [(\"123 Main St\", 4), (\"456 Elm St\", 4), (\"789 Oak St\", 2)]\n    \n    Input: [\"A\", \"B\", \"C\", \"A\", \"B\", \"A\", \"D\", \"E\"], 5\n    Output: [(\"A\", 3), (\"B\", 2)]\n    \"\"\"\n", "entry_point": "optimize_delivery_route", "solution": "    # Count the frequency of each address\n    address_counts = Counter(addresses)\n    \n    # Sort addresses by frequency in descending order\n    sorted_addresses = sorted(address_counts.items(), key=lambda x: x[1], reverse=True)\n    \n    optimized_route = []\n    remaining_packages = max_packages\n    \n    # Allocate packages using a greedy approach\n    for address, count in sorted_addresses:\n        if remaining_packages > 0:\n            packages_to_deliver = min(count, remaining_packages)\n            optimized_route.append((address, packages_to_deliver))\n            remaining_packages -= packages_to_deliver\n        else:\n            break\n    \n    return optimized_route\n", "test": "def check(candidate):\n    assert candidate([\"Home\", \"Office\", \"Home\", \"School\", \"Office\", \"Home\"], 6) == [('Home', 3), ('Office', 2), ('School', 1)]\n    assert candidate([], 5) == []\n    assert candidate([\"A\", \"B\", \"C\", \"A\", \"B\", \"A\", \"D\", \"E\"], 5) == [('A', 3), ('B', 2)]\n    assert candidate([\"123 Main St\", \"456 Elm St\", \"123 Main St\", \"789 Oak St\", \"456 Elm St\"], 10) == [('123 Main St', 2), ('456 Elm St', 2), ('789 Oak St', 1)]\n    assert candidate([\"1\", \"2\", \"3\", \"4\", \"5\"], 5) == [('1', 1), ('2', 1), ('3', 1), ('4', 1), ('5', 1)]\n    assert candidate([\"A\", \"B\", \"C\", \"D\", \"E\"], 1) == [('A', 1)]\n    assert candidate([\"A\", \"A\", \"A\", \"A\", \"B\", \"B\", \"C\"], 10) == [('A', 4), ('B', 2), ('C', 1)]\n    assert candidate([\"A\"], 1) == [('A', 1)]\n    assert candidate([\"X\", \"Y\", \"Z\"], 3) == [('X', 1), ('Y', 1), ('Z', 1)]\n    assert candidate([\"X\", \"Y\", \"Z\", \"X\", \"Y\", \"Z\"], 10) == [('X', 2), ('Y', 2), ('Z', 2)]\n", "language": "python"}
{"task_id": "revision1a_problem487", "prompt": "import random\nfrom typing import List, Tuple\n\ndef stock_market_simulator(initial_balance: float, num_days: int) -> Tuple[float, List[float]]:\n    \"\"\"\n    Create a stock market simulator that models the volatility of a fictional stock over a specified number of days.\n    The program should take an initial balance and the number of days to simulate as input.\n    Each day, the stock price should randomly fluctuate between -5% and +5% of its previous value.\n    The simulator should track the daily stock prices and calculate the final balance after the simulation period.\n    \n    Return a tuple containing the final balance and a list of daily stock prices.\n    \n    Example:\n    Input: 10000, 5\n    Output: (10234.56, [100.0, 103.2, 98.7, 101.5, 102.3])\n    \n    This simulation helps users understand the unpredictable nature of stock markets and the importance of long-term investing.\n    \"\"\"\n", "entry_point": "stock_market_simulator", "solution": "    # Initialize variables\n    current_price = 100.0  # Starting price of the stock\n    daily_prices = [current_price]\n    shares = initial_balance / current_price\n\n    # Simulate stock price changes for each day\n    for _ in range(num_days - 1):\n        # Generate a random percentage change between -5% and 5%\n        price_change = random.uniform(-0.05, 0.05)\n        \n        # Update the current price\n        current_price *= (1 + price_change)\n        \n        # Round the price to 2 decimal places for readability\n        current_price = round(current_price, 2)\n        \n        # Add the current price to the list of daily prices\n        daily_prices.append(current_price)\n\n    # Calculate the final balance\n    final_balance = shares * current_price\n\n    # Round the final balance to 2 decimal places\n    final_balance = round(final_balance, 2)\n\n    return (final_balance, daily_prices)\n", "test": "def check(candidate):\n    assert candidate(1, 1) == (1.0, [100.0])\n", "language": "python"}
{"task_id": "revision1a_problem84", "prompt": "def decode_morse(message: str) -> str:\n    \"\"\"\n    You are a radio operator on a ship during World War II. You've intercepted a message in Morse code,\n    but you need to decode it quickly. Write a function that takes a string of Morse code and returns\n    the decoded message in plain English.\n\n    The Morse code dictionary is provided. Each letter is separated by a space, and each word is\n    separated by a forward slash '/'.\n\n    Use dictionary comprehension to create the reverse lookup for decoding.\n    Implement error handling for invalid Morse code characters.\n\n    Example:\n    Input: \".... . .-.. .-.. --- / .-- --- .-. .-.. -..\"\n    Output: \"HELLO WORLD\"\n\n    Input: \"... --- ... / .-- . / .- .-. . / ... .. -. -.- .. -. --.\"\n    Output: \"SOS WE ARE SINKING\"\n\n    Hint: You may want to use the split() method and list comprehension.\n    \"\"\"\n", "entry_point": "decode_morse", "solution": "    morse_code_dict = {\n        'A': '.-', 'B': '-...', 'C': '-.-.', 'D': '-..', 'E': '.', 'F': '..-.',\n        'G': '--.', 'H': '....', 'I': '..', 'J': '.---', 'K': '-.-', 'L': '.-..',\n        'M': '--', 'N': '-.', 'O': '---', 'P': '.--.', 'Q': '--.-', 'R': '.-.',\n        'S': '...', 'T': '-', 'U': '..-', 'V': '...-', 'W': '.--', 'X': '-..-',\n        'Y': '-.--', 'Z': '--..', '0': '-----', '1': '.----', '2': '..---',\n        '3': '...--', '4': '....-', '5': '.....', '6': '-....', '7': '--...',\n        '8': '---..', '9': '----.'\n    }\n\n    # Create reverse lookup dictionary using dictionary comprehension\n    reverse_morse_dict = {v: k for k, v in morse_code_dict.items()}\n\n    try:\n        # Split the message into words\n        words = message.split('/')\n\n        # Decode each word\n        decoded_words = []\n        for word in words:\n            # Split the word into letters\n            letters = word.strip().split()\n            # Decode each letter and join them\n            decoded_word = ''.join([reverse_morse_dict[letter] for letter in letters])\n            decoded_words.append(decoded_word)\n\n        # Join the decoded words with spaces\n        return ' '.join(decoded_words)\n    except KeyError as e:\n        # Handle invalid Morse code characters\n        return f\"Error: Invalid Morse code character encountered - {str(e)}\"\n", "test": "def check(candidate):\n    assert candidate(\".- / -... / -.-. / -.. / . / ..-.\") == 'A B C D E F'\n    assert candidate(\"... --- ... / .-- . / .- .-. . / ... .. -. -.- .. -. --.\") == 'SOS WE ARE SINKING'\n    assert candidate(\"/ / / /\") == '    '\n    assert candidate(\"... --- ...\") == 'SOS'\n    assert candidate(\"-.--.- .-.-.- --..-- ..--.. -.-.-- -..-. -..-.\") == \"Error: Invalid Morse code character encountered - '-.--.-'\"\n    assert candidate(\".-\") == 'A'\n    assert candidate(\"\") == ''\n    assert candidate(\".- -... -.-.\") == 'ABC'\n    assert candidate(\".... . .-.. .-.. --- / .-- --- .-. .-.. -..\") == 'HELLO WORLD'\n    assert candidate(\".- -... -.-. -.. . ..-. --. .... .. .--- -.- .-.. -- -. --- .--. --.- .-. ... - ..- ...- .-- -..- -.-- --..\") == 'ABCDEFGHIJKLMNOPQRSTUVWXYZ'\n", "language": "python"}
{"task_id": "revision1a_problem108", "prompt": "from typing import List\nimport heapq\n\ndef network_latency(connections: List[List[int]], start: int, end: int) -> int:\n    \"\"\"\n    In a computer network, we have various nodes connected by cables with different latencies.\n    Your task is to find the path with the lowest total latency between a start node and an end node.\n    The network is represented as a list of connections, where each connection is [node1, node2, latency].\n    Implement Dijkstra's algorithm to solve this problem.\n    Take input from the user for connections, start node, and end node.\n    Return the lowest total latency if a path exists, or -1 if no path is found.\n\n    Example:\n    Input: [[0,1,5],[0,2,2],[1,2,1],[1,3,3],[2,3,6],[2,4,4],[3,4,2]], 0, 4\n    Output: 8\n    Input: [[0,1,1],[1,2,2],[2,3,3],[3,4,4],[4,5,5]], 0, 5\n    Output: 15\n    Input: [[0,1,1],[1,2,1],[0,3,1],[3,4,1]], 0, 2\n    Output: 2\n    \"\"\"\n", "entry_point": "network_latency", "solution": "    # Create an adjacency list to represent the network\n    graph = {}\n    for node1, node2, latency in connections:\n        if node1 not in graph:\n            graph[node1] = []\n        if node2 not in graph:\n            graph[node2] = []\n        graph[node1].append((node2, latency))\n        graph[node2].append((node1, latency))\n\n    # Initialize distances and priority queue\n    distances = {node: float('inf') for node in graph}\n    distances[start] = 0\n    pq = [(0, start)]\n\n    # Dijkstra's algorithm\n    while pq:\n        current_distance, current_node = heapq.heappop(pq)\n\n        if current_node == end:\n            return current_distance\n\n        if current_distance > distances[current_node]:\n            continue\n\n        for neighbor, latency in graph[current_node]:\n            distance = current_distance + latency\n            if distance < distances[neighbor]:\n                distances[neighbor] = distance\n                heapq.heappush(pq, (distance, neighbor))\n\n    # If end node is not reached, return -1\n    return -1\n", "test": "def check(candidate):\n    assert candidate([[0,1,1],[1,2,1],[2,3,1],[3,4,1],[4,0,1]], 0, 3) == 2\n    assert candidate([[0,1,5],[1,2,5],[2,3,5],[3,4,5],[4,5,5]], 0, 5) == 25\n    assert candidate([[0,1,1]], 0, 1) == 1\n    assert candidate([[0,1,1],[1,2,1],[2,3,1]], 0, 3) == 3\n    assert candidate([[0,1,1],[1,2,1],[2,3,1],[3,4,1],[4,5,1]], 0, 5) == 5\n    assert candidate([[0,1,1],[1,2,2],[2,3,3],[3,4,4],[4,5,5]], 0, 5) == 15\n    assert candidate([[0,1,1],[0,2,2],[0,3,3],[1,4,4],[2,4,5],[3,4,6]], 0, 4) == 5\n    assert candidate([[0,1,5],[0,2,2],[1,2,1],[1,3,3],[2,3,6],[2,4,4],[3,4,2]], 0, 4) == 6\n    assert candidate([[0,1,1],[1,2,1],[0,3,1],[3,4,1]], 0, 2) == 2\n    assert candidate([[0,1,10],[1,2,20],[2,3,30],[3,4,40]], 0, 4) == 100\n", "language": "python"}
{"task_id": "revision1a_problem610", "prompt": "from typing import List\n\ndef optimize_delivery_route(distances: List[List[int]], max_distance: int) -> List[int]:\n    \"\"\"\n    A delivery company wants to optimize their route to maximize the number of deliveries within a given maximum distance.\n    Given a 2D matrix 'distances' where distances[i][j] represents the distance between city i and city j,\n    and a maximum allowed distance 'max_distance', find the longest possible delivery route that doesn't exceed the max_distance.\n    \n    The route should start and end at city 0 (the depot) and visit each city at most once.\n    Use dynamic programming with bitmasks to solve this problem efficiently.\n    \n    Take the 'distances' matrix and 'max_distance' as input from the user and return the list of cities in the optimal route order.\n    \n    Example:\n    Input: [[0,10,15,20],[10,0,35,25],[15,35,0,30],[20,25,30,0]], 80\n    Output: [0, 1, 3, 2, 0]\n    \"\"\"\n", "entry_point": "optimize_delivery_route", "solution": "    n = len(distances)\n    all_cities = (1 << n) - 1\n\n    # Initialize DP table\n    dp = [[float('inf')] * (1 << n) for _ in range(n)]\n    dp[0][1] = 0\n\n    # Helper function to count set bits\n    def count_set_bits(mask):\n        return bin(mask).count('1')\n\n    # Fill DP table\n    for mask in range(1, 1 << n):\n        for i in range(n):\n            if mask & (1 << i):\n                for j in range(n):\n                    if i != j and mask & (1 << j):\n                        prev_mask = mask ^ (1 << i)\n                        if dp[j][prev_mask] + distances[j][i] <= max_distance:\n                            dp[i][mask] = min(dp[i][mask], dp[j][prev_mask] + distances[j][i])\n\n    # Find the optimal route\n    max_cities = 0\n    best_last_city = 0\n    best_mask = 0\n\n    for mask in range(1, 1 << n):\n        if mask & 1:  # Ensure the route includes city 0\n            for last_city in range(1, n):\n                if mask & (1 << last_city):\n                    if dp[last_city][mask] + distances[last_city][0] <= max_distance:\n                        cities_visited = count_set_bits(mask)\n                        if cities_visited > max_cities:\n                            max_cities = cities_visited\n                            best_last_city = last_city\n                            best_mask = mask\n\n    # Reconstruct the route\n    if max_cities == 0:\n        return [0]  # No valid route found\n\n    route = [0] * (max_cities + 1)\n    route[0] = 0\n    route[-1] = 0\n    current_city = best_last_city\n    current_mask = best_mask\n    for i in range(max_cities - 1, 0, -1):\n        route[i] = current_city\n        for j in range(n):\n            if j != current_city and current_mask & (1 << j):\n                prev_mask = current_mask ^ (1 << current_city)\n                if dp[j][prev_mask] + distances[j][current_city] == dp[current_city][current_mask]:\n                    current_city = j\n                    current_mask = prev_mask\n                    break\n\n    return route\n", "test": "def check(candidate):\n    assert candidate([[0,5,10],[5,0,15],[10,15,0]], 30) == [0, 2, 1, 0]\n    assert candidate([[0,100],[100,0]], 99) == [0]\n    assert candidate([[0,100,200],[100,0,300],[200,300,0]], 500) == [0, 1, 0]\n    assert candidate([[0,10,15,20],[10,0,35,25],[15,35,0,30],[20,25,30,0]], 80) == [0, 2, 3, 1, 0]\n    assert candidate([[0]], 10) == [0]\n    assert candidate([[0,5,5,5],[5,0,5,5],[5,5,0,5],[5,5,5,0]], 15) == [0, 2, 1, 0]\n    assert candidate([[0,10,20,30],[10,0,40,50],[20,40,0,60],[30,50,60,0]], 100) == [0, 2, 1, 0]\n    assert candidate([[0,10,20],[10,0,30],[20,30,0]], 40) == [0, 1, 0]\n    assert candidate([[0,1],[1,0]], 2) == [0, 1, 0]\n    assert candidate([[0,1,1,1,1],[1,0,1,1,1],[1,1,0,1,1],[1,1,1,0,1],[1,1,1,1,0]], 5) == [0, 4, 3, 2, 1, 0]\n", "language": "python"}
{"task_id": "revision1a_problem310", "prompt": "def morse_code_translator(text: str, mode: str) -> str:\n    \"\"\"\n    Create a Morse code translator that can convert between English text and Morse code.\n\n    The function should:\n    1. Take a string of text as input\n    2. Take a mode parameter ('encode' or 'decode')\n    3. If mode is 'encode', convert the input text to Morse code\n    4. If mode is 'decode', convert the input Morse code to English text\n    5. Return the translated string\n\n    Use the following Morse code convention:\n    - Letters are separated by a single space\n    - Words are separated by three spaces\n    - Only handle letters A-Z and numbers 0-9\n\n    Example:\n    Input: \"HELLO WORLD\", \"encode\"\n    Output: \".... . .-.. .-.. ---   .-- --- .-. .-.. -..\"\n\n    Input: \".... . .-.. .-.. ---   .-- --- .-. .-.. -..\", \"decode\"\n    Output: \"HELLO WORLD\"\n\n    Raise a ValueError if an invalid character is encountered during encoding\n    or an invalid Morse code sequence is encountered during decoding.\n    \"\"\"\n", "entry_point": "morse_code_translator", "solution": "    morse_code_dict = {\n        'A': '.-', 'B': '-...', 'C': '-.-.', 'D': '-..', 'E': '.', 'F': '..-.',\n        'G': '--.', 'H': '....', 'I': '..', 'J': '.---', 'K': '-.-', 'L': '.-..',\n        'M': '--', 'N': '-.', 'O': '---', 'P': '.--.', 'Q': '--.-', 'R': '.-.',\n        'S': '...', 'T': '-', 'U': '..-', 'V': '...-', 'W': '.--', 'X': '-..-',\n        'Y': '-.--', 'Z': '--..', '0': '-----', '1': '.----', '2': '..---',\n        '3': '...--', '4': '....-', '5': '.....', '6': '-....', '7': '--...',\n        '8': '---..', '9': '----.'\n    }\n    \n    reverse_morse_code_dict = {v: k for k, v in morse_code_dict.items()}\n    \n    def encode(text):\n        encoded = []\n        for word in text.upper().split():\n            encoded_word = []\n            for char in word:\n                if char in morse_code_dict:\n                    encoded_word.append(morse_code_dict[char])\n                else:\n                    raise ValueError(f\"Invalid character '{char}' encountered during encoding.\")\n            encoded.append(' '.join(encoded_word))\n        return '   '.join(encoded)\n    \n    def decode(morse_code):\n        decoded = []\n        for word in morse_code.split('   '):\n            decoded_word = []\n            for char in word.split():\n                if char in reverse_morse_code_dict:\n                    decoded_word.append(reverse_morse_code_dict[char])\n                else:\n                    raise ValueError(f\"Invalid Morse code sequence '{char}' encountered during decoding.\")\n            decoded.append(''.join(decoded_word))\n        return ' '.join(decoded)\n    \n    if mode == 'encode':\n        return encode(text)\n    elif mode == 'decode':\n        return decode(text)\n    else:\n        raise ValueError(\"Invalid mode. Use 'encode' or 'decode'.\")\n", "test": "def check(candidate):\n    assert candidate(\".... . .-.. .-.. ---   .-- --- .-. .-.. -..\", \"decode\") == 'HELLO WORLD'\n    assert candidate(\"A B C 1 2 3\", \"encode\") == '.-   -...   -.-.   .----   ..---   ...--'\n    assert candidate(\".--. -.-- - .... --- -.   ...--\", \"decode\") == 'PYTHON 3'\n    assert candidate(\".- -...   -.-. .---- ..--- ...--\", \"decode\") == 'AB C123'\n    assert candidate(\"PYTHON 3\", \"encode\") == '.--. -.-- - .... --- -.   ...--'\n    assert candidate(\"... --- ...\", \"decode\") == 'SOS'\n    assert candidate(\"\", \"encode\") == ''\n    assert candidate(\"HELLO WORLD\", \"encode\") == '.... . .-.. .-.. ---   .-- --- .-. .-.. -..'\n    assert candidate(\"SOS\", \"encode\") == '... --- ...'\n    assert candidate(\"\", \"decode\") == ''\n", "language": "python"}
{"task_id": "revision1a_problem495", "prompt": "from typing import List, Tuple\nimport heapq\n\ndef optimal_delivery_route(n: int, roads: List[Tuple[int, int, int]], start: int, end: int) -> List[int]:\n    \"\"\"\n    A delivery company wants to optimize its routes in a city with n intersections.\n    The roads between intersections are represented as a list of tuples (from, to, time),\n    where 'from' and 'to' are intersection IDs (0 to n-1), and 'time' is the minutes it takes to travel that road.\n    \n    Your task is to find the fastest route from the start intersection to the end intersection,\n    considering that some roads might be one-way. If there's no possible route, return an empty list.\n    \n    Use Dijkstra's algorithm to solve this problem efficiently.\n    \n    Args:\n    n (int): Number of intersections in the city\n    roads (List[Tuple[int, int, int]]): List of roads, each represented as (from, to, time)\n    start (int): Starting intersection ID\n    end (int): Destination intersection ID\n    \n    Returns:\n    List[int]: The list of intersection IDs representing the fastest route, or an empty list if no route exists\n    \n    Example:\n    Input: n=5, roads=[(0,1,5), (0,2,2), (1,3,1), (2,1,1), (2,3,5), (2,4,2), (3,4,1)], start=0, end=4\n    Output: [0, 2, 4]\n    \"\"\"\n", "entry_point": "optimal_delivery_route", "solution": "    # Create an adjacency list to represent the graph\n    graph = [[] for _ in range(n)]\n    for from_node, to_node, time in roads:\n        graph[from_node].append((to_node, time))\n    \n    # Initialize distances and previous nodes\n    distances = [float('inf')] * n\n    distances[start] = 0\n    previous = [None] * n\n    \n    # Priority queue to store nodes to visit\n    pq = [(0, start)]\n    \n    while pq:\n        current_dist, current_node = heapq.heappop(pq)\n        \n        # If we've reached the end node, we can stop\n        if current_node == end:\n            break\n        \n        # If we've already found a shorter path to the current node, skip it\n        if current_dist > distances[current_node]:\n            continue\n        \n        # Check all neighbors of the current node\n        for neighbor, time in graph[current_node]:\n            distance = current_dist + time\n            \n            # If we've found a shorter path to the neighbor, update it\n            if distance < distances[neighbor]:\n                distances[neighbor] = distance\n                previous[neighbor] = current_node\n                heapq.heappush(pq, (distance, neighbor))\n    \n    # Reconstruct the path\n    if distances[end] == float('inf'):\n        return []  # No path exists\n    \n    path = []\n    current = end\n    while current is not None:\n        path.append(current)\n        current = previous[current]\n    \n    return path[::-1]  # Reverse the path to get start to end order\n", "test": "def check(candidate):\n    assert candidate(3, [(0,1,1), (1,2,1)], 0, 2) == [0, 1, 2]\n    assert candidate(3, [(0,1,1), (1,2,1)], 2, 0) == []\n    assert candidate(5, [(0,1,1), (1,2,1), (2,3,1), (3,4,1)], 0, 4) == [0, 1, 2, 3, 4]\n    assert candidate(5, [(0,1,5), (0,2,2), (1,3,1), (2,1,1), (2,3,5), (2,4,2), (3,4,1)], 0, 4) == [0, 2, 4]\n    assert candidate(6, [(0,1,1), (1,2,1), (2,3,1), (3,4,1), (4,5,1)], 0, 5) == [0, 1, 2, 3, 4, 5]\n    assert candidate(3, [(0,1,5), (1,2,5), (0,2,9)], 0, 2) == [0, 2]\n    assert candidate(5, [(0,1,10), (1,2,10), (2,3,10), (3,4,10), (0,4,39)], 0, 4) == [0, 4]\n    assert candidate(4, [(0,1,1), (1,2,1), (2,3,1), (0,3,2)], 0, 3) == [0, 3]\n    assert candidate(2, [(0,1,10)], 0, 1) == [0, 1]\n    assert candidate(4, [(0,1,1), (1,2,1), (2,3,1), (3,0,1)], 0, 3) == [0, 1, 2, 3]\n", "language": "python"}
{"task_id": "revision1a_problem407", "prompt": "from typing import List, Tuple\n\ndef optimal_study_schedule(courses: List[Tuple[str, int, int]]) -> List[str]:\n    \"\"\"\n    As a university student, you're trying to create an optimal study schedule for your upcoming exams. \n    You have a list of courses, each represented by a tuple containing the course name, its difficulty level (1-10), \n    and the number of days until the exam. You want to prioritize studying based on a score calculated as: \n    (difficulty * 10) / days_until_exam.\n\n    Your task is to sort the courses based on this score in descending order, so you can focus on the most critical subjects first.\n\n    Input: A list of tuples, where each tuple contains (course_name: str, difficulty: int, days_until_exam: int)\n    Output: A list of course names sorted by their calculated priority score in descending order\n\n    Use lambda functions and sorting to solve this problem efficiently.\n\n    Example:\n    Input: [(\"Math\", 8, 5), (\"History\", 6, 3), (\"Physics\", 9, 2), (\"Literature\", 5, 7)]\n    Output: ['Physics', 'History', 'Math', 'Literature']\n\n    Input: [(\"Chemistry\", 7, 4), (\"Biology\", 6, 6), (\"Computer Science\", 8, 3), (\"Economics\", 5, 5)]\n    Output: ['Computer Science', 'Chemistry', 'Economics', 'Biology']\n    \"\"\"\n", "entry_point": "optimal_study_schedule", "solution": "    # Sort the courses based on the calculated priority score in descending order\n    sorted_courses = sorted(courses, key=lambda x: (x[1] * 10) / x[2], reverse=True)\n    \n    # Extract and return only the course names from the sorted list\n    return [course[0] for course in sorted_courses]\n", "test": "def check(candidate):\n    assert candidate([(\"Math\", 8, 5), (\"History\", 6, 3), (\"Physics\", 9, 2), (\"Literature\", 5, 7)]) == ['Physics', 'History', 'Math', 'Literature']\n    assert candidate([(\"Psychology\", 6, 7), (\"Sociology\", 5, 8), (\"Anthropology\", 7, 6), (\"Philosophy\", 8, 5)]) == ['Philosophy', 'Anthropology', 'Psychology', 'Sociology']\n    assert candidate([(\"English\", 5, 5), (\"French\", 6, 4), (\"Spanish\", 7, 3), (\"German\", 8, 2), (\"Italian\", 9, 1)]) == ['Italian', 'German', 'Spanish', 'French', 'English']\n    assert candidate([(\"Programming\", 7, 5), (\"Algorithms\", 8, 4), (\"Data Structures\", 9, 3), (\"Databases\", 6, 6)]) == ['Data Structures', 'Algorithms', 'Programming', 'Databases']\n    assert candidate([(\"Astronomy\", 8, 3), (\"Astrophysics\", 9, 2), (\"Cosmology\", 10, 1)]) == ['Cosmology', 'Astrophysics', 'Astronomy']\n    assert candidate([(\"Art\", 3, 10), (\"Music\", 4, 8), (\"Dance\", 5, 6), (\"Drama\", 6, 4)]) == ['Drama', 'Dance', 'Music', 'Art']\n    assert candidate([(\"Medicine\", 10, 1), (\"Surgery\", 9, 2), (\"Pharmacology\", 8, 3), (\"Anatomy\", 7, 4), (\"Physiology\", 6, 5)]) == ['Medicine', 'Surgery', 'Pharmacology', 'Anatomy', 'Physiology']\n    assert candidate([(\"Chemistry\", 7, 4), (\"Biology\", 6, 6), (\"Computer Science\", 8, 3), (\"Economics\", 5, 5)]) == ['Computer Science', 'Chemistry', 'Biology', 'Economics']\n    assert candidate([(\"Geology\", 5, 9), (\"Geography\", 4, 10), (\"Meteorology\", 6, 8), (\"Oceanography\", 7, 7)]) == ['Oceanography', 'Meteorology', 'Geology', 'Geography']\n    assert candidate([(\"Calculus\", 10, 1), (\"Statistics\", 9, 2), (\"Linear Algebra\", 8, 3), (\"Discrete Math\", 7, 4)]) == ['Calculus', 'Statistics', 'Linear Algebra', 'Discrete Math']\n", "language": "python"}
{"task_id": "revision1a_problem12", "prompt": "from typing import List, Tuple\n\ndef calculate_investment_returns(initial_investments: List[float], interest_rates: List[float], years: int) -> List[Tuple[float, float]]:\n    \"\"\"\n    A financial advisor wants to calculate the returns on multiple investments for their clients.\n    They need a function that takes a list of initial investments, a list of corresponding annual interest rates,\n    and the number of years to calculate for. The function should return a list of tuples, where each tuple\n    contains the final amount and the total interest earned for each investment.\n\n    Use list comprehension to calculate the results.\n    Round all monetary values to two decimal places.\n\n    Example:\n    Input: [1000, 5000, 10000], [0.05, 0.07, 0.06], 10\n    Output: [(1628.89, 628.89), (9836.13, 4836.13), (17908.48, 7908.48)]\n\n    Input: [2000, 3000], [0.04, 0.06], 5\n    Output: [(2433.26, 433.26), (4019.78, 1019.78)]\n    \"\"\"\n", "entry_point": "calculate_investment_returns", "solution": "    return [\n        (\n            round(initial * (1 + rate) ** years, 2),\n            round(initial * (1 + rate) ** years - initial, 2)\n        )\n        for initial, rate in zip(initial_investments, interest_rates)\n    ]\n", "test": "def check(candidate):\n    assert candidate([1, 10, 100, 1000], [0.01, 0.05, 0.1, 0.15], 30) == [(1.35, 0.35), (43.22, 33.22), (1744.94, 1644.94), (66211.77, 65211.77)]\n    assert candidate([100, 200, 300, 400, 500], [0.02, 0.03, 0.04, 0.05, 0.06], 7) == [(114.87, 14.87), (245.97, 45.97), (394.78, 94.78), (562.84, 162.84), (751.82, 251.82)]\n    assert candidate([10000], [0.08], 20) == [(46609.57, 36609.57)]\n    assert candidate([1000, 2000], [0.05, 0.05], 0) == [(1000.0, 0.0), (2000.0, 0.0)]\n    assert candidate([50000, 75000], [0.09, 0.095], 25) == [(431154.03, 381154.03), (725127.28, 650127.28)]\n    assert candidate([1000, 5000, 10000], [0.05, 0.07, 0.06], 10) == [(1628.89, 628.89), (9835.76, 4835.76), (17908.48, 7908.48)]\n    assert candidate([2000, 3000], [0.04, 0.06], 5) == [(2433.31, 433.31), (4014.68, 1014.68)]\n    assert candidate([5000], [0], 5) == [(5000, 0)]\n    assert candidate([500, 1500, 2500], [0.03, 0.05, 0.07], 15) == [(778.98, 278.98), (3118.39, 1618.39), (6897.58, 4397.58)]\n    assert candidate([1000000], [0.01], 1) == [(1010000.0, 10000.0)]\n", "language": "python"}
{"task_id": "revision1a_problem437", "prompt": "from typing import List\n\ndef encryption_key(message: str, key: List[int]) -> str:\n    \"\"\"\n    A secret agent needs to encrypt a message using a special key-based algorithm.\n    The encryption works by shifting each character in the message by the corresponding value in the key.\n    If the key is shorter than the message, it repeats cyclically.\n    The shift wraps around the alphabet (26 letters) and preserves case. Non-alphabetic characters remain unchanged.\n    \n    Write a function that takes the original message and the key as inputs, and returns the encrypted message.\n    \n    Example:\n    Input: \"Hello, World!\", [3, 1, 4]\n    Output: \"Khpos, Zruog!\"\n    \n    Input: \"Secret Mission\", [2, 0, 1, 5]\n    Output: \"Ufahgv Nkuwjqp\"\n    \n    Note: This encryption method is a variation of the Vigen\u00e8re cipher.\n    \"\"\"\n", "entry_point": "encryption_key", "solution": "    def shift_char(char: str, shift: int) -> str:\n        if not char.isalpha():\n            return char\n        \n        ascii_offset = ord('A') if char.isupper() else ord('a')\n        shifted = (ord(char) - ascii_offset + shift) % 26\n        return chr(shifted + ascii_offset)\n\n    encrypted = []\n    key_length = len(key)\n    \n    for i, char in enumerate(message):\n        shift = key[i % key_length]\n        encrypted.append(shift_char(char, shift))\n    \n    return ''.join(encrypted)\n", "test": "def check(candidate):\n    assert candidate(\"Secret Mission\", [2, 0, 1, 5]) == 'Uedwgt Rkstnqn'\n    assert candidate(\"Repeated Key\", [1, 1, 1, 1]) == 'Sfqfbufe Lfz'\n    assert candidate(\"Single\", [100]) == 'Oejcha'\n    assert candidate(\"Hello, World!\", [3, 1, 4]) == 'Kfpop, Xsumh!'\n    assert candidate(\"\", [1, 2, 3]) == ''\n    assert candidate(\"ABCDEFGHIJKLMNOPQRSTUVWXYZ\", [1]) == 'BCDEFGHIJKLMNOPQRSTUVWXYZA'\n    assert candidate(\"abcdefghijklmnopqrstuvwxyz\", [26]) == 'abcdefghijklmnopqrstuvwxyz'\n    assert candidate(\"Mixed Case TEXT\", [0]) == 'Mixed Case TEXT'\n    assert candidate(\"The quick brown fox jumps over the lazy dog.\", [5, 10, 15, 20]) == 'Yrt vexwp qltgc kym oebjx dpjb nmo ffjn iyv.'\n    assert candidate(\"1234567890!@#$%^&*()\", [1, 2, 3, 4, 5]) == '1234567890!@#$%^&*()'\n", "language": "python"}
