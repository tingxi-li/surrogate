{"task_id": "revision1a_problem629", "prompt": "from typing import List\n\ndef calculate_water_trapped(heights: List[int]) -> int:\n    \"\"\"\n    In a city with varying building heights, we want to calculate how much rainwater can be trapped between the buildings.\n    Each building is represented by its height, and the width of each building is considered to be 1 unit.\n    We need to determine the total amount of water that can be trapped after it rains.\n\n    Take input from the user for the heights of the buildings in the form of a list.\n    Return the total amount of water that can be trapped.\n\n    Example:\n    Input: [0, 1, 0, 2, 1, 0, 1, 3, 2, 1, 2, 1]\n    Output: 6\n\n    Input: [4, 2, 0, 3, 2, 5]\n    Output: 9\n    \"\"\"\n", "entry_point": "calculate_water_trapped", "solution": "    if not heights:\n        return 0\n\n    n = len(heights)\n    left_max = [0] * n\n    right_max = [0] * n\n    \n    # Calculate the maximum height to the left of each building\n    left_max[0] = heights[0]\n    for i in range(1, n):\n        left_max[i] = max(left_max[i-1], heights[i])\n    \n    # Calculate the maximum height to the right of each building\n    right_max[n-1] = heights[n-1]\n    for i in range(n-2, -1, -1):\n        right_max[i] = max(right_max[i+1], heights[i])\n    \n    # Calculate the amount of water trapped at each position\n    water_trapped = 0\n    for i in range(n):\n        water_level = min(left_max[i], right_max[i])\n        if water_level > heights[i]:\n            water_trapped += water_level - heights[i]\n    \n    return water_trapped\n", "test": "def check(candidate):\n    assert candidate([3, 0, 0, 3]) == 6\n    assert candidate([4, 2, 0, 3, 2, 5]) == 9\n    assert candidate([1]) == 0\n    assert candidate([0, 1, 0, 2, 1, 0, 1, 3, 2, 1, 2, 1]) == 6\n    assert candidate([1, 1, 1, 1]) == 0\n    assert candidate([]) == 0\n    assert candidate([3, 0, 3]) == 3\n    assert candidate([1, 2, 3, 4, 5]) == 0\n    assert candidate([5, 4, 3, 2, 1]) == 0\n    assert candidate([5, 0, 5]) == 5\n", "language": "python"}
{"task_id": "revision1a_problem660", "prompt": "from typing import List\nimport itertools\n\ndef optimize_delivery_route(locations: List[List[int]], fuel_capacity: int) -> List[int]:\n    \"\"\"\n    As a delivery truck driver, I need to find the optimal route to deliver packages to multiple locations.\n    Given a list of location coordinates (x, y) and the fuel capacity of the truck, determine the best order to visit all locations\n    while minimizing the total distance traveled. The truck starts and ends at the origin (0, 0).\n    Assume that 1 unit of fuel is consumed per 1 unit of distance traveled.\n    If it's impossible to visit all locations with the given fuel capacity, return an empty list.\n    Take input from the user for the list of locations and fuel capacity, and return the optimal order of locations to visit.\n    Use dynamic programming to solve this problem efficiently.\n    Example:\n    Input: [[1, 2], [-3, 5], [4, -1], [2, 3]], 30\n    Output: [0, 3, 1, 2, 0]\n    Input: [[5, 5], [-5, -5], [10, 10]], 40\n    Output: []\n    \"\"\"\n", "entry_point": "optimize_delivery_route", "solution": "    def distance(a, b):\n        return abs(a[0] - b[0]) + abs(a[1] - b[1])\n\n    n = len(locations)\n    all_locations = [(0, 0)] + locations\n    \n    # Create a distance matrix\n    dist = [[distance(all_locations[i], all_locations[j]) for j in range(n+1)] for i in range(n+1)]\n    \n    # Initialize DP table\n    dp = {}\n    \n    def tsp(mask, pos):\n        if mask == (1 << (n + 1)) - 1:\n            return dist[pos][0] if dist[pos][0] <= fuel_capacity else float('inf')\n        \n        if (mask, pos) in dp:\n            return dp[(mask, pos)]\n        \n        ans = float('inf')\n        for nxt in range(n + 1):\n            if mask & (1 << nxt) == 0:\n                if dist[pos][nxt] <= fuel_capacity:\n                    ans = min(ans, dist[pos][nxt] + tsp(mask | (1 << nxt), nxt))\n        \n        dp[(mask, pos)] = ans\n        return ans\n    \n    total_distance = tsp(1, 0)\n    \n    if total_distance > fuel_capacity:\n        return []\n    \n    # Reconstruct the path\n    path = [0]\n    mask = 1\n    pos = 0\n    \n    for _ in range(n):\n        best_nxt = None\n        for nxt in range(1, n + 1):\n            if mask & (1 << nxt) == 0:\n                if best_nxt is None or dp[(mask | (1 << nxt), nxt)] < dp[(mask | (1 << best_nxt), best_nxt)]:\n                    best_nxt = nxt\n        \n        path.append(best_nxt)\n        mask |= 1 << best_nxt\n        pos = best_nxt\n    \n    path.append(0)\n    return [i - 1 for i in path[1:-1]]\n\n# Example usage:\n# locations = eval(input(\"Enter the list of locations (e.g., [[1, 2], [-3, 5], [4, -1], [2, 3]]): \"))\n# fuel_capacity = int(input(\"Enter the fuel capacity: \"))\n# result = optimize_delivery_route(locations, fuel_capacity)\n# print(\"Optimal route:\", result)\n", "test": "def check(candidate):\n    assert candidate([], 100) == []\n    assert candidate([[1, 1], [2, 2], [3, 3]], 20) == [2, 1, 0]\n    assert candidate([[1, 2], [-3, 5], [4, -1], [2, 3]], 30) == [1, 2, 3, 0]\n    assert candidate([[1, 0], [0, 1], [-1, 0], [0, -1]], 8) == [0, 1, 2, 3]\n    assert candidate([[-1, -1], [-2, -2], [-3, -3]], 20) == [2, 1, 0]\n    assert candidate([[0, 0]], 10) == [0]\n    assert candidate([[3, 4], [5, 12], [8, 15]], 100) == [2, 1, 0]\n    assert candidate([[1000, 1000]], 2001) == []\n    assert candidate([[1, 1], [1, 2], [1, 3], [1, 4], [1, 5]], 15) == [4, 3, 2, 1, 0]\n    assert candidate([[5, 5], [-5, -5], [10, 10]], 40) == []\n", "language": "python"}
{"task_id": "revision1a_problem7", "prompt": "from typing import List, Dict, Tuple, Union\nfrom collections import defaultdict\n\ndef analyze_social_network(n: int, connections: List[Tuple[int, int]], k: int) -> Dict[str, Union[List[int], int]]:\n    \"\"\"\n    You're a data scientist working for a social media company. Your task is to analyze the company's social network\n    to identify influential users and community structures.\n\n    Given:\n    - n: the number of users in the network (numbered from 0 to n-1)\n    - connections: a list of tuples (u, v) representing friendships between users u and v\n    - k: a parameter for identifying top influencers\n\n    Your analysis should return a dictionary with the following information:\n    1. 'top_influencers': a list of the k users with the most connections\n    2. 'avg_friends': the average number of friends per user\n    3. 'largest_clique': the size of the largest fully connected group of users\n    4. 'communities': the number of disconnected communities in the network\n\n    This problem involves graph theory, data structures, and algorithm design concepts.\n\n    Example:\n    Input: 6, [(0,1), (0,2), (1,2), (1,3), (2,4), (3,4), (3,5)], 2\n    Output: {\n        'top_influencers': [1, 3],\n        'avg_friends': 2.33,\n        'largest_clique': 3,\n        'communities': 1\n    }\n\n    Input: 8, [(0,1), (2,3), (4,5), (6,7)], 3\n    Output: {\n        'top_influencers': [0, 1, 2],\n        'avg_friends': 1.0,\n        'largest_clique': 2,\n        'communities': 4\n    }\n    \"\"\"\n", "entry_point": "analyze_social_network", "solution": "    # Create an adjacency list to represent the graph\n    graph = defaultdict(set)\n    for u, v in connections:\n        graph[u].add(v)\n        graph[v].add(u)\n\n    # 1. Find top influencers\n    degree = {user: len(friends) for user, friends in graph.items()}\n    top_influencers = sorted(degree, key=degree.get, reverse=True)[:k]\n\n    # 2. Calculate average number of friends\n    total_friends = sum(degree.values())\n    avg_friends = round(total_friends / n, 2)\n\n    # 3. Find the largest clique size\n    def bron_kerbosch(R, P, X):\n        if not P and not X:\n            return len(R)\n        max_clique = 0\n        for v in list(P):\n            max_clique = max(max_clique, bron_kerbosch(R | {v}, P & graph[v], X & graph[v]))\n            P.remove(v)\n            X.add(v)\n        return max_clique\n\n    largest_clique = bron_kerbosch(set(), set(range(n)), set())\n\n    # 4. Count disconnected communities\n    def dfs(node, visited):\n        visited.add(node)\n        for neighbor in graph[node]:\n            if neighbor not in visited:\n                dfs(neighbor, visited)\n\n    visited = set()\n    communities = 0\n    for node in range(n):\n        if node not in visited:\n            dfs(node, visited)\n            communities += 1\n\n    return {\n        'top_influencers': top_influencers,\n        'avg_friends': avg_friends,\n        'largest_clique': largest_clique,\n        'communities': communities\n    }\n", "test": "def check(candidate):\n    assert candidate(7, [(0,1), (1,2), (2,3), (3,4), (4,5), (5,6), (6,0)], 2) == {'top_influencers': [0, 1], 'avg_friends': 2.0, 'largest_clique': 2, 'communities': 1}\n    assert candidate(6, [(0,1), (0,2), (1,2), (1,3), (2,4), (3,4), (3,5)], 2) == {'top_influencers': [1, 2], 'avg_friends': 2.33, 'largest_clique': 3, 'communities': 1}\n    assert candidate(8, [(0,1), (2,3), (4,5), (6,7)], 3) == {'top_influencers': [0, 1, 2], 'avg_friends': 1.0, 'largest_clique': 2, 'communities': 4}\n    assert candidate(6, [], 3) == {'top_influencers': [], 'avg_friends': 0.0, 'largest_clique': 1, 'communities': 6}\n    assert candidate(10, [(i,i+1) for i in range(9)], 5) == {'top_influencers': [1, 2, 3, 4, 5], 'avg_friends': 1.8, 'largest_clique': 2, 'communities': 1}\n    assert candidate(2, [(0,1)], 1) == {'top_influencers': [0], 'avg_friends': 1.0, 'largest_clique': 2, 'communities': 1}\n    assert candidate(1, [], 1) == {'top_influencers': [], 'avg_friends': 0.0, 'largest_clique': 1, 'communities': 1}\n    assert candidate(5, [(0,1), (1,2), (2,3), (3,4), (4,0)], 1) == {'top_influencers': [0], 'avg_friends': 2.0, 'largest_clique': 2, 'communities': 1}\n    assert candidate(4, [(0,1), (1,2), (2,3), (3,0), (0,2), (1,3)], 4) == {'top_influencers': [0, 1, 2, 3], 'avg_friends': 3.0, 'largest_clique': 4, 'communities': 1}\n", "language": "python"}
{"task_id": "revision1a_problem331", "prompt": "import itertools\nfrom typing import List, Tuple\n\ndef optimize_delivery_route(num_locations: int, distances: List[List[int]], time_windows: List[Tuple[int, int]]) -> List[int]:\n    \"\"\"\n    A delivery company wants to optimize its route for a fleet of drones. Each drone needs to visit multiple locations in a city, considering the distances between locations and specific time windows for each delivery.\n\n    Given the number of locations, a 2D matrix of distances between locations, and a list of time windows for each location, determine the optimal route that minimizes total distance traveled while meeting all time window constraints.\n\n    The function should return the optimal order of locations to visit.\n\n    Example:\n    Input: 4, [[0,10,15,20],[10,0,35,25],[15,35,0,30],[20,25,30,0]], [(0,50),(10,60),(0,70),(30,80)]\n    Output: [0, 1, 3, 2]\n\n    This output means the optimal route is to visit location 0, then 1, then 3, and finally 2.\n    \"\"\"\n", "entry_point": "optimize_delivery_route", "solution": "    \n    def is_valid_time(current_time, next_location):\n        start, end = time_windows[next_location]\n        return start <= current_time <= end\n\n    def tsp_dp(mask, pos, current_time):\n        if mask == (1 << num_locations) - 1:\n            return 0 if is_valid_time(current_time, 0) else float('inf')\n\n        if (mask, pos, current_time) in memo:\n            return memo[(mask, pos, current_time)]\n\n        min_cost = float('inf')\n        for next_loc in range(num_locations):\n            if mask & (1 << next_loc) == 0:\n                new_time = current_time + distances[pos][next_loc]\n                if is_valid_time(new_time, next_loc):\n                    cost = distances[pos][next_loc] + tsp_dp(mask | (1 << next_loc), next_loc, new_time)\n                    min_cost = min(min_cost, cost)\n\n        memo[(mask, pos, current_time)] = min_cost\n        return min_cost\n\n    memo = {}\n    min_distance = tsp_dp(1, 0, 0)\n\n    if min_distance == float('inf'):\n        return []  # No valid route found\n\n    # Reconstruct the path\n    path = [0]\n    mask = 1\n    pos = 0\n    current_time = 0\n\n    for _ in range(1, num_locations):\n        next_loc = min(\n            [i for i in range(num_locations) if mask & (1 << i) == 0],\n            key=lambda x: distances[pos][x] + tsp_dp(mask | (1 << x), x, current_time + distances[pos][x])\n        )\n        path.append(next_loc)\n        mask |= 1 << next_loc\n        current_time += distances[pos][next_loc]\n        pos = next_loc\n\n    return path\n", "test": "def check(candidate):\n    assert candidate(4, [[0,5,10,15],[5,0,20,25],[10,20,0,30],[15,25,30,0]], [(0,40),(10,50),(20,60),(30,70)]) == []\n    assert candidate(5, [[0,10,20,30,40],[10,0,15,25,35],[20,15,0,10,20],[30,25,10,0,15],[40,35,20,15,0]], [(0,60),(10,70),(20,80),(30,90),(40,100)]) == [0, 1, 2, 3, 4]\n    assert candidate(4, [[0,100,200,300],[100,0,400,500],[200,400,0,600],[300,500,600,0]], [(0,1000),(0,1000),(0,1000),(0,1000)]) == []\n    assert candidate(2, [[0,5],[5,0]], [(0,20),(10,30)]) == []\n    assert candidate(3, [[0,5,10],[5,0,15],[10,15,0]], [(0,30),(10,40),(20,50)]) == []\n    assert candidate(3, [[0,10,20],[10,0,30],[20,30,0]], [(5,15),(15,25),(25,35)]) == []\n    assert candidate(3, [[0,1,1],[1,0,1],[1,1,0]], [(0,10),(0,10),(0,10)]) == [0, 1, 2]\n    assert candidate(5, [[0,1,2,3,4],[1,0,2,3,4],[2,2,0,3,4],[3,3,3,0,4],[4,4,4,4,0]], [(0,100),(10,110),(20,120),(30,130),(40,140)]) == []\n    assert candidate(6, [[0,10,20,30,40,50],[10,0,15,25,35,45],[20,15,0,10,20,30],[30,25,10,0,15,25],[40,35,20,15,0,10],[50,45,30,25,10,0]], [(0,70),(10,80),(20,90),(30,100),(40,110),(50,120)]) == [0, 1, 2, 3, 4, 5]\n    assert candidate(4, [[0,10,15,20],[10,0,35,25],[15,35,0,30],[20,25,30,0]], [(0,50),(10,60),(0,70),(30,80)]) == []\n", "language": "python"}
{"task_id": "revision1a_problem258", "prompt": "from typing import List, Tuple\n\ndef optimize_warehouse(n: int, m: int, shelves: List[Tuple[int, int, int]]) -> int:\n    \"\"\"\n    You are tasked with optimizing the layout of a large warehouse for an e-commerce company.\n    The warehouse has 'n' rows and 'm' columns, forming a grid. Each cell in the grid can either be empty or contain a shelf.\n    Each shelf is represented by a tuple (x, y, h), where (x, y) are the coordinates of the shelf and 'h' is its height.\n\n    To maximize efficiency, you need to determine the maximum number of shelves that can be seen from the front of the warehouse.\n    A shelf is visible if there is no taller shelf in front of it in the same column.\n\n    Your task is to write a function that takes the warehouse dimensions and a list of shelf information,\n    and returns the number of visible shelves.\n\n    Take input from the user for the warehouse dimensions and shelf information, and return the count of visible shelves.\n\n    Example:\n    Input: 4, 5, [(1,1,10), (2,2,5), (3,1,7), (4,3,8), (1,4,15), (3,5,12)]\n    Output: 4\n    Input: 3, 3, [(1,1,5), (2,2,7), (3,3,10), (1,3,8), (3,1,6)]\n    Output: 3\n    \"\"\"\n", "entry_point": "optimize_warehouse", "solution": "    # Create a dictionary to store the tallest shelf in each column\n    tallest_shelves = {}\n\n    # Iterate through all shelves\n    for x, y, h in shelves:\n        # If the current shelf is taller than the tallest shelf in its column,\n        # or if there's no shelf in this column yet, update the tallest shelf\n        if y not in tallest_shelves or h > tallest_shelves[y][1]:\n            tallest_shelves[y] = (x, h)\n\n    # Count the number of visible shelves\n    visible_shelves = len(tallest_shelves)\n\n    return visible_shelves\n", "test": "def check(candidate):\n    assert candidate(5, 5, [(1,1,10), (2,2,20), (3,3,30), (4,4,40), (5,5,50)]) == 5\n    assert candidate(3, 4, [(1,1,5), (2,2,10), (3,3,15), (1,4,20)]) == 4\n    assert candidate(3, 3, [(1,1,5), (2,2,7), (3,3,10)]) == 3\n    assert candidate(4, 3, [(1,1,5), (2,2,10), (3,3,15), (4,1,20)]) == 3\n    assert candidate(2, 2, [(1,1,5), (2,2,10)]) == 2\n    assert candidate(1, 1, [(1,1,5)]) == 1\n    assert candidate(5, 1, [(1,1,5), (2,1,10), (3,1,15), (4,1,20), (5,1,25)]) == 1\n    assert candidate(4, 4, [(1,1,10), (2,2,5), (3,3,15), (4,4,20)]) == 4\n    assert candidate(3, 3, [(1,1,10), (1,2,20), (1,3,30), (2,1,15), (2,2,25), (2,3,35), (3,1,5), (3,2,15), (3,3,25)]) == 3\n    assert candidate(1, 5, [(1,1,5), (1,2,10), (1,3,15), (1,4,20), (1,5,25)]) == 5\n", "language": "python"}
{"task_id": "revision1a_problem507", "prompt": "def calculate_delivery_time(distance: float, traffic_level: str) -> str:\n    \"\"\"\n    As a delivery service dispatcher, I need to estimate the delivery time for packages based on the distance and traffic conditions.\n    Write a function that takes the distance in kilometers and the traffic level (low, medium, high) as inputs and calculates the estimated delivery time.\n    Assume the following speeds for different traffic levels:\n    - Low traffic: 60 km/h\n    - Medium traffic: 40 km/h\n    - High traffic: 20 km/h\n    Round the delivery time to the nearest 5 minutes.\n\n    Example:\n    Input: 30, \"low\"\n    Output: \"Estimated delivery time: 30 minutes\"\n\n    Example:\n    Input: 45, \"high\"\n    Output: \"Estimated delivery time: 2 hours 15 minutes\"\n    \"\"\"\n", "entry_point": "calculate_delivery_time", "solution": "    # Define speeds for different traffic levels\n    speeds = {\n        \"low\": 60,\n        \"medium\": 40,\n        \"high\": 20\n    }\n    \n    # Calculate time in hours\n    speed = speeds.get(traffic_level.lower(), 40)  # Default to medium if invalid input\n    time_hours = distance / speed\n    \n    # Convert to minutes and round to nearest 5\n    time_minutes = round(time_hours * 60 / 5) * 5\n    \n    # Calculate hours and remaining minutes\n    hours = time_minutes // 60\n    minutes = time_minutes % 60\n    \n    # Construct the output string\n    if hours == 0:\n        return f\"Estimated delivery time: {minutes} minutes\"\n    elif minutes == 0:\n        return f\"Estimated delivery time: {hours} hour{'s' if hours > 1 else ''}\"\n    else:\n        return f\"Estimated delivery time: {hours} hour{'s' if hours > 1 else ''} {minutes} minutes\"\n", "test": "def check(candidate):\n    assert candidate(75, \"medium\") == 'Estimated delivery time: 1 hour 50 minutes'\n    assert candidate(10, \"medium\") == 'Estimated delivery time: 15 minutes'\n    assert candidate(15, \"high\") == 'Estimated delivery time: 45 minutes'\n    assert candidate(60, \"low\") == 'Estimated delivery time: 1 hour'\n    assert candidate(2.5, \"low\") == 'Estimated delivery time: 0 minutes'\n    assert candidate(45, \"high\") == 'Estimated delivery time: 2 hours 15 minutes'\n    assert candidate(100, \"high\") == 'Estimated delivery time: 5 hours'\n    assert candidate(0, \"medium\") == 'Estimated delivery time: 0 minutes'\n    assert candidate(30, \"low\") == 'Estimated delivery time: 30 minutes'\n    assert candidate(5, \"low\") == 'Estimated delivery time: 5 minutes'\n", "language": "python"}
{"task_id": "revision1a_problem540", "prompt": "from typing import List, Tuple\n\ndef optimize_warehouse(warehouse_size: Tuple[int, int], boxes: List[Tuple[int, int, int]]) -> int:\n    \"\"\"\n    You are managing a warehouse and need to optimize the placement of boxes to maximize storage efficiency.\n    The warehouse floor is represented as a grid, and boxes can be placed in any orientation (rotated 90 degrees if needed).\n    Your task is to determine the maximum number of boxes that can be stored in the warehouse.\n\n    Parameters:\n    warehouse_size (Tuple[int, int]): The dimensions of the warehouse floor (width, length).\n    boxes (List[Tuple[int, int, int]]): A list of box dimensions (width, length, height) and quantities.\n\n    Returns:\n    int: The maximum number of boxes that can be stored in the warehouse.\n\n    Example:\n    Input: (10, 10), [(3, 2, 5, 10), (4, 4, 2, 5), (2, 3, 4, 8)]\n    Output: 18\n    Explanation: 10 of the first box type, 4 of the second, and 4 of the third can be placed in the 10x10 warehouse.\n    \"\"\"\n", "entry_point": "optimize_warehouse", "solution": "    def can_place(w: int, l: int) -> bool:\n        return (w <= warehouse_size[0] and l <= warehouse_size[1]) or (l <= warehouse_size[0] and w <= warehouse_size[1])\n\n    def place_boxes(index: int, remaining_area: int) -> int:\n        if index == len(boxes) or remaining_area == 0:\n            return 0\n\n        width, length, _, quantity = boxes[index]\n        max_boxes = 0\n\n        for orientation in [(width, length), (length, width)]:\n            if can_place(*orientation):\n                box_area = orientation[0] * orientation[1]\n                boxes_to_place = min(quantity, remaining_area // box_area)\n                \n                if boxes_to_place > 0:\n                    placed = boxes_to_place + place_boxes(index + 1, remaining_area - boxes_to_place * box_area)\n                    max_boxes = max(max_boxes, placed)\n\n        not_placed = place_boxes(index + 1, remaining_area)\n        return max(max_boxes, not_placed)\n\n    total_area = warehouse_size[0] * warehouse_size[1]\n    return place_boxes(0, total_area)\n", "test": "def check(candidate):\n    assert candidate((5, 5), [(1, 1, 1, 25)]) == 25\n    assert candidate((8, 12), [(2, 3, 4, 10), (4, 2, 3, 8), (3, 3, 3, 5)]) == 14\n    assert candidate((15, 15), [(3, 3, 3, 25), (5, 5, 5, 9)]) == 25\n    assert candidate((50, 50), [(10, 5, 5, 50), (5, 5, 5, 100), (8, 8, 4, 30)]) == 100\n    assert candidate((20, 30), [(5, 4, 3, 20), (3, 3, 3, 30), (6, 2, 2, 15)]) == 45\n    assert candidate((10, 10), [(3, 2, 5, 10), (4, 4, 2, 5), (2, 3, 4, 8)]) == 16\n    assert candidate((100, 100), [(10, 10, 10, 100)]) == 100\n    assert candidate((30, 30), [(6, 5, 4, 25), (7, 7, 3, 20), (10, 3, 8, 15)]) == 30\n    assert candidate((60, 80), [(15, 10, 5, 30), (20, 5, 8, 25), (12, 12, 12, 15)]) == 40\n    assert candidate((25, 40), [(5, 5, 5, 40), (8, 3, 4, 30), (10, 2, 6, 20)]) == 44\n", "language": "python"}
{"task_id": "revision1a_problem180", "prompt": "import math\nfrom typing import List, Tuple\nimport random\n\ndef optimize_delivery_route(locations: List[Tuple[float, float]], start: Tuple[float, float]) -> List[Tuple[float, float]]:\n    \"\"\"\n    Implement a function to optimize a delivery route for a local courier service.\n    The function should use a simple heuristic algorithm to find a near-optimal path visiting all locations.\n    \n    Parameters:\n    - locations: A list of tuples representing (latitude, longitude) coordinates of delivery locations.\n    - start: A tuple representing the (latitude, longitude) of the starting point.\n\n    The function should return a list of coordinates representing the optimized route, including the start and end points.\n\n    Use the Nearest Neighbor algorithm as a simple heuristic:\n    1. Start from the given starting point.\n    2. Find the nearest unvisited location.\n    3. Move to that location and mark it as visited.\n    4. Repeat steps 2-3 until all locations are visited.\n    5. Return to the starting point.\n\n    Example:\n    Input: \n    locations = [(40.7128, -74.0060), (34.0522, -118.2437), (41.8781, -87.6298), (29.7604, -95.3698)]\n    start = (38.9072, -77.0369)\n    \n    Output: \n    [(38.9072, -77.0369), (40.7128, -74.0060), (41.8781, -87.6298), (29.7604, -95.3698), (34.0522, -118.2437), (38.9072, -77.0369)]\n    \"\"\"\n", "entry_point": "optimize_delivery_route", "solution": "    def distance(point1: Tuple[float, float], point2: Tuple[float, float]) -> float:\n        \"\"\"Calculate the Euclidean distance between two points.\"\"\"\n        return ((point1[0] - point2[0]) ** 2 + (point1[1] - point2[1]) ** 2) ** 0.5\n\n    unvisited = locations.copy()\n    route = [start]\n    current = start\n\n    while unvisited:\n        nearest = min(unvisited, key=lambda x: distance(current, x))\n        route.append(nearest)\n        current = nearest\n        unvisited.remove(nearest)\n\n    route.append(start)  # Return to the starting point\n    return route\n", "test": "def check(candidate):\n    assert candidate([(-90, -180), (90, 180)], (0, 0)) == [(0, 0), (-90, -180), (90, 180), (0, 0)]\n    assert candidate([], (0, 0)) == [(0, 0), (0, 0)]\n    assert candidate([(1, 1), (2, 2), (3, 3)], (0, 0)) == [(0, 0), (1, 1), (2, 2), (3, 3), (0, 0)]\n    assert candidate([(i, i) for i in range(100)], (0, 0)) == [(0, 0), (0, 0), (1, 1), (2, 2), (3, 3), (4, 4), (5, 5), (6, 6), (7, 7), (8, 8), (9, 9), (10, 10), (11, 11), (12, 12), (13, 13), (14, 14), (15, 15), (16, 16), (17, 17), (18, 18), (19, 19), (20, 20), (21, 21), (22, 22), (23, 23), (24, 24), (25, 25), (26, 26), (27, 27), (28, 28), (29, 29), (30, 30), (31, 31), (32, 32), (33, 33), (34, 34), (35, 35), (36, 36), (37, 37), (38, 38), (39, 39), (40, 40), (41, 41), (42, 42), (43, 43), (44, 44), (45, 45), (46, 46), (47, 47), (48, 48), (49, 49), (50, 50), (51, 51), (52, 52), (53, 53), (54, 54), (55, 55), (56, 56), (57, 57), (58, 58), (59, 59), (60, 60), (61, 61), (62, 62), (63, 63), (64, 64), (65, 65), (66, 66), (67, 67), (68, 68), (69, 69), (70, 70), (71, 71), (72, 72), (73, 73), (74, 74), (75, 75), (76, 76), (77, 77), (78, 78), (79, 79), (80, 80), (81, 81), (82, 82), (83, 83), (84, 84), (85, 85), (86, 86), (87, 87), (88, 88), (89, 89), (90, 90), (91, 91), (92, 92), (93, 93), (94, 94), (95, 95), (96, 96), (97, 97), (98, 98), (99, 99), (0, 0)]\n    assert candidate([(0, 0), (0, 1), (1, 0), (1, 1)], (0.5, 0.5)) == [(0.5, 0.5), (0, 0), (0, 1), (1, 1), (1, 0), (0.5, 0.5)]\n    assert candidate([(0, 0), (0, 0), (0, 0)], (1, 1)) == [(1, 1), (0, 0), (0, 0), (0, 0), (1, 1)]\n    assert candidate([(40.7128, -74.0060), (34.0522, -118.2437), (41.8781, -87.6298), (29.7604, -95.3698)], (38.9072, -77.0369)) == [(38.9072, -77.0369), (40.7128, -74.006), (41.8781, -87.6298), (29.7604, -95.3698), (34.0522, -118.2437), (38.9072, -77.0369)]\n    assert candidate([(1, 1)], (0, 0)) == [(0, 0), (1, 1), (0, 0)]\n    assert candidate([(math.sin(i), math.cos(i)) for i in range(10)], (0, 0)) == [(0, 0), (0.0, 1.0), (-0.27941549819892586, 0.960170286650366), (-0.9589242746631385, 0.28366218546322625), (-0.7568024953079282, -0.6536436208636119), (0.1411200080598672, -0.9899924966004454), (0.4121184852417566, -0.9111302618846769), (0.9092974268256817, -0.4161468365471424), (0.9893582466233818, -0.14550003380861354), (0.8414709848078965, 0.5403023058681398), (0.6569865987187891, 0.7539022543433046), (0, 0)]\n", "language": "python"}
{"task_id": "revision1a_problem520", "prompt": "from typing import List, Tuple\n\ndef calculate_delivery_time(orders: List[Tuple[str, int, int]]) -> int:\n    \"\"\"\n    As a delivery scheduler for a pizza restaurant, I need to optimize our delivery times.\n    Each order is represented by a tuple containing the customer's name, the number of pizzas ordered,\n    and the distance to their house in kilometers.\n    \n    The delivery time is calculated as follows:\n    1. Base time of 10 minutes for preparation\n    2. 2 minutes per pizza for boxing\n    3. 3 minutes per kilometer for driving\n    4. If the total number of pizzas in all orders exceeds 10, add an additional 15 minutes for each group of 10 pizzas\n    \n    Your task is to calculate the total delivery time in minutes for all orders.\n    \n    Input: A list of tuples, each containing (customer_name, num_pizzas, distance)\n    Output: The total delivery time in minutes\n    \n    Example:\n    Input: [(\"Alice\", 2, 3), (\"Bob\", 3, 5), (\"Charlie\", 7, 1)]\n    Output: 80\n    \n    Explanation:\n    Base time: 10 minutes\n    Boxing time: (2 + 3 + 7) * 2 = 24 minutes\n    Driving time: (3 + 5 + 1) * 3 = 27 minutes\n    Additional time for over 10 pizzas: 15 minutes\n    Total: 10 + 24 + 27 + 15 = 76 minutes\n    \"\"\"\n", "entry_point": "calculate_delivery_time", "solution": "    \n    base_time = 10  # minutes\n    total_pizzas = sum(order[1] for order in orders)\n    total_distance = sum(order[2] for order in orders)\n    \n    boxing_time = total_pizzas * 2  # 2 minutes per pizza\n    driving_time = total_distance * 3  # 3 minutes per kilometer\n    \n    # Calculate additional time for groups of 10 pizzas\n    additional_time = (total_pizzas // 10) * 15\n    \n    total_time = base_time + boxing_time + driving_time + additional_time\n    \n    return total_time\n", "test": "def check(candidate):\n    assert candidate([(\"John\", 1, 1)]) == 15\n    assert candidate([(\"David\", 20, 1)]) == 83\n    assert candidate([(\"Sarah\", 5, 5), (\"Mike\", 5, 5)]) == 75\n    assert candidate([(\"Emma\", 1, 20)]) == 72\n    assert candidate([(\"Frank\", 5, 5)] * 5) == 165\n    assert candidate([(\"Alex\", 1, 1), (\"Beth\", 1, 1), (\"Carl\", 1, 1)]) == 25\n    assert candidate([(\"Alice\", 2, 3), (\"Bob\", 3, 5), (\"Charlie\", 7, 1)]) == 76\n    assert candidate([(\"Mary\", 10, 0)]) == 45\n    assert candidate([(\"Tom\", 0, 10)]) == 40\n    assert candidate([]) == 10\n", "language": "python"}
{"task_id": "revision1a_problem369", "prompt": "import random\nfrom typing import List\n\ndef epidemic_simulation(population: int, initial_infected: int, days: int, R0: float) -> List[int]:\n    \"\"\"\n    You are an epidemiologist developing a simulation model for the spread of a new infectious disease.\n    Your task is to create a function that simulates the progression of the epidemic over time.\n\n    The simulation should consider the following factors:\n    1. Total population\n    2. Initial number of infected individuals\n    3. Number of days to simulate\n    4. R0 (basic reproduction number) of the disease\n\n    Implement the following features:\n    1. Daily infection calculations\n    2. Recovery and immunity\n    3. Population dynamics (births and deaths)\n    4. Intervention measures (e.g., vaccination, social distancing)\n\n    Use object-oriented programming to model individuals and their disease states.\n    Implement stochastic elements to make the simulation more realistic.\n\n    Take input from the user for the total population, initial infected count, number of days to simulate, and R0.\n    Return a list where the i-th element represents the number of active infections on day i.\n\n    Example:\n    Input:\n    population = 10000\n    initial_infected = 10\n    days = 30\n    R0 = 2.5\n    Output: [10, 25, 62, 155, 387, ...] (list of 30 elements)\n    \"\"\"\n", "entry_point": "epidemic_simulation", "solution": "    class Individual:\n        def __init__(self):\n            self.state = \"susceptible\"\n            self.days_infected = 0\n\n        def infect(self):\n            self.state = \"infected\"\n            self.days_infected = 0\n\n        def update(self):\n            if self.state == \"infected\":\n                self.days_infected += 1\n                if self.days_infected >= 14:  # Assume 14 days for recovery\n                    self.state = \"recovered\"\n\n    # Initialize population\n    individuals = [Individual() for _ in range(population)]\n    for i in range(initial_infected):\n        individuals[i].infect()\n\n    # Simulation parameters\n    infection_rate = R0 / 14  # Assume 14 days of infectiousness\n    birth_rate = 0.00005  # Daily birth rate\n    death_rate = 0.00003  # Daily death rate\n    vaccination_rate = 0.001  # Daily vaccination rate\n    social_distancing_factor = 0.7  # Reduction factor due to social distancing\n\n    active_infections = []\n\n    for _ in range(days):\n        infected_count = sum(1 for ind in individuals if ind.state == \"infected\")\n        active_infections.append(infected_count)\n\n        # Update individuals\n        for ind in individuals:\n            ind.update()\n\n        # New infections\n        for ind in individuals:\n            if ind.state == \"susceptible\":\n                exposure_risk = infection_rate * infected_count / population * social_distancing_factor\n                if random.random() < exposure_risk:\n                    ind.infect()\n\n        # Births and deaths\n        new_births = int(population * birth_rate)\n        individuals.extend([Individual() for _ in range(new_births)])\n\n        deaths = random.sample(individuals, int(population * death_rate))\n        for ind in deaths:\n            individuals.remove(ind)\n\n        # Vaccination\n        susceptible = [ind for ind in individuals if ind.state == \"susceptible\"]\n        vaccinated = random.sample(susceptible, int(len(susceptible) * vaccination_rate))\n        for ind in vaccinated:\n            ind.state = \"recovered\"  # Assume vaccination leads to immunity\n\n        population = len(individuals)\n\n    return active_infections\n", "test": "def check(candidate):\n    assert candidate(1, 1, 5, 1.0) == [1, 1, 1, 1, 1]\n", "language": "python"}
{"task_id": "revision1a_problem120", "prompt": "from typing import List\n\ndef longest_consecutive_sequence(nums: List[int]) -> int:\n    \"\"\"\n    Given an unsorted array of integers, find the length of the longest consecutive elements sequence.\n    The sequence can be in any order within the array. Try to solve this problem in O(n) time complexity.\n    Take a list of integers as input from the user and return the length of the longest consecutive sequence.\n\n    This problem simulates finding the longest streak of consecutive numbers in a set of lottery tickets.\n\n    Example:\n    Input: [100, 4, 200, 1, 3, 2]\n    Output: 4 (The longest consecutive sequence is [1, 2, 3, 4])\n    Input: [0, 3, 7, 2, 5, 8, 4, 6, 0, 1]\n    Output: 9 (The longest consecutive sequence is [0, 1, 2, 3, 4, 5, 6, 7, 8])\n    \"\"\"\n", "entry_point": "longest_consecutive_sequence", "solution": "    if not nums:\n        return 0\n\n    num_set = set(nums)\n    longest_sequence = 0\n\n    for num in num_set:\n        if num - 1 not in num_set:  # Check if it's the start of a sequence\n            current_num = num\n            current_sequence = 1\n\n            while current_num + 1 in num_set:\n                current_num += 1\n                current_sequence += 1\n\n            longest_sequence = max(longest_sequence, current_sequence)\n\n    return longest_sequence\n", "test": "def check(candidate):\n    assert candidate([0, 3, 7, 2, 5, 8, 4, 6, 0, 1]) == 9\n    assert candidate([5, 4, 3, 2, 1]) == 5\n    assert candidate([1, 2, 4, 8, 16, 32]) == 2\n    assert candidate([2, 4, 6, 8, 10]) == 1\n    assert candidate([1, 3, 5, 7, 9]) == 1\n    assert candidate([1, 2, 3, 4, 5]) == 5\n    assert candidate([1, 10, 100, 1000]) == 1\n    assert candidate([]) == 0\n    assert candidate([1]) == 1\n    assert candidate([100, 4, 200, 1, 3, 2]) == 4\n", "language": "python"}
{"task_id": "revision1a_problem37", "prompt": "from typing import List\nimport math\n\ndef spiral_prime(n: int) -> List[List[int]]:\n    \"\"\"\n    Generate a spiral matrix of size n x n filled with prime numbers.\n    The spiral should start from the center and move outwards in a clockwise direction.\n    If there are not enough prime numbers to fill the matrix, use the next available prime.\n    \n    Parameters:\n    n (int): The size of the square matrix (n x n)\n    \n    Returns:\n    List[List[int]]: A 2D list representing the spiral matrix filled with prime numbers\n    \n    Example:\n    Input: 3\n    Output: [[5, 3, 2],\n             [11, 7, 1],\n             [13, 17, 19]]\n    \n    Input: 4\n    Output: [[7, 5, 3, 2],\n             [19, 11, 1, 13],\n             [23, 17, 29, 31],\n             [37, 41, 43, 47]]\n    \"\"\"\n", "entry_point": "spiral_prime", "solution": "    def is_prime(num):\n        if num < 2:\n            return False\n        for i in range(2, int(math.sqrt(num)) + 1):\n            if num % i == 0:\n                return False\n        return True\n\n    def next_prime(num):\n        num += 1\n        while not is_prime(num):\n            num += 1\n        return num\n\n    matrix = [[0 for _ in range(n)] for _ in range(n)]\n    directions = [(0, 1), (1, 0), (0, -1), (-1, 0)]  # right, down, left, up\n    x, y = n // 2, n // 2  # Start from the center\n    dir_index = 0\n    steps = 1\n    prime = 2\n\n    for _ in range(n * n):\n        matrix[x][y] = prime\n        prime = next_prime(prime)\n\n        for _ in range(2):\n            for _ in range(steps):\n                dx, dy = directions[dir_index]\n                x, y = x + dx, y + dy\n                if 0 <= x < n and 0 <= y < n and matrix[x][y] == 0:\n                    matrix[x][y] = prime\n                    prime = next_prime(prime)\n                else:\n                    x, y = x - dx, y - dy\n                    break\n            dir_index = (dir_index + 1) % 4\n\n        steps += 1\n\n    return matrix\n", "test": "def check(candidate):\n    assert candidate(9) == [[419, 421, 431, 433, 439, 443, 449, 457, 947], [401, 227, 229, 233, 239, 241, 251, 257, 263], [397, 211, 97, 101, 103, 107, 109, 113, 269], [389, 199, 83, 23, 29, 31, 37, 127, 271], [383, 197, 79, 17, 2, 3, 41, 131, 277], [379, 193, 73, 13, 11, 7, 43, 137, 281], [373, 191, 71, 67, 61, 59, 53, 139, 283], [367, 181, 179, 173, 167, 163, 157, 151, 293], [359, 353, 349, 347, 337, 331, 317, 313, 311]]\n    assert candidate(6) == [[167, 157, 151, 149, 139, 137], [173, 97, 101, 103, 107, 113], [179, 83, 23, 29, 31, 37], [181, 79, 17, 2, 3, 41], [191, 73, 13, 11, 7, 43], [353, 71, 67, 61, 59, 53]]\n    assert candidate(4) == [[67, 59, 53, 47], [71, 23, 29, 37], [73, 17, 2, 3], [127, 13, 11, 7]]\n    assert candidate(8) == [[331, 313, 311, 307, 293, 283, 281, 277], [337, 227, 229, 233, 239, 241, 251, 263], [347, 211, 97, 101, 103, 107, 109, 113], [349, 199, 83, 23, 29, 31, 37, 127], [353, 197, 79, 17, 2, 3, 41, 131], [359, 193, 73, 13, 11, 7, 43, 137], [367, 191, 71, 67, 61, 59, 53, 139], [709, 181, 179, 173, 167, 163, 157, 151]]\n    assert candidate(1) == [[2]]\n    assert candidate(3) == [[23, 29, 59], [17, 2, 3], [13, 11, 7]]\n    assert candidate(2) == [[11, 17], [5, 3]]\n    assert candidate(7) == [[227, 229, 233, 239, 241, 251, 509], [211, 97, 101, 103, 107, 109, 113], [199, 83, 23, 29, 31, 37, 127], [197, 79, 17, 2, 3, 41, 131], [193, 73, 13, 11, 7, 43, 137], [191, 71, 67, 61, 59, 53, 139], [181, 179, 173, 167, 163, 157, 151]]\n    assert candidate(5) == [[97, 101, 103, 107, 227], [83, 23, 29, 31, 37], [79, 17, 2, 3, 41], [73, 13, 11, 7, 43], [71, 67, 61, 59, 53]]\n    assert candidate(10) == [[563, 547, 541, 523, 521, 509, 503, 499, 491, 487], [569, 419, 421, 431, 433, 439, 443, 449, 457, 463], [571, 401, 227, 229, 233, 239, 241, 251, 257, 263], [577, 397, 211, 97, 101, 103, 107, 109, 113, 269], [587, 389, 199, 83, 23, 29, 31, 37, 127, 271], [593, 383, 197, 79, 17, 2, 3, 41, 131, 277], [599, 379, 193, 73, 13, 11, 7, 43, 137, 281], [601, 373, 191, 71, 67, 61, 59, 53, 139, 283], [607, 367, 181, 179, 173, 167, 163, 157, 151, 293], [1217, 359, 353, 349, 347, 337, 331, 317, 313, 311]]\n", "language": "python"}
{"task_id": "revision1a_problem741", "prompt": "from typing import List\n\ndef spiral_matrix(n: int) -> List[List[int]]:\n    \"\"\"\n    In a competitive programming contest, you are given a task to generate a spiral matrix.\n    The matrix should be filled with integers from 1 to n^2 in a clockwise spiral order.\n    Take an integer n as input and return a 2D list representing the spiral matrix.\n\n    Example:\n    Input: 3\n    Output: [[1, 2, 3], [8, 9, 4], [7, 6, 5]]\n    Input: 4\n    Output: [[1, 2, 3, 4], [12, 13, 14, 5], [11, 16, 15, 6], [10, 9, 8, 7]]\n    \"\"\"\n", "entry_point": "spiral_matrix", "solution": "    matrix = [[0 for _ in range(n)] for _ in range(n)]\n    num = 1\n    top, bottom, left, right = 0, n - 1, 0, n - 1\n\n    while num <= n * n:\n        # Fill top row\n        for i in range(left, right + 1):\n            matrix[top][i] = num\n            num += 1\n        top += 1\n\n        # Fill right column\n        for i in range(top, bottom + 1):\n            matrix[i][right] = num\n            num += 1\n        right -= 1\n\n        # Fill bottom row\n        for i in range(right, left - 1, -1):\n            matrix[bottom][i] = num\n            num += 1\n        bottom -= 1\n\n        # Fill left column\n        for i in range(bottom, top - 1, -1):\n            matrix[i][left] = num\n            num += 1\n        left += 1\n\n    return matrix\n", "test": "def check(candidate):\n    assert candidate(100) == [[1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99, 100], [396, 397, 398, 399, 400, 401, 402, 403, 404, 405, 406, 407, 408, 409, 410, 411, 412, 413, 414, 415, 416, 417, 418, 419, 420, 421, 422, 423, 424, 425, 426, 427, 428, 429, 430, 431, 432, 433, 434, 435, 436, 437, 438, 439, 440, 441, 442, 443, 444, 445, 446, 447, 448, 449, 450, 451, 452, 453, 454, 455, 456, 457, 458, 459, 460, 461, 462, 463, 464, 465, 466, 467, 468, 469, 470, 471, 472, 473, 474, 475, 476, 477, 478, 479, 480, 481, 482, 483, 484, 485, 486, 487, 488, 489, 490, 491, 492, 493, 494, 101], [395, 784, 785, 786, 787, 788, 789, 790, 791, 792, 793, 794, 795, 796, 797, 798, 799, 800, 801, 802, 803, 804, 805, 806, 807, 808, 809, 810, 811, 812, 813, 814, 815, 816, 817, 818, 819, 820, 821, 822, 823, 824, 825, 826, 827, 828, 829, 830, 831, 832, 833, 834, 835, 836, 837, 838, 839, 840, 841, 842, 843, 844, 845, 846, 847, 848, 849, 850, 851, 852, 853, 854, 855, 856, 857, 858, 859, 860, 861, 862, 863, 864, 865, 866, 867, 868, 869, 870, 871, 872, 873, 874, 875, 876, 877, 878, 879, 880, 495, 102], [394, 783, 1164, 1165, 1166, 1167, 1168, 1169, 1170, 1171, 1172, 1173, 1174, 1175, 1176, 1177, 1178, 1179, 1180, 1181, 1182, 1183, 1184, 1185, 1186, 1187, 1188, 1189, 1190, 1191, 1192, 1193, 1194, 1195, 1196, 1197, 1198, 1199, 1200, 1201, 1202, 1203, 1204, 1205, 1206, 1207, 1208, 1209, 1210, 1211, 1212, 1213, 1214, 1215, 1216, 1217, 1218, 1219, 1220, 1221, 1222, 1223, 1224, 1225, 1226, 1227, 1228, 1229, 1230, 1231, 1232, 1233, 1234, 1235, 1236, 1237, 1238, 1239, 1240, 1241, 1242, 1243, 1244, 1245, 1246, 1247, 1248, 1249, 1250, 1251, 1252, 1253, 1254, 1255, 1256, 1257, 1258, 881, 496, 103], [393, 782, 1163, 1536, 1537, 1538, 1539, 1540, 1541, 1542, 1543, 1544, 1545, 1546, 1547, 1548, 1549, 1550, 1551, 1552, 1553, 1554, 1555, 1556, 1557, 1558, 1559, 1560, 1561, 1562, 1563, 1564, 1565, 1566, 1567, 1568, 1569, 1570, 1571, 1572, 1573, 1574, 1575, 1576, 1577, 1578, 1579, 1580, 1581, 1582, 1583, 1584, 1585, 1586, 1587, 1588, 1589, 1590, 1591, 1592, 1593, 1594, 1595, 1596, 1597, 1598, 1599, 1600, 1601, 1602, 1603, 1604, 1605, 1606, 1607, 1608, 1609, 1610, 1611, 1612, 1613, 1614, 1615, 1616, 1617, 1618, 1619, 1620, 1621, 1622, 1623, 1624, 1625, 1626, 1627, 1628, 1259, 882, 497, 104], [392, 781, 1162, 1535, 1900, 1901, 1902, 1903, 1904, 1905, 1906, 1907, 1908, 1909, 1910, 1911, 1912, 1913, 1914, 1915, 1916, 1917, 1918, 1919, 1920, 1921, 1922, 1923, 1924, 1925, 1926, 1927, 1928, 1929, 1930, 1931, 1932, 1933, 1934, 1935, 1936, 1937, 1938, 1939, 1940, 1941, 1942, 1943, 1944, 1945, 1946, 1947, 1948, 1949, 1950, 1951, 1952, 1953, 1954, 1955, 1956, 1957, 1958, 1959, 1960, 1961, 1962, 1963, 1964, 1965, 1966, 1967, 1968, 1969, 1970, 1971, 1972, 1973, 1974, 1975, 1976, 1977, 1978, 1979, 1980, 1981, 1982, 1983, 1984, 1985, 1986, 1987, 1988, 1989, 1990, 1629, 1260, 883, 498, 105], [391, 780, 1161, 1534, 1899, 2256, 2257, 2258, 2259, 2260, 2261, 2262, 2263, 2264, 2265, 2266, 2267, 2268, 2269, 2270, 2271, 2272, 2273, 2274, 2275, 2276, 2277, 2278, 2279, 2280, 2281, 2282, 2283, 2284, 2285, 2286, 2287, 2288, 2289, 2290, 2291, 2292, 2293, 2294, 2295, 2296, 2297, 2298, 2299, 2300, 2301, 2302, 2303, 2304, 2305, 2306, 2307, 2308, 2309, 2310, 2311, 2312, 2313, 2314, 2315, 2316, 2317, 2318, 2319, 2320, 2321, 2322, 2323, 2324, 2325, 2326, 2327, 2328, 2329, 2330, 2331, 2332, 2333, 2334, 2335, 2336, 2337, 2338, 2339, 2340, 2341, 2342, 2343, 2344, 1991, 1630, 1261, 884, 499, 106], [390, 779, 1160, 1533, 1898, 2255, 2604, 2605, 2606, 2607, 2608, 2609, 2610, 2611, 2612, 2613, 2614, 2615, 2616, 2617, 2618, 2619, 2620, 2621, 2622, 2623, 2624, 2625, 2626, 2627, 2628, 2629, 2630, 2631, 2632, 2633, 2634, 2635, 2636, 2637, 2638, 2639, 2640, 2641, 2642, 2643, 2644, 2645, 2646, 2647, 2648, 2649, 2650, 2651, 2652, 2653, 2654, 2655, 2656, 2657, 2658, 2659, 2660, 2661, 2662, 2663, 2664, 2665, 2666, 2667, 2668, 2669, 2670, 2671, 2672, 2673, 2674, 2675, 2676, 2677, 2678, 2679, 2680, 2681, 2682, 2683, 2684, 2685, 2686, 2687, 2688, 2689, 2690, 2345, 1992, 1631, 1262, 885, 500, 107], [389, 778, 1159, 1532, 1897, 2254, 2603, 2944, 2945, 2946, 2947, 2948, 2949, 2950, 2951, 2952, 2953, 2954, 2955, 2956, 2957, 2958, 2959, 2960, 2961, 2962, 2963, 2964, 2965, 2966, 2967, 2968, 2969, 2970, 2971, 2972, 2973, 2974, 2975, 2976, 2977, 2978, 2979, 2980, 2981, 2982, 2983, 2984, 2985, 2986, 2987, 2988, 2989, 2990, 2991, 2992, 2993, 2994, 2995, 2996, 2997, 2998, 2999, 3000, 3001, 3002, 3003, 3004, 3005, 3006, 3007, 3008, 3009, 3010, 3011, 3012, 3013, 3014, 3015, 3016, 3017, 3018, 3019, 3020, 3021, 3022, 3023, 3024, 3025, 3026, 3027, 3028, 2691, 2346, 1993, 1632, 1263, 886, 501, 108], [388, 777, 1158, 1531, 1896, 2253, 2602, 2943, 3276, 3277, 3278, 3279, 3280, 3281, 3282, 3283, 3284, 3285, 3286, 3287, 3288, 3289, 3290, 3291, 3292, 3293, 3294, 3295, 3296, 3297, 3298, 3299, 3300, 3301, 3302, 3303, 3304, 3305, 3306, 3307, 3308, 3309, 3310, 3311, 3312, 3313, 3314, 3315, 3316, 3317, 3318, 3319, 3320, 3321, 3322, 3323, 3324, 3325, 3326, 3327, 3328, 3329, 3330, 3331, 3332, 3333, 3334, 3335, 3336, 3337, 3338, 3339, 3340, 3341, 3342, 3343, 3344, 3345, 3346, 3347, 3348, 3349, 3350, 3351, 3352, 3353, 3354, 3355, 3356, 3357, 3358, 3029, 2692, 2347, 1994, 1633, 1264, 887, 502, 109], [387, 776, 1157, 1530, 1895, 2252, 2601, 2942, 3275, 3600, 3601, 3602, 3603, 3604, 3605, 3606, 3607, 3608, 3609, 3610, 3611, 3612, 3613, 3614, 3615, 3616, 3617, 3618, 3619, 3620, 3621, 3622, 3623, 3624, 3625, 3626, 3627, 3628, 3629, 3630, 3631, 3632, 3633, 3634, 3635, 3636, 3637, 3638, 3639, 3640, 3641, 3642, 3643, 3644, 3645, 3646, 3647, 3648, 3649, 3650, 3651, 3652, 3653, 3654, 3655, 3656, 3657, 3658, 3659, 3660, 3661, 3662, 3663, 3664, 3665, 3666, 3667, 3668, 3669, 3670, 3671, 3672, 3673, 3674, 3675, 3676, 3677, 3678, 3679, 3680, 3359, 3030, 2693, 2348, 1995, 1634, 1265, 888, 503, 110], [386, 775, 1156, 1529, 1894, 2251, 2600, 2941, 3274, 3599, 3916, 3917, 3918, 3919, 3920, 3921, 3922, 3923, 3924, 3925, 3926, 3927, 3928, 3929, 3930, 3931, 3932, 3933, 3934, 3935, 3936, 3937, 3938, 3939, 3940, 3941, 3942, 3943, 3944, 3945, 3946, 3947, 3948, 3949, 3950, 3951, 3952, 3953, 3954, 3955, 3956, 3957, 3958, 3959, 3960, 3961, 3962, 3963, 3964, 3965, 3966, 3967, 3968, 3969, 3970, 3971, 3972, 3973, 3974, 3975, 3976, 3977, 3978, 3979, 3980, 3981, 3982, 3983, 3984, 3985, 3986, 3987, 3988, 3989, 3990, 3991, 3992, 3993, 3994, 3681, 3360, 3031, 2694, 2349, 1996, 1635, 1266, 889, 504, 111], [385, 774, 1155, 1528, 1893, 2250, 2599, 2940, 3273, 3598, 3915, 4224, 4225, 4226, 4227, 4228, 4229, 4230, 4231, 4232, 4233, 4234, 4235, 4236, 4237, 4238, 4239, 4240, 4241, 4242, 4243, 4244, 4245, 4246, 4247, 4248, 4249, 4250, 4251, 4252, 4253, 4254, 4255, 4256, 4257, 4258, 4259, 4260, 4261, 4262, 4263, 4264, 4265, 4266, 4267, 4268, 4269, 4270, 4271, 4272, 4273, 4274, 4275, 4276, 4277, 4278, 4279, 4280, 4281, 4282, 4283, 4284, 4285, 4286, 4287, 4288, 4289, 4290, 4291, 4292, 4293, 4294, 4295, 4296, 4297, 4298, 4299, 4300, 3995, 3682, 3361, 3032, 2695, 2350, 1997, 1636, 1267, 890, 505, 112], [384, 773, 1154, 1527, 1892, 2249, 2598, 2939, 3272, 3597, 3914, 4223, 4524, 4525, 4526, 4527, 4528, 4529, 4530, 4531, 4532, 4533, 4534, 4535, 4536, 4537, 4538, 4539, 4540, 4541, 4542, 4543, 4544, 4545, 4546, 4547, 4548, 4549, 4550, 4551, 4552, 4553, 4554, 4555, 4556, 4557, 4558, 4559, 4560, 4561, 4562, 4563, 4564, 4565, 4566, 4567, 4568, 4569, 4570, 4571, 4572, 4573, 4574, 4575, 4576, 4577, 4578, 4579, 4580, 4581, 4582, 4583, 4584, 4585, 4586, 4587, 4588, 4589, 4590, 4591, 4592, 4593, 4594, 4595, 4596, 4597, 4598, 4301, 3996, 3683, 3362, 3033, 2696, 2351, 1998, 1637, 1268, 891, 506, 113], [383, 772, 1153, 1526, 1891, 2248, 2597, 2938, 3271, 3596, 3913, 4222, 4523, 4816, 4817, 4818, 4819, 4820, 4821, 4822, 4823, 4824, 4825, 4826, 4827, 4828, 4829, 4830, 4831, 4832, 4833, 4834, 4835, 4836, 4837, 4838, 4839, 4840, 4841, 4842, 4843, 4844, 4845, 4846, 4847, 4848, 4849, 4850, 4851, 4852, 4853, 4854, 4855, 4856, 4857, 4858, 4859, 4860, 4861, 4862, 4863, 4864, 4865, 4866, 4867, 4868, 4869, 4870, 4871, 4872, 4873, 4874, 4875, 4876, 4877, 4878, 4879, 4880, 4881, 4882, 4883, 4884, 4885, 4886, 4887, 4888, 4599, 4302, 3997, 3684, 3363, 3034, 2697, 2352, 1999, 1638, 1269, 892, 507, 114], [382, 771, 1152, 1525, 1890, 2247, 2596, 2937, 3270, 3595, 3912, 4221, 4522, 4815, 5100, 5101, 5102, 5103, 5104, 5105, 5106, 5107, 5108, 5109, 5110, 5111, 5112, 5113, 5114, 5115, 5116, 5117, 5118, 5119, 5120, 5121, 5122, 5123, 5124, 5125, 5126, 5127, 5128, 5129, 5130, 5131, 5132, 5133, 5134, 5135, 5136, 5137, 5138, 5139, 5140, 5141, 5142, 5143, 5144, 5145, 5146, 5147, 5148, 5149, 5150, 5151, 5152, 5153, 5154, 5155, 5156, 5157, 5158, 5159, 5160, 5161, 5162, 5163, 5164, 5165, 5166, 5167, 5168, 5169, 5170, 4889, 4600, 4303, 3998, 3685, 3364, 3035, 2698, 2353, 2000, 1639, 1270, 893, 508, 115], [381, 770, 1151, 1524, 1889, 2246, 2595, 2936, 3269, 3594, 3911, 4220, 4521, 4814, 5099, 5376, 5377, 5378, 5379, 5380, 5381, 5382, 5383, 5384, 5385, 5386, 5387, 5388, 5389, 5390, 5391, 5392, 5393, 5394, 5395, 5396, 5397, 5398, 5399, 5400, 5401, 5402, 5403, 5404, 5405, 5406, 5407, 5408, 5409, 5410, 5411, 5412, 5413, 5414, 5415, 5416, 5417, 5418, 5419, 5420, 5421, 5422, 5423, 5424, 5425, 5426, 5427, 5428, 5429, 5430, 5431, 5432, 5433, 5434, 5435, 5436, 5437, 5438, 5439, 5440, 5441, 5442, 5443, 5444, 5171, 4890, 4601, 4304, 3999, 3686, 3365, 3036, 2699, 2354, 2001, 1640, 1271, 894, 509, 116], [380, 769, 1150, 1523, 1888, 2245, 2594, 2935, 3268, 3593, 3910, 4219, 4520, 4813, 5098, 5375, 5644, 5645, 5646, 5647, 5648, 5649, 5650, 5651, 5652, 5653, 5654, 5655, 5656, 5657, 5658, 5659, 5660, 5661, 5662, 5663, 5664, 5665, 5666, 5667, 5668, 5669, 5670, 5671, 5672, 5673, 5674, 5675, 5676, 5677, 5678, 5679, 5680, 5681, 5682, 5683, 5684, 5685, 5686, 5687, 5688, 5689, 5690, 5691, 5692, 5693, 5694, 5695, 5696, 5697, 5698, 5699, 5700, 5701, 5702, 5703, 5704, 5705, 5706, 5707, 5708, 5709, 5710, 5445, 5172, 4891, 4602, 4305, 4000, 3687, 3366, 3037, 2700, 2355, 2002, 1641, 1272, 895, 510, 117], [379, 768, 1149, 1522, 1887, 2244, 2593, 2934, 3267, 3592, 3909, 4218, 4519, 4812, 5097, 5374, 5643, 5904, 5905, 5906, 5907, 5908, 5909, 5910, 5911, 5912, 5913, 5914, 5915, 5916, 5917, 5918, 5919, 5920, 5921, 5922, 5923, 5924, 5925, 5926, 5927, 5928, 5929, 5930, 5931, 5932, 5933, 5934, 5935, 5936, 5937, 5938, 5939, 5940, 5941, 5942, 5943, 5944, 5945, 5946, 5947, 5948, 5949, 5950, 5951, 5952, 5953, 5954, 5955, 5956, 5957, 5958, 5959, 5960, 5961, 5962, 5963, 5964, 5965, 5966, 5967, 5968, 5711, 5446, 5173, 4892, 4603, 4306, 4001, 3688, 3367, 3038, 2701, 2356, 2003, 1642, 1273, 896, 511, 118], [378, 767, 1148, 1521, 1886, 2243, 2592, 2933, 3266, 3591, 3908, 4217, 4518, 4811, 5096, 5373, 5642, 5903, 6156, 6157, 6158, 6159, 6160, 6161, 6162, 6163, 6164, 6165, 6166, 6167, 6168, 6169, 6170, 6171, 6172, 6173, 6174, 6175, 6176, 6177, 6178, 6179, 6180, 6181, 6182, 6183, 6184, 6185, 6186, 6187, 6188, 6189, 6190, 6191, 6192, 6193, 6194, 6195, 6196, 6197, 6198, 6199, 6200, 6201, 6202, 6203, 6204, 6205, 6206, 6207, 6208, 6209, 6210, 6211, 6212, 6213, 6214, 6215, 6216, 6217, 6218, 5969, 5712, 5447, 5174, 4893, 4604, 4307, 4002, 3689, 3368, 3039, 2702, 2357, 2004, 1643, 1274, 897, 512, 119], [377, 766, 1147, 1520, 1885, 2242, 2591, 2932, 3265, 3590, 3907, 4216, 4517, 4810, 5095, 5372, 5641, 5902, 6155, 6400, 6401, 6402, 6403, 6404, 6405, 6406, 6407, 6408, 6409, 6410, 6411, 6412, 6413, 6414, 6415, 6416, 6417, 6418, 6419, 6420, 6421, 6422, 6423, 6424, 6425, 6426, 6427, 6428, 6429, 6430, 6431, 6432, 6433, 6434, 6435, 6436, 6437, 6438, 6439, 6440, 6441, 6442, 6443, 6444, 6445, 6446, 6447, 6448, 6449, 6450, 6451, 6452, 6453, 6454, 6455, 6456, 6457, 6458, 6459, 6460, 6219, 5970, 5713, 5448, 5175, 4894, 4605, 4308, 4003, 3690, 3369, 3040, 2703, 2358, 2005, 1644, 1275, 898, 513, 120], [376, 765, 1146, 1519, 1884, 2241, 2590, 2931, 3264, 3589, 3906, 4215, 4516, 4809, 5094, 5371, 5640, 5901, 6154, 6399, 6636, 6637, 6638, 6639, 6640, 6641, 6642, 6643, 6644, 6645, 6646, 6647, 6648, 6649, 6650, 6651, 6652, 6653, 6654, 6655, 6656, 6657, 6658, 6659, 6660, 6661, 6662, 6663, 6664, 6665, 6666, 6667, 6668, 6669, 6670, 6671, 6672, 6673, 6674, 6675, 6676, 6677, 6678, 6679, 6680, 6681, 6682, 6683, 6684, 6685, 6686, 6687, 6688, 6689, 6690, 6691, 6692, 6693, 6694, 6461, 6220, 5971, 5714, 5449, 5176, 4895, 4606, 4309, 4004, 3691, 3370, 3041, 2704, 2359, 2006, 1645, 1276, 899, 514, 121], [375, 764, 1145, 1518, 1883, 2240, 2589, 2930, 3263, 3588, 3905, 4214, 4515, 4808, 5093, 5370, 5639, 5900, 6153, 6398, 6635, 6864, 6865, 6866, 6867, 6868, 6869, 6870, 6871, 6872, 6873, 6874, 6875, 6876, 6877, 6878, 6879, 6880, 6881, 6882, 6883, 6884, 6885, 6886, 6887, 6888, 6889, 6890, 6891, 6892, 6893, 6894, 6895, 6896, 6897, 6898, 6899, 6900, 6901, 6902, 6903, 6904, 6905, 6906, 6907, 6908, 6909, 6910, 6911, 6912, 6913, 6914, 6915, 6916, 6917, 6918, 6919, 6920, 6695, 6462, 6221, 5972, 5715, 5450, 5177, 4896, 4607, 4310, 4005, 3692, 3371, 3042, 2705, 2360, 2007, 1646, 1277, 900, 515, 122], [374, 763, 1144, 1517, 1882, 2239, 2588, 2929, 3262, 3587, 3904, 4213, 4514, 4807, 5092, 5369, 5638, 5899, 6152, 6397, 6634, 6863, 7084, 7085, 7086, 7087, 7088, 7089, 7090, 7091, 7092, 7093, 7094, 7095, 7096, 7097, 7098, 7099, 7100, 7101, 7102, 7103, 7104, 7105, 7106, 7107, 7108, 7109, 7110, 7111, 7112, 7113, 7114, 7115, 7116, 7117, 7118, 7119, 7120, 7121, 7122, 7123, 7124, 7125, 7126, 7127, 7128, 7129, 7130, 7131, 7132, 7133, 7134, 7135, 7136, 7137, 7138, 6921, 6696, 6463, 6222, 5973, 5716, 5451, 5178, 4897, 4608, 4311, 4006, 3693, 3372, 3043, 2706, 2361, 2008, 1647, 1278, 901, 516, 123], [373, 762, 1143, 1516, 1881, 2238, 2587, 2928, 3261, 3586, 3903, 4212, 4513, 4806, 5091, 5368, 5637, 5898, 6151, 6396, 6633, 6862, 7083, 7296, 7297, 7298, 7299, 7300, 7301, 7302, 7303, 7304, 7305, 7306, 7307, 7308, 7309, 7310, 7311, 7312, 7313, 7314, 7315, 7316, 7317, 7318, 7319, 7320, 7321, 7322, 7323, 7324, 7325, 7326, 7327, 7328, 7329, 7330, 7331, 7332, 7333, 7334, 7335, 7336, 7337, 7338, 7339, 7340, 7341, 7342, 7343, 7344, 7345, 7346, 7347, 7348, 7139, 6922, 6697, 6464, 6223, 5974, 5717, 5452, 5179, 4898, 4609, 4312, 4007, 3694, 3373, 3044, 2707, 2362, 2009, 1648, 1279, 902, 517, 124], [372, 761, 1142, 1515, 1880, 2237, 2586, 2927, 3260, 3585, 3902, 4211, 4512, 4805, 5090, 5367, 5636, 5897, 6150, 6395, 6632, 6861, 7082, 7295, 7500, 7501, 7502, 7503, 7504, 7505, 7506, 7507, 7508, 7509, 7510, 7511, 7512, 7513, 7514, 7515, 7516, 7517, 7518, 7519, 7520, 7521, 7522, 7523, 7524, 7525, 7526, 7527, 7528, 7529, 7530, 7531, 7532, 7533, 7534, 7535, 7536, 7537, 7538, 7539, 7540, 7541, 7542, 7543, 7544, 7545, 7546, 7547, 7548, 7549, 7550, 7349, 7140, 6923, 6698, 6465, 6224, 5975, 5718, 5453, 5180, 4899, 4610, 4313, 4008, 3695, 3374, 3045, 2708, 2363, 2010, 1649, 1280, 903, 518, 125], [371, 760, 1141, 1514, 1879, 2236, 2585, 2926, 3259, 3584, 3901, 4210, 4511, 4804, 5089, 5366, 5635, 5896, 6149, 6394, 6631, 6860, 7081, 7294, 7499, 7696, 7697, 7698, 7699, 7700, 7701, 7702, 7703, 7704, 7705, 7706, 7707, 7708, 7709, 7710, 7711, 7712, 7713, 7714, 7715, 7716, 7717, 7718, 7719, 7720, 7721, 7722, 7723, 7724, 7725, 7726, 7727, 7728, 7729, 7730, 7731, 7732, 7733, 7734, 7735, 7736, 7737, 7738, 7739, 7740, 7741, 7742, 7743, 7744, 7551, 7350, 7141, 6924, 6699, 6466, 6225, 5976, 5719, 5454, 5181, 4900, 4611, 4314, 4009, 3696, 3375, 3046, 2709, 2364, 2011, 1650, 1281, 904, 519, 126], [370, 759, 1140, 1513, 1878, 2235, 2584, 2925, 3258, 3583, 3900, 4209, 4510, 4803, 5088, 5365, 5634, 5895, 6148, 6393, 6630, 6859, 7080, 7293, 7498, 7695, 7884, 7885, 7886, 7887, 7888, 7889, 7890, 7891, 7892, 7893, 7894, 7895, 7896, 7897, 7898, 7899, 7900, 7901, 7902, 7903, 7904, 7905, 7906, 7907, 7908, 7909, 7910, 7911, 7912, 7913, 7914, 7915, 7916, 7917, 7918, 7919, 7920, 7921, 7922, 7923, 7924, 7925, 7926, 7927, 7928, 7929, 7930, 7745, 7552, 7351, 7142, 6925, 6700, 6467, 6226, 5977, 5720, 5455, 5182, 4901, 4612, 4315, 4010, 3697, 3376, 3047, 2710, 2365, 2012, 1651, 1282, 905, 520, 127], [369, 758, 1139, 1512, 1877, 2234, 2583, 2924, 3257, 3582, 3899, 4208, 4509, 4802, 5087, 5364, 5633, 5894, 6147, 6392, 6629, 6858, 7079, 7292, 7497, 7694, 7883, 8064, 8065, 8066, 8067, 8068, 8069, 8070, 8071, 8072, 8073, 8074, 8075, 8076, 8077, 8078, 8079, 8080, 8081, 8082, 8083, 8084, 8085, 8086, 8087, 8088, 8089, 8090, 8091, 8092, 8093, 8094, 8095, 8096, 8097, 8098, 8099, 8100, 8101, 8102, 8103, 8104, 8105, 8106, 8107, 8108, 7931, 7746, 7553, 7352, 7143, 6926, 6701, 6468, 6227, 5978, 5721, 5456, 5183, 4902, 4613, 4316, 4011, 3698, 3377, 3048, 2711, 2366, 2013, 1652, 1283, 906, 521, 128], [368, 757, 1138, 1511, 1876, 2233, 2582, 2923, 3256, 3581, 3898, 4207, 4508, 4801, 5086, 5363, 5632, 5893, 6146, 6391, 6628, 6857, 7078, 7291, 7496, 7693, 7882, 8063, 8236, 8237, 8238, 8239, 8240, 8241, 8242, 8243, 8244, 8245, 8246, 8247, 8248, 8249, 8250, 8251, 8252, 8253, 8254, 8255, 8256, 8257, 8258, 8259, 8260, 8261, 8262, 8263, 8264, 8265, 8266, 8267, 8268, 8269, 8270, 8271, 8272, 8273, 8274, 8275, 8276, 8277, 8278, 8109, 7932, 7747, 7554, 7353, 7144, 6927, 6702, 6469, 6228, 5979, 5722, 5457, 5184, 4903, 4614, 4317, 4012, 3699, 3378, 3049, 2712, 2367, 2014, 1653, 1284, 907, 522, 129], [367, 756, 1137, 1510, 1875, 2232, 2581, 2922, 3255, 3580, 3897, 4206, 4507, 4800, 5085, 5362, 5631, 5892, 6145, 6390, 6627, 6856, 7077, 7290, 7495, 7692, 7881, 8062, 8235, 8400, 8401, 8402, 8403, 8404, 8405, 8406, 8407, 8408, 8409, 8410, 8411, 8412, 8413, 8414, 8415, 8416, 8417, 8418, 8419, 8420, 8421, 8422, 8423, 8424, 8425, 8426, 8427, 8428, 8429, 8430, 8431, 8432, 8433, 8434, 8435, 8436, 8437, 8438, 8439, 8440, 8279, 8110, 7933, 7748, 7555, 7354, 7145, 6928, 6703, 6470, 6229, 5980, 5723, 5458, 5185, 4904, 4615, 4318, 4013, 3700, 3379, 3050, 2713, 2368, 2015, 1654, 1285, 908, 523, 130], [366, 755, 1136, 1509, 1874, 2231, 2580, 2921, 3254, 3579, 3896, 4205, 4506, 4799, 5084, 5361, 5630, 5891, 6144, 6389, 6626, 6855, 7076, 7289, 7494, 7691, 7880, 8061, 8234, 8399, 8556, 8557, 8558, 8559, 8560, 8561, 8562, 8563, 8564, 8565, 8566, 8567, 8568, 8569, 8570, 8571, 8572, 8573, 8574, 8575, 8576, 8577, 8578, 8579, 8580, 8581, 8582, 8583, 8584, 8585, 8586, 8587, 8588, 8589, 8590, 8591, 8592, 8593, 8594, 8441, 8280, 8111, 7934, 7749, 7556, 7355, 7146, 6929, 6704, 6471, 6230, 5981, 5724, 5459, 5186, 4905, 4616, 4319, 4014, 3701, 3380, 3051, 2714, 2369, 2016, 1655, 1286, 909, 524, 131], [365, 754, 1135, 1508, 1873, 2230, 2579, 2920, 3253, 3578, 3895, 4204, 4505, 4798, 5083, 5360, 5629, 5890, 6143, 6388, 6625, 6854, 7075, 7288, 7493, 7690, 7879, 8060, 8233, 8398, 8555, 8704, 8705, 8706, 8707, 8708, 8709, 8710, 8711, 8712, 8713, 8714, 8715, 8716, 8717, 8718, 8719, 8720, 8721, 8722, 8723, 8724, 8725, 8726, 8727, 8728, 8729, 8730, 8731, 8732, 8733, 8734, 8735, 8736, 8737, 8738, 8739, 8740, 8595, 8442, 8281, 8112, 7935, 7750, 7557, 7356, 7147, 6930, 6705, 6472, 6231, 5982, 5725, 5460, 5187, 4906, 4617, 4320, 4015, 3702, 3381, 3052, 2715, 2370, 2017, 1656, 1287, 910, 525, 132], [364, 753, 1134, 1507, 1872, 2229, 2578, 2919, 3252, 3577, 3894, 4203, 4504, 4797, 5082, 5359, 5628, 5889, 6142, 6387, 6624, 6853, 7074, 7287, 7492, 7689, 7878, 8059, 8232, 8397, 8554, 8703, 8844, 8845, 8846, 8847, 8848, 8849, 8850, 8851, 8852, 8853, 8854, 8855, 8856, 8857, 8858, 8859, 8860, 8861, 8862, 8863, 8864, 8865, 8866, 8867, 8868, 8869, 8870, 8871, 8872, 8873, 8874, 8875, 8876, 8877, 8878, 8741, 8596, 8443, 8282, 8113, 7936, 7751, 7558, 7357, 7148, 6931, 6706, 6473, 6232, 5983, 5726, 5461, 5188, 4907, 4618, 4321, 4016, 3703, 3382, 3053, 2716, 2371, 2018, 1657, 1288, 911, 526, 133], [363, 752, 1133, 1506, 1871, 2228, 2577, 2918, 3251, 3576, 3893, 4202, 4503, 4796, 5081, 5358, 5627, 5888, 6141, 6386, 6623, 6852, 7073, 7286, 7491, 7688, 7877, 8058, 8231, 8396, 8553, 8702, 8843, 8976, 8977, 8978, 8979, 8980, 8981, 8982, 8983, 8984, 8985, 8986, 8987, 8988, 8989, 8990, 8991, 8992, 8993, 8994, 8995, 8996, 8997, 8998, 8999, 9000, 9001, 9002, 9003, 9004, 9005, 9006, 9007, 9008, 8879, 8742, 8597, 8444, 8283, 8114, 7937, 7752, 7559, 7358, 7149, 6932, 6707, 6474, 6233, 5984, 5727, 5462, 5189, 4908, 4619, 4322, 4017, 3704, 3383, 3054, 2717, 2372, 2019, 1658, 1289, 912, 527, 134], [362, 751, 1132, 1505, 1870, 2227, 2576, 2917, 3250, 3575, 3892, 4201, 4502, 4795, 5080, 5357, 5626, 5887, 6140, 6385, 6622, 6851, 7072, 7285, 7490, 7687, 7876, 8057, 8230, 8395, 8552, 8701, 8842, 8975, 9100, 9101, 9102, 9103, 9104, 9105, 9106, 9107, 9108, 9109, 9110, 9111, 9112, 9113, 9114, 9115, 9116, 9117, 9118, 9119, 9120, 9121, 9122, 9123, 9124, 9125, 9126, 9127, 9128, 9129, 9130, 9009, 8880, 8743, 8598, 8445, 8284, 8115, 7938, 7753, 7560, 7359, 7150, 6933, 6708, 6475, 6234, 5985, 5728, 5463, 5190, 4909, 4620, 4323, 4018, 3705, 3384, 3055, 2718, 2373, 2020, 1659, 1290, 913, 528, 135], [361, 750, 1131, 1504, 1869, 2226, 2575, 2916, 3249, 3574, 3891, 4200, 4501, 4794, 5079, 5356, 5625, 5886, 6139, 6384, 6621, 6850, 7071, 7284, 7489, 7686, 7875, 8056, 8229, 8394, 8551, 8700, 8841, 8974, 9099, 9216, 9217, 9218, 9219, 9220, 9221, 9222, 9223, 9224, 9225, 9226, 9227, 9228, 9229, 9230, 9231, 9232, 9233, 9234, 9235, 9236, 9237, 9238, 9239, 9240, 9241, 9242, 9243, 9244, 9131, 9010, 8881, 8744, 8599, 8446, 8285, 8116, 7939, 7754, 7561, 7360, 7151, 6934, 6709, 6476, 6235, 5986, 5729, 5464, 5191, 4910, 4621, 4324, 4019, 3706, 3385, 3056, 2719, 2374, 2021, 1660, 1291, 914, 529, 136], [360, 749, 1130, 1503, 1868, 2225, 2574, 2915, 3248, 3573, 3890, 4199, 4500, 4793, 5078, 5355, 5624, 5885, 6138, 6383, 6620, 6849, 7070, 7283, 7488, 7685, 7874, 8055, 8228, 8393, 8550, 8699, 8840, 8973, 9098, 9215, 9324, 9325, 9326, 9327, 9328, 9329, 9330, 9331, 9332, 9333, 9334, 9335, 9336, 9337, 9338, 9339, 9340, 9341, 9342, 9343, 9344, 9345, 9346, 9347, 9348, 9349, 9350, 9245, 9132, 9011, 8882, 8745, 8600, 8447, 8286, 8117, 7940, 7755, 7562, 7361, 7152, 6935, 6710, 6477, 6236, 5987, 5730, 5465, 5192, 4911, 4622, 4325, 4020, 3707, 3386, 3057, 2720, 2375, 2022, 1661, 1292, 915, 530, 137], [359, 748, 1129, 1502, 1867, 2224, 2573, 2914, 3247, 3572, 3889, 4198, 4499, 4792, 5077, 5354, 5623, 5884, 6137, 6382, 6619, 6848, 7069, 7282, 7487, 7684, 7873, 8054, 8227, 8392, 8549, 8698, 8839, 8972, 9097, 9214, 9323, 9424, 9425, 9426, 9427, 9428, 9429, 9430, 9431, 9432, 9433, 9434, 9435, 9436, 9437, 9438, 9439, 9440, 9441, 9442, 9443, 9444, 9445, 9446, 9447, 9448, 9351, 9246, 9133, 9012, 8883, 8746, 8601, 8448, 8287, 8118, 7941, 7756, 7563, 7362, 7153, 6936, 6711, 6478, 6237, 5988, 5731, 5466, 5193, 4912, 4623, 4326, 4021, 3708, 3387, 3058, 2721, 2376, 2023, 1662, 1293, 916, 531, 138], [358, 747, 1128, 1501, 1866, 2223, 2572, 2913, 3246, 3571, 3888, 4197, 4498, 4791, 5076, 5353, 5622, 5883, 6136, 6381, 6618, 6847, 7068, 7281, 7486, 7683, 7872, 8053, 8226, 8391, 8548, 8697, 8838, 8971, 9096, 9213, 9322, 9423, 9516, 9517, 9518, 9519, 9520, 9521, 9522, 9523, 9524, 9525, 9526, 9527, 9528, 9529, 9530, 9531, 9532, 9533, 9534, 9535, 9536, 9537, 9538, 9449, 9352, 9247, 9134, 9013, 8884, 8747, 8602, 8449, 8288, 8119, 7942, 7757, 7564, 7363, 7154, 6937, 6712, 6479, 6238, 5989, 5732, 5467, 5194, 4913, 4624, 4327, 4022, 3709, 3388, 3059, 2722, 2377, 2024, 1663, 1294, 917, 532, 139], [357, 746, 1127, 1500, 1865, 2222, 2571, 2912, 3245, 3570, 3887, 4196, 4497, 4790, 5075, 5352, 5621, 5882, 6135, 6380, 6617, 6846, 7067, 7280, 7485, 7682, 7871, 8052, 8225, 8390, 8547, 8696, 8837, 8970, 9095, 9212, 9321, 9422, 9515, 9600, 9601, 9602, 9603, 9604, 9605, 9606, 9607, 9608, 9609, 9610, 9611, 9612, 9613, 9614, 9615, 9616, 9617, 9618, 9619, 9620, 9539, 9450, 9353, 9248, 9135, 9014, 8885, 8748, 8603, 8450, 8289, 8120, 7943, 7758, 7565, 7364, 7155, 6938, 6713, 6480, 6239, 5990, 5733, 5468, 5195, 4914, 4625, 4328, 4023, 3710, 3389, 3060, 2723, 2378, 2025, 1664, 1295, 918, 533, 140], [356, 745, 1126, 1499, 1864, 2221, 2570, 2911, 3244, 3569, 3886, 4195, 4496, 4789, 5074, 5351, 5620, 5881, 6134, 6379, 6616, 6845, 7066, 7279, 7484, 7681, 7870, 8051, 8224, 8389, 8546, 8695, 8836, 8969, 9094, 9211, 9320, 9421, 9514, 9599, 9676, 9677, 9678, 9679, 9680, 9681, 9682, 9683, 9684, 9685, 9686, 9687, 9688, 9689, 9690, 9691, 9692, 9693, 9694, 9621, 9540, 9451, 9354, 9249, 9136, 9015, 8886, 8749, 8604, 8451, 8290, 8121, 7944, 7759, 7566, 7365, 7156, 6939, 6714, 6481, 6240, 5991, 5734, 5469, 5196, 4915, 4626, 4329, 4024, 3711, 3390, 3061, 2724, 2379, 2026, 1665, 1296, 919, 534, 141], [355, 744, 1125, 1498, 1863, 2220, 2569, 2910, 3243, 3568, 3885, 4194, 4495, 4788, 5073, 5350, 5619, 5880, 6133, 6378, 6615, 6844, 7065, 7278, 7483, 7680, 7869, 8050, 8223, 8388, 8545, 8694, 8835, 8968, 9093, 9210, 9319, 9420, 9513, 9598, 9675, 9744, 9745, 9746, 9747, 9748, 9749, 9750, 9751, 9752, 9753, 9754, 9755, 9756, 9757, 9758, 9759, 9760, 9695, 9622, 9541, 9452, 9355, 9250, 9137, 9016, 8887, 8750, 8605, 8452, 8291, 8122, 7945, 7760, 7567, 7366, 7157, 6940, 6715, 6482, 6241, 5992, 5735, 5470, 5197, 4916, 4627, 4330, 4025, 3712, 3391, 3062, 2725, 2380, 2027, 1666, 1297, 920, 535, 142], [354, 743, 1124, 1497, 1862, 2219, 2568, 2909, 3242, 3567, 3884, 4193, 4494, 4787, 5072, 5349, 5618, 5879, 6132, 6377, 6614, 6843, 7064, 7277, 7482, 7679, 7868, 8049, 8222, 8387, 8544, 8693, 8834, 8967, 9092, 9209, 9318, 9419, 9512, 9597, 9674, 9743, 9804, 9805, 9806, 9807, 9808, 9809, 9810, 9811, 9812, 9813, 9814, 9815, 9816, 9817, 9818, 9761, 9696, 9623, 9542, 9453, 9356, 9251, 9138, 9017, 8888, 8751, 8606, 8453, 8292, 8123, 7946, 7761, 7568, 7367, 7158, 6941, 6716, 6483, 6242, 5993, 5736, 5471, 5198, 4917, 4628, 4331, 4026, 3713, 3392, 3063, 2726, 2381, 2028, 1667, 1298, 921, 536, 143], [353, 742, 1123, 1496, 1861, 2218, 2567, 2908, 3241, 3566, 3883, 4192, 4493, 4786, 5071, 5348, 5617, 5878, 6131, 6376, 6613, 6842, 7063, 7276, 7481, 7678, 7867, 8048, 8221, 8386, 8543, 8692, 8833, 8966, 9091, 9208, 9317, 9418, 9511, 9596, 9673, 9742, 9803, 9856, 9857, 9858, 9859, 9860, 9861, 9862, 9863, 9864, 9865, 9866, 9867, 9868, 9819, 9762, 9697, 9624, 9543, 9454, 9357, 9252, 9139, 9018, 8889, 8752, 8607, 8454, 8293, 8124, 7947, 7762, 7569, 7368, 7159, 6942, 6717, 6484, 6243, 5994, 5737, 5472, 5199, 4918, 4629, 4332, 4027, 3714, 3393, 3064, 2727, 2382, 2029, 1668, 1299, 922, 537, 144], [352, 741, 1122, 1495, 1860, 2217, 2566, 2907, 3240, 3565, 3882, 4191, 4492, 4785, 5070, 5347, 5616, 5877, 6130, 6375, 6612, 6841, 7062, 7275, 7480, 7677, 7866, 8047, 8220, 8385, 8542, 8691, 8832, 8965, 9090, 9207, 9316, 9417, 9510, 9595, 9672, 9741, 9802, 9855, 9900, 9901, 9902, 9903, 9904, 9905, 9906, 9907, 9908, 9909, 9910, 9869, 9820, 9763, 9698, 9625, 9544, 9455, 9358, 9253, 9140, 9019, 8890, 8753, 8608, 8455, 8294, 8125, 7948, 7763, 7570, 7369, 7160, 6943, 6718, 6485, 6244, 5995, 5738, 5473, 5200, 4919, 4630, 4333, 4028, 3715, 3394, 3065, 2728, 2383, 2030, 1669, 1300, 923, 538, 145], [351, 740, 1121, 1494, 1859, 2216, 2565, 2906, 3239, 3564, 3881, 4190, 4491, 4784, 5069, 5346, 5615, 5876, 6129, 6374, 6611, 6840, 7061, 7274, 7479, 7676, 7865, 8046, 8219, 8384, 8541, 8690, 8831, 8964, 9089, 9206, 9315, 9416, 9509, 9594, 9671, 9740, 9801, 9854, 9899, 9936, 9937, 9938, 9939, 9940, 9941, 9942, 9943, 9944, 9911, 9870, 9821, 9764, 9699, 9626, 9545, 9456, 9359, 9254, 9141, 9020, 8891, 8754, 8609, 8456, 8295, 8126, 7949, 7764, 7571, 7370, 7161, 6944, 6719, 6486, 6245, 5996, 5739, 5474, 5201, 4920, 4631, 4334, 4029, 3716, 3395, 3066, 2729, 2384, 2031, 1670, 1301, 924, 539, 146], [350, 739, 1120, 1493, 1858, 2215, 2564, 2905, 3238, 3563, 3880, 4189, 4490, 4783, 5068, 5345, 5614, 5875, 6128, 6373, 6610, 6839, 7060, 7273, 7478, 7675, 7864, 8045, 8218, 8383, 8540, 8689, 8830, 8963, 9088, 9205, 9314, 9415, 9508, 9593, 9670, 9739, 9800, 9853, 9898, 9935, 9964, 9965, 9966, 9967, 9968, 9969, 9970, 9945, 9912, 9871, 9822, 9765, 9700, 9627, 9546, 9457, 9360, 9255, 9142, 9021, 8892, 8755, 8610, 8457, 8296, 8127, 7950, 7765, 7572, 7371, 7162, 6945, 6720, 6487, 6246, 5997, 5740, 5475, 5202, 4921, 4632, 4335, 4030, 3717, 3396, 3067, 2730, 2385, 2032, 1671, 1302, 925, 540, 147], [349, 738, 1119, 1492, 1857, 2214, 2563, 2904, 3237, 3562, 3879, 4188, 4489, 4782, 5067, 5344, 5613, 5874, 6127, 6372, 6609, 6838, 7059, 7272, 7477, 7674, 7863, 8044, 8217, 8382, 8539, 8688, 8829, 8962, 9087, 9204, 9313, 9414, 9507, 9592, 9669, 9738, 9799, 9852, 9897, 9934, 9963, 9984, 9985, 9986, 9987, 9988, 9971, 9946, 9913, 9872, 9823, 9766, 9701, 9628, 9547, 9458, 9361, 9256, 9143, 9022, 8893, 8756, 8611, 8458, 8297, 8128, 7951, 7766, 7573, 7372, 7163, 6946, 6721, 6488, 6247, 5998, 5741, 5476, 5203, 4922, 4633, 4336, 4031, 3718, 3397, 3068, 2731, 2386, 2033, 1672, 1303, 926, 541, 148], [348, 737, 1118, 1491, 1856, 2213, 2562, 2903, 3236, 3561, 3878, 4187, 4488, 4781, 5066, 5343, 5612, 5873, 6126, 6371, 6608, 6837, 7058, 7271, 7476, 7673, 7862, 8043, 8216, 8381, 8538, 8687, 8828, 8961, 9086, 9203, 9312, 9413, 9506, 9591, 9668, 9737, 9798, 9851, 9896, 9933, 9962, 9983, 9996, 9997, 9998, 9989, 9972, 9947, 9914, 9873, 9824, 9767, 9702, 9629, 9548, 9459, 9362, 9257, 9144, 9023, 8894, 8757, 8612, 8459, 8298, 8129, 7952, 7767, 7574, 7373, 7164, 6947, 6722, 6489, 6248, 5999, 5742, 5477, 5204, 4923, 4634, 4337, 4032, 3719, 3398, 3069, 2732, 2387, 2034, 1673, 1304, 927, 542, 149], [347, 736, 1117, 1490, 1855, 2212, 2561, 2902, 3235, 3560, 3877, 4186, 4487, 4780, 5065, 5342, 5611, 5872, 6125, 6370, 6607, 6836, 7057, 7270, 7475, 7672, 7861, 8042, 8215, 8380, 8537, 8686, 8827, 8960, 9085, 9202, 9311, 9412, 9505, 9590, 9667, 9736, 9797, 9850, 9895, 9932, 9961, 9982, 9995, 10000, 9999, 9990, 9973, 9948, 9915, 9874, 9825, 9768, 9703, 9630, 9549, 9460, 9363, 9258, 9145, 9024, 8895, 8758, 8613, 8460, 8299, 8130, 7953, 7768, 7575, 7374, 7165, 6948, 6723, 6490, 6249, 6000, 5743, 5478, 5205, 4924, 4635, 4338, 4033, 3720, 3399, 3070, 2733, 2388, 2035, 1674, 1305, 928, 543, 150], [346, 735, 1116, 1489, 1854, 2211, 2560, 2901, 3234, 3559, 3876, 4185, 4486, 4779, 5064, 5341, 5610, 5871, 6124, 6369, 6606, 6835, 7056, 7269, 7474, 7671, 7860, 8041, 8214, 8379, 8536, 8685, 8826, 8959, 9084, 9201, 9310, 9411, 9504, 9589, 9666, 9735, 9796, 9849, 9894, 9931, 9960, 9981, 9994, 9993, 9992, 9991, 9974, 9949, 9916, 9875, 9826, 9769, 9704, 9631, 9550, 9461, 9364, 9259, 9146, 9025, 8896, 8759, 8614, 8461, 8300, 8131, 7954, 7769, 7576, 7375, 7166, 6949, 6724, 6491, 6250, 6001, 5744, 5479, 5206, 4925, 4636, 4339, 4034, 3721, 3400, 3071, 2734, 2389, 2036, 1675, 1306, 929, 544, 151], [345, 734, 1115, 1488, 1853, 2210, 2559, 2900, 3233, 3558, 3875, 4184, 4485, 4778, 5063, 5340, 5609, 5870, 6123, 6368, 6605, 6834, 7055, 7268, 7473, 7670, 7859, 8040, 8213, 8378, 8535, 8684, 8825, 8958, 9083, 9200, 9309, 9410, 9503, 9588, 9665, 9734, 9795, 9848, 9893, 9930, 9959, 9980, 9979, 9978, 9977, 9976, 9975, 9950, 9917, 9876, 9827, 9770, 9705, 9632, 9551, 9462, 9365, 9260, 9147, 9026, 8897, 8760, 8615, 8462, 8301, 8132, 7955, 7770, 7577, 7376, 7167, 6950, 6725, 6492, 6251, 6002, 5745, 5480, 5207, 4926, 4637, 4340, 4035, 3722, 3401, 3072, 2735, 2390, 2037, 1676, 1307, 930, 545, 152], [344, 733, 1114, 1487, 1852, 2209, 2558, 2899, 3232, 3557, 3874, 4183, 4484, 4777, 5062, 5339, 5608, 5869, 6122, 6367, 6604, 6833, 7054, 7267, 7472, 7669, 7858, 8039, 8212, 8377, 8534, 8683, 8824, 8957, 9082, 9199, 9308, 9409, 9502, 9587, 9664, 9733, 9794, 9847, 9892, 9929, 9958, 9957, 9956, 9955, 9954, 9953, 9952, 9951, 9918, 9877, 9828, 9771, 9706, 9633, 9552, 9463, 9366, 9261, 9148, 9027, 8898, 8761, 8616, 8463, 8302, 8133, 7956, 7771, 7578, 7377, 7168, 6951, 6726, 6493, 6252, 6003, 5746, 5481, 5208, 4927, 4638, 4341, 4036, 3723, 3402, 3073, 2736, 2391, 2038, 1677, 1308, 931, 546, 153], [343, 732, 1113, 1486, 1851, 2208, 2557, 2898, 3231, 3556, 3873, 4182, 4483, 4776, 5061, 5338, 5607, 5868, 6121, 6366, 6603, 6832, 7053, 7266, 7471, 7668, 7857, 8038, 8211, 8376, 8533, 8682, 8823, 8956, 9081, 9198, 9307, 9408, 9501, 9586, 9663, 9732, 9793, 9846, 9891, 9928, 9927, 9926, 9925, 9924, 9923, 9922, 9921, 9920, 9919, 9878, 9829, 9772, 9707, 9634, 9553, 9464, 9367, 9262, 9149, 9028, 8899, 8762, 8617, 8464, 8303, 8134, 7957, 7772, 7579, 7378, 7169, 6952, 6727, 6494, 6253, 6004, 5747, 5482, 5209, 4928, 4639, 4342, 4037, 3724, 3403, 3074, 2737, 2392, 2039, 1678, 1309, 932, 547, 154], [342, 731, 1112, 1485, 1850, 2207, 2556, 2897, 3230, 3555, 3872, 4181, 4482, 4775, 5060, 5337, 5606, 5867, 6120, 6365, 6602, 6831, 7052, 7265, 7470, 7667, 7856, 8037, 8210, 8375, 8532, 8681, 8822, 8955, 9080, 9197, 9306, 9407, 9500, 9585, 9662, 9731, 9792, 9845, 9890, 9889, 9888, 9887, 9886, 9885, 9884, 9883, 9882, 9881, 9880, 9879, 9830, 9773, 9708, 9635, 9554, 9465, 9368, 9263, 9150, 9029, 8900, 8763, 8618, 8465, 8304, 8135, 7958, 7773, 7580, 7379, 7170, 6953, 6728, 6495, 6254, 6005, 5748, 5483, 5210, 4929, 4640, 4343, 4038, 3725, 3404, 3075, 2738, 2393, 2040, 1679, 1310, 933, 548, 155], [341, 730, 1111, 1484, 1849, 2206, 2555, 2896, 3229, 3554, 3871, 4180, 4481, 4774, 5059, 5336, 5605, 5866, 6119, 6364, 6601, 6830, 7051, 7264, 7469, 7666, 7855, 8036, 8209, 8374, 8531, 8680, 8821, 8954, 9079, 9196, 9305, 9406, 9499, 9584, 9661, 9730, 9791, 9844, 9843, 9842, 9841, 9840, 9839, 9838, 9837, 9836, 9835, 9834, 9833, 9832, 9831, 9774, 9709, 9636, 9555, 9466, 9369, 9264, 9151, 9030, 8901, 8764, 8619, 8466, 8305, 8136, 7959, 7774, 7581, 7380, 7171, 6954, 6729, 6496, 6255, 6006, 5749, 5484, 5211, 4930, 4641, 4344, 4039, 3726, 3405, 3076, 2739, 2394, 2041, 1680, 1311, 934, 549, 156], [340, 729, 1110, 1483, 1848, 2205, 2554, 2895, 3228, 3553, 3870, 4179, 4480, 4773, 5058, 5335, 5604, 5865, 6118, 6363, 6600, 6829, 7050, 7263, 7468, 7665, 7854, 8035, 8208, 8373, 8530, 8679, 8820, 8953, 9078, 9195, 9304, 9405, 9498, 9583, 9660, 9729, 9790, 9789, 9788, 9787, 9786, 9785, 9784, 9783, 9782, 9781, 9780, 9779, 9778, 9777, 9776, 9775, 9710, 9637, 9556, 9467, 9370, 9265, 9152, 9031, 8902, 8765, 8620, 8467, 8306, 8137, 7960, 7775, 7582, 7381, 7172, 6955, 6730, 6497, 6256, 6007, 5750, 5485, 5212, 4931, 4642, 4345, 4040, 3727, 3406, 3077, 2740, 2395, 2042, 1681, 1312, 935, 550, 157], [339, 728, 1109, 1482, 1847, 2204, 2553, 2894, 3227, 3552, 3869, 4178, 4479, 4772, 5057, 5334, 5603, 5864, 6117, 6362, 6599, 6828, 7049, 7262, 7467, 7664, 7853, 8034, 8207, 8372, 8529, 8678, 8819, 8952, 9077, 9194, 9303, 9404, 9497, 9582, 9659, 9728, 9727, 9726, 9725, 9724, 9723, 9722, 9721, 9720, 9719, 9718, 9717, 9716, 9715, 9714, 9713, 9712, 9711, 9638, 9557, 9468, 9371, 9266, 9153, 9032, 8903, 8766, 8621, 8468, 8307, 8138, 7961, 7776, 7583, 7382, 7173, 6956, 6731, 6498, 6257, 6008, 5751, 5486, 5213, 4932, 4643, 4346, 4041, 3728, 3407, 3078, 2741, 2396, 2043, 1682, 1313, 936, 551, 158], [338, 727, 1108, 1481, 1846, 2203, 2552, 2893, 3226, 3551, 3868, 4177, 4478, 4771, 5056, 5333, 5602, 5863, 6116, 6361, 6598, 6827, 7048, 7261, 7466, 7663, 7852, 8033, 8206, 8371, 8528, 8677, 8818, 8951, 9076, 9193, 9302, 9403, 9496, 9581, 9658, 9657, 9656, 9655, 9654, 9653, 9652, 9651, 9650, 9649, 9648, 9647, 9646, 9645, 9644, 9643, 9642, 9641, 9640, 9639, 9558, 9469, 9372, 9267, 9154, 9033, 8904, 8767, 8622, 8469, 8308, 8139, 7962, 7777, 7584, 7383, 7174, 6957, 6732, 6499, 6258, 6009, 5752, 5487, 5214, 4933, 4644, 4347, 4042, 3729, 3408, 3079, 2742, 2397, 2044, 1683, 1314, 937, 552, 159], [337, 726, 1107, 1480, 1845, 2202, 2551, 2892, 3225, 3550, 3867, 4176, 4477, 4770, 5055, 5332, 5601, 5862, 6115, 6360, 6597, 6826, 7047, 7260, 7465, 7662, 7851, 8032, 8205, 8370, 8527, 8676, 8817, 8950, 9075, 9192, 9301, 9402, 9495, 9580, 9579, 9578, 9577, 9576, 9575, 9574, 9573, 9572, 9571, 9570, 9569, 9568, 9567, 9566, 9565, 9564, 9563, 9562, 9561, 9560, 9559, 9470, 9373, 9268, 9155, 9034, 8905, 8768, 8623, 8470, 8309, 8140, 7963, 7778, 7585, 7384, 7175, 6958, 6733, 6500, 6259, 6010, 5753, 5488, 5215, 4934, 4645, 4348, 4043, 3730, 3409, 3080, 2743, 2398, 2045, 1684, 1315, 938, 553, 160], [336, 725, 1106, 1479, 1844, 2201, 2550, 2891, 3224, 3549, 3866, 4175, 4476, 4769, 5054, 5331, 5600, 5861, 6114, 6359, 6596, 6825, 7046, 7259, 7464, 7661, 7850, 8031, 8204, 8369, 8526, 8675, 8816, 8949, 9074, 9191, 9300, 9401, 9494, 9493, 9492, 9491, 9490, 9489, 9488, 9487, 9486, 9485, 9484, 9483, 9482, 9481, 9480, 9479, 9478, 9477, 9476, 9475, 9474, 9473, 9472, 9471, 9374, 9269, 9156, 9035, 8906, 8769, 8624, 8471, 8310, 8141, 7964, 7779, 7586, 7385, 7176, 6959, 6734, 6501, 6260, 6011, 5754, 5489, 5216, 4935, 4646, 4349, 4044, 3731, 3410, 3081, 2744, 2399, 2046, 1685, 1316, 939, 554, 161], [335, 724, 1105, 1478, 1843, 2200, 2549, 2890, 3223, 3548, 3865, 4174, 4475, 4768, 5053, 5330, 5599, 5860, 6113, 6358, 6595, 6824, 7045, 7258, 7463, 7660, 7849, 8030, 8203, 8368, 8525, 8674, 8815, 8948, 9073, 9190, 9299, 9400, 9399, 9398, 9397, 9396, 9395, 9394, 9393, 9392, 9391, 9390, 9389, 9388, 9387, 9386, 9385, 9384, 9383, 9382, 9381, 9380, 9379, 9378, 9377, 9376, 9375, 9270, 9157, 9036, 8907, 8770, 8625, 8472, 8311, 8142, 7965, 7780, 7587, 7386, 7177, 6960, 6735, 6502, 6261, 6012, 5755, 5490, 5217, 4936, 4647, 4350, 4045, 3732, 3411, 3082, 2745, 2400, 2047, 1686, 1317, 940, 555, 162], [334, 723, 1104, 1477, 1842, 2199, 2548, 2889, 3222, 3547, 3864, 4173, 4474, 4767, 5052, 5329, 5598, 5859, 6112, 6357, 6594, 6823, 7044, 7257, 7462, 7659, 7848, 8029, 8202, 8367, 8524, 8673, 8814, 8947, 9072, 9189, 9298, 9297, 9296, 9295, 9294, 9293, 9292, 9291, 9290, 9289, 9288, 9287, 9286, 9285, 9284, 9283, 9282, 9281, 9280, 9279, 9278, 9277, 9276, 9275, 9274, 9273, 9272, 9271, 9158, 9037, 8908, 8771, 8626, 8473, 8312, 8143, 7966, 7781, 7588, 7387, 7178, 6961, 6736, 6503, 6262, 6013, 5756, 5491, 5218, 4937, 4648, 4351, 4046, 3733, 3412, 3083, 2746, 2401, 2048, 1687, 1318, 941, 556, 163], [333, 722, 1103, 1476, 1841, 2198, 2547, 2888, 3221, 3546, 3863, 4172, 4473, 4766, 5051, 5328, 5597, 5858, 6111, 6356, 6593, 6822, 7043, 7256, 7461, 7658, 7847, 8028, 8201, 8366, 8523, 8672, 8813, 8946, 9071, 9188, 9187, 9186, 9185, 9184, 9183, 9182, 9181, 9180, 9179, 9178, 9177, 9176, 9175, 9174, 9173, 9172, 9171, 9170, 9169, 9168, 9167, 9166, 9165, 9164, 9163, 9162, 9161, 9160, 9159, 9038, 8909, 8772, 8627, 8474, 8313, 8144, 7967, 7782, 7589, 7388, 7179, 6962, 6737, 6504, 6263, 6014, 5757, 5492, 5219, 4938, 4649, 4352, 4047, 3734, 3413, 3084, 2747, 2402, 2049, 1688, 1319, 942, 557, 164], [332, 721, 1102, 1475, 1840, 2197, 2546, 2887, 3220, 3545, 3862, 4171, 4472, 4765, 5050, 5327, 5596, 5857, 6110, 6355, 6592, 6821, 7042, 7255, 7460, 7657, 7846, 8027, 8200, 8365, 8522, 8671, 8812, 8945, 9070, 9069, 9068, 9067, 9066, 9065, 9064, 9063, 9062, 9061, 9060, 9059, 9058, 9057, 9056, 9055, 9054, 9053, 9052, 9051, 9050, 9049, 9048, 9047, 9046, 9045, 9044, 9043, 9042, 9041, 9040, 9039, 8910, 8773, 8628, 8475, 8314, 8145, 7968, 7783, 7590, 7389, 7180, 6963, 6738, 6505, 6264, 6015, 5758, 5493, 5220, 4939, 4650, 4353, 4048, 3735, 3414, 3085, 2748, 2403, 2050, 1689, 1320, 943, 558, 165], [331, 720, 1101, 1474, 1839, 2196, 2545, 2886, 3219, 3544, 3861, 4170, 4471, 4764, 5049, 5326, 5595, 5856, 6109, 6354, 6591, 6820, 7041, 7254, 7459, 7656, 7845, 8026, 8199, 8364, 8521, 8670, 8811, 8944, 8943, 8942, 8941, 8940, 8939, 8938, 8937, 8936, 8935, 8934, 8933, 8932, 8931, 8930, 8929, 8928, 8927, 8926, 8925, 8924, 8923, 8922, 8921, 8920, 8919, 8918, 8917, 8916, 8915, 8914, 8913, 8912, 8911, 8774, 8629, 8476, 8315, 8146, 7969, 7784, 7591, 7390, 7181, 6964, 6739, 6506, 6265, 6016, 5759, 5494, 5221, 4940, 4651, 4354, 4049, 3736, 3415, 3086, 2749, 2404, 2051, 1690, 1321, 944, 559, 166], [330, 719, 1100, 1473, 1838, 2195, 2544, 2885, 3218, 3543, 3860, 4169, 4470, 4763, 5048, 5325, 5594, 5855, 6108, 6353, 6590, 6819, 7040, 7253, 7458, 7655, 7844, 8025, 8198, 8363, 8520, 8669, 8810, 8809, 8808, 8807, 8806, 8805, 8804, 8803, 8802, 8801, 8800, 8799, 8798, 8797, 8796, 8795, 8794, 8793, 8792, 8791, 8790, 8789, 8788, 8787, 8786, 8785, 8784, 8783, 8782, 8781, 8780, 8779, 8778, 8777, 8776, 8775, 8630, 8477, 8316, 8147, 7970, 7785, 7592, 7391, 7182, 6965, 6740, 6507, 6266, 6017, 5760, 5495, 5222, 4941, 4652, 4355, 4050, 3737, 3416, 3087, 2750, 2405, 2052, 1691, 1322, 945, 560, 167], [329, 718, 1099, 1472, 1837, 2194, 2543, 2884, 3217, 3542, 3859, 4168, 4469, 4762, 5047, 5324, 5593, 5854, 6107, 6352, 6589, 6818, 7039, 7252, 7457, 7654, 7843, 8024, 8197, 8362, 8519, 8668, 8667, 8666, 8665, 8664, 8663, 8662, 8661, 8660, 8659, 8658, 8657, 8656, 8655, 8654, 8653, 8652, 8651, 8650, 8649, 8648, 8647, 8646, 8645, 8644, 8643, 8642, 8641, 8640, 8639, 8638, 8637, 8636, 8635, 8634, 8633, 8632, 8631, 8478, 8317, 8148, 7971, 7786, 7593, 7392, 7183, 6966, 6741, 6508, 6267, 6018, 5761, 5496, 5223, 4942, 4653, 4356, 4051, 3738, 3417, 3088, 2751, 2406, 2053, 1692, 1323, 946, 561, 168], [328, 717, 1098, 1471, 1836, 2193, 2542, 2883, 3216, 3541, 3858, 4167, 4468, 4761, 5046, 5323, 5592, 5853, 6106, 6351, 6588, 6817, 7038, 7251, 7456, 7653, 7842, 8023, 8196, 8361, 8518, 8517, 8516, 8515, 8514, 8513, 8512, 8511, 8510, 8509, 8508, 8507, 8506, 8505, 8504, 8503, 8502, 8501, 8500, 8499, 8498, 8497, 8496, 8495, 8494, 8493, 8492, 8491, 8490, 8489, 8488, 8487, 8486, 8485, 8484, 8483, 8482, 8481, 8480, 8479, 8318, 8149, 7972, 7787, 7594, 7393, 7184, 6967, 6742, 6509, 6268, 6019, 5762, 5497, 5224, 4943, 4654, 4357, 4052, 3739, 3418, 3089, 2752, 2407, 2054, 1693, 1324, 947, 562, 169], [327, 716, 1097, 1470, 1835, 2192, 2541, 2882, 3215, 3540, 3857, 4166, 4467, 4760, 5045, 5322, 5591, 5852, 6105, 6350, 6587, 6816, 7037, 7250, 7455, 7652, 7841, 8022, 8195, 8360, 8359, 8358, 8357, 8356, 8355, 8354, 8353, 8352, 8351, 8350, 8349, 8348, 8347, 8346, 8345, 8344, 8343, 8342, 8341, 8340, 8339, 8338, 8337, 8336, 8335, 8334, 8333, 8332, 8331, 8330, 8329, 8328, 8327, 8326, 8325, 8324, 8323, 8322, 8321, 8320, 8319, 8150, 7973, 7788, 7595, 7394, 7185, 6968, 6743, 6510, 6269, 6020, 5763, 5498, 5225, 4944, 4655, 4358, 4053, 3740, 3419, 3090, 2753, 2408, 2055, 1694, 1325, 948, 563, 170], [326, 715, 1096, 1469, 1834, 2191, 2540, 2881, 3214, 3539, 3856, 4165, 4466, 4759, 5044, 5321, 5590, 5851, 6104, 6349, 6586, 6815, 7036, 7249, 7454, 7651, 7840, 8021, 8194, 8193, 8192, 8191, 8190, 8189, 8188, 8187, 8186, 8185, 8184, 8183, 8182, 8181, 8180, 8179, 8178, 8177, 8176, 8175, 8174, 8173, 8172, 8171, 8170, 8169, 8168, 8167, 8166, 8165, 8164, 8163, 8162, 8161, 8160, 8159, 8158, 8157, 8156, 8155, 8154, 8153, 8152, 8151, 7974, 7789, 7596, 7395, 7186, 6969, 6744, 6511, 6270, 6021, 5764, 5499, 5226, 4945, 4656, 4359, 4054, 3741, 3420, 3091, 2754, 2409, 2056, 1695, 1326, 949, 564, 171], [325, 714, 1095, 1468, 1833, 2190, 2539, 2880, 3213, 3538, 3855, 4164, 4465, 4758, 5043, 5320, 5589, 5850, 6103, 6348, 6585, 6814, 7035, 7248, 7453, 7650, 7839, 8020, 8019, 8018, 8017, 8016, 8015, 8014, 8013, 8012, 8011, 8010, 8009, 8008, 8007, 8006, 8005, 8004, 8003, 8002, 8001, 8000, 7999, 7998, 7997, 7996, 7995, 7994, 7993, 7992, 7991, 7990, 7989, 7988, 7987, 7986, 7985, 7984, 7983, 7982, 7981, 7980, 7979, 7978, 7977, 7976, 7975, 7790, 7597, 7396, 7187, 6970, 6745, 6512, 6271, 6022, 5765, 5500, 5227, 4946, 4657, 4360, 4055, 3742, 3421, 3092, 2755, 2410, 2057, 1696, 1327, 950, 565, 172], [324, 713, 1094, 1467, 1832, 2189, 2538, 2879, 3212, 3537, 3854, 4163, 4464, 4757, 5042, 5319, 5588, 5849, 6102, 6347, 6584, 6813, 7034, 7247, 7452, 7649, 7838, 7837, 7836, 7835, 7834, 7833, 7832, 7831, 7830, 7829, 7828, 7827, 7826, 7825, 7824, 7823, 7822, 7821, 7820, 7819, 7818, 7817, 7816, 7815, 7814, 7813, 7812, 7811, 7810, 7809, 7808, 7807, 7806, 7805, 7804, 7803, 7802, 7801, 7800, 7799, 7798, 7797, 7796, 7795, 7794, 7793, 7792, 7791, 7598, 7397, 7188, 6971, 6746, 6513, 6272, 6023, 5766, 5501, 5228, 4947, 4658, 4361, 4056, 3743, 3422, 3093, 2756, 2411, 2058, 1697, 1328, 951, 566, 173], [323, 712, 1093, 1466, 1831, 2188, 2537, 2878, 3211, 3536, 3853, 4162, 4463, 4756, 5041, 5318, 5587, 5848, 6101, 6346, 6583, 6812, 7033, 7246, 7451, 7648, 7647, 7646, 7645, 7644, 7643, 7642, 7641, 7640, 7639, 7638, 7637, 7636, 7635, 7634, 7633, 7632, 7631, 7630, 7629, 7628, 7627, 7626, 7625, 7624, 7623, 7622, 7621, 7620, 7619, 7618, 7617, 7616, 7615, 7614, 7613, 7612, 7611, 7610, 7609, 7608, 7607, 7606, 7605, 7604, 7603, 7602, 7601, 7600, 7599, 7398, 7189, 6972, 6747, 6514, 6273, 6024, 5767, 5502, 5229, 4948, 4659, 4362, 4057, 3744, 3423, 3094, 2757, 2412, 2059, 1698, 1329, 952, 567, 174], [322, 711, 1092, 1465, 1830, 2187, 2536, 2877, 3210, 3535, 3852, 4161, 4462, 4755, 5040, 5317, 5586, 5847, 6100, 6345, 6582, 6811, 7032, 7245, 7450, 7449, 7448, 7447, 7446, 7445, 7444, 7443, 7442, 7441, 7440, 7439, 7438, 7437, 7436, 7435, 7434, 7433, 7432, 7431, 7430, 7429, 7428, 7427, 7426, 7425, 7424, 7423, 7422, 7421, 7420, 7419, 7418, 7417, 7416, 7415, 7414, 7413, 7412, 7411, 7410, 7409, 7408, 7407, 7406, 7405, 7404, 7403, 7402, 7401, 7400, 7399, 7190, 6973, 6748, 6515, 6274, 6025, 5768, 5503, 5230, 4949, 4660, 4363, 4058, 3745, 3424, 3095, 2758, 2413, 2060, 1699, 1330, 953, 568, 175], [321, 710, 1091, 1464, 1829, 2186, 2535, 2876, 3209, 3534, 3851, 4160, 4461, 4754, 5039, 5316, 5585, 5846, 6099, 6344, 6581, 6810, 7031, 7244, 7243, 7242, 7241, 7240, 7239, 7238, 7237, 7236, 7235, 7234, 7233, 7232, 7231, 7230, 7229, 7228, 7227, 7226, 7225, 7224, 7223, 7222, 7221, 7220, 7219, 7218, 7217, 7216, 7215, 7214, 7213, 7212, 7211, 7210, 7209, 7208, 7207, 7206, 7205, 7204, 7203, 7202, 7201, 7200, 7199, 7198, 7197, 7196, 7195, 7194, 7193, 7192, 7191, 6974, 6749, 6516, 6275, 6026, 5769, 5504, 5231, 4950, 4661, 4364, 4059, 3746, 3425, 3096, 2759, 2414, 2061, 1700, 1331, 954, 569, 176], [320, 709, 1090, 1463, 1828, 2185, 2534, 2875, 3208, 3533, 3850, 4159, 4460, 4753, 5038, 5315, 5584, 5845, 6098, 6343, 6580, 6809, 7030, 7029, 7028, 7027, 7026, 7025, 7024, 7023, 7022, 7021, 7020, 7019, 7018, 7017, 7016, 7015, 7014, 7013, 7012, 7011, 7010, 7009, 7008, 7007, 7006, 7005, 7004, 7003, 7002, 7001, 7000, 6999, 6998, 6997, 6996, 6995, 6994, 6993, 6992, 6991, 6990, 6989, 6988, 6987, 6986, 6985, 6984, 6983, 6982, 6981, 6980, 6979, 6978, 6977, 6976, 6975, 6750, 6517, 6276, 6027, 5770, 5505, 5232, 4951, 4662, 4365, 4060, 3747, 3426, 3097, 2760, 2415, 2062, 1701, 1332, 955, 570, 177], [319, 708, 1089, 1462, 1827, 2184, 2533, 2874, 3207, 3532, 3849, 4158, 4459, 4752, 5037, 5314, 5583, 5844, 6097, 6342, 6579, 6808, 6807, 6806, 6805, 6804, 6803, 6802, 6801, 6800, 6799, 6798, 6797, 6796, 6795, 6794, 6793, 6792, 6791, 6790, 6789, 6788, 6787, 6786, 6785, 6784, 6783, 6782, 6781, 6780, 6779, 6778, 6777, 6776, 6775, 6774, 6773, 6772, 6771, 6770, 6769, 6768, 6767, 6766, 6765, 6764, 6763, 6762, 6761, 6760, 6759, 6758, 6757, 6756, 6755, 6754, 6753, 6752, 6751, 6518, 6277, 6028, 5771, 5506, 5233, 4952, 4663, 4366, 4061, 3748, 3427, 3098, 2761, 2416, 2063, 1702, 1333, 956, 571, 178], [318, 707, 1088, 1461, 1826, 2183, 2532, 2873, 3206, 3531, 3848, 4157, 4458, 4751, 5036, 5313, 5582, 5843, 6096, 6341, 6578, 6577, 6576, 6575, 6574, 6573, 6572, 6571, 6570, 6569, 6568, 6567, 6566, 6565, 6564, 6563, 6562, 6561, 6560, 6559, 6558, 6557, 6556, 6555, 6554, 6553, 6552, 6551, 6550, 6549, 6548, 6547, 6546, 6545, 6544, 6543, 6542, 6541, 6540, 6539, 6538, 6537, 6536, 6535, 6534, 6533, 6532, 6531, 6530, 6529, 6528, 6527, 6526, 6525, 6524, 6523, 6522, 6521, 6520, 6519, 6278, 6029, 5772, 5507, 5234, 4953, 4664, 4367, 4062, 3749, 3428, 3099, 2762, 2417, 2064, 1703, 1334, 957, 572, 179], [317, 706, 1087, 1460, 1825, 2182, 2531, 2872, 3205, 3530, 3847, 4156, 4457, 4750, 5035, 5312, 5581, 5842, 6095, 6340, 6339, 6338, 6337, 6336, 6335, 6334, 6333, 6332, 6331, 6330, 6329, 6328, 6327, 6326, 6325, 6324, 6323, 6322, 6321, 6320, 6319, 6318, 6317, 6316, 6315, 6314, 6313, 6312, 6311, 6310, 6309, 6308, 6307, 6306, 6305, 6304, 6303, 6302, 6301, 6300, 6299, 6298, 6297, 6296, 6295, 6294, 6293, 6292, 6291, 6290, 6289, 6288, 6287, 6286, 6285, 6284, 6283, 6282, 6281, 6280, 6279, 6030, 5773, 5508, 5235, 4954, 4665, 4368, 4063, 3750, 3429, 3100, 2763, 2418, 2065, 1704, 1335, 958, 573, 180], [316, 705, 1086, 1459, 1824, 2181, 2530, 2871, 3204, 3529, 3846, 4155, 4456, 4749, 5034, 5311, 5580, 5841, 6094, 6093, 6092, 6091, 6090, 6089, 6088, 6087, 6086, 6085, 6084, 6083, 6082, 6081, 6080, 6079, 6078, 6077, 6076, 6075, 6074, 6073, 6072, 6071, 6070, 6069, 6068, 6067, 6066, 6065, 6064, 6063, 6062, 6061, 6060, 6059, 6058, 6057, 6056, 6055, 6054, 6053, 6052, 6051, 6050, 6049, 6048, 6047, 6046, 6045, 6044, 6043, 6042, 6041, 6040, 6039, 6038, 6037, 6036, 6035, 6034, 6033, 6032, 6031, 5774, 5509, 5236, 4955, 4666, 4369, 4064, 3751, 3430, 3101, 2764, 2419, 2066, 1705, 1336, 959, 574, 181], [315, 704, 1085, 1458, 1823, 2180, 2529, 2870, 3203, 3528, 3845, 4154, 4455, 4748, 5033, 5310, 5579, 5840, 5839, 5838, 5837, 5836, 5835, 5834, 5833, 5832, 5831, 5830, 5829, 5828, 5827, 5826, 5825, 5824, 5823, 5822, 5821, 5820, 5819, 5818, 5817, 5816, 5815, 5814, 5813, 5812, 5811, 5810, 5809, 5808, 5807, 5806, 5805, 5804, 5803, 5802, 5801, 5800, 5799, 5798, 5797, 5796, 5795, 5794, 5793, 5792, 5791, 5790, 5789, 5788, 5787, 5786, 5785, 5784, 5783, 5782, 5781, 5780, 5779, 5778, 5777, 5776, 5775, 5510, 5237, 4956, 4667, 4370, 4065, 3752, 3431, 3102, 2765, 2420, 2067, 1706, 1337, 960, 575, 182], [314, 703, 1084, 1457, 1822, 2179, 2528, 2869, 3202, 3527, 3844, 4153, 4454, 4747, 5032, 5309, 5578, 5577, 5576, 5575, 5574, 5573, 5572, 5571, 5570, 5569, 5568, 5567, 5566, 5565, 5564, 5563, 5562, 5561, 5560, 5559, 5558, 5557, 5556, 5555, 5554, 5553, 5552, 5551, 5550, 5549, 5548, 5547, 5546, 5545, 5544, 5543, 5542, 5541, 5540, 5539, 5538, 5537, 5536, 5535, 5534, 5533, 5532, 5531, 5530, 5529, 5528, 5527, 5526, 5525, 5524, 5523, 5522, 5521, 5520, 5519, 5518, 5517, 5516, 5515, 5514, 5513, 5512, 5511, 5238, 4957, 4668, 4371, 4066, 3753, 3432, 3103, 2766, 2421, 2068, 1707, 1338, 961, 576, 183], [313, 702, 1083, 1456, 1821, 2178, 2527, 2868, 3201, 3526, 3843, 4152, 4453, 4746, 5031, 5308, 5307, 5306, 5305, 5304, 5303, 5302, 5301, 5300, 5299, 5298, 5297, 5296, 5295, 5294, 5293, 5292, 5291, 5290, 5289, 5288, 5287, 5286, 5285, 5284, 5283, 5282, 5281, 5280, 5279, 5278, 5277, 5276, 5275, 5274, 5273, 5272, 5271, 5270, 5269, 5268, 5267, 5266, 5265, 5264, 5263, 5262, 5261, 5260, 5259, 5258, 5257, 5256, 5255, 5254, 5253, 5252, 5251, 5250, 5249, 5248, 5247, 5246, 5245, 5244, 5243, 5242, 5241, 5240, 5239, 4958, 4669, 4372, 4067, 3754, 3433, 3104, 2767, 2422, 2069, 1708, 1339, 962, 577, 184], [312, 701, 1082, 1455, 1820, 2177, 2526, 2867, 3200, 3525, 3842, 4151, 4452, 4745, 5030, 5029, 5028, 5027, 5026, 5025, 5024, 5023, 5022, 5021, 5020, 5019, 5018, 5017, 5016, 5015, 5014, 5013, 5012, 5011, 5010, 5009, 5008, 5007, 5006, 5005, 5004, 5003, 5002, 5001, 5000, 4999, 4998, 4997, 4996, 4995, 4994, 4993, 4992, 4991, 4990, 4989, 4988, 4987, 4986, 4985, 4984, 4983, 4982, 4981, 4980, 4979, 4978, 4977, 4976, 4975, 4974, 4973, 4972, 4971, 4970, 4969, 4968, 4967, 4966, 4965, 4964, 4963, 4962, 4961, 4960, 4959, 4670, 4373, 4068, 3755, 3434, 3105, 2768, 2423, 2070, 1709, 1340, 963, 578, 185], [311, 700, 1081, 1454, 1819, 2176, 2525, 2866, 3199, 3524, 3841, 4150, 4451, 4744, 4743, 4742, 4741, 4740, 4739, 4738, 4737, 4736, 4735, 4734, 4733, 4732, 4731, 4730, 4729, 4728, 4727, 4726, 4725, 4724, 4723, 4722, 4721, 4720, 4719, 4718, 4717, 4716, 4715, 4714, 4713, 4712, 4711, 4710, 4709, 4708, 4707, 4706, 4705, 4704, 4703, 4702, 4701, 4700, 4699, 4698, 4697, 4696, 4695, 4694, 4693, 4692, 4691, 4690, 4689, 4688, 4687, 4686, 4685, 4684, 4683, 4682, 4681, 4680, 4679, 4678, 4677, 4676, 4675, 4674, 4673, 4672, 4671, 4374, 4069, 3756, 3435, 3106, 2769, 2424, 2071, 1710, 1341, 964, 579, 186], [310, 699, 1080, 1453, 1818, 2175, 2524, 2865, 3198, 3523, 3840, 4149, 4450, 4449, 4448, 4447, 4446, 4445, 4444, 4443, 4442, 4441, 4440, 4439, 4438, 4437, 4436, 4435, 4434, 4433, 4432, 4431, 4430, 4429, 4428, 4427, 4426, 4425, 4424, 4423, 4422, 4421, 4420, 4419, 4418, 4417, 4416, 4415, 4414, 4413, 4412, 4411, 4410, 4409, 4408, 4407, 4406, 4405, 4404, 4403, 4402, 4401, 4400, 4399, 4398, 4397, 4396, 4395, 4394, 4393, 4392, 4391, 4390, 4389, 4388, 4387, 4386, 4385, 4384, 4383, 4382, 4381, 4380, 4379, 4378, 4377, 4376, 4375, 4070, 3757, 3436, 3107, 2770, 2425, 2072, 1711, 1342, 965, 580, 187], [309, 698, 1079, 1452, 1817, 2174, 2523, 2864, 3197, 3522, 3839, 4148, 4147, 4146, 4145, 4144, 4143, 4142, 4141, 4140, 4139, 4138, 4137, 4136, 4135, 4134, 4133, 4132, 4131, 4130, 4129, 4128, 4127, 4126, 4125, 4124, 4123, 4122, 4121, 4120, 4119, 4118, 4117, 4116, 4115, 4114, 4113, 4112, 4111, 4110, 4109, 4108, 4107, 4106, 4105, 4104, 4103, 4102, 4101, 4100, 4099, 4098, 4097, 4096, 4095, 4094, 4093, 4092, 4091, 4090, 4089, 4088, 4087, 4086, 4085, 4084, 4083, 4082, 4081, 4080, 4079, 4078, 4077, 4076, 4075, 4074, 4073, 4072, 4071, 3758, 3437, 3108, 2771, 2426, 2073, 1712, 1343, 966, 581, 188], [308, 697, 1078, 1451, 1816, 2173, 2522, 2863, 3196, 3521, 3838, 3837, 3836, 3835, 3834, 3833, 3832, 3831, 3830, 3829, 3828, 3827, 3826, 3825, 3824, 3823, 3822, 3821, 3820, 3819, 3818, 3817, 3816, 3815, 3814, 3813, 3812, 3811, 3810, 3809, 3808, 3807, 3806, 3805, 3804, 3803, 3802, 3801, 3800, 3799, 3798, 3797, 3796, 3795, 3794, 3793, 3792, 3791, 3790, 3789, 3788, 3787, 3786, 3785, 3784, 3783, 3782, 3781, 3780, 3779, 3778, 3777, 3776, 3775, 3774, 3773, 3772, 3771, 3770, 3769, 3768, 3767, 3766, 3765, 3764, 3763, 3762, 3761, 3760, 3759, 3438, 3109, 2772, 2427, 2074, 1713, 1344, 967, 582, 189], [307, 696, 1077, 1450, 1815, 2172, 2521, 2862, 3195, 3520, 3519, 3518, 3517, 3516, 3515, 3514, 3513, 3512, 3511, 3510, 3509, 3508, 3507, 3506, 3505, 3504, 3503, 3502, 3501, 3500, 3499, 3498, 3497, 3496, 3495, 3494, 3493, 3492, 3491, 3490, 3489, 3488, 3487, 3486, 3485, 3484, 3483, 3482, 3481, 3480, 3479, 3478, 3477, 3476, 3475, 3474, 3473, 3472, 3471, 3470, 3469, 3468, 3467, 3466, 3465, 3464, 3463, 3462, 3461, 3460, 3459, 3458, 3457, 3456, 3455, 3454, 3453, 3452, 3451, 3450, 3449, 3448, 3447, 3446, 3445, 3444, 3443, 3442, 3441, 3440, 3439, 3110, 2773, 2428, 2075, 1714, 1345, 968, 583, 190], [306, 695, 1076, 1449, 1814, 2171, 2520, 2861, 3194, 3193, 3192, 3191, 3190, 3189, 3188, 3187, 3186, 3185, 3184, 3183, 3182, 3181, 3180, 3179, 3178, 3177, 3176, 3175, 3174, 3173, 3172, 3171, 3170, 3169, 3168, 3167, 3166, 3165, 3164, 3163, 3162, 3161, 3160, 3159, 3158, 3157, 3156, 3155, 3154, 3153, 3152, 3151, 3150, 3149, 3148, 3147, 3146, 3145, 3144, 3143, 3142, 3141, 3140, 3139, 3138, 3137, 3136, 3135, 3134, 3133, 3132, 3131, 3130, 3129, 3128, 3127, 3126, 3125, 3124, 3123, 3122, 3121, 3120, 3119, 3118, 3117, 3116, 3115, 3114, 3113, 3112, 3111, 2774, 2429, 2076, 1715, 1346, 969, 584, 191], [305, 694, 1075, 1448, 1813, 2170, 2519, 2860, 2859, 2858, 2857, 2856, 2855, 2854, 2853, 2852, 2851, 2850, 2849, 2848, 2847, 2846, 2845, 2844, 2843, 2842, 2841, 2840, 2839, 2838, 2837, 2836, 2835, 2834, 2833, 2832, 2831, 2830, 2829, 2828, 2827, 2826, 2825, 2824, 2823, 2822, 2821, 2820, 2819, 2818, 2817, 2816, 2815, 2814, 2813, 2812, 2811, 2810, 2809, 2808, 2807, 2806, 2805, 2804, 2803, 2802, 2801, 2800, 2799, 2798, 2797, 2796, 2795, 2794, 2793, 2792, 2791, 2790, 2789, 2788, 2787, 2786, 2785, 2784, 2783, 2782, 2781, 2780, 2779, 2778, 2777, 2776, 2775, 2430, 2077, 1716, 1347, 970, 585, 192], [304, 693, 1074, 1447, 1812, 2169, 2518, 2517, 2516, 2515, 2514, 2513, 2512, 2511, 2510, 2509, 2508, 2507, 2506, 2505, 2504, 2503, 2502, 2501, 2500, 2499, 2498, 2497, 2496, 2495, 2494, 2493, 2492, 2491, 2490, 2489, 2488, 2487, 2486, 2485, 2484, 2483, 2482, 2481, 2480, 2479, 2478, 2477, 2476, 2475, 2474, 2473, 2472, 2471, 2470, 2469, 2468, 2467, 2466, 2465, 2464, 2463, 2462, 2461, 2460, 2459, 2458, 2457, 2456, 2455, 2454, 2453, 2452, 2451, 2450, 2449, 2448, 2447, 2446, 2445, 2444, 2443, 2442, 2441, 2440, 2439, 2438, 2437, 2436, 2435, 2434, 2433, 2432, 2431, 2078, 1717, 1348, 971, 586, 193], [303, 692, 1073, 1446, 1811, 2168, 2167, 2166, 2165, 2164, 2163, 2162, 2161, 2160, 2159, 2158, 2157, 2156, 2155, 2154, 2153, 2152, 2151, 2150, 2149, 2148, 2147, 2146, 2145, 2144, 2143, 2142, 2141, 2140, 2139, 2138, 2137, 2136, 2135, 2134, 2133, 2132, 2131, 2130, 2129, 2128, 2127, 2126, 2125, 2124, 2123, 2122, 2121, 2120, 2119, 2118, 2117, 2116, 2115, 2114, 2113, 2112, 2111, 2110, 2109, 2108, 2107, 2106, 2105, 2104, 2103, 2102, 2101, 2100, 2099, 2098, 2097, 2096, 2095, 2094, 2093, 2092, 2091, 2090, 2089, 2088, 2087, 2086, 2085, 2084, 2083, 2082, 2081, 2080, 2079, 1718, 1349, 972, 587, 194], [302, 691, 1072, 1445, 1810, 1809, 1808, 1807, 1806, 1805, 1804, 1803, 1802, 1801, 1800, 1799, 1798, 1797, 1796, 1795, 1794, 1793, 1792, 1791, 1790, 1789, 1788, 1787, 1786, 1785, 1784, 1783, 1782, 1781, 1780, 1779, 1778, 1777, 1776, 1775, 1774, 1773, 1772, 1771, 1770, 1769, 1768, 1767, 1766, 1765, 1764, 1763, 1762, 1761, 1760, 1759, 1758, 1757, 1756, 1755, 1754, 1753, 1752, 1751, 1750, 1749, 1748, 1747, 1746, 1745, 1744, 1743, 1742, 1741, 1740, 1739, 1738, 1737, 1736, 1735, 1734, 1733, 1732, 1731, 1730, 1729, 1728, 1727, 1726, 1725, 1724, 1723, 1722, 1721, 1720, 1719, 1350, 973, 588, 195], [301, 690, 1071, 1444, 1443, 1442, 1441, 1440, 1439, 1438, 1437, 1436, 1435, 1434, 1433, 1432, 1431, 1430, 1429, 1428, 1427, 1426, 1425, 1424, 1423, 1422, 1421, 1420, 1419, 1418, 1417, 1416, 1415, 1414, 1413, 1412, 1411, 1410, 1409, 1408, 1407, 1406, 1405, 1404, 1403, 1402, 1401, 1400, 1399, 1398, 1397, 1396, 1395, 1394, 1393, 1392, 1391, 1390, 1389, 1388, 1387, 1386, 1385, 1384, 1383, 1382, 1381, 1380, 1379, 1378, 1377, 1376, 1375, 1374, 1373, 1372, 1371, 1370, 1369, 1368, 1367, 1366, 1365, 1364, 1363, 1362, 1361, 1360, 1359, 1358, 1357, 1356, 1355, 1354, 1353, 1352, 1351, 974, 589, 196], [300, 689, 1070, 1069, 1068, 1067, 1066, 1065, 1064, 1063, 1062, 1061, 1060, 1059, 1058, 1057, 1056, 1055, 1054, 1053, 1052, 1051, 1050, 1049, 1048, 1047, 1046, 1045, 1044, 1043, 1042, 1041, 1040, 1039, 1038, 1037, 1036, 1035, 1034, 1033, 1032, 1031, 1030, 1029, 1028, 1027, 1026, 1025, 1024, 1023, 1022, 1021, 1020, 1019, 1018, 1017, 1016, 1015, 1014, 1013, 1012, 1011, 1010, 1009, 1008, 1007, 1006, 1005, 1004, 1003, 1002, 1001, 1000, 999, 998, 997, 996, 995, 994, 993, 992, 991, 990, 989, 988, 987, 986, 985, 984, 983, 982, 981, 980, 979, 978, 977, 976, 975, 590, 197], [299, 688, 687, 686, 685, 684, 683, 682, 681, 680, 679, 678, 677, 676, 675, 674, 673, 672, 671, 670, 669, 668, 667, 666, 665, 664, 663, 662, 661, 660, 659, 658, 657, 656, 655, 654, 653, 652, 651, 650, 649, 648, 647, 646, 645, 644, 643, 642, 641, 640, 639, 638, 637, 636, 635, 634, 633, 632, 631, 630, 629, 628, 627, 626, 625, 624, 623, 622, 621, 620, 619, 618, 617, 616, 615, 614, 613, 612, 611, 610, 609, 608, 607, 606, 605, 604, 603, 602, 601, 600, 599, 598, 597, 596, 595, 594, 593, 592, 591, 198], [298, 297, 296, 295, 294, 293, 292, 291, 290, 289, 288, 287, 286, 285, 284, 283, 282, 281, 280, 279, 278, 277, 276, 275, 274, 273, 272, 271, 270, 269, 268, 267, 266, 265, 264, 263, 262, 261, 260, 259, 258, 257, 256, 255, 254, 253, 252, 251, 250, 249, 248, 247, 246, 245, 244, 243, 242, 241, 240, 239, 238, 237, 236, 235, 234, 233, 232, 231, 230, 229, 228, 227, 226, 225, 224, 223, 222, 221, 220, 219, 218, 217, 216, 215, 214, 213, 212, 211, 210, 209, 208, 207, 206, 205, 204, 203, 202, 201, 200, 199]]\n    assert candidate(4) == [[1, 2, 3, 4], [12, 13, 14, 5], [11, 16, 15, 6], [10, 9, 8, 7]]\n    assert candidate(5) == [[1, 2, 3, 4, 5], [16, 17, 18, 19, 6], [15, 24, 25, 20, 7], [14, 23, 22, 21, 8], [13, 12, 11, 10, 9]]\n    assert candidate(2) == [[1, 2], [4, 3]]\n    assert candidate(1) == [[1]]\n    assert candidate(10) == [[1, 2, 3, 4, 5, 6, 7, 8, 9, 10], [36, 37, 38, 39, 40, 41, 42, 43, 44, 11], [35, 64, 65, 66, 67, 68, 69, 70, 45, 12], [34, 63, 84, 85, 86, 87, 88, 71, 46, 13], [33, 62, 83, 96, 97, 98, 89, 72, 47, 14], [32, 61, 82, 95, 100, 99, 90, 73, 48, 15], [31, 60, 81, 94, 93, 92, 91, 74, 49, 16], [30, 59, 80, 79, 78, 77, 76, 75, 50, 17], [29, 58, 57, 56, 55, 54, 53, 52, 51, 18], [28, 27, 26, 25, 24, 23, 22, 21, 20, 19]]\n    assert candidate(20) == [[1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20], [76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 21], [75, 144, 145, 146, 147, 148, 149, 150, 151, 152, 153, 154, 155, 156, 157, 158, 159, 160, 95, 22], [74, 143, 204, 205, 206, 207, 208, 209, 210, 211, 212, 213, 214, 215, 216, 217, 218, 161, 96, 23], [73, 142, 203, 256, 257, 258, 259, 260, 261, 262, 263, 264, 265, 266, 267, 268, 219, 162, 97, 24], [72, 141, 202, 255, 300, 301, 302, 303, 304, 305, 306, 307, 308, 309, 310, 269, 220, 163, 98, 25], [71, 140, 201, 254, 299, 336, 337, 338, 339, 340, 341, 342, 343, 344, 311, 270, 221, 164, 99, 26], [70, 139, 200, 253, 298, 335, 364, 365, 366, 367, 368, 369, 370, 345, 312, 271, 222, 165, 100, 27], [69, 138, 199, 252, 297, 334, 363, 384, 385, 386, 387, 388, 371, 346, 313, 272, 223, 166, 101, 28], [68, 137, 198, 251, 296, 333, 362, 383, 396, 397, 398, 389, 372, 347, 314, 273, 224, 167, 102, 29], [67, 136, 197, 250, 295, 332, 361, 382, 395, 400, 399, 390, 373, 348, 315, 274, 225, 168, 103, 30], [66, 135, 196, 249, 294, 331, 360, 381, 394, 393, 392, 391, 374, 349, 316, 275, 226, 169, 104, 31], [65, 134, 195, 248, 293, 330, 359, 380, 379, 378, 377, 376, 375, 350, 317, 276, 227, 170, 105, 32], [64, 133, 194, 247, 292, 329, 358, 357, 356, 355, 354, 353, 352, 351, 318, 277, 228, 171, 106, 33], [63, 132, 193, 246, 291, 328, 327, 326, 325, 324, 323, 322, 321, 320, 319, 278, 229, 172, 107, 34], [62, 131, 192, 245, 290, 289, 288, 287, 286, 285, 284, 283, 282, 281, 280, 279, 230, 173, 108, 35], [61, 130, 191, 244, 243, 242, 241, 240, 239, 238, 237, 236, 235, 234, 233, 232, 231, 174, 109, 36], [60, 129, 190, 189, 188, 187, 186, 185, 184, 183, 182, 181, 180, 179, 178, 177, 176, 175, 110, 37], [59, 128, 127, 126, 125, 124, 123, 122, 121, 120, 119, 118, 117, 116, 115, 114, 113, 112, 111, 38], [58, 57, 56, 55, 54, 53, 52, 51, 50, 49, 48, 47, 46, 45, 44, 43, 42, 41, 40, 39]]\n    assert candidate(0) == []\n    assert candidate(50) == [[1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50], [196, 197, 198, 199, 200, 201, 202, 203, 204, 205, 206, 207, 208, 209, 210, 211, 212, 213, 214, 215, 216, 217, 218, 219, 220, 221, 222, 223, 224, 225, 226, 227, 228, 229, 230, 231, 232, 233, 234, 235, 236, 237, 238, 239, 240, 241, 242, 243, 244, 51], [195, 384, 385, 386, 387, 388, 389, 390, 391, 392, 393, 394, 395, 396, 397, 398, 399, 400, 401, 402, 403, 404, 405, 406, 407, 408, 409, 410, 411, 412, 413, 414, 415, 416, 417, 418, 419, 420, 421, 422, 423, 424, 425, 426, 427, 428, 429, 430, 245, 52], [194, 383, 564, 565, 566, 567, 568, 569, 570, 571, 572, 573, 574, 575, 576, 577, 578, 579, 580, 581, 582, 583, 584, 585, 586, 587, 588, 589, 590, 591, 592, 593, 594, 595, 596, 597, 598, 599, 600, 601, 602, 603, 604, 605, 606, 607, 608, 431, 246, 53], [193, 382, 563, 736, 737, 738, 739, 740, 741, 742, 743, 744, 745, 746, 747, 748, 749, 750, 751, 752, 753, 754, 755, 756, 757, 758, 759, 760, 761, 762, 763, 764, 765, 766, 767, 768, 769, 770, 771, 772, 773, 774, 775, 776, 777, 778, 609, 432, 247, 54], [192, 381, 562, 735, 900, 901, 902, 903, 904, 905, 906, 907, 908, 909, 910, 911, 912, 913, 914, 915, 916, 917, 918, 919, 920, 921, 922, 923, 924, 925, 926, 927, 928, 929, 930, 931, 932, 933, 934, 935, 936, 937, 938, 939, 940, 779, 610, 433, 248, 55], [191, 380, 561, 734, 899, 1056, 1057, 1058, 1059, 1060, 1061, 1062, 1063, 1064, 1065, 1066, 1067, 1068, 1069, 1070, 1071, 1072, 1073, 1074, 1075, 1076, 1077, 1078, 1079, 1080, 1081, 1082, 1083, 1084, 1085, 1086, 1087, 1088, 1089, 1090, 1091, 1092, 1093, 1094, 941, 780, 611, 434, 249, 56], [190, 379, 560, 733, 898, 1055, 1204, 1205, 1206, 1207, 1208, 1209, 1210, 1211, 1212, 1213, 1214, 1215, 1216, 1217, 1218, 1219, 1220, 1221, 1222, 1223, 1224, 1225, 1226, 1227, 1228, 1229, 1230, 1231, 1232, 1233, 1234, 1235, 1236, 1237, 1238, 1239, 1240, 1095, 942, 781, 612, 435, 250, 57], [189, 378, 559, 732, 897, 1054, 1203, 1344, 1345, 1346, 1347, 1348, 1349, 1350, 1351, 1352, 1353, 1354, 1355, 1356, 1357, 1358, 1359, 1360, 1361, 1362, 1363, 1364, 1365, 1366, 1367, 1368, 1369, 1370, 1371, 1372, 1373, 1374, 1375, 1376, 1377, 1378, 1241, 1096, 943, 782, 613, 436, 251, 58], [188, 377, 558, 731, 896, 1053, 1202, 1343, 1476, 1477, 1478, 1479, 1480, 1481, 1482, 1483, 1484, 1485, 1486, 1487, 1488, 1489, 1490, 1491, 1492, 1493, 1494, 1495, 1496, 1497, 1498, 1499, 1500, 1501, 1502, 1503, 1504, 1505, 1506, 1507, 1508, 1379, 1242, 1097, 944, 783, 614, 437, 252, 59], [187, 376, 557, 730, 895, 1052, 1201, 1342, 1475, 1600, 1601, 1602, 1603, 1604, 1605, 1606, 1607, 1608, 1609, 1610, 1611, 1612, 1613, 1614, 1615, 1616, 1617, 1618, 1619, 1620, 1621, 1622, 1623, 1624, 1625, 1626, 1627, 1628, 1629, 1630, 1509, 1380, 1243, 1098, 945, 784, 615, 438, 253, 60], [186, 375, 556, 729, 894, 1051, 1200, 1341, 1474, 1599, 1716, 1717, 1718, 1719, 1720, 1721, 1722, 1723, 1724, 1725, 1726, 1727, 1728, 1729, 1730, 1731, 1732, 1733, 1734, 1735, 1736, 1737, 1738, 1739, 1740, 1741, 1742, 1743, 1744, 1631, 1510, 1381, 1244, 1099, 946, 785, 616, 439, 254, 61], [185, 374, 555, 728, 893, 1050, 1199, 1340, 1473, 1598, 1715, 1824, 1825, 1826, 1827, 1828, 1829, 1830, 1831, 1832, 1833, 1834, 1835, 1836, 1837, 1838, 1839, 1840, 1841, 1842, 1843, 1844, 1845, 1846, 1847, 1848, 1849, 1850, 1745, 1632, 1511, 1382, 1245, 1100, 947, 786, 617, 440, 255, 62], [184, 373, 554, 727, 892, 1049, 1198, 1339, 1472, 1597, 1714, 1823, 1924, 1925, 1926, 1927, 1928, 1929, 1930, 1931, 1932, 1933, 1934, 1935, 1936, 1937, 1938, 1939, 1940, 1941, 1942, 1943, 1944, 1945, 1946, 1947, 1948, 1851, 1746, 1633, 1512, 1383, 1246, 1101, 948, 787, 618, 441, 256, 63], [183, 372, 553, 726, 891, 1048, 1197, 1338, 1471, 1596, 1713, 1822, 1923, 2016, 2017, 2018, 2019, 2020, 2021, 2022, 2023, 2024, 2025, 2026, 2027, 2028, 2029, 2030, 2031, 2032, 2033, 2034, 2035, 2036, 2037, 2038, 1949, 1852, 1747, 1634, 1513, 1384, 1247, 1102, 949, 788, 619, 442, 257, 64], [182, 371, 552, 725, 890, 1047, 1196, 1337, 1470, 1595, 1712, 1821, 1922, 2015, 2100, 2101, 2102, 2103, 2104, 2105, 2106, 2107, 2108, 2109, 2110, 2111, 2112, 2113, 2114, 2115, 2116, 2117, 2118, 2119, 2120, 2039, 1950, 1853, 1748, 1635, 1514, 1385, 1248, 1103, 950, 789, 620, 443, 258, 65], [181, 370, 551, 724, 889, 1046, 1195, 1336, 1469, 1594, 1711, 1820, 1921, 2014, 2099, 2176, 2177, 2178, 2179, 2180, 2181, 2182, 2183, 2184, 2185, 2186, 2187, 2188, 2189, 2190, 2191, 2192, 2193, 2194, 2121, 2040, 1951, 1854, 1749, 1636, 1515, 1386, 1249, 1104, 951, 790, 621, 444, 259, 66], [180, 369, 550, 723, 888, 1045, 1194, 1335, 1468, 1593, 1710, 1819, 1920, 2013, 2098, 2175, 2244, 2245, 2246, 2247, 2248, 2249, 2250, 2251, 2252, 2253, 2254, 2255, 2256, 2257, 2258, 2259, 2260, 2195, 2122, 2041, 1952, 1855, 1750, 1637, 1516, 1387, 1250, 1105, 952, 791, 622, 445, 260, 67], [179, 368, 549, 722, 887, 1044, 1193, 1334, 1467, 1592, 1709, 1818, 1919, 2012, 2097, 2174, 2243, 2304, 2305, 2306, 2307, 2308, 2309, 2310, 2311, 2312, 2313, 2314, 2315, 2316, 2317, 2318, 2261, 2196, 2123, 2042, 1953, 1856, 1751, 1638, 1517, 1388, 1251, 1106, 953, 792, 623, 446, 261, 68], [178, 367, 548, 721, 886, 1043, 1192, 1333, 1466, 1591, 1708, 1817, 1918, 2011, 2096, 2173, 2242, 2303, 2356, 2357, 2358, 2359, 2360, 2361, 2362, 2363, 2364, 2365, 2366, 2367, 2368, 2319, 2262, 2197, 2124, 2043, 1954, 1857, 1752, 1639, 1518, 1389, 1252, 1107, 954, 793, 624, 447, 262, 69], [177, 366, 547, 720, 885, 1042, 1191, 1332, 1465, 1590, 1707, 1816, 1917, 2010, 2095, 2172, 2241, 2302, 2355, 2400, 2401, 2402, 2403, 2404, 2405, 2406, 2407, 2408, 2409, 2410, 2369, 2320, 2263, 2198, 2125, 2044, 1955, 1858, 1753, 1640, 1519, 1390, 1253, 1108, 955, 794, 625, 448, 263, 70], [176, 365, 546, 719, 884, 1041, 1190, 1331, 1464, 1589, 1706, 1815, 1916, 2009, 2094, 2171, 2240, 2301, 2354, 2399, 2436, 2437, 2438, 2439, 2440, 2441, 2442, 2443, 2444, 2411, 2370, 2321, 2264, 2199, 2126, 2045, 1956, 1859, 1754, 1641, 1520, 1391, 1254, 1109, 956, 795, 626, 449, 264, 71], [175, 364, 545, 718, 883, 1040, 1189, 1330, 1463, 1588, 1705, 1814, 1915, 2008, 2093, 2170, 2239, 2300, 2353, 2398, 2435, 2464, 2465, 2466, 2467, 2468, 2469, 2470, 2445, 2412, 2371, 2322, 2265, 2200, 2127, 2046, 1957, 1860, 1755, 1642, 1521, 1392, 1255, 1110, 957, 796, 627, 450, 265, 72], [174, 363, 544, 717, 882, 1039, 1188, 1329, 1462, 1587, 1704, 1813, 1914, 2007, 2092, 2169, 2238, 2299, 2352, 2397, 2434, 2463, 2484, 2485, 2486, 2487, 2488, 2471, 2446, 2413, 2372, 2323, 2266, 2201, 2128, 2047, 1958, 1861, 1756, 1643, 1522, 1393, 1256, 1111, 958, 797, 628, 451, 266, 73], [173, 362, 543, 716, 881, 1038, 1187, 1328, 1461, 1586, 1703, 1812, 1913, 2006, 2091, 2168, 2237, 2298, 2351, 2396, 2433, 2462, 2483, 2496, 2497, 2498, 2489, 2472, 2447, 2414, 2373, 2324, 2267, 2202, 2129, 2048, 1959, 1862, 1757, 1644, 1523, 1394, 1257, 1112, 959, 798, 629, 452, 267, 74], [172, 361, 542, 715, 880, 1037, 1186, 1327, 1460, 1585, 1702, 1811, 1912, 2005, 2090, 2167, 2236, 2297, 2350, 2395, 2432, 2461, 2482, 2495, 2500, 2499, 2490, 2473, 2448, 2415, 2374, 2325, 2268, 2203, 2130, 2049, 1960, 1863, 1758, 1645, 1524, 1395, 1258, 1113, 960, 799, 630, 453, 268, 75], [171, 360, 541, 714, 879, 1036, 1185, 1326, 1459, 1584, 1701, 1810, 1911, 2004, 2089, 2166, 2235, 2296, 2349, 2394, 2431, 2460, 2481, 2494, 2493, 2492, 2491, 2474, 2449, 2416, 2375, 2326, 2269, 2204, 2131, 2050, 1961, 1864, 1759, 1646, 1525, 1396, 1259, 1114, 961, 800, 631, 454, 269, 76], [170, 359, 540, 713, 878, 1035, 1184, 1325, 1458, 1583, 1700, 1809, 1910, 2003, 2088, 2165, 2234, 2295, 2348, 2393, 2430, 2459, 2480, 2479, 2478, 2477, 2476, 2475, 2450, 2417, 2376, 2327, 2270, 2205, 2132, 2051, 1962, 1865, 1760, 1647, 1526, 1397, 1260, 1115, 962, 801, 632, 455, 270, 77], [169, 358, 539, 712, 877, 1034, 1183, 1324, 1457, 1582, 1699, 1808, 1909, 2002, 2087, 2164, 2233, 2294, 2347, 2392, 2429, 2458, 2457, 2456, 2455, 2454, 2453, 2452, 2451, 2418, 2377, 2328, 2271, 2206, 2133, 2052, 1963, 1866, 1761, 1648, 1527, 1398, 1261, 1116, 963, 802, 633, 456, 271, 78], [168, 357, 538, 711, 876, 1033, 1182, 1323, 1456, 1581, 1698, 1807, 1908, 2001, 2086, 2163, 2232, 2293, 2346, 2391, 2428, 2427, 2426, 2425, 2424, 2423, 2422, 2421, 2420, 2419, 2378, 2329, 2272, 2207, 2134, 2053, 1964, 1867, 1762, 1649, 1528, 1399, 1262, 1117, 964, 803, 634, 457, 272, 79], [167, 356, 537, 710, 875, 1032, 1181, 1322, 1455, 1580, 1697, 1806, 1907, 2000, 2085, 2162, 2231, 2292, 2345, 2390, 2389, 2388, 2387, 2386, 2385, 2384, 2383, 2382, 2381, 2380, 2379, 2330, 2273, 2208, 2135, 2054, 1965, 1868, 1763, 1650, 1529, 1400, 1263, 1118, 965, 804, 635, 458, 273, 80], [166, 355, 536, 709, 874, 1031, 1180, 1321, 1454, 1579, 1696, 1805, 1906, 1999, 2084, 2161, 2230, 2291, 2344, 2343, 2342, 2341, 2340, 2339, 2338, 2337, 2336, 2335, 2334, 2333, 2332, 2331, 2274, 2209, 2136, 2055, 1966, 1869, 1764, 1651, 1530, 1401, 1264, 1119, 966, 805, 636, 459, 274, 81], [165, 354, 535, 708, 873, 1030, 1179, 1320, 1453, 1578, 1695, 1804, 1905, 1998, 2083, 2160, 2229, 2290, 2289, 2288, 2287, 2286, 2285, 2284, 2283, 2282, 2281, 2280, 2279, 2278, 2277, 2276, 2275, 2210, 2137, 2056, 1967, 1870, 1765, 1652, 1531, 1402, 1265, 1120, 967, 806, 637, 460, 275, 82], [164, 353, 534, 707, 872, 1029, 1178, 1319, 1452, 1577, 1694, 1803, 1904, 1997, 2082, 2159, 2228, 2227, 2226, 2225, 2224, 2223, 2222, 2221, 2220, 2219, 2218, 2217, 2216, 2215, 2214, 2213, 2212, 2211, 2138, 2057, 1968, 1871, 1766, 1653, 1532, 1403, 1266, 1121, 968, 807, 638, 461, 276, 83], [163, 352, 533, 706, 871, 1028, 1177, 1318, 1451, 1576, 1693, 1802, 1903, 1996, 2081, 2158, 2157, 2156, 2155, 2154, 2153, 2152, 2151, 2150, 2149, 2148, 2147, 2146, 2145, 2144, 2143, 2142, 2141, 2140, 2139, 2058, 1969, 1872, 1767, 1654, 1533, 1404, 1267, 1122, 969, 808, 639, 462, 277, 84], [162, 351, 532, 705, 870, 1027, 1176, 1317, 1450, 1575, 1692, 1801, 1902, 1995, 2080, 2079, 2078, 2077, 2076, 2075, 2074, 2073, 2072, 2071, 2070, 2069, 2068, 2067, 2066, 2065, 2064, 2063, 2062, 2061, 2060, 2059, 1970, 1873, 1768, 1655, 1534, 1405, 1268, 1123, 970, 809, 640, 463, 278, 85], [161, 350, 531, 704, 869, 1026, 1175, 1316, 1449, 1574, 1691, 1800, 1901, 1994, 1993, 1992, 1991, 1990, 1989, 1988, 1987, 1986, 1985, 1984, 1983, 1982, 1981, 1980, 1979, 1978, 1977, 1976, 1975, 1974, 1973, 1972, 1971, 1874, 1769, 1656, 1535, 1406, 1269, 1124, 971, 810, 641, 464, 279, 86], [160, 349, 530, 703, 868, 1025, 1174, 1315, 1448, 1573, 1690, 1799, 1900, 1899, 1898, 1897, 1896, 1895, 1894, 1893, 1892, 1891, 1890, 1889, 1888, 1887, 1886, 1885, 1884, 1883, 1882, 1881, 1880, 1879, 1878, 1877, 1876, 1875, 1770, 1657, 1536, 1407, 1270, 1125, 972, 811, 642, 465, 280, 87], [159, 348, 529, 702, 867, 1024, 1173, 1314, 1447, 1572, 1689, 1798, 1797, 1796, 1795, 1794, 1793, 1792, 1791, 1790, 1789, 1788, 1787, 1786, 1785, 1784, 1783, 1782, 1781, 1780, 1779, 1778, 1777, 1776, 1775, 1774, 1773, 1772, 1771, 1658, 1537, 1408, 1271, 1126, 973, 812, 643, 466, 281, 88], [158, 347, 528, 701, 866, 1023, 1172, 1313, 1446, 1571, 1688, 1687, 1686, 1685, 1684, 1683, 1682, 1681, 1680, 1679, 1678, 1677, 1676, 1675, 1674, 1673, 1672, 1671, 1670, 1669, 1668, 1667, 1666, 1665, 1664, 1663, 1662, 1661, 1660, 1659, 1538, 1409, 1272, 1127, 974, 813, 644, 467, 282, 89], [157, 346, 527, 700, 865, 1022, 1171, 1312, 1445, 1570, 1569, 1568, 1567, 1566, 1565, 1564, 1563, 1562, 1561, 1560, 1559, 1558, 1557, 1556, 1555, 1554, 1553, 1552, 1551, 1550, 1549, 1548, 1547, 1546, 1545, 1544, 1543, 1542, 1541, 1540, 1539, 1410, 1273, 1128, 975, 814, 645, 468, 283, 90], [156, 345, 526, 699, 864, 1021, 1170, 1311, 1444, 1443, 1442, 1441, 1440, 1439, 1438, 1437, 1436, 1435, 1434, 1433, 1432, 1431, 1430, 1429, 1428, 1427, 1426, 1425, 1424, 1423, 1422, 1421, 1420, 1419, 1418, 1417, 1416, 1415, 1414, 1413, 1412, 1411, 1274, 1129, 976, 815, 646, 469, 284, 91], [155, 344, 525, 698, 863, 1020, 1169, 1310, 1309, 1308, 1307, 1306, 1305, 1304, 1303, 1302, 1301, 1300, 1299, 1298, 1297, 1296, 1295, 1294, 1293, 1292, 1291, 1290, 1289, 1288, 1287, 1286, 1285, 1284, 1283, 1282, 1281, 1280, 1279, 1278, 1277, 1276, 1275, 1130, 977, 816, 647, 470, 285, 92], [154, 343, 524, 697, 862, 1019, 1168, 1167, 1166, 1165, 1164, 1163, 1162, 1161, 1160, 1159, 1158, 1157, 1156, 1155, 1154, 1153, 1152, 1151, 1150, 1149, 1148, 1147, 1146, 1145, 1144, 1143, 1142, 1141, 1140, 1139, 1138, 1137, 1136, 1135, 1134, 1133, 1132, 1131, 978, 817, 648, 471, 286, 93], [153, 342, 523, 696, 861, 1018, 1017, 1016, 1015, 1014, 1013, 1012, 1011, 1010, 1009, 1008, 1007, 1006, 1005, 1004, 1003, 1002, 1001, 1000, 999, 998, 997, 996, 995, 994, 993, 992, 991, 990, 989, 988, 987, 986, 985, 984, 983, 982, 981, 980, 979, 818, 649, 472, 287, 94], [152, 341, 522, 695, 860, 859, 858, 857, 856, 855, 854, 853, 852, 851, 850, 849, 848, 847, 846, 845, 844, 843, 842, 841, 840, 839, 838, 837, 836, 835, 834, 833, 832, 831, 830, 829, 828, 827, 826, 825, 824, 823, 822, 821, 820, 819, 650, 473, 288, 95], [151, 340, 521, 694, 693, 692, 691, 690, 689, 688, 687, 686, 685, 684, 683, 682, 681, 680, 679, 678, 677, 676, 675, 674, 673, 672, 671, 670, 669, 668, 667, 666, 665, 664, 663, 662, 661, 660, 659, 658, 657, 656, 655, 654, 653, 652, 651, 474, 289, 96], [150, 339, 520, 519, 518, 517, 516, 515, 514, 513, 512, 511, 510, 509, 508, 507, 506, 505, 504, 503, 502, 501, 500, 499, 498, 497, 496, 495, 494, 493, 492, 491, 490, 489, 488, 487, 486, 485, 484, 483, 482, 481, 480, 479, 478, 477, 476, 475, 290, 97], [149, 338, 337, 336, 335, 334, 333, 332, 331, 330, 329, 328, 327, 326, 325, 324, 323, 322, 321, 320, 319, 318, 317, 316, 315, 314, 313, 312, 311, 310, 309, 308, 307, 306, 305, 304, 303, 302, 301, 300, 299, 298, 297, 296, 295, 294, 293, 292, 291, 98], [148, 147, 146, 145, 144, 143, 142, 141, 140, 139, 138, 137, 136, 135, 134, 133, 132, 131, 130, 129, 128, 127, 126, 125, 124, 123, 122, 121, 120, 119, 118, 117, 116, 115, 114, 113, 112, 111, 110, 109, 108, 107, 106, 105, 104, 103, 102, 101, 100, 99]]\n    assert candidate(3) == [[1, 2, 3], [8, 9, 4], [7, 6, 5]]\n", "language": "python"}
{"task_id": "revision1a_problem268", "prompt": "from typing import List, Tuple\n\ndef optimize_delivery(n: int, packages: List[Tuple[int, int, int]]) -> List[int]:\n    \"\"\"\n    As a delivery company manager, you need to optimize the delivery route for your drivers.\n    You are given N packages with their weight, delivery time window, and profit.\n    Each package takes 1 hour to deliver, and only one package can be delivered at a time.\n    Your task is to find the sequence of deliveries that will maximize the company's profit.\n    \n    Take input from the user for the number of packages and their details:\n    (delivery window end time, weight, profit)\n    \n    Return a list containing the maximum profit and the number of packages delivered.\n    \n    Example:\n    Input: 5, [(3, 30, 400), (1, 25, 300), (2, 35, 450), (4, 20, 380), (3, 15, 200)]\n    Output: [1230, 4]\n    \n    Explanation: The optimal sequence is to deliver packages 2, 3, 1, and 4,\n    resulting in a total profit of 300 + 450 + 400 + 380 = 1230, delivering 4 packages.\n    \"\"\"\n", "entry_point": "optimize_delivery", "solution": "    # Sort packages based on delivery window end time\n    packages.sort(key=lambda x: x[0])\n    \n    # Initialize dynamic programming table\n    dp = [0] * (n + 1)\n    \n    def binary_search(end_time, start, end):\n        while start < end:\n            mid = (start + end) // 2\n            if packages[mid][0] <= end_time:\n                start = mid + 1\n            else:\n                end = mid\n        return start\n\n    # Fill the dp table\n    for i in range(1, n + 1):\n        current_profit = packages[i-1][2]\n        prev_compatible = binary_search(i - 1, 0, i - 1)\n        dp[i] = max(dp[i-1], current_profit + dp[prev_compatible])\n    \n    # Backtrack to find the number of packages delivered\n    max_profit = dp[n]\n    count = 0\n    i = n\n    while i > 0:\n        if i == 0 or dp[i] != dp[i-1]:\n            count += 1\n            i = binary_search(i - 1, 0, i - 1)\n        else:\n            i -= 1\n    \n    return [max_profit, count]\n", "test": "def check(candidate):\n    assert candidate(4, [(4, 10, 100), (3, 20, 200), (2, 30, 300), (1, 40, 400)]) == [1000, 4]\n    assert candidate(5, [(3, 30, 400), (1, 25, 300), (2, 35, 450), (4, 20, 380), (3, 15, 200)]) == [1730, 5]\n    assert candidate(6, [(1, 5, 50), (2, 10, 100), (3, 15, 150), (4, 20, 200), (5, 25, 250), (6, 30, 300)]) == [1050, 6]\n    assert candidate(4, [(2, 5, 200), (1, 10, 100), (3, 15, 300), (4, 20, 400)]) == [1000, 4]\n    assert candidate(7, [(1, 10, 100), (2, 20, 200), (3, 30, 300), (4, 40, 400), (5, 50, 500), (6, 60, 600), (7, 70, 700)]) == [2800, 7]\n    assert candidate(1, [(1, 100, 1000)]) == [1000, 1]\n    assert candidate(3, [(1, 10, 100), (2, 20, 200), (3, 30, 300)]) == [600, 3]\n    assert candidate(5, [(5, 10, 100), (4, 20, 200), (3, 30, 300), (2, 40, 400), (1, 50, 500)]) == [1500, 5]\n    assert candidate(3, [(3, 30, 300), (2, 20, 200), (1, 10, 100)]) == [600, 3]\n    assert candidate(2, [(1, 50, 500), (1, 60, 600)]) == [1100, 2]\n", "language": "python"}
{"task_id": "revision1a_problem252", "prompt": "from typing import List\n\ndef optimize_delivery_route(locations: List[List[int]], fuel_capacity: int) -> List[int]:\n    \"\"\"\n    You are a logistics manager for a delivery company. You need to optimize the delivery route for a truck\n    given a list of delivery locations and the truck's fuel capacity.\n\n    Each location is represented by a list [x, y, fuel_cost], where x and y are coordinates,\n    and fuel_cost is the amount of fuel needed to reach this location from the previous one.\n\n    Your task is to find the optimal route that visits the maximum number of locations before running out of fuel.\n    The truck starts with a full tank at the depot [0, 0].\n\n    Return a list of indices representing the optimal route, including the starting point (0).\n\n    If multiple routes visit the same number of locations, return the one with the least fuel consumption.\n\n    Take the list of locations and fuel capacity as input from the user and print the optimal route.\n\n    Example 1:\n    Input: [[0, 0, 0], [1, 1, 10], [2, 2, 15], [3, 3, 25]], 30\n    Output: [0, 1, 2]\n\n    Example 2:\n    Input: [[0, 0, 0], [2, 2, 15], [5, 5, 35], [10, 10, 20]], 50\n    Output: [0, 1, 3]\n    \"\"\"\n", "entry_point": "optimize_delivery_route", "solution": "    def dfs(current, fuel_left, visited):\n        nonlocal best_route, max_locations, min_fuel_consumption\n\n        if len(visited) > max_locations or (len(visited) == max_locations and fuel_capacity - fuel_left < min_fuel_consumption):\n            best_route = visited[:]\n            max_locations = len(visited)\n            min_fuel_consumption = fuel_capacity - fuel_left\n\n        for next_location in range(1, len(locations)):\n            if next_location not in visited:\n                fuel_cost = locations[next_location][2]\n                if fuel_left >= fuel_cost:\n                    visited.append(next_location)\n                    dfs(next_location, fuel_left - fuel_cost, visited)\n                    visited.pop()\n\n    best_route = [0]\n    max_locations = 1\n    min_fuel_consumption = 0\n\n    dfs(0, fuel_capacity, [0])\n    return best_route\n", "test": "def check(candidate):\n    assert candidate([[0, 0, 0], [10, 10, 50], [20, 20, 100], [30, 30, 150]], 200) == [0, 1, 2]\n    assert candidate([[0, 0, 0], [1, 1, 1], [2, 2, 2], [3, 3, 3], [4, 4, 4]], 10) == [0, 1, 2, 3, 4]\n    assert candidate([[0, 0, 0], [5, 5, 25], [10, 10, 50], [15, 15, 75]], 100) == [0, 1, 2]\n    assert candidate([[0, 0, 0], [1, 1, 10], [2, 2, 15], [3, 3, 25]], 30) == [0, 1, 2]\n    assert candidate([[0, 0, 0], [2, 2, 15], [5, 5, 35], [10, 10, 20]], 50) == [0, 1, 3]\n    assert candidate([[0, 0, 0], [1, 1, 10], [2, 2, 20], [3, 3, 30]], 40) == [0, 1, 2]\n    assert candidate([[0, 0, 0], [1, 1, 5], [2, 2, 10], [3, 3, 15], [4, 4, 20]], 25) == [0, 1, 2]\n    assert candidate([[0, 0, 0], [1, 1, 5], [2, 2, 5], [3, 3, 5], [4, 4, 5]], 19) == [0, 1, 2, 3]\n    assert candidate([[0, 0, 0], [1, 1, 10], [2, 2, 10], [3, 3, 10], [4, 4, 10]], 35) == [0, 1, 2, 3]\n    assert candidate([[0, 0, 0], [1, 0, 5], [0, 1, 5], [-1, 0, 5], [0, -1, 5]], 15) == [0, 1, 2, 3]\n", "language": "python"}
{"task_id": "revision1a_problem204", "prompt": "from collections import Counter, deque\nfrom collections import Counter\nfrom typing import List\n\ndef schedule_tasks(tasks: List[int], cooldown: int) -> int:\n    \"\"\"\n    You are designing a task scheduler for a computer system. The system has a list of tasks to execute, \n    represented by integers (task types). After executing a task, there must be a cooldown period \n    before the same task type can be executed again.\n\n    Given a list of tasks and a cooldown period, determine the minimum number of time units needed \n    to execute all tasks.\n\n    Rules:\n    1. Each task takes 1 time unit to execute.\n    2. After executing a task of a certain type, you must wait for 'cooldown' time units before executing another task of the same type.\n    3. Different types of tasks can be executed without waiting.\n    4. The order of task execution can be changed to minimize the total time.\n\n    Take the list of tasks and cooldown period as input from the user and return the minimum number of time units needed.\n\n    Example:\n    Input: [1,1,2,1], 2\n    Output: 7\n    Explanation: Execute task 1, wait 2 units, execute task 2, wait 1 unit, execute task 1, wait 2 units, execute task 1.\n\n    Input: [1,2,3,1,2,3], 3\n    Output: 7\n    Explanation: Execute tasks in the order 1,2,3,1,2,3 with no waiting time between different task types.\n    \"\"\"\n", "entry_point": "schedule_tasks", "solution": "    task_counts = Counter(tasks)\n    max_count = max(task_counts.values())\n    max_count_tasks = sum(1 for count in task_counts.values() if count == max_count)\n    \n    min_time = max((max_count - 1) * (cooldown + 1) + max_count_tasks, len(tasks))\n    \n    return min_time\n", "test": "def check(candidate):\n    assert candidate([1,1,2,1], 2) == 7\n    assert candidate([1,2,1,2,1,2], 1) == 6\n    assert candidate([1,1,1,2,2,2], 2) == 8\n    assert candidate([1], 5) == 1\n    assert candidate([1,2,3,4,5,1,2,3,4,5], 4) == 10\n    assert candidate([1,2,3,4,1,2,3,4], 3) == 8\n    assert candidate([1,1,1,1,1,1,1,1,1,1], 9) == 91\n    assert candidate([1,1,1,1,1], 4) == 21\n    assert candidate([1,2,3,1,2,3], 3) == 7\n    assert candidate([1,2,3,4,5], 0) == 5\n", "language": "python"}
{"task_id": "revision1a_problem694", "prompt": "from typing import List, Dict\n\ndef optimize_delivery_route(packages: List[Dict[str, float]], max_weight: float) -> List[List[str]]:\n    \"\"\"\n    I'm a delivery driver for an e-commerce company. Each day, I receive a list of packages to deliver, \n    each with a weight and destination address. My truck has a maximum weight capacity, and I want to optimize \n    my route to make as few trips as possible while delivering all packages.\n\n    Take input from the user in the form of a list of dictionaries, where each dictionary represents a package \n    with 'weight' and 'address' keys, and a float representing the maximum weight capacity of the truck. \n    Return a list of lists, where each inner list represents a trip and contains the addresses for that trip.\n\n    Use a greedy algorithm to solve this problem, always choosing the heaviest package that can fit in the \n    remaining capacity for each trip.\n\n    Example:\n    Input: \n    packages = [\n        {'weight': 10.5, 'address': '123 Main St'},\n        {'weight': 5.2, 'address': '456 Elm St'},\n        {'weight': 8.7, 'address': '789 Oak St'},\n        {'weight': 3.1, 'address': '321 Pine St'}\n    ]\n    max_weight = 15.0\n\n    Output: [\n        ['123 Main St', '456 Elm St'],\n        ['789 Oak St', '321 Pine St']\n    ]\n    \"\"\"\n", "entry_point": "optimize_delivery_route", "solution": "    # Sort packages by weight in descending order\n    sorted_packages = sorted(packages, key=lambda x: x['weight'], reverse=True)\n    \n    trips = []\n    current_trip = []\n    current_weight = 0\n    \n    while sorted_packages:\n        for package in sorted_packages[:]:\n            if current_weight + package['weight'] <= max_weight:\n                current_trip.append(package['address'])\n                current_weight += package['weight']\n                sorted_packages.remove(package)\n        \n        if current_trip:\n            trips.append(current_trip)\n            current_trip = []\n            current_weight = 0\n    \n    return trips\n", "test": "def check(candidate):\n    assert candidate([{'weight': 5.5, 'address': 'A'}, {'weight': 5.5, 'address': 'B'}], 11.0) == [['A', 'B']]\n    assert candidate([{'weight': 100.0, 'address': 'Heavy'}], 100.0) == [['Heavy']]\n    assert candidate([{'weight': 10.0, 'address': 'A'}, {'weight': 10.0, 'address': 'B'}, {'weight': 10.0, 'address': 'C'}], 10.0) == [['A'], ['B'], ['C']]\n    assert candidate([{'weight': 1.0, 'address': 'A'}, {'weight': 1.0, 'address': 'B'}, {'weight': 1.0, 'address': 'C'}, {'weight': 1.0, 'address': 'D'}], 2.0) == [['A', 'B'], ['C', 'D']]\n    assert candidate([{'weight': 1.0, 'address': 'A'}, {'weight': 2.0, 'address': 'B'}, {'weight': 3.0, 'address': 'C'}, {'weight': 4.0, 'address': 'D'}, {'weight': 5.0, 'address': 'E'}], 15.0) == [['E', 'D', 'C', 'B', 'A']]\n    assert candidate([{'weight': 0.1, 'address': 'Tiny'}, {'weight': 0.2, 'address': 'Small'}, {'weight': 0.3, 'address': 'Light'}], 1.0) == [['Light', 'Small', 'Tiny']]\n    assert candidate([{'weight': 1.0, 'address': 'X'}, {'weight': 2.0, 'address': 'Y'}, {'weight': 3.0, 'address': 'Z'}], 6.0) == [['Z', 'Y', 'X']]\n    assert candidate([{'weight': 10.5, 'address': '123 Main St'}, {'weight': 5.2, 'address': '456 Elm St'}, {'weight': 8.7, 'address': '789 Oak St'}, {'weight': 3.1, 'address': '321 Pine St'}], 15.0) == [['123 Main St', '321 Pine St'], ['789 Oak St', '456 Elm St']]\n    assert candidate([{'weight': 5.0, 'address': 'A'}, {'weight': 5.0, 'address': 'B'}, {'weight': 5.0, 'address': 'C'}], 10.0) == [['A', 'B'], ['C']]\n", "language": "python"}
{"task_id": "revision1a_problem393", "prompt": "from typing import List\n\ndef optimize_delivery_route(packages: List[int], max_weight: int) -> int:\n    \"\"\"\n    A delivery driver needs to deliver packages to a neighborhood. Each house needs a package of a specific weight.\n    The driver's truck can only carry a certain maximum weight per trip.\n    Your task is to determine the minimum number of trips the driver needs to make to deliver all packages.\n\n    Take input from the user for the list of package weights and the maximum weight the truck can carry.\n    Return the minimum number of trips required.\n\n    Use dynamic programming to solve this problem efficiently.\n\n    Example:\n    Input: packages = [2, 3, 4, 5, 6], max_weight = 10\n    Output: 3\n    Input: packages = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10], max_weight = 15\n    Output: 5\n    \"\"\"\n", "entry_point": "optimize_delivery_route", "solution": "    n = len(packages)\n    dp = [float('inf')] * (max_weight + 1)\n    dp[0] = 0\n\n    for i in range(1, max_weight + 1):\n        for package in packages:\n            if package <= i:\n                dp[i] = min(dp[i], dp[i - package] + 1)\n\n    total_weight = sum(packages)\n    trips = 0\n    while total_weight > 0:\n        trips += 1\n        total_weight -= min(total_weight, max_weight)\n\n    return trips\n\n", "test": "def check(candidate):\n    assert candidate([1, 2, 3, 4, 5, 6, 7, 8, 9, 10], 15) == 4\n    assert candidate([10, 20, 30, 40, 50], 100) == 2\n    assert candidate([1, 2, 3, 4, 5], 5) == 3\n    assert candidate([1, 2, 3, 4, 5], 10) == 2\n    assert candidate([100], 100) == 1\n    assert candidate([2, 4, 6, 8, 10], 12) == 3\n    assert candidate([5, 5, 5, 5, 5], 15) == 2\n    assert candidate([1, 3, 5, 7, 9], 10) == 3\n    assert candidate([1, 1, 1, 1, 1], 5) == 1\n    assert candidate([7, 7, 7, 7, 7], 14) == 3\n", "language": "python"}
{"task_id": "revision1a_problem335", "prompt": "def calculate_tax(income: float, tax_brackets: list) -> float:\n    \"\"\"\n    Calculate the total tax owed based on a progressive tax system.\n\n    In many countries, tax systems are structured in brackets where different portions of income are taxed at increasing rates. Your task is to implement this system.\n\n    The function takes two parameters:\n    1. income: The total taxable income\n    2. tax_brackets: A list of tuples, where each tuple contains two elements:\n       - The upper limit of the bracket (the last bracket should have float('inf') as the limit)\n       - The tax rate for that bracket (as a decimal, e.g., 0.1 for 10%)\n\n    The function should return the total tax owed.\n\n    Use a for loop to iterate through the tax brackets.\n\n    Example:\n    Input: income = 50000, tax_brackets = [(10000, 0.1), (30000, 0.15), (float('inf'), 0.25)]\n    Output: 8500.0\n\n    Explanation:\n    - First 10000 taxed at 10%: 1000\n    - Next 20000 taxed at 15%: 3000\n    - Remaining 20000 taxed at 25%: 5000\n    - Total tax: 1000 + 3000 + 5000 = 9000\n    \"\"\"\n", "entry_point": "calculate_tax", "solution": "    total_tax = 0\n    previous_limit = 0\n\n    for bracket, rate in tax_brackets:\n        if income > previous_limit:\n            taxable_amount = min(income - previous_limit, bracket - previous_limit)\n            total_tax += taxable_amount * rate\n            previous_limit = bracket\n\n        if income <= bracket:\n            break\n\n    return total_tax\n", "test": "def check(candidate):\n    assert candidate(500, [(1000, 0.01), (float('inf'), 0.02)]) == 5.0\n    assert candidate(200000, [(50000, 0.1), (100000, 0.15), (150000, 0.2), (float('inf'), 0.25)]) == 35000.0\n    assert candidate(50000, [(10000, 0.1), (30000, 0.15), (float('inf'), 0.25)]) == 9000.0\n    assert candidate(5000, [(10000, 0.05), (float('inf'), 0.1)]) == 250.0\n    assert candidate(75000, [(20000, 0.1), (50000, 0.2), (100000, 0.3), (float('inf'), 0.4)]) == 15500.0\n    assert candidate(100000, [(50000, 0.1), (100000, 0.2), (float('inf'), 0.3)]) == 15000.0\n    assert candidate(0, [(10000, 0.1), (20000, 0.15), (float('inf'), 0.2)]) == 0\n    assert candidate(30000, [(10000, 0.05), (20000, 0.1), (30000, 0.15), (float('inf'), 0.2)]) == 3000.0\n    assert candidate(1000000, [(100000, 0.1), (500000, 0.2), (1000000, 0.3), (float('inf'), 0.4)]) == 240000.0\n", "language": "python"}
{"task_id": "revision1a_problem444", "prompt": "from typing import List\n\ndef optimize_delivery_routes(cities: int, max_distance: int, routes: List[List[int]]) -> int:\n    \"\"\"\n    A delivery company wants to optimize its routes between cities. The task is to determine if all cities can be reached \n    within a maximum allowed distance per trip, given the connections between cities and their distances.\n\n    The function should return 1 if it's possible to reach all cities within the maximum allowed distance, and 0 otherwise.\n\n    Parameters:\n    cities (int): The number of cities\n    max_distance (int): The maximum allowed distance per trip\n    routes (List[List[int]]): A list of routes, where each route is represented as [city1, city2, distance]\n\n    Returns:\n    int: 1 if all cities can be reached within the maximum distance, 0 otherwise\n\n    Example:\n    Input: 5, 300, [[0,1,100], [1,2,125], [2,3,200], [3,4,150], [4,0,250]]\n    Output: 1\n    \"\"\"\n", "entry_point": "optimize_delivery_routes", "solution": "    def find(parent, i):\n        if parent[i] == i:\n            return i\n        return find(parent, parent[i])\n\n    def union(parent, rank, x, y):\n        xroot = find(parent, x)\n        yroot = find(parent, y)\n        if rank[xroot] < rank[yroot]:\n            parent[xroot] = yroot\n        elif rank[xroot] > rank[yroot]:\n            parent[yroot] = xroot\n        else:\n            parent[yroot] = xroot\n            rank[xroot] += 1\n\n    parent = list(range(cities))\n    rank = [0] * cities\n    connected_cities = 0\n\n    routes.sort(key=lambda x: x[2])  # Sort routes by distance\n\n    for route in routes:\n        city1, city2, distance = route\n        if distance <= max_distance:\n            x = find(parent, city1)\n            y = find(parent, city2)\n            if x != y:\n                union(parent, rank, x, y)\n                connected_cities += 1\n                if connected_cities == cities - 1:\n                    return 1\n\n    return 0\n", "test": "def check(candidate):\n    assert candidate(2, 50, [[0,1,100]]) == 0\n    assert candidate(3, 100, [[0,1,50], [1,2,75], [2,0,60]]) == 1\n    assert candidate(4, 300, [[0,1,100], [1,2,200], [2,3,250]]) == 1\n    assert candidate(1, 100, []) == 0\n    assert candidate(4, 200, [[0,1,100], [1,2,150], [2,3,175], [3,0,190]]) == 1\n    assert candidate(5, 500, [[0,1,100], [1,2,200], [2,3,300], [3,4,400]]) == 1\n    assert candidate(2, 100, [[0,1,50]]) == 1\n    assert candidate(3, 200, [[0,1,100], [1,2,150]]) == 1\n    assert candidate(6, 1000, [[0,1,200], [1,2,300], [2,3,400], [3,4,500], [4,5,600]]) == 1\n    assert candidate(5, 300, [[0,1,100], [1,2,125], [2,3,200], [3,4,150], [4,0,250]]) == 1\n", "language": "python"}
{"task_id": "revision1a_problem729", "prompt": "from typing import List\n\ndef longest_increasing_subsequence_2d(matrix: List[List[int]]) -> int:\n    \"\"\"\n    In a geographical survey, elevation data is collected in a 2D grid. The goal is to find the longest path of \n    increasing elevation that can be formed by moving only right or down from the current position.\n    \n    Take a 2D matrix as input where each cell represents the elevation at that point.\n    Return the length of the longest increasing path.\n    \n    Use dynamic programming to solve this problem efficiently.\n    \n    Example:\n    Input: [\n        [1, 2, 3, 4],\n        [2, 2, 3, 4],\n        [3, 2, 3, 4],\n        [4, 5, 6, 7]\n    ]\n    Output: 7\n    \n    One possible path of length 7 is: 1 -> 2 -> 2 -> 3 -> 4 -> 5 -> 6 -> 7\n    \"\"\"\n", "entry_point": "longest_increasing_subsequence_2d", "solution": "    if not matrix or not matrix[0]:\n        return 0\n\n    rows, cols = len(matrix), len(matrix[0])\n    dp = [[1] * cols for _ in range(rows)]\n    \n    def dfs(i: int, j: int) -> int:\n        if dp[i][j] > 1:\n            return dp[i][j]\n        \n        max_length = 1\n        \n        # Check right\n        if j + 1 < cols and matrix[i][j+1] > matrix[i][j]:\n            max_length = max(max_length, 1 + dfs(i, j+1))\n        \n        # Check down\n        if i + 1 < rows and matrix[i+1][j] > matrix[i][j]:\n            max_length = max(max_length, 1 + dfs(i+1, j))\n        \n        dp[i][j] = max_length\n        return max_length\n    \n    max_path_length = 1\n    for i in range(rows):\n        for j in range(cols):\n            max_path_length = max(max_path_length, dfs(i, j))\n    \n    return max_path_length\n", "test": "def check(candidate):\n    assert candidate([[1,2],[3,4]]) == 3\n    assert candidate([[9,8,7],[6,5,4],[3,2,1]]) == 1\n    assert candidate([[1]]) == 1\n    assert candidate([[1,2,3],[4,5,6],[7,8,9]]) == 5\n    assert candidate([[1,2,3],[2,1,4],[3,4,5]]) == 5\n    assert candidate([[1,2,3,4,5],[6,7,8,9,10],[11,12,13,14,15],[16,17,18,19,20],[21,22,23,24,25]]) == 9\n    assert candidate([[1,1,1],[1,1,1],[1,1,1]]) == 1\n    assert candidate([[5,4,3],[6,5,4],[7,6,5]]) == 3\n    assert candidate([[1,2,3,4],[2,2,3,4],[3,2,3,4],[4,5,6,7]]) == 7\n", "language": "python"}
{"task_id": "revision1a_problem137", "prompt": "from typing import List, Tuple\nimport math\n\ndef optimize_delivery_route(locations: List[Tuple[float, float]], start: Tuple[float, float]) -> List[Tuple[float, float]]:\n    \"\"\"\n    A food delivery service wants to optimize their delivery route to minimize travel time and fuel consumption.\n    Given a list of delivery locations (as latitude-longitude pairs) and a starting point, determine the most efficient\n    route that visits all locations exactly once and returns to the starting point.\n\n    Use the nearest neighbor algorithm to solve this Traveling Salesman Problem (TSP) heuristically.\n    \n    Parameters:\n    locations (List[Tuple[float, float]]): A list of (latitude, longitude) tuples representing delivery locations.\n    start (Tuple[float, float]): The starting point (latitude, longitude) for the delivery route.\n\n    Returns:\n    List[Tuple[float, float]]: An ordered list of coordinates representing the optimized route, including the start/end point.\n\n    Example:\n    Input: \n    locations = [(40.7128, -74.0060), (34.0522, -118.2437), (41.8781, -87.6298), (29.7604, -95.3698)]\n    start = (38.9072, -77.0369)\n    Output: \n    [(38.9072, -77.0369), (40.7128, -74.0060), (41.8781, -87.6298), (29.7604, -95.3698), (34.0522, -118.2437), (38.9072, -77.0369)]\n    \"\"\"\n", "entry_point": "optimize_delivery_route", "solution": "    def haversine_distance(point1: Tuple[float, float], point2: Tuple[float, float]) -> float:\n        \"\"\"Calculate the great-circle distance between two points on Earth.\"\"\"\n        lat1, lon1 = point1\n        lat2, lon2 = point2\n        \n        # Convert latitude and longitude to radians\n        lat1, lon1, lat2, lon2 = map(math.radians, [lat1, lon1, lat2, lon2])\n        \n        # Haversine formula\n        dlat = lat2 - lat1\n        dlon = lon2 - lon1\n        a = math.sin(dlat/2)**2 + math.cos(lat1) * math.cos(lat2) * math.sin(dlon/2)**2\n        c = 2 * math.asin(math.sqrt(a))\n        r = 6371  # Radius of Earth in kilometers\n        return c * r\n\n    unvisited = locations.copy()\n    route = [start]\n    current = start\n\n    while unvisited:\n        nearest = min(unvisited, key=lambda x: haversine_distance(current, x))\n        route.append(nearest)\n        current = nearest\n        unvisited.remove(nearest)\n\n    route.append(start)  # Return to the starting point\n    return route\n", "test": "def check(candidate):\n    assert candidate([(0, 0), (0, 1), (1, 0), (1, 1)], (0.5, 0.5)) == [(0.5, 0.5), (1, 0), (1, 1), (0, 1), (0, 0), (0.5, 0.5)]\n    assert candidate([(90, 0), (-90, 0), (0, 180), (0, -180)], (0, 0)) == [(0, 0), (90, 0), (0, 180), (0, -180), (-90, 0), (0, 0)]\n    assert candidate([(0, 0)], (0, 0)) == [(0, 0), (0, 0), (0, 0)]\n    assert candidate([(0, 0), (1, 1), (2, 2), (3, 3)], (0, 0)) == [(0, 0), (0, 0), (1, 1), (2, 2), (3, 3), (0, 0)]\n    assert candidate([], (0, 0)) == [(0, 0), (0, 0)]\n    assert candidate([(40.7128, -74.0060), (34.0522, -118.2437), (41.8781, -87.6298), (29.7604, -95.3698)], (38.9072, -77.0369)) == [(38.9072, -77.0369), (40.7128, -74.006), (41.8781, -87.6298), (29.7604, -95.3698), (34.0522, -118.2437), (38.9072, -77.0369)]\n    assert candidate([(i, i) for i in range(100)], (0, 0)) == [(0, 0), (0, 0), (1, 1), (2, 2), (3, 3), (4, 4), (5, 5), (6, 6), (7, 7), (8, 8), (9, 9), (10, 10), (11, 11), (12, 12), (13, 13), (14, 14), (15, 15), (16, 16), (17, 17), (18, 18), (19, 19), (20, 20), (21, 21), (22, 22), (23, 23), (24, 24), (25, 25), (26, 26), (27, 27), (28, 28), (29, 29), (30, 30), (31, 31), (32, 32), (33, 33), (34, 34), (35, 35), (36, 36), (37, 37), (38, 38), (39, 39), (40, 40), (41, 41), (42, 42), (43, 43), (44, 44), (45, 45), (46, 46), (47, 47), (48, 48), (49, 49), (50, 50), (51, 51), (52, 52), (53, 53), (54, 54), (55, 55), (56, 56), (57, 57), (58, 58), (59, 59), (60, 60), (61, 61), (62, 62), (63, 63), (64, 64), (65, 65), (66, 66), (67, 67), (68, 68), (69, 69), (70, 70), (71, 71), (72, 72), (73, 73), (74, 74), (75, 75), (76, 76), (77, 77), (78, 78), (79, 79), (80, 80), (81, 81), (82, 82), (83, 83), (84, 84), (85, 85), (86, 86), (87, 87), (88, 88), (89, 89), (90, 90), (91, 91), (92, 92), (93, 93), (94, 94), (95, 95), (96, 96), (97, 97), (98, 98), (99, 99), (0, 0)]\n    assert candidate([(0, 0), (0, 0), (0, 0)], (1, 1)) == [(1, 1), (0, 0), (0, 0), (0, 0), (1, 1)]\n    assert candidate([(1, 1)], (0, 0)) == [(0, 0), (1, 1), (0, 0)]\n", "language": "python"}
{"task_id": "revision1a_problem373", "prompt": "from typing import List, Tuple\nimport re\n\ndef analyze_dna_sequences(sequences: List[str]) -> Tuple[str, float, List[str]]:\n    \"\"\"\n    As a bioinformatics researcher, you're tasked with analyzing DNA sequences from multiple patients.\n    Create a function that processes a list of DNA sequences, where each sequence is a string of nucleotides (A, T, C, G).\n    \n    The function should:\n    1. Find the longest common subsequence among all input sequences.\n    2. Calculate the average GC-content across all sequences.\n    3. Identify any potential mutation sites (positions where nucleotides differ across sequences).\n    \n    Use regular expressions, list comprehensions, and advanced string manipulation techniques.\n    \n    Parameters:\n    sequences (List[str]): A list of DNA sequences, each represented as a string.\n    \n    Returns:\n    Tuple[str, float, List[str]]: A tuple containing:\n        - The longest common subsequence (string)\n        - The average GC-content (float)\n        - A list of potential mutation sites (list of strings)\n    \n    Example:\n    Input: [\"ATCGATCG\", \"ATCGATTG\", \"ATCGCTCG\"]\n    Output: (\"ATCG\", 0.5416666666666666, ['4', '5', '6'])\n    \n    Explanation:\n    - Longest common subsequence: \"ATCG\"\n    - Average GC-content: (4+4+5) / (8+8+8) = 0.5416666666666666\n    - Mutation sites: positions 4, 5, and 6 (0-indexed)\n    \"\"\"\n", "entry_point": "analyze_dna_sequences", "solution": "    def longest_common_subsequence(seq1, seq2):\n        m, n = len(seq1), len(seq2)\n        dp = [[0] * (n + 1) for _ in range(m + 1)]\n        for i in range(1, m + 1):\n            for j in range(1, n + 1):\n                if seq1[i - 1] == seq2[j - 1]:\n                    dp[i][j] = dp[i - 1][j - 1] + 1\n                else:\n                    dp[i][j] = max(dp[i - 1][j], dp[i][j - 1])\n        lcs = []\n        i, j = m, n\n        while i > 0 and j > 0:\n            if seq1[i - 1] == seq2[j - 1]:\n                lcs.append(seq1[i - 1])\n                i -= 1\n                j -= 1\n            elif dp[i - 1][j] > dp[i][j - 1]:\n                i -= 1\n            else:\n                j -= 1\n        return ''.join(reversed(lcs))\n\n    # Find the longest common subsequence\n    lcs = sequences[0]\n    for seq in sequences[1:]:\n        lcs = longest_common_subsequence(lcs, seq)\n\n    # Calculate average GC-content\n    gc_count = sum(len(re.findall(r'[GC]', seq)) for seq in sequences)\n    total_length = sum(len(seq) for seq in sequences)\n    avg_gc_content = gc_count / total_length\n\n    # Identify potential mutation sites\n    mutation_sites = []\n    for i in range(min(len(seq) for seq in sequences)):\n        if len(set(seq[i] for seq in sequences)) > 1:\n            mutation_sites.append(str(i))\n\n    return lcs, avg_gc_content, mutation_sites\n", "test": "def check(candidate):\n    assert candidate([\"ATCG\", \"TACG\", \"GCAT\", \"CGTA\"]) == ('G', 0.5, ['0', '1', '2', '3'])\n    assert candidate([\"ATATATATATAT\", \"CGCGCGCGCGCG\"]) == ('', 0.5, ['0', '1', '2', '3', '4', '5', '6', '7', '8', '9', '10', '11'])\n    assert candidate([\"ATCGATCGATCG\", \"ATCGATCGATCG\"]) == ('ATCGATCGATCG', 0.5, [])\n    assert candidate([\"AAAA\", \"AAAA\", \"AAAA\"]) == ('AAAA', 0.0, [])\n    assert candidate([\"A\", \"T\", \"C\", \"G\"]) == ('', 0.5, ['0'])\n    assert candidate([\"AT\", \"CG\", \"TA\"]) == ('', 0.3333333333333333, ['0', '1'])\n    assert candidate([\"ATCGATCG\", \"ATCGATTG\", \"ATCGCTCG\"]) == ('ATCGTG', 0.5, ['4', '6'])\n    assert candidate([\"ATCG\", \"ATCG\", \"ATCG\", \"ATCG\"]) == ('ATCG', 0.5, [])\n    assert candidate([\"AAAACCCCGGGGTTTT\", \"AAAACCCCGGGGTTTT\", \"AAAACCCCGGGGTTTT\"]) == ('AAAACCCCGGGGTTTT', 0.5, [])\n    assert candidate([\"GCGC\", \"CGCG\", \"GCGC\"]) == ('CGC', 1.0, ['0', '1', '2', '3'])\n", "language": "python"}
{"task_id": "revision1a_problem435", "prompt": "from typing import List, Tuple\n\ndef palindrome_pairs(words: List[str]) -> List[Tuple[str, str]]:\n    \"\"\"\n    Write a Python function that takes a list of words and finds all pairs of words that, when concatenated,\n    form a palindrome. A palindrome is a word that reads the same forwards and backwards.\n\n    The function should return a list of tuples, where each tuple contains a pair of words that form a palindrome\n    when concatenated. The order of the words in each tuple should be the same as their order in the input list.\n\n    Example:\n    Input: [\"bat\", \"tab\", \"cat\", \"tac\", \"dog\", \"god\"]\n    Output: [(\"bat\", \"tab\"), (\"tab\", \"bat\"), (\"cat\", \"tac\"), (\"tac\", \"cat\"), (\"dog\", \"god\")]\n\n    Input: [\"hello\", \"world\", \"olleh\", \"dlrow\"]\n    Output: [(\"hello\", \"olleh\"), (\"world\", \"dlrow\")]\n\n    Note: The function should consider both the case where the first word is concatenated to the second,\n    and the case where the second word is concatenated to the first.\n    \"\"\"\n", "entry_point": "palindrome_pairs", "solution": "    def is_palindrome(s: str) -> bool:\n        return s == s[::-1]\n\n    word_dict = {word: i for i, word in enumerate(words)}\n    result = []\n\n    for i, word in enumerate(words):\n        for j in range(len(word) + 1):\n            prefix = word[:j]\n            suffix = word[j:]\n\n            # Check if the reversed prefix exists in the word_dict\n            if is_palindrome(suffix):\n                reversed_prefix = prefix[::-1]\n                if reversed_prefix in word_dict and word_dict[reversed_prefix] != i:\n                    result.append((word, reversed_prefix))\n\n            # Check if the reversed suffix exists in the word_dict\n            if j != 0 and is_palindrome(prefix):\n                reversed_suffix = suffix[::-1]\n                if reversed_suffix in word_dict and word_dict[reversed_suffix] != i:\n                    result.append((reversed_suffix, word))\n\n    return result\n", "test": "def check(candidate):\n    assert candidate([\"madam\", \"adam\", \"dam\"]) == [('madam', 'adam')]\n    assert candidate([\"a\", \"b\", \"c\", \"d\"]) == []\n    assert candidate([\"racecar\", \"car\", \"race\"]) == [('race', 'car')]\n    assert candidate([\"123\", \"321\", \"456\", \"654\"]) == [('123', '321'), ('321', '123'), ('456', '654'), ('654', '456')]\n    assert candidate([\"hello\", \"olleh\", \"world\"]) == [('hello', 'olleh'), ('olleh', 'hello')]\n    assert candidate([\"\", \"a\", \"aa\", \"aaa\"]) == [('a', ''), ('', 'a'), ('aa', ''), ('aa', 'a'), ('a', 'aa'), ('', 'aa'), ('aaa', ''), ('aaa', 'a'), ('aa', 'aaa'), ('aaa', 'aa'), ('a', 'aaa'), ('', 'aaa')]\n    assert candidate([\"bat\", \"tab\", \"cat\"]) == [('bat', 'tab'), ('tab', 'bat')]\n    assert candidate([\"lol\", \"pop\", \"mom\", \"dad\"]) == []\n    assert candidate([\"abc\", \"cba\", \"def\", \"fed\"]) == [('abc', 'cba'), ('cba', 'abc'), ('def', 'fed'), ('fed', 'def')]\n    assert candidate([\"abcd\", \"dcba\", \"efgh\"]) == [('abcd', 'dcba'), ('dcba', 'abcd')]\n", "language": "python"}
{"task_id": "revision1a_problem678", "prompt": "def network_latency(nodes: int, connections: list, start: int, end: int) -> int:\n    \"\"\"\n    You're a network engineer tasked with optimizing data transmission in a computer network.\n    The network consists of nodes (computers) connected by cables with varying latencies.\n    Your goal is to find the path with the lowest total latency between two specific nodes.\n\n    Take the following inputs from the user:\n    - The number of nodes in the network\n    - A list of connections, where each connection is a tuple (node1, node2, latency)\n    - The start node\n    - The end node\n\n    Return the lowest possible latency between the start and end nodes.\n    If there's no path between the nodes, return -1.\n\n    Example 1:\n    Input: 5, [(0,1,10), (0,2,5), (1,2,2), (1,3,1), (2,3,9), (2,4,2), (3,4,4)], 0, 4\n    Output: 7\n\n    Example 2:\n    Input: 4, [(0,1,1), (1,2,2), (2,3,3)], 0, 3\n    Output: 6\n    \"\"\"\n", "entry_point": "network_latency", "solution": "    import heapq\n    from collections import defaultdict\n\n    # Create an adjacency list to represent the network\n    graph = defaultdict(list)\n    for node1, node2, latency in connections:\n        graph[node1].append((node2, latency))\n        graph[node2].append((node1, latency))  # Assuming bidirectional connections\n\n    # Initialize distances and visited set\n    distances = [float('inf')] * nodes\n    distances[start] = 0\n    visited = set()\n\n    # Priority queue to store nodes to visit\n    pq = [(0, start)]\n\n    while pq:\n        current_distance, current_node = heapq.heappop(pq)\n\n        if current_node == end:\n            return current_distance\n\n        if current_node in visited:\n            continue\n\n        visited.add(current_node)\n\n        for neighbor, latency in graph[current_node]:\n            distance = current_distance + latency\n            if distance < distances[neighbor]:\n                distances[neighbor] = distance\n                heapq.heappush(pq, (distance, neighbor))\n\n    return -1 if distances[end] == float('inf') else distances[end]\n", "test": "def check(candidate):\n    assert candidate(7, [(0,1,1), (1,2,2), (2,3,3), (3,4,4), (4,5,5), (5,6,6)], 0, 6) == 21\n    assert candidate(6, [(0,1,1), (1,2,2), (2,3,3), (3,4,4), (4,5,5)], 0, 5) == 15\n    assert candidate(4, [(0,1,1), (1,2,1), (2,3,1), (0,3,4)], 0, 3) == 3\n    assert candidate(4, [(0,1,1), (0,2,2), (0,3,3), (1,2,4), (1,3,5), (2,3,6)], 0, 3) == 3\n    assert candidate(5, [(0,1,1), (1,2,1), (2,3,1), (3,4,1), (0,4,10)], 0, 4) == 4\n    assert candidate(3, [(0,1,1), (1,2,1), (0,2,3)], 0, 2) == 2\n    assert candidate(5, [(0,1,10), (0,2,5), (1,2,2), (1,3,1), (2,3,9), (2,4,2), (3,4,4)], 0, 4) == 7\n    assert candidate(4, [(0,1,1), (1,2,2), (2,3,3)], 0, 3) == 6\n    assert candidate(3, [(0,1,1), (1,2,1)], 0, 2) == 2\n    assert candidate(2, [(0,1,100)], 0, 1) == 100\n", "language": "python"}
{"task_id": "revision1a_problem297", "prompt": "import math\nfrom typing import List\nimport statistics\n\ndef compress_image(image: List[List[int]], threshold: float) -> List[List[List[int]]]:\n    \"\"\"\n    You are working on an image compression algorithm using the quadtree data structure.\n    Your task is to implement a function that compresses a grayscale image represented as a 2D list of integers (0-255).\n\n    The function should:\n    1. Recursively divide the image into quadrants.\n    2. For each quadrant, calculate the mean and variance of pixel values.\n    3. If the variance is below the given threshold, represent the entire quadrant by its mean value.\n    4. If the variance is above the threshold, further divide the quadrant.\n    5. Return a nested list representing the compressed image structure.\n\n    Take the image dimensions, pixel values, and compression threshold as input from the user.\n    Display the compressed image structure.\n\n    Example:\n    Input:\n    Image dimensions: 4x4\n    Pixel values:\n    100 120 130 140\n    105 115 135 145\n    110 130 150 160\n    120 140 170 180\n    Threshold: 50\n    Output: [[[112, 137], [120, 150]], [[130, 165]]]\n    \"\"\"\n", "entry_point": "compress_image", "solution": "    def compress_quadrant(x: int, y: int, size: int) -> List:\n        if size == 1:\n            return image[y][x]\n\n        half_size = size // 2\n        quadrants = [\n            compress_quadrant(x, y, half_size),\n            compress_quadrant(x + half_size, y, half_size),\n            compress_quadrant(x, y + half_size, half_size),\n            compress_quadrant(x + half_size, y + half_size, half_size)\n        ]\n\n        # Calculate mean and variance\n        pixels = [pixel for quadrant in quadrants for pixel in (quadrant if isinstance(quadrant, list) else [quadrant])]\n        mean = sum(pixels) / len(pixels)\n        variance = sum((pixel - mean) ** 2 for pixel in pixels) / len(pixels)\n\n        if variance <= threshold:\n            return int(mean)\n        else:\n            return quadrants\n\n    return compress_quadrant(0, 0, len(image))\n\n", "test": "def check(candidate):\n    assert candidate([[0, 0, 0, 0], [0, 0, 0, 0], [0, 0, 0, 0], [0, 0, 0, 0]], 0) == 0\n    assert candidate([[0, 0], [0, 0]], 10) == 0\n    assert candidate([[255, 255], [255, 255]], 0.1) == 255\n    assert candidate([[128, 128, 128, 128], [128, 128, 128, 128], [128, 128, 128, 128], [128, 128, 128, 128]], 1) == 128\n    assert candidate([[100]], 5) == 100\n    assert candidate([[1, 2, 3, 4], [5, 6, 7, 8], [9, 10, 11, 12], [13, 14, 15, 16]], 5) == [3, 5, 11, 13]\n    assert candidate([[0, 255], [255, 0]], 100) == [0, 255, 255, 0]\n    assert candidate([[50, 60, 70], [55, 65, 75], [60, 70, 80]], 25) == [50, 60, 55, 65]\n    assert candidate([[100, 120, 130, 140], [105, 115, 135, 145], [110, 130, 150, 160], [120, 140, 170, 180]], 50) == [[100, 120, 105, 115], 137, [110, 130, 120, 140], [150, 160, 170, 180]]\n    assert candidate([[0, 255, 0, 255], [255, 0, 255, 0], [0, 255, 0, 255], [255, 0, 255, 0]], 200) == [[0, 255, 255, 0], [0, 255, 255, 0], [0, 255, 255, 0], [0, 255, 255, 0]]\n", "language": "python"}
{"task_id": "revision1a_problem488", "prompt": "from typing import List, Tuple\nimport math\n\ndef optimize_delivery_route(packages: List[Tuple[float, float]], fuel_capacity: float, fuel_consumption: float) -> List[int]:\n    \"\"\"\n    A delivery company wants to optimize its route for delivering packages. Given a list of package locations\n    (represented as (x, y) coordinates), the fuel capacity of the delivery truck, and the fuel consumption rate,\n    determine the optimal order to deliver the packages while minimizing fuel usage.\n\n    The truck starts and ends at the origin (0, 0). Implement a function that returns the optimal order of package\n    deliveries as a list of indices from the input list.\n\n    Use dynamic programming to solve this problem efficiently.\n\n    Args:\n    packages (List[Tuple[float, float]]): List of package locations as (x, y) coordinates\n    fuel_capacity (float): The maximum amount of fuel the truck can hold\n    fuel_consumption (float): Fuel consumed per unit distance\n\n    Returns:\n    List[int]: The optimal order of package deliveries as indices from the input list\n\n    Example:\n    Input: packages = [(1, 1), (2, 2), (3, 3)], fuel_capacity = 20, fuel_consumption = 0.1\n    Output: [0, 1, 2]\n\n    Input: packages = [(5, 5), (1, 1), (4, 4), (2, 2)], fuel_capacity = 30, fuel_consumption = 0.2\n    Output: [1, 3, 2, 0]\n    \"\"\"\n", "entry_point": "optimize_delivery_route", "solution": "    def distance(p1, p2):\n        return math.sqrt((p1[0] - p2[0])**2 + (p1[1] - p2[1])**2)\n\n    n = len(packages)\n    all_locations = [(0, 0)] + packages\n    \n    # Create a distance matrix\n    dist = [[distance(all_locations[i], all_locations[j]) for j in range(n+1)] for i in range(n+1)]\n    \n    # Initialize DP table\n    dp = [[float('inf')] * (1 << (n+1)) for _ in range(n+1)]\n    dp[0][1] = 0  # Start at the origin\n    \n    # Fill DP table\n    for mask in range(1, 1 << (n+1)):\n        for i in range(n+1):\n            if (mask & (1 << i)) == 0:\n                continue\n            for j in range(n+1):\n                if i == j or (mask & (1 << j)) == 0:\n                    continue\n                if dp[i][mask] + dist[i][j] * fuel_consumption <= fuel_capacity:\n                    dp[j][mask | (1 << j)] = min(dp[j][mask | (1 << j)], dp[i][mask] + dist[i][j] * fuel_consumption)\n    \n    # Find the optimal path\n    current = 0\n    mask = (1 << (n+1)) - 1\n    path = []\n    \n    while mask != 1:\n        next_location = -1\n        for i in range(1, n+1):\n            if (mask & (1 << i)) and (next_location == -1 or dp[i][mask] + dist[i][0] * fuel_consumption < dp[next_location][mask] + dist[next_location][0] * fuel_consumption):\n                next_location = i\n        path.append(next_location - 1)\n        mask &= ~(1 << next_location)\n        current = next_location\n    \n    return path[::-1]\n", "test": "def check(candidate):\n    assert candidate([], 10, 0.5) == []\n    assert candidate([(0, 1)], 5, 0.1) == [0]\n    assert candidate([(0, 5), (5, 0), (5, 5)], 25, 0.2) == [2, 1, 0]\n    assert candidate([(10, 10), (20, 20), (30, 30)], 100, 0.5) == [2, 1, 0]\n    assert candidate([(5, 5), (1, 1), (4, 4), (2, 2)], 30, 0.2) == [3, 2, 1, 0]\n    assert candidate([(1, 1), (2, 2), (3, 3), (4, 4), (5, 5)], 50, 0.1) == [4, 3, 2, 1, 0]\n    assert candidate([(1, 1), (2, 2), (3, 3)], 20, 0.1) == [2, 1, 0]\n    assert candidate([(0.5, 0.5), (1.5, 1.5), (2.5, 2.5)], 8, 0.25) == [2, 1, 0]\n    assert candidate([(-1, -1), (1, 1), (-1, 1), (1, -1)], 15, 0.3) == [3, 2, 1, 0]\n    assert candidate([(1, 0), (0, 1), (1, 1)], 10, 0.2) == [2, 1, 0]\n", "language": "python"}
{"task_id": "revision1a_problem388", "prompt": "from collections import Counter\nimport datetime\nfrom typing import List, Dict\n\ndef analyze_website_traffic(log_entries: List[Dict[str, str]]) -> Dict[str, Dict[str, int]]:\n    \"\"\"\n    Analyze website traffic data from a list of log entries. Each log entry is a dictionary containing\n    'timestamp' (in ISO format), 'url', and 'user_id' keys.\n    \n    Return a dictionary with URLs as keys, and values as nested dictionaries containing:\n    - 'total_visits': total number of visits to the URL\n    - 'unique_visitors': number of unique visitors to the URL\n    - 'peak_hour': hour of the day (0-23) with the most visits\n\n    Use list comprehension, datetime manipulation, and the Counter class from the collections module.\n\n    Example:\n    Input: [\n        {\"timestamp\": \"2023-05-01T10:30:00\", \"url\": \"/home\", \"user_id\": \"user1\"},\n        {\"timestamp\": \"2023-05-01T11:45:00\", \"url\": \"/products\", \"user_id\": \"user2\"},\n        {\"timestamp\": \"2023-05-01T12:15:00\", \"url\": \"/home\", \"user_id\": \"user3\"},\n        {\"timestamp\": \"2023-05-01T13:00:00\", \"url\": \"/home\", \"user_id\": \"user1\"},\n        {\"timestamp\": \"2023-05-01T14:30:00\", \"url\": \"/products\", \"user_id\": \"user3\"}\n    ]\n\n    Output: {\n        \"/home\": {\n            \"total_visits\": 3,\n            \"unique_visitors\": 2,\n            \"peak_hour\": 13\n        },\n        \"/products\": {\n            \"total_visits\": 2,\n            \"unique_visitors\": 2,\n            \"peak_hour\": 11\n        }\n    }\n    \"\"\"\n", "entry_point": "analyze_website_traffic", "solution": "    # Initialize the result dictionary\n    result = {}\n\n    # Process each log entry\n    for entry in log_entries:\n        url = entry['url']\n        user_id = entry['user_id']\n        timestamp = datetime.datetime.fromisoformat(entry['timestamp'])\n\n        # Initialize URL data if not present\n        if url not in result:\n            result[url] = {\n                'total_visits': 0,\n                'unique_visitors': set(),\n                'hourly_visits': Counter()\n            }\n\n        # Update URL data\n        result[url]['total_visits'] += 1\n        result[url]['unique_visitors'].add(user_id)\n        result[url]['hourly_visits'][timestamp.hour] += 1\n\n    # Process the collected data to get the final result\n    final_result = {\n        url: {\n            'total_visits': data['total_visits'],\n            'unique_visitors': len(data['unique_visitors']),\n            'peak_hour': max(data['hourly_visits'], key=data['hourly_visits'].get)\n        }\n        for url, data in result.items()\n    }\n\n    return final_result\n", "test": "def check(candidate):\n    assert candidate([{\"timestamp\": \"2023-05-01T10:30:00\", \"url\": \"/home\", \"user_id\": \"user1\"}, {\"timestamp\": \"2023-05-01T22:30:00\", \"url\": \"/home\", \"user_id\": \"user2\"}]) == {'/home': {'total_visits': 2, 'unique_visitors': 2, 'peak_hour': 10}}\n    assert candidate([{\"timestamp\": f\"2023-05-01T{i:02d}:00:00\", \"url\": \"/home\", \"user_id\": f\"user{i}\"} for i in range(24)]) == {'/home': {'total_visits': 24, 'unique_visitors': 24, 'peak_hour': 0}}\n    assert candidate([{\"timestamp\": \"2023-05-01T10:30:00\", \"url\": \"/home\", \"user_id\": \"user1\"}, {\"timestamp\": \"2023-05-01T10:30:01\", \"url\": \"/about\", \"user_id\": \"user1\"}, {\"timestamp\": \"2023-05-01T10:30:02\", \"url\": \"/contact\", \"user_id\": \"user1\"}]) == {'/home': {'total_visits': 1, 'unique_visitors': 1, 'peak_hour': 10}, '/about': {'total_visits': 1, 'unique_visitors': 1, 'peak_hour': 10}, '/contact': {'total_visits': 1, 'unique_visitors': 1, 'peak_hour': 10}}\n    assert candidate([{\"timestamp\": \"2023-05-01T10:30:00\", \"url\": \"/home\", \"user_id\": \"user1\"}, {\"timestamp\": \"2023-05-01T10:31:00\", \"url\": \"/home\", \"user_id\": \"user1\"}]) == {'/home': {'total_visits': 2, 'unique_visitors': 1, 'peak_hour': 10}}\n    assert candidate([{\"timestamp\": \"2023-05-01T10:30:00\", \"url\": \"/home\", \"user_id\": \"user1\"}, {\"timestamp\": \"2023-05-02T10:30:00\", \"url\": \"/home\", \"user_id\": \"user1\"}]) == {'/home': {'total_visits': 2, 'unique_visitors': 1, 'peak_hour': 10}}\n    assert candidate([{\"timestamp\": \"2023-05-01T00:00:00\", \"url\": \"/home\", \"user_id\": \"user1\"}]) == {'/home': {'total_visits': 1, 'unique_visitors': 1, 'peak_hour': 0}}\n    assert candidate([{\"timestamp\": \"2023-05-01T23:59:59\", \"url\": \"/home\", \"user_id\": \"user1\"}, {\"timestamp\": \"2023-05-02T00:00:00\", \"url\": \"/home\", \"user_id\": \"user1\"}]) == {'/home': {'total_visits': 2, 'unique_visitors': 1, 'peak_hour': 23}}\n    assert candidate([{\"timestamp\": \"2023-05-01T10:30:00\", \"url\": \"/home\", \"user_id\": \"user1\"}, {\"timestamp\": \"2023-05-01T11:45:00\", \"url\": \"/products\", \"user_id\": \"user2\"}, {\"timestamp\": \"2023-05-01T12:15:00\", \"url\": \"/home\", \"user_id\": \"user3\"}, {\"timestamp\": \"2023-05-01T13:00:00\", \"url\": \"/home\", \"user_id\": \"user1\"}, {\"timestamp\": \"2023-05-01T14:30:00\", \"url\": \"/products\", \"user_id\": \"user3\"}]) == {'/home': {'total_visits': 3, 'unique_visitors': 2, 'peak_hour': 10}, '/products': {'total_visits': 2, 'unique_visitors': 2, 'peak_hour': 11}}\n    assert candidate([]) == {}\n    assert candidate([{\"timestamp\": \"2023-05-01T10:30:00\", \"url\": \"/home\", \"user_id\": \"user1\"} for _ in range(100)]) == {'/home': {'total_visits': 100, 'unique_visitors': 1, 'peak_hour': 10}}\n", "language": "python"}
{"task_id": "revision1a_problem77", "prompt": "import re\nfrom typing import Dict\n\ndef analyze_text(text: str) -> Dict[str, int]:\n    \"\"\"\n    A linguist is studying the frequency of words in various texts. To assist in their research,\n    they need a function that can analyze a given text and provide statistics about word usage.\n\n    Write a function that takes a string of text as input and returns a dictionary containing\n    the following information:\n\n    1. The total number of words in the text\n    2. The number of unique words\n    3. The number of sentences\n    4. The length of the longest word\n    5. The number of words that appear only once\n\n    Words should be considered case-insensitive and defined as sequences of alphabetic characters.\n    Sentences are assumed to end with '.', '!', or '?'.\n\n    Example:\n    Input: \"Hello world! This is a test. How many words are there? One, two, three, four, five.\"\n    Output: {\n        'total_words': 15,\n        'unique_words': 13,\n        'sentence_count': 3,\n        'longest_word_length': 5,\n        'single_occurrence_words': 11\n    }\n\n    Input: \"The quick brown fox jumps over the lazy dog. The dog barks.\"\n    Output: {\n        'total_words': 11,\n        'unique_words': 9,\n        'sentence_count': 2,\n        'longest_word_length': 5,\n        'single_occurrence_words': 8\n    }\n    \"\"\"\n", "entry_point": "analyze_text", "solution": "    # Convert text to lowercase\n    text = text.lower()\n    \n    # Split text into words (sequences of alphabetic characters)\n    words = re.findall(r'\\b[a-z]+\\b', text)\n    \n    # Count total words\n    total_words = len(words)\n    \n    # Count unique words\n    unique_words = len(set(words))\n    \n    # Count sentences\n    sentence_count = len(re.findall(r'[.!?]', text))\n    \n    # Find length of longest word\n    longest_word_length = max(len(word) for word in words) if words else 0\n    \n    # Count words that appear only once\n    word_frequency = {}\n    for word in words:\n        word_frequency[word] = word_frequency.get(word, 0) + 1\n    single_occurrence_words = sum(1 for count in word_frequency.values() if count == 1)\n    \n    # Prepare and return the result dictionary\n    return {\n        'total_words': total_words,\n        'unique_words': unique_words,\n        'sentence_count': sentence_count,\n        'longest_word_length': longest_word_length,\n        'single_occurrence_words': single_occurrence_words\n    }\n", "test": "def check(candidate):\n    assert candidate(\"Single.\") == {'total_words': 1, 'unique_words': 1, 'sentence_count': 1, 'longest_word_length': 6, 'single_occurrence_words': 1}\n    assert candidate(\"Multiple!!!!! Exclamation!!!! Marks!!!!\") == {'total_words': 3, 'unique_words': 3, 'sentence_count': 13, 'longest_word_length': 11, 'single_occurrence_words': 3}\n    assert candidate(\"No punctuation no sentences\") == {'total_words': 4, 'unique_words': 3, 'sentence_count': 0, 'longest_word_length': 11, 'single_occurrence_words': 2}\n    assert candidate(\"Repeat repeat repeat repeat repeat.\") == {'total_words': 5, 'unique_words': 1, 'sentence_count': 1, 'longest_word_length': 6, 'single_occurrence_words': 0}\n    assert candidate(\"\") == {'total_words': 0, 'unique_words': 0, 'sentence_count': 0, 'longest_word_length': 0, 'single_occurrence_words': 0}\n    assert candidate(\"Short? Very! Yes.\") == {'total_words': 3, 'unique_words': 3, 'sentence_count': 3, 'longest_word_length': 5, 'single_occurrence_words': 3}\n    assert candidate(\"The quick brown fox jumps over the lazy dog. The dog barks.\") == {'total_words': 12, 'unique_words': 9, 'sentence_count': 2, 'longest_word_length': 5, 'single_occurrence_words': 7}\n    assert candidate(\"UPPERCASE WORDS ARE COUNTED AS LOWERCASE.\") == {'total_words': 6, 'unique_words': 6, 'sentence_count': 1, 'longest_word_length': 9, 'single_occurrence_words': 6}\n    assert candidate(\"What about hyphenated-words and under_scores?\") == {'total_words': 5, 'unique_words': 5, 'sentence_count': 1, 'longest_word_length': 10, 'single_occurrence_words': 5}\n    assert candidate(\"Hello world! This is a test. How many words are there? One, two, three, four, five.\") == {'total_words': 16, 'unique_words': 16, 'sentence_count': 4, 'longest_word_length': 5, 'single_occurrence_words': 16}\n", "language": "python"}
{"task_id": "revision1a_problem352", "prompt": "from itertools import permutations\nfrom typing import List\n\ndef decrypt_alien_message(message: str, known_words: List[str]) -> str:\n    \"\"\"\n    An astronomer has intercepted a coded message from an alien civilization. The message is a string of lowercase letters, where each letter represents a unique sound in the alien language.\n\n    Some words in the alien language are known and provided in the 'known_words' list. Using this information, attempt to decrypt the message by replacing alien sounds with corresponding Earth letters.\n\n    If multiple decryptions are possible, return the lexicographically smallest one. If no valid decryption exists, return an empty string.\n\n    Example:\n    Input: message = \"oqoqoq\", known_words = [\"hello\", \"world\"]\n    Output: \"ababab\"\n\n    Explanation: One possible decryption maps 'o' to 'a' and 'q' to 'b', which is the lexicographically smallest valid decryption.\n    \"\"\"\n", "entry_point": "decrypt_alien_message", "solution": "    def is_valid_mapping(mapping):\n        decrypted = ''.join(mapping[c] for c in message)\n        return all(word in decrypted for word in known_words)\n\n    unique_chars = sorted(set(message))\n    earth_chars = 'abcdefghijklmnopqrstuvwxyz'\n\n    if len(unique_chars) > len(earth_chars):\n        return \"\"\n\n    for perm in permutations(earth_chars, len(unique_chars)):\n        mapping = dict(zip(unique_chars, perm))\n        if is_valid_mapping(mapping):\n            return ''.join(mapping[c] for c in message)\n\n    return \"\"\n", "test": "def check(candidate):\n    assert candidate(\"hello\", [\"hello\"]) == 'hello'\n    assert candidate(\"aaaabbbb\", [\"abab\", \"baba\"]) == ''\n    assert candidate(\"\", [\"empty\"]) == ''\n    assert candidate(\"xyxyxy\", [\"foo\", \"bar\", \"baz\"]) == ''\n    assert candidate(\"xyzxyzxyz\", [\"abc\", \"def\", \"ghi\"]) == ''\n    assert candidate(\"zzz\", [\"aaa\", \"bbb\", \"ccc\"]) == ''\n    assert candidate(\"abc\", [\"abc\"]) == 'abc'\n    assert candidate(\"oqoqoq\", [\"hello\", \"world\"]) == ''\n    assert candidate(\"a\", [\"a\"]) == 'a'\n    assert candidate(\"aabbcc\", [\"abc\"]) == ''\n", "language": "python"}
{"task_id": "revision1a_problem117", "prompt": "from typing import List, Dict, Tuple\nfrom collections import defaultdict\n\ndef analyze_social_network(connections: List[Tuple[str, str]], interests: Dict[str, List[str]]) -> Dict[str, List[str]]:\n    \"\"\"\n    A social media company wants to analyze its user network to suggest new connections based on shared interests.\n    Given a list of existing connections between users and a dictionary of user interests, identify potential new\n    connections for each user based on shared interests with friends-of-friends.\n\n    This problem involves graph traversal, set operations, and dictionary manipulation.\n\n    Args:\n    connections (List[Tuple[str, str]]): List of tuples representing connections between users\n    interests (Dict[str, List[str]]): Dictionary mapping users to their list of interests\n\n    Returns:\n    Dict[str, List[str]]: Dictionary mapping users to lists of suggested new connections\n\n    Example:\n    Input:\n    connections = [(\"Alice\", \"Bob\"), (\"Bob\", \"Charlie\"), (\"David\", \"Eve\"), (\"Eve\", \"Frank\"), (\"Frank\", \"George\")]\n    interests = {\n        \"Alice\": [\"music\", \"art\", \"technology\"],\n        \"Bob\": [\"sports\", \"technology\", \"cooking\"],\n        \"Charlie\": [\"technology\", \"gardening\", \"photography\"],\n        \"David\": [\"sports\", \"music\", \"travel\"],\n        \"Eve\": [\"art\", \"travel\", \"cooking\"],\n        \"Frank\": [\"technology\", \"sports\", \"photography\"],\n        \"George\": [\"music\", \"cooking\", \"gardening\"]\n    }\n    Output:\n    {\n        \"Alice\": [\"Charlie\", \"Frank\"],\n        \"Bob\": [\"Eve\", \"Frank\"],\n        \"Charlie\": [\"Alice\", \"Frank\"],\n        \"David\": [\"George\"],\n        \"Eve\": [\"Alice\", \"Bob\"],\n        \"Frank\": [\"Alice\", \"Bob\", \"Charlie\"],\n        \"George\": [\"David\"]\n    }\n    \"\"\"\n", "entry_point": "analyze_social_network", "solution": "    # Create a graph of connections\n    graph = defaultdict(set)\n    for user1, user2 in connections:\n        graph[user1].add(user2)\n        graph[user2].add(user1)\n    \n    # Function to get friends of friends\n    def get_friends_of_friends(user):\n        friends_of_friends = set()\n        for friend in graph[user]:\n            friends_of_friends.update(graph[friend])\n        friends_of_friends.discard(user)\n        friends_of_friends -= graph[user]\n        return friends_of_friends\n    \n    # Function to calculate shared interests\n    def shared_interests(user1, user2):\n        return set(interests[user1]) & set(interests[user2])\n    \n    # Generate suggestions\n    suggestions = defaultdict(list)\n    for user in interests:\n        fof = get_friends_of_friends(user)\n        for potential_friend in fof:\n            if shared_interests(user, potential_friend):\n                suggestions[user].append(potential_friend)\n    \n    # Sort suggestions alphabetically\n    for user in suggestions:\n        suggestions[user].sort()\n    \n    return dict(suggestions)\n", "test": "def check(candidate):\n    assert candidate([(\"A\", \"B\")], {\"A\": [], \"B\": []}) == {}\n    assert candidate([(\"A\", \"B\"), (\"B\", \"C\"), (\"C\", \"D\")], {\"A\": [\"x\"], \"B\": [\"y\"], \"C\": [\"z\"], \"D\": [\"x\"]}) == {}\n    assert candidate([], {\"A\": [\"x\"], \"B\": [\"y\"]}) == {}\n    assert candidate([(\"A\", \"B\"), (\"A\", \"C\"), (\"A\", \"D\")], {\"A\": [\"x\"], \"B\": [\"x\"], \"C\": [\"x\"], \"D\": [\"x\"], \"E\": [\"x\"]}) == {'B': ['C', 'D'], 'C': ['B', 'D'], 'D': ['B', 'C']}\n    assert candidate([(\"A\", \"B\"), (\"B\", \"C\")], {\"A\": [\"x\"], \"B\": [\"x\", \"y\"], \"C\": [\"y\"]}) == {}\n    assert candidate([(\"A\", \"B\")], {\"A\": [\"x\"], \"B\": [\"y\"]}) == {}\n    assert candidate([(\"A\", \"B\"), (\"B\", \"C\"), (\"C\", \"A\")], {\"A\": [\"x\"], \"B\": [\"x\"], \"C\": [\"x\"]}) == {}\n    assert candidate([(\"A\", \"B\"), (\"C\", \"D\")], {\"A\": [\"x\"], \"B\": [\"y\"], \"C\": [\"z\"], \"D\": [\"w\"]}) == {}\n    assert candidate([(\"A\", \"B\"), (\"B\", \"C\"), (\"C\", \"D\"), (\"D\", \"E\")], {\"A\": [\"x\"], \"B\": [\"x\", \"y\"], \"C\": [\"y\", \"z\"], \"D\": [\"z\", \"w\"], \"E\": [\"w\"]}) == {}\n    assert candidate([(\"A\", \"B\")], {}) == {}\n", "language": "python"}
{"task_id": "revision1a_problem314", "prompt": "def encrypt_message(message: str, shift: int) -> str:\n    \"\"\"\n    Implement a Caesar cipher encryption function that takes a message and a shift value as input.\n    The function should encrypt the message by shifting each letter in the alphabet by the given shift value.\n    Ignore spaces and punctuation. Preserve the case of the original message.\n    Use a combination of list comprehension and the ord() and chr() functions.\n\n    Example:\n    Input: \"Hello, World!\", 3\n    Output: \"Khoor, Zruog!\"\n\n    Input: \"Python is fun\", 7\n    Output: \"Wfaovu pz mbu\"\n    \"\"\"\n", "entry_point": "encrypt_message", "solution": "    def shift_char(char: str, shift: int) -> str:\n        if char.isalpha():\n            ascii_offset = ord('A') if char.isupper() else ord('a')\n            return chr((ord(char) - ascii_offset + shift) % 26 + ascii_offset)\n        return char\n\n    return ''.join([shift_char(char, shift) for char in message])\n", "test": "def check(candidate):\n    assert candidate(\"lowercase\", 1) == 'mpxfsdbtf'\n    assert candidate(\"UPPERCASE\", 5) == 'ZUUJWHFXJ'\n    assert candidate(\"Single\", 0) == 'Single'\n    assert candidate(\"!@#$%^&*()_+\", 4) == '!@#$%^&*()_+'\n    assert candidate(\"1234567890\", 8) == '1234567890'\n    assert candidate(\"Hello, World!\", 3) == 'Khoor, Zruog!'\n    assert candidate(\"Wrap Around\", 26) == 'Wrap Around'\n    assert candidate(\"\", 10) == ''\n    assert candidate(\"Mixed Case\", 13) == 'Zvkrq Pnfr'\n    assert candidate(\"Python is fun\", 7) == 'Wfaovu pz mbu'\n", "language": "python"}
{"task_id": "revision1a_problem573", "prompt": "import math\n\ndef calculate_orbit(mass: float, radius: float) -> float:\n    \"\"\"\n    As a planetary scientist, you're studying a newly discovered exoplanet. \n    You need to calculate the orbital period of this planet around its star.\n    \n    The orbital period T (in seconds) of a planet can be calculated using the formula:\n    T = 2\u03c0 * sqrt(r^3 / (G * M))\n    \n    Where:\n    r is the orbital radius in meters\n    M is the mass of the star in kg\n    G is the gravitational constant (6.67430 \u00d7 10^-11 m^3 kg^-1 s^-2)\n    \n    Write a function that takes the mass of the star (in solar masses) and the orbital radius \n    (in astronomical units) as inputs, and returns the orbital period in Earth years.\n    \n    Note: \n    1 solar mass = 1.989 \u00d7 10^30 kg\n    1 astronomical unit (AU) = 1.496 \u00d7 10^11 m\n    1 Earth year = 365.25 days = 31,557,600 seconds\n    \n    Round the result to 2 decimal places.\n\n    Example:\n    Input: 1.0, 1.0 (Earth orbiting the Sun)\n    Output: 1.00\n    Input: 0.1, 0.1 (A planet orbiting a red dwarf)\n    Output: 0.10\n    \"\"\"\n", "entry_point": "calculate_orbit", "solution": "    # Constants\n    G = 6.67430e-11  # Gravitational constant in m^3 kg^-1 s^-2\n    SOLAR_MASS = 1.989e30  # kg\n    AU = 1.496e11  # m\n    EARTH_YEAR = 31557600  # seconds\n\n    # Convert inputs to SI units\n    mass_kg = mass * SOLAR_MASS\n    radius_m = radius * AU\n\n    # Calculate orbital period in seconds\n    T = 2 * math.pi * math.sqrt((radius_m ** 3) / (G * mass_kg))\n\n    # Convert orbital period to Earth years\n    T_years = T / EARTH_YEAR\n\n    # Round to 2 decimal places\n    return round(T_years, 2)\n", "test": "def check(candidate):\n    assert candidate(3.0, 3.0) == 3.0\n    assert candidate(0.3, 0.5) == 0.65\n    assert candidate(0.05, 5.0) == 49.99\n    assert candidate(1.0, 1.0) == 1.0\n    assert candidate(2.0, 1.5) == 1.3\n    assert candidate(0.1, 0.1) == 0.1\n    assert candidate(0.5, 2.0) == 4.0\n    assert candidate(1.5, 0.8) == 0.58\n    assert candidate(0.8, 1.2) == 1.47\n    assert candidate(5.0, 0.1) == 0.01\n", "language": "python"}
{"task_id": "revision1a_problem358", "prompt": "from typing import List, Dict\nimport heapq\n\ndef network_latency(nodes: int, connections: List[List[int]], queries: List[List[int]]) -> List[int]:\n    \"\"\"\n    You're a network engineer tasked with analyzing the latency in a computer network.\n\n    The network consists of 'nodes' number of computers, numbered from 0 to nodes-1.\n    'connections' is a list where each element [a, b, t] represents a bidirectional \n    connection between computers a and b with latency t milliseconds.\n\n    You need to process 'queries', where each query [s, d] asks for the minimum \n    latency between source computer s and destination computer d.\n\n    Implement Dijkstra's algorithm using a priority queue (heap) to efficiently \n    compute the minimum latency for each query.\n\n    Return a list of minimum latencies corresponding to each query.\n\n    Example:\n    Input: \n    nodes = 4\n    connections = [[0,1,10], [0,2,15], [1,2,5], [1,3,12], [2,3,8]]\n    queries = [[0,3], [2,0], [1,2]]\n\n    Output: [20, 15, 5]\n    \"\"\"\n", "entry_point": "network_latency", "solution": "    def build_graph(nodes: int, connections: List[List[int]]) -> Dict[int, List[tuple]]:\n        graph = {i: [] for i in range(nodes)}\n        for a, b, t in connections:\n            graph[a].append((b, t))\n            graph[b].append((a, t))\n        return graph\n\n    def dijkstra(graph: Dict[int, List[tuple]], start: int) -> List[int]:\n        distances = [float('inf')] * len(graph)\n        distances[start] = 0\n        pq = [(0, start)]\n\n        while pq:\n            current_dist, current_node = heapq.heappop(pq)\n\n            if current_dist > distances[current_node]:\n                continue\n\n            for neighbor, weight in graph[current_node]:\n                distance = current_dist + weight\n                if distance < distances[neighbor]:\n                    distances[neighbor] = distance\n                    heapq.heappush(pq, (distance, neighbor))\n\n        return distances\n\n    graph = build_graph(nodes, connections)\n    result = []\n\n    for start, end in queries:\n        distances = dijkstra(graph, start)\n        result.append(distances[end])\n\n    return result\n", "test": "def check(candidate):\n    assert candidate(4, [[0,1,10], [0,2,15], [1,2,5], [1,3,12], [2,3,8]], [[0,3], [2,0], [1,2]]) == [22, 15, 5]\n    assert candidate(4, [[0,1,1], [1,2,1], [2,3,1], [3,0,1]], [[0,2], [1,3], [3,1]]) == [2, 2, 2]\n    assert candidate(6, [[0,1,5], [1,2,5], [2,3,5], [3,4,5], [4,5,5], [5,0,5]], [[0,3], [2,5], [1,4]]) == [15, 15, 15]\n    assert candidate(3, [[0,1,5], [1,2,5], [0,2,10]], [[0,2], [2,1], [1,0]]) == [10, 5, 5]\n    assert candidate(5, [[0,1,1], [1,2,2], [2,3,3], [3,4,4]], [[0,4], [4,0], [2,3]]) == [10, 10, 3]\n    assert candidate(10, [[i,i+1,1] for i in range(9)], [[0,9], [9,0], [4,7]]) == [9, 9, 3]\n    assert candidate(1, [], [[0,0]]) == [0]\n    assert candidate(6, [[0,1,1], [1,2,1], [2,3,1], [3,4,1], [4,5,1]], [[0,5], [5,0], [2,4]]) == [5, 5, 2]\n    assert candidate(2, [[0,1,100]], [[0,1], [1,0]]) == [100, 100]\n    assert candidate(5, [[0,1,1], [0,2,2], [0,3,3], [0,4,4]], [[1,4], [2,3], [4,1]]) == [5, 5, 5]\n", "language": "python"}
{"task_id": "revision1a_problem250", "prompt": "from datetime import datetime, timedelta\n\ndef calculate_fine(return_date: str, due_date: str) -> str:\n    \"\"\"\n    A library wants to implement an automated system to calculate fines for overdue books.\n    The fine structure is as follows:\n    - If returned on or before the due date: No fine\n    - Up to 7 days late: $1 per day\n    - 8 to 30 days late: $2 per day\n    - More than 30 days late: $3 per day plus $50 flat fee\n    \n    Dates are in the format \"YYYY-MM-DD\".\n    If the return date is earlier than or equal to the due date, return \"No fine\".\n    Otherwise, return the fine amount as a string preceded by \"$\".\n    If there's an error in date format or calculation, return an appropriate error message.\n    \n    Example 1:\n    Input: \"2023-05-15\", \"2023-05-10\"\n    Output: \"$5\"\n    \n    Example 2:\n    Input: \"2023-06-20\", \"2023-05-15\"\n    Output: \"$120\"\n    \n    Example 3:\n    Input: \"2023-05-01\", \"2023-05-15\"\n    Output: \"No fine\"\n    \"\"\"\n", "entry_point": "calculate_fine", "solution": "    try:\n        # Convert string dates to datetime objects\n        return_date = datetime.strptime(return_date, \"%Y-%m-%d\")\n        due_date = datetime.strptime(due_date, \"%Y-%m-%d\")\n        \n        # Calculate the difference in days\n        days_late = (return_date - due_date).days\n        \n        # If returned on or before the due date\n        if days_late <= 0:\n            return \"No fine\"\n        \n        # Calculate fine based on days late\n        if days_late <= 7:\n            fine = days_late * 1\n        elif days_late <= 30:\n            fine = days_late * 2\n        else:\n            fine = days_late * 3 + 50\n        \n        return f\"${fine}\"\n    \n    except ValueError:\n        return \"Error: Invalid date format. Please use YYYY-MM-DD.\"\n    except Exception as e:\n        return f\"Error: An unexpected error occurred - {str(e)}\"\n", "test": "def check(candidate):\n    assert candidate(\"2023-05-22\", \"2023-05-15\") == '$7'\n    assert candidate(\"2023-06-14\", \"2023-05-15\") == '$60'\n    assert candidate(\"2024-05-15\", \"2023-05-15\") == '$1148'\n    assert candidate(\"2023-12-31\", \"2023-12-25\") == '$6'\n    assert candidate(\"2023-06-15\", \"2023-05-15\") == '$143'\n    assert candidate(\"2024-01-01\", \"2023-12-31\") == '$1'\n    assert candidate(\"2023-05-14\", \"2023-05-15\") == 'No fine'\n    assert candidate(\"2023-05-16\", \"2023-05-15\") == '$1'\n    assert candidate(\"2023-07-15\", \"2023-05-15\") == '$233'\n    assert candidate(\"2023-05-15\", \"2023-05-15\") == 'No fine'\n", "language": "python"}
{"task_id": "revision1a_problem24", "prompt": "from typing import List\n\ndef longest_balanced_substring(s: str) -> int:\n    \"\"\"\n    In a text editor, you're working on a string of parentheses. You want to find the length of the longest \n    balanced substring of parentheses.\n\n    A balanced string of parentheses is one where every opening parenthesis '(' has a corresponding closing \n    parenthesis ')' and vice versa, and the substring of parentheses between them is also balanced.\n\n    Take the input string from the user and return the length of the longest balanced substring.\n\n    Example:\n    Input: \"((())()(()\"\n    Output: 6\n\n    Input: \")()())((()))\"\n    Output: 6\n    \"\"\"\n", "entry_point": "longest_balanced_substring", "solution": "    def is_balanced(substring):\n        stack = []\n        for char in substring:\n            if char == '(':\n                stack.append(char)\n            elif char == ')':\n                if not stack:\n                    return False\n                stack.pop()\n        return len(stack) == 0\n\n    n = len(s)\n    max_length = 0\n\n    for i in range(n):\n        for j in range(i + 2, n + 1, 2):  # Ensure even-length substrings\n            substring = s[i:j]\n            if is_balanced(substring):\n                max_length = max(max_length, j - i)\n\n    return max_length\n", "test": "def check(candidate):\n    assert candidate(\"()\") == 2\n    assert candidate(\"()()()()()())\") == 12\n    assert candidate(\"((())\") == 4\n    assert candidate(\")(\") == 0\n    assert candidate(\"())\") == 2\n    assert candidate(\"((((((())\") == 4\n    assert candidate(\")()())((()))\") == 6\n    assert candidate(\"((())()(()\") == 6\n    assert candidate(\"(())\") == 4\n    assert candidate(\"\") == 0\n", "language": "python"}
{"task_id": "revision1a_problem16", "prompt": "import math\n\ndef calculate_orbit(mass: float, radius: float) -> tuple:\n    \"\"\"\n    As a space mission planner, you need to calculate the orbital period and velocity of a satellite around a celestial body.\n\n    Given the mass of the celestial body (in kg) and the radius of the orbit (in meters), calculate the orbital period (in seconds) and orbital velocity (in m/s) of the satellite.\n\n    Use the formulas:\n    Orbital period: T = 2\u03c0 * sqrt(r^3 / (G * M))\n    Orbital velocity: v = sqrt((G * M) / r)\n\n    Where:\n    G is the gravitational constant (6.67430 x 10^-11 N(m/kg)^2)\n    M is the mass of the celestial body\n    r is the radius of the orbit\n\n    Round the results to 2 decimal places.\n\n    If the mass or radius is negative or zero, return None for both values.\n\n    Example:\n    Input: 5.97e24, 6.37e6 (Earth's mass and radius)\n    Output: (5060.85, 7905.78)\n\n    Input: 7.34e22, 1.74e6 (Moon's mass and radius)\n    Output: (6765.08, 1680.51)\n    \"\"\"\n", "entry_point": "calculate_orbit", "solution": "    # Check if mass or radius is negative or zero\n    if mass <= 0 or radius <= 0:\n        return None, None\n\n    # Gravitational constant\n    G = 6.67430e-11\n\n    # Calculate orbital period\n    T = 2 * math.pi * math.sqrt(radius**3 / (G * mass))\n\n    # Calculate orbital velocity\n    v = math.sqrt((G * mass) / radius)\n\n    # Round results to 2 decimal places\n    T_rounded = round(T, 2)\n    v_rounded = round(v, 2)\n\n    return T_rounded, v_rounded\n", "test": "def check(candidate):\n    assert candidate(6.39e23, 3.39e6) == (6005.18, 3546.94)\n    assert candidate(7.34e22, 1.74e6) == (6515.58, 1677.94)\n    assert candidate(8.68e25, 2.55e7) == (10629.86, 15072.75)\n    assert candidate(1.024e26, 2.47e7) == (9329.8, 16634.29)\n    assert candidate(5.68e26, 5.82e7) == (14328.06, 25522.05)\n    assert candidate(5.97e24, 6.37e6) == (5060.56, 7908.98)\n    assert candidate(1.0, 1.0) == (769089.72, 0.0)\n    assert candidate(1.989e30, 1.496e11) == (31554187.75, 29788.9)\n    assert candidate(1.898e27, 6.99e7) == (10316.79, 42570.86)\n    assert candidate(1e10, 1e5) == (243207524.08, 0.0)\n", "language": "python"}
{"task_id": "revision1a_problem713", "prompt": "from typing import List, Tuple\n\ndef optimize_warehouse(items: List[Tuple[int, int]], capacity: int) -> Tuple[int, List[int]]:\n    \"\"\"\n    I'm designing an inventory management system for a warehouse.\n    The warehouse has a limited weight capacity, and we need to maximize the value of items we can store.\n    Each item has a weight and a value associated with it.\n    Take input from the user for N items, where each item is represented by (weight, value),\n    and the total weight capacity of the warehouse.\n    Return the maximum total value that can be stored and the list of item indices to be included.\n    Few points to note:\n    1. Items are indexed from 0 to N-1.\n    2. You can't take a fraction of an item, either take it completely or don't take it.\n    3. Try to use dynamic programming (0/1 Knapsack approach) to solve this problem efficiently.\n    Example:\n    Input: [(10, 60), (20, 100), (30, 120)], 50\n    Output: (220, [1, 2])\n    \"\"\"\n", "entry_point": "optimize_warehouse", "solution": "    n = len(items)\n    \n    # Create a 2D table for dynamic programming\n    dp = [[0 for _ in range(capacity + 1)] for _ in range(n + 1)]\n    \n    # Fill the dp table\n    for i in range(1, n + 1):\n        for w in range(capacity + 1):\n            if items[i-1][0] <= w:\n                dp[i][w] = max(dp[i-1][w], dp[i-1][w-items[i-1][0]] + items[i-1][1])\n            else:\n                dp[i][w] = dp[i-1][w]\n    \n    # Backtrack to find the items included\n    included_items = []\n    w = capacity\n    for i in range(n, 0, -1):\n        if dp[i][w] != dp[i-1][w]:\n            included_items.append(i - 1)\n            w -= items[i-1][0]\n    \n    included_items.reverse()\n    \n    return (dp[n][capacity], included_items)\n", "test": "def check(candidate):\n    assert candidate([(10, 60), (20, 100), (30, 120)], 50) == (220, [1, 2])\n    assert candidate([(1, 1)], 1) == (1, [0])\n    assert candidate([(1, 10), (2, 20), (3, 30)], 100) == (60, [0, 1, 2])\n    assert candidate([], 100) == (0, [])\n    assert candidate([(1, 1), (2, 2), (3, 3), (4, 4), (5, 5)], 15) == (15, [0, 1, 2, 3, 4])\n    assert candidate([(100, 1), (1, 100)], 99) == (100, [1])\n    assert candidate([(10, 100), (20, 200), (30, 300)], 0) == (0, [])\n    assert candidate([(10, 10), (10, 20), (10, 30), (10, 40)], 20) == (70, [2, 3])\n    assert candidate([(5, 10), (4, 40), (6, 30), (3, 50)], 10) == (90, [1, 3])\n    assert candidate([(50, 100), (50, 100), (50, 100)], 100) == (200, [0, 1])\n", "language": "python"}
{"task_id": "revision1a_problem635", "prompt": "import math\nfrom typing import List, Tuple\n\ndef optimize_delivery_routes(warehouses: List[Tuple[float, float]], customers: List[Tuple[float, float]], max_distance: float) -> List[List[int]]:\n    \"\"\"\n    A logistics company wants to optimize its delivery routes. They have multiple warehouses and customers spread across a city.\n    Each warehouse can serve customers within a certain radius to ensure timely deliveries.\n\n    Your task is to assign customers to warehouses while minimizing the number of warehouses used and ensuring no customer is left unserved.\n\n    Parameters:\n    warehouses: A list of (x, y) coordinates representing warehouse locations.\n    customers: A list of (x, y) coordinates representing customer locations.\n    max_distance: The maximum allowed distance between a warehouse and its assigned customers.\n\n    Returns:\n    A list of lists, where each sublist contains the indices of customers assigned to a particular warehouse.\n    The warehouse index corresponds to the index in the 'warehouses' list.\n\n    Example:\n    Input: \n    warehouses = [(0, 0), (10, 10), (20, 20)]\n    customers = [(1, 2), (3, 4), (11, 12), (15, 16), (21, 22)]\n    max_distance = 5\n\n    Output: [[0, 1], [2], [3, 4]]\n\n    This problem requires knowledge of geometric calculations, clustering algorithms, and optimization techniques.\n    \"\"\"\n", "entry_point": "optimize_delivery_routes", "solution": "    def calculate_distance(point1: Tuple[float, float], point2: Tuple[float, float]) -> float:\n        return math.sqrt((point1[0] - point2[0])**2 + (point1[1] - point2[1])**2)\n\n    def find_nearest_warehouse(customer: Tuple[float, float], warehouses: List[Tuple[float, float]]) -> int:\n        min_distance = float('inf')\n        nearest_warehouse = -1\n        for i, warehouse in enumerate(warehouses):\n            distance = calculate_distance(customer, warehouse)\n            if distance <= max_distance and distance < min_distance:\n                min_distance = distance\n                nearest_warehouse = i\n        return nearest_warehouse\n\n    assignments = [[] for _ in range(len(warehouses))]\n    unassigned_customers = []\n\n    for i, customer in enumerate(customers):\n        nearest_warehouse = find_nearest_warehouse(customer, warehouses)\n        if nearest_warehouse != -1:\n            assignments[nearest_warehouse].append(i)\n        else:\n            unassigned_customers.append(i)\n\n    # Try to assign unassigned customers to the nearest warehouse, even if it's beyond max_distance\n    for customer_index in unassigned_customers:\n        customer = customers[customer_index]\n        min_distance = float('inf')\n        nearest_warehouse = -1\n        for i, warehouse in enumerate(warehouses):\n            distance = calculate_distance(customer, warehouse)\n            if distance < min_distance:\n                min_distance = distance\n                nearest_warehouse = i\n        assignments[nearest_warehouse].append(customer_index)\n\n    # Remove empty warehouse assignments\n    assignments = [assignment for assignment in assignments if assignment]\n\n    return assignments\n", "test": "def check(candidate):\n    assert candidate([(0, 0), (100, 100)], [(1, 1), (99, 99)], 2) == [[0], [1]]\n    assert candidate([(0, 0)], [(0, 1), (0, 2), (0, 3), (0, 4), (0, 5)], 5) == [[0, 1, 2, 3, 4]]\n    assert candidate([(0, 0)], [(1, 0), (0, 1), (-1, 0), (0, -1)], 1.1) == [[0, 1, 2, 3]]\n    assert candidate([(1, 1), (2, 2), (3, 3)], [(1, 1), (2, 2), (3, 3)], 0.1) == [[0], [1], [2]]\n    assert candidate([(0, 0), (10, 10)], [(5, 5)], 7) == [[0]]\n    assert candidate([], [], 10) == []\n    assert candidate([(0, 0), (10, 0), (0, 10), (10, 10)], [(5, 5)], 7.1) == [[0]]\n    assert candidate([(0, 0)], [(1, 1), (2, 2), (3, 3)], 5) == [[0, 1, 2]]\n    assert candidate([(0, 0), (10, 10), (20, 20)], [(1, 2), (3, 4), (11, 12), (15, 16), (21, 22)], 5) == [[0, 1], [2], [4, 3]]\n    assert candidate([(0, 0)], [(10, 10)], 9) == [[0]]\n", "language": "python"}
{"task_id": "revision1a_problem645", "prompt": "from typing import List, Dict, Any\n\ndef analyze_book_sales(sales_data: List[Dict[str, Any]]) -> str:\n    \"\"\"\n    Your task is to create a Python program that analyzes book sales data for a publishing company.\n    The program should take a list of dictionaries as input, where each dictionary represents a book sale\n    and contains information such as the book title, author, price, and number of copies sold.\n\n    The program should perform the following analyses:\n    1. Calculate the total revenue from all book sales.\n    2. Identify the best-selling book (by number of copies sold).\n    3. Calculate the average price of books sold.\n    4. Determine the author with the highest total revenue.\n\n    Return a formatted string containing the results of the analysis.\n\n    Example:\n    Input: [\n        {\"title\": \"Python Basics\", \"author\": \"John Doe\", \"price\": 29.99, \"copies_sold\": 1000},\n        {\"title\": \"Advanced AI\", \"author\": \"Jane Smith\", \"price\": 49.99, \"copies_sold\": 750},\n        {\"title\": \"Data Science 101\", \"author\": \"John Doe\", \"price\": 39.99, \"copies_sold\": 1200}\n    ]\n    Output: \"Total Revenue: $97,987.50\n    Best-selling Book: Data Science 101\n    Average Book Price: $39.99\n    Author with Highest Revenue: John Doe\"\n\n    Input: [\n        {\"title\": \"Web Development\", \"author\": \"Alice Johnson\", \"price\": 34.99, \"copies_sold\": 500},\n        {\"title\": \"Machine Learning\", \"author\": \"Bob Williams\", \"price\": 54.99, \"copies_sold\": 300}\n    ]\n    Output: \"Total Revenue: $34,192.00\n    Best-selling Book: Web Development\n    Average Book Price: $44.99\n    Author with Highest Revenue: Alice Johnson\"\n    \"\"\"\n", "entry_point": "analyze_book_sales", "solution": "    total_revenue = 0\n    best_selling_book = \"\"\n    max_copies_sold = 0\n    total_price = 0\n    author_revenue = {}\n\n    for book in sales_data:\n        revenue = book['price'] * book['copies_sold']\n        total_revenue += revenue\n        total_price += book['price']\n\n        if book['copies_sold'] > max_copies_sold:\n            max_copies_sold = book['copies_sold']\n            best_selling_book = book['title']\n\n        author = book['author']\n        if author in author_revenue:\n            author_revenue[author] += revenue\n        else:\n            author_revenue[author] = revenue\n\n    average_price = total_price / len(sales_data)\n    author_highest_revenue = max(author_revenue, key=author_revenue.get)\n\n    result = f\"Total Revenue: ${total_revenue:.2f}\\n\"\n    result += f\"Best-selling Book: {best_selling_book}\\n\"\n    result += f\"Average Book Price: ${average_price:.2f}\\n\"\n    result += f\"Author with Highest Revenue: {author_highest_revenue}\"\n\n    return result\n", "test": "def check(candidate):\n    assert candidate([{\"title\": \"Single Book\", \"author\": \"Lone Author\", \"price\": 15.99, \"copies_sold\": 1000}]) == 'Total Revenue: $15990.00\\nBest-selling Book: Single Book\\nAverage Book Price: $15.99\\nAuthor with Highest Revenue: Lone Author'\n    assert candidate([{\"title\": \"Web Development\", \"author\": \"Alice Johnson\", \"price\": 34.99, \"copies_sold\": 500}, {\"title\": \"Machine Learning\", \"author\": \"Bob Williams\", \"price\": 54.99, \"copies_sold\": 300}]) == 'Total Revenue: $33992.00\\nBest-selling Book: Web Development\\nAverage Book Price: $44.99\\nAuthor with Highest Revenue: Alice Johnson'\n    assert candidate([{\"title\": \"Book A\", \"author\": \"Author X\", \"price\": 10.00, \"copies_sold\": 100}, {\"title\": \"Book B\", \"author\": \"Author Y\", \"price\": 20.00, \"copies_sold\": 50}, {\"title\": \"Book C\", \"author\": \"Author Z\", \"price\": 30.00, \"copies_sold\": 75}]) == 'Total Revenue: $4250.00\\nBest-selling Book: Book A\\nAverage Book Price: $20.00\\nAuthor with Highest Revenue: Author Z'\n    assert candidate([{\"title\": \"Expensive Book\", \"author\": \"Rich Writer\", \"price\": 999.99, \"copies_sold\": 1}, {\"title\": \"Cheap Book\", \"author\": \"Frugal Writer\", \"price\": 0.99, \"copies_sold\": 1000}]) == 'Total Revenue: $1989.99\\nBest-selling Book: Cheap Book\\nAverage Book Price: $500.49\\nAuthor with Highest Revenue: Rich Writer'\n    assert candidate([{\"title\": \"Free Book\", \"author\": \"Generous Author\", \"price\": 0.00, \"copies_sold\": 10000}]) == 'Total Revenue: $0.00\\nBest-selling Book: Free Book\\nAverage Book Price: $0.00\\nAuthor with Highest Revenue: Generous Author'\n    assert candidate([{\"title\": \"Book 1\", \"author\": \"Author A\", \"price\": 9.99, \"copies_sold\": 10}, {\"title\": \"Book 2\", \"author\": \"Author A\", \"price\": 19.99, \"copies_sold\": 20}]) == 'Total Revenue: $499.70\\nBest-selling Book: Book 2\\nAverage Book Price: $14.99\\nAuthor with Highest Revenue: Author A'\n    assert candidate([{\"title\": \"Python Basics\", \"author\": \"John Doe\", \"price\": 29.99, \"copies_sold\": 1000}, {\"title\": \"Advanced AI\", \"author\": \"Jane Smith\", \"price\": 49.99, \"copies_sold\": 750}, {\"title\": \"Data Science 101\", \"author\": \"John Doe\", \"price\": 39.99, \"copies_sold\": 1200}]) == 'Total Revenue: $115470.50\\nBest-selling Book: Data Science 101\\nAverage Book Price: $39.99\\nAuthor with Highest Revenue: John Doe'\n    assert candidate([{\"title\": \"Book X\", \"author\": \"Author X\", \"price\": 25.00, \"copies_sold\": 100}, {\"title\": \"Book Y\", \"author\": \"Author Y\", \"price\": 25.00, \"copies_sold\": 100}]) == 'Total Revenue: $5000.00\\nBest-selling Book: Book X\\nAverage Book Price: $25.00\\nAuthor with Highest Revenue: Author X'\n    assert candidate([{\"title\": \"Bestseller\", \"author\": \"Famous Author\", \"price\": 29.99, \"copies_sold\": 1000000}]) == 'Total Revenue: $29990000.00\\nBest-selling Book: Bestseller\\nAverage Book Price: $29.99\\nAuthor with Highest Revenue: Famous Author'\n    assert candidate([{\"title\": \"Book 1\", \"author\": \"Author A\", \"price\": 10.00, \"copies_sold\": 100}, {\"title\": \"Book 2\", \"author\": \"Author B\", \"price\": 20.00, \"copies_sold\": 50}, {\"title\": \"Book 3\", \"author\": \"Author C\", \"price\": 30.00, \"copies_sold\": 33}, {\"title\": \"Book 4\", \"author\": \"Author D\", \"price\": 40.00, \"copies_sold\": 25}, {\"title\": \"Book 5\", \"author\": \"Author E\", \"price\": 50.00, \"copies_sold\": 20}]) == 'Total Revenue: $4990.00\\nBest-selling Book: Book 1\\nAverage Book Price: $30.00\\nAuthor with Highest Revenue: Author A'\n", "language": "python"}
{"task_id": "revision1a_problem663", "prompt": "from collections import deque\nfrom typing import List, Tuple\n\ndef optimize_delivery_route(warehouses: int, roads: List[List[int]]) -> Tuple[int, List[int]]:\n    \"\"\"\n    A delivery company wants to optimize its route between two major distribution centers.\n    There are several warehouses along the way that can be used as intermediate stops.\n    The goal is to find the route that allows for the maximum cargo capacity while minimizing the number of stops.\n\n    Each road between warehouses has a maximum weight limit for trucks.\n    The company wants to know the maximum cargo weight they can transport and the optimal path to take.\n\n    Input:\n    - warehouses: The total number of warehouses (including start and end points)\n    - roads: A matrix where roads[i][j] represents the weight limit of the road from warehouse i to j.\n             0 means no direct road exists between the warehouses.\n\n    Return a tuple containing:\n    1. The maximum cargo weight that can be transported\n    2. A list representing the optimal path (warehouse indices)\n\n    Use the Ford-Fulkerson algorithm or a similar max-flow algorithm to solve this problem.\n\n    Example:\n    Input: 5, [\n        [0, 10, 5, 15, 0],\n        [0, 0, 4, 0, 10],\n        [0, 0, 0, 3, 6],\n        [0, 0, 0, 0, 8],\n        [0, 0, 0, 0, 0]\n    ]\n    Output: (13, [0, 1, 4])\n    \"\"\"\n", "entry_point": "optimize_delivery_route", "solution": "    def bfs(graph, source, sink, parent):\n        visited = [False] * warehouses\n        queue = deque()\n        queue.append(source)\n        visited[source] = True\n        \n        while queue:\n            u = queue.popleft()\n            for v in range(warehouses):\n                if not visited[v] and graph[u][v] > 0:\n                    queue.append(v)\n                    visited[v] = True\n                    parent[v] = u\n                    if v == sink:\n                        return True\n        return False\n\n    def ford_fulkerson(graph, source, sink):\n        parent = [-1] * warehouses\n        max_flow = 0\n\n        while bfs(graph, source, sink, parent):\n            path_flow = float('inf')\n            s = sink\n            while s != source:\n                path_flow = min(path_flow, graph[parent[s]][s])\n                s = parent[s]\n\n            max_flow += path_flow\n\n            v = sink\n            while v != source:\n                u = parent[v]\n                graph[u][v] -= path_flow\n                graph[v][u] += path_flow\n                v = parent[v]\n\n        return max_flow\n\n    def find_path(graph, source, sink):\n        stack = [(source, [source])]\n        while stack:\n            (node, path) = stack.pop()\n            for next_node in range(warehouses):\n                if graph[node][next_node] > 0 and next_node not in path:\n                    if next_node == sink:\n                        return path + [next_node]\n                    else:\n                        stack.append((next_node, path + [next_node]))\n        return []\n\n    graph = [row[:] for row in roads]\n    max_cargo = ford_fulkerson(graph, 0, warehouses - 1)\n    optimal_path = find_path(graph, 0, warehouses - 1)\n\n    return max_cargo, optimal_path\n", "test": "def check(candidate):\n    assert candidate(3, [[0, 5, 10], [0, 0, 8], [0, 0, 0]]) == (15, [])\n    assert candidate(5, [[0, 10, 5, 15, 0], [0, 0, 4, 0, 10], [0, 0, 0, 3, 6], [0, 0, 0, 0, 8], [0, 0, 0, 0, 0]]) == (23, [])\n    assert candidate(3, [[0, 5, 0], [0, 0, 5], [0, 0, 0]]) == (5, [])\n    assert candidate(5, [[0, 20, 0, 0, 0], [0, 0, 15, 0, 0], [0, 0, 0, 10, 0], [0, 0, 0, 0, 5], [0, 0, 0, 0, 0]]) == (5, [])\n    assert candidate(4, [[0, 10, 10, 10], [0, 0, 10, 10], [0, 0, 0, 10], [0, 0, 0, 0]]) == (30, [])\n    assert candidate(4, [[0, 10, 5, 15], [0, 0, 4, 0], [0, 0, 0, 3], [0, 0, 0, 0]]) == (18, [])\n    assert candidate(3, [[0, 100, 100], [0, 0, 100], [0, 0, 0]]) == (200, [])\n    assert candidate(6, [[0, 10, 5, 15, 0, 0], [0, 0, 4, 0, 10, 0], [0, 0, 0, 3, 6, 0], [0, 0, 0, 0, 8, 5], [0, 0, 0, 0, 0, 12], [0, 0, 0, 0, 0, 0]]) == (17, [])\n    assert candidate(4, [[0, 1, 1, 1], [0, 0, 1, 1], [0, 0, 0, 1], [0, 0, 0, 0]]) == (3, [])\n    assert candidate(2, [[0, 10], [0, 0]]) == (10, [])\n", "language": "python"}
{"task_id": "revision1a_problem49", "prompt": "from typing import List\n\ndef max_profit_job_scheduling(start_times: List[int], end_times: List[int], profits: List[int]) -> int:\n    \"\"\"\n    You're a freelancer with various job offers. Each job has a start time, end time, and associated profit.\n    You want to maximize your total profit, but you can't work on overlapping jobs.\n    \n    Implement a function that takes three lists: start times, end times, and profits of jobs,\n    and returns the maximum profit you can make.\n    \n    Note:\n    1. All three input lists have the same length.\n    2. Start time and end time are inclusive (you can start a new job at the exact end time of the previous job).\n    3. Use dynamic programming to solve this problem efficiently.\n    \n    Example 1:\n    Input: \n    start_times = [1, 2, 3, 3]\n    end_times = [3, 4, 5, 6]\n    profits = [50, 10, 40, 70]\n    Output: 120\n    Explanation: The optimal selection is jobs 0 and 3 (profit 50 + 70 = 120)\n    \n    Example 2:\n    Input:\n    start_times = [1, 2, 3, 4, 6]\n    end_times = [3, 5, 10, 6, 9]\n    profits = [20, 20, 100, 70, 60]\n    Output: 150\n    Explanation: The optimal selection is jobs 1 and 4 (profit 20 + 130 = 150)\n    \"\"\"\n", "entry_point": "max_profit_job_scheduling", "solution": "    \n    # Combine start times, end times, and profits into a list of tuples\n    jobs = sorted(zip(start_times, end_times, profits), key=lambda x: x[1])\n    \n    n = len(jobs)\n    dp = [0] * (n + 1)\n    \n    for i in range(1, n + 1):\n        current_profit = jobs[i-1][2]\n        \n        # Binary search to find the latest non-overlapping job\n        left, right = 0, i - 1\n        while left < right:\n            mid = (left + right + 1) // 2\n            if jobs[mid][1] <= jobs[i-1][0]:\n                left = mid\n            else:\n                right = mid - 1\n        \n        if jobs[left][1] <= jobs[i-1][0]:\n            current_profit += dp[left + 1]\n        \n        # Update dp with the maximum profit\n        dp[i] = max(dp[i-1], current_profit)\n    \n    return dp[n]\n", "test": "def check(candidate):\n    assert candidate([1, 1, 1, 1, 1], [2, 3, 4, 5, 6], [5, 4, 3, 2, 1]) == 5\n    assert candidate([1, 3, 5, 7, 9], [2, 4, 6, 8, 10], [10, 20, 30, 40, 50]) == 150\n    assert candidate([1, 2, 3, 4, 5], [2, 3, 4, 5, 6], [1, 2, 3, 4, 5]) == 15\n    assert candidate([1, 1, 1], [2, 2, 2], [10, 20, 30]) == 30\n    assert candidate([1, 3, 5], [2, 4, 6], [50, 50, 50]) == 150\n    assert candidate([1, 2, 3, 3], [3, 4, 5, 6], [50, 10, 40, 70]) == 120\n    assert candidate([1], [2], [100]) == 100\n    assert candidate([1, 2, 3], [4, 5, 6], [5, 6, 7]) == 7\n    assert candidate([1, 2, 3, 4, 5], [6, 7, 8, 9, 10], [100, 200, 300, 400, 500]) == 500\n    assert candidate([1, 2, 3, 4, 6], [3, 5, 10, 6, 9], [20, 20, 100, 70, 60]) == 150\n", "language": "python"}
{"task_id": "revision1a_problem463", "prompt": "import sys\nfrom typing import List, Tuple\n\ndef optimize_delivery_route(n: int, distances: List[List[int]], time_windows: List[Tuple[int, int]]) -> List[int]:\n    \"\"\"\n    A delivery company wants to optimize its route for n customers. Each customer has a specific time window for delivery.\n    The goal is to find the optimal route that visits all customers within their time windows while minimizing the total distance traveled.\n\n    Parameters:\n    n (int): Number of customers\n    distances (List[List[int]]): An n x n matrix where distances[i][j] represents the distance between customer i and j\n    time_windows (List[Tuple[int, int]]): A list of tuples where each tuple (start, end) represents the time window for each customer\n\n    Returns:\n    List[int]: The optimal route as a list of customer indices, or an empty list if no valid route exists\n\n    This problem combines elements of the Traveling Salesman Problem and scheduling with time windows, making it NP-hard.\n    You may want to consider using dynamic programming with bitmasks or a constraint programming approach.\n\n    Example:\n    Input: \n    n = 4\n    distances = [[0, 10, 15, 20], [10, 0, 35, 25], [15, 35, 0, 30], [20, 25, 30, 0]]\n    time_windows = [(0, 5), (3, 7), (8, 12), (10, 14)]\n    Output: [0, 1, 3, 2]  # This route visits all customers within their time windows\n    \"\"\"\n", "entry_point": "optimize_delivery_route", "solution": "    \n    # Initialize memoization table\n    memo = {}\n    \n    def dp(mask: int, pos: int, time: int) -> Tuple[int, List[int]]:\n        if mask == (1 << n) - 1:\n            return distances[pos][0], [0]\n        \n        if (mask, pos, time) in memo:\n            return memo[(mask, pos, time)]\n        \n        best_cost = sys.maxsize\n        best_path = []\n        \n        for next_pos in range(n):\n            if mask & (1 << next_pos) == 0:\n                new_time = time + distances[pos][next_pos]\n                if new_time <= time_windows[next_pos][1]:\n                    wait_time = max(0, time_windows[next_pos][0] - new_time)\n                    cost, path = dp(mask | (1 << next_pos), next_pos, new_time + wait_time)\n                    total_cost = distances[pos][next_pos] + wait_time + cost\n                    if total_cost < best_cost:\n                        best_cost = total_cost\n                        best_path = [next_pos] + path\n        \n        memo[(mask, pos, time)] = (best_cost, best_path)\n        return best_cost, best_path\n    \n    # Start the route from customer 0\n    cost, path = dp(1, 0, 0)\n    \n    if cost == sys.maxsize:\n        return []  # No valid route exists\n    \n    return [0] + path  # Add the starting point (0) to the path\n\n", "test": "def check(candidate):\n    assert candidate(2, [[0, 1], [1, 0]], [(0, 2), (1, 3)]) == [0, 1, 0]\n    assert candidate(4, [[0, 1, 1, 1], [1, 0, 1, 1], [1, 1, 0, 1], [1, 1, 1, 0]], [(0, 1), (0, 1), (0, 1), (0, 1)]) == []\n    assert candidate(3, [[0, 1, 2], [1, 0, 3], [2, 3, 0]], [(0, 3), (2, 5), (4, 7)]) == [0, 1, 2, 0]\n    assert candidate(5, [[0, 1, 2, 3, 4], [1, 0, 5, 6, 7], [2, 5, 0, 8, 9], [3, 6, 8, 0, 10], [4, 7, 9, 10, 0]], [(0, 2), (1, 3), (2, 4), (3, 5), (4, 6)]) == []\n    assert candidate(3, [[0, 10, 20], [10, 0, 30], [20, 30, 0]], [(0, 5), (10, 15), (20, 25)]) == []\n    assert candidate(3, [[0, 100, 200], [100, 0, 300], [200, 300, 0]], [(0, 10), (5, 15), (10, 20)]) == []\n    assert candidate(5, [[0]*5 for _ in range(5)], [(i, i+1) for i in range(5)]) == [0, 1, 2, 3, 4, 0]\n    assert candidate(1, [[0]], [(0, 1)]) == [0, 0]\n    assert candidate(4, [[0, 10, 15, 20], [10, 0, 35, 25], [15, 35, 0, 30], [20, 25, 30, 0]], [(0, 5), (3, 7), (8, 12), (10, 14)]) == []\n    assert candidate(2, [[0, 1000], [1000, 0]], [(0, 5), (995, 1000)]) == [0, 1, 0]\n", "language": "python"}
{"task_id": "revision1a_problem577", "prompt": "from typing import List\n\ndef optimal_study_schedule(subjects: List[str], time_required: List[int], deadlines: List[int]) -> List[str]:\n    \"\"\"\n    As a student preparing for final exams, you need to create an optimal study schedule. \n    You have a list of subjects, the time required to study each subject, and their respective deadlines.\n    Your task is to determine the order in which you should study the subjects to maximize the number of subjects you can complete before their deadlines.\n\n    The function should take three lists as input:\n    - subjects: A list of strings representing the subject names.\n    - time_required: A list of integers representing the time (in hours) required to study each subject.\n    - deadlines: A list of integers representing the number of hours left until the deadline for each subject.\n\n    The function should return a list of subject names in the optimal order to study them.\n\n    Use dynamic programming to solve this problem efficiently.\n    Expected Time Complexity: O(N^2), where N is the number of subjects.\n\n    Example:\n    Input: \n    subjects = [\"Math\", \"Physics\", \"Chemistry\", \"Biology\"]\n    time_required = [4, 3, 2, 5]\n    deadlines = [6, 8, 4, 7]\n    Output: [\"Chemistry\", \"Physics\", \"Math\", \"Biology\"]\n\n    Input:\n    subjects = [\"History\", \"Literature\", \"Economics\", \"Psychology\"]\n    time_required = [3, 4, 2, 5]\n    deadlines = [5, 7, 3, 8]\n    Output: [\"Economics\", \"History\", \"Literature\", \"Psychology\"]\n    \"\"\"\n", "entry_point": "optimal_study_schedule", "solution": "    n = len(subjects)\n    \n    # Create a list of tuples (subject, time_required, deadline)\n    subject_info = list(zip(subjects, time_required, deadlines))\n    \n    # Sort the subjects based on deadlines\n    subject_info.sort(key=lambda x: x[2])\n    \n    # Initialize the dp table\n    dp = [[0] * (n + 1) for _ in range(n + 1)]\n    \n    # Fill the dp table\n    for i in range(1, n + 1):\n        for j in range(1, n + 1):\n            if subject_info[i-1][1] <= subject_info[j-1][2]:\n                dp[i][j] = max(dp[i-1][j], dp[i-1][j-1] + 1)\n            else:\n                dp[i][j] = dp[i-1][j]\n    \n    # Backtrack to find the optimal schedule\n    schedule = []\n    i, j = n, n\n    while i > 0 and j > 0:\n        if dp[i][j] != dp[i-1][j]:\n            schedule.append(subject_info[i-1][0])\n            j -= 1\n        i -= 1\n    \n    # Reverse the schedule to get the correct order\n    return schedule[::-1]\n", "test": "def check(candidate):\n    assert candidate([\"Physics\", \"Chemistry\", \"Biology\", \"Math\", \"English\"], [3, 2, 4, 5, 1], [5, 4, 7, 8, 3]) == ['English', 'Chemistry', 'Physics', 'Biology', 'Math']\n    assert candidate([\"A\", \"B\", \"C\", \"D\", \"E\", \"F\"], [1, 2, 3, 4, 5, 6], [2, 3, 4, 5, 6, 7]) == ['A', 'B', 'C', 'D', 'E', 'F']\n    assert candidate([\"Subject1\"], [5], [6]) == ['Subject1']\n    assert candidate([\"Economics\", \"Business\", \"Accounting\"], [4, 3, 2], [5, 4, 3]) == ['Accounting', 'Business', 'Economics']\n    assert candidate([\"Music\", \"Dance\", \"Drama\", \"Painting\"], [2, 3, 1, 4], [3, 5, 2, 6]) == ['Drama', 'Music', 'Dance', 'Painting']\n    assert candidate([\"History\", \"Geography\", \"Civics\", \"Economics\", \"Sociology\"], [3, 2, 1, 4, 5], [4, 3, 2, 5, 6]) == ['Civics', 'Geography', 'History', 'Economics', 'Sociology']\n    assert candidate([\"Computer Science\", \"Statistics\", \"Calculus\"], [6, 4, 5], [8, 7, 9]) == ['Statistics', 'Computer Science', 'Calculus']\n    assert candidate([\"Biology\", \"Geography\", \"Art\"], [5, 2, 1], [6, 3, 2]) == ['Art', 'Geography', 'Biology']\n    assert candidate([\"Math\", \"Physics\", \"Chemistry\"], [2, 3, 1], [3, 4, 2]) == ['Chemistry', 'Math', 'Physics']\n    assert candidate([\"English\", \"Spanish\", \"French\", \"German\"], [4, 3, 2, 5], [6, 5, 4, 7]) == ['French', 'Spanish', 'English', 'German']\n", "language": "python"}
{"task_id": "revision1a_problem740", "prompt": "from typing import List\n\ndef min_cost_connect_points(points: List[List[int]]) -> int:\n    \"\"\"\n    A city planner wants to connect all points in a 2D plane with the minimum total cost.\n    \n    You are given an array 'points' representing integer coordinates of some points on a 2D-plane, where points[i] = [xi, yi].\n    \n    The cost of connecting two points [xi, yi] and [xj, yj] is the manhattan distance between them: |xi - xj| + |yi - yj|.\n    \n    Return the minimum cost to make all points connected. All points should be connected, and there should be no cycles in the connections.\n    \n    Implement Kruskal's algorithm using a disjoint-set data structure to solve this problem efficiently.\n    \n    Take the list of points as input from the user and return the minimum cost to connect all points.\n    \n    Example:\n    Input: [[0,0],[2,2],[3,10],[5,2],[7,0]]\n    Output: 20\n    \"\"\"\n", "entry_point": "min_cost_connect_points", "solution": "    \n    def find(parent, i):\n        if parent[i] != i:\n            parent[i] = find(parent, parent[i])\n        return parent[i]\n\n    def union(parent, rank, x, y):\n        xroot = find(parent, x)\n        yroot = find(parent, y)\n\n        if rank[xroot] < rank[yroot]:\n            parent[xroot] = yroot\n        elif rank[xroot] > rank[yroot]:\n            parent[yroot] = xroot\n        else:\n            parent[yroot] = xroot\n            rank[xroot] += 1\n\n    def manhattan_distance(p1, p2):\n        return abs(p1[0] - p2[0]) + abs(p1[1] - p2[1])\n\n    n = len(points)\n    edges = []\n\n    for i in range(n):\n        for j in range(i+1, n):\n            dist = manhattan_distance(points[i], points[j])\n            edges.append((dist, i, j))\n\n    edges.sort()\n\n    parent = list(range(n))\n    rank = [0] * n\n    min_cost = 0\n    edges_used = 0\n\n    for edge in edges:\n        cost, u, v = edge\n        x = find(parent, u)\n        y = find(parent, v)\n\n        if x != y:\n            union(parent, rank, x, y)\n            min_cost += cost\n            edges_used += 1\n\n        if edges_used == n - 1:\n            break\n\n    return min_cost\n", "test": "def check(candidate):\n    assert candidate([[0,0],[1,0],[2,0],[3,0],[4,0]]) == 4\n    assert candidate([[1,1],[2,2],[3,3],[4,4],[5,5]]) == 8\n    assert candidate([[0,0],[100,100],[-100,-100]]) == 400\n    assert candidate([[0,0],[0,1],[0,2],[0,3],[0,4]]) == 4\n    assert candidate([[0,0],[1,1],[2,2],[3,3],[4,4],[5,5],[6,6]]) == 12\n    assert candidate([[0,0],[1,1],[2,2]]) == 4\n    assert candidate([[0,0],[2,2],[3,10],[5,2],[7,0]]) == 20\n    assert candidate([[-1,-1],[1,1],[-1,1],[1,-1]]) == 6\n    assert candidate([[0,0]]) == 0\n    assert candidate([[0,0],[0,1],[1,0],[1,1]]) == 3\n", "language": "python"}
{"task_id": "revision1a_problem679", "prompt": "import heapq\nfrom typing import List\n\ndef optimize_solar_panel_placement(roof_dimensions: List[int], panel_sizes: List[List[int]]) -> int:\n    \"\"\"\n    As a solar energy consultant, I need to maximize the number of solar panels that can be installed on a rectangular roof.\n    Given the dimensions of the roof (length and width) and a list of available solar panel sizes (each panel's length and width),\n    determine the maximum number of panels that can be installed without overlapping and without exceeding the roof's dimensions.\n    Panels can be rotated 90 degrees if needed.\n    Take input from the user for the roof dimensions and the list of panel sizes, and return the maximum number of panels that can be installed.\n    Try to solve this problem in O(n log n) time complexity, where n is the number of panel sizes.\n    Example:\n    Input: [10, 12], [[3, 2], [4, 5], [2, 4], [6, 3]]\n    Output: 8\n    Input: [8, 9], [[3, 3], [4, 4], [5, 2]]\n    Output: 6\n    \"\"\"\n", "entry_point": "optimize_solar_panel_placement", "solution": "    def count_panels(roof_length: int, roof_width: int, panel_length: int, panel_width: int) -> int:\n        horizontal = (roof_length // panel_length) * (roof_width // panel_width)\n        vertical = (roof_length // panel_width) * (roof_width // panel_length)\n        return max(horizontal, vertical)\n\n    roof_length, roof_width = roof_dimensions\n    max_panels = 0\n\n    # Sort panel sizes by area in descending order\n    panel_sizes.sort(key=lambda x: x[0] * x[1], reverse=True)\n\n    for panel_length, panel_width in panel_sizes:\n        panels = count_panels(roof_length, roof_width, panel_length, panel_width)\n        max_panels = max(max_panels, panels)\n\n    return max_panels\n", "test": "def check(candidate):\n    assert candidate([50, 60], [[10, 15], [12, 18], [20, 25], [30, 35]]) == 20\n    assert candidate([25, 25], [[5, 5], [10, 10], [15, 15]]) == 25\n    assert candidate([8, 9], [[3, 3], [4, 4], [5, 2]]) == 6\n    assert candidate([15, 10], [[2, 2], [3, 3], [4, 4], [5, 5]]) == 35\n    assert candidate([5, 5], [[1, 1], [2, 2], [3, 3]]) == 25\n    assert candidate([18, 24], [[3, 4], [6, 8], [9, 12]]) == 36\n    assert candidate([30, 40], [[5, 10], [8, 12], [15, 20]]) == 24\n    assert candidate([100, 100], [[10, 10], [20, 20], [25, 25], [50, 50]]) == 100\n    assert candidate([10, 12], [[3, 2], [4, 5], [2, 4], [6, 3]]) == 20\n    assert candidate([20, 20], [[5, 5], [4, 4], [3, 3]]) == 36\n", "language": "python"}
{"task_id": "revision1a_problem187", "prompt": "from typing import List, Dict\n\ndef analyze_stock_portfolio(portfolio: Dict[str, int], prices: Dict[str, float]) -> Dict[str, float]:\n    \"\"\"\n    You are a financial analyst tasked with evaluating an investment portfolio.\n\n    Given a dictionary representing a stock portfolio (where keys are stock symbols and values are the number of shares owned)\n    and another dictionary containing the current prices of stocks (where keys are stock symbols and values are prices per share),\n    calculate the total value of each stock holding and the overall portfolio value.\n\n    Return a dictionary where keys are stock symbols and values are the total value of that stock holding,\n    with an additional key 'Total' representing the total portfolio value.\n\n    Example:\n\n    Input: \n    portfolio = {'AAPL': 50, 'GOOGL': 20, 'MSFT': 30}\n    prices = {'AAPL': 150.75, 'GOOGL': 2500.50, 'MSFT': 300.25}\n\n    Output: \n    {'AAPL': 7537.5, 'GOOGL': 50010.0, 'MSFT': 9007.5, 'Total': 66555.0}\n\n    Input:\n    portfolio = {'TSLA': 10, 'AMZN': 5}\n    prices = {'TSLA': 700.50, 'AMZN': 3200.75}\n\n    Output:\n    {'TSLA': 7005.0, 'AMZN': 16003.75, 'Total': 23008.75}\n    \"\"\"\n", "entry_point": "analyze_stock_portfolio", "solution": "    result = {}\n    total_value = 0.0\n\n    for stock, shares in portfolio.items():\n        if stock in prices:\n            stock_value = shares * prices[stock]\n            result[stock] = stock_value\n            total_value += stock_value\n\n    result['Total'] = total_value\n    return result\n", "test": "def check(candidate):\n    assert candidate({'CRYPTO': 0}, {'CRYPTO': 1000000.00}) == {'CRYPTO': 0.0, 'Total': 0.0}\n    assert candidate({'GOOGL': 1}, {'GOOGL': 2500.50}) == {'GOOGL': 2500.5, 'Total': 2500.5}\n    assert candidate({'A': 10, 'B': 20, 'C': 30}, {'A': 1.00, 'B': 2.00, 'C': 3.00}) == {'A': 10.0, 'B': 40.0, 'C': 90.0, 'Total': 140.0}\n    assert candidate({'ABC': 1, 'DEF': 1}, {'ABC': 0.01, 'DEF': 0.01}) == {'ABC': 0.01, 'DEF': 0.01, 'Total': 0.02}\n    assert candidate({'TSLA': 10, 'AMZN': 5}, {'TSLA': 700.50, 'AMZN': 3200.75}) == {'TSLA': 7005.0, 'AMZN': 16003.75, 'Total': 23008.75}\n    assert candidate({'X': 1, 'Y': 2, 'Z': 3}, {'X': 100.00, 'Y': 200.00, 'Z': 300.00}) == {'X': 100.0, 'Y': 400.0, 'Z': 900.0, 'Total': 1400.0}\n    assert candidate({'AAPL': 50, 'GOOGL': 20, 'MSFT': 30}, {'AAPL': 150.75, 'GOOGL': 2500.50, 'MSFT': 300.25}) == {'AAPL': 7537.5, 'GOOGL': 50010.0, 'MSFT': 9007.5, 'Total': 66555.0}\n    assert candidate({'AAPL': 1000000}, {'AAPL': 150.75}) == {'AAPL': 150750000.0, 'Total': 150750000.0}\n    assert candidate({'XYZ': 100}, {'XYZ': 10.00}) == {'XYZ': 1000.0, 'Total': 1000.0}\n", "language": "python"}
{"task_id": "revision1a_problem652", "prompt": "from typing import List, Dict, Tuple\nfrom collections import defaultdict\n\ndef analyze_social_network(connections: List[Tuple[str, str]], interests: Dict[str, List[str]]) -> Dict[str, List[str]]:\n    \"\"\"\n    A social media platform wants to analyze user connections and suggest new friends based on shared interests.\n\n    Given a list of existing connections between users (as tuples of user IDs) and a dictionary of user interests,\n    determine potential new connections for each user based on the following criteria:\n    1. Users who share at least two interests\n    2. Users who are second-degree connections (friends of friends) and share at least one interest\n\n    Take input from the user for the list of connections and the dictionary of user interests.\n    Return a dictionary where each key is a user ID and the value is a list of suggested new connections (user IDs).\n\n    Example:\n    Input:\n    connections = [(\"user1\", \"user2\"), (\"user2\", \"user3\"), (\"user3\", \"user4\")]\n    interests = {\n        \"user1\": [\"sports\", \"music\", \"travel\"],\n        \"user2\": [\"music\", \"art\", \"food\"],\n        \"user3\": [\"sports\", \"food\", \"technology\"],\n        \"user4\": [\"music\", \"travel\", \"art\"],\n        \"user5\": [\"sports\", \"technology\", \"books\"]\n    }\n    Output:\n    {\n        \"user1\": [\"user4\", \"user5\"],\n        \"user2\": [\"user4\"],\n        \"user3\": [\"user1\", \"user5\"],\n        \"user4\": [\"user1\", \"user2\"],\n        \"user5\": [\"user1\", \"user3\"]\n    }\n    \"\"\"\n", "entry_point": "analyze_social_network", "solution": "    def get_shared_interests(user1, user2):\n        return len(set(interests[user1]) & set(interests[user2]))\n\n    # Build a graph of connections\n    graph = defaultdict(set)\n    for u, v in connections:\n        graph[u].add(v)\n        graph[v].add(u)\n\n    # Find potential connections for each user\n    potential_connections = defaultdict(set)\n    for user in interests:\n        # First-degree connections\n        first_degree = graph[user]\n        \n        # Second-degree connections\n        second_degree = set()\n        for friend in first_degree:\n            second_degree.update(graph[friend])\n        second_degree -= first_degree\n        second_degree.discard(user)\n\n        # Check shared interests\n        for other_user in interests:\n            if other_user != user and other_user not in first_degree:\n                shared = get_shared_interests(user, other_user)\n                if shared >= 2 or (other_user in second_degree and shared >= 1):\n                    potential_connections[user].add(other_user)\n\n    # Convert sets to sorted lists\n    return {user: sorted(connections) for user, connections in potential_connections.items()}\n\n", "test": "def check(candidate):\n    assert candidate([(\"1\", \"2\"), (\"2\", \"3\"), (\"3\", \"4\"), (\"4\", \"5\"), (\"5\", \"1\")], {\"1\": [\"a\", \"b\"], \"2\": [\"b\", \"c\"], \"3\": [\"c\", \"d\"], \"4\": [\"d\", \"e\"], \"5\": [\"e\", \"a\"]}) == {}\n    assert candidate([(\"user1\", \"user2\"), (\"user2\", \"user3\"), (\"user3\", \"user4\")], {\"user1\": [\"sports\", \"music\", \"travel\"], \"user2\": [\"music\", \"art\", \"food\"], \"user3\": [\"sports\", \"food\", \"technology\"], \"user4\": [\"music\", \"travel\", \"art\"], \"user5\": [\"sports\", \"technology\", \"books\"]}) == {'user1': ['user3', 'user4'], 'user2': ['user4'], 'user3': ['user1', 'user5'], 'user4': ['user1', 'user2'], 'user5': ['user3']}\n    assert candidate([(\"A\", \"B\"), (\"B\", \"C\"), (\"C\", \"A\")], {\"A\": [\"1\", \"2\"], \"B\": [\"2\", \"3\"], \"C\": [\"3\", \"1\"], \"D\": [\"1\", \"2\", \"3\"]}) == {'A': ['D'], 'B': ['D'], 'C': ['D'], 'D': ['A', 'B', 'C']}\n    assert candidate([(\"user1\", \"user2\"), (\"user2\", \"user3\")], {\"user1\": [], \"user2\": [], \"user3\": []}) == {}\n    assert candidate([(\"user1\", \"user2\")], {\"user1\": [\"sports\"], \"user2\": [\"music\"], \"user3\": [\"sports\", \"music\"]}) == {}\n    assert candidate([(\"X\", \"Y\")], {\"X\": [\"1\", \"2\", \"3\"], \"Y\": [\"3\", \"4\", \"5\"], \"Z\": [\"1\", \"3\", \"5\"]}) == {'X': ['Z'], 'Y': ['Z'], 'Z': ['X', 'Y']}\n    assert candidate([(\"A\", \"B\"), (\"B\", \"C\"), (\"C\", \"D\"), (\"D\", \"E\")], {\"A\": [\"1\"], \"B\": [\"1\", \"2\"], \"C\": [\"2\", \"3\"], \"D\": [\"3\", \"4\"], \"E\": [\"4\", \"5\"]}) == {}\n    assert candidate([(\"A\", \"B\"), (\"B\", \"C\"), (\"C\", \"D\")], {\"A\": [\"1\", \"2\", \"3\"], \"B\": [\"2\", \"3\", \"4\"], \"C\": [\"3\", \"4\", \"5\"], \"D\": [\"4\", \"5\", \"6\"], \"E\": [\"1\", \"3\", \"5\"]}) == {'A': ['C', 'E'], 'B': ['D'], 'C': ['A', 'E'], 'D': ['B'], 'E': ['A', 'C']}\n    assert candidate([(\"A\", \"B\"), (\"C\", \"D\")], {\"A\": [\"1\", \"2\"], \"B\": [\"2\", \"3\"], \"C\": [\"3\", \"4\"], \"D\": [\"4\", \"5\"], \"E\": [\"1\", \"5\"]}) == {}\n    assert candidate([], {\"user1\": [\"sports\"], \"user2\": [\"music\"]}) == {}\n", "language": "python"}
{"task_id": "revision1a_problem242", "prompt": "from typing import List, Tuple\nimport heapq\n\ndef optimize_delivery_route(packages: List[Tuple[int, int, int]]) -> List[int]:\n    \"\"\"\n    A delivery company wants to optimize its route for delivering packages in a city. \n    Each package has a destination (x, y coordinates) and a priority level.\n    The company wants to deliver higher priority packages first, but also wants to minimize the total distance traveled.\n\n    Write a function that takes a list of tuples, where each tuple contains (x, y, priority) for a package.\n    Return a list of indices representing the optimal order to deliver the packages.\n\n    Use a priority queue (heap) to balance between priority and distance. \n    Calculate distances using Manhattan distance (|x1-x2| + |y1-y2|).\n    Start from the origin (0, 0) and update the current position after each delivery.\n\n    Example:\n    Input: [(1, 2, 3), (3, 4, 1), (0, 5, 2), (5, 1, 1)]\n    Output: [0, 2, 1, 3]\n\n    Explanation: Package 0 has highest priority, then package 2, then choose between 1 and 3 based on distance.\n    \"\"\"\n", "entry_point": "optimize_delivery_route", "solution": "    def manhattan_distance(x1, y1, x2, y2):\n        return abs(x1 - x2) + abs(y1 - y2)\n\n    current_x, current_y = 0, 0\n    n = len(packages)\n    undelivered = [(-(priority * 1000 - manhattan_distance(current_x, current_y, x, y)), i) \n                   for i, (x, y, priority) in enumerate(packages)]\n    heapq.heapify(undelivered)\n\n    result = []\n    while undelivered:\n        _, index = heapq.heappop(undelivered)\n        result.append(index)\n        current_x, current_y, _ = packages[index]\n\n        # Update distances for remaining packages\n        for i in range(len(undelivered)):\n            priority_distance, pkg_index = undelivered[i]\n            x, y, priority = packages[pkg_index]\n            new_distance = manhattan_distance(current_x, current_y, x, y)\n            new_priority_distance = -(priority * 1000 - new_distance)\n            undelivered[i] = (new_priority_distance, pkg_index)\n        \n        heapq.heapify(undelivered)\n\n    return result\n", "test": "def check(candidate):\n    assert candidate([]) == []\n    assert candidate([(-1, -1, 1), (-2, -2, 2), (-3, -3, 3), (-4, -4, 4)]) == [3, 2, 1, 0]\n    assert candidate([(0, 1, 5), (1, 0, 4), (1, 1, 3), (0, 0, 2), (2, 2, 1)]) == [0, 1, 2, 3, 4]\n    assert candidate([(100, 100, 1), (50, 50, 2), (25, 25, 3), (0, 0, 4)]) == [3, 2, 1, 0]\n    assert candidate([(1, 1, 1), (2, 2, 2), (3, 3, 3), (4, 4, 4), (5, 5, 5)]) == [4, 3, 2, 1, 0]\n    assert candidate([(1, 2, 3), (3, 4, 1), (0, 5, 2), (5, 1, 1)]) == [0, 2, 1, 3]\n    assert candidate([(0, 0, 1), (1, 1, 2), (2, 2, 3), (3, 3, 4)]) == [3, 2, 1, 0]\n    assert candidate([(10, 10, 1), (5, 5, 2), (1, 1, 3), (0, 0, 4)]) == [3, 2, 1, 0]\n    assert candidate([(1, 1, 1), (1, 1, 2), (1, 1, 3), (1, 1, 4)]) == [3, 2, 1, 0]\n    assert candidate([(0, 0, 1)]) == [0]\n", "language": "python"}
{"task_id": "revision1a_problem727", "prompt": "import itertools\nimport math\nfrom typing import List, Tuple\n\ndef optimize_delivery_route(locations: List[Tuple[float, float]], fuel_capacity: float, fuel_consumption: float) -> List[int]:\n    \"\"\"\n    A delivery company wants to optimize their route to maximize the number of deliveries while minimizing fuel consumption.\n\n    Given a list of delivery locations as (x, y) coordinates, the fuel capacity of the delivery vehicle, and the fuel consumption rate per unit distance,\n    determine the optimal order of deliveries to make the most stops before running out of fuel.\n\n    The vehicle starts at (0, 0) and must return to this point at the end of the route. Assume that the distance between two points is calculated using\n    Euclidean distance.\n\n    Take input from the user for the list of locations, fuel capacity, and fuel consumption rate. Return the optimal route as a list of indices\n    representing the order of visits to the locations.\n\n    Example:\n    Input: [(1, 2), (3, 4), (-2, 1), (0, 5)], 20.0, 0.1\n    Output: [2, 0, 3, 1]\n\n    This output means the optimal route is: (0, 0) -> (-2, 1) -> (1, 2) -> (0, 5) -> (3, 4) -> (0, 0)\n    \"\"\"\n", "entry_point": "optimize_delivery_route", "solution": "    def calculate_distance(point1: Tuple[float, float], point2: Tuple[float, float]) -> float:\n        return math.sqrt((point1[0] - point2[0])**2 + (point1[1] - point2[1])**2)\n\n    def calculate_route_fuel(route: List[int]) -> float:\n        total_distance = 0\n        prev_point = (0, 0)\n        for idx in route:\n            total_distance += calculate_distance(prev_point, locations[idx])\n            prev_point = locations[idx]\n        total_distance += calculate_distance(prev_point, (0, 0))\n        return total_distance * fuel_consumption\n\n    n = len(locations)\n    max_deliveries = 0\n    optimal_route = []\n\n    for r in range(1, n + 1):\n        for perm in itertools.permutations(range(n), r):\n            fuel_needed = calculate_route_fuel(perm)\n            if fuel_needed <= fuel_capacity and len(perm) > max_deliveries:\n                max_deliveries = len(perm)\n                optimal_route = list(perm)\n\n    return optimal_route\n\n# Example usage:\n# locations = eval(input(\"Enter the list of locations (as a list of tuples): \"))\n# fuel_capacity = float(input(\"Enter the fuel capacity: \"))\n# fuel_consumption = float(input(\"Enter the fuel consumption rate: \"))\n# result = optimize_delivery_route(locations, fuel_capacity, fuel_consumption)\n# print(\"Optimal route:\", result)\n", "test": "def check(candidate):\n    assert candidate([(1, 2), (3, 4), (-2, 1), (0, 5)], 20.0, 0.1) == [0, 1, 2, 3]\n    assert candidate([(-1, -1), (2, 2), (3, -3), (-4, 4)], 30.0, 0.2) == [0, 1, 2, 3]\n    assert candidate([(0, 1), (1, 0), (1, 1)], 10.0, 0.5) == [0, 1, 2]\n    assert candidate([(10, 0), (0, 10), (-10, 0), (0, -10)], 100.0, 0.05) == [0, 1, 2, 3]\n    assert candidate([], 10.0, 0.1) == []\n    assert candidate([(0.5, 0.5), (1.5, 1.5), (2.5, 2.5)], 15.0, 0.3) == [0, 1, 2]\n    assert candidate([(1, 1), (2, 2), (3, 3), (4, 4), (5, 5)], 50.0, 0.1) == [0, 1, 2, 3, 4]\n    assert candidate([(0.1, 0.1), (0.2, 0.2), (0.3, 0.3)], 1.0, 0.01) == [0, 1, 2]\n    assert candidate([(-5, -5), (-4, -4), (-3, -3), (-2, -2), (-1, -1)], 40.0, 0.15) == [0, 1, 2, 3, 4]\n    assert candidate([(1, 1)], 5.0, 0.1) == [0]\n", "language": "python"}
{"task_id": "revision1a_problem434", "prompt": "from typing import List\n\ndef decode_alien_message(encrypted_message: str, codebook: List[tuple]) -> str:\n    \"\"\"\n    You've intercepted an encrypted message from an alien civilization and need to decode it.\n    The aliens use a substitution cipher where each symbol in their language corresponds to a letter in English.\n    You're given the encrypted message as a string and a codebook as a list of tuples, where each tuple contains\n    (alien_symbol, english_letter).\n    Your task is to decode the message using dynamic programming to handle potential ambiguities in the decoding process.\n    Take the encrypted message and codebook as input and return the decoded message in English.\n\n    Example:\n    Input: \"!@#$%\", [('!', 'H'), ('@', 'E'), ('#', 'L'), ('$', 'L'), ('%', 'O'), ('!@', 'W')]\n    Output: \"HELLO\"\n\n    Input: \"&*()_+\", [('&', 'A'), ('*', 'L'), ('(', 'I'), (')', 'E'), ('_', 'N'), ('+', 'S'), ('&*', 'B')]\n    Output: \"ALIENS\"\n    \"\"\"\n", "entry_point": "decode_alien_message", "solution": "    # Create a dictionary from the codebook for easy lookup\n    code_dict = {alien: english for alien, english in codebook}\n    \n    # Initialize the dynamic programming table\n    n = len(encrypted_message)\n    dp = ['' for _ in range(n + 1)]\n    dp[0] = ''\n    \n    # Fill the dynamic programming table\n    for i in range(1, n + 1):\n        for j in range(i):\n            substr = encrypted_message[j:i]\n            if substr in code_dict:\n                if dp[j] != '' or j == 0:\n                    candidate = dp[j] + code_dict[substr]\n                    if dp[i] == '' or len(candidate) < len(dp[i]):\n                        dp[i] = candidate\n    \n    # Return the decoded message\n    return dp[n]\n", "test": "def check(candidate):\n    assert candidate(\"\", []) == ''\n", "language": "python"}
{"task_id": "revision1a_problem533", "prompt": "def encode_decode_message(message: str, operation: str, shift: int) -> str:\n    \"\"\"\n    You're part of a secret spy organization, and you need to encode and decode messages.\n    Create a program that can both encode and decode messages using a Caesar cipher.\n    \n    The Caesar cipher works by shifting each letter in the message by a certain number of positions in the alphabet.\n    For example, with a shift of 3, 'A' would become 'D', 'B' would become 'E', and so on.\n    \n    Your function should take three inputs:\n    1. The message (a string)\n    2. The operation ('encode' or 'decode')\n    3. The shift value (an integer)\n    \n    The function should return the encoded or decoded message as a string.\n    Preserve spaces and punctuation, and wrap around the alphabet (e.g., 'Z' with a shift of 1 becomes 'A').\n    Assume all alphabetic characters in the input are uppercase.\n    \n    Example:\n    Input: \"HELLO WORLD\", \"encode\", 3\n    Output: \"KHOOR ZRUOG\"\n    Input: \"KHOOR ZRUOG\", \"decode\", 3\n    Output: \"HELLO WORLD\"\n    \"\"\"\n", "entry_point": "encode_decode_message", "solution": "    def shift_char(char: str, shift_value: int) -> str:\n        if not char.isalpha():\n            return char\n        \n        ascii_offset = ord('A')\n        shifted = (ord(char) - ascii_offset + shift_value) % 26\n        return chr(shifted + ascii_offset)\n\n    if operation.lower() == 'decode':\n        shift = -shift\n\n    return ''.join(shift_char(char, shift) for char in message)\n", "test": "def check(candidate):\n    assert candidate(\"ZRRG ZR NG ZVQAVTUG\", \"decode\", 13) == 'MEET ME AT MIDNIGHT'\n    assert candidate(\"ATTACK AT DAWN\", \"encode\", 5) == 'FYYFHP FY IFBS'\n    assert candidate(\"FYYFHP FY IFBS\", \"decode\", 5) == 'ATTACK AT DAWN'\n    assert candidate(\"A\", \"decode\", 1) == 'Z'\n    assert candidate(\"Z\", \"encode\", 1) == 'A'\n    assert candidate(\"MEET ME AT MIDNIGHT\", \"encode\", 13) == 'ZRRG ZR NG ZVQAVTUG'\n    assert candidate(\"HELLO WORLD\", \"encode\", 3) == 'KHOOR ZRUOG'\n    assert candidate(\"TOP SECRET\", \"encode\", 0) == 'TOP SECRET'\n    assert candidate(\"ABC XYZ\", \"encode\", 26) == 'ABC XYZ'\n    assert candidate(\"KHOOR ZRUOG\", \"decode\", 3) == 'HELLO WORLD'\n", "language": "python"}
{"task_id": "revision1a_problem642", "prompt": "from typing import List\nimport heapq\n\ndef minimum_network_latency(nodes: int, connections: List[List[int]], start: int) -> List[int]:\n    \"\"\"\n    In a large distributed system, we need to find the minimum latency from a given node to all other nodes in the network.\n    The network is represented as an undirected graph where each edge has a latency value.\n    \n    Take the number of nodes, a list of connections (where each connection is [node1, node2, latency]), and the starting node as input.\n    Return a list where the i-th element is the minimum latency from the start node to node i.\n    \n    Use Dijkstra's algorithm to solve this problem efficiently.\n    \n    Example:\n    Input: \n    nodes = 5\n    connections = [[0,1,10], [0,2,3], [1,2,1], [1,3,2], [2,1,4], [2,3,8], [2,4,2], [3,4,7], [4,3,9]]\n    start = 0\n    \n    Output: [0, 4, 3, 6, 5]\n    \n    This means the minimum latency from node 0 to nodes 0, 1, 2, 3, and 4 are 0, 4, 3, 6, and 5 respectively.\n    \"\"\"\n", "entry_point": "minimum_network_latency", "solution": "    # Create an adjacency list to represent the graph\n    graph = [[] for _ in range(nodes)]\n    for u, v, latency in connections:\n        graph[u].append((v, latency))\n        graph[v].append((u, latency))  # Since it's an undirected graph\n\n    # Initialize distances array with infinity for all nodes except the start node\n    distances = [float('inf')] * nodes\n    distances[start] = 0\n\n    # Priority queue to store nodes to visit (latency, node)\n    pq = [(0, start)]\n\n    while pq:\n        current_latency, current_node = heapq.heappop(pq)\n\n        # If we've found a longer path, skip this node\n        if current_latency > distances[current_node]:\n            continue\n\n        # Check all neighbors of the current node\n        for neighbor, latency in graph[current_node]:\n            new_latency = current_latency + latency\n\n            # If we've found a shorter path, update the distance and add to queue\n            if new_latency < distances[neighbor]:\n                distances[neighbor] = new_latency\n                heapq.heappush(pq, (new_latency, neighbor))\n\n    return distances\n", "test": "def check(candidate):\n    assert candidate(3, [[0,1,5], [1,2,3], [0,2,10]], 0) == [0, 5, 8]\n    assert candidate(6, [[0,1,1], [1,2,1], [2,3,1], [3,4,1], [4,5,1], [5,0,1]], 0) == [0, 1, 2, 3, 2, 1]\n    assert candidate(3, [[0,1,1], [1,2,1], [0,2,3]], 1) == [1, 0, 1]\n    assert candidate(2, [[0,1,1]], 0) == [0, 1]\n    assert candidate(5, [[0,1,10], [0,2,3], [1,2,1], [1,3,2], [2,1,4], [2,3,8], [2,4,2], [3,4,7], [4,3,9]], 0) == [0, 4, 3, 6, 5]\n    assert candidate(5, [[0,1,1], [1,2,2], [2,3,3], [3,4,4], [4,0,5]], 2) == [3, 2, 0, 3, 7]\n    assert candidate(6, [[0,1,2], [1,2,3], [2,3,4], [3,4,5], [4,5,6], [5,0,1]], 0) == [0, 2, 5, 9, 7, 1]\n    assert candidate(4, [[0,1,1], [1,2,2], [2,3,3], [3,0,4]], 0) == [0, 1, 3, 4]\n    assert candidate(4, [[0,1,1], [0,2,2], [0,3,3], [1,2,4], [1,3,5], [2,3,6]], 0) == [0, 1, 2, 3]\n    assert candidate(4, [[0,1,10], [1,2,20], [2,3,30], [3,0,40]], 3) == [40, 50, 30, 0]\n", "language": "python"}
{"task_id": "revision1a_problem282", "prompt": "from typing import List, Tuple\n\ndef optimize_study_schedule(subjects: List[str], durations: List[int], max_time: int) -> Tuple[List[str], int]:\n    \"\"\"\n    A student wants to optimize their study schedule. Given a list of subjects, their corresponding study durations,\n    and a maximum study time, determine the best combination of subjects to study within the time limit.\n    \n    Use dynamic programming to solve this problem (similar to the knapsack problem).\n    Return a tuple containing the list of selected subjects and the total study time.\n\n    Example:\n    Input: \n    subjects = [\"Math\", \"Science\", \"History\", \"English\", \"Art\"]\n    durations = [45, 30, 40, 35, 20]\n    max_time = 100\n\n    Output: ([\"Math\", \"Science\", \"English\"], 110)\n\n    Input:\n    subjects = [\"Physics\", \"Chemistry\", \"Biology\"]\n    durations = [60, 45, 50]\n    max_time = 120\n\n    Output: ([\"Chemistry\", \"Biology\"], 95)\n    \"\"\"\n", "entry_point": "optimize_study_schedule", "solution": "    n = len(subjects)\n    \n    # Create a 2D table for dynamic programming\n    dp = [[0 for _ in range(max_time + 1)] for _ in range(n + 1)]\n    \n    # Fill the dp table\n    for i in range(1, n + 1):\n        for j in range(1, max_time + 1):\n            if durations[i - 1] <= j:\n                dp[i][j] = max(dp[i - 1][j], dp[i - 1][j - durations[i - 1]] + durations[i - 1])\n            else:\n                dp[i][j] = dp[i - 1][j]\n    \n    # Backtrack to find the selected subjects\n    selected_subjects = []\n    total_time = dp[n][max_time]\n    j = max_time\n    \n    for i in range(n, 0, -1):\n        if dp[i][j] != dp[i - 1][j]:\n            selected_subjects.append(subjects[i - 1])\n            j -= durations[i - 1]\n    \n    selected_subjects.reverse()\n    \n    return (selected_subjects, total_time)\n", "test": "def check(candidate):\n    assert candidate([\"X\", \"Y\", \"Z\"], [100, 200, 300], 500) == (['Y', 'Z'], 500)\n    assert candidate([\"Math\", \"English\"], [60, 45], 50) == (['English'], 45)\n    assert candidate([\"Physics\", \"Chemistry\", \"Biology\"], [60, 45, 50], 120) == (['Physics', 'Biology'], 110)\n    assert candidate([\"Math\", \"Science\", \"History\", \"English\", \"Art\"], [45, 30, 40, 35, 20], 100) == (['Math', 'English', 'Art'], 100)\n    assert candidate([\"A\", \"B\", \"C\", \"D\", \"E\"], [10, 20, 30, 40, 50], 60) == (['A', 'B', 'C'], 60)\n    assert candidate([\"A\", \"B\", \"C\"], [10, 10, 10], 30) == (['A', 'B', 'C'], 30)\n    assert candidate([\"S1\", \"S2\", \"S3\", \"S4\", \"S5\"], [30, 30, 30, 30, 30], 90) == (['S1', 'S2', 'S3'], 90)\n    assert candidate([\"Subject1\"], [30], 50) == (['Subject1'], 30)\n    assert candidate([\"Short\", \"Medium\", \"Long\"], [5, 15, 25], 20) == (['Short', 'Medium'], 20)\n    assert candidate([], [], 100) == ([], 0)\n", "language": "python"}
{"task_id": "revision1a_problem198", "prompt": "def decode_alien_message(message: str) -> str:\n    \"\"\"\n    I intercepted an alien message, but it's encoded. Help me decode it!\n    The aliens use a simple substitution cipher where each letter is replaced by the letter that comes \n    3 positions after it in the alphabet (wrapping around from 'Z' back to 'A').\n    Numbers and spaces remain unchanged.\n    Take the encoded message as input from the user and return the decoded message.\n    The input will contain only uppercase letters, numbers, and spaces.\n    \n    Example:\n    Input: \"KHOS ZRUOG 2023\"\n    Output: \"HELLO WORLD 2023\"\n    \n    Hint: 'A' becomes 'D', 'B' becomes 'E', ..., 'X' becomes 'A', 'Y' becomes 'B', 'Z' becomes 'C'.\n    \"\"\"\n", "entry_point": "decode_alien_message", "solution": "    def shift_letter(char: str) -> str:\n        if char.isalpha():\n            ascii_offset = ord('A')\n            shifted = (ord(char) - ascii_offset - 3) % 26\n            return chr(shifted + ascii_offset)\n        return char\n\n    decoded_message = ''.join(shift_letter(char) for char in message)\n    return decoded_message\n", "test": "def check(candidate):\n    assert candidate(\"ABC XYZ\") == 'XYZ UVW'\n    assert candidate(\"VSDFH LQYDGHUV\") == 'SPACE INVADERS'\n    assert candidate(\"CBVHG RQ D WUXH VWRUB\") == 'ZYSED ON A TRUE STORY'\n    assert candidate(\"DWWDFN DW GDZQ\") == 'ATTACK AT DAWN'\n    assert candidate(\"WKH TXLFN EURZQ IRA MXPSV RYHU WKH ODCB GRJ\") == 'THE QUICK BROWN FOX JUMPS OVER THE LAZY DOG'\n    assert candidate(\"KHOS ZRUOG 2023\") == 'HELP WORLD 2023'\n    assert candidate(\"ABCDEFGHIJKLMNOPQRSTUVWXYZ\") == 'XYZABCDEFGHIJKLMNOPQRSTUVW'\n    assert candidate(\"WHVW FDVH\") == 'TEST CASE'\n    assert candidate(\"123 456 789\") == '123 456 789'\n    assert candidate(\"KHOOR IURP PDUV\") == 'HELLO FROM MARS'\n", "language": "python"}
{"task_id": "revision1a_problem493", "prompt": "from typing import List\n\ndef longest_common_subsequence(str1: str, str2: str) -> str:\n    \"\"\"\n    As a bioinformatics researcher, you're working on comparing DNA sequences.\n    You need to find the longest common subsequence (LCS) between two DNA strings.\n    The LCS is the longest sequence of characters that appear in the same order in both strings,\n    but they don't need to be consecutive.\n\n    Implement a function using dynamic programming to find the LCS of two given strings.\n    Take two input strings from the user and return the longest common subsequence.\n\n    Example:\n    Input: \"AGGTAB\", \"GXTXAYB\"\n    Output: \"GTAB\"\n    \n    Input: \"ABCDGH\", \"AEDFHR\"\n    Output: \"ADH\"\n    \"\"\"\n", "entry_point": "longest_common_subsequence", "solution": "    m, n = len(str1), len(str2)\n    \n    # Create a 2D table to store the lengths of LCS\n    dp = [[0] * (n + 1) for _ in range(m + 1)]\n    \n    # Fill the dp table\n    for i in range(1, m + 1):\n        for j in range(1, n + 1):\n            if str1[i-1] == str2[j-1]:\n                dp[i][j] = dp[i-1][j-1] + 1\n            else:\n                dp[i][j] = max(dp[i-1][j], dp[i][j-1])\n    \n    # Backtrack to find the LCS\n    lcs = []\n    i, j = m, n\n    while i > 0 and j > 0:\n        if str1[i-1] == str2[j-1]:\n            lcs.append(str1[i-1])\n            i -= 1\n            j -= 1\n        elif dp[i-1][j] > dp[i][j-1]:\n            i -= 1\n        else:\n            j -= 1\n    \n    # Return the LCS as a string\n    return ''.join(reversed(lcs))\n", "test": "def check(candidate):\n    assert candidate(\"ABC\", \"ABC\") == 'ABC'\n    assert candidate(\"A\", \"A\") == 'A'\n    assert candidate(\"ATGC\", \"CGTA\") == 'C'\n    assert candidate(\"A\", \"\") == ''\n    assert candidate(\"GATTACA\", \"GCATCGA\") == 'GATCA'\n    assert candidate(\"\", \"A\") == ''\n    assert candidate(\"AAAA\", \"AAAA\") == 'AAAA'\n    assert candidate(\"ABCDGH\", \"AEDFHR\") == 'ADH'\n    assert candidate(\"\", \"\") == ''\n    assert candidate(\"AGGTAB\", \"GXTXAYB\") == 'GTAB'\n", "language": "python"}
{"task_id": "revision1a_problem164", "prompt": "from typing import List\n\ndef jump_game(nums: List[int]) -> bool:\n    \"\"\"\n    You're designing a platform game where the player needs to reach the end of a level\n    by jumping from platform to platform. Each number in the input list represents the maximum\n    jump length from that position.\n\n    Write a function that takes a list of non-negative integers representing the maximum jump\n    length at each position, and returns True if it's possible to reach the last index, or False otherwise.\n\n    Example:\n    Input: [2,3,1,1,4]\n    Output: True\n    Explanation: Jump 1 step from index 0 to 1, then 3 steps to the last index.\n    \n    Input: [3,2,1,0,4]\n    Output: False\n    Explanation: You will always arrive at index 3 no matter what. Its maximum jump length is 0, which makes it impossible to reach the last index.\n    \"\"\"\n", "entry_point": "jump_game", "solution": "    n = len(nums)\n    max_reach = 0\n    \n    for i in range(n):\n        if i > max_reach:\n            return False\n        \n        max_reach = max(max_reach, i + nums[i])\n        \n        if max_reach >= n - 1:\n            return True\n    \n    return False\n", "test": "def check(candidate):\n    assert candidate([1]) == True\n    assert candidate([1,0]) == True\n    assert candidate([0]) == True\n    assert candidate([1,2,3,4,5]) == True\n    assert candidate([2,0,0]) == True\n    assert candidate([4,3,2,1,0]) == True\n    assert candidate([3,2,1,0,4]) == False\n    assert candidate([1,1,1,1]) == True\n    assert candidate([5,4,3,2,1,0,0]) == False\n    assert candidate([2,3,1,1,4]) == True\n", "language": "python"}
{"task_id": "revision1a_problem542", "prompt": "from typing import List\n\ndef analyze_stock_data(prices: List[float], dates: List[str]) -> str:\n    \"\"\"\n    Analyze historical stock price data to identify the best buying and selling dates for maximum profit.\n\n    You are given two lists: 'prices' containing daily closing prices of a stock, and 'dates' containing the corresponding dates.\n    Your task is to determine the best day to buy the stock and the best day to sell it in order to maximize profit.\n    If no profit can be made, suggest holding the stock.\n\n    Take input from the user for both lists and return a string with the buy date, sell date, and maximum profit.\n\n    Example:\n    INPUT: \n    prices = [100.0, 180.0, 260.0, 310.0, 40.0, 535.0, 695.0]\n    dates = [\"2023-01-01\", \"2023-01-02\", \"2023-01-03\", \"2023-01-04\", \"2023-01-05\", \"2023-01-06\", \"2023-01-07\"]\n    Output: \"Buy on 2023-01-05, Sell on 2023-01-07, Maximum Profit: $655.0\"\n\n    INPUT:\n    prices = [500.0, 480.0, 460.0, 440.0, 420.0]\n    dates = [\"2023-01-01\", \"2023-01-02\", \"2023-01-03\", \"2023-01-04\", \"2023-01-05\"]\n    Output: \"Hold the stock. No profit can be made.\"\n    \"\"\"\n", "entry_point": "analyze_stock_data", "solution": "    # Input validation\n    if len(prices) != len(dates):\n        return \"Error: The number of prices and dates must be the same.\"\n    \n    if len(prices) < 2:\n        return \"Error: At least two data points are required for analysis.\"\n    \n    # Initialize variables\n    max_profit = 0\n    buy_date = sell_date = None\n    min_price = float('inf')\n    min_date = None\n    \n    # Iterate through the prices and dates\n    for i in range(len(prices)):\n        # Update the minimum price and date\n        if prices[i] < min_price:\n            min_price = prices[i]\n            min_date = dates[i]\n        \n        # Calculate the current profit\n        current_profit = prices[i] - min_price\n        \n        # Update max profit and dates if a better profit is found\n        if current_profit > max_profit:\n            max_profit = current_profit\n            buy_date = min_date\n            sell_date = dates[i]\n    \n    # Check if profit can be made\n    if max_profit > 0:\n        return f\"Buy on {buy_date}, Sell on {sell_date}, Maximum Profit: ${max_profit:.1f}\"\n    else:\n        return \"Hold the stock. No profit can be made.\"\n", "test": "def check(candidate):\n    assert candidate([100.0], [\"2023-01-01\"]) == 'Error: At least two data points are required for analysis.'\n    assert candidate([500.0, 480.0, 460.0, 440.0, 420.0], [\"2023-01-01\", \"2023-01-02\", \"2023-01-03\", \"2023-01-04\", \"2023-01-05\"]) == 'Hold the stock. No profit can be made.'\n    assert candidate([100.0, 100.0, 100.0, 100.0, 100.0], [\"2023-01-01\", \"2023-01-02\", \"2023-01-03\", \"2023-01-04\", \"2023-01-05\"]) == 'Hold the stock. No profit can be made.'\n    assert candidate([10.0, 20.0, 30.0, 40.0, 50.0], [\"2023-01-01\", \"2023-01-02\", \"2023-01-03\", \"2023-01-04\", \"2023-01-05\"]) == 'Buy on 2023-01-01, Sell on 2023-01-05, Maximum Profit: $40.0'\n    assert candidate([0.1, 0.2, 0.3, 0.4, 0.5], [\"2023-01-01\", \"2023-01-02\", \"2023-01-03\", \"2023-01-04\", \"2023-01-05\"]) == 'Buy on 2023-01-01, Sell on 2023-01-05, Maximum Profit: $0.4'\n    assert candidate([100.0, 180.0, 260.0, 310.0, 40.0, 535.0, 695.0], [\"2023-01-01\", \"2023-01-02\", \"2023-01-03\", \"2023-01-04\", \"2023-01-05\", \"2023-01-06\", \"2023-01-07\"]) == 'Buy on 2023-01-05, Sell on 2023-01-07, Maximum Profit: $655.0'\n    assert candidate([2.0, 1.0], [\"2023-01-01\", \"2023-01-02\"]) == 'Hold the stock. No profit can be made.'\n    assert candidate([100.0, 200.0, 150.0, 300.0, 250.0], [\"2023-01-01\", \"2023-01-02\", \"2023-01-03\", \"2023-01-04\", \"2023-01-05\"]) == 'Buy on 2023-01-01, Sell on 2023-01-04, Maximum Profit: $200.0'\n    assert candidate([50.0, 40.0, 30.0, 20.0, 10.0], [\"2023-01-01\", \"2023-01-02\", \"2023-01-03\", \"2023-01-04\", \"2023-01-05\"]) == 'Hold the stock. No profit can be made.'\n    assert candidate([1.0, 2.0], [\"2023-01-01\", \"2023-01-02\"]) == 'Buy on 2023-01-01, Sell on 2023-01-02, Maximum Profit: $1.0'\n", "language": "python"}
{"task_id": "revision1a_problem236", "prompt": "from typing import List, Dict, Any\n\ndef inventory_management(items: List[Dict[str, Any]]) -> Dict[str, Any]:\n    \"\"\"\n    Develop an inventory management system for a small retail store. The system should:\n\n    1. Add new items to the inventory with details like name, price, quantity, and category\n    2. Update existing item details\n    3. Remove items from the inventory\n    4. Display current inventory status\n    5. Calculate total inventory value\n    6. Find items low in stock (quantity < 5)\n    7. Generate a report of items by category\n\n    The function should take a list of dictionaries representing inventory actions and return a dictionary with the results of these actions.\n\n    Example:\n    Input: [\n        {\"action\": \"add\", \"name\": \"T-shirt\", \"price\": 15.99, \"quantity\": 50, \"category\": \"Clothing\"},\n        {\"action\": \"add\", \"name\": \"Jeans\", \"price\": 39.99, \"quantity\": 30, \"category\": \"Clothing\"},\n        {\"action\": \"update\", \"name\": \"T-shirt\", \"quantity\": 45},\n        {\"action\": \"remove\", \"name\": \"Jeans\"},\n        {\"action\": \"add\", \"name\": \"Notebook\", \"price\": 4.99, \"quantity\": 100, \"category\": \"Stationery\"},\n        {\"action\": \"status\"}\n    ]\n    Output: {\n        \"inventory\": [\n            {\"name\": \"T-shirt\", \"price\": 15.99, \"quantity\": 45, \"category\": \"Clothing\"},\n            {\"name\": \"Notebook\", \"price\": 4.99, \"quantity\": 100, \"category\": \"Stationery\"}\n        ],\n        \"total_value\": 1219.55,\n        \"low_stock\": [],\n        \"categories\": {\n            \"Clothing\": [\"T-shirt\"],\n            \"Stationery\": [\"Notebook\"]\n        }\n    }\n\n    This system could be used by small business owners to efficiently manage their product inventory.\n    \"\"\"\n", "entry_point": "inventory_management", "solution": "    inventory = []\n    categories = {}\n\n    def add_item(item):\n        inventory.append(item)\n        category = item['category']\n        if category not in categories:\n            categories[category] = []\n        categories[category].append(item['name'])\n\n    def update_item(name, updates):\n        for item in inventory:\n            if item['name'] == name:\n                item.update(updates)\n                break\n\n    def remove_item(name):\n        for item in inventory:\n            if item['name'] == name:\n                inventory.remove(item)\n                categories[item['category']].remove(item['name'])\n                if not categories[item['category']]:\n                    del categories[item['category']]\n                break\n\n    def get_status():\n        total_value = sum(item['price'] * item['quantity'] for item in inventory)\n        low_stock = [item['name'] for item in inventory if item['quantity'] < 5]\n        return {\n            \"inventory\": inventory,\n            \"total_value\": round(total_value, 2),\n            \"low_stock\": low_stock,\n            \"categories\": categories\n        }\n\n    for action in items:\n        if action['action'] == 'add':\n            add_item({k: v for k, v in action.items() if k != 'action'})\n        elif action['action'] == 'update':\n            update_item(action['name'], {k: v for k, v in action.items() if k not in ['action', 'name']})\n        elif action['action'] == 'remove':\n            remove_item(action['name'])\n        elif action['action'] == 'status':\n            return get_status()\n\n    return get_status()\n", "test": "def check(candidate):\n    assert candidate([{\"action\": \"add\", \"name\": \"Laptop\", \"price\": 999.99, \"quantity\": 10, \"category\": \"Electronics\"}, {\"action\": \"update\", \"name\": \"Laptop\", \"price\": 1099.99}, {\"action\": \"status\"}]) == {'inventory': [{'name': 'Laptop', 'price': 1099.99, 'quantity': 10, 'category': 'Electronics'}], 'total_value': 10999.9, 'low_stock': [], 'categories': {'Electronics': ['Laptop']}}\n    assert candidate([{\"action\": \"add\", \"name\": \"Socks\", \"price\": 5.99, \"quantity\": 4, \"category\": \"Clothing\"}, {\"action\": \"status\"}]) == {'inventory': [{'name': 'Socks', 'price': 5.99, 'quantity': 4, 'category': 'Clothing'}], 'total_value': 23.96, 'low_stock': ['Socks'], 'categories': {'Clothing': ['Socks']}}\n    assert candidate([{\"action\": \"add\", \"name\": \"Notebook\", \"price\": 4.99, \"quantity\": 100, \"category\": \"Stationery\"}, {\"action\": \"remove\", \"name\": \"Notebook\"}, {\"action\": \"status\"}]) == {'inventory': [], 'total_value': 0, 'low_stock': [], 'categories': {}}\n    assert candidate([{\"action\": \"add\", \"name\": \"Shirt\", \"price\": 25.99, \"quantity\": 40, \"category\": \"Clothing\"}, {\"action\": \"add\", \"name\": \"Pants\", \"price\": 35.99, \"quantity\": 30, \"category\": \"Clothing\"}, {\"action\": \"add\", \"name\": \"Shoes\", \"price\": 59.99, \"quantity\": 20, \"category\": \"Footwear\"}, {\"action\": \"status\"}]) == {'inventory': [{'name': 'Shirt', 'price': 25.99, 'quantity': 40, 'category': 'Clothing'}, {'name': 'Pants', 'price': 35.99, 'quantity': 30, 'category': 'Clothing'}, {'name': 'Shoes', 'price': 59.99, 'quantity': 20, 'category': 'Footwear'}], 'total_value': 3319.1, 'low_stock': [], 'categories': {'Clothing': ['Shirt', 'Pants'], 'Footwear': ['Shoes']}}\n    assert candidate([{\"action\": \"add\", \"name\": \"Pencil\", \"price\": 0.99, \"quantity\": 200, \"category\": \"Stationery\"}, {\"action\": \"add\", \"name\": \"Eraser\", \"price\": 0.50, \"quantity\": 150, \"category\": \"Stationery\"}, {\"action\": \"status\"}]) == {'inventory': [{'name': 'Pencil', 'price': 0.99, 'quantity': 200, 'category': 'Stationery'}, {'name': 'Eraser', 'price': 0.5, 'quantity': 150, 'category': 'Stationery'}], 'total_value': 273.0, 'low_stock': [], 'categories': {'Stationery': ['Pencil', 'Eraser']}}\n    assert candidate([{\"action\": \"add\", \"name\": \"Mug\", \"price\": 8.99, \"quantity\": 25, \"category\": \"Kitchenware\"}, {\"action\": \"remove\", \"name\": \"Mug\"}, {\"action\": \"add\", \"name\": \"Mug\", \"price\": 9.99, \"quantity\": 30, \"category\": \"Kitchenware\"}, {\"action\": \"status\"}]) == {'inventory': [{'name': 'Mug', 'price': 9.99, 'quantity': 30, 'category': 'Kitchenware'}], 'total_value': 299.7, 'low_stock': [], 'categories': {'Kitchenware': ['Mug']}}\n    assert candidate([{\"action\": \"add\", \"name\": \"Headphones\", \"price\": 79.99, \"quantity\": 15, \"category\": \"Electronics\"}, {\"action\": \"update\", \"name\": \"Headphones\", \"quantity\": 3}, {\"action\": \"status\"}]) == {'inventory': [{'name': 'Headphones', 'price': 79.99, 'quantity': 3, 'category': 'Electronics'}], 'total_value': 239.97, 'low_stock': ['Headphones'], 'categories': {'Electronics': ['Headphones']}}\n    assert candidate([{\"action\": \"add\", \"name\": \"Jeans\", \"price\": 39.99, \"quantity\": 30, \"category\": \"Clothing\"}, {\"action\": \"update\", \"name\": \"Jeans\", \"quantity\": 25}, {\"action\": \"status\"}]) == {'inventory': [{'name': 'Jeans', 'price': 39.99, 'quantity': 25, 'category': 'Clothing'}], 'total_value': 999.75, 'low_stock': [], 'categories': {'Clothing': ['Jeans']}}\n    assert candidate([{\"action\": \"add\", \"name\": \"T-shirt\", \"price\": 15.99, \"quantity\": 50, \"category\": \"Clothing\"}, {\"action\": \"status\"}]) == {'inventory': [{'name': 'T-shirt', 'price': 15.99, 'quantity': 50, 'category': 'Clothing'}], 'total_value': 799.5, 'low_stock': [], 'categories': {'Clothing': ['T-shirt']}}\n    assert candidate([{\"action\": \"add\", \"name\": \"Book\", \"price\": 12.99, \"quantity\": 50, \"category\": \"Books\"}, {\"action\": \"update\", \"name\": \"Book\", \"quantity\": 0}, {\"action\": \"status\"}]) == {'inventory': [{'name': 'Book', 'price': 12.99, 'quantity': 0, 'category': 'Books'}], 'total_value': 0.0, 'low_stock': ['Book'], 'categories': {'Books': ['Book']}}\n", "language": "python"}
{"task_id": "revision1a_problem572", "prompt": "import math\nfrom typing import List, Tuple\n\ndef optimize_delivery_route(locations: List[Tuple[float, float]], fuel_capacity: float, fuel_consumption: float) -> List[int]:\n    \"\"\"\n    You are a delivery driver trying to optimize your route. You have a list of delivery locations represented\n    as (x, y) coordinates, a fuel capacity for your vehicle, and a fuel consumption rate per unit distance.\n\n    Your task is to find the maximum number of deliveries you can make before running out of fuel, starting\n    from the origin (0, 0) and returning to it after each delivery. You must visit the locations in the order they\n    are given.\n\n    Implement a function that takes:\n    - A list of tuples representing the (x, y) coordinates of delivery locations\n    - The fuel capacity of your vehicle (in liters)\n    - The fuel consumption rate (in liters per unit distance)\n\n    Return a list of indices representing the locations you can visit before running out of fuel.\n\n    Example:\n    Input: [(1, 1), (2, 2), (3, 3), (4, 4)], 20.0, 0.5\n    Output: [0, 1, 2]\n\n    Input: [(0, 5), (3, 4), (2, 1), (6, 8), (4, 2)], 30.0, 0.3\n    Output: [0, 1, 2, 3]\n    \"\"\"\n", "entry_point": "optimize_delivery_route", "solution": "    def distance(x1: float, y1: float, x2: float, y2: float) -> float:\n        return ((x2 - x1) ** 2 + (y2 - y1) ** 2) ** 0.5\n\n    visited = []\n    remaining_fuel = fuel_capacity\n\n    for i, (x, y) in enumerate(locations):\n        dist_to_location = distance(0, 0, x, y)\n        fuel_needed = dist_to_location * 2 * fuel_consumption\n\n        if fuel_needed <= remaining_fuel:\n            visited.append(i)\n            remaining_fuel -= fuel_needed\n        else:\n            break\n\n    return visited\n", "test": "def check(candidate):\n    assert candidate([(10, 10)], 5.0, 0.1) == [0]\n    assert candidate([(1, 1), (2, 2), (3, 3)], 100.0, 0.1) == [0, 1, 2]\n    assert candidate([(1, 1), (2, 2), (3, 3), (4, 4)], 20.0, 0.5) == [0, 1, 2, 3]\n    assert candidate([(1, 0), (2, 0), (3, 0), (4, 0), (5, 0)], 15.0, 0.5) == [0, 1, 2, 3, 4]\n    assert candidate([(1, 1)], 5.0, 0.5) == [0]\n    assert candidate([], 10.0, 1.0) == []\n    assert candidate([(1, 1), (-2, -2), (3, -3), (-4, 4)], 30.0, 0.4) == [0, 1, 2, 3]\n    assert candidate([(5, 5), (10, 10), (15, 15), (20, 20)], 50.0, 0.2) == [0, 1, 2, 3]\n    assert candidate([(0, 5), (3, 4), (2, 1), (6, 8), (4, 2)], 30.0, 0.3) == [0, 1, 2, 3, 4]\n    assert candidate([(0, 1), (0, 2), (0, 3), (0, 4), (0, 5)], 15.0, 0.5) == [0, 1, 2, 3, 4]\n", "language": "python"}
{"task_id": "revision1a_problem467", "prompt": "import heapq\nfrom typing import List, Tuple\n\ndef optimize_network(nodes: int, connections: List[Tuple[int, int, int]]) -> List[Tuple[int, int, int]]:\n    \"\"\"\n    As a network engineer, I need to optimize a company's computer network. The network consists of several nodes \n    (computers) connected by cables. Each cable has a cost associated with it. I want to ensure all nodes are connected \n    while minimizing the total cost of cables used.\n\n    Implement Kruskal's algorithm to find the Minimum Spanning Tree (MST) of the network. The function should take the \n    number of nodes and a list of connections (edges) as input, where each connection is represented as a tuple \n    (node1, node2, cost). Return the list of connections that form the MST.\n\n    Example:\n    Input: 4, [(0,1,10), (0,2,6), (0,3,5), (1,3,15), (2,3,4)]\n    Output: [(2,3,4), (0,3,5), (0,1,10)]\n\n    Note: The output list should be sorted by the cost of the connections in ascending order.\n    \"\"\"\n", "entry_point": "optimize_network", "solution": "    def find(parent, i):\n        if parent[i] == i:\n            return i\n        return find(parent, parent[i])\n\n    def union(parent, rank, x, y):\n        xroot = find(parent, x)\n        yroot = find(parent, y)\n\n        if rank[xroot] < rank[yroot]:\n            parent[xroot] = yroot\n        elif rank[xroot] > rank[yroot]:\n            parent[yroot] = xroot\n        else:\n            parent[yroot] = xroot\n            rank[xroot] += 1\n\n    # Sort connections by cost\n    connections.sort(key=lambda x: x[2])\n\n    parent = list(range(nodes))\n    rank = [0] * nodes\n    mst = []\n    \n    for node1, node2, cost in connections:\n        x = find(parent, node1)\n        y = find(parent, node2)\n\n        if x != y:\n            mst.append((node1, node2, cost))\n            union(parent, rank, x, y)\n\n    # Sort the MST by cost\n    mst.sort(key=lambda x: x[2])\n\n    return mst\n", "test": "def check(candidate):\n    assert candidate(6, [(0,1,1), (1,2,2), (2,3,3), (3,4,4), (4,5,5), (5,0,6)]) == [(0, 1, 1), (1, 2, 2), (2, 3, 3), (3, 4, 4), (4, 5, 5)]\n    assert candidate(5, [(0,1,10), (1,2,20), (2,3,30), (3,4,40), (4,0,50)]) == [(0, 1, 10), (1, 2, 20), (2, 3, 30), (3, 4, 40)]\n    assert candidate(3, [(0,1,5), (1,2,5), (0,2,5)]) == [(0, 1, 5), (1, 2, 5)]\n    assert candidate(2, [(0,1,100)]) == [(0, 1, 100)]\n    assert candidate(7, [(0,1,7), (0,3,5), (1,2,8), (1,3,9), (1,4,7), (2,4,5), (3,4,15), (3,5,6), (4,5,8), (4,6,9), (5,6,11)]) == [(0, 3, 5), (2, 4, 5), (3, 5, 6), (0, 1, 7), (1, 4, 7), (4, 6, 9)]\n    assert candidate(3, [(0,1,1), (1,2,2), (0,2,3)]) == [(0, 1, 1), (1, 2, 2)]\n    assert candidate(4, [(0,1,1), (0,2,1), (0,3,1), (1,2,1), (1,3,1), (2,3,1)]) == [(0, 1, 1), (0, 2, 1), (0, 3, 1)]\n    assert candidate(6, [(0,1,4), (0,2,3), (1,2,1), (1,3,2), (2,3,4), (2,4,3), (3,4,2), (3,5,1), (4,5,5)]) == [(1, 2, 1), (3, 5, 1), (1, 3, 2), (3, 4, 2), (0, 2, 3)]\n    assert candidate(4, [(0,1,10), (0,2,6), (0,3,5), (1,3,15), (2,3,4)]) == [(2, 3, 4), (0, 3, 5), (0, 1, 10)]\n    assert candidate(5, [(0,1,2), (0,3,6), (1,2,3), (1,3,8), (1,4,5), (2,4,7), (3,4,9)]) == [(0, 1, 2), (1, 2, 3), (1, 4, 5), (0, 3, 6)]\n", "language": "python"}
{"task_id": "revision1a_problem20", "prompt": "from typing import List\n\ndef longest_arithmetic_subsequence(nums: List[int]) -> int:\n    \"\"\"\n    You are given a list of integers representing the heights of buildings in a city skyline. Your task is to find the length of the longest arithmetic subsequence in this list.\n\n    An arithmetic subsequence is a subsequence of the original list where the difference between every two consecutive elements is constant.\n\n    Write a function that takes the list of building heights as input and returns the length of the longest arithmetic subsequence.\n\n    Example:\n    Input: [3,6,9,12,15,18,21]\n    Output: 7\n    Explanation: The entire list forms an arithmetic sequence with a common difference of 3.\n\n    Input: [9,4,7,2,10]\n    Output: 3\n    Explanation: The longest arithmetic subsequence is [4,7,10] with a common difference of 3.\n\n    Input: [20,1,15,3,10,5,8]\n    Output: 4\n    Explanation: The longest arithmetic subsequence is [20,15,10,5] with a common difference of -5.\n    \"\"\"\n", "entry_point": "longest_arithmetic_subsequence", "solution": "    n = len(nums)\n    if n <= 2:\n        return n\n\n    dp = [{} for _ in range(n)]\n    max_length = 2\n\n    for i in range(1, n):\n        for j in range(i):\n            diff = nums[i] - nums[j]\n            if diff in dp[j]:\n                dp[i][diff] = dp[j][diff] + 1\n            else:\n                dp[i][diff] = 2\n            max_length = max(max_length, dp[i][diff])\n\n    return max_length\n", "test": "def check(candidate):\n    assert candidate([1,2,3,4,5,6,7,8,9,10]) == 10\n    assert candidate([1,3,5,7,9,11,13,15]) == 8\n    assert candidate([10,7,4,1]) == 4\n    assert candidate([1,2,1,2,1,2,1]) == 4\n    assert candidate([1,5,9,13,17,21,25,29]) == 8\n    assert candidate([1,1,1,1,1]) == 5\n    assert candidate([3,6,9,12,15,18,21]) == 7\n    assert candidate([9,4,7,2,10]) == 3\n    assert candidate([20,1,15,3,10,5,8]) == 4\n    assert candidate([2,4,6,8,10,12,14,16]) == 8\n", "language": "python"}
{"task_id": "revision1a_problem360", "prompt": "import math\nfrom typing import List, Tuple\n\ndef optimize_delivery_routes(warehouses: List[Tuple[float, float]], customers: List[Tuple[float, float]], max_distance: float) -> List[List[int]]:\n    \"\"\"\n    A large e-commerce company wants to optimize its delivery routes. They have multiple warehouses and customers spread across a city.\n    Each warehouse can serve customers within a certain radius to ensure timely delivery.\n\n    Write a function that takes the following inputs:\n    - warehouses: A list of (x, y) coordinates representing warehouse locations.\n    - customers: A list of (x, y) coordinates representing customer locations.\n    - max_distance: The maximum distance a warehouse can serve.\n\n    The function should return a list of lists, where each sublist contains the indices of customers that should be served by each warehouse.\n    Customers that cannot be served by any warehouse (out of range) should be in a separate sublist at the end.\n\n    Use efficient algorithms to handle large datasets and consider edge cases.\n\n    Example:\n    Input: \n    warehouses = [(0, 0), (10, 10)]\n    customers = [(1, 2), (8, 9), (12, 5), (5, 5), (15, 15)]\n    max_distance = 5\n\n    Output: [[0, 3], [1], [2, 4]]\n\n    Explanation: \n    - Warehouse at (0, 0) serves customers at (1, 2) and (5, 5)\n    - Warehouse at (10, 10) serves customer at (8, 9)\n    - Customers at (12, 5) and (15, 15) are out of range and grouped together\n    \"\"\"\n", "entry_point": "optimize_delivery_routes", "solution": "    \n    def calculate_distance(point1: Tuple[float, float], point2: Tuple[float, float]) -> float:\n        return math.sqrt((point1[0] - point2[0])**2 + (point1[1] - point2[1])**2)\n\n    result = [[] for _ in range(len(warehouses) + 1)]\n    \n    for customer_idx, customer in enumerate(customers):\n        min_distance = float('inf')\n        nearest_warehouse = -1\n        \n        for warehouse_idx, warehouse in enumerate(warehouses):\n            distance = calculate_distance(customer, warehouse)\n            if distance <= max_distance and distance < min_distance:\n                min_distance = distance\n                nearest_warehouse = warehouse_idx\n        \n        if nearest_warehouse != -1:\n            result[nearest_warehouse].append(customer_idx)\n        else:\n            result[-1].append(customer_idx)\n    \n    # Remove empty lists\n    result = [sublist for sublist in result if sublist]\n    \n    return result\n", "test": "def check(candidate):\n    assert candidate([(0, 0), (1, 1)], [(0.5, 0.5), (1.5, 1.5)], 1) == [[0], [1]]\n    assert candidate([(0, 0), (10, 0), (0, 10), (10, 10)], [(5, 5), (2, 8), (8, 2), (15, 15)], 7) == [[2], [1], [0, 3]]\n    assert candidate([(0, 0)], [(1, 0), (0, 1), (-1, 0), (0, -1)], 1) == [[0, 1, 2, 3]]\n    assert candidate([(0, 0)], [(0, 0), (0, 5), (5, 0), (5, 5)], 5) == [[0, 1, 2], [3]]\n    assert candidate([(0, 0), (10, 10)], [(1, 2), (8, 9), (12, 5), (5, 5), (15, 15)], 5) == [[0], [1], [2, 3, 4]]\n    assert candidate([(0, 0)], [], 5) == []\n    assert candidate([(0, 0), (5, 5), (10, 10)], [(2, 2), (7, 7), (12, 12)], 3) == [[0], [1], [2]]\n    assert candidate([], [(1, 1), (2, 2), (3, 3)], 5) == [[0, 1, 2]]\n    assert candidate([(0, 0)], [(1, 1), (2, 2), (3, 3), (4, 4), (5, 5)], 3) == [[0, 1], [2, 3, 4]]\n    assert candidate([(0, 0), (100, 100)], [(50, 50)], 70) == [[0]]\n", "language": "python"}
{"task_id": "revision1a_problem735", "prompt": "from typing import List, Tuple\n\ndef optimize_warehouse(items: List[Tuple[str, int, int]]) -> List[str]:\n    \"\"\"\n    A warehouse needs to optimize its storage system based on item frequency and weight.\n    Each item is represented by a tuple containing (name, frequency, weight).\n    The goal is to arrange items in a way that minimizes retrieval time and considers weight constraints.\n\n    The optimization algorithm should follow these rules:\n    1. Items with higher frequency should be placed closer to the front.\n    2. If frequencies are equal, lighter items should be placed first.\n    3. If an item's weight is more than twice the average weight, it should be placed in a separate \"heavy items\" section.\n    4. Items in the \"heavy items\" section should be sorted by frequency, then by weight.\n\n    Return a list of item names in their optimized order.\n\n    Example:\n    Input: [(\"Book\", 10, 2), (\"Chair\", 5, 15), (\"Lamp\", 8, 3), (\"Table\", 3, 25), (\"Pen\", 20, 1)]\n    Output: [\"Pen\", \"Book\", \"Lamp\", \"Chair\", \"Table\"]\n\n    Explanation: \n    - \"Pen\" has the highest frequency and is lightest.\n    - \"Book\" and \"Lamp\" are placed based on their frequency and weight.\n    - \"Chair\" and \"Table\" are in the \"heavy items\" section, sorted by frequency.\n    \"\"\"\n", "entry_point": "optimize_warehouse", "solution": "    \n    def calculate_average_weight(items):\n        total_weight = sum(item[2] for item in items)\n        return total_weight / len(items)\n    \n    average_weight = calculate_average_weight(items)\n    regular_items = []\n    heavy_items = []\n    \n    for item in items:\n        if item[2] > 2 * average_weight:\n            heavy_items.append(item)\n        else:\n            regular_items.append(item)\n    \n    # Sort regular items by frequency (descending) and then by weight (ascending)\n    regular_items.sort(key=lambda x: (-x[1], x[2]))\n    \n    # Sort heavy items by frequency (descending) and then by weight (ascending)\n    heavy_items.sort(key=lambda x: (-x[1], x[2]))\n    \n    # Combine regular and heavy items\n    optimized_items = regular_items + heavy_items\n    \n    # Extract and return item names in the optimized order\n    return [item[0] for item in optimized_items]\n", "test": "def check(candidate):\n    assert candidate([(\"X\", 100, 1), (\"Y\", 1, 100)]) == ['X', 'Y']\n    assert candidate([(\"Item\", 1, 1)] * 10) == ['Item', 'Item', 'Item', 'Item', 'Item', 'Item', 'Item', 'Item', 'Item', 'Item']\n    assert candidate([(\"Apple\", 15, 1), (\"Banana\", 15, 2), (\"Orange\", 15, 1)]) == ['Apple', 'Orange', 'Banana']\n    assert candidate([(\"Heavy\", 1, 1000), (\"Light1\", 2, 1), (\"Light2\", 2, 2)]) == ['Light1', 'Light2', 'Heavy']\n    assert candidate([(\"A\", 1, 1), (\"B\", 2, 2), (\"C\", 3, 3), (\"D\", 4, 4), (\"E\", 5, 5)]) == ['E', 'D', 'C', 'B', 'A']\n    assert candidate([(\"Item1\", 10, 10), (\"Item2\", 10, 11), (\"Item3\", 10, 9)]) == ['Item3', 'Item1', 'Item2']\n    assert candidate([(\"Book\", 10, 2), (\"Chair\", 5, 15), (\"Lamp\", 8, 3), (\"Table\", 3, 25), (\"Pen\", 20, 1)]) == ['Pen', 'Book', 'Lamp', 'Chair', 'Table']\n    assert candidate([(\"A\", 1, 10), (\"B\", 2, 20), (\"C\", 3, 30), (\"D\", 4, 40), (\"E\", 5, 50)]) == ['E', 'D', 'C', 'B', 'A']\n    assert candidate([(\"Single\", 1, 1)]) == ['Single']\n    assert candidate([(\"Heavy1\", 5, 100), (\"Heavy2\", 6, 90), (\"Light\", 1, 1)]) == ['Heavy2', 'Heavy1', 'Light']\n", "language": "python"}
{"task_id": "revision1a_problem197", "prompt": "from typing import List\n\ndef schedule_tasks(tasks: List[tuple], processors: int) -> List[List[tuple]]:\n    \"\"\"\n    You are designing a task scheduler for a multi-processor system. Your goal is to create a Python function that takes a list of tasks and the number of available processors, and returns an optimal schedule that minimizes the total execution time.\n\n    Each task is represented as a tuple containing (task_id, execution_time). The function should distribute the tasks among the processors to minimize the overall completion time.\n\n    Take input as a list of tuples representing tasks and an integer representing the number of processors. Return a list of lists, where each inner list represents the tasks assigned to a processor.\n\n    Example:\n    Input: tasks = [(1, 3), (2, 2), (3, 1), (4, 4), (5, 3)], processors = 2\n    Output: [[(1, 3), (3, 1), (5, 3)], [(2, 2), (4, 4)]]\n\n    Input: tasks = [(1, 2), (2, 4), (3, 3), (4, 1), (5, 5), (6, 2)], processors = 3\n    Output: [[(2, 4), (4, 1)], [(3, 3), (6, 2)], [(1, 2), (5, 5)]]\n    \"\"\"\n", "entry_point": "schedule_tasks", "solution": "    # Sort tasks in descending order of execution time\n    sorted_tasks = sorted(tasks, key=lambda x: x[1], reverse=True)\n    \n    # Initialize processors with empty task lists and total execution times\n    processor_schedules = [[] for _ in range(processors)]\n    processor_times = [0] * processors\n    \n    # Assign tasks to processors using a greedy approach\n    for task in sorted_tasks:\n        # Find the processor with the least total execution time\n        min_time_processor = min(range(processors), key=lambda i: processor_times[i])\n        \n        # Assign the task to the processor with the least total execution time\n        processor_schedules[min_time_processor].append(task)\n        processor_times[min_time_processor] += task[1]\n    \n    return processor_schedules\n", "test": "def check(candidate):\n    assert candidate([(i, i) for i in range(1, 11)], 5) == [[(10, 10), (1, 1)], [(9, 9), (2, 2)], [(8, 8), (3, 3)], [(7, 7), (4, 4)], [(6, 6), (5, 5)]]\n    assert candidate([(1, 3), (2, 2), (3, 1), (4, 4), (5, 3)], 2) == [[(4, 4), (2, 2), (3, 1)], [(1, 3), (5, 3)]]\n    assert candidate([], 5) == [[], [], [], [], []]\n    assert candidate([(1, 100), (2, 200), (3, 300)], 10) == [[(3, 300)], [(2, 200)], [(1, 100)], [], [], [], [], [], [], []]\n    assert candidate([(1, 10), (2, 20), (3, 30), (4, 40)], 2) == [[(4, 40), (1, 10)], [(3, 30), (2, 20)]]\n    assert candidate([(1, 1), (2, 1), (3, 1)], 1) == [[(1, 1), (2, 1), (3, 1)]]\n    assert candidate([(1, 2), (2, 4), (3, 3), (4, 1), (5, 5), (6, 2)], 3) == [[(5, 5), (4, 1)], [(2, 4), (6, 2)], [(3, 3), (1, 2)]]\n    assert candidate([(1, 1)], 1) == [[(1, 1)]]\n    assert candidate([(1, 5), (2, 5), (3, 5), (4, 5)], 4) == [[(1, 5)], [(2, 5)], [(3, 5)], [(4, 5)]]\n    assert candidate([(1, 5), (2, 4), (3, 3), (4, 2), (5, 1)], 3) == [[(1, 5)], [(2, 4), (5, 1)], [(3, 3), (4, 2)]]\n", "language": "python"}
{"task_id": "revision1a_problem296", "prompt": "def decode_alien_message(encoded: str, cipher: str) -> str:\n    \"\"\"\n    An alien civilization has sent us a message, but it's encoded using an unknown substitution cipher.\n    Fortunately, we've intercepted a sample of their language along with its English translation.\n    Your task is to decode the alien message using the provided cipher.\n\n    The cipher is a string where each pair of characters represents a mapping from an alien symbol to an English letter.\n    The encoded message consists only of alien symbols present in the cipher.\n    Assume that the cipher covers all symbols used in the encoded message.\n\n    Write a program that takes the encoded message and the cipher as input, and returns the decoded message in English.\n    If a symbol in the encoded message is not found in the cipher, leave it unchanged in the output.\n\n    Example:\n    Input: \n        Enter encoded message: !@#$%^&*\n        Enter cipher: !a@b#c$d%e^f&g*h\n    Output: abcdefgh\n\n    Input:\n        Enter encoded message: !!@@##$$\n        Enter cipher: !a@b#c$d%e^f&g*h\n    Output: aabbccdd\n    \"\"\"\n", "entry_point": "decode_alien_message", "solution": "    # Create a dictionary to store the alien-to-English mapping\n    cipher_dict = {}\n    \n    # Populate the cipher dictionary\n    for i in range(0, len(cipher), 2):\n        if i + 1 < len(cipher):\n            alien_symbol = cipher[i]\n            english_letter = cipher[i + 1]\n            cipher_dict[alien_symbol] = english_letter\n    \n    # Decode the message\n    decoded_message = \"\"\n    for symbol in encoded:\n        if symbol in cipher_dict:\n            decoded_message += cipher_dict[symbol]\n        else:\n            decoded_message += symbol\n    \n    return decoded_message\n", "test": "def check(candidate):\n    assert candidate(\"!@!@!@\", \"!a@b#c$d%e^f&g*h\") == 'ababab'\n    assert candidate(\"\", \"!a@b#c$d%e^f&g*h\") == ''\n    assert candidate(\"!!@@##$$\", \"!a@b#c$d%e^f&g*h\") == 'aabbccdd'\n    assert candidate(\"abcdef\", \"aAbBcCdDeEfF\") == 'ABCDEF'\n    assert candidate(\"12345\", \"1a2b3c4d5e\") == 'abcde'\n    assert candidate(\"!@#$%^&*()\", \"!a@b#c$d%e^f&g*h()i\") == 'abcdefgh))'\n    assert candidate(\"!@#$%^&*\", \"!a@b#c$d%e^f&g*h\") == 'abcdefgh'\n    assert candidate(\"hello\", \"!a@b#c$d%e^f&g*h\") == 'hello'\n    assert candidate(\"!@#$%^&*\", \"\") == '!@#$%^&*'\n    assert candidate(\"ABCDEF\", \"AaBbCcDdEeFf\") == 'abcdef'\n", "language": "python"}
{"task_id": "revision1a_problem232", "prompt": "def matrix_operations(matrix1: list, matrix2: list, operation: str) -> list:\n    \"\"\"\n    As a data scientist, you often work with matrices for various calculations.\n    \n    Create a function that performs matrix operations based on user input:\n    1. Addition\n    2. Subtraction\n    3. Multiplication\n    4. Element-wise multiplication\n    \n    Use object-oriented programming to create a Matrix class with methods for each operation.\n    Implement proper error handling for invalid inputs (mismatched dimensions, invalid operation).\n    Use type hints and docstrings for better code readability.\n    \n    Example:\n    Input: [[1, 2], [3, 4]], [[5, 6], [7, 8]], \"add\"\n    Output: [[6, 8], [10, 12]]\n    \n    Input: [[1, 2], [3, 4]], [[5, 6], [7, 8]], \"multiply\"\n    Output: [[19, 22], [43, 50]]\n    \n    Input: [[1, 2], [3, 4]], [[5, 6], [7, 8]], \"element_wise\"\n    Output: [[5, 12], [21, 32]]\n    \"\"\"\n", "entry_point": "matrix_operations", "solution": "    class Matrix:\n        def __init__(self, matrix: list):\n            self.matrix = matrix\n            self.rows = len(matrix)\n            self.cols = len(matrix[0]) if self.rows > 0 else 0\n\n        def __add__(self, other: 'Matrix') -> 'Matrix':\n            if self.rows != other.rows or self.cols != other.cols:\n                raise ValueError(\"Matrices must have the same dimensions for addition\")\n            return Matrix([[self.matrix[i][j] + other.matrix[i][j] for j in range(self.cols)] for i in range(self.rows)])\n\n        def __sub__(self, other: 'Matrix') -> 'Matrix':\n            if self.rows != other.rows or self.cols != other.cols:\n                raise ValueError(\"Matrices must have the same dimensions for subtraction\")\n            return Matrix([[self.matrix[i][j] - other.matrix[i][j] for j in range(self.cols)] for i in range(self.rows)])\n\n        def __mul__(self, other: 'Matrix') -> 'Matrix':\n            if self.cols != other.rows:\n                raise ValueError(\"Number of columns in first matrix must equal number of rows in second matrix\")\n            result = [[sum(a * b for a, b in zip(row, col)) for col in zip(*other.matrix)] for row in self.matrix]\n            return Matrix(result)\n\n        def element_wise_multiply(self, other: 'Matrix') -> 'Matrix':\n            if self.rows != other.rows or self.cols != other.cols:\n                raise ValueError(\"Matrices must have the same dimensions for element-wise multiplication\")\n            return Matrix([[self.matrix[i][j] * other.matrix[i][j] for j in range(self.cols)] for i in range(self.rows)])\n\n    try:\n        m1 = Matrix(matrix1)\n        m2 = Matrix(matrix2)\n\n        if operation.lower() == \"add\":\n            result = m1 + m2\n        elif operation.lower() == \"subtract\":\n            result = m1 - m2\n        elif operation.lower() == \"multiply\":\n            result = m1 * m2\n        elif operation.lower() == \"element_wise\":\n            result = m1.element_wise_multiply(m2)\n        else:\n            raise ValueError(\"Invalid operation. Choose 'add', 'subtract', 'multiply', or 'element_wise'\")\n\n        return result.matrix\n    except Exception as e:\n        return str(e)\n", "test": "def check(candidate):\n    assert candidate([[0, 0], [0, 0]], [[1, 1], [1, 1]], \"subtract\") == [[-1, -1], [-1, -1]]\n    assert candidate([[1, 2, 3], [4, 5, 6], [7, 8, 9]], [[9, 8, 7], [6, 5, 4], [3, 2, 1]], \"add\") == [[10, 10, 10], [10, 10, 10], [10, 10, 10]]\n    assert candidate([[1, 2], [3, 4]], [[5, 6], [7, 8]], \"add\") == [[6, 8], [10, 12]]\n    assert candidate([[1, 2, 3], [4, 5, 6]], [[7, 8], [9, 10], [11, 12]], \"multiply\") == [[58, 64], [139, 154]]\n    assert candidate([[1, 2], [3, 4]], [[5, 6], [7, 8]], \"element_wise\") == [[5, 12], [21, 32]]\n    assert candidate([[1]], [[2]], \"element_wise\") == [[2]]\n    assert candidate([[1, 2], [3, 4]], [[5, 6], [7, 8]], \"invalid_operation\") == \"Invalid operation. Choose 'add', 'subtract', 'multiply', or 'element_wise'\"\n    assert candidate([[1, 2], [3, 4]], [[5, 6], [7, 8]], \"multiply\") == [[19, 22], [43, 50]]\n    assert candidate([[1, 2], [3, 4]], [[5, 6], [7, 8]], \"subtract\") == [[-4, -4], [-4, -4]]\n    assert candidate([[1, 2], [3, 4]], [[5, 6]], \"add\") == 'Matrices must have the same dimensions for addition'\n", "language": "python"}
{"task_id": "revision1a_problem482", "prompt": "def decode_ways(s: str) -> int:\n    \"\"\"\n    A cryptographer is working on decoding messages where letters are represented by numbers.\n    'A' is represented as 1, 'B' as 2, and so on up to 'Z' as 26.\n    Given a string of digits, determine the total number of ways to decode it.\n\n    Take input from the user as a string of digits and return the number of possible decodings.\n    The input is guaranteed to be valid (only digits, and able to be decoded).\n\n    Example:\n    Input: \"12\"\n    Output: 2\n    Explanation: It could be decoded as \"AB\" (1 2) or \"L\" (12)\n\n    Input: \"226\"\n    Output: 3\n    Explanation: It could be decoded as \"BZ\" (2 26), \"VF\" (22 6), or \"BBF\" (2 2 6)\n    \"\"\"\n", "entry_point": "decode_ways", "solution": "    if not s or s[0] == '0':\n        return 0\n\n    n = len(s)\n    dp = [0] * (n + 1)\n    dp[0] = 1\n    dp[1] = 1\n\n    for i in range(2, n + 1):\n        # Check if the current digit is valid (not '0')\n        if s[i - 1] != '0':\n            dp[i] += dp[i - 1]\n\n        # Check if the last two digits form a valid number (10-26)\n        two_digit = int(s[i - 2:i])\n        if 10 <= two_digit <= 26:\n            dp[i] += dp[i - 2]\n\n    return dp[n]\n", "test": "def check(candidate):\n    assert candidate(\"2020\") == 1\n    assert candidate(\"123\") == 3\n    assert candidate(\"1234\") == 3\n    assert candidate(\"27\") == 1\n    assert candidate(\"10\") == 1\n    assert candidate(\"1\") == 1\n    assert candidate(\"226\") == 3\n    assert candidate(\"101\") == 1\n    assert candidate(\"12\") == 2\n    assert candidate(\"1010\") == 1\n", "language": "python"}
{"task_id": "revision1a_problem490", "prompt": "import math\nfrom typing import List, Tuple\n\ndef optimize_delivery_route(locations: List[Tuple[float, float]], start: Tuple[float, float]) -> List[Tuple[float, float]]:\n    \"\"\"\n    As a logistics manager for a food delivery company, you need to optimize the route for your delivery drivers.\n    Given a list of customer locations (as latitude-longitude pairs) and the starting point of the driver,\n    implement the Nearest Neighbor algorithm to find an optimized delivery route.\n\n    The function should return the optimized route as a list of coordinates, starting and ending at the driver's initial location.\n\n    Example:\n    Input: \n    locations = [(40.7128, -74.0060), (34.0522, -118.2437), (41.8781, -87.6298), (29.7604, -95.3698)]\n    start = (37.7749, -122.4194)\n\n    Output:\n    [(37.7749, -122.4194), (34.0522, -118.2437), (29.7604, -95.3698), (41.8781, -87.6298), (40.7128, -74.0060), (37.7749, -122.4194)]\n\n    This problem requires understanding of geographical distances, algorithmic thinking, and optimization techniques.\n    \"\"\"\n", "entry_point": "optimize_delivery_route", "solution": "    def calculate_distance(point1: Tuple[float, float], point2: Tuple[float, float]) -> float:\n        \"\"\"Calculate the Euclidean distance between two points.\"\"\"\n        return math.sqrt((point1[0] - point2[0])**2 + (point1[1] - point2[1])**2)\n\n    unvisited = locations.copy()\n    route = [start]\n    current = start\n\n    while unvisited:\n        nearest = min(unvisited, key=lambda x: calculate_distance(current, x))\n        route.append(nearest)\n        current = nearest\n        unvisited.remove(nearest)\n\n    route.append(start)  # Return to the starting point\n\n    return route\n", "test": "def check(candidate):\n    assert candidate([(19.4326, -99.1332), (4.7110, -74.0721), (-22.9068, -43.1729), (-34.6037, -58.3816)], (33.7490, -84.3880)) == [(33.749, -84.388), (19.4326, -99.1332), (4.711, -74.0721), (-22.9068, -43.1729), (-34.6037, -58.3816), (33.749, -84.388)]\n    assert candidate([(55.7558, 37.6173), (59.9139, 10.7522), (60.1699, 24.9384), (64.1265, -21.8174)], (51.5074, -0.1278)) == [(51.5074, -0.1278), (59.9139, 10.7522), (60.1699, 24.9384), (55.7558, 37.6173), (64.1265, -21.8174), (51.5074, -0.1278)]\n    assert candidate([(31.2304, 121.4737), (39.9042, 116.4074), (13.7563, 100.5018), (3.1390, 101.6869)], (35.6762, 139.6503)) == [(35.6762, 139.6503), (31.2304, 121.4737), (39.9042, 116.4074), (13.7563, 100.5018), (3.139, 101.6869), (35.6762, 139.6503)]\n    assert candidate([(45.4215, -75.6972), (49.2827, -123.1207), (53.5461, -113.4938), (43.6532, -79.3832)], (45.5017, -73.5673)) == [(45.5017, -73.5673), (45.4215, -75.6972), (43.6532, -79.3832), (53.5461, -113.4938), (49.2827, -123.1207), (45.5017, -73.5673)]\n    assert candidate([(25.2048, 55.2708), (24.8607, 67.0011), (33.3152, 44.3661), (23.6345, 58.5323)], (21.4225, 39.8262)) == [(21.4225, 39.8262), (33.3152, 44.3661), (25.2048, 55.2708), (23.6345, 58.5323), (24.8607, 67.0011), (21.4225, 39.8262)]\n    assert candidate([(51.5074, -0.1278), (48.8566, 2.3522), (52.5200, 13.4050), (41.9028, 12.4964)], (40.7128, -74.0060)) == [(40.7128, -74.006), (51.5074, -0.1278), (48.8566, 2.3522), (52.52, 13.405), (41.9028, 12.4964), (40.7128, -74.006)]\n    assert candidate([(35.6762, 139.6503), (22.3193, 114.1694), (1.3521, 103.8198), (-33.8688, 151.2093)], (37.5665, 126.9780)) == [(37.5665, 126.978), (35.6762, 139.6503), (22.3193, 114.1694), (1.3521, 103.8198), (-33.8688, 151.2093), (37.5665, 126.978)]\n    assert candidate([(40.4168, -3.7038), (48.2082, 16.3738), (50.0755, 14.4378), (52.2297, 21.0122)], (45.4642, 9.1900)) == [(45.4642, 9.19), (50.0755, 14.4378), (48.2082, 16.3738), (52.2297, 21.0122), (40.4168, -3.7038), (45.4642, 9.19)]\n    assert candidate([(52.3676, 4.9041), (50.8503, 4.3517), (48.1351, 11.5820), (45.4642, 9.1900)], (48.8566, 2.3522)) == [(48.8566, 2.3522), (50.8503, 4.3517), (52.3676, 4.9041), (48.1351, 11.582), (45.4642, 9.19), (48.8566, 2.3522)]\n    assert candidate([(40.7128, -74.0060), (34.0522, -118.2437), (41.8781, -87.6298), (29.7604, -95.3698)], (37.7749, -122.4194)) == [(37.7749, -122.4194), (34.0522, -118.2437), (29.7604, -95.3698), (41.8781, -87.6298), (40.7128, -74.006), (37.7749, -122.4194)]\n", "language": "python"}
{"task_id": "revision1a_problem176", "prompt": "from typing import List\nimport heapq\nimport math\n\ndef optimize_factory(n: int, machines: List[int], tasks: List[int]) -> int:\n    \"\"\"\n    You're managing a smart factory with n machines, each with different processing capabilities.\n    Your goal is to optimize task allocation to minimize the total production time.\n\n    machines[i] represents the processing power of the i-th machine (tasks per hour).\n    tasks[i] represents the complexity of the i-th task (hours needed on a machine with power 1).\n\n    Rules for task allocation:\n    1. Each machine can only work on one task at a time.\n    2. Tasks cannot be split between machines.\n    3. Machines can work simultaneously.\n    4. The time to complete a task on a machine = task complexity / machine power (rounded up).\n\n    Your function should return the minimum time (in hours) needed to complete all tasks.\n\n    Take input for the number of machines/tasks (n), list of machine powers, and list of task complexities.\n    Return the minimum time to complete all tasks.\n\n    Example:\n    Input: 3, [2, 3, 1], [3, 4, 5]\n    Output: 4\n\n    Input: 2, [2, 3], [1, 1, 1, 1]\n    Output: 2\n    \"\"\"\n", "entry_point": "optimize_factory", "solution": "    # Sort tasks in descending order\n    tasks.sort(reverse=True)\n    \n    # Create a min-heap to store machine completion times\n    machine_times = [(0, power) for power in machines]\n    heapq.heapify(machine_times)\n    \n    max_time = 0\n    \n    for task in tasks:\n        # Get the machine that will finish its current task first\n        completion_time, machine_power = heapq.heappop(machine_times)\n        \n        # Calculate the time needed for this task on this machine\n        task_time = math.ceil(task / machine_power)\n        \n        # Update the machine's completion time\n        new_completion_time = completion_time + task_time\n        \n        # Update the max_time if necessary\n        max_time = max(max_time, new_completion_time)\n        \n        # Put the machine back into the heap with its updated completion time\n        heapq.heappush(machine_times, (new_completion_time, machine_power))\n    \n    return max_time\n", "test": "def check(candidate):\n    assert candidate(4, [10, 20, 30, 40], [100, 200, 300, 400]) == 40\n    assert candidate(1, [1], [1]) == 1\n    assert candidate(3, [2, 3, 1], [3, 4, 5]) == 5\n    assert candidate(3, [1, 2, 3], [10, 20, 30]) == 30\n    assert candidate(6, [1, 2, 3, 4, 5, 6], [6, 5, 4, 3, 2, 1]) == 6\n    assert candidate(4, [5, 5, 5, 5], [10, 10, 10, 10]) == 2\n    assert candidate(2, [1000, 1], [1, 1000]) == 1000\n    assert candidate(3, [1, 1, 1], [1, 1, 1]) == 1\n    assert candidate(5, [1, 2, 3, 4, 5], [5, 4, 3, 2, 1]) == 5\n    assert candidate(2, [2, 3], [1, 1, 1, 1]) == 2\n", "language": "python"}
{"task_id": "revision1a_problem55", "prompt": "from typing import List\n\ndef optimize_delivery_route(packages: List[int], max_weight: int) -> int:\n    \"\"\"\n    Imagine you're a delivery driver for an e-commerce company. You have a list of package weights to deliver and a weight limit for your vehicle.\n    Your task is to determine the minimum number of trips required to deliver all packages without exceeding the weight limit per trip.\n    Each trip must contain at least one package, and you can't split packages across trips.\n\n    Write a function that takes a list of package weights and the maximum weight capacity of your vehicle as input,\n    and returns the minimum number of trips required to deliver all packages.\n\n    Example:\n    Input: packages = [2, 3, 4, 5, 6], max_weight = 10\n    Output: 3\n    Explanation: You can make the deliveries in 3 trips: [6, 4], [5, 3], [2]\n\n    Input: packages = [1, 2, 3, 4, 5, 6], max_weight = 7\n    Output: 3\n    Explanation: You can make the deliveries in 3 trips: [6], [5, 2], [4, 3, 1]\n\n    Take input from the user for the list of package weights and the maximum weight capacity of the vehicle.\n    Return the minimum number of trips required to deliver all packages.\n    \"\"\"\n", "entry_point": "optimize_delivery_route", "solution": "    packages.sort(reverse=True)  # Sort packages in descending order\n    trips = 0\n    left, right = 0, len(packages) - 1\n\n    while left <= right:\n        if packages[left] + packages[right] <= max_weight:\n            left += 1\n            right -= 1\n        else:\n            left += 1\n        trips += 1\n\n    return trips\n", "test": "def check(candidate):\n    assert candidate([1, 2, 3, 4, 5, 6, 7, 8, 9, 10], 15) == 5\n    assert candidate([50, 50, 50, 50], 100) == 2\n    assert candidate([10, 20, 30, 40, 50], 100) == 3\n    assert candidate([1, 1, 1, 1, 1], 5) == 3\n    assert candidate([10, 10, 10, 10, 10], 20) == 3\n    assert candidate([1, 2, 3, 4, 5], 10) == 3\n    assert candidate([1, 2, 4, 8, 16, 32], 32) == 4\n    assert candidate([5], 10) == 1\n    assert candidate([1, 2, 3, 4, 5, 6, 7, 8, 9, 10], 55) == 5\n    assert candidate([100, 200, 300], 300) == 2\n", "language": "python"}
{"task_id": "revision1a_problem643", "prompt": "from typing import List\n\ndef decrypt_message(encrypted: str, key: List[int]) -> str:\n    \"\"\"\n    A secret agent needs to decrypt a message that was encoded using a complex algorithm.\n    The encryption process involved the following steps:\n    1. Each character in the original message was replaced by its ASCII value.\n    2. Each ASCII value was then XORed with a corresponding value from a repeating key.\n    3. The resulting values were converted back to characters.\n\n    Your task is to reverse this process and recover the original message.\n\n    Input:\n    - encrypted: A string containing the encrypted message\n    - key: A list of integers representing the repeating key used for XOR operation\n\n    Output: The decrypted message as a string\n\n    Example:\n    Input: \"Hgnnq#Yqtnf\", [3, 1, 4]\n    Output: \"Hello World\"\n\n    Note: Assume all characters in the original message were printable ASCII characters.\n    \"\"\"\n", "entry_point": "decrypt_message", "solution": "    decrypted = []\n    key_length = len(key)\n    \n    for i, char in enumerate(encrypted):\n        # Step 1: Convert the encrypted character back to its ASCII value\n        ascii_value = ord(char)\n        \n        # Step 2: XOR the ASCII value with the corresponding key value\n        key_index = i % key_length\n        decrypted_ascii = ascii_value ^ key[key_index]\n        \n        # Step 3: Convert the decrypted ASCII value back to a character\n        decrypted_char = chr(decrypted_ascii)\n        \n        decrypted.append(decrypted_char)\n    \n    # Join the decrypted characters into a single string\n    return ''.join(decrypted)\n", "test": "def check(candidate):\n    assert candidate(\"a\" * 100, [7]) == 'ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff'\n    assert candidate(\"ABC\", [255]) == '\u00be\u00bd\u00bc'\n    assert candidate(\"A\", [0]) == 'A'\n    assert candidate(\"Hgnnq#Yqtnf\", [3, 1, 4]) == \"Kfjmp'Zppmg\"\n    assert candidate(\"\", [1, 2, 3]) == ''\n    assert candidate(\"Hello World!\", [0]) == 'Hello World!'\n    assert candidate(\"0123456789\", [42]) == '\\x1a\\x1b\\x18\\x19\\x1e\\x1f\\x1c\\x1d\\x12\\x13'\n    assert candidate(\"ABCDEFGHIJKLMNOPQRSTUVWXYZ\", [1, 2, 3, 4, 5]) == '@@@@@GEKMOJNNJJQSQWQTTT\\\\\\\\['\n    assert candidate(\"!@#$%^&*()\", [10, 20, 30]) == '+T=.1@,>6#'\n    assert candidate(\"abcdefghijklmnopqrstuvwxyz\", [1]) == '`cbedgfihkjmlonqpsrutwvyx{'\n", "language": "python"}
{"task_id": "revision1a_problem327", "prompt": "from typing import List\n\ndef optimize_delivery_route(addresses: List[str], max_packages: int) -> List[List[str]]:\n    \"\"\"\n    You are a delivery driver for an e-commerce company, and you need to optimize your delivery route.\n    Given a list of delivery addresses and the maximum number of packages you can carry in one trip,\n    create an efficient route plan that minimizes the number of trips required.\n\n    The function should group the addresses into sublists, where each sublist represents a single trip\n    and contains no more than the maximum number of packages allowed. The goal is to minimize the number\n    of sublists (trips) while ensuring that all addresses are covered.\n\n    Take input as a list of address strings and the maximum number of packages per trip.\n    Return a list of lists, where each inner list represents a trip with its corresponding addresses.\n\n    Example:\n    Input: ['123 Main St', '456 Elm St', '789 Oak St', '101 Pine St', '202 Maple St'], 2\n    Output: [['123 Main St', '456 Elm St'], ['789 Oak St', '101 Pine St'], ['202 Maple St']]\n\n    Example:\n    Input: ['A', 'B', 'C', 'D', 'E', 'F', 'G'], 3\n    Output: [['A', 'B', 'C'], ['D', 'E', 'F'], ['G']]\n    \"\"\"\n", "entry_point": "optimize_delivery_route", "solution": "    # Initialize an empty list to store the optimized route\n    optimized_route = []\n    \n    # Iterate through the addresses list with a step size of max_packages\n    for i in range(0, len(addresses), max_packages):\n        # Create a sublist of addresses for each trip\n        trip = addresses[i:i + max_packages]\n        # Add the trip to the optimized route\n        optimized_route.append(trip)\n    \n    return optimized_route\n", "test": "def check(candidate):\n    assert candidate(['One', 'Two', 'Three', 'Four', 'Five'], 5) == [['One', 'Two', 'Three', 'Four', 'Five']]\n    assert candidate(['A', 'B', 'C'], 3) == [['A', 'B', 'C']]\n    assert candidate(['A', 'B', 'C', 'D', 'E', 'F', 'G'], 3) == [['A', 'B', 'C'], ['D', 'E', 'F'], ['G']]\n    assert candidate(['123 Main St', '456 Elm St', '789 Oak St', '101 Pine St', '202 Maple St'], 2) == [['123 Main St', '456 Elm St'], ['789 Oak St', '101 Pine St'], ['202 Maple St']]\n    assert candidate(['1st St', '2nd St', '3rd St', '4th St', '5th St', '6th St', '7th St', '8th St'], 3) == [['1st St', '2nd St', '3rd St'], ['4th St', '5th St', '6th St'], ['7th St', '8th St']]\n    assert candidate(['Red', 'Blue', 'Green', 'Yellow', 'Purple', 'Orange'], 2) == [['Red', 'Blue'], ['Green', 'Yellow'], ['Purple', 'Orange']]\n    assert candidate(['Alpha', 'Beta', 'Gamma', 'Delta', 'Epsilon'], 3) == [['Alpha', 'Beta', 'Gamma'], ['Delta', 'Epsilon']]\n    assert candidate(['1', '2', '3', '4', '5', '6', '7', '8', '9', '10'], 4) == [['1', '2', '3', '4'], ['5', '6', '7', '8'], ['9', '10']]\n    assert candidate(['X'], 5) == [['X']]\n", "language": "python"}
{"task_id": "revision1a_problem555", "prompt": "import math\nfrom typing import List, Tuple\n\ndef optimize_delivery_route(locations: List[Tuple[float, float]]) -> List[int]:\n    \"\"\"\n    You are tasked with creating a Python program to optimize the delivery route for a local courier service.\n    The program should take a list of tuples representing the (x, y) coordinates of delivery locations and find\n    the most efficient route that visits all locations exactly once and returns to the starting point (0, 0).\n\n    Use the Nearest Neighbor algorithm to approximate the solution to the Traveling Salesman Problem:\n    1. Start at the depot (0, 0).\n    2. Find the nearest unvisited location.\n    3. Move to that location and mark it as visited.\n    4. Repeat steps 2-3 until all locations have been visited.\n    5. Return to the depot.\n\n    Return a list of integers representing the order of locations to visit, where 0 is the depot\n    and 1 to n are the delivery locations.\n\n    Example:\n    Input: [(1.0, 1.0), (2.0, 2.0), (3.0, 1.0)]\n    Output: [0, 1, 2, 3, 0]\n\n    Input: [(0.5, 0.5), (1.5, 1.5), (2.5, 0.5), (1.5, -0.5)]\n    Output: [0, 1, 2, 3, 4, 0]\n    \"\"\"\n", "entry_point": "optimize_delivery_route", "solution": "    def distance(point1, point2):\n        return math.sqrt((point1[0] - point2[0])**2 + (point1[1] - point2[1])**2)\n\n    n = len(locations)\n    unvisited = set(range(1, n + 1))\n    route = [0]  # Start at the depot\n    current_location = (0, 0)  # Depot coordinates\n\n    while unvisited:\n        nearest = min(unvisited, key=lambda x: distance(current_location, locations[x - 1]))\n        route.append(nearest)\n        unvisited.remove(nearest)\n        current_location = locations[nearest - 1]\n\n    route.append(0)  # Return to the depot\n    return route\n", "test": "def check(candidate):\n    assert candidate([(0.1, 0.1), (0.2, 0.2), (0.3, 0.3), (0.4, 0.4), (0.5, 0.5)]) == [0, 1, 2, 3, 4, 5, 0]\n    assert candidate([(1.0, 0.0), (2.0, 0.0), (3.0, 0.0), (4.0, 0.0), (5.0, 0.0)]) == [0, 1, 2, 3, 4, 5, 0]\n    assert candidate([(0.0, 1.0), (1.0, 0.0), (-1.0, 0.0), (0.0, -1.0)]) == [0, 1, 2, 4, 3, 0]\n    assert candidate([]) == [0, 0]\n    assert candidate([(1.1, 1.1), (2.2, 2.2), (3.3, 3.3), (4.4, 4.4), (5.5, 5.5)]) == [0, 1, 2, 3, 4, 5, 0]\n    assert candidate([(0.5, 0.5), (1.5, 1.5), (2.5, 0.5), (1.5, -0.5)]) == [0, 1, 2, 3, 4, 0]\n    assert candidate([(0.0, 1.0), (0.0, 2.0), (0.0, 3.0), (0.0, 4.0), (0.0, 5.0)]) == [0, 1, 2, 3, 4, 5, 0]\n    assert candidate([(10.0, 10.0), (-10.0, -10.0), (10.0, -10.0), (-10.0, 10.0)]) == [0, 1, 3, 2, 4, 0]\n    assert candidate([(1.0, 1.0)]) == [0, 1, 0]\n    assert candidate([(1.0, 1.0), (2.0, 2.0), (3.0, 1.0)]) == [0, 1, 2, 3, 0]\n", "language": "python"}
{"task_id": "revision1a_problem374", "prompt": "import math\nfrom typing import List, Tuple\n\ndef optimize_delivery_route(locations: List[Tuple[float, float]]) -> List[int]:\n    \"\"\"\n    A food delivery company wants to optimize their delivery route to minimize travel distance.\n    Given a list of (x, y) coordinates representing customer locations, return the optimal order\n    of visits as a list of indices.\n\n    Use the Nearest Neighbor algorithm to solve this Traveling Salesman Problem approximation.\n    Start from the first location (index 0) and always move to the nearest unvisited location.\n\n    Example:\n    Input: [(0, 0), (1, 1), (2, 2), (3, 3)]\n    Output: [0, 1, 2, 3]\n\n    Input: [(0, 0), (3, 4), (-2, 2), (1, 5), (4, 1)]\n    Output: [0, 4, 1, 3, 2]\n    \"\"\"\n", "entry_point": "optimize_delivery_route", "solution": "    def distance(loc1: Tuple[float, float], loc2: Tuple[float, float]) -> float:\n        return math.sqrt((loc1[0] - loc2[0])**2 + (loc1[1] - loc2[1])**2)\n\n    n = len(locations)\n    unvisited = set(range(1, n))  # All locations except the starting point\n    route = [0]  # Start from the first location (index 0)\n    current = 0\n\n    while unvisited:\n        nearest = min(unvisited, key=lambda x: distance(locations[current], locations[x]))\n        route.append(nearest)\n        unvisited.remove(nearest)\n        current = nearest\n\n    return route\n", "test": "def check(candidate):\n    assert candidate([(0, 0), (10, 10), (20, 20), (30, 30), (40, 40)]) == [0, 1, 2, 3, 4]\n    assert candidate([(-1, -1), (-2, -2), (-3, -3), (-4, -4)]) == [0, 1, 2, 3]\n    assert candidate([(1.5, 2.7), (3.2, 4.1), (0.8, 1.9), (5.4, 2.3)]) == [0, 2, 1, 3]\n    assert candidate([(0, 0), (0, 1), (0, 2), (0, 3), (0, 4)]) == [0, 1, 2, 3, 4]\n    assert candidate([(1, 1)]) == [0]\n    assert candidate([]) == [0]\n    assert candidate([(0, 0), (1, 1), (2, 2), (3, 3)]) == [0, 1, 2, 3]\n    assert candidate([(0, 0), (3, 4), (-2, 2), (1, 5), (4, 1)]) == [0, 2, 3, 1, 4]\n    assert candidate([(0, 0), (0, 0), (0, 0), (1, 1)]) == [0, 1, 2, 3]\n    assert candidate([(0, 0), (1, 0), (2, 0), (3, 0), (4, 0)]) == [0, 1, 2, 3, 4]\n", "language": "python"}
{"task_id": "revision1a_problem301", "prompt": "from typing import List, Dict\nimport re\n\ndef analyze_text(text: str) -> Dict[str, List[str]]:\n    \"\"\"\n    Analyze a given text and categorize words based on their starting letter.\n    Ignore punctuation and consider only alphabetic characters.\n    Return a dictionary where keys are letters and values are lists of words starting with that letter.\n\n    Parameters:\n    text (str): The input text to analyze\n\n    Returns:\n    Dict[str, List[str]]: A dictionary with letters as keys and lists of words as values\n\n    Example:\n    Input: \"The quick brown fox jumps over the lazy dog.\"\n    Output: {\n        \"t\": [\"the\"],\n        \"q\": [\"quick\"],\n        \"b\": [\"brown\"],\n        \"f\": [\"fox\"],\n        \"j\": [\"jumps\"],\n        \"o\": [\"over\"],\n        \"l\": [\"lazy\"],\n        \"d\": [\"dog\"]\n    }\n\n    This function requires knowledge of string manipulation, regular expressions,\n    dictionary operations, and list comprehension.\n    \"\"\"\n", "entry_point": "analyze_text", "solution": "    # Remove punctuation and convert to lowercase\n    clean_text = re.sub(r'[^\\w\\s]', '', text.lower())\n    \n    # Split the text into words\n    words = clean_text.split()\n    \n    # Create a dictionary to store the categorized words\n    result = {}\n    \n    # Categorize words based on their starting letter\n    for word in words:\n        if word:\n            first_letter = word[0]\n            if first_letter.isalpha():\n                if first_letter not in result:\n                    result[first_letter] = []\n                if word not in result[first_letter]:\n                    result[first_letter].append(word)\n    \n    return result\n", "test": "def check(candidate):\n    assert candidate(\"123 456 789\") == {}\n    assert candidate(\"!@#$%^&*()_+\") == {}\n    assert candidate(\"The quick brown fox jumps over the lazy dog.\") == {'t': ['the'], 'q': ['quick'], 'b': ['brown'], 'f': ['fox'], 'j': ['jumps'], 'o': ['over'], 'l': ['lazy'], 'd': ['dog']}\n    assert candidate(\"AAA BBB CCC\") == {'a': ['aaa'], 'b': ['bbb'], 'c': ['ccc']}\n    assert candidate(\"  Spaces   at   the   beginning   and   end  \") == {'s': ['spaces'], 'a': ['at', 'and'], 't': ['the'], 'b': ['beginning'], 'e': ['end']}\n    assert candidate(\"a b c d e f g h i j k l m n o p q r s t u v w x y z\") == {'a': ['a'], 'b': ['b'], 'c': ['c'], 'd': ['d'], 'e': ['e'], 'f': ['f'], 'g': ['g'], 'h': ['h'], 'i': ['i'], 'j': ['j'], 'k': ['k'], 'l': ['l'], 'm': ['m'], 'n': ['n'], 'o': ['o'], 'p': ['p'], 'q': ['q'], 'r': ['r'], 's': ['s'], 't': ['t'], 'u': ['u'], 'v': ['v'], 'w': ['w'], 'x': ['x'], 'y': ['y'], 'z': ['z']}\n    assert candidate(\"\") == {}\n    assert candidate(\"Mixed123 Content! With456 Numbers789 and Punctuation.\") == {'m': ['mixed123'], 'c': ['content'], 'w': ['with456'], 'n': ['numbers789'], 'a': ['and'], 'p': ['punctuation']}\n    assert candidate(\"A\") == {'a': ['a']}\n    assert candidate(\"Hello, World! How are you today?\") == {'h': ['hello', 'how'], 'w': ['world'], 'a': ['are'], 'y': ['you'], 't': ['today']}\n", "language": "python"}
{"task_id": "revision1a_problem726", "prompt": "def calculate_shipping_cost(weight: float, distance: int) -> float:\n    \"\"\"\n    A shipping company calculates the cost of shipping based on the weight of the package and the distance it needs to travel.\n    If the weight is less than 5 kg, the base cost is $10.\n    If the weight is between 5 kg and 20 kg (inclusive), the base cost is $20.\n    If the weight is more than 20 kg, the base cost is $30.\n\n    Additionally, for every 100 km of distance (rounded up), there's an extra charge:\n    - $1 for packages less than 5 kg\n    - $2 for packages between 5 kg and 20 kg\n    - $3 for packages more than 20 kg\n\n    Take the weight of the package (in kg) and the distance (in km) as input and return the total shipping cost.\n\n    Example:\n    Input: 4.5, 250\n    Output: 13.0\n    Input: 15, 720\n    Output: 34.0\n    \"\"\"\n", "entry_point": "calculate_shipping_cost", "solution": "    # Determine base cost based on weight\n    if weight < 5:\n        base_cost = 10\n        distance_charge = 1\n    elif 5 <= weight <= 20:\n        base_cost = 20\n        distance_charge = 2\n    else:\n        base_cost = 30\n        distance_charge = 3\n\n    # Calculate additional charge based on distance\n    distance_units = -(-distance // 100)  # Equivalent to ceil(distance / 100)\n    additional_cost = distance_units * distance_charge\n\n    # Calculate total shipping cost\n    total_cost = base_cost + additional_cost\n\n    return float(total_cost)\n", "test": "def check(candidate):\n    assert candidate(20.01, 201) == 39.0\n    assert candidate(0.1, 50) == 11.0\n    assert candidate(5, 100) == 22.0\n    assert candidate(21, 500) == 45.0\n    assert candidate(5.01, 101) == 24.0\n    assert candidate(20, 1000) == 40.0\n    assert candidate(15, 720) == 36.0\n    assert candidate(19.99, 199) == 24.0\n    assert candidate(4.99, 99) == 11.0\n    assert candidate(4.5, 250) == 13.0\n", "language": "python"}
{"task_id": "revision1a_problem519", "prompt": "import itertools\nfrom typing import List, Tuple\nfrom itertools import combinations\n\ndef network_reliability(nodes: int, connections: List[Tuple[int, int, float]]) -> float:\n    \"\"\"\n    You are a network engineer tasked with evaluating the reliability of a computer network.\n    The network consists of nodes (computers) connected by edges (network cables) with varying reliability probabilities.\n    Given the number of nodes and a list of connections between nodes (along with their reliability probabilities),\n    calculate the overall reliability of the network.\n    \n    The overall reliability is defined as the probability that there exists at least one path between any two nodes in the network.\n    \n    Take input from the user for the number of nodes and the list of connections, and print the overall network reliability as a float between 0 and 1.\n    \n    Example 1:\n    Input:\n    nodes = 4\n    connections = [(0, 1, 0.9), (1, 2, 0.8), (2, 3, 0.7), (0, 3, 0.6)]\n    Output: 0.9784\n    \n    Example 2:\n    Input:\n    nodes = 5\n    connections = [(0, 1, 0.95), (1, 2, 0.9), (2, 3, 0.85), (3, 4, 0.8), (0, 4, 0.75)]\n    Output: 0.9997\n    \"\"\"\n", "entry_point": "network_reliability", "solution": "    def find(parent, i):\n        if parent[i] == i:\n            return i\n        return find(parent, parent[i])\n\n    def union(parent, rank, x, y):\n        xroot = find(parent, x)\n        yroot = find(parent, y)\n        if rank[xroot] < rank[yroot]:\n            parent[xroot] = yroot\n        elif rank[xroot] > rank[yroot]:\n            parent[yroot] = xroot\n        else:\n            parent[yroot] = xroot\n            rank[xroot] += 1\n\n    def is_connected(parent):\n        root = find(parent, 0)\n        return all(find(parent, i) == root for i in range(nodes))\n\n    reliability = 0\n    total_scenarios = 2 ** len(connections)\n\n    for scenario in range(total_scenarios):\n        parent = list(range(nodes))\n        rank = [0] * nodes\n        scenario_prob = 1\n\n        for i, (u, v, p) in enumerate(connections):\n            if scenario & (1 << i):\n                union(parent, rank, u, v)\n                scenario_prob *= p\n            else:\n                scenario_prob *= (1 - p)\n\n        if is_connected(parent):\n            reliability += scenario_prob\n\n    return reliability\n", "test": "def check(candidate):\n    assert candidate(3, [(0, 1, 1.0), (1, 2, 1.0), (0, 2, 1.0)]) == 1.0\n    assert candidate(4, [(0, 1, 0.5), (1, 2, 0.5), (2, 3, 0.5), (3, 0, 0.5)]) == 0.3125\n    assert candidate(4, [(0, 1, 0.75), (0, 2, 0.75), (0, 3, 0.75), (1, 2, 0.75), (1, 3, 0.75), (2, 3, 0.75)]) == 0.93603515625\n    assert candidate(5, [(0, 1, 0.99), (1, 2, 0.99), (2, 3, 0.99), (3, 4, 0.99), (4, 0, 0.99)]) == 0.9990198504\n    assert candidate(5, [(0, 1, 0.95), (1, 2, 0.9), (2, 3, 0.85), (3, 4, 0.8), (0, 4, 0.75)]) == 0.8387625000000001\n    assert candidate(4, [(0, 1, 0.9), (1, 2, 0.8), (2, 3, 0.7), (0, 3, 0.6)]) == 0.7428\n    assert candidate(3, [(0, 1, 0.8), (1, 2, 0.7)]) == 0.5599999999999999\n    assert candidate(2, [(0, 1, 0.5)]) == 0.5\n    assert candidate(3, [(0, 1, 0.1), (1, 2, 0.1), (2, 0, 0.1)]) == 0.028000000000000004\n    assert candidate(6, [(0, 1, 0.9), (1, 2, 0.8), (2, 3, 0.7), (3, 4, 0.6), (4, 5, 0.5), (5, 0, 0.4)]) == 0.29976\n", "language": "python"}
{"task_id": "revision1a_problem71", "prompt": "from typing import List, Dict, Tuple\nfrom collections import defaultdict, deque\n\ndef analyze_social_network(connections: List[Tuple[str, str]]) -> Dict[str, int]:\n    \"\"\"\n    You are a data analyst working for a social media company. Your task is to analyze the social network\n    and identify the most influential users based on their connections.\n\n    Write a Python function that takes a list of connections between users and returns a dictionary\n    with each user's influence score. The influence score is calculated as follows:\n    1. Each user gets 1 point for every direct connection they have.\n    2. Each user gets 0.5 points for every second-degree connection (friend of a friend).\n    3. Each user gets 0.25 points for every third-degree connection.\n\n    The function should:\n    1. Build a graph representation of the social network.\n    2. Implement a breadth-first search to find connections up to the third degree.\n    3. Calculate the influence score for each user.\n    4. Return a dictionary with usernames as keys and influence scores as values.\n\n    Input format: List of tuples, where each tuple represents a connection between two users\n    Output format: Dictionary with usernames as keys and influence scores as values\n\n    Example:\n    Input: [\n        (\"Alice\", \"Bob\"),\n        (\"Bob\", \"Charlie\"),\n        (\"Charlie\", \"David\"),\n        (\"David\", \"Eve\"),\n        (\"Alice\", \"Frank\"),\n        (\"Frank\", \"George\")\n    ]\n    Output: {\n        \"Alice\": 4.75,\n        \"Bob\": 4.25,\n        \"Charlie\": 4.25,\n        \"David\": 3.75,\n        \"Eve\": 2.5,\n        \"Frank\": 3.75,\n        \"George\": 2.5\n    }\n\n    Note: The actual output values may vary slightly depending on the specific implementation.\n    \"\"\"\n", "entry_point": "analyze_social_network", "solution": "    # Build graph representation\n    graph = defaultdict(set)\n    for user1, user2 in connections:\n        graph[user1].add(user2)\n        graph[user2].add(user1)\n    \n    # Calculate influence scores\n    influence_scores = {}\n    \n    for user in graph:\n        score = 0\n        visited = set()\n        queue = deque([(user, 0)])\n        \n        while queue:\n            current_user, degree = queue.popleft()\n            \n            if current_user not in visited:\n                visited.add(current_user)\n                \n                if degree == 0:\n                    score += len(graph[current_user])\n                elif degree == 1:\n                    score += 0.5\n                elif degree == 2:\n                    score += 0.25\n                \n                if degree < 3:\n                    for neighbor in graph[current_user]:\n                        if neighbor not in visited:\n                            queue.append((neighbor, degree + 1))\n        \n        influence_scores[user] = score\n    \n    return influence_scores\n", "test": "def check(candidate):\n    assert candidate([(\"John\", \"Mary\"), (\"Mary\", \"Peter\"), (\"Peter\", \"Sarah\"), (\"Sarah\", \"John\")]) == {'John': 3.25, 'Mary': 3.25, 'Peter': 3.25, 'Sarah': 3.25}\n    assert candidate([(\"User1\", \"User2\"), (\"User2\", \"User3\"), (\"User3\", \"User4\"), (\"User4\", \"User1\")]) == {'User1': 3.25, 'User2': 3.25, 'User3': 3.25, 'User4': 3.25}\n    assert candidate([(\"A\", \"B\"), (\"B\", \"C\"), (\"C\", \"D\"), (\"D\", \"E\")]) == {'A': 1.75, 'B': 3.25, 'C': 3.5, 'D': 3.25, 'E': 1.75}\n    assert candidate([(\"A\", \"B\"), (\"B\", \"C\"), (\"C\", \"D\"), (\"D\", \"E\"), (\"E\", \"A\")]) == {'A': 3.5, 'B': 3.5, 'C': 3.5, 'D': 3.5, 'E': 3.5}\n    assert candidate([(\"Node1\", \"Node2\"), (\"Node2\", \"Node3\"), (\"Node3\", \"Node4\"), (\"Node4\", \"Node5\"), (\"Node5\", \"Node1\")]) == {'Node1': 3.5, 'Node2': 3.5, 'Node3': 3.5, 'Node4': 3.5, 'Node5': 3.5}\n    assert candidate([(\"Alice\", \"Bob\"), (\"Bob\", \"Charlie\"), (\"Charlie\", \"David\"), (\"David\", \"Eve\"), (\"Eve\", \"Alice\")]) == {'Alice': 3.5, 'Bob': 3.5, 'Charlie': 3.5, 'David': 3.5, 'Eve': 3.5}\n    assert candidate([(\"X\", \"Y\"), (\"Y\", \"Z\"), (\"Z\", \"X\")]) == {'X': 3.0, 'Y': 3.0, 'Z': 3.0}\n    assert candidate([(\"1\", \"2\"), (\"2\", \"3\"), (\"3\", \"4\"), (\"4\", \"5\"), (\"5\", \"6\"), (\"6\", \"1\")]) == {'1': 3.5, '2': 3.5, '3': 3.5, '4': 3.5, '5': 3.5, '6': 3.5}\n    assert candidate([(\"Alice\", \"Bob\"), (\"Bob\", \"Charlie\")]) == {'Alice': 1.75, 'Bob': 3.0, 'Charlie': 1.75}\n    assert candidate([(\"A\", \"B\"), (\"B\", \"C\"), (\"C\", \"A\"), (\"D\", \"E\"), (\"E\", \"F\"), (\"F\", \"D\")]) == {'A': 3.0, 'B': 3.0, 'C': 3.0, 'D': 3.0, 'E': 3.0, 'F': 3.0}\n", "language": "python"}
{"task_id": "revision1a_problem558", "prompt": "from typing import List\n\ndef optimize_delivery_route(packages: List[int], truck_capacity: int) -> List[int]:\n    \"\"\"\n    A delivery company needs to optimize its route for delivering packages. They have a list of package weights and a truck with a maximum capacity.\n    The goal is to find the maximum number of packages that can be delivered in one trip without exceeding the truck's capacity.\n    Additionally, they want to know which packages to choose to maximize the total weight carried without going over the limit.\n    \n    Your task is to implement a function that takes a list of package weights and the truck's capacity as input,\n    and returns a list of indices representing the packages that should be loaded onto the truck for optimal delivery.\n    \n    The challenge is to solve this problem using dynamic programming to achieve an O(n*W) time complexity,\n    where n is the number of packages and W is the truck's capacity.\n    \n    Example:\n    Input: [2, 3, 4, 5, 9], 10\n    Output: [1, 2, 3]  # Indices of packages with weights 3, 4, and 5, totaling 12 (which is <= 10)\n    \n    Input: [1, 3, 4, 5], 7\n    Output: [1, 2, 3]  # Indices of packages with weights 3, 4, and 1, totaling 7\n    \"\"\"\n", "entry_point": "optimize_delivery_route", "solution": "    n = len(packages)\n    \n    # Initialize the dynamic programming table\n    dp = [[0 for _ in range(truck_capacity + 1)] for _ in range(n + 1)]\n    \n    # Fill the dp table\n    for i in range(1, n + 1):\n        for w in range(1, truck_capacity + 1):\n            if packages[i-1] <= w:\n                dp[i][w] = max(dp[i-1][w], dp[i-1][w-packages[i-1]] + packages[i-1])\n            else:\n                dp[i][w] = dp[i-1][w]\n    \n    # Backtrack to find the chosen packages\n    chosen_packages = []\n    i, w = n, truck_capacity\n    while i > 0 and w > 0:\n        if dp[i][w] != dp[i-1][w]:\n            chosen_packages.append(i-1)\n            w -= packages[i-1]\n        i -= 1\n    \n    # Reverse the list to get the correct order\n    chosen_packages.reverse()\n    \n    return chosen_packages\n", "test": "def check(candidate):\n    assert candidate([5, 10, 15, 20, 25], 40) == [0, 2, 3]\n    assert candidate([100], 99) == []\n    assert candidate([5, 5, 5, 5, 5], 20) == [0, 1, 2, 3]\n    assert candidate([2, 3, 4, 5, 9], 10) == [0, 1, 3]\n    assert candidate([50, 50, 50], 100) == [0, 1]\n    assert candidate([1, 1, 1, 1, 1], 3) == [0, 1, 2]\n    assert candidate([10, 20, 30], 50) == [1, 2]\n    assert candidate([1, 2, 3, 4, 5], 15) == [0, 1, 2, 3, 4]\n    assert candidate([1, 3, 4, 5], 7) == [1, 2]\n    assert candidate([1, 2, 3, 4, 5, 6, 7, 8, 9, 10], 30) == [0, 1, 2, 3, 4, 6, 7]\n", "language": "python"}
{"task_id": "revision1a_problem263", "prompt": "from typing import List, Tuple\nimport sys\n\ndef optimize_delivery_route(n: int, distances: List[List[int]], time_windows: List[Tuple[int, int]]) -> List[int]:\n    \"\"\"\n    A delivery company needs to optimize their route for n customers in a city. \n    The company wants to minimize the total distance traveled while ensuring each customer \n    is visited within their specified time window.\n\n    Given:\n    - n: number of customers\n    - distances: an n x n matrix where distances[i][j] represents the distance between customer i and j\n    - time_windows: a list of tuples (start_time, end_time) representing the time window for each customer\n\n    Return the optimal order of customers to visit as a list of customer indices.\n\n    Use dynamic programming and branch and bound techniques to solve this problem efficiently.\n\n    Example:\n    Input: \n    n = 4\n    distances = [\n        [0, 10, 15, 20],\n        [10, 0, 35, 25],\n        [15, 35, 0, 30],\n        [20, 25, 30, 0]\n    ]\n    time_windows = [(0, 5), (7, 10), (8, 12), (10, 15)]\n\n    Output: [0, 1, 3, 2]\n    \"\"\"\n", "entry_point": "optimize_delivery_route", "solution": "    \n    def tsp_dp(mask, pos):\n        if mask == (1 << n) - 1:\n            return distances[pos][0], [0]\n        \n        if (mask, pos) in memo:\n            return memo[(mask, pos)]\n        \n        min_cost = sys.maxsize\n        best_path = []\n        \n        for next_pos in range(n):\n            if next_pos != pos and not (mask & (1 << next_pos)):\n                new_mask = mask | (1 << next_pos)\n                cost, path = tsp_dp(new_mask, next_pos)\n                total_cost = distances[pos][next_pos] + cost\n                \n                if total_cost < min_cost:\n                    min_cost = total_cost\n                    best_path = [next_pos] + path\n        \n        memo[(mask, pos)] = (min_cost, best_path)\n        return min_cost, best_path\n    \n    def is_valid_time(path):\n        current_time = 0\n        for i in range(len(path)):\n            if i > 0:\n                current_time += distances[path[i-1]][path[i]]\n            start, end = time_windows[path[i]]\n            if current_time < start:\n                current_time = start\n            elif current_time > end:\n                return False\n        return True\n    \n    memo = {}\n    _, initial_path = tsp_dp(1, 0)\n    \n    def branch_and_bound(path, current_cost):\n        nonlocal best_path, best_cost\n        \n        if len(path) == n:\n            if current_cost < best_cost and is_valid_time(path):\n                best_path = path[:]\n                best_cost = current_cost\n            return\n        \n        for next_pos in range(n):\n            if next_pos not in path:\n                new_path = path + [next_pos]\n                new_cost = current_cost + distances[path[-1]][next_pos]\n                \n                if new_cost < best_cost:\n                    branch_and_bound(new_path, new_cost)\n    \n    best_path = initial_path\n    best_cost = sum(distances[best_path[i]][best_path[i+1]] for i in range(n-1)) + distances[best_path[-1]][best_path[0]]\n    \n    branch_and_bound([0], 0)\n    \n    return best_path\n\n", "test": "def check(candidate):\n    assert candidate(3, [[0, 5, 10], [5, 0, 15], [10, 15, 0]], [(1, 3), (2, 4), (3, 5)]) == [1, 2, 0]\n    assert candidate(2, [[0, 100], [100, 0]], [(0, 10), (5, 15)]) == [1, 0]\n    assert candidate(5, [[0, 10, 20, 30, 40], [10, 0, 15, 25, 35], [20, 15, 0, 10, 20], [30, 25, 10, 0, 15], [40, 35, 20, 15, 0]], [(0, 5), (2, 7), (4, 9), (6, 11), (8, 13)]) == [1, 2, 3, 4, 0]\n    assert candidate(4, [[0, 10, 15, 20], [10, 0, 35, 25], [15, 35, 0, 30], [20, 25, 30, 0]], [(0, 5), (7, 10), (8, 12), (10, 15)]) == [1, 3, 2, 0]\n", "language": "python"}
{"task_id": "revision1a_problem563", "prompt": "from typing import List, Tuple\n\ndef find_prime_pairs(n: int) -> List[Tuple[int, int]]:\n    \"\"\"\n    Given an even number n (n > 2), find all pairs of prime numbers that sum up to n.\n    This is known as the Goldbach Conjecture problem. Implement this using the Sieve of Eratosthenes\n    algorithm for prime number generation to optimize the solution.\n\n    Take input from the user and print all the prime pairs that sum up to the given even number.\n    The time complexity should be O(n log log n) due to the Sieve of Eratosthenes.\n\n    Example:\n    Input: 10\n    Output: [(3, 7), (5, 5)]\n\n    Input: 100\n    Output: [(3, 97), (11, 89), (17, 83), (29, 71), (41, 59), (47, 53)]\n    \"\"\"\n", "entry_point": "find_prime_pairs", "solution": "    def sieve_of_eratosthenes(limit):\n        primes = [True] * (limit + 1)\n        primes[0] = primes[1] = False\n        \n        for i in range(2, int(limit**0.5) + 1):\n            if primes[i]:\n                for j in range(i*i, limit + 1, i):\n                    primes[j] = False\n        \n        return primes\n\n    if n <= 2 or n % 2 != 0:\n        return []\n\n    primes = sieve_of_eratosthenes(n)\n    prime_pairs = []\n\n    for i in range(2, n // 2 + 1):\n        if primes[i] and primes[n - i]:\n            prime_pairs.append((i, n - i))\n\n    return prime_pairs\n\n# Test the function with user input\nif __name__ == \"__main__\":\n    try:\n        user_input = int(input(\"Enter an even number greater than 2: \"))\n        if user_input <= 2 or user_input % 2 != 0:\n            print(\"Please enter an even number greater than 2.\")\n        else:\n            result = find_prime_pairs(user_input)\n            print(f\"Prime pairs for {user_input}:\")\n            print(result)\n    except ValueError:\n        print(\"Invalid input. Please enter a valid integer.\")\n", "test": "def check(candidate):\n    assert candidate(100) == [(3, 97), (11, 89), (17, 83), (29, 71), (41, 59), (47, 53)]\n    assert candidate(30) == [(7, 23), (11, 19), (13, 17)]\n    assert candidate(6) == [(3, 3)]\n    assert candidate(1000) == [(3, 997), (17, 983), (23, 977), (29, 971), (47, 953), (53, 947), (59, 941), (71, 929), (89, 911), (113, 887), (137, 863), (173, 827), (179, 821), (191, 809), (227, 773), (239, 761), (257, 743), (281, 719), (317, 683), (347, 653), (353, 647), (359, 641), (383, 617), (401, 599), (431, 569), (443, 557), (479, 521), (491, 509)]\n    assert candidate(4) == [(2, 2)]\n    assert candidate(50) == [(3, 47), (7, 43), (13, 37), (19, 31)]\n    assert candidate(8) == [(3, 5)]\n    assert candidate(10) == [(3, 7), (5, 5)]\n    assert candidate(20) == [(3, 17), (7, 13)]\n    assert candidate(12) == [(5, 7)]\n", "language": "python"}
{"task_id": "revision1a_problem60", "prompt": "import math\nfrom typing import List, Tuple\n\ndef optimize_delivery_route(locations: List[Tuple[float, float]], start: Tuple[float, float]) -> List[Tuple[float, float]]:\n    \"\"\"\n    A delivery company wants to optimize their route for multiple package deliveries.\n    Given a list of delivery locations (as latitude-longitude pairs) and a starting point,\n    find the most efficient route that visits all locations and returns to the start.\n\n    This problem is known as the Traveling Salesman Problem (TSP). Implement a solution\n    using dynamic programming or a heuristic algorithm like nearest neighbor.\n\n    Take input from the user for the starting location and a list of delivery locations,\n    then return the optimized route as a list of coordinates.\n\n    Example:\n    Input: [(0,0), [(1,1), (2,2), (3,3), (4,4)]]\n    Output: [(0,0), (1,1), (2,2), (3,3), (4,4), (0,0)]\n    Input: [(0,0), [(2,2), (1,3), (4,1), (3,4)]]\n    Output: [(0,0), (2,2), (3,4), (1,3), (4,1), (0,0)]\n    \"\"\"\n", "entry_point": "optimize_delivery_route", "solution": "    def distance(point1: Tuple[float, float], point2: Tuple[float, float]) -> float:\n        return math.sqrt((point1[0] - point2[0])**2 + (point1[1] - point2[1])**2)\n\n    def nearest_neighbor(current: Tuple[float, float], unvisited: List[Tuple[float, float]]) -> Tuple[float, float]:\n        return min(unvisited, key=lambda point: distance(current, point))\n\n    route = [start]\n    unvisited = locations.copy()\n\n    while unvisited:\n        current = route[-1]\n        next_location = nearest_neighbor(current, unvisited)\n        route.append(next_location)\n        unvisited.remove(next_location)\n\n    route.append(start)  # Return to the starting point\n    return route\n", "test": "def check(candidate):\n    assert candidate([(1, 1), (2, 2), (3, 3), (4, 4), (5, 5)], (0, 0)) == [(0, 0), (1, 1), (2, 2), (3, 3), (4, 4), (5, 5), (0, 0)]\n    assert candidate([(0, 0), (1, 0), (0, 1), (1, 1), (0.5, 0.5)], (0, 0)) == [(0, 0), (0, 0), (0.5, 0.5), (1, 0), (1, 1), (0, 1), (0, 0)]\n    assert candidate([(0, 0)], (0, 0)) == [(0, 0), (0, 0), (0, 0)]\n    assert candidate([(0, 0), (1, 1), (2, 2), (3, 3)], (0, 0)) == [(0, 0), (0, 0), (1, 1), (2, 2), (3, 3), (0, 0)]\n    assert candidate([(1.5, 1.5), (2.5, 2.5), (3.5, 3.5)], (0.5, 0.5)) == [(0.5, 0.5), (1.5, 1.5), (2.5, 2.5), (3.5, 3.5), (0.5, 0.5)]\n    assert candidate([(0, 0), (10, 0), (10, 10), (0, 10)], (5, 5)) == [(5, 5), (0, 0), (10, 0), (10, 10), (0, 10), (5, 5)]\n    assert candidate([(40.7128, -74.0060), (34.0522, -118.2437), (41.8781, -87.6298)], (37.7749, -122.4194)) == [(37.7749, -122.4194), (34.0522, -118.2437), (41.8781, -87.6298), (40.7128, -74.006), (37.7749, -122.4194)]\n    assert candidate([(1, 1), (1, 2), (1, 3), (1, 4), (1, 5)], (1, 0)) == [(1, 0), (1, 1), (1, 2), (1, 3), (1, 4), (1, 5), (1, 0)]\n    assert candidate([(90, 180), (-90, -180), (0, 0)], (45, 45)) == [(45, 45), (0, 0), (90, 180), (-90, -180), (45, 45)]\n    assert candidate([(0, 0), (0, 1), (1, 0), (1, 1)], (0, 0)) == [(0, 0), (0, 0), (0, 1), (1, 1), (1, 0), (0, 0)]\n", "language": "python"}
{"task_id": "revision1a_problem279", "prompt": "def decode_alien_message(message: str, codebook: dict) -> str:\n    \"\"\"\n    Scientists have intercepted an alien message and partially decrypted their language.\n    Help decode the full message using the provided codebook.\n\n    The message consists of alien symbols, and the codebook provides translations for some symbols.\n    If a symbol is not in the codebook, leave it unchanged.\n    Decode the message from right to left, and if a combination of symbols matches a codebook entry,\n    replace it with the corresponding Earth word.\n\n    Example:\n    Input: \n    message = \"@#$%^&*\"\n    codebook = {\"*\": \"hello\", \"&^\": \"world\", \"%$#@\": \"earthlings\"}\n    Output: \"hello world earthlings\"\n\n    Input:\n    message = \"!@#$%^&*\"\n    codebook = {\"*&\": \"greetings\", \"#$\": \"from\", \"!\": \"mars\"}\n    Output: \"greetings from mars\"\n    \"\"\"\n", "entry_point": "decode_alien_message", "solution": "    decoded_message = []\n    i = len(message) - 1\n\n    while i >= 0:\n        found = False\n        for key, value in codebook.items():\n            if message[max(0, i-len(key)+1):i+1] == key:\n                decoded_message.append(value)\n                i -= len(key)\n                found = True\n                break\n        \n        if not found:\n            decoded_message.append(message[i])\n            i -= 1\n\n    return ' '.join(decoded_message[::-1])\n", "test": "def check(candidate):\n    assert candidate(\"xyz\", {\"x\": \"a\", \"y\": \"b\", \"z\": \"c\"}) == 'a b c'\n    assert candidate(\"@#$%^&*\", {\"*\": \"hello\", \"&^\": \"world\", \"%$#@\": \"earthlings\"}) == '@ # $ % ^ & hello'\n    assert candidate(\"abcdefg\", {\"a\": \"one\", \"bcd\": \"two\", \"efg\": \"three\"}) == 'one two three'\n    assert candidate(\"!@#$%\", {\"!@#$%\": \"all\"}) == 'all'\n    assert candidate(\"abcde\", {\"abc\": \"start\", \"de\": \"end\"}) == 'start end'\n    assert candidate(\"!@#$%^&*\", {\"*&\": \"greetings\", \"#$\": \"from\", \"!\": \"mars\"}) == 'mars @ from % ^ & *'\n    assert candidate(\"12345\", {\"1\": \"one\", \"2\": \"two\", \"3\": \"three\", \"4\": \"four\", \"5\": \"five\"}) == 'one two three four five'\n    assert candidate(\"\", {}) == ''\n    assert candidate(\"aabbccddee\", {\"aa\": \"double\", \"cc\": \"trouble\", \"ee\": \"bubble\"}) == 'double b b trouble d d bubble'\n    assert candidate(\"123456789\", {\"9\": \"nine\", \"87\": \"eighty-seven\", \"654321\": \"reverse\"}) == '1 2 3 4 5 6 7 8 nine'\n", "language": "python"}
{"task_id": "revision1a_problem648", "prompt": "from typing import List\n\ndef job_scheduling(start_times: List[int], end_times: List[int], profits: List[int]) -> int:\n    \"\"\"\n    You are a freelance worker trying to maximize your earnings. You have a list of job offers,\n    each with a start time, end time, and associated profit. You can only work on one job at a time,\n    and once you start a job, you must complete it. Write a function that determines the maximum profit\n    you can make from these jobs.\n\n    The function takes three lists as input:\n    - start_times: list of integers representing the start times of jobs\n    - end_times: list of integers representing the end times of jobs\n    - profits: list of integers representing the profit of each job\n\n    Return the maximum profit you can make.\n\n    Example:\n    Input: \n    start_times = [1, 2, 3, 3]\n    end_times = [3, 4, 5, 6]\n    profits = [50, 10, 40, 70]\n    Output: 120\n\n    Input:\n    start_times = [1, 2, 3, 4, 6]\n    end_times = [3, 5, 10, 6, 9]\n    profits = [20, 20, 100, 70, 60]\n    Output: 150\n    \"\"\"\n", "entry_point": "job_scheduling", "solution": "    # Sort jobs based on end times\n    jobs = sorted(zip(start_times, end_times, profits), key=lambda x: x[1])\n    n = len(jobs)\n    \n    # Initialize dp array to store maximum profit at each job\n    dp = [0] * n\n    dp[0] = jobs[0][2]  # Profit of the first job\n    \n    # Dynamic programming to find maximum profit\n    for i in range(1, n):\n        # Find the latest non-overlapping job\n        j = i - 1\n        while j >= 0 and jobs[j][1] > jobs[i][0]:\n            j -= 1\n        \n        # Calculate profit including current job\n        if j >= 0:\n            profit_with_current = jobs[i][2] + dp[j]\n        else:\n            profit_with_current = jobs[i][2]\n        \n        # Update dp[i] with maximum profit\n        dp[i] = max(profit_with_current, dp[i-1])\n    \n    # Return the maximum profit\n    return dp[-1]\n", "test": "def check(candidate):\n    assert candidate([1, 2, 3, 4, 5], [6, 6, 6, 6, 6], [10, 20, 30, 40, 50]) == 50\n    assert candidate([1, 2, 3, 4, 5], [2, 3, 4, 5, 6], [5, 5, 5, 5, 5]) == 25\n    assert candidate([1, 2, 3, 3], [3, 4, 5, 6], [50, 10, 40, 70]) == 120\n    assert candidate([1, 2, 3, 4, 6], [3, 5, 10, 6, 9], [20, 20, 100, 70, 60]) == 150\n    assert candidate([1], [2], [100]) == 100\n    assert candidate([1, 2, 3, 4, 5], [2, 3, 4, 5, 6], [50, 40, 30, 20, 10]) == 150\n    assert candidate([1, 1, 1, 1, 1], [2, 3, 4, 5, 6], [10, 20, 30, 40, 50]) == 50\n    assert candidate([1, 1, 1], [2, 2, 2], [10, 20, 30]) == 30\n    assert candidate([1, 2], [2, 3], [10, 20]) == 30\n    assert candidate([1, 3, 5], [2, 4, 6], [100, 200, 300]) == 600\n", "language": "python"}
{"task_id": "revision1a_problem604", "prompt": "import sys\nimport itertools\nfrom typing import List, Tuple\nfrom itertools import permutations\n\ndef optimize_delivery_route(n: int, distances: List[Tuple[int, int, int]]) -> List[int]:\n    \"\"\"\n    As a logistics manager for a delivery company, you need to optimize the delivery route for a fleet of trucks.\n    You have n cities numbered from 0 to n-1, and a list of distances between some pairs of cities.\n    Your task is to find the shortest path that visits all cities exactly once and returns to the starting city (city 0).\n\n    Take input from the user for the number of cities and the distances between pairs of cities.\n    Return the optimal route as a list of city indices.\n\n    The distances list contains tuples (a, b, d) where:\n    - a and b are city indices\n    - d is the distance between cities a and b\n\n    If no valid route exists, return an empty list.\n\n    Example:\n    Input: 4, [(0,1,10), (0,2,15), (0,3,20), (1,2,35), (1,3,25), (2,3,30)]\n    Output: [0, 1, 3, 2, 0]\n    Input: 3, [(0,1,10), (1,2,20)]\n    Output: []\n    \"\"\"\n", "entry_point": "optimize_delivery_route", "solution": "    # Create a distance matrix\n    dist_matrix = [[float('inf')] * n for _ in range(n)]\n    for a, b, d in distances:\n        dist_matrix[a][b] = d\n        dist_matrix[b][a] = d  # Assuming bidirectional roads\n\n    # Helper function to calculate the total distance of a route\n    def route_distance(route):\n        total_distance = 0\n        for i in range(len(route) - 1):\n            if dist_matrix[route[i]][route[i+1]] == float('inf'):\n                return float('inf')\n            total_distance += dist_matrix[route[i]][route[i+1]]\n        return total_distance\n\n    # Generate all possible routes\n    cities = list(range(1, n))  # Exclude the starting city (0)\n    all_routes = itertools.permutations(cities)\n\n    # Find the shortest valid route\n    shortest_route = []\n    min_distance = float('inf')\n\n    for route in all_routes:\n        current_route = [0] + list(route) + [0]  # Add starting and ending city\n        current_distance = route_distance(current_route)\n        \n        if current_distance < min_distance:\n            min_distance = current_distance\n            shortest_route = current_route\n\n    return shortest_route if min_distance != float('inf') else []\n", "test": "def check(candidate):\n    assert candidate(4, [(0,1,10), (1,2,20), (2,3,30), (3,0,40)]) == [0, 1, 2, 3, 0]\n    assert candidate(5, [(0,1,10), (1,2,20), (2,3,30), (3,4,40)]) == []\n    assert candidate(4, [(0,1,10), (0,2,20), (0,3,30), (1,2,40), (1,3,50), (2,3,60)]) == [0, 1, 2, 3, 0]\n    assert candidate(2, [(0,1,10)]) == [0, 1, 0]\n    assert candidate(3, [(0,1,10), (1,2,20)]) == []\n    assert candidate(4, [(0,1,10), (0,2,15), (0,3,20), (1,2,35), (1,3,25), (2,3,30)]) == [0, 1, 3, 2, 0]\n    assert candidate(3, [(0,1,10), (0,2,20), (1,2,30)]) == [0, 1, 2, 0]\n    assert candidate(6, [(0,1,10), (1,2,20), (2,3,30), (3,4,40), (4,5,50), (5,0,60)]) == [0, 1, 2, 3, 4, 5, 0]\n    assert candidate(3, [(0,1,10), (1,2,20), (2,0,30)]) == [0, 1, 2, 0]\n    assert candidate(5, [(0,1,10), (0,2,15), (0,3,20), (0,4,25), (1,2,35), (1,3,25), (1,4,30), (2,3,30), (2,4,20), (3,4,15)]) == [0, 1, 3, 4, 2, 0]\n", "language": "python"}
{"task_id": "revision1a_problem449", "prompt": "from typing import List, Tuple\nimport re\n\ndef parse_medical_records(records: List[str]) -> List[Tuple[str, str, int]]:\n    \"\"\"\n    Parse and sanitize medical records, extracting patient information and test results.\n    \n    Each record is in the format: 'Name: [First Last], ID: [A-Z]{2}[0-9]{6}, Test: [Test Name], Result: [0-9]+.[0-9]+'\n    \n    Your task is to:\n    1. Extract the patient's full name, ID, and test result (as an integer, rounded down).\n    2. Remove any records with invalid IDs (IDs must start with 'PT').\n    3. Sort the records by test result in descending order.\n    4. If two patients have the same test result, sort alphabetically by last name.\n    \n    Use regular expressions, lambda functions, and list comprehensions in your solution.\n    \n    Example:\n    Input: [\n        \"Name: John Doe, ID: PT123456, Test: Cholesterol, Result: 185.5\",\n        \"Name: Jane Smith, ID: DR789012, Test: Blood Sugar, Result: 110.0\",\n        \"Name: Bob Johnson, ID: PT654321, Test: Cholesterol, Result: 200.7\"\n    ]\n    Output: [\n        (\"Bob Johnson\", \"PT654321\", 200),\n        (\"John Doe\", \"PT123456\", 185)\n    ]\n    \"\"\"\n", "entry_point": "parse_medical_records", "solution": "    def parse_record(record):\n        pattern = r'Name: ([\\w\\s]+), ID: (PT\\d{6}), Test: [\\w\\s]+, Result: (\\d+\\.\\d+)'\n        match = re.match(pattern, record)\n        if match:\n            name, id, result = match.groups()\n            return (name, id, int(float(result)))\n        return None\n\n    parsed_records = [parse_record(record) for record in records if parse_record(record)]\n    \n    sorted_records = sorted(\n        parsed_records,\n        key=lambda x: (-x[2], x[0].split()[-1])  # Sort by result (descending) and last name\n    )\n    \n    return sorted_records\n\n", "test": "def check(candidate):\n    assert candidate([\"Name: Alice Brown, ID: PT111111, Test: Blood Pressure, Result: 120.0\"]) == [('Alice Brown', 'PT111111', 120)]\n    assert candidate([\"Name: Fiona Gray, ID: PT555555, Test: Iron, Result: 90.8\"]) == [('Fiona Gray', 'PT555555', 90)]\n    assert candidate([\"Name: David Black, ID: PT444444, Test: Vitamin D, Result: 30.5\"]) == [('David Black', 'PT444444', 30)]\n    assert candidate([\"Name: Bob Johnson, ID: PT654321, Test: Cholesterol, Result: 200.7\"]) == [('Bob Johnson', 'PT654321', 200)]\n    assert candidate([\"Name: John Doe, ID: PT123456, Test: Cholesterol, Result: 185.5\"]) == [('John Doe', 'PT123456', 185)]\n    assert candidate([\"Name: Helen Red, ID: PT777777, Test: Calcium, Result: 9.5\"]) == [('Helen Red', 'PT777777', 9)]\n    assert candidate([\"Name: Charlie White, ID: DR222222, Test: Hemoglobin, Result: 14.5\"]) == []\n    assert candidate([\"Name: Jane Smith, ID: PT789012, Test: Blood Sugar, Result: 110.0\"]) == [('Jane Smith', 'PT789012', 110)]\n    assert candidate([\"Name: George Blue, ID: PT666666, Test: Glucose, Result: 99.9\"]) == [('George Blue', 'PT666666', 99)]\n    assert candidate([\"Name: Eva Green, ID: PT333333, Test: Thyroid, Result: 3.2\"]) == [('Eva Green', 'PT333333', 3)]\n", "language": "python"}
{"task_id": "revision1a_problem267", "prompt": "import re\nfrom typing import List, Dict\n\ndef analyze_text(text: str) -> Dict[str, List[str]]:\n    \"\"\"\n    Analyze a given text and categorize words based on their length and starting letter.\n\n    This function demonstrates the use of regular expressions, dictionary comprehension,\n    and advanced string manipulation.\n\n    Parameters:\n    text (str): The input text to analyze\n\n    Returns:\n    Dict[str, List[str]]: A dictionary with the following keys:\n                          'short_words': List of words with 3 or fewer characters\n                          'medium_words': List of words with 4-6 characters\n                          'long_words': List of words with 7 or more characters\n                          'vowel_words': List of words starting with a vowel\n                          'consonant_words': List of words starting with a consonant\n\n    Example:\n    Input: \"The quick brown fox jumps over the lazy dog\"\n    Output: {\n        'short_words': ['The', 'fox', 'the', 'dog'],\n        'medium_words': ['quick', 'brown', 'jumps', 'over', 'lazy'],\n        'long_words': [],\n        'vowel_words': ['over'],\n        'consonant_words': ['The', 'quick', 'brown', 'fox', 'jumps', 'the', 'lazy', 'dog']\n    }\n\n    Note: Words are considered case-insensitive for categorization purposes.\n    \"\"\"\n", "entry_point": "analyze_text", "solution": "    # Use regex to split the text into words\n    words = re.findall(r'\\b\\w+\\b', text)\n    \n    # Define helper functions\n    def is_vowel_word(word):\n        return word[0].lower() in 'aeiou'\n    \n    def categorize_by_length(word):\n        length = len(word)\n        if length <= 3:\n            return 'short_words'\n        elif 4 <= length <= 6:\n            return 'medium_words'\n        else:\n            return 'long_words'\n    \n    # Initialize the result dictionary\n    result = {\n        'short_words': [],\n        'medium_words': [],\n        'long_words': [],\n        'vowel_words': [],\n        'consonant_words': []\n    }\n    \n    # Categorize words\n    for word in words:\n        length_category = categorize_by_length(word)\n        result[length_category].append(word)\n        \n        if is_vowel_word(word):\n            result['vowel_words'].append(word)\n        else:\n            result['consonant_words'].append(word)\n    \n    return result\n", "test": "def check(candidate):\n    assert candidate(\"The quick brown fox jumps over the lazy dog\") == {'short_words': ['The', 'fox', 'the', 'dog'], 'medium_words': ['quick', 'brown', 'jumps', 'over', 'lazy'], 'long_words': [], 'vowel_words': ['over'], 'consonant_words': ['The', 'quick', 'brown', 'fox', 'jumps', 'the', 'lazy', 'dog']}\n    assert candidate(\"To be or not to be, that is the question\") == {'short_words': ['To', 'be', 'or', 'not', 'to', 'be', 'is', 'the'], 'medium_words': ['that'], 'long_words': ['question'], 'vowel_words': ['or', 'is'], 'consonant_words': ['To', 'be', 'not', 'to', 'be', 'that', 'the', 'question']}\n    assert candidate(\"A\") == {'short_words': ['A'], 'medium_words': [], 'long_words': [], 'vowel_words': ['A'], 'consonant_words': []}\n    assert candidate(\"Hello world! How are you today?\") == {'short_words': ['How', 'are', 'you'], 'medium_words': ['Hello', 'world', 'today'], 'long_words': [], 'vowel_words': ['are'], 'consonant_words': ['Hello', 'world', 'How', 'you', 'today']}\n    assert candidate(\"Supercalifragilisticexpialidocious\") == {'short_words': [], 'medium_words': [], 'long_words': ['Supercalifragilisticexpialidocious'], 'vowel_words': [], 'consonant_words': ['Supercalifragilisticexpialidocious']}\n    assert candidate(\"a b c d e f g h i j k l m n o p\") == {'short_words': ['a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm', 'n', 'o', 'p'], 'medium_words': [], 'long_words': [], 'vowel_words': ['a', 'e', 'i', 'o'], 'consonant_words': ['b', 'c', 'd', 'f', 'g', 'h', 'j', 'k', 'l', 'm', 'n', 'p']}\n    assert candidate(\"Python is a powerful programming language\") == {'short_words': ['is', 'a'], 'medium_words': ['Python'], 'long_words': ['powerful', 'programming', 'language'], 'vowel_words': ['is', 'a'], 'consonant_words': ['Python', 'powerful', 'programming', 'language']}\n    assert candidate(\"aeiou\") == {'short_words': [], 'medium_words': ['aeiou'], 'long_words': [], 'vowel_words': ['aeiou'], 'consonant_words': []}\n    assert candidate(\"\") == {'short_words': [], 'medium_words': [], 'long_words': [], 'vowel_words': [], 'consonant_words': []}\n    assert candidate(\"1234 5678 90\") == {'short_words': ['90'], 'medium_words': ['1234', '5678'], 'long_words': [], 'vowel_words': [], 'consonant_words': ['1234', '5678', '90']}\n", "language": "python"}
{"task_id": "revision1a_problem110", "prompt": "from typing import List, Tuple\n\ndef optimize_investment(budget: int, projects: List[Tuple[str, int, float]]) -> List[str]:\n    \"\"\"\n    As a financial advisor, you need to help a client optimize their investment portfolio.\n    Given a budget and a list of potential investment projects, each with a name, cost, and expected return on investment (ROI),\n    determine the best combination of projects to maximize the total ROI while staying within the budget.\n\n    The function should take an integer representing the budget and a list of tuples, where each tuple contains:\n    (project_name: str, cost: int, roi: float)\n\n    Return a list of project names that represent the optimal investment portfolio.\n\n    Use dynamic programming to solve this knapsack-like problem efficiently.\n\n    Example:\n    Input:\n    budget = 1000\n    projects = [\n        (\"Project A\", 200, 0.2),\n        (\"Project B\", 300, 0.3),\n        (\"Project C\", 400, 0.4),\n        (\"Project D\", 500, 0.5),\n        (\"Project E\", 600, 0.6)\n    ]\n\n    Output:\n    [\"Project B\", \"Project D\"]\n    \"\"\"\n", "entry_point": "optimize_investment", "solution": "    n = len(projects)\n    \n    # Create a 2D table to store the maximum ROI for each subproblem\n    dp = [[0.0] * (budget + 1) for _ in range(n + 1)]\n    \n    # Fill the dp table\n    for i in range(1, n + 1):\n        for j in range(budget + 1):\n            name, cost, roi = projects[i - 1]\n            if cost <= j:\n                dp[i][j] = max(dp[i - 1][j], dp[i - 1][j - cost] + roi)\n            else:\n                dp[i][j] = dp[i - 1][j]\n    \n    # Backtrack to find the selected projects\n    selected_projects = []\n    i, j = n, budget\n    while i > 0 and j > 0:\n        if dp[i][j] != dp[i - 1][j]:\n            name, cost, roi = projects[i - 1]\n            selected_projects.append(name)\n            j -= cost\n        i -= 1\n    \n    # Reverse the list to get the projects in order\n    selected_projects.reverse()\n    \n    return selected_projects\n", "test": "def check(candidate):\n    assert candidate(999, [(\"A\", 1000, 1.0)]) == []\n    assert candidate(1000, [(\"A\", 500, 0.5), (\"B\", 500, 0.5)]) == ['A', 'B']\n    assert candidate(1000, []) == []\n    assert candidate(0, [(\"P\", 100, 0.5), (\"Q\", 200, 0.7)]) == []\n    assert candidate(2000, [(\"P1\", 500, 0.5), (\"P2\", 750, 0.6), (\"P3\", 1000, 0.7)]) == ['P2', 'P3']\n    assert candidate(1000, [(\"Project A\", 200, 0.2), (\"Project B\", 300, 0.3), (\"Project C\", 400, 0.4), (\"Project D\", 500, 0.5), (\"Project E\", 600, 0.6)]) == ['Project A', 'Project B', 'Project D']\n    assert candidate(1000, [(\"X\", 1000, 1.0)]) == ['X']\n    assert candidate(1000, [(\"A\", 100, 0.1), (\"B\", 200, 0.2), (\"C\", 300, 0.3), (\"D\", 400, 0.4)]) == ['A', 'B', 'C', 'D']\n    assert candidate(100, [(\"S\", 50, 0.1), (\"M\", 50, 0.2)]) == ['S', 'M']\n    assert candidate(500, [(\"A\", 100, 0.1), (\"B\", 200, 0.2), (\"C\", 300, 0.3)]) == ['B', 'C']\n", "language": "python"}
{"task_id": "revision1a_problem154", "prompt": "from typing import List, Tuple\n\ndef optimize_delivery_route(packages: List[Tuple[str, float, float]], fuel_capacity: float) -> List[str]:\n    \"\"\"\n    You are a delivery driver for an e-commerce company tasked with optimizing your delivery route.\n    Given a list of packages to deliver, each represented by a tuple containing the package ID, \n    its weight, and the distance to its destination, your goal is to maximize the number of \n    packages delivered while staying within your vehicle's fuel capacity.\n\n    Write a Python function that takes the list of packages and the fuel capacity as input, \n    and returns a list of package IDs representing the optimal delivery route.\n\n    Assumptions:\n    - Your vehicle consumes 1 unit of fuel per unit of weight per unit of distance.\n    - You must return to the starting point after each delivery.\n    - Packages can be delivered in any order.\n\n    Example:\n    Input: \n    packages = [(\"P1\", 10, 5), (\"P2\", 5, 10), (\"P3\", 8, 7), (\"P4\", 3, 15)]\n    fuel_capacity = 200\n\n    Output: [\"P2\", \"P4\", \"P3\"]\n\n    Explanation: This route allows delivery of 3 packages within the fuel capacity:\n    P2 consumes 5 * 10 * 2 = 100 fuel (round trip)\n    P4 consumes 3 * 15 * 2 = 90 fuel (round trip)\n    P3 consumes 8 * 7 * 2 = 112 fuel (round trip)\n    Total fuel consumed: 302, which is within the 400 fuel capacity for two round trips.\n    P1 cannot be included as it would exceed the fuel capacity.\n    \"\"\"\n", "entry_point": "optimize_delivery_route", "solution": "    def fuel_consumption(package):\n        return package[1] * package[2] * 2  # weight * distance * 2 (round trip)\n\n    # Sort packages by fuel consumption in ascending order\n    sorted_packages = sorted(packages, key=fuel_consumption)\n\n    optimal_route = []\n    total_fuel = 0\n\n    for package in sorted_packages:\n        package_fuel = fuel_consumption(package)\n        if total_fuel + package_fuel <= fuel_capacity:\n            optimal_route.append(package[0])  # Add package ID to the route\n            total_fuel += package_fuel\n        else:\n            break  # Stop if adding the next package would exceed fuel capacity\n\n    return optimal_route\n", "test": "def check(candidate):\n    assert candidate([(\"P1\", 1, 1), (\"P2\", 1, 1), (\"P3\", 1, 1), (\"P4\", 1, 1), (\"P5\", 1, 1)], 10) == ['P1', 'P2', 'P3', 'P4', 'P5']\n    assert candidate([(\"P1\", 1, 100)], 200) == ['P1']\n    assert candidate([(\"P1\", 10, 10), (\"P2\", 10, 10), (\"P3\", 10, 10)], 400) == ['P1', 'P2']\n    assert candidate([(\"P1\", 1, 1), (\"P2\", 2, 2), (\"P3\", 3, 3)], 50) == ['P1', 'P2', 'P3']\n    assert candidate([(\"P1\", 5, 20), (\"P2\", 10, 10), (\"P3\", 15, 5)], 300) == ['P3']\n    assert candidate([(\"P1\", 1, 1)], 1) == []\n    assert candidate([(\"P1\", 50, 1), (\"P2\", 1, 50)], 150) == ['P1']\n    assert candidate([(\"P1\", 10, 5), (\"P2\", 5, 10), (\"P3\", 8, 7), (\"P4\", 3, 15)], 200) == ['P4', 'P1']\n    assert candidate([(\"P1\", 100, 1)], 199) == []\n    assert candidate([(\"P1\", 0.5, 0.5), (\"P2\", 0.5, 0.5)], 1) == ['P1', 'P2']\n", "language": "python"}
{"task_id": "revision1a_problem364", "prompt": "from typing import List\n\ndef manage_library(actions: List[str]) -> List[str]:\n    \"\"\"\n    Create a Python class named Library that represents a library management system.\n    The Library class should support the following operations:\n    1. Initialization: The class should be initialized with a library name and an initial book inventory.\n    2. Add and Remove Books: Implement methods add_book and remove_book that allow adding new books to the inventory and removing existing ones.\n    3. Borrow and Return: Implement methods borrow_book and return_book for users to borrow and return books. Ensure that a book can't be borrowed if it's not available.\n    4. Search: Implement a method search_book that returns all books matching a given title or author.\n    Take input from the user for the library name and initial inventory. Later, take input for actions like adding, removing, borrowing, returning, or searching for books.\n    Example\n    Input: [\"Central Library\", \"Pride and Prejudice,To Kill a Mockingbird\", \"Add\", \"1984\", \"Borrow\", \"To Kill a Mockingbird\", \"Search\", \"1984\", \"Return\", \"To Kill a Mockingbird\", \"Exit\"]\n    Output: [\"Book '1984' added successfully\", \"Book 'To Kill a Mockingbird' borrowed successfully\", \"Book '1984' found in inventory\", \"Book 'To Kill a Mockingbird' returned successfully\"]\n    \"\"\"\n", "entry_point": "manage_library", "solution": "    class Library:\n        def __init__(self, name, initial_inventory):\n            self.name = name\n            self.inventory = initial_inventory\n            self.borrowed_books = []\n\n        def add_book(self, book):\n            self.inventory.append(book)\n            return f\"Book '{book}' added successfully\"\n\n        def remove_book(self, book):\n            if book in self.inventory:\n                self.inventory.remove(book)\n                return f\"Book '{book}' removed successfully\"\n            return f\"Book '{book}' not found in inventory\"\n\n        def borrow_book(self, book):\n            if book in self.inventory:\n                self.inventory.remove(book)\n                self.borrowed_books.append(book)\n                return f\"Book '{book}' borrowed successfully\"\n            return f\"Book '{book}' not available for borrowing\"\n\n        def return_book(self, book):\n            if book in self.borrowed_books:\n                self.borrowed_books.remove(book)\n                self.inventory.append(book)\n                return f\"Book '{book}' returned successfully\"\n            return f\"Book '{book}' was not borrowed from this library\"\n\n        def search_book(self, query):\n            results = [book for book in self.inventory if query.lower() in book.lower()]\n            if results:\n                return f\"Book '{query}' found in inventory\"\n            return f\"No books found matching '{query}'\"\n\n    output = []\n    library_name = actions[0]\n    initial_inventory = actions[1].split(',')\n    library = Library(library_name, initial_inventory)\n\n    for i in range(2, len(actions), 2):\n        action = actions[i]\n        if action == \"Exit\":\n            break\n        \n        if i + 1 < len(actions):\n            book = actions[i + 1]\n            \n            if action == \"Add\":\n                output.append(library.add_book(book))\n            elif action == \"Remove\":\n                output.append(library.remove_book(book))\n            elif action == \"Borrow\":\n                output.append(library.borrow_book(book))\n            elif action == \"Return\":\n                output.append(library.return_book(book))\n            elif action == \"Search\":\n                output.append(library.search_book(book))\n\n    return output\n", "test": "def check(candidate):\n    assert candidate([\"Science Library\", \"A Brief History of Time,Cosmos\", \"Add\", \"The Selfish Gene\", \"Borrow\", \"Cosmos\", \"Search\", \"History\", \"Return\", \"Cosmos\", \"Exit\"]) == [\"Book 'The Selfish Gene' added successfully\", \"Book 'Cosmos' borrowed successfully\", \"Book 'History' found in inventory\", \"Book 'Cosmos' returned successfully\"]\n    assert candidate([\"Local Library\", \"Lord of the Rings,The Hobbit\", \"Add\", \"The Silmarillion\", \"Search\", \"Tolkien\", \"Borrow\", \"The Hobbit\", \"Return\", \"The Hobbit\", \"Exit\"]) == [\"Book 'The Silmarillion' added successfully\", \"No books found matching 'Tolkien'\", \"Book 'The Hobbit' borrowed successfully\", \"Book 'The Hobbit' returned successfully\"]\n    assert candidate([\"Romance Library\", \"Pride and Prejudice,Romeo and Juliet\", \"Add\", \"Outlander\", \"Borrow\", \"Pride and Prejudice\", \"Search\", \"Love\", \"Exit\"]) == [\"Book 'Outlander' added successfully\", \"Book 'Pride and Prejudice' borrowed successfully\", \"No books found matching 'Love'\"]\n    assert candidate([\"City Library\", \"The Great Gatsby,Moby Dick\", \"Add\", \"1984\", \"Borrow\", \"Moby Dick\", \"Search\", \"1984\", \"Return\", \"Moby Dick\", \"Exit\"]) == [\"Book '1984' added successfully\", \"Book 'Moby Dick' borrowed successfully\", \"Book '1984' found in inventory\", \"Book 'Moby Dick' returned successfully\"]\n    assert candidate([\"School Library\", \"\", \"Add\", \"Harry Potter\", \"Add\", \"The Hobbit\", \"Borrow\", \"Harry Potter\", \"Search\", \"The\", \"Exit\"]) == [\"Book 'Harry Potter' added successfully\", \"Book 'The Hobbit' added successfully\", \"Book 'Harry Potter' borrowed successfully\", \"Book 'The' found in inventory\"]\n    assert candidate([\"Mystery Library\", \"The Da Vinci Code,Gone Girl\", \"Add\", \"The Girl with the Dragon Tattoo\", \"Borrow\", \"Gone Girl\", \"Search\", \"Girl\", \"Exit\"]) == [\"Book 'The Girl with the Dragon Tattoo' added successfully\", \"Book 'Gone Girl' borrowed successfully\", \"Book 'Girl' found in inventory\"]\n    assert candidate([\"Public Library\", \"To Kill a Mockingbird,Pride and Prejudice,1984\", \"Remove\", \"Pride and Prejudice\", \"Borrow\", \"1984\", \"Search\", \"To Kill\", \"Exit\"]) == [\"Book 'Pride and Prejudice' removed successfully\", \"Book '1984' borrowed successfully\", \"Book 'To Kill' found in inventory\"]\n    assert candidate([\"University Library\", \"The Catcher in the Rye,Brave New World\", \"Add\", \"Animal Farm\", \"Borrow\", \"Brave New World\", \"Borrow\", \"Animal Farm\", \"Return\", \"Brave New World\", \"Exit\"]) == [\"Book 'Animal Farm' added successfully\", \"Book 'Brave New World' borrowed successfully\", \"Book 'Animal Farm' borrowed successfully\", \"Book 'Brave New World' returned successfully\"]\n    assert candidate([\"Kids Library\", \"Green Eggs and Ham,The Cat in the Hat\", \"Add\", \"Oh, the Places You\\'ll Go!\", \"Borrow\", \"The Cat in the Hat\", \"Search\", \"Dr. Seuss\", \"Exit\"]) == [\"Book 'Oh, the Places You'll Go!' added successfully\", \"Book 'The Cat in the Hat' borrowed successfully\", \"No books found matching 'Dr. Seuss'\"]\n    assert candidate([\"Digital Library\", \"Neuromancer,Snow Crash\", \"Add\", \"Ready Player One\", \"Borrow\", \"Neuromancer\", \"Search\", \"Cyber\", \"Return\", \"Neuromancer\", \"Exit\"]) == [\"Book 'Ready Player One' added successfully\", \"Book 'Neuromancer' borrowed successfully\", \"No books found matching 'Cyber'\", \"Book 'Neuromancer' returned successfully\"]\n", "language": "python"}
{"task_id": "revision1a_problem320", "prompt": "import math\nfrom typing import List, Tuple\n\ndef optimize_delivery_route(locations: List[Tuple[float, float]], start: Tuple[float, float]) -> List[int]:\n    \"\"\"\n    You are a logistics manager for an e-commerce company, tasked with optimizing the delivery route for a courier.\n    The courier needs to visit multiple locations in a city, starting from a given point, and return to the same point at the end.\n    Your goal is to find the most efficient route that minimizes the total distance traveled.\n\n    This function implements the Traveling Salesman Problem (TSP) using a nearest neighbor heuristic algorithm.\n\n    Args:\n    locations (List[Tuple[float, float]]): A list of tuples representing the (latitude, longitude) coordinates of delivery locations.\n    start (Tuple[float, float]): The starting point coordinates (latitude, longitude) for the courier.\n\n    Returns:\n    List[int]: An ordered list of indices representing the optimized route, including the return to the start point.\n\n    Example:\n    Input: \n    locations = [(40.7128, -74.0060), (34.0522, -118.2437), (41.8781, -87.6298), (29.7604, -95.3698)]\n    start = (38.9072, -77.0369)\n    \n    Output: [0, 2, 1, 3, 0]\n\n    This output suggests the courier should visit the locations in the order: start -> 0 -> 2 -> 1 -> 3 -> start\n    \"\"\"\n", "entry_point": "optimize_delivery_route", "solution": "    def calculate_distance(point1: Tuple[float, float], point2: Tuple[float, float]) -> float:\n        \"\"\"Calculate the Euclidean distance between two points.\"\"\"\n        return math.sqrt((point1[0] - point2[0])**2 + (point1[1] - point2[1])**2)\n\n    num_locations = len(locations)\n    unvisited = set(range(num_locations))\n    route = []\n    current = start\n\n    while unvisited:\n        nearest = min(unvisited, key=lambda x: calculate_distance(current, locations[x]))\n        route.append(nearest)\n        unvisited.remove(nearest)\n        current = locations[nearest]\n\n    # Add the first location to complete the loop\n    route.append(route[0])\n\n    return route\n", "test": "def check(candidate):\n    assert candidate([(1, 1), (2, 2)], (0, 0)) == [0, 1, 0]\n    assert candidate([(i, 0) for i in range(10)], (5, 0)) == [5, 4, 3, 2, 1, 0, 6, 7, 8, 9, 5]\n    assert candidate([(i, i) for i in range(100)], (50, 50)) == [50, 49, 48, 47, 46, 45, 44, 43, 42, 41, 40, 39, 38, 37, 36, 35, 34, 33, 32, 31, 30, 29, 28, 27, 26, 25, 24, 23, 22, 21, 20, 19, 18, 17, 16, 15, 14, 13, 12, 11, 10, 9, 8, 7, 6, 5, 4, 3, 2, 1, 0, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99, 50]\n    assert candidate([(40.7128, -74.0060), (34.0522, -118.2437), (41.8781, -87.6298), (29.7604, -95.3698)], (38.9072, -77.0369)) == [0, 2, 3, 1, 0]\n    assert candidate([(1, 1), (1, 1), (1, 1)], (0, 0)) == [0, 1, 2, 0]\n    assert candidate([(0, 0), (0, 0), (1, 1)], (0, 0)) == [0, 1, 2, 0]\n    assert candidate([(90, 180), (-90, -180), (0, 0)], (45, 45)) == [2, 0, 1, 2]\n    assert candidate([(0, 0), (0, 1), (1, 0), (1, 1)], (0.5, 0.5)) == [0, 1, 3, 2, 0]\n    assert candidate([(0, 0), (1, 1), (2, 2), (3, 3)], (0, 0)) == [0, 1, 2, 3, 0]\n    assert candidate([(10, 10)], (0, 0)) == [0, 0]\n", "language": "python"}
{"task_id": "revision1a_problem304", "prompt": "from typing import Dict\n\ndef calculate_carbon_footprint(activities: Dict[str, float]) -> float:\n    \"\"\"\n    Calculate an individual's carbon footprint based on their daily activities.\n    \n    The function takes a dictionary of activities and their corresponding values:\n    - 'driving': miles driven per day\n    - 'electricity': kWh used per day\n    - 'meat_consumption': ounces of meat consumed per day\n    - 'flying': miles flown per year (divided by 365 for daily impact)\n    \n    Return the total daily carbon footprint in kg of CO2 equivalent.\n    \n    Use the following conversion factors:\n    - Driving: 0.4 kg CO2 per mile\n    - Electricity: 0.5 kg CO2 per kWh\n    - Meat consumption: 0.2 kg CO2 per ounce\n    - Flying: 0.18 kg CO2 per mile\n    \n    Example:\n    Input: {'driving': 20, 'electricity': 10, 'meat_consumption': 6, 'flying': 7300}\n    Output: 22.6\n    \n    Input: {'driving': 0, 'electricity': 5, 'meat_consumption': 0, 'flying': 0}\n    Output: 2.5\n    \"\"\"\n", "entry_point": "calculate_carbon_footprint", "solution": "    conversion_factors = {\n        'driving': 0.4,\n        'electricity': 0.5,\n        'meat_consumption': 0.2,\n        'flying': 0.18 / 365  # Convert yearly miles to daily impact\n    }\n    \n    total_carbon_footprint = 0\n    \n    for activity, value in activities.items():\n        if activity in conversion_factors:\n            total_carbon_footprint += value * conversion_factors[activity]\n    \n    return round(total_carbon_footprint, 1)\n", "test": "def check(candidate):\n    assert candidate({'driving': 10, 'electricity': 8, 'meat_consumption': 4, 'flying': 5000}) == 11.3\n    assert candidate({'driving': 5, 'electricity': 3, 'meat_consumption': 2, 'flying': 1000}) == 4.4\n    assert candidate({'driving': 0, 'electricity': 5, 'meat_consumption': 0, 'flying': 0}) == 2.5\n    assert candidate({'driving': 50, 'electricity': 15, 'meat_consumption': 8, 'flying': 10000}) == 34.0\n    assert candidate({'driving': 20, 'electricity': 10, 'meat_consumption': 6, 'flying': 7300}) == 17.8\n    assert candidate({'driving': 0.5, 'electricity': 0.5, 'meat_consumption': 0.5, 'flying': 182.5}) == 0.6\n    assert candidate({'driving': 100, 'electricity': 20, 'meat_consumption': 16, 'flying': 20000}) == 63.1\n    assert candidate({'driving': 1, 'electricity': 1, 'meat_consumption': 1, 'flying': 365}) == 1.3\n    assert candidate({'driving': 30, 'electricity': 12, 'meat_consumption': 10, 'flying': 3650}) == 21.8\n", "language": "python"}
{"task_id": "revision1a_problem97", "prompt": "from typing import List, Tuple\nfrom collections import defaultdict\n\ndef optimize_delivery(packages: List[Tuple[int, int, int]]) -> List[int]:\n    \"\"\"\n    You're working for a delivery company that needs to optimize its package loading process.\n    Write a function that determines the best order to load packages onto a truck to minimize unloading time.\n    \n    Each package is represented by a tuple (weight, value, destination).\n    The truck has a weight capacity of 1000 kg and can hold up to 50 packages.\n    Packages must be unloaded in the reverse order they were loaded (last in, first out).\n    The goal is to maximize the total value while ensuring that packages for each destination are grouped together.\n    \n    Take input from the user for the list of packages and return a list of indices representing the optimal loading order.\n    \n    Example:\n    Input: [(50, 100, 1), (30, 80, 2), (40, 90, 1), (60, 110, 3), (55, 70, 2)]\n    Output: [4, 1, 2, 0, 3]\n    \"\"\"\n", "entry_point": "optimize_delivery", "solution": "    # Group packages by destination\n    destinations = defaultdict(list)\n    for i, (weight, value, dest) in enumerate(packages):\n        destinations[dest].append((i, weight, value))\n    \n    # Sort destinations by total value (descending)\n    sorted_destinations = sorted(destinations.items(), key=lambda x: sum(p[2] for p in x[1]), reverse=True)\n    \n    result = []\n    total_weight = 0\n    total_packages = 0\n    \n    for dest, packages_list in sorted_destinations:\n        # Sort packages within each destination by value-to-weight ratio (descending)\n        packages_list.sort(key=lambda x: x[2] / x[1], reverse=True)\n        \n        for idx, weight, value in packages_list:\n            if total_weight + weight <= 1000 and total_packages < 50:\n                result.append(idx)\n                total_weight += weight\n                total_packages += 1\n            else:\n                break\n        \n        if total_weight >= 1000 or total_packages >= 50:\n            break\n    \n    # Reverse the result to get the loading order (last in, first out)\n    return result[::-1]\n", "test": "def check(candidate):\n    assert candidate([(20, 30, 1)] * 49 + [(30, 40, 2)]) == [48, 47, 46, 45, 44, 43, 42, 41, 40, 39, 38, 37, 36, 35, 34, 33, 32, 31, 30, 29, 28, 27, 26, 25, 24, 23, 22, 21, 20, 19, 18, 17, 16, 15, 14, 13, 12, 11, 10, 9, 8, 7, 6, 5, 4, 3, 2, 1, 0]\n    assert candidate([(50, 100, 1), (50, 200, 1), (50, 300, 1), (50, 400, 1), (50, 500, 1)]) == [0, 1, 2, 3, 4]\n    assert candidate([(10, 20, 1)] * 50) == [49, 48, 47, 46, 45, 44, 43, 42, 41, 40, 39, 38, 37, 36, 35, 34, 33, 32, 31, 30, 29, 28, 27, 26, 25, 24, 23, 22, 21, 20, 19, 18, 17, 16, 15, 14, 13, 12, 11, 10, 9, 8, 7, 6, 5, 4, 3, 2, 1, 0]\n    assert candidate([(10, 10, 1), (20, 20, 2), (30, 30, 3), (40, 40, 4), (50, 50, 5)] * 10) == [0, 12, 7, 2, 48, 43, 38, 33, 28, 23, 18, 13, 8, 3, 49, 44, 39, 34, 29, 24, 19, 14, 9, 4]\n    assert candidate([(1000, 1000, 1)]) == [0]\n    assert candidate([(100, 100, 1), (200, 50, 2), (300, 25, 3), (400, 10, 4), (500, 5, 5)]) == [3, 2, 1, 0]\n    assert candidate([(50, 100, 1), (30, 80, 2), (40, 90, 1), (60, 110, 3), (55, 70, 2)]) == [3, 4, 1, 0, 2]\n    assert candidate([(100, 200, 1), (200, 300, 2), (300, 400, 3), (400, 500, 4), (500, 600, 5)]) == [0, 3, 4]\n    assert candidate([(100, 100, i) for i in range(1, 11)]) == [9, 8, 7, 6, 5, 4, 3, 2, 1, 0]\n    assert candidate([(999, 1000, 1), (1, 1, 2)]) == [1, 0]\n", "language": "python"}
{"task_id": "revision1a_problem333", "prompt": "from typing import List, Tuple\nimport math\n\ndef optimize_delivery_route(warehouses: List[Tuple[float, float]], destinations: List[Tuple[float, float]], fuel_capacity: float, fuel_consumption: float) -> List[int]:\n    \"\"\"\n    As a logistics manager for a delivery company, I need to optimize our delivery routes. \n    We have multiple warehouses and multiple delivery destinations. Our delivery truck has a limited fuel capacity,\n    and we need to determine the most efficient route that visits all destinations while minimizing fuel stops.\n\n    Write a function that takes the following inputs:\n    - A list of warehouse locations (each as a tuple of x, y coordinates)\n    - A list of destination locations (each as a tuple of x, y coordinates)\n    - The fuel capacity of the truck (in liters)\n    - The fuel consumption rate (in liters per unit distance)\n\n    Return a list of integers representing the optimal route. Each integer should be the index of a location\n    (negative for warehouses, positive for destinations) in the order they should be visited.\n    Use 0 to represent returning to the starting warehouse.\n\n    Implement this using a combination of nearest neighbor heuristic and dynamic programming for fuel management.\n\n    Example:\n    Input: [(0, 0), (100, 100)], [(20, 20), (40, 40), (60, 60), (80, 80)], 50, 0.1\n    Output: [-1, 1, 2, -2, 3, 4, 0]\n\n    Input: [(0, 0), (50, 50), (100, 100)], [(25, 25), (75, 75), (60, 40), (40, 60)], 40, 0.2\n    Output: [-1, 1, 3, -2, 4, 2, -3, 0]\n    \"\"\"\n", "entry_point": "optimize_delivery_route", "solution": "    def distance(p1, p2):\n        return math.sqrt((p1[0] - p2[0])**2 + (p1[1] - p2[1])**2)\n\n    def nearest_neighbor(current, locations):\n        return min(range(len(locations)), key=lambda i: distance(current, locations[i]))\n\n    route = [-1]  # Start from the first warehouse\n    current_location = warehouses[0]\n    remaining_fuel = fuel_capacity\n    unvisited_destinations = list(destinations)\n\n    while unvisited_destinations:\n        nearest_dest_index = nearest_neighbor(current_location, unvisited_destinations)\n        nearest_dest = unvisited_destinations[nearest_dest_index]\n        dist_to_dest = distance(current_location, nearest_dest)\n        fuel_needed = dist_to_dest * fuel_consumption\n\n        if fuel_needed <= remaining_fuel:\n            # Can reach the destination with current fuel\n            route.append(destinations.index(nearest_dest) + 1)\n            current_location = nearest_dest\n            remaining_fuel -= fuel_needed\n            unvisited_destinations.pop(nearest_dest_index)\n        else:\n            # Need to refuel\n            nearest_warehouse_index = nearest_neighbor(current_location, warehouses)\n            if nearest_warehouse_index + 1 == abs(route[-1]):\n                # Already at the nearest warehouse, just refuel\n                remaining_fuel = fuel_capacity\n            else:\n                # Go to the nearest warehouse\n                route.append(-(nearest_warehouse_index + 1))\n                current_location = warehouses[nearest_warehouse_index]\n                remaining_fuel = fuel_capacity\n\n    # Return to the starting warehouse\n    route.append(0)\n\n    return route\n", "test": "def check(candidate):\n    assert candidate([(0, 0), (100, 0), (0, 100)], [(50, 50)], 75, 0.5) == [-1, 1, 0]\n    assert candidate([(0, 0)], [(10, 10), (20, 20), (30, 30)], 100, 0.1) == [-1, 1, 2, 3, 0]\n    assert candidate([(0, 0)], [(10, 10)], 100, 0.1) == [-1, 1, 0]\n    assert candidate([(0, 0), (1, 1)], [(0.5, 0.5)], 1, 0.1) == [-1, 1, 0]\n    assert candidate([(0, 0), (100, 100)], [(50, 50)], 100, 0.1) == [-1, 1, 0]\n    assert candidate([(0, 0), (10, 10)], [(5, 5), (15, 15)], 20, 1) == [-1, 1, 2, 0]\n    assert candidate([(0, 0)], [(1, 1), (2, 2), (3, 3), (4, 4), (5, 5)], 10, 0.5) == [-1, 1, 2, 3, 4, 5, 0]\n    assert candidate([(0, 0), (50, 50), (100, 100)], [(25, 25), (75, 75)], 100, 0.1) == [-1, 1, 2, 0]\n    assert candidate([(0, 0), (100, 100), (200, 200)], [(50, 50), (150, 150)], 200, 0.2) == [-1, 1, 2, 0]\n    assert candidate([(0, 0)], [(10, 0), (0, 10), (10, 10)], 50, 0.2) == [-1, 1, 3, 2, 0]\n", "language": "python"}
{"task_id": "revision1a_problem705", "prompt": "from typing import List, Tuple\n\ndef stock_profit(prices: List[int], k: int) -> int:\n    \"\"\"\n    Given a list of stock prices for n days and a number k, calculate the maximum profit\n    that can be made by buying and selling stocks with at most k transactions.\n    A transaction consists of buying a stock on one day and selling it on a later day.\n    You cannot engage in multiple transactions simultaneously (i.e., you must sell the\n    stock before you buy again).\n\n    Take the list of stock prices and k as input from the user and return the maximum profit.\n\n    Example:\n    Input: prices = [3,2,6,5,0,3], k = 2\n    Output: 7\n    Explanation: Buy on day 2 (price = 2) and sell on day 3 (price = 6), profit = 6-2 = 4.\n                 Then buy on day 5 (price = 0) and sell on day 6 (price = 3), profit = 3-0 = 3.\n    \n    Input: prices = [3,3,5,0,0,3,1,4], k = 2\n    Output: 6\n    Explanation: Buy on day 3 (price = 5) and sell on day 4 (price = 0), profit = 0-5 = -5.\n                 Then buy on day 5 (price = 0) and sell on day 8 (price = 4), profit = 4-0 = 4.\n                 Then buy on day 7 (price = 1) and sell on day 8 (price = 4), profit = 4-1 = 3.\n                 Total profit: -5 + 4 + 3 = 2.\n    \"\"\"\n", "entry_point": "stock_profit", "solution": "    if not prices or k == 0:\n        return 0\n\n    n = len(prices)\n    \n    # If k is larger than or equal to n/2, we can make maximum profit by making all profitable transactions\n    if k >= n // 2:\n        return sum(max(0, prices[i] - prices[i-1]) for i in range(1, n))\n\n    # Initialize the profit table\n    profit = [[0 for _ in range(n)] for _ in range(k+1)]\n\n    for i in range(1, k+1):\n        max_diff = -prices[0]\n        for j in range(1, n):\n            profit[i][j] = max(profit[i][j-1], prices[j] + max_diff)\n            max_diff = max(max_diff, profit[i-1][j] - prices[j])\n\n    return profit[k][n-1]\n", "test": "def check(candidate):\n    assert candidate([5,4,3,2,1], 1) == 0\n    assert candidate([3,3,5,0,0,3,1,4], 2) == 6\n    assert candidate([10,22,5,75,65,80], 2) == 87\n    assert candidate([3,2,6,5,0,3], 2) == 7\n    assert candidate([1], 1) == 0\n    assert candidate([1,2,3,4,5], 5) == 4\n    assert candidate([1,2,3,4,5], 1) == 4\n    assert candidate([90,80,70,60,50], 1) == 0\n    assert candidate([100,30,15,10,8,25,80], 3) == 72\n    assert candidate([1,1,1,1,1], 3) == 0\n", "language": "python"}
{"task_id": "revision1a_problem548", "prompt": "from typing import List\n\ndef spiral_matrix(n: int) -> List[List[int]]:\n    \"\"\"\n    Generate a spiral matrix of size n x n filled with numbers from 1 to n^2.\n    The matrix should be filled in a clockwise spiral pattern starting from the top-left corner.\n    This function could be used in game development for generating spiral-shaped levels or puzzles.\n\n    Take an integer n as input from the user, return a 2D list representing the spiral matrix.\n\n    Example:\n    Input: 3\n    Output: [[1, 2, 3],\n             [8, 9, 4],\n             [7, 6, 5]]\n\n    Input: 4\n    Output: [[1,  2,  3,  4],\n             [12, 13, 14, 5],\n             [11, 16, 15, 6],\n             [10, 9,  8,  7]]\n    \"\"\"\n", "entry_point": "spiral_matrix", "solution": "    # Initialize the matrix with zeros\n    matrix = [[0 for _ in range(n)] for _ in range(n)]\n    \n    # Define the boundaries of the current spiral\n    top, bottom, left, right = 0, n - 1, 0, n - 1\n    \n    # Initialize the current number to be filled\n    num = 1\n    \n    while num <= n * n:\n        # Fill top row\n        for i in range(left, right + 1):\n            matrix[top][i] = num\n            num += 1\n        top += 1\n        \n        # Fill right column\n        for i in range(top, bottom + 1):\n            matrix[i][right] = num\n            num += 1\n        right -= 1\n        \n        # Fill bottom row\n        for i in range(right, left - 1, -1):\n            matrix[bottom][i] = num\n            num += 1\n        bottom -= 1\n        \n        # Fill left column\n        for i in range(bottom, top - 1, -1):\n            matrix[i][left] = num\n            num += 1\n        left += 1\n    \n    return matrix\n", "test": "def check(candidate):\n    assert candidate(100) == [[1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99, 100], [396, 397, 398, 399, 400, 401, 402, 403, 404, 405, 406, 407, 408, 409, 410, 411, 412, 413, 414, 415, 416, 417, 418, 419, 420, 421, 422, 423, 424, 425, 426, 427, 428, 429, 430, 431, 432, 433, 434, 435, 436, 437, 438, 439, 440, 441, 442, 443, 444, 445, 446, 447, 448, 449, 450, 451, 452, 453, 454, 455, 456, 457, 458, 459, 460, 461, 462, 463, 464, 465, 466, 467, 468, 469, 470, 471, 472, 473, 474, 475, 476, 477, 478, 479, 480, 481, 482, 483, 484, 485, 486, 487, 488, 489, 490, 491, 492, 493, 494, 101], [395, 784, 785, 786, 787, 788, 789, 790, 791, 792, 793, 794, 795, 796, 797, 798, 799, 800, 801, 802, 803, 804, 805, 806, 807, 808, 809, 810, 811, 812, 813, 814, 815, 816, 817, 818, 819, 820, 821, 822, 823, 824, 825, 826, 827, 828, 829, 830, 831, 832, 833, 834, 835, 836, 837, 838, 839, 840, 841, 842, 843, 844, 845, 846, 847, 848, 849, 850, 851, 852, 853, 854, 855, 856, 857, 858, 859, 860, 861, 862, 863, 864, 865, 866, 867, 868, 869, 870, 871, 872, 873, 874, 875, 876, 877, 878, 879, 880, 495, 102], [394, 783, 1164, 1165, 1166, 1167, 1168, 1169, 1170, 1171, 1172, 1173, 1174, 1175, 1176, 1177, 1178, 1179, 1180, 1181, 1182, 1183, 1184, 1185, 1186, 1187, 1188, 1189, 1190, 1191, 1192, 1193, 1194, 1195, 1196, 1197, 1198, 1199, 1200, 1201, 1202, 1203, 1204, 1205, 1206, 1207, 1208, 1209, 1210, 1211, 1212, 1213, 1214, 1215, 1216, 1217, 1218, 1219, 1220, 1221, 1222, 1223, 1224, 1225, 1226, 1227, 1228, 1229, 1230, 1231, 1232, 1233, 1234, 1235, 1236, 1237, 1238, 1239, 1240, 1241, 1242, 1243, 1244, 1245, 1246, 1247, 1248, 1249, 1250, 1251, 1252, 1253, 1254, 1255, 1256, 1257, 1258, 881, 496, 103], [393, 782, 1163, 1536, 1537, 1538, 1539, 1540, 1541, 1542, 1543, 1544, 1545, 1546, 1547, 1548, 1549, 1550, 1551, 1552, 1553, 1554, 1555, 1556, 1557, 1558, 1559, 1560, 1561, 1562, 1563, 1564, 1565, 1566, 1567, 1568, 1569, 1570, 1571, 1572, 1573, 1574, 1575, 1576, 1577, 1578, 1579, 1580, 1581, 1582, 1583, 1584, 1585, 1586, 1587, 1588, 1589, 1590, 1591, 1592, 1593, 1594, 1595, 1596, 1597, 1598, 1599, 1600, 1601, 1602, 1603, 1604, 1605, 1606, 1607, 1608, 1609, 1610, 1611, 1612, 1613, 1614, 1615, 1616, 1617, 1618, 1619, 1620, 1621, 1622, 1623, 1624, 1625, 1626, 1627, 1628, 1259, 882, 497, 104], [392, 781, 1162, 1535, 1900, 1901, 1902, 1903, 1904, 1905, 1906, 1907, 1908, 1909, 1910, 1911, 1912, 1913, 1914, 1915, 1916, 1917, 1918, 1919, 1920, 1921, 1922, 1923, 1924, 1925, 1926, 1927, 1928, 1929, 1930, 1931, 1932, 1933, 1934, 1935, 1936, 1937, 1938, 1939, 1940, 1941, 1942, 1943, 1944, 1945, 1946, 1947, 1948, 1949, 1950, 1951, 1952, 1953, 1954, 1955, 1956, 1957, 1958, 1959, 1960, 1961, 1962, 1963, 1964, 1965, 1966, 1967, 1968, 1969, 1970, 1971, 1972, 1973, 1974, 1975, 1976, 1977, 1978, 1979, 1980, 1981, 1982, 1983, 1984, 1985, 1986, 1987, 1988, 1989, 1990, 1629, 1260, 883, 498, 105], [391, 780, 1161, 1534, 1899, 2256, 2257, 2258, 2259, 2260, 2261, 2262, 2263, 2264, 2265, 2266, 2267, 2268, 2269, 2270, 2271, 2272, 2273, 2274, 2275, 2276, 2277, 2278, 2279, 2280, 2281, 2282, 2283, 2284, 2285, 2286, 2287, 2288, 2289, 2290, 2291, 2292, 2293, 2294, 2295, 2296, 2297, 2298, 2299, 2300, 2301, 2302, 2303, 2304, 2305, 2306, 2307, 2308, 2309, 2310, 2311, 2312, 2313, 2314, 2315, 2316, 2317, 2318, 2319, 2320, 2321, 2322, 2323, 2324, 2325, 2326, 2327, 2328, 2329, 2330, 2331, 2332, 2333, 2334, 2335, 2336, 2337, 2338, 2339, 2340, 2341, 2342, 2343, 2344, 1991, 1630, 1261, 884, 499, 106], [390, 779, 1160, 1533, 1898, 2255, 2604, 2605, 2606, 2607, 2608, 2609, 2610, 2611, 2612, 2613, 2614, 2615, 2616, 2617, 2618, 2619, 2620, 2621, 2622, 2623, 2624, 2625, 2626, 2627, 2628, 2629, 2630, 2631, 2632, 2633, 2634, 2635, 2636, 2637, 2638, 2639, 2640, 2641, 2642, 2643, 2644, 2645, 2646, 2647, 2648, 2649, 2650, 2651, 2652, 2653, 2654, 2655, 2656, 2657, 2658, 2659, 2660, 2661, 2662, 2663, 2664, 2665, 2666, 2667, 2668, 2669, 2670, 2671, 2672, 2673, 2674, 2675, 2676, 2677, 2678, 2679, 2680, 2681, 2682, 2683, 2684, 2685, 2686, 2687, 2688, 2689, 2690, 2345, 1992, 1631, 1262, 885, 500, 107], [389, 778, 1159, 1532, 1897, 2254, 2603, 2944, 2945, 2946, 2947, 2948, 2949, 2950, 2951, 2952, 2953, 2954, 2955, 2956, 2957, 2958, 2959, 2960, 2961, 2962, 2963, 2964, 2965, 2966, 2967, 2968, 2969, 2970, 2971, 2972, 2973, 2974, 2975, 2976, 2977, 2978, 2979, 2980, 2981, 2982, 2983, 2984, 2985, 2986, 2987, 2988, 2989, 2990, 2991, 2992, 2993, 2994, 2995, 2996, 2997, 2998, 2999, 3000, 3001, 3002, 3003, 3004, 3005, 3006, 3007, 3008, 3009, 3010, 3011, 3012, 3013, 3014, 3015, 3016, 3017, 3018, 3019, 3020, 3021, 3022, 3023, 3024, 3025, 3026, 3027, 3028, 2691, 2346, 1993, 1632, 1263, 886, 501, 108], [388, 777, 1158, 1531, 1896, 2253, 2602, 2943, 3276, 3277, 3278, 3279, 3280, 3281, 3282, 3283, 3284, 3285, 3286, 3287, 3288, 3289, 3290, 3291, 3292, 3293, 3294, 3295, 3296, 3297, 3298, 3299, 3300, 3301, 3302, 3303, 3304, 3305, 3306, 3307, 3308, 3309, 3310, 3311, 3312, 3313, 3314, 3315, 3316, 3317, 3318, 3319, 3320, 3321, 3322, 3323, 3324, 3325, 3326, 3327, 3328, 3329, 3330, 3331, 3332, 3333, 3334, 3335, 3336, 3337, 3338, 3339, 3340, 3341, 3342, 3343, 3344, 3345, 3346, 3347, 3348, 3349, 3350, 3351, 3352, 3353, 3354, 3355, 3356, 3357, 3358, 3029, 2692, 2347, 1994, 1633, 1264, 887, 502, 109], [387, 776, 1157, 1530, 1895, 2252, 2601, 2942, 3275, 3600, 3601, 3602, 3603, 3604, 3605, 3606, 3607, 3608, 3609, 3610, 3611, 3612, 3613, 3614, 3615, 3616, 3617, 3618, 3619, 3620, 3621, 3622, 3623, 3624, 3625, 3626, 3627, 3628, 3629, 3630, 3631, 3632, 3633, 3634, 3635, 3636, 3637, 3638, 3639, 3640, 3641, 3642, 3643, 3644, 3645, 3646, 3647, 3648, 3649, 3650, 3651, 3652, 3653, 3654, 3655, 3656, 3657, 3658, 3659, 3660, 3661, 3662, 3663, 3664, 3665, 3666, 3667, 3668, 3669, 3670, 3671, 3672, 3673, 3674, 3675, 3676, 3677, 3678, 3679, 3680, 3359, 3030, 2693, 2348, 1995, 1634, 1265, 888, 503, 110], [386, 775, 1156, 1529, 1894, 2251, 2600, 2941, 3274, 3599, 3916, 3917, 3918, 3919, 3920, 3921, 3922, 3923, 3924, 3925, 3926, 3927, 3928, 3929, 3930, 3931, 3932, 3933, 3934, 3935, 3936, 3937, 3938, 3939, 3940, 3941, 3942, 3943, 3944, 3945, 3946, 3947, 3948, 3949, 3950, 3951, 3952, 3953, 3954, 3955, 3956, 3957, 3958, 3959, 3960, 3961, 3962, 3963, 3964, 3965, 3966, 3967, 3968, 3969, 3970, 3971, 3972, 3973, 3974, 3975, 3976, 3977, 3978, 3979, 3980, 3981, 3982, 3983, 3984, 3985, 3986, 3987, 3988, 3989, 3990, 3991, 3992, 3993, 3994, 3681, 3360, 3031, 2694, 2349, 1996, 1635, 1266, 889, 504, 111], [385, 774, 1155, 1528, 1893, 2250, 2599, 2940, 3273, 3598, 3915, 4224, 4225, 4226, 4227, 4228, 4229, 4230, 4231, 4232, 4233, 4234, 4235, 4236, 4237, 4238, 4239, 4240, 4241, 4242, 4243, 4244, 4245, 4246, 4247, 4248, 4249, 4250, 4251, 4252, 4253, 4254, 4255, 4256, 4257, 4258, 4259, 4260, 4261, 4262, 4263, 4264, 4265, 4266, 4267, 4268, 4269, 4270, 4271, 4272, 4273, 4274, 4275, 4276, 4277, 4278, 4279, 4280, 4281, 4282, 4283, 4284, 4285, 4286, 4287, 4288, 4289, 4290, 4291, 4292, 4293, 4294, 4295, 4296, 4297, 4298, 4299, 4300, 3995, 3682, 3361, 3032, 2695, 2350, 1997, 1636, 1267, 890, 505, 112], [384, 773, 1154, 1527, 1892, 2249, 2598, 2939, 3272, 3597, 3914, 4223, 4524, 4525, 4526, 4527, 4528, 4529, 4530, 4531, 4532, 4533, 4534, 4535, 4536, 4537, 4538, 4539, 4540, 4541, 4542, 4543, 4544, 4545, 4546, 4547, 4548, 4549, 4550, 4551, 4552, 4553, 4554, 4555, 4556, 4557, 4558, 4559, 4560, 4561, 4562, 4563, 4564, 4565, 4566, 4567, 4568, 4569, 4570, 4571, 4572, 4573, 4574, 4575, 4576, 4577, 4578, 4579, 4580, 4581, 4582, 4583, 4584, 4585, 4586, 4587, 4588, 4589, 4590, 4591, 4592, 4593, 4594, 4595, 4596, 4597, 4598, 4301, 3996, 3683, 3362, 3033, 2696, 2351, 1998, 1637, 1268, 891, 506, 113], [383, 772, 1153, 1526, 1891, 2248, 2597, 2938, 3271, 3596, 3913, 4222, 4523, 4816, 4817, 4818, 4819, 4820, 4821, 4822, 4823, 4824, 4825, 4826, 4827, 4828, 4829, 4830, 4831, 4832, 4833, 4834, 4835, 4836, 4837, 4838, 4839, 4840, 4841, 4842, 4843, 4844, 4845, 4846, 4847, 4848, 4849, 4850, 4851, 4852, 4853, 4854, 4855, 4856, 4857, 4858, 4859, 4860, 4861, 4862, 4863, 4864, 4865, 4866, 4867, 4868, 4869, 4870, 4871, 4872, 4873, 4874, 4875, 4876, 4877, 4878, 4879, 4880, 4881, 4882, 4883, 4884, 4885, 4886, 4887, 4888, 4599, 4302, 3997, 3684, 3363, 3034, 2697, 2352, 1999, 1638, 1269, 892, 507, 114], [382, 771, 1152, 1525, 1890, 2247, 2596, 2937, 3270, 3595, 3912, 4221, 4522, 4815, 5100, 5101, 5102, 5103, 5104, 5105, 5106, 5107, 5108, 5109, 5110, 5111, 5112, 5113, 5114, 5115, 5116, 5117, 5118, 5119, 5120, 5121, 5122, 5123, 5124, 5125, 5126, 5127, 5128, 5129, 5130, 5131, 5132, 5133, 5134, 5135, 5136, 5137, 5138, 5139, 5140, 5141, 5142, 5143, 5144, 5145, 5146, 5147, 5148, 5149, 5150, 5151, 5152, 5153, 5154, 5155, 5156, 5157, 5158, 5159, 5160, 5161, 5162, 5163, 5164, 5165, 5166, 5167, 5168, 5169, 5170, 4889, 4600, 4303, 3998, 3685, 3364, 3035, 2698, 2353, 2000, 1639, 1270, 893, 508, 115], [381, 770, 1151, 1524, 1889, 2246, 2595, 2936, 3269, 3594, 3911, 4220, 4521, 4814, 5099, 5376, 5377, 5378, 5379, 5380, 5381, 5382, 5383, 5384, 5385, 5386, 5387, 5388, 5389, 5390, 5391, 5392, 5393, 5394, 5395, 5396, 5397, 5398, 5399, 5400, 5401, 5402, 5403, 5404, 5405, 5406, 5407, 5408, 5409, 5410, 5411, 5412, 5413, 5414, 5415, 5416, 5417, 5418, 5419, 5420, 5421, 5422, 5423, 5424, 5425, 5426, 5427, 5428, 5429, 5430, 5431, 5432, 5433, 5434, 5435, 5436, 5437, 5438, 5439, 5440, 5441, 5442, 5443, 5444, 5171, 4890, 4601, 4304, 3999, 3686, 3365, 3036, 2699, 2354, 2001, 1640, 1271, 894, 509, 116], [380, 769, 1150, 1523, 1888, 2245, 2594, 2935, 3268, 3593, 3910, 4219, 4520, 4813, 5098, 5375, 5644, 5645, 5646, 5647, 5648, 5649, 5650, 5651, 5652, 5653, 5654, 5655, 5656, 5657, 5658, 5659, 5660, 5661, 5662, 5663, 5664, 5665, 5666, 5667, 5668, 5669, 5670, 5671, 5672, 5673, 5674, 5675, 5676, 5677, 5678, 5679, 5680, 5681, 5682, 5683, 5684, 5685, 5686, 5687, 5688, 5689, 5690, 5691, 5692, 5693, 5694, 5695, 5696, 5697, 5698, 5699, 5700, 5701, 5702, 5703, 5704, 5705, 5706, 5707, 5708, 5709, 5710, 5445, 5172, 4891, 4602, 4305, 4000, 3687, 3366, 3037, 2700, 2355, 2002, 1641, 1272, 895, 510, 117], [379, 768, 1149, 1522, 1887, 2244, 2593, 2934, 3267, 3592, 3909, 4218, 4519, 4812, 5097, 5374, 5643, 5904, 5905, 5906, 5907, 5908, 5909, 5910, 5911, 5912, 5913, 5914, 5915, 5916, 5917, 5918, 5919, 5920, 5921, 5922, 5923, 5924, 5925, 5926, 5927, 5928, 5929, 5930, 5931, 5932, 5933, 5934, 5935, 5936, 5937, 5938, 5939, 5940, 5941, 5942, 5943, 5944, 5945, 5946, 5947, 5948, 5949, 5950, 5951, 5952, 5953, 5954, 5955, 5956, 5957, 5958, 5959, 5960, 5961, 5962, 5963, 5964, 5965, 5966, 5967, 5968, 5711, 5446, 5173, 4892, 4603, 4306, 4001, 3688, 3367, 3038, 2701, 2356, 2003, 1642, 1273, 896, 511, 118], [378, 767, 1148, 1521, 1886, 2243, 2592, 2933, 3266, 3591, 3908, 4217, 4518, 4811, 5096, 5373, 5642, 5903, 6156, 6157, 6158, 6159, 6160, 6161, 6162, 6163, 6164, 6165, 6166, 6167, 6168, 6169, 6170, 6171, 6172, 6173, 6174, 6175, 6176, 6177, 6178, 6179, 6180, 6181, 6182, 6183, 6184, 6185, 6186, 6187, 6188, 6189, 6190, 6191, 6192, 6193, 6194, 6195, 6196, 6197, 6198, 6199, 6200, 6201, 6202, 6203, 6204, 6205, 6206, 6207, 6208, 6209, 6210, 6211, 6212, 6213, 6214, 6215, 6216, 6217, 6218, 5969, 5712, 5447, 5174, 4893, 4604, 4307, 4002, 3689, 3368, 3039, 2702, 2357, 2004, 1643, 1274, 897, 512, 119], [377, 766, 1147, 1520, 1885, 2242, 2591, 2932, 3265, 3590, 3907, 4216, 4517, 4810, 5095, 5372, 5641, 5902, 6155, 6400, 6401, 6402, 6403, 6404, 6405, 6406, 6407, 6408, 6409, 6410, 6411, 6412, 6413, 6414, 6415, 6416, 6417, 6418, 6419, 6420, 6421, 6422, 6423, 6424, 6425, 6426, 6427, 6428, 6429, 6430, 6431, 6432, 6433, 6434, 6435, 6436, 6437, 6438, 6439, 6440, 6441, 6442, 6443, 6444, 6445, 6446, 6447, 6448, 6449, 6450, 6451, 6452, 6453, 6454, 6455, 6456, 6457, 6458, 6459, 6460, 6219, 5970, 5713, 5448, 5175, 4894, 4605, 4308, 4003, 3690, 3369, 3040, 2703, 2358, 2005, 1644, 1275, 898, 513, 120], [376, 765, 1146, 1519, 1884, 2241, 2590, 2931, 3264, 3589, 3906, 4215, 4516, 4809, 5094, 5371, 5640, 5901, 6154, 6399, 6636, 6637, 6638, 6639, 6640, 6641, 6642, 6643, 6644, 6645, 6646, 6647, 6648, 6649, 6650, 6651, 6652, 6653, 6654, 6655, 6656, 6657, 6658, 6659, 6660, 6661, 6662, 6663, 6664, 6665, 6666, 6667, 6668, 6669, 6670, 6671, 6672, 6673, 6674, 6675, 6676, 6677, 6678, 6679, 6680, 6681, 6682, 6683, 6684, 6685, 6686, 6687, 6688, 6689, 6690, 6691, 6692, 6693, 6694, 6461, 6220, 5971, 5714, 5449, 5176, 4895, 4606, 4309, 4004, 3691, 3370, 3041, 2704, 2359, 2006, 1645, 1276, 899, 514, 121], [375, 764, 1145, 1518, 1883, 2240, 2589, 2930, 3263, 3588, 3905, 4214, 4515, 4808, 5093, 5370, 5639, 5900, 6153, 6398, 6635, 6864, 6865, 6866, 6867, 6868, 6869, 6870, 6871, 6872, 6873, 6874, 6875, 6876, 6877, 6878, 6879, 6880, 6881, 6882, 6883, 6884, 6885, 6886, 6887, 6888, 6889, 6890, 6891, 6892, 6893, 6894, 6895, 6896, 6897, 6898, 6899, 6900, 6901, 6902, 6903, 6904, 6905, 6906, 6907, 6908, 6909, 6910, 6911, 6912, 6913, 6914, 6915, 6916, 6917, 6918, 6919, 6920, 6695, 6462, 6221, 5972, 5715, 5450, 5177, 4896, 4607, 4310, 4005, 3692, 3371, 3042, 2705, 2360, 2007, 1646, 1277, 900, 515, 122], [374, 763, 1144, 1517, 1882, 2239, 2588, 2929, 3262, 3587, 3904, 4213, 4514, 4807, 5092, 5369, 5638, 5899, 6152, 6397, 6634, 6863, 7084, 7085, 7086, 7087, 7088, 7089, 7090, 7091, 7092, 7093, 7094, 7095, 7096, 7097, 7098, 7099, 7100, 7101, 7102, 7103, 7104, 7105, 7106, 7107, 7108, 7109, 7110, 7111, 7112, 7113, 7114, 7115, 7116, 7117, 7118, 7119, 7120, 7121, 7122, 7123, 7124, 7125, 7126, 7127, 7128, 7129, 7130, 7131, 7132, 7133, 7134, 7135, 7136, 7137, 7138, 6921, 6696, 6463, 6222, 5973, 5716, 5451, 5178, 4897, 4608, 4311, 4006, 3693, 3372, 3043, 2706, 2361, 2008, 1647, 1278, 901, 516, 123], [373, 762, 1143, 1516, 1881, 2238, 2587, 2928, 3261, 3586, 3903, 4212, 4513, 4806, 5091, 5368, 5637, 5898, 6151, 6396, 6633, 6862, 7083, 7296, 7297, 7298, 7299, 7300, 7301, 7302, 7303, 7304, 7305, 7306, 7307, 7308, 7309, 7310, 7311, 7312, 7313, 7314, 7315, 7316, 7317, 7318, 7319, 7320, 7321, 7322, 7323, 7324, 7325, 7326, 7327, 7328, 7329, 7330, 7331, 7332, 7333, 7334, 7335, 7336, 7337, 7338, 7339, 7340, 7341, 7342, 7343, 7344, 7345, 7346, 7347, 7348, 7139, 6922, 6697, 6464, 6223, 5974, 5717, 5452, 5179, 4898, 4609, 4312, 4007, 3694, 3373, 3044, 2707, 2362, 2009, 1648, 1279, 902, 517, 124], [372, 761, 1142, 1515, 1880, 2237, 2586, 2927, 3260, 3585, 3902, 4211, 4512, 4805, 5090, 5367, 5636, 5897, 6150, 6395, 6632, 6861, 7082, 7295, 7500, 7501, 7502, 7503, 7504, 7505, 7506, 7507, 7508, 7509, 7510, 7511, 7512, 7513, 7514, 7515, 7516, 7517, 7518, 7519, 7520, 7521, 7522, 7523, 7524, 7525, 7526, 7527, 7528, 7529, 7530, 7531, 7532, 7533, 7534, 7535, 7536, 7537, 7538, 7539, 7540, 7541, 7542, 7543, 7544, 7545, 7546, 7547, 7548, 7549, 7550, 7349, 7140, 6923, 6698, 6465, 6224, 5975, 5718, 5453, 5180, 4899, 4610, 4313, 4008, 3695, 3374, 3045, 2708, 2363, 2010, 1649, 1280, 903, 518, 125], [371, 760, 1141, 1514, 1879, 2236, 2585, 2926, 3259, 3584, 3901, 4210, 4511, 4804, 5089, 5366, 5635, 5896, 6149, 6394, 6631, 6860, 7081, 7294, 7499, 7696, 7697, 7698, 7699, 7700, 7701, 7702, 7703, 7704, 7705, 7706, 7707, 7708, 7709, 7710, 7711, 7712, 7713, 7714, 7715, 7716, 7717, 7718, 7719, 7720, 7721, 7722, 7723, 7724, 7725, 7726, 7727, 7728, 7729, 7730, 7731, 7732, 7733, 7734, 7735, 7736, 7737, 7738, 7739, 7740, 7741, 7742, 7743, 7744, 7551, 7350, 7141, 6924, 6699, 6466, 6225, 5976, 5719, 5454, 5181, 4900, 4611, 4314, 4009, 3696, 3375, 3046, 2709, 2364, 2011, 1650, 1281, 904, 519, 126], [370, 759, 1140, 1513, 1878, 2235, 2584, 2925, 3258, 3583, 3900, 4209, 4510, 4803, 5088, 5365, 5634, 5895, 6148, 6393, 6630, 6859, 7080, 7293, 7498, 7695, 7884, 7885, 7886, 7887, 7888, 7889, 7890, 7891, 7892, 7893, 7894, 7895, 7896, 7897, 7898, 7899, 7900, 7901, 7902, 7903, 7904, 7905, 7906, 7907, 7908, 7909, 7910, 7911, 7912, 7913, 7914, 7915, 7916, 7917, 7918, 7919, 7920, 7921, 7922, 7923, 7924, 7925, 7926, 7927, 7928, 7929, 7930, 7745, 7552, 7351, 7142, 6925, 6700, 6467, 6226, 5977, 5720, 5455, 5182, 4901, 4612, 4315, 4010, 3697, 3376, 3047, 2710, 2365, 2012, 1651, 1282, 905, 520, 127], [369, 758, 1139, 1512, 1877, 2234, 2583, 2924, 3257, 3582, 3899, 4208, 4509, 4802, 5087, 5364, 5633, 5894, 6147, 6392, 6629, 6858, 7079, 7292, 7497, 7694, 7883, 8064, 8065, 8066, 8067, 8068, 8069, 8070, 8071, 8072, 8073, 8074, 8075, 8076, 8077, 8078, 8079, 8080, 8081, 8082, 8083, 8084, 8085, 8086, 8087, 8088, 8089, 8090, 8091, 8092, 8093, 8094, 8095, 8096, 8097, 8098, 8099, 8100, 8101, 8102, 8103, 8104, 8105, 8106, 8107, 8108, 7931, 7746, 7553, 7352, 7143, 6926, 6701, 6468, 6227, 5978, 5721, 5456, 5183, 4902, 4613, 4316, 4011, 3698, 3377, 3048, 2711, 2366, 2013, 1652, 1283, 906, 521, 128], [368, 757, 1138, 1511, 1876, 2233, 2582, 2923, 3256, 3581, 3898, 4207, 4508, 4801, 5086, 5363, 5632, 5893, 6146, 6391, 6628, 6857, 7078, 7291, 7496, 7693, 7882, 8063, 8236, 8237, 8238, 8239, 8240, 8241, 8242, 8243, 8244, 8245, 8246, 8247, 8248, 8249, 8250, 8251, 8252, 8253, 8254, 8255, 8256, 8257, 8258, 8259, 8260, 8261, 8262, 8263, 8264, 8265, 8266, 8267, 8268, 8269, 8270, 8271, 8272, 8273, 8274, 8275, 8276, 8277, 8278, 8109, 7932, 7747, 7554, 7353, 7144, 6927, 6702, 6469, 6228, 5979, 5722, 5457, 5184, 4903, 4614, 4317, 4012, 3699, 3378, 3049, 2712, 2367, 2014, 1653, 1284, 907, 522, 129], [367, 756, 1137, 1510, 1875, 2232, 2581, 2922, 3255, 3580, 3897, 4206, 4507, 4800, 5085, 5362, 5631, 5892, 6145, 6390, 6627, 6856, 7077, 7290, 7495, 7692, 7881, 8062, 8235, 8400, 8401, 8402, 8403, 8404, 8405, 8406, 8407, 8408, 8409, 8410, 8411, 8412, 8413, 8414, 8415, 8416, 8417, 8418, 8419, 8420, 8421, 8422, 8423, 8424, 8425, 8426, 8427, 8428, 8429, 8430, 8431, 8432, 8433, 8434, 8435, 8436, 8437, 8438, 8439, 8440, 8279, 8110, 7933, 7748, 7555, 7354, 7145, 6928, 6703, 6470, 6229, 5980, 5723, 5458, 5185, 4904, 4615, 4318, 4013, 3700, 3379, 3050, 2713, 2368, 2015, 1654, 1285, 908, 523, 130], [366, 755, 1136, 1509, 1874, 2231, 2580, 2921, 3254, 3579, 3896, 4205, 4506, 4799, 5084, 5361, 5630, 5891, 6144, 6389, 6626, 6855, 7076, 7289, 7494, 7691, 7880, 8061, 8234, 8399, 8556, 8557, 8558, 8559, 8560, 8561, 8562, 8563, 8564, 8565, 8566, 8567, 8568, 8569, 8570, 8571, 8572, 8573, 8574, 8575, 8576, 8577, 8578, 8579, 8580, 8581, 8582, 8583, 8584, 8585, 8586, 8587, 8588, 8589, 8590, 8591, 8592, 8593, 8594, 8441, 8280, 8111, 7934, 7749, 7556, 7355, 7146, 6929, 6704, 6471, 6230, 5981, 5724, 5459, 5186, 4905, 4616, 4319, 4014, 3701, 3380, 3051, 2714, 2369, 2016, 1655, 1286, 909, 524, 131], [365, 754, 1135, 1508, 1873, 2230, 2579, 2920, 3253, 3578, 3895, 4204, 4505, 4798, 5083, 5360, 5629, 5890, 6143, 6388, 6625, 6854, 7075, 7288, 7493, 7690, 7879, 8060, 8233, 8398, 8555, 8704, 8705, 8706, 8707, 8708, 8709, 8710, 8711, 8712, 8713, 8714, 8715, 8716, 8717, 8718, 8719, 8720, 8721, 8722, 8723, 8724, 8725, 8726, 8727, 8728, 8729, 8730, 8731, 8732, 8733, 8734, 8735, 8736, 8737, 8738, 8739, 8740, 8595, 8442, 8281, 8112, 7935, 7750, 7557, 7356, 7147, 6930, 6705, 6472, 6231, 5982, 5725, 5460, 5187, 4906, 4617, 4320, 4015, 3702, 3381, 3052, 2715, 2370, 2017, 1656, 1287, 910, 525, 132], [364, 753, 1134, 1507, 1872, 2229, 2578, 2919, 3252, 3577, 3894, 4203, 4504, 4797, 5082, 5359, 5628, 5889, 6142, 6387, 6624, 6853, 7074, 7287, 7492, 7689, 7878, 8059, 8232, 8397, 8554, 8703, 8844, 8845, 8846, 8847, 8848, 8849, 8850, 8851, 8852, 8853, 8854, 8855, 8856, 8857, 8858, 8859, 8860, 8861, 8862, 8863, 8864, 8865, 8866, 8867, 8868, 8869, 8870, 8871, 8872, 8873, 8874, 8875, 8876, 8877, 8878, 8741, 8596, 8443, 8282, 8113, 7936, 7751, 7558, 7357, 7148, 6931, 6706, 6473, 6232, 5983, 5726, 5461, 5188, 4907, 4618, 4321, 4016, 3703, 3382, 3053, 2716, 2371, 2018, 1657, 1288, 911, 526, 133], [363, 752, 1133, 1506, 1871, 2228, 2577, 2918, 3251, 3576, 3893, 4202, 4503, 4796, 5081, 5358, 5627, 5888, 6141, 6386, 6623, 6852, 7073, 7286, 7491, 7688, 7877, 8058, 8231, 8396, 8553, 8702, 8843, 8976, 8977, 8978, 8979, 8980, 8981, 8982, 8983, 8984, 8985, 8986, 8987, 8988, 8989, 8990, 8991, 8992, 8993, 8994, 8995, 8996, 8997, 8998, 8999, 9000, 9001, 9002, 9003, 9004, 9005, 9006, 9007, 9008, 8879, 8742, 8597, 8444, 8283, 8114, 7937, 7752, 7559, 7358, 7149, 6932, 6707, 6474, 6233, 5984, 5727, 5462, 5189, 4908, 4619, 4322, 4017, 3704, 3383, 3054, 2717, 2372, 2019, 1658, 1289, 912, 527, 134], [362, 751, 1132, 1505, 1870, 2227, 2576, 2917, 3250, 3575, 3892, 4201, 4502, 4795, 5080, 5357, 5626, 5887, 6140, 6385, 6622, 6851, 7072, 7285, 7490, 7687, 7876, 8057, 8230, 8395, 8552, 8701, 8842, 8975, 9100, 9101, 9102, 9103, 9104, 9105, 9106, 9107, 9108, 9109, 9110, 9111, 9112, 9113, 9114, 9115, 9116, 9117, 9118, 9119, 9120, 9121, 9122, 9123, 9124, 9125, 9126, 9127, 9128, 9129, 9130, 9009, 8880, 8743, 8598, 8445, 8284, 8115, 7938, 7753, 7560, 7359, 7150, 6933, 6708, 6475, 6234, 5985, 5728, 5463, 5190, 4909, 4620, 4323, 4018, 3705, 3384, 3055, 2718, 2373, 2020, 1659, 1290, 913, 528, 135], [361, 750, 1131, 1504, 1869, 2226, 2575, 2916, 3249, 3574, 3891, 4200, 4501, 4794, 5079, 5356, 5625, 5886, 6139, 6384, 6621, 6850, 7071, 7284, 7489, 7686, 7875, 8056, 8229, 8394, 8551, 8700, 8841, 8974, 9099, 9216, 9217, 9218, 9219, 9220, 9221, 9222, 9223, 9224, 9225, 9226, 9227, 9228, 9229, 9230, 9231, 9232, 9233, 9234, 9235, 9236, 9237, 9238, 9239, 9240, 9241, 9242, 9243, 9244, 9131, 9010, 8881, 8744, 8599, 8446, 8285, 8116, 7939, 7754, 7561, 7360, 7151, 6934, 6709, 6476, 6235, 5986, 5729, 5464, 5191, 4910, 4621, 4324, 4019, 3706, 3385, 3056, 2719, 2374, 2021, 1660, 1291, 914, 529, 136], [360, 749, 1130, 1503, 1868, 2225, 2574, 2915, 3248, 3573, 3890, 4199, 4500, 4793, 5078, 5355, 5624, 5885, 6138, 6383, 6620, 6849, 7070, 7283, 7488, 7685, 7874, 8055, 8228, 8393, 8550, 8699, 8840, 8973, 9098, 9215, 9324, 9325, 9326, 9327, 9328, 9329, 9330, 9331, 9332, 9333, 9334, 9335, 9336, 9337, 9338, 9339, 9340, 9341, 9342, 9343, 9344, 9345, 9346, 9347, 9348, 9349, 9350, 9245, 9132, 9011, 8882, 8745, 8600, 8447, 8286, 8117, 7940, 7755, 7562, 7361, 7152, 6935, 6710, 6477, 6236, 5987, 5730, 5465, 5192, 4911, 4622, 4325, 4020, 3707, 3386, 3057, 2720, 2375, 2022, 1661, 1292, 915, 530, 137], [359, 748, 1129, 1502, 1867, 2224, 2573, 2914, 3247, 3572, 3889, 4198, 4499, 4792, 5077, 5354, 5623, 5884, 6137, 6382, 6619, 6848, 7069, 7282, 7487, 7684, 7873, 8054, 8227, 8392, 8549, 8698, 8839, 8972, 9097, 9214, 9323, 9424, 9425, 9426, 9427, 9428, 9429, 9430, 9431, 9432, 9433, 9434, 9435, 9436, 9437, 9438, 9439, 9440, 9441, 9442, 9443, 9444, 9445, 9446, 9447, 9448, 9351, 9246, 9133, 9012, 8883, 8746, 8601, 8448, 8287, 8118, 7941, 7756, 7563, 7362, 7153, 6936, 6711, 6478, 6237, 5988, 5731, 5466, 5193, 4912, 4623, 4326, 4021, 3708, 3387, 3058, 2721, 2376, 2023, 1662, 1293, 916, 531, 138], [358, 747, 1128, 1501, 1866, 2223, 2572, 2913, 3246, 3571, 3888, 4197, 4498, 4791, 5076, 5353, 5622, 5883, 6136, 6381, 6618, 6847, 7068, 7281, 7486, 7683, 7872, 8053, 8226, 8391, 8548, 8697, 8838, 8971, 9096, 9213, 9322, 9423, 9516, 9517, 9518, 9519, 9520, 9521, 9522, 9523, 9524, 9525, 9526, 9527, 9528, 9529, 9530, 9531, 9532, 9533, 9534, 9535, 9536, 9537, 9538, 9449, 9352, 9247, 9134, 9013, 8884, 8747, 8602, 8449, 8288, 8119, 7942, 7757, 7564, 7363, 7154, 6937, 6712, 6479, 6238, 5989, 5732, 5467, 5194, 4913, 4624, 4327, 4022, 3709, 3388, 3059, 2722, 2377, 2024, 1663, 1294, 917, 532, 139], [357, 746, 1127, 1500, 1865, 2222, 2571, 2912, 3245, 3570, 3887, 4196, 4497, 4790, 5075, 5352, 5621, 5882, 6135, 6380, 6617, 6846, 7067, 7280, 7485, 7682, 7871, 8052, 8225, 8390, 8547, 8696, 8837, 8970, 9095, 9212, 9321, 9422, 9515, 9600, 9601, 9602, 9603, 9604, 9605, 9606, 9607, 9608, 9609, 9610, 9611, 9612, 9613, 9614, 9615, 9616, 9617, 9618, 9619, 9620, 9539, 9450, 9353, 9248, 9135, 9014, 8885, 8748, 8603, 8450, 8289, 8120, 7943, 7758, 7565, 7364, 7155, 6938, 6713, 6480, 6239, 5990, 5733, 5468, 5195, 4914, 4625, 4328, 4023, 3710, 3389, 3060, 2723, 2378, 2025, 1664, 1295, 918, 533, 140], [356, 745, 1126, 1499, 1864, 2221, 2570, 2911, 3244, 3569, 3886, 4195, 4496, 4789, 5074, 5351, 5620, 5881, 6134, 6379, 6616, 6845, 7066, 7279, 7484, 7681, 7870, 8051, 8224, 8389, 8546, 8695, 8836, 8969, 9094, 9211, 9320, 9421, 9514, 9599, 9676, 9677, 9678, 9679, 9680, 9681, 9682, 9683, 9684, 9685, 9686, 9687, 9688, 9689, 9690, 9691, 9692, 9693, 9694, 9621, 9540, 9451, 9354, 9249, 9136, 9015, 8886, 8749, 8604, 8451, 8290, 8121, 7944, 7759, 7566, 7365, 7156, 6939, 6714, 6481, 6240, 5991, 5734, 5469, 5196, 4915, 4626, 4329, 4024, 3711, 3390, 3061, 2724, 2379, 2026, 1665, 1296, 919, 534, 141], [355, 744, 1125, 1498, 1863, 2220, 2569, 2910, 3243, 3568, 3885, 4194, 4495, 4788, 5073, 5350, 5619, 5880, 6133, 6378, 6615, 6844, 7065, 7278, 7483, 7680, 7869, 8050, 8223, 8388, 8545, 8694, 8835, 8968, 9093, 9210, 9319, 9420, 9513, 9598, 9675, 9744, 9745, 9746, 9747, 9748, 9749, 9750, 9751, 9752, 9753, 9754, 9755, 9756, 9757, 9758, 9759, 9760, 9695, 9622, 9541, 9452, 9355, 9250, 9137, 9016, 8887, 8750, 8605, 8452, 8291, 8122, 7945, 7760, 7567, 7366, 7157, 6940, 6715, 6482, 6241, 5992, 5735, 5470, 5197, 4916, 4627, 4330, 4025, 3712, 3391, 3062, 2725, 2380, 2027, 1666, 1297, 920, 535, 142], [354, 743, 1124, 1497, 1862, 2219, 2568, 2909, 3242, 3567, 3884, 4193, 4494, 4787, 5072, 5349, 5618, 5879, 6132, 6377, 6614, 6843, 7064, 7277, 7482, 7679, 7868, 8049, 8222, 8387, 8544, 8693, 8834, 8967, 9092, 9209, 9318, 9419, 9512, 9597, 9674, 9743, 9804, 9805, 9806, 9807, 9808, 9809, 9810, 9811, 9812, 9813, 9814, 9815, 9816, 9817, 9818, 9761, 9696, 9623, 9542, 9453, 9356, 9251, 9138, 9017, 8888, 8751, 8606, 8453, 8292, 8123, 7946, 7761, 7568, 7367, 7158, 6941, 6716, 6483, 6242, 5993, 5736, 5471, 5198, 4917, 4628, 4331, 4026, 3713, 3392, 3063, 2726, 2381, 2028, 1667, 1298, 921, 536, 143], [353, 742, 1123, 1496, 1861, 2218, 2567, 2908, 3241, 3566, 3883, 4192, 4493, 4786, 5071, 5348, 5617, 5878, 6131, 6376, 6613, 6842, 7063, 7276, 7481, 7678, 7867, 8048, 8221, 8386, 8543, 8692, 8833, 8966, 9091, 9208, 9317, 9418, 9511, 9596, 9673, 9742, 9803, 9856, 9857, 9858, 9859, 9860, 9861, 9862, 9863, 9864, 9865, 9866, 9867, 9868, 9819, 9762, 9697, 9624, 9543, 9454, 9357, 9252, 9139, 9018, 8889, 8752, 8607, 8454, 8293, 8124, 7947, 7762, 7569, 7368, 7159, 6942, 6717, 6484, 6243, 5994, 5737, 5472, 5199, 4918, 4629, 4332, 4027, 3714, 3393, 3064, 2727, 2382, 2029, 1668, 1299, 922, 537, 144], [352, 741, 1122, 1495, 1860, 2217, 2566, 2907, 3240, 3565, 3882, 4191, 4492, 4785, 5070, 5347, 5616, 5877, 6130, 6375, 6612, 6841, 7062, 7275, 7480, 7677, 7866, 8047, 8220, 8385, 8542, 8691, 8832, 8965, 9090, 9207, 9316, 9417, 9510, 9595, 9672, 9741, 9802, 9855, 9900, 9901, 9902, 9903, 9904, 9905, 9906, 9907, 9908, 9909, 9910, 9869, 9820, 9763, 9698, 9625, 9544, 9455, 9358, 9253, 9140, 9019, 8890, 8753, 8608, 8455, 8294, 8125, 7948, 7763, 7570, 7369, 7160, 6943, 6718, 6485, 6244, 5995, 5738, 5473, 5200, 4919, 4630, 4333, 4028, 3715, 3394, 3065, 2728, 2383, 2030, 1669, 1300, 923, 538, 145], [351, 740, 1121, 1494, 1859, 2216, 2565, 2906, 3239, 3564, 3881, 4190, 4491, 4784, 5069, 5346, 5615, 5876, 6129, 6374, 6611, 6840, 7061, 7274, 7479, 7676, 7865, 8046, 8219, 8384, 8541, 8690, 8831, 8964, 9089, 9206, 9315, 9416, 9509, 9594, 9671, 9740, 9801, 9854, 9899, 9936, 9937, 9938, 9939, 9940, 9941, 9942, 9943, 9944, 9911, 9870, 9821, 9764, 9699, 9626, 9545, 9456, 9359, 9254, 9141, 9020, 8891, 8754, 8609, 8456, 8295, 8126, 7949, 7764, 7571, 7370, 7161, 6944, 6719, 6486, 6245, 5996, 5739, 5474, 5201, 4920, 4631, 4334, 4029, 3716, 3395, 3066, 2729, 2384, 2031, 1670, 1301, 924, 539, 146], [350, 739, 1120, 1493, 1858, 2215, 2564, 2905, 3238, 3563, 3880, 4189, 4490, 4783, 5068, 5345, 5614, 5875, 6128, 6373, 6610, 6839, 7060, 7273, 7478, 7675, 7864, 8045, 8218, 8383, 8540, 8689, 8830, 8963, 9088, 9205, 9314, 9415, 9508, 9593, 9670, 9739, 9800, 9853, 9898, 9935, 9964, 9965, 9966, 9967, 9968, 9969, 9970, 9945, 9912, 9871, 9822, 9765, 9700, 9627, 9546, 9457, 9360, 9255, 9142, 9021, 8892, 8755, 8610, 8457, 8296, 8127, 7950, 7765, 7572, 7371, 7162, 6945, 6720, 6487, 6246, 5997, 5740, 5475, 5202, 4921, 4632, 4335, 4030, 3717, 3396, 3067, 2730, 2385, 2032, 1671, 1302, 925, 540, 147], [349, 738, 1119, 1492, 1857, 2214, 2563, 2904, 3237, 3562, 3879, 4188, 4489, 4782, 5067, 5344, 5613, 5874, 6127, 6372, 6609, 6838, 7059, 7272, 7477, 7674, 7863, 8044, 8217, 8382, 8539, 8688, 8829, 8962, 9087, 9204, 9313, 9414, 9507, 9592, 9669, 9738, 9799, 9852, 9897, 9934, 9963, 9984, 9985, 9986, 9987, 9988, 9971, 9946, 9913, 9872, 9823, 9766, 9701, 9628, 9547, 9458, 9361, 9256, 9143, 9022, 8893, 8756, 8611, 8458, 8297, 8128, 7951, 7766, 7573, 7372, 7163, 6946, 6721, 6488, 6247, 5998, 5741, 5476, 5203, 4922, 4633, 4336, 4031, 3718, 3397, 3068, 2731, 2386, 2033, 1672, 1303, 926, 541, 148], [348, 737, 1118, 1491, 1856, 2213, 2562, 2903, 3236, 3561, 3878, 4187, 4488, 4781, 5066, 5343, 5612, 5873, 6126, 6371, 6608, 6837, 7058, 7271, 7476, 7673, 7862, 8043, 8216, 8381, 8538, 8687, 8828, 8961, 9086, 9203, 9312, 9413, 9506, 9591, 9668, 9737, 9798, 9851, 9896, 9933, 9962, 9983, 9996, 9997, 9998, 9989, 9972, 9947, 9914, 9873, 9824, 9767, 9702, 9629, 9548, 9459, 9362, 9257, 9144, 9023, 8894, 8757, 8612, 8459, 8298, 8129, 7952, 7767, 7574, 7373, 7164, 6947, 6722, 6489, 6248, 5999, 5742, 5477, 5204, 4923, 4634, 4337, 4032, 3719, 3398, 3069, 2732, 2387, 2034, 1673, 1304, 927, 542, 149], [347, 736, 1117, 1490, 1855, 2212, 2561, 2902, 3235, 3560, 3877, 4186, 4487, 4780, 5065, 5342, 5611, 5872, 6125, 6370, 6607, 6836, 7057, 7270, 7475, 7672, 7861, 8042, 8215, 8380, 8537, 8686, 8827, 8960, 9085, 9202, 9311, 9412, 9505, 9590, 9667, 9736, 9797, 9850, 9895, 9932, 9961, 9982, 9995, 10000, 9999, 9990, 9973, 9948, 9915, 9874, 9825, 9768, 9703, 9630, 9549, 9460, 9363, 9258, 9145, 9024, 8895, 8758, 8613, 8460, 8299, 8130, 7953, 7768, 7575, 7374, 7165, 6948, 6723, 6490, 6249, 6000, 5743, 5478, 5205, 4924, 4635, 4338, 4033, 3720, 3399, 3070, 2733, 2388, 2035, 1674, 1305, 928, 543, 150], [346, 735, 1116, 1489, 1854, 2211, 2560, 2901, 3234, 3559, 3876, 4185, 4486, 4779, 5064, 5341, 5610, 5871, 6124, 6369, 6606, 6835, 7056, 7269, 7474, 7671, 7860, 8041, 8214, 8379, 8536, 8685, 8826, 8959, 9084, 9201, 9310, 9411, 9504, 9589, 9666, 9735, 9796, 9849, 9894, 9931, 9960, 9981, 9994, 9993, 9992, 9991, 9974, 9949, 9916, 9875, 9826, 9769, 9704, 9631, 9550, 9461, 9364, 9259, 9146, 9025, 8896, 8759, 8614, 8461, 8300, 8131, 7954, 7769, 7576, 7375, 7166, 6949, 6724, 6491, 6250, 6001, 5744, 5479, 5206, 4925, 4636, 4339, 4034, 3721, 3400, 3071, 2734, 2389, 2036, 1675, 1306, 929, 544, 151], [345, 734, 1115, 1488, 1853, 2210, 2559, 2900, 3233, 3558, 3875, 4184, 4485, 4778, 5063, 5340, 5609, 5870, 6123, 6368, 6605, 6834, 7055, 7268, 7473, 7670, 7859, 8040, 8213, 8378, 8535, 8684, 8825, 8958, 9083, 9200, 9309, 9410, 9503, 9588, 9665, 9734, 9795, 9848, 9893, 9930, 9959, 9980, 9979, 9978, 9977, 9976, 9975, 9950, 9917, 9876, 9827, 9770, 9705, 9632, 9551, 9462, 9365, 9260, 9147, 9026, 8897, 8760, 8615, 8462, 8301, 8132, 7955, 7770, 7577, 7376, 7167, 6950, 6725, 6492, 6251, 6002, 5745, 5480, 5207, 4926, 4637, 4340, 4035, 3722, 3401, 3072, 2735, 2390, 2037, 1676, 1307, 930, 545, 152], [344, 733, 1114, 1487, 1852, 2209, 2558, 2899, 3232, 3557, 3874, 4183, 4484, 4777, 5062, 5339, 5608, 5869, 6122, 6367, 6604, 6833, 7054, 7267, 7472, 7669, 7858, 8039, 8212, 8377, 8534, 8683, 8824, 8957, 9082, 9199, 9308, 9409, 9502, 9587, 9664, 9733, 9794, 9847, 9892, 9929, 9958, 9957, 9956, 9955, 9954, 9953, 9952, 9951, 9918, 9877, 9828, 9771, 9706, 9633, 9552, 9463, 9366, 9261, 9148, 9027, 8898, 8761, 8616, 8463, 8302, 8133, 7956, 7771, 7578, 7377, 7168, 6951, 6726, 6493, 6252, 6003, 5746, 5481, 5208, 4927, 4638, 4341, 4036, 3723, 3402, 3073, 2736, 2391, 2038, 1677, 1308, 931, 546, 153], [343, 732, 1113, 1486, 1851, 2208, 2557, 2898, 3231, 3556, 3873, 4182, 4483, 4776, 5061, 5338, 5607, 5868, 6121, 6366, 6603, 6832, 7053, 7266, 7471, 7668, 7857, 8038, 8211, 8376, 8533, 8682, 8823, 8956, 9081, 9198, 9307, 9408, 9501, 9586, 9663, 9732, 9793, 9846, 9891, 9928, 9927, 9926, 9925, 9924, 9923, 9922, 9921, 9920, 9919, 9878, 9829, 9772, 9707, 9634, 9553, 9464, 9367, 9262, 9149, 9028, 8899, 8762, 8617, 8464, 8303, 8134, 7957, 7772, 7579, 7378, 7169, 6952, 6727, 6494, 6253, 6004, 5747, 5482, 5209, 4928, 4639, 4342, 4037, 3724, 3403, 3074, 2737, 2392, 2039, 1678, 1309, 932, 547, 154], [342, 731, 1112, 1485, 1850, 2207, 2556, 2897, 3230, 3555, 3872, 4181, 4482, 4775, 5060, 5337, 5606, 5867, 6120, 6365, 6602, 6831, 7052, 7265, 7470, 7667, 7856, 8037, 8210, 8375, 8532, 8681, 8822, 8955, 9080, 9197, 9306, 9407, 9500, 9585, 9662, 9731, 9792, 9845, 9890, 9889, 9888, 9887, 9886, 9885, 9884, 9883, 9882, 9881, 9880, 9879, 9830, 9773, 9708, 9635, 9554, 9465, 9368, 9263, 9150, 9029, 8900, 8763, 8618, 8465, 8304, 8135, 7958, 7773, 7580, 7379, 7170, 6953, 6728, 6495, 6254, 6005, 5748, 5483, 5210, 4929, 4640, 4343, 4038, 3725, 3404, 3075, 2738, 2393, 2040, 1679, 1310, 933, 548, 155], [341, 730, 1111, 1484, 1849, 2206, 2555, 2896, 3229, 3554, 3871, 4180, 4481, 4774, 5059, 5336, 5605, 5866, 6119, 6364, 6601, 6830, 7051, 7264, 7469, 7666, 7855, 8036, 8209, 8374, 8531, 8680, 8821, 8954, 9079, 9196, 9305, 9406, 9499, 9584, 9661, 9730, 9791, 9844, 9843, 9842, 9841, 9840, 9839, 9838, 9837, 9836, 9835, 9834, 9833, 9832, 9831, 9774, 9709, 9636, 9555, 9466, 9369, 9264, 9151, 9030, 8901, 8764, 8619, 8466, 8305, 8136, 7959, 7774, 7581, 7380, 7171, 6954, 6729, 6496, 6255, 6006, 5749, 5484, 5211, 4930, 4641, 4344, 4039, 3726, 3405, 3076, 2739, 2394, 2041, 1680, 1311, 934, 549, 156], [340, 729, 1110, 1483, 1848, 2205, 2554, 2895, 3228, 3553, 3870, 4179, 4480, 4773, 5058, 5335, 5604, 5865, 6118, 6363, 6600, 6829, 7050, 7263, 7468, 7665, 7854, 8035, 8208, 8373, 8530, 8679, 8820, 8953, 9078, 9195, 9304, 9405, 9498, 9583, 9660, 9729, 9790, 9789, 9788, 9787, 9786, 9785, 9784, 9783, 9782, 9781, 9780, 9779, 9778, 9777, 9776, 9775, 9710, 9637, 9556, 9467, 9370, 9265, 9152, 9031, 8902, 8765, 8620, 8467, 8306, 8137, 7960, 7775, 7582, 7381, 7172, 6955, 6730, 6497, 6256, 6007, 5750, 5485, 5212, 4931, 4642, 4345, 4040, 3727, 3406, 3077, 2740, 2395, 2042, 1681, 1312, 935, 550, 157], [339, 728, 1109, 1482, 1847, 2204, 2553, 2894, 3227, 3552, 3869, 4178, 4479, 4772, 5057, 5334, 5603, 5864, 6117, 6362, 6599, 6828, 7049, 7262, 7467, 7664, 7853, 8034, 8207, 8372, 8529, 8678, 8819, 8952, 9077, 9194, 9303, 9404, 9497, 9582, 9659, 9728, 9727, 9726, 9725, 9724, 9723, 9722, 9721, 9720, 9719, 9718, 9717, 9716, 9715, 9714, 9713, 9712, 9711, 9638, 9557, 9468, 9371, 9266, 9153, 9032, 8903, 8766, 8621, 8468, 8307, 8138, 7961, 7776, 7583, 7382, 7173, 6956, 6731, 6498, 6257, 6008, 5751, 5486, 5213, 4932, 4643, 4346, 4041, 3728, 3407, 3078, 2741, 2396, 2043, 1682, 1313, 936, 551, 158], [338, 727, 1108, 1481, 1846, 2203, 2552, 2893, 3226, 3551, 3868, 4177, 4478, 4771, 5056, 5333, 5602, 5863, 6116, 6361, 6598, 6827, 7048, 7261, 7466, 7663, 7852, 8033, 8206, 8371, 8528, 8677, 8818, 8951, 9076, 9193, 9302, 9403, 9496, 9581, 9658, 9657, 9656, 9655, 9654, 9653, 9652, 9651, 9650, 9649, 9648, 9647, 9646, 9645, 9644, 9643, 9642, 9641, 9640, 9639, 9558, 9469, 9372, 9267, 9154, 9033, 8904, 8767, 8622, 8469, 8308, 8139, 7962, 7777, 7584, 7383, 7174, 6957, 6732, 6499, 6258, 6009, 5752, 5487, 5214, 4933, 4644, 4347, 4042, 3729, 3408, 3079, 2742, 2397, 2044, 1683, 1314, 937, 552, 159], [337, 726, 1107, 1480, 1845, 2202, 2551, 2892, 3225, 3550, 3867, 4176, 4477, 4770, 5055, 5332, 5601, 5862, 6115, 6360, 6597, 6826, 7047, 7260, 7465, 7662, 7851, 8032, 8205, 8370, 8527, 8676, 8817, 8950, 9075, 9192, 9301, 9402, 9495, 9580, 9579, 9578, 9577, 9576, 9575, 9574, 9573, 9572, 9571, 9570, 9569, 9568, 9567, 9566, 9565, 9564, 9563, 9562, 9561, 9560, 9559, 9470, 9373, 9268, 9155, 9034, 8905, 8768, 8623, 8470, 8309, 8140, 7963, 7778, 7585, 7384, 7175, 6958, 6733, 6500, 6259, 6010, 5753, 5488, 5215, 4934, 4645, 4348, 4043, 3730, 3409, 3080, 2743, 2398, 2045, 1684, 1315, 938, 553, 160], [336, 725, 1106, 1479, 1844, 2201, 2550, 2891, 3224, 3549, 3866, 4175, 4476, 4769, 5054, 5331, 5600, 5861, 6114, 6359, 6596, 6825, 7046, 7259, 7464, 7661, 7850, 8031, 8204, 8369, 8526, 8675, 8816, 8949, 9074, 9191, 9300, 9401, 9494, 9493, 9492, 9491, 9490, 9489, 9488, 9487, 9486, 9485, 9484, 9483, 9482, 9481, 9480, 9479, 9478, 9477, 9476, 9475, 9474, 9473, 9472, 9471, 9374, 9269, 9156, 9035, 8906, 8769, 8624, 8471, 8310, 8141, 7964, 7779, 7586, 7385, 7176, 6959, 6734, 6501, 6260, 6011, 5754, 5489, 5216, 4935, 4646, 4349, 4044, 3731, 3410, 3081, 2744, 2399, 2046, 1685, 1316, 939, 554, 161], [335, 724, 1105, 1478, 1843, 2200, 2549, 2890, 3223, 3548, 3865, 4174, 4475, 4768, 5053, 5330, 5599, 5860, 6113, 6358, 6595, 6824, 7045, 7258, 7463, 7660, 7849, 8030, 8203, 8368, 8525, 8674, 8815, 8948, 9073, 9190, 9299, 9400, 9399, 9398, 9397, 9396, 9395, 9394, 9393, 9392, 9391, 9390, 9389, 9388, 9387, 9386, 9385, 9384, 9383, 9382, 9381, 9380, 9379, 9378, 9377, 9376, 9375, 9270, 9157, 9036, 8907, 8770, 8625, 8472, 8311, 8142, 7965, 7780, 7587, 7386, 7177, 6960, 6735, 6502, 6261, 6012, 5755, 5490, 5217, 4936, 4647, 4350, 4045, 3732, 3411, 3082, 2745, 2400, 2047, 1686, 1317, 940, 555, 162], [334, 723, 1104, 1477, 1842, 2199, 2548, 2889, 3222, 3547, 3864, 4173, 4474, 4767, 5052, 5329, 5598, 5859, 6112, 6357, 6594, 6823, 7044, 7257, 7462, 7659, 7848, 8029, 8202, 8367, 8524, 8673, 8814, 8947, 9072, 9189, 9298, 9297, 9296, 9295, 9294, 9293, 9292, 9291, 9290, 9289, 9288, 9287, 9286, 9285, 9284, 9283, 9282, 9281, 9280, 9279, 9278, 9277, 9276, 9275, 9274, 9273, 9272, 9271, 9158, 9037, 8908, 8771, 8626, 8473, 8312, 8143, 7966, 7781, 7588, 7387, 7178, 6961, 6736, 6503, 6262, 6013, 5756, 5491, 5218, 4937, 4648, 4351, 4046, 3733, 3412, 3083, 2746, 2401, 2048, 1687, 1318, 941, 556, 163], [333, 722, 1103, 1476, 1841, 2198, 2547, 2888, 3221, 3546, 3863, 4172, 4473, 4766, 5051, 5328, 5597, 5858, 6111, 6356, 6593, 6822, 7043, 7256, 7461, 7658, 7847, 8028, 8201, 8366, 8523, 8672, 8813, 8946, 9071, 9188, 9187, 9186, 9185, 9184, 9183, 9182, 9181, 9180, 9179, 9178, 9177, 9176, 9175, 9174, 9173, 9172, 9171, 9170, 9169, 9168, 9167, 9166, 9165, 9164, 9163, 9162, 9161, 9160, 9159, 9038, 8909, 8772, 8627, 8474, 8313, 8144, 7967, 7782, 7589, 7388, 7179, 6962, 6737, 6504, 6263, 6014, 5757, 5492, 5219, 4938, 4649, 4352, 4047, 3734, 3413, 3084, 2747, 2402, 2049, 1688, 1319, 942, 557, 164], [332, 721, 1102, 1475, 1840, 2197, 2546, 2887, 3220, 3545, 3862, 4171, 4472, 4765, 5050, 5327, 5596, 5857, 6110, 6355, 6592, 6821, 7042, 7255, 7460, 7657, 7846, 8027, 8200, 8365, 8522, 8671, 8812, 8945, 9070, 9069, 9068, 9067, 9066, 9065, 9064, 9063, 9062, 9061, 9060, 9059, 9058, 9057, 9056, 9055, 9054, 9053, 9052, 9051, 9050, 9049, 9048, 9047, 9046, 9045, 9044, 9043, 9042, 9041, 9040, 9039, 8910, 8773, 8628, 8475, 8314, 8145, 7968, 7783, 7590, 7389, 7180, 6963, 6738, 6505, 6264, 6015, 5758, 5493, 5220, 4939, 4650, 4353, 4048, 3735, 3414, 3085, 2748, 2403, 2050, 1689, 1320, 943, 558, 165], [331, 720, 1101, 1474, 1839, 2196, 2545, 2886, 3219, 3544, 3861, 4170, 4471, 4764, 5049, 5326, 5595, 5856, 6109, 6354, 6591, 6820, 7041, 7254, 7459, 7656, 7845, 8026, 8199, 8364, 8521, 8670, 8811, 8944, 8943, 8942, 8941, 8940, 8939, 8938, 8937, 8936, 8935, 8934, 8933, 8932, 8931, 8930, 8929, 8928, 8927, 8926, 8925, 8924, 8923, 8922, 8921, 8920, 8919, 8918, 8917, 8916, 8915, 8914, 8913, 8912, 8911, 8774, 8629, 8476, 8315, 8146, 7969, 7784, 7591, 7390, 7181, 6964, 6739, 6506, 6265, 6016, 5759, 5494, 5221, 4940, 4651, 4354, 4049, 3736, 3415, 3086, 2749, 2404, 2051, 1690, 1321, 944, 559, 166], [330, 719, 1100, 1473, 1838, 2195, 2544, 2885, 3218, 3543, 3860, 4169, 4470, 4763, 5048, 5325, 5594, 5855, 6108, 6353, 6590, 6819, 7040, 7253, 7458, 7655, 7844, 8025, 8198, 8363, 8520, 8669, 8810, 8809, 8808, 8807, 8806, 8805, 8804, 8803, 8802, 8801, 8800, 8799, 8798, 8797, 8796, 8795, 8794, 8793, 8792, 8791, 8790, 8789, 8788, 8787, 8786, 8785, 8784, 8783, 8782, 8781, 8780, 8779, 8778, 8777, 8776, 8775, 8630, 8477, 8316, 8147, 7970, 7785, 7592, 7391, 7182, 6965, 6740, 6507, 6266, 6017, 5760, 5495, 5222, 4941, 4652, 4355, 4050, 3737, 3416, 3087, 2750, 2405, 2052, 1691, 1322, 945, 560, 167], [329, 718, 1099, 1472, 1837, 2194, 2543, 2884, 3217, 3542, 3859, 4168, 4469, 4762, 5047, 5324, 5593, 5854, 6107, 6352, 6589, 6818, 7039, 7252, 7457, 7654, 7843, 8024, 8197, 8362, 8519, 8668, 8667, 8666, 8665, 8664, 8663, 8662, 8661, 8660, 8659, 8658, 8657, 8656, 8655, 8654, 8653, 8652, 8651, 8650, 8649, 8648, 8647, 8646, 8645, 8644, 8643, 8642, 8641, 8640, 8639, 8638, 8637, 8636, 8635, 8634, 8633, 8632, 8631, 8478, 8317, 8148, 7971, 7786, 7593, 7392, 7183, 6966, 6741, 6508, 6267, 6018, 5761, 5496, 5223, 4942, 4653, 4356, 4051, 3738, 3417, 3088, 2751, 2406, 2053, 1692, 1323, 946, 561, 168], [328, 717, 1098, 1471, 1836, 2193, 2542, 2883, 3216, 3541, 3858, 4167, 4468, 4761, 5046, 5323, 5592, 5853, 6106, 6351, 6588, 6817, 7038, 7251, 7456, 7653, 7842, 8023, 8196, 8361, 8518, 8517, 8516, 8515, 8514, 8513, 8512, 8511, 8510, 8509, 8508, 8507, 8506, 8505, 8504, 8503, 8502, 8501, 8500, 8499, 8498, 8497, 8496, 8495, 8494, 8493, 8492, 8491, 8490, 8489, 8488, 8487, 8486, 8485, 8484, 8483, 8482, 8481, 8480, 8479, 8318, 8149, 7972, 7787, 7594, 7393, 7184, 6967, 6742, 6509, 6268, 6019, 5762, 5497, 5224, 4943, 4654, 4357, 4052, 3739, 3418, 3089, 2752, 2407, 2054, 1693, 1324, 947, 562, 169], [327, 716, 1097, 1470, 1835, 2192, 2541, 2882, 3215, 3540, 3857, 4166, 4467, 4760, 5045, 5322, 5591, 5852, 6105, 6350, 6587, 6816, 7037, 7250, 7455, 7652, 7841, 8022, 8195, 8360, 8359, 8358, 8357, 8356, 8355, 8354, 8353, 8352, 8351, 8350, 8349, 8348, 8347, 8346, 8345, 8344, 8343, 8342, 8341, 8340, 8339, 8338, 8337, 8336, 8335, 8334, 8333, 8332, 8331, 8330, 8329, 8328, 8327, 8326, 8325, 8324, 8323, 8322, 8321, 8320, 8319, 8150, 7973, 7788, 7595, 7394, 7185, 6968, 6743, 6510, 6269, 6020, 5763, 5498, 5225, 4944, 4655, 4358, 4053, 3740, 3419, 3090, 2753, 2408, 2055, 1694, 1325, 948, 563, 170], [326, 715, 1096, 1469, 1834, 2191, 2540, 2881, 3214, 3539, 3856, 4165, 4466, 4759, 5044, 5321, 5590, 5851, 6104, 6349, 6586, 6815, 7036, 7249, 7454, 7651, 7840, 8021, 8194, 8193, 8192, 8191, 8190, 8189, 8188, 8187, 8186, 8185, 8184, 8183, 8182, 8181, 8180, 8179, 8178, 8177, 8176, 8175, 8174, 8173, 8172, 8171, 8170, 8169, 8168, 8167, 8166, 8165, 8164, 8163, 8162, 8161, 8160, 8159, 8158, 8157, 8156, 8155, 8154, 8153, 8152, 8151, 7974, 7789, 7596, 7395, 7186, 6969, 6744, 6511, 6270, 6021, 5764, 5499, 5226, 4945, 4656, 4359, 4054, 3741, 3420, 3091, 2754, 2409, 2056, 1695, 1326, 949, 564, 171], [325, 714, 1095, 1468, 1833, 2190, 2539, 2880, 3213, 3538, 3855, 4164, 4465, 4758, 5043, 5320, 5589, 5850, 6103, 6348, 6585, 6814, 7035, 7248, 7453, 7650, 7839, 8020, 8019, 8018, 8017, 8016, 8015, 8014, 8013, 8012, 8011, 8010, 8009, 8008, 8007, 8006, 8005, 8004, 8003, 8002, 8001, 8000, 7999, 7998, 7997, 7996, 7995, 7994, 7993, 7992, 7991, 7990, 7989, 7988, 7987, 7986, 7985, 7984, 7983, 7982, 7981, 7980, 7979, 7978, 7977, 7976, 7975, 7790, 7597, 7396, 7187, 6970, 6745, 6512, 6271, 6022, 5765, 5500, 5227, 4946, 4657, 4360, 4055, 3742, 3421, 3092, 2755, 2410, 2057, 1696, 1327, 950, 565, 172], [324, 713, 1094, 1467, 1832, 2189, 2538, 2879, 3212, 3537, 3854, 4163, 4464, 4757, 5042, 5319, 5588, 5849, 6102, 6347, 6584, 6813, 7034, 7247, 7452, 7649, 7838, 7837, 7836, 7835, 7834, 7833, 7832, 7831, 7830, 7829, 7828, 7827, 7826, 7825, 7824, 7823, 7822, 7821, 7820, 7819, 7818, 7817, 7816, 7815, 7814, 7813, 7812, 7811, 7810, 7809, 7808, 7807, 7806, 7805, 7804, 7803, 7802, 7801, 7800, 7799, 7798, 7797, 7796, 7795, 7794, 7793, 7792, 7791, 7598, 7397, 7188, 6971, 6746, 6513, 6272, 6023, 5766, 5501, 5228, 4947, 4658, 4361, 4056, 3743, 3422, 3093, 2756, 2411, 2058, 1697, 1328, 951, 566, 173], [323, 712, 1093, 1466, 1831, 2188, 2537, 2878, 3211, 3536, 3853, 4162, 4463, 4756, 5041, 5318, 5587, 5848, 6101, 6346, 6583, 6812, 7033, 7246, 7451, 7648, 7647, 7646, 7645, 7644, 7643, 7642, 7641, 7640, 7639, 7638, 7637, 7636, 7635, 7634, 7633, 7632, 7631, 7630, 7629, 7628, 7627, 7626, 7625, 7624, 7623, 7622, 7621, 7620, 7619, 7618, 7617, 7616, 7615, 7614, 7613, 7612, 7611, 7610, 7609, 7608, 7607, 7606, 7605, 7604, 7603, 7602, 7601, 7600, 7599, 7398, 7189, 6972, 6747, 6514, 6273, 6024, 5767, 5502, 5229, 4948, 4659, 4362, 4057, 3744, 3423, 3094, 2757, 2412, 2059, 1698, 1329, 952, 567, 174], [322, 711, 1092, 1465, 1830, 2187, 2536, 2877, 3210, 3535, 3852, 4161, 4462, 4755, 5040, 5317, 5586, 5847, 6100, 6345, 6582, 6811, 7032, 7245, 7450, 7449, 7448, 7447, 7446, 7445, 7444, 7443, 7442, 7441, 7440, 7439, 7438, 7437, 7436, 7435, 7434, 7433, 7432, 7431, 7430, 7429, 7428, 7427, 7426, 7425, 7424, 7423, 7422, 7421, 7420, 7419, 7418, 7417, 7416, 7415, 7414, 7413, 7412, 7411, 7410, 7409, 7408, 7407, 7406, 7405, 7404, 7403, 7402, 7401, 7400, 7399, 7190, 6973, 6748, 6515, 6274, 6025, 5768, 5503, 5230, 4949, 4660, 4363, 4058, 3745, 3424, 3095, 2758, 2413, 2060, 1699, 1330, 953, 568, 175], [321, 710, 1091, 1464, 1829, 2186, 2535, 2876, 3209, 3534, 3851, 4160, 4461, 4754, 5039, 5316, 5585, 5846, 6099, 6344, 6581, 6810, 7031, 7244, 7243, 7242, 7241, 7240, 7239, 7238, 7237, 7236, 7235, 7234, 7233, 7232, 7231, 7230, 7229, 7228, 7227, 7226, 7225, 7224, 7223, 7222, 7221, 7220, 7219, 7218, 7217, 7216, 7215, 7214, 7213, 7212, 7211, 7210, 7209, 7208, 7207, 7206, 7205, 7204, 7203, 7202, 7201, 7200, 7199, 7198, 7197, 7196, 7195, 7194, 7193, 7192, 7191, 6974, 6749, 6516, 6275, 6026, 5769, 5504, 5231, 4950, 4661, 4364, 4059, 3746, 3425, 3096, 2759, 2414, 2061, 1700, 1331, 954, 569, 176], [320, 709, 1090, 1463, 1828, 2185, 2534, 2875, 3208, 3533, 3850, 4159, 4460, 4753, 5038, 5315, 5584, 5845, 6098, 6343, 6580, 6809, 7030, 7029, 7028, 7027, 7026, 7025, 7024, 7023, 7022, 7021, 7020, 7019, 7018, 7017, 7016, 7015, 7014, 7013, 7012, 7011, 7010, 7009, 7008, 7007, 7006, 7005, 7004, 7003, 7002, 7001, 7000, 6999, 6998, 6997, 6996, 6995, 6994, 6993, 6992, 6991, 6990, 6989, 6988, 6987, 6986, 6985, 6984, 6983, 6982, 6981, 6980, 6979, 6978, 6977, 6976, 6975, 6750, 6517, 6276, 6027, 5770, 5505, 5232, 4951, 4662, 4365, 4060, 3747, 3426, 3097, 2760, 2415, 2062, 1701, 1332, 955, 570, 177], [319, 708, 1089, 1462, 1827, 2184, 2533, 2874, 3207, 3532, 3849, 4158, 4459, 4752, 5037, 5314, 5583, 5844, 6097, 6342, 6579, 6808, 6807, 6806, 6805, 6804, 6803, 6802, 6801, 6800, 6799, 6798, 6797, 6796, 6795, 6794, 6793, 6792, 6791, 6790, 6789, 6788, 6787, 6786, 6785, 6784, 6783, 6782, 6781, 6780, 6779, 6778, 6777, 6776, 6775, 6774, 6773, 6772, 6771, 6770, 6769, 6768, 6767, 6766, 6765, 6764, 6763, 6762, 6761, 6760, 6759, 6758, 6757, 6756, 6755, 6754, 6753, 6752, 6751, 6518, 6277, 6028, 5771, 5506, 5233, 4952, 4663, 4366, 4061, 3748, 3427, 3098, 2761, 2416, 2063, 1702, 1333, 956, 571, 178], [318, 707, 1088, 1461, 1826, 2183, 2532, 2873, 3206, 3531, 3848, 4157, 4458, 4751, 5036, 5313, 5582, 5843, 6096, 6341, 6578, 6577, 6576, 6575, 6574, 6573, 6572, 6571, 6570, 6569, 6568, 6567, 6566, 6565, 6564, 6563, 6562, 6561, 6560, 6559, 6558, 6557, 6556, 6555, 6554, 6553, 6552, 6551, 6550, 6549, 6548, 6547, 6546, 6545, 6544, 6543, 6542, 6541, 6540, 6539, 6538, 6537, 6536, 6535, 6534, 6533, 6532, 6531, 6530, 6529, 6528, 6527, 6526, 6525, 6524, 6523, 6522, 6521, 6520, 6519, 6278, 6029, 5772, 5507, 5234, 4953, 4664, 4367, 4062, 3749, 3428, 3099, 2762, 2417, 2064, 1703, 1334, 957, 572, 179], [317, 706, 1087, 1460, 1825, 2182, 2531, 2872, 3205, 3530, 3847, 4156, 4457, 4750, 5035, 5312, 5581, 5842, 6095, 6340, 6339, 6338, 6337, 6336, 6335, 6334, 6333, 6332, 6331, 6330, 6329, 6328, 6327, 6326, 6325, 6324, 6323, 6322, 6321, 6320, 6319, 6318, 6317, 6316, 6315, 6314, 6313, 6312, 6311, 6310, 6309, 6308, 6307, 6306, 6305, 6304, 6303, 6302, 6301, 6300, 6299, 6298, 6297, 6296, 6295, 6294, 6293, 6292, 6291, 6290, 6289, 6288, 6287, 6286, 6285, 6284, 6283, 6282, 6281, 6280, 6279, 6030, 5773, 5508, 5235, 4954, 4665, 4368, 4063, 3750, 3429, 3100, 2763, 2418, 2065, 1704, 1335, 958, 573, 180], [316, 705, 1086, 1459, 1824, 2181, 2530, 2871, 3204, 3529, 3846, 4155, 4456, 4749, 5034, 5311, 5580, 5841, 6094, 6093, 6092, 6091, 6090, 6089, 6088, 6087, 6086, 6085, 6084, 6083, 6082, 6081, 6080, 6079, 6078, 6077, 6076, 6075, 6074, 6073, 6072, 6071, 6070, 6069, 6068, 6067, 6066, 6065, 6064, 6063, 6062, 6061, 6060, 6059, 6058, 6057, 6056, 6055, 6054, 6053, 6052, 6051, 6050, 6049, 6048, 6047, 6046, 6045, 6044, 6043, 6042, 6041, 6040, 6039, 6038, 6037, 6036, 6035, 6034, 6033, 6032, 6031, 5774, 5509, 5236, 4955, 4666, 4369, 4064, 3751, 3430, 3101, 2764, 2419, 2066, 1705, 1336, 959, 574, 181], [315, 704, 1085, 1458, 1823, 2180, 2529, 2870, 3203, 3528, 3845, 4154, 4455, 4748, 5033, 5310, 5579, 5840, 5839, 5838, 5837, 5836, 5835, 5834, 5833, 5832, 5831, 5830, 5829, 5828, 5827, 5826, 5825, 5824, 5823, 5822, 5821, 5820, 5819, 5818, 5817, 5816, 5815, 5814, 5813, 5812, 5811, 5810, 5809, 5808, 5807, 5806, 5805, 5804, 5803, 5802, 5801, 5800, 5799, 5798, 5797, 5796, 5795, 5794, 5793, 5792, 5791, 5790, 5789, 5788, 5787, 5786, 5785, 5784, 5783, 5782, 5781, 5780, 5779, 5778, 5777, 5776, 5775, 5510, 5237, 4956, 4667, 4370, 4065, 3752, 3431, 3102, 2765, 2420, 2067, 1706, 1337, 960, 575, 182], [314, 703, 1084, 1457, 1822, 2179, 2528, 2869, 3202, 3527, 3844, 4153, 4454, 4747, 5032, 5309, 5578, 5577, 5576, 5575, 5574, 5573, 5572, 5571, 5570, 5569, 5568, 5567, 5566, 5565, 5564, 5563, 5562, 5561, 5560, 5559, 5558, 5557, 5556, 5555, 5554, 5553, 5552, 5551, 5550, 5549, 5548, 5547, 5546, 5545, 5544, 5543, 5542, 5541, 5540, 5539, 5538, 5537, 5536, 5535, 5534, 5533, 5532, 5531, 5530, 5529, 5528, 5527, 5526, 5525, 5524, 5523, 5522, 5521, 5520, 5519, 5518, 5517, 5516, 5515, 5514, 5513, 5512, 5511, 5238, 4957, 4668, 4371, 4066, 3753, 3432, 3103, 2766, 2421, 2068, 1707, 1338, 961, 576, 183], [313, 702, 1083, 1456, 1821, 2178, 2527, 2868, 3201, 3526, 3843, 4152, 4453, 4746, 5031, 5308, 5307, 5306, 5305, 5304, 5303, 5302, 5301, 5300, 5299, 5298, 5297, 5296, 5295, 5294, 5293, 5292, 5291, 5290, 5289, 5288, 5287, 5286, 5285, 5284, 5283, 5282, 5281, 5280, 5279, 5278, 5277, 5276, 5275, 5274, 5273, 5272, 5271, 5270, 5269, 5268, 5267, 5266, 5265, 5264, 5263, 5262, 5261, 5260, 5259, 5258, 5257, 5256, 5255, 5254, 5253, 5252, 5251, 5250, 5249, 5248, 5247, 5246, 5245, 5244, 5243, 5242, 5241, 5240, 5239, 4958, 4669, 4372, 4067, 3754, 3433, 3104, 2767, 2422, 2069, 1708, 1339, 962, 577, 184], [312, 701, 1082, 1455, 1820, 2177, 2526, 2867, 3200, 3525, 3842, 4151, 4452, 4745, 5030, 5029, 5028, 5027, 5026, 5025, 5024, 5023, 5022, 5021, 5020, 5019, 5018, 5017, 5016, 5015, 5014, 5013, 5012, 5011, 5010, 5009, 5008, 5007, 5006, 5005, 5004, 5003, 5002, 5001, 5000, 4999, 4998, 4997, 4996, 4995, 4994, 4993, 4992, 4991, 4990, 4989, 4988, 4987, 4986, 4985, 4984, 4983, 4982, 4981, 4980, 4979, 4978, 4977, 4976, 4975, 4974, 4973, 4972, 4971, 4970, 4969, 4968, 4967, 4966, 4965, 4964, 4963, 4962, 4961, 4960, 4959, 4670, 4373, 4068, 3755, 3434, 3105, 2768, 2423, 2070, 1709, 1340, 963, 578, 185], [311, 700, 1081, 1454, 1819, 2176, 2525, 2866, 3199, 3524, 3841, 4150, 4451, 4744, 4743, 4742, 4741, 4740, 4739, 4738, 4737, 4736, 4735, 4734, 4733, 4732, 4731, 4730, 4729, 4728, 4727, 4726, 4725, 4724, 4723, 4722, 4721, 4720, 4719, 4718, 4717, 4716, 4715, 4714, 4713, 4712, 4711, 4710, 4709, 4708, 4707, 4706, 4705, 4704, 4703, 4702, 4701, 4700, 4699, 4698, 4697, 4696, 4695, 4694, 4693, 4692, 4691, 4690, 4689, 4688, 4687, 4686, 4685, 4684, 4683, 4682, 4681, 4680, 4679, 4678, 4677, 4676, 4675, 4674, 4673, 4672, 4671, 4374, 4069, 3756, 3435, 3106, 2769, 2424, 2071, 1710, 1341, 964, 579, 186], [310, 699, 1080, 1453, 1818, 2175, 2524, 2865, 3198, 3523, 3840, 4149, 4450, 4449, 4448, 4447, 4446, 4445, 4444, 4443, 4442, 4441, 4440, 4439, 4438, 4437, 4436, 4435, 4434, 4433, 4432, 4431, 4430, 4429, 4428, 4427, 4426, 4425, 4424, 4423, 4422, 4421, 4420, 4419, 4418, 4417, 4416, 4415, 4414, 4413, 4412, 4411, 4410, 4409, 4408, 4407, 4406, 4405, 4404, 4403, 4402, 4401, 4400, 4399, 4398, 4397, 4396, 4395, 4394, 4393, 4392, 4391, 4390, 4389, 4388, 4387, 4386, 4385, 4384, 4383, 4382, 4381, 4380, 4379, 4378, 4377, 4376, 4375, 4070, 3757, 3436, 3107, 2770, 2425, 2072, 1711, 1342, 965, 580, 187], [309, 698, 1079, 1452, 1817, 2174, 2523, 2864, 3197, 3522, 3839, 4148, 4147, 4146, 4145, 4144, 4143, 4142, 4141, 4140, 4139, 4138, 4137, 4136, 4135, 4134, 4133, 4132, 4131, 4130, 4129, 4128, 4127, 4126, 4125, 4124, 4123, 4122, 4121, 4120, 4119, 4118, 4117, 4116, 4115, 4114, 4113, 4112, 4111, 4110, 4109, 4108, 4107, 4106, 4105, 4104, 4103, 4102, 4101, 4100, 4099, 4098, 4097, 4096, 4095, 4094, 4093, 4092, 4091, 4090, 4089, 4088, 4087, 4086, 4085, 4084, 4083, 4082, 4081, 4080, 4079, 4078, 4077, 4076, 4075, 4074, 4073, 4072, 4071, 3758, 3437, 3108, 2771, 2426, 2073, 1712, 1343, 966, 581, 188], [308, 697, 1078, 1451, 1816, 2173, 2522, 2863, 3196, 3521, 3838, 3837, 3836, 3835, 3834, 3833, 3832, 3831, 3830, 3829, 3828, 3827, 3826, 3825, 3824, 3823, 3822, 3821, 3820, 3819, 3818, 3817, 3816, 3815, 3814, 3813, 3812, 3811, 3810, 3809, 3808, 3807, 3806, 3805, 3804, 3803, 3802, 3801, 3800, 3799, 3798, 3797, 3796, 3795, 3794, 3793, 3792, 3791, 3790, 3789, 3788, 3787, 3786, 3785, 3784, 3783, 3782, 3781, 3780, 3779, 3778, 3777, 3776, 3775, 3774, 3773, 3772, 3771, 3770, 3769, 3768, 3767, 3766, 3765, 3764, 3763, 3762, 3761, 3760, 3759, 3438, 3109, 2772, 2427, 2074, 1713, 1344, 967, 582, 189], [307, 696, 1077, 1450, 1815, 2172, 2521, 2862, 3195, 3520, 3519, 3518, 3517, 3516, 3515, 3514, 3513, 3512, 3511, 3510, 3509, 3508, 3507, 3506, 3505, 3504, 3503, 3502, 3501, 3500, 3499, 3498, 3497, 3496, 3495, 3494, 3493, 3492, 3491, 3490, 3489, 3488, 3487, 3486, 3485, 3484, 3483, 3482, 3481, 3480, 3479, 3478, 3477, 3476, 3475, 3474, 3473, 3472, 3471, 3470, 3469, 3468, 3467, 3466, 3465, 3464, 3463, 3462, 3461, 3460, 3459, 3458, 3457, 3456, 3455, 3454, 3453, 3452, 3451, 3450, 3449, 3448, 3447, 3446, 3445, 3444, 3443, 3442, 3441, 3440, 3439, 3110, 2773, 2428, 2075, 1714, 1345, 968, 583, 190], [306, 695, 1076, 1449, 1814, 2171, 2520, 2861, 3194, 3193, 3192, 3191, 3190, 3189, 3188, 3187, 3186, 3185, 3184, 3183, 3182, 3181, 3180, 3179, 3178, 3177, 3176, 3175, 3174, 3173, 3172, 3171, 3170, 3169, 3168, 3167, 3166, 3165, 3164, 3163, 3162, 3161, 3160, 3159, 3158, 3157, 3156, 3155, 3154, 3153, 3152, 3151, 3150, 3149, 3148, 3147, 3146, 3145, 3144, 3143, 3142, 3141, 3140, 3139, 3138, 3137, 3136, 3135, 3134, 3133, 3132, 3131, 3130, 3129, 3128, 3127, 3126, 3125, 3124, 3123, 3122, 3121, 3120, 3119, 3118, 3117, 3116, 3115, 3114, 3113, 3112, 3111, 2774, 2429, 2076, 1715, 1346, 969, 584, 191], [305, 694, 1075, 1448, 1813, 2170, 2519, 2860, 2859, 2858, 2857, 2856, 2855, 2854, 2853, 2852, 2851, 2850, 2849, 2848, 2847, 2846, 2845, 2844, 2843, 2842, 2841, 2840, 2839, 2838, 2837, 2836, 2835, 2834, 2833, 2832, 2831, 2830, 2829, 2828, 2827, 2826, 2825, 2824, 2823, 2822, 2821, 2820, 2819, 2818, 2817, 2816, 2815, 2814, 2813, 2812, 2811, 2810, 2809, 2808, 2807, 2806, 2805, 2804, 2803, 2802, 2801, 2800, 2799, 2798, 2797, 2796, 2795, 2794, 2793, 2792, 2791, 2790, 2789, 2788, 2787, 2786, 2785, 2784, 2783, 2782, 2781, 2780, 2779, 2778, 2777, 2776, 2775, 2430, 2077, 1716, 1347, 970, 585, 192], [304, 693, 1074, 1447, 1812, 2169, 2518, 2517, 2516, 2515, 2514, 2513, 2512, 2511, 2510, 2509, 2508, 2507, 2506, 2505, 2504, 2503, 2502, 2501, 2500, 2499, 2498, 2497, 2496, 2495, 2494, 2493, 2492, 2491, 2490, 2489, 2488, 2487, 2486, 2485, 2484, 2483, 2482, 2481, 2480, 2479, 2478, 2477, 2476, 2475, 2474, 2473, 2472, 2471, 2470, 2469, 2468, 2467, 2466, 2465, 2464, 2463, 2462, 2461, 2460, 2459, 2458, 2457, 2456, 2455, 2454, 2453, 2452, 2451, 2450, 2449, 2448, 2447, 2446, 2445, 2444, 2443, 2442, 2441, 2440, 2439, 2438, 2437, 2436, 2435, 2434, 2433, 2432, 2431, 2078, 1717, 1348, 971, 586, 193], [303, 692, 1073, 1446, 1811, 2168, 2167, 2166, 2165, 2164, 2163, 2162, 2161, 2160, 2159, 2158, 2157, 2156, 2155, 2154, 2153, 2152, 2151, 2150, 2149, 2148, 2147, 2146, 2145, 2144, 2143, 2142, 2141, 2140, 2139, 2138, 2137, 2136, 2135, 2134, 2133, 2132, 2131, 2130, 2129, 2128, 2127, 2126, 2125, 2124, 2123, 2122, 2121, 2120, 2119, 2118, 2117, 2116, 2115, 2114, 2113, 2112, 2111, 2110, 2109, 2108, 2107, 2106, 2105, 2104, 2103, 2102, 2101, 2100, 2099, 2098, 2097, 2096, 2095, 2094, 2093, 2092, 2091, 2090, 2089, 2088, 2087, 2086, 2085, 2084, 2083, 2082, 2081, 2080, 2079, 1718, 1349, 972, 587, 194], [302, 691, 1072, 1445, 1810, 1809, 1808, 1807, 1806, 1805, 1804, 1803, 1802, 1801, 1800, 1799, 1798, 1797, 1796, 1795, 1794, 1793, 1792, 1791, 1790, 1789, 1788, 1787, 1786, 1785, 1784, 1783, 1782, 1781, 1780, 1779, 1778, 1777, 1776, 1775, 1774, 1773, 1772, 1771, 1770, 1769, 1768, 1767, 1766, 1765, 1764, 1763, 1762, 1761, 1760, 1759, 1758, 1757, 1756, 1755, 1754, 1753, 1752, 1751, 1750, 1749, 1748, 1747, 1746, 1745, 1744, 1743, 1742, 1741, 1740, 1739, 1738, 1737, 1736, 1735, 1734, 1733, 1732, 1731, 1730, 1729, 1728, 1727, 1726, 1725, 1724, 1723, 1722, 1721, 1720, 1719, 1350, 973, 588, 195], [301, 690, 1071, 1444, 1443, 1442, 1441, 1440, 1439, 1438, 1437, 1436, 1435, 1434, 1433, 1432, 1431, 1430, 1429, 1428, 1427, 1426, 1425, 1424, 1423, 1422, 1421, 1420, 1419, 1418, 1417, 1416, 1415, 1414, 1413, 1412, 1411, 1410, 1409, 1408, 1407, 1406, 1405, 1404, 1403, 1402, 1401, 1400, 1399, 1398, 1397, 1396, 1395, 1394, 1393, 1392, 1391, 1390, 1389, 1388, 1387, 1386, 1385, 1384, 1383, 1382, 1381, 1380, 1379, 1378, 1377, 1376, 1375, 1374, 1373, 1372, 1371, 1370, 1369, 1368, 1367, 1366, 1365, 1364, 1363, 1362, 1361, 1360, 1359, 1358, 1357, 1356, 1355, 1354, 1353, 1352, 1351, 974, 589, 196], [300, 689, 1070, 1069, 1068, 1067, 1066, 1065, 1064, 1063, 1062, 1061, 1060, 1059, 1058, 1057, 1056, 1055, 1054, 1053, 1052, 1051, 1050, 1049, 1048, 1047, 1046, 1045, 1044, 1043, 1042, 1041, 1040, 1039, 1038, 1037, 1036, 1035, 1034, 1033, 1032, 1031, 1030, 1029, 1028, 1027, 1026, 1025, 1024, 1023, 1022, 1021, 1020, 1019, 1018, 1017, 1016, 1015, 1014, 1013, 1012, 1011, 1010, 1009, 1008, 1007, 1006, 1005, 1004, 1003, 1002, 1001, 1000, 999, 998, 997, 996, 995, 994, 993, 992, 991, 990, 989, 988, 987, 986, 985, 984, 983, 982, 981, 980, 979, 978, 977, 976, 975, 590, 197], [299, 688, 687, 686, 685, 684, 683, 682, 681, 680, 679, 678, 677, 676, 675, 674, 673, 672, 671, 670, 669, 668, 667, 666, 665, 664, 663, 662, 661, 660, 659, 658, 657, 656, 655, 654, 653, 652, 651, 650, 649, 648, 647, 646, 645, 644, 643, 642, 641, 640, 639, 638, 637, 636, 635, 634, 633, 632, 631, 630, 629, 628, 627, 626, 625, 624, 623, 622, 621, 620, 619, 618, 617, 616, 615, 614, 613, 612, 611, 610, 609, 608, 607, 606, 605, 604, 603, 602, 601, 600, 599, 598, 597, 596, 595, 594, 593, 592, 591, 198], [298, 297, 296, 295, 294, 293, 292, 291, 290, 289, 288, 287, 286, 285, 284, 283, 282, 281, 280, 279, 278, 277, 276, 275, 274, 273, 272, 271, 270, 269, 268, 267, 266, 265, 264, 263, 262, 261, 260, 259, 258, 257, 256, 255, 254, 253, 252, 251, 250, 249, 248, 247, 246, 245, 244, 243, 242, 241, 240, 239, 238, 237, 236, 235, 234, 233, 232, 231, 230, 229, 228, 227, 226, 225, 224, 223, 222, 221, 220, 219, 218, 217, 216, 215, 214, 213, 212, 211, 210, 209, 208, 207, 206, 205, 204, 203, 202, 201, 200, 199]]\n    assert candidate(5) == [[1, 2, 3, 4, 5], [16, 17, 18, 19, 6], [15, 24, 25, 20, 7], [14, 23, 22, 21, 8], [13, 12, 11, 10, 9]]\n    assert candidate(1) == [[1]]\n    assert candidate(10) == [[1, 2, 3, 4, 5, 6, 7, 8, 9, 10], [36, 37, 38, 39, 40, 41, 42, 43, 44, 11], [35, 64, 65, 66, 67, 68, 69, 70, 45, 12], [34, 63, 84, 85, 86, 87, 88, 71, 46, 13], [33, 62, 83, 96, 97, 98, 89, 72, 47, 14], [32, 61, 82, 95, 100, 99, 90, 73, 48, 15], [31, 60, 81, 94, 93, 92, 91, 74, 49, 16], [30, 59, 80, 79, 78, 77, 76, 75, 50, 17], [29, 58, 57, 56, 55, 54, 53, 52, 51, 18], [28, 27, 26, 25, 24, 23, 22, 21, 20, 19]]\n    assert candidate(50) == [[1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50], [196, 197, 198, 199, 200, 201, 202, 203, 204, 205, 206, 207, 208, 209, 210, 211, 212, 213, 214, 215, 216, 217, 218, 219, 220, 221, 222, 223, 224, 225, 226, 227, 228, 229, 230, 231, 232, 233, 234, 235, 236, 237, 238, 239, 240, 241, 242, 243, 244, 51], [195, 384, 385, 386, 387, 388, 389, 390, 391, 392, 393, 394, 395, 396, 397, 398, 399, 400, 401, 402, 403, 404, 405, 406, 407, 408, 409, 410, 411, 412, 413, 414, 415, 416, 417, 418, 419, 420, 421, 422, 423, 424, 425, 426, 427, 428, 429, 430, 245, 52], [194, 383, 564, 565, 566, 567, 568, 569, 570, 571, 572, 573, 574, 575, 576, 577, 578, 579, 580, 581, 582, 583, 584, 585, 586, 587, 588, 589, 590, 591, 592, 593, 594, 595, 596, 597, 598, 599, 600, 601, 602, 603, 604, 605, 606, 607, 608, 431, 246, 53], [193, 382, 563, 736, 737, 738, 739, 740, 741, 742, 743, 744, 745, 746, 747, 748, 749, 750, 751, 752, 753, 754, 755, 756, 757, 758, 759, 760, 761, 762, 763, 764, 765, 766, 767, 768, 769, 770, 771, 772, 773, 774, 775, 776, 777, 778, 609, 432, 247, 54], [192, 381, 562, 735, 900, 901, 902, 903, 904, 905, 906, 907, 908, 909, 910, 911, 912, 913, 914, 915, 916, 917, 918, 919, 920, 921, 922, 923, 924, 925, 926, 927, 928, 929, 930, 931, 932, 933, 934, 935, 936, 937, 938, 939, 940, 779, 610, 433, 248, 55], [191, 380, 561, 734, 899, 1056, 1057, 1058, 1059, 1060, 1061, 1062, 1063, 1064, 1065, 1066, 1067, 1068, 1069, 1070, 1071, 1072, 1073, 1074, 1075, 1076, 1077, 1078, 1079, 1080, 1081, 1082, 1083, 1084, 1085, 1086, 1087, 1088, 1089, 1090, 1091, 1092, 1093, 1094, 941, 780, 611, 434, 249, 56], [190, 379, 560, 733, 898, 1055, 1204, 1205, 1206, 1207, 1208, 1209, 1210, 1211, 1212, 1213, 1214, 1215, 1216, 1217, 1218, 1219, 1220, 1221, 1222, 1223, 1224, 1225, 1226, 1227, 1228, 1229, 1230, 1231, 1232, 1233, 1234, 1235, 1236, 1237, 1238, 1239, 1240, 1095, 942, 781, 612, 435, 250, 57], [189, 378, 559, 732, 897, 1054, 1203, 1344, 1345, 1346, 1347, 1348, 1349, 1350, 1351, 1352, 1353, 1354, 1355, 1356, 1357, 1358, 1359, 1360, 1361, 1362, 1363, 1364, 1365, 1366, 1367, 1368, 1369, 1370, 1371, 1372, 1373, 1374, 1375, 1376, 1377, 1378, 1241, 1096, 943, 782, 613, 436, 251, 58], [188, 377, 558, 731, 896, 1053, 1202, 1343, 1476, 1477, 1478, 1479, 1480, 1481, 1482, 1483, 1484, 1485, 1486, 1487, 1488, 1489, 1490, 1491, 1492, 1493, 1494, 1495, 1496, 1497, 1498, 1499, 1500, 1501, 1502, 1503, 1504, 1505, 1506, 1507, 1508, 1379, 1242, 1097, 944, 783, 614, 437, 252, 59], [187, 376, 557, 730, 895, 1052, 1201, 1342, 1475, 1600, 1601, 1602, 1603, 1604, 1605, 1606, 1607, 1608, 1609, 1610, 1611, 1612, 1613, 1614, 1615, 1616, 1617, 1618, 1619, 1620, 1621, 1622, 1623, 1624, 1625, 1626, 1627, 1628, 1629, 1630, 1509, 1380, 1243, 1098, 945, 784, 615, 438, 253, 60], [186, 375, 556, 729, 894, 1051, 1200, 1341, 1474, 1599, 1716, 1717, 1718, 1719, 1720, 1721, 1722, 1723, 1724, 1725, 1726, 1727, 1728, 1729, 1730, 1731, 1732, 1733, 1734, 1735, 1736, 1737, 1738, 1739, 1740, 1741, 1742, 1743, 1744, 1631, 1510, 1381, 1244, 1099, 946, 785, 616, 439, 254, 61], [185, 374, 555, 728, 893, 1050, 1199, 1340, 1473, 1598, 1715, 1824, 1825, 1826, 1827, 1828, 1829, 1830, 1831, 1832, 1833, 1834, 1835, 1836, 1837, 1838, 1839, 1840, 1841, 1842, 1843, 1844, 1845, 1846, 1847, 1848, 1849, 1850, 1745, 1632, 1511, 1382, 1245, 1100, 947, 786, 617, 440, 255, 62], [184, 373, 554, 727, 892, 1049, 1198, 1339, 1472, 1597, 1714, 1823, 1924, 1925, 1926, 1927, 1928, 1929, 1930, 1931, 1932, 1933, 1934, 1935, 1936, 1937, 1938, 1939, 1940, 1941, 1942, 1943, 1944, 1945, 1946, 1947, 1948, 1851, 1746, 1633, 1512, 1383, 1246, 1101, 948, 787, 618, 441, 256, 63], [183, 372, 553, 726, 891, 1048, 1197, 1338, 1471, 1596, 1713, 1822, 1923, 2016, 2017, 2018, 2019, 2020, 2021, 2022, 2023, 2024, 2025, 2026, 2027, 2028, 2029, 2030, 2031, 2032, 2033, 2034, 2035, 2036, 2037, 2038, 1949, 1852, 1747, 1634, 1513, 1384, 1247, 1102, 949, 788, 619, 442, 257, 64], [182, 371, 552, 725, 890, 1047, 1196, 1337, 1470, 1595, 1712, 1821, 1922, 2015, 2100, 2101, 2102, 2103, 2104, 2105, 2106, 2107, 2108, 2109, 2110, 2111, 2112, 2113, 2114, 2115, 2116, 2117, 2118, 2119, 2120, 2039, 1950, 1853, 1748, 1635, 1514, 1385, 1248, 1103, 950, 789, 620, 443, 258, 65], [181, 370, 551, 724, 889, 1046, 1195, 1336, 1469, 1594, 1711, 1820, 1921, 2014, 2099, 2176, 2177, 2178, 2179, 2180, 2181, 2182, 2183, 2184, 2185, 2186, 2187, 2188, 2189, 2190, 2191, 2192, 2193, 2194, 2121, 2040, 1951, 1854, 1749, 1636, 1515, 1386, 1249, 1104, 951, 790, 621, 444, 259, 66], [180, 369, 550, 723, 888, 1045, 1194, 1335, 1468, 1593, 1710, 1819, 1920, 2013, 2098, 2175, 2244, 2245, 2246, 2247, 2248, 2249, 2250, 2251, 2252, 2253, 2254, 2255, 2256, 2257, 2258, 2259, 2260, 2195, 2122, 2041, 1952, 1855, 1750, 1637, 1516, 1387, 1250, 1105, 952, 791, 622, 445, 260, 67], [179, 368, 549, 722, 887, 1044, 1193, 1334, 1467, 1592, 1709, 1818, 1919, 2012, 2097, 2174, 2243, 2304, 2305, 2306, 2307, 2308, 2309, 2310, 2311, 2312, 2313, 2314, 2315, 2316, 2317, 2318, 2261, 2196, 2123, 2042, 1953, 1856, 1751, 1638, 1517, 1388, 1251, 1106, 953, 792, 623, 446, 261, 68], [178, 367, 548, 721, 886, 1043, 1192, 1333, 1466, 1591, 1708, 1817, 1918, 2011, 2096, 2173, 2242, 2303, 2356, 2357, 2358, 2359, 2360, 2361, 2362, 2363, 2364, 2365, 2366, 2367, 2368, 2319, 2262, 2197, 2124, 2043, 1954, 1857, 1752, 1639, 1518, 1389, 1252, 1107, 954, 793, 624, 447, 262, 69], [177, 366, 547, 720, 885, 1042, 1191, 1332, 1465, 1590, 1707, 1816, 1917, 2010, 2095, 2172, 2241, 2302, 2355, 2400, 2401, 2402, 2403, 2404, 2405, 2406, 2407, 2408, 2409, 2410, 2369, 2320, 2263, 2198, 2125, 2044, 1955, 1858, 1753, 1640, 1519, 1390, 1253, 1108, 955, 794, 625, 448, 263, 70], [176, 365, 546, 719, 884, 1041, 1190, 1331, 1464, 1589, 1706, 1815, 1916, 2009, 2094, 2171, 2240, 2301, 2354, 2399, 2436, 2437, 2438, 2439, 2440, 2441, 2442, 2443, 2444, 2411, 2370, 2321, 2264, 2199, 2126, 2045, 1956, 1859, 1754, 1641, 1520, 1391, 1254, 1109, 956, 795, 626, 449, 264, 71], [175, 364, 545, 718, 883, 1040, 1189, 1330, 1463, 1588, 1705, 1814, 1915, 2008, 2093, 2170, 2239, 2300, 2353, 2398, 2435, 2464, 2465, 2466, 2467, 2468, 2469, 2470, 2445, 2412, 2371, 2322, 2265, 2200, 2127, 2046, 1957, 1860, 1755, 1642, 1521, 1392, 1255, 1110, 957, 796, 627, 450, 265, 72], [174, 363, 544, 717, 882, 1039, 1188, 1329, 1462, 1587, 1704, 1813, 1914, 2007, 2092, 2169, 2238, 2299, 2352, 2397, 2434, 2463, 2484, 2485, 2486, 2487, 2488, 2471, 2446, 2413, 2372, 2323, 2266, 2201, 2128, 2047, 1958, 1861, 1756, 1643, 1522, 1393, 1256, 1111, 958, 797, 628, 451, 266, 73], [173, 362, 543, 716, 881, 1038, 1187, 1328, 1461, 1586, 1703, 1812, 1913, 2006, 2091, 2168, 2237, 2298, 2351, 2396, 2433, 2462, 2483, 2496, 2497, 2498, 2489, 2472, 2447, 2414, 2373, 2324, 2267, 2202, 2129, 2048, 1959, 1862, 1757, 1644, 1523, 1394, 1257, 1112, 959, 798, 629, 452, 267, 74], [172, 361, 542, 715, 880, 1037, 1186, 1327, 1460, 1585, 1702, 1811, 1912, 2005, 2090, 2167, 2236, 2297, 2350, 2395, 2432, 2461, 2482, 2495, 2500, 2499, 2490, 2473, 2448, 2415, 2374, 2325, 2268, 2203, 2130, 2049, 1960, 1863, 1758, 1645, 1524, 1395, 1258, 1113, 960, 799, 630, 453, 268, 75], [171, 360, 541, 714, 879, 1036, 1185, 1326, 1459, 1584, 1701, 1810, 1911, 2004, 2089, 2166, 2235, 2296, 2349, 2394, 2431, 2460, 2481, 2494, 2493, 2492, 2491, 2474, 2449, 2416, 2375, 2326, 2269, 2204, 2131, 2050, 1961, 1864, 1759, 1646, 1525, 1396, 1259, 1114, 961, 800, 631, 454, 269, 76], [170, 359, 540, 713, 878, 1035, 1184, 1325, 1458, 1583, 1700, 1809, 1910, 2003, 2088, 2165, 2234, 2295, 2348, 2393, 2430, 2459, 2480, 2479, 2478, 2477, 2476, 2475, 2450, 2417, 2376, 2327, 2270, 2205, 2132, 2051, 1962, 1865, 1760, 1647, 1526, 1397, 1260, 1115, 962, 801, 632, 455, 270, 77], [169, 358, 539, 712, 877, 1034, 1183, 1324, 1457, 1582, 1699, 1808, 1909, 2002, 2087, 2164, 2233, 2294, 2347, 2392, 2429, 2458, 2457, 2456, 2455, 2454, 2453, 2452, 2451, 2418, 2377, 2328, 2271, 2206, 2133, 2052, 1963, 1866, 1761, 1648, 1527, 1398, 1261, 1116, 963, 802, 633, 456, 271, 78], [168, 357, 538, 711, 876, 1033, 1182, 1323, 1456, 1581, 1698, 1807, 1908, 2001, 2086, 2163, 2232, 2293, 2346, 2391, 2428, 2427, 2426, 2425, 2424, 2423, 2422, 2421, 2420, 2419, 2378, 2329, 2272, 2207, 2134, 2053, 1964, 1867, 1762, 1649, 1528, 1399, 1262, 1117, 964, 803, 634, 457, 272, 79], [167, 356, 537, 710, 875, 1032, 1181, 1322, 1455, 1580, 1697, 1806, 1907, 2000, 2085, 2162, 2231, 2292, 2345, 2390, 2389, 2388, 2387, 2386, 2385, 2384, 2383, 2382, 2381, 2380, 2379, 2330, 2273, 2208, 2135, 2054, 1965, 1868, 1763, 1650, 1529, 1400, 1263, 1118, 965, 804, 635, 458, 273, 80], [166, 355, 536, 709, 874, 1031, 1180, 1321, 1454, 1579, 1696, 1805, 1906, 1999, 2084, 2161, 2230, 2291, 2344, 2343, 2342, 2341, 2340, 2339, 2338, 2337, 2336, 2335, 2334, 2333, 2332, 2331, 2274, 2209, 2136, 2055, 1966, 1869, 1764, 1651, 1530, 1401, 1264, 1119, 966, 805, 636, 459, 274, 81], [165, 354, 535, 708, 873, 1030, 1179, 1320, 1453, 1578, 1695, 1804, 1905, 1998, 2083, 2160, 2229, 2290, 2289, 2288, 2287, 2286, 2285, 2284, 2283, 2282, 2281, 2280, 2279, 2278, 2277, 2276, 2275, 2210, 2137, 2056, 1967, 1870, 1765, 1652, 1531, 1402, 1265, 1120, 967, 806, 637, 460, 275, 82], [164, 353, 534, 707, 872, 1029, 1178, 1319, 1452, 1577, 1694, 1803, 1904, 1997, 2082, 2159, 2228, 2227, 2226, 2225, 2224, 2223, 2222, 2221, 2220, 2219, 2218, 2217, 2216, 2215, 2214, 2213, 2212, 2211, 2138, 2057, 1968, 1871, 1766, 1653, 1532, 1403, 1266, 1121, 968, 807, 638, 461, 276, 83], [163, 352, 533, 706, 871, 1028, 1177, 1318, 1451, 1576, 1693, 1802, 1903, 1996, 2081, 2158, 2157, 2156, 2155, 2154, 2153, 2152, 2151, 2150, 2149, 2148, 2147, 2146, 2145, 2144, 2143, 2142, 2141, 2140, 2139, 2058, 1969, 1872, 1767, 1654, 1533, 1404, 1267, 1122, 969, 808, 639, 462, 277, 84], [162, 351, 532, 705, 870, 1027, 1176, 1317, 1450, 1575, 1692, 1801, 1902, 1995, 2080, 2079, 2078, 2077, 2076, 2075, 2074, 2073, 2072, 2071, 2070, 2069, 2068, 2067, 2066, 2065, 2064, 2063, 2062, 2061, 2060, 2059, 1970, 1873, 1768, 1655, 1534, 1405, 1268, 1123, 970, 809, 640, 463, 278, 85], [161, 350, 531, 704, 869, 1026, 1175, 1316, 1449, 1574, 1691, 1800, 1901, 1994, 1993, 1992, 1991, 1990, 1989, 1988, 1987, 1986, 1985, 1984, 1983, 1982, 1981, 1980, 1979, 1978, 1977, 1976, 1975, 1974, 1973, 1972, 1971, 1874, 1769, 1656, 1535, 1406, 1269, 1124, 971, 810, 641, 464, 279, 86], [160, 349, 530, 703, 868, 1025, 1174, 1315, 1448, 1573, 1690, 1799, 1900, 1899, 1898, 1897, 1896, 1895, 1894, 1893, 1892, 1891, 1890, 1889, 1888, 1887, 1886, 1885, 1884, 1883, 1882, 1881, 1880, 1879, 1878, 1877, 1876, 1875, 1770, 1657, 1536, 1407, 1270, 1125, 972, 811, 642, 465, 280, 87], [159, 348, 529, 702, 867, 1024, 1173, 1314, 1447, 1572, 1689, 1798, 1797, 1796, 1795, 1794, 1793, 1792, 1791, 1790, 1789, 1788, 1787, 1786, 1785, 1784, 1783, 1782, 1781, 1780, 1779, 1778, 1777, 1776, 1775, 1774, 1773, 1772, 1771, 1658, 1537, 1408, 1271, 1126, 973, 812, 643, 466, 281, 88], [158, 347, 528, 701, 866, 1023, 1172, 1313, 1446, 1571, 1688, 1687, 1686, 1685, 1684, 1683, 1682, 1681, 1680, 1679, 1678, 1677, 1676, 1675, 1674, 1673, 1672, 1671, 1670, 1669, 1668, 1667, 1666, 1665, 1664, 1663, 1662, 1661, 1660, 1659, 1538, 1409, 1272, 1127, 974, 813, 644, 467, 282, 89], [157, 346, 527, 700, 865, 1022, 1171, 1312, 1445, 1570, 1569, 1568, 1567, 1566, 1565, 1564, 1563, 1562, 1561, 1560, 1559, 1558, 1557, 1556, 1555, 1554, 1553, 1552, 1551, 1550, 1549, 1548, 1547, 1546, 1545, 1544, 1543, 1542, 1541, 1540, 1539, 1410, 1273, 1128, 975, 814, 645, 468, 283, 90], [156, 345, 526, 699, 864, 1021, 1170, 1311, 1444, 1443, 1442, 1441, 1440, 1439, 1438, 1437, 1436, 1435, 1434, 1433, 1432, 1431, 1430, 1429, 1428, 1427, 1426, 1425, 1424, 1423, 1422, 1421, 1420, 1419, 1418, 1417, 1416, 1415, 1414, 1413, 1412, 1411, 1274, 1129, 976, 815, 646, 469, 284, 91], [155, 344, 525, 698, 863, 1020, 1169, 1310, 1309, 1308, 1307, 1306, 1305, 1304, 1303, 1302, 1301, 1300, 1299, 1298, 1297, 1296, 1295, 1294, 1293, 1292, 1291, 1290, 1289, 1288, 1287, 1286, 1285, 1284, 1283, 1282, 1281, 1280, 1279, 1278, 1277, 1276, 1275, 1130, 977, 816, 647, 470, 285, 92], [154, 343, 524, 697, 862, 1019, 1168, 1167, 1166, 1165, 1164, 1163, 1162, 1161, 1160, 1159, 1158, 1157, 1156, 1155, 1154, 1153, 1152, 1151, 1150, 1149, 1148, 1147, 1146, 1145, 1144, 1143, 1142, 1141, 1140, 1139, 1138, 1137, 1136, 1135, 1134, 1133, 1132, 1131, 978, 817, 648, 471, 286, 93], [153, 342, 523, 696, 861, 1018, 1017, 1016, 1015, 1014, 1013, 1012, 1011, 1010, 1009, 1008, 1007, 1006, 1005, 1004, 1003, 1002, 1001, 1000, 999, 998, 997, 996, 995, 994, 993, 992, 991, 990, 989, 988, 987, 986, 985, 984, 983, 982, 981, 980, 979, 818, 649, 472, 287, 94], [152, 341, 522, 695, 860, 859, 858, 857, 856, 855, 854, 853, 852, 851, 850, 849, 848, 847, 846, 845, 844, 843, 842, 841, 840, 839, 838, 837, 836, 835, 834, 833, 832, 831, 830, 829, 828, 827, 826, 825, 824, 823, 822, 821, 820, 819, 650, 473, 288, 95], [151, 340, 521, 694, 693, 692, 691, 690, 689, 688, 687, 686, 685, 684, 683, 682, 681, 680, 679, 678, 677, 676, 675, 674, 673, 672, 671, 670, 669, 668, 667, 666, 665, 664, 663, 662, 661, 660, 659, 658, 657, 656, 655, 654, 653, 652, 651, 474, 289, 96], [150, 339, 520, 519, 518, 517, 516, 515, 514, 513, 512, 511, 510, 509, 508, 507, 506, 505, 504, 503, 502, 501, 500, 499, 498, 497, 496, 495, 494, 493, 492, 491, 490, 489, 488, 487, 486, 485, 484, 483, 482, 481, 480, 479, 478, 477, 476, 475, 290, 97], [149, 338, 337, 336, 335, 334, 333, 332, 331, 330, 329, 328, 327, 326, 325, 324, 323, 322, 321, 320, 319, 318, 317, 316, 315, 314, 313, 312, 311, 310, 309, 308, 307, 306, 305, 304, 303, 302, 301, 300, 299, 298, 297, 296, 295, 294, 293, 292, 291, 98], [148, 147, 146, 145, 144, 143, 142, 141, 140, 139, 138, 137, 136, 135, 134, 133, 132, 131, 130, 129, 128, 127, 126, 125, 124, 123, 122, 121, 120, 119, 118, 117, 116, 115, 114, 113, 112, 111, 110, 109, 108, 107, 106, 105, 104, 103, 102, 101, 100, 99]]\n    assert candidate(20) == [[1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20], [76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 21], [75, 144, 145, 146, 147, 148, 149, 150, 151, 152, 153, 154, 155, 156, 157, 158, 159, 160, 95, 22], [74, 143, 204, 205, 206, 207, 208, 209, 210, 211, 212, 213, 214, 215, 216, 217, 218, 161, 96, 23], [73, 142, 203, 256, 257, 258, 259, 260, 261, 262, 263, 264, 265, 266, 267, 268, 219, 162, 97, 24], [72, 141, 202, 255, 300, 301, 302, 303, 304, 305, 306, 307, 308, 309, 310, 269, 220, 163, 98, 25], [71, 140, 201, 254, 299, 336, 337, 338, 339, 340, 341, 342, 343, 344, 311, 270, 221, 164, 99, 26], [70, 139, 200, 253, 298, 335, 364, 365, 366, 367, 368, 369, 370, 345, 312, 271, 222, 165, 100, 27], [69, 138, 199, 252, 297, 334, 363, 384, 385, 386, 387, 388, 371, 346, 313, 272, 223, 166, 101, 28], [68, 137, 198, 251, 296, 333, 362, 383, 396, 397, 398, 389, 372, 347, 314, 273, 224, 167, 102, 29], [67, 136, 197, 250, 295, 332, 361, 382, 395, 400, 399, 390, 373, 348, 315, 274, 225, 168, 103, 30], [66, 135, 196, 249, 294, 331, 360, 381, 394, 393, 392, 391, 374, 349, 316, 275, 226, 169, 104, 31], [65, 134, 195, 248, 293, 330, 359, 380, 379, 378, 377, 376, 375, 350, 317, 276, 227, 170, 105, 32], [64, 133, 194, 247, 292, 329, 358, 357, 356, 355, 354, 353, 352, 351, 318, 277, 228, 171, 106, 33], [63, 132, 193, 246, 291, 328, 327, 326, 325, 324, 323, 322, 321, 320, 319, 278, 229, 172, 107, 34], [62, 131, 192, 245, 290, 289, 288, 287, 286, 285, 284, 283, 282, 281, 280, 279, 230, 173, 108, 35], [61, 130, 191, 244, 243, 242, 241, 240, 239, 238, 237, 236, 235, 234, 233, 232, 231, 174, 109, 36], [60, 129, 190, 189, 188, 187, 186, 185, 184, 183, 182, 181, 180, 179, 178, 177, 176, 175, 110, 37], [59, 128, 127, 126, 125, 124, 123, 122, 121, 120, 119, 118, 117, 116, 115, 114, 113, 112, 111, 38], [58, 57, 56, 55, 54, 53, 52, 51, 50, 49, 48, 47, 46, 45, 44, 43, 42, 41, 40, 39]]\n    assert candidate(0) == []\n    assert candidate(3) == [[1, 2, 3], [8, 9, 4], [7, 6, 5]]\n    assert candidate(4) == [[1, 2, 3, 4], [12, 13, 14, 5], [11, 16, 15, 6], [10, 9, 8, 7]]\n    assert candidate(2) == [[1, 2], [4, 3]]\n", "language": "python"}
{"task_id": "revision1a_problem611", "prompt": "import math\nfrom typing import List, Tuple\n\ndef optimize_delivery_route(locations: List[Tuple[float, float]], start: Tuple[float, float]) -> List[Tuple[float, float]]:\n    \"\"\"\n    A food delivery service wants to optimize their delivery routes to minimize travel time and fuel consumption. \n    They need a function that takes a list of customer locations (as latitude and longitude coordinates) \n    and the starting point of the delivery driver, then returns the most efficient route to visit all locations.\n\n    The function should use the Traveling Salesman Problem (TSP) algorithm with nearest neighbor heuristic \n    to find an approximately optimal solution. The route should start and end at the given starting point.\n\n    Parameters:\n    locations (List[Tuple[float, float]]): List of (latitude, longitude) coordinates for each delivery location\n    start (Tuple[float, float]): The starting point (latitude, longitude) for the delivery driver\n\n    Returns:\n    List[Tuple[float, float]]: The optimized route as a list of (latitude, longitude) coordinates\n\n    Example:\n    Input: \n    locations = [(40.7128, -74.0060), (34.0522, -118.2437), (41.8781, -87.6298), (29.7604, -95.3698)]\n    start = (38.9072, -77.0369)\n    \n    Output: \n    [(38.9072, -77.0369), (40.7128, -74.0060), (41.8781, -87.6298), (29.7604, -95.3698), (34.0522, -118.2437), (38.9072, -77.0369)]\n    \"\"\"\n", "entry_point": "optimize_delivery_route", "solution": "    def calculate_distance(point1: Tuple[float, float], point2: Tuple[float, float]) -> float:\n        \"\"\"Calculate the Euclidean distance between two points.\"\"\"\n        return math.sqrt((point1[0] - point2[0])**2 + (point1[1] - point2[1])**2)\n\n    def find_nearest_neighbor(current: Tuple[float, float], unvisited: List[Tuple[float, float]]) -> Tuple[float, float]:\n        \"\"\"Find the nearest unvisited location.\"\"\"\n        return min(unvisited, key=lambda x: calculate_distance(current, x))\n\n    # Initialize the route with the starting point\n    route = [start]\n    unvisited = locations.copy()\n\n    # Apply the nearest neighbor heuristic\n    while unvisited:\n        current = route[-1]\n        nearest = find_nearest_neighbor(current, unvisited)\n        route.append(nearest)\n        unvisited.remove(nearest)\n\n    # Add the starting point at the end to complete the route\n    route.append(start)\n\n    return route\n", "test": "def check(candidate):\n    assert candidate([(25.2048, 55.2708), (24.4539, 54.3773), (26.2285, 50.5860), (23.6145, 58.5922)], (21.4225, 39.8262)) == [(21.4225, 39.8262), (26.2285, 50.586), (24.4539, 54.3773), (25.2048, 55.2708), (23.6145, 58.5922), (21.4225, 39.8262)]\n    assert candidate([(19.4326, -99.1332), (4.7110, -74.0721), (-34.6037, -58.3816), (-23.5505, -46.6333)], (9.9281, -84.0907)) == [(9.9281, -84.0907), (4.711, -74.0721), (19.4326, -99.1332), (-34.6037, -58.3816), (-23.5505, -46.6333), (9.9281, -84.0907)]\n    assert candidate([(51.5074, -0.1278), (48.8566, 2.3522), (52.5200, 13.4050), (41.9028, 12.4964)], (50.0755, 14.4378)) == [(50.0755, 14.4378), (52.52, 13.405), (41.9028, 12.4964), (48.8566, 2.3522), (51.5074, -0.1278), (50.0755, 14.4378)]\n    assert candidate([(35.6762, 139.6503), (22.3193, 114.1694), (1.3521, 103.8198), (-33.8688, 151.2093)], (37.5665, 126.9780)) == [(37.5665, 126.978), (35.6762, 139.6503), (22.3193, 114.1694), (1.3521, 103.8198), (-33.8688, 151.2093), (37.5665, 126.978)]\n    assert candidate([(40.7128, -74.0060), (34.0522, -118.2437), (41.8781, -87.6298), (29.7604, -95.3698)], (38.9072, -77.0369)) == [(38.9072, -77.0369), (40.7128, -74.006), (41.8781, -87.6298), (29.7604, -95.3698), (34.0522, -118.2437), (38.9072, -77.0369)]\n    assert candidate([(40.7128, -74.0060)], (38.9072, -77.0369)) == [(38.9072, -77.0369), (40.7128, -74.006), (38.9072, -77.0369)]\n    assert candidate([(31.2304, 121.4737), (39.9042, 116.4074), (37.5665, 126.9780), (35.6762, 139.6503)], (22.3193, 114.1694)) == [(22.3193, 114.1694), (31.2304, 121.4737), (37.5665, 126.978), (39.9042, 116.4074), (35.6762, 139.6503), (22.3193, 114.1694)]\n    assert candidate([(43.6532, -79.3832), (45.5017, -73.5673), (49.2827, -123.1207), (51.0486, -114.0708)], (47.6062, -122.3321)) == [(47.6062, -122.3321), (49.2827, -123.1207), (51.0486, -114.0708), (43.6532, -79.3832), (45.5017, -73.5673), (47.6062, -122.3321)]\n    assert candidate([(40.4168, -3.7038), (48.2082, 16.3738), (45.4642, 9.1900), (52.3676, 4.9041)], (48.8566, 2.3522)) == [(48.8566, 2.3522), (52.3676, 4.9041), (45.4642, 9.19), (48.2082, 16.3738), (40.4168, -3.7038), (48.8566, 2.3522)]\n    assert candidate([(55.7558, 37.6173), (59.9139, 10.7522), (60.1699, 24.9384), (55.6761, 12.5683)], (52.5200, 13.4050)) == [(52.52, 13.405), (55.6761, 12.5683), (59.9139, 10.7522), (60.1699, 24.9384), (55.7558, 37.6173), (52.52, 13.405)]\n", "language": "python"}
{"task_id": "revision1a_problem349", "prompt": "from typing import List, Tuple\n\ndef optimize_study_schedule(subjects: List[str], difficulties: List[int], available_time: int) -> List[Tuple[str, int]]:\n    \"\"\"\n    Given a list of subjects, their corresponding difficulties (1-10), and total available study time,\n    create an optimized study schedule. Allocate more time to difficult subjects while ensuring all subjects\n    are covered. Each difficulty point should correspond to 10 minutes of study time.\n    This function could be used in an educational app to help students manage their study time effectively.\n\n    Take lists of subjects and difficulties, and an integer for available time (in minutes) as input.\n    Return a list of tuples, each containing a subject and its allocated study time in minutes.\n\n    Example:\n    Input: \n    subjects = [\"Math\", \"History\", \"Physics\", \"Literature\"]\n    difficulties = [8, 5, 7, 4]\n    available_time = 180\n\n    Output: \n    [(\"Math\", 60), (\"Physics\", 50), (\"History\", 40), (\"Literature\", 30)]\n\n    Input:\n    subjects = [\"Programming\", \"Database\", \"Algorithms\"]\n    difficulties = [6, 7, 9]\n    available_time = 150\n\n    Output:\n    [(\"Algorithms\", 60), (\"Database\", 50), (\"Programming\", 40)]\n    \"\"\"\n", "entry_point": "optimize_study_schedule", "solution": "    # Create a list of tuples with subjects and difficulties\n    subject_difficulty = list(zip(subjects, difficulties))\n    \n    # Sort the list based on difficulty in descending order\n    subject_difficulty.sort(key=lambda x: x[1], reverse=True)\n    \n    # Calculate the total difficulty points\n    total_difficulty = sum(difficulties)\n    \n    # Calculate the time per difficulty point\n    time_per_point = available_time / total_difficulty\n    \n    # Create the optimized schedule\n    schedule = []\n    remaining_time = available_time\n    \n    for subject, difficulty in subject_difficulty:\n        # Calculate the ideal study time for this subject\n        ideal_time = int(difficulty * time_per_point)\n        \n        # Adjust the study time if there's not enough remaining time\n        allocated_time = min(ideal_time, remaining_time)\n        \n        # Add the subject and allocated time to the schedule\n        schedule.append((subject, allocated_time))\n        \n        # Update the remaining time\n        remaining_time -= allocated_time\n        \n        # If there's no more time left, break the loop\n        if remaining_time <= 0:\n            break\n    \n    return schedule\n", "test": "def check(candidate):\n    assert candidate([\"Music\"], [1], 30) == [('Music', 30)]\n    assert candidate([\"Geography\", \"Biology\", \"Chemistry\", \"Economics\", \"Psychology\"], [6, 8, 7, 5, 4], 300) == [('Biology', 80), ('Chemistry', 70), ('Geography', 60), ('Economics', 50), ('Psychology', 40)]\n    assert candidate([\"English\", \"Science\", \"Art\"], [3, 5, 2], 100) == [('Science', 50), ('English', 30), ('Art', 20)]\n    assert candidate([\"Programming\", \"Database\", \"Algorithms\"], [6, 7, 9], 150) == [('Algorithms', 61), ('Database', 47), ('Programming', 40)]\n    assert candidate([\"Math\", \"History\", \"Physics\", \"Literature\"], [8, 5, 7, 4], 180) == [('Math', 60), ('Physics', 52), ('History', 37), ('Literature', 30)]\n    assert candidate([\"Calculus\", \"Statistics\"], [10, 9], 200) == [('Calculus', 105), ('Statistics', 94)]\n    assert candidate([\"French\", \"German\", \"Spanish\", \"Italian\", \"Chinese\"], [5, 6, 4, 7, 8], 250) == [('Chinese', 66), ('Italian', 58), ('German', 50), ('French', 41), ('Spanish', 33)]\n    assert candidate([\"Computer Science\", \"Engineering\", \"Mathematics\", \"Physics\"], [9, 8, 10, 9], 400) == [('Mathematics', 111), ('Computer Science', 100), ('Physics', 100), ('Engineering', 88)]\n    assert candidate([\"History\", \"Geography\", \"Civics\"], [3, 4, 2], 90) == [('Geography', 40), ('History', 30), ('Civics', 20)]\n    assert candidate([\"Cooking\", \"Gardening\", \"Painting\", \"Photography\"], [2, 3, 4, 5], 140) == [('Photography', 50), ('Painting', 40), ('Gardening', 30), ('Cooking', 20)]\n", "language": "python"}
{"task_id": "revision1a_problem668", "prompt": "import heapq\nfrom typing import List, Tuple\n\ndef optimize_delivery_route(packages: List[Tuple[str, int, int]], fuel_capacity: int) -> List[str]:\n    \"\"\"\n    A delivery company wants to optimize their route based on package weights and fuel capacity.\n    \n    Your task is to implement a function that takes a list of packages and the truck's fuel capacity,\n    and returns the optimal order of deliveries to maximize the number of packages delivered before refueling.\n    \n    Each package is represented by a tuple containing (address, weight, priority).\n    Use a priority queue (heap) to solve this problem efficiently.\n    \n    Parameters:\n    packages (List[Tuple[str, int, int]]): List of packages with (address, weight, priority)\n    fuel_capacity (int): The maximum weight the truck can carry before refueling\n    \n    Returns:\n    List[str]: The optimal order of delivery addresses\n    \n    Example:\n    Input: \n    packages = [(\"123 Main St\", 10, 2), (\"456 Elm St\", 5, 1), (\"789 Oak St\", 8, 3)]\n    fuel_capacity = 15\n    \n    Output: \n    [\"456 Elm St\", \"789 Oak St\", \"123 Main St\"]\n    \n    Explanation: The optimal route delivers the package with the highest priority first,\n    while ensuring the total weight doesn't exceed the fuel capacity.\n    \"\"\"\n", "entry_point": "optimize_delivery_route", "solution": "    # Create a priority queue (min-heap) based on priority (negated to make it a max-heap)\n    pq = [(-priority, weight, address) for address, weight, priority in packages]\n    heapq.heapify(pq)\n    \n    optimal_route = []\n    current_weight = 0\n    \n    while pq:\n        _, weight, address = heapq.heappop(pq)\n        \n        if current_weight + weight <= fuel_capacity:\n            optimal_route.append(address)\n            current_weight += weight\n        else:\n            # If the current package doesn't fit, try the next one\n            heapq.heappush(pq, (_, weight, address))\n            \n            # If no more packages can be added, break the loop\n            if not any(w <= fuel_capacity - current_weight for _, w, _ in pq):\n                break\n    \n    return optimal_route\n", "test": "def check(candidate):\n    assert candidate([(\"X\", 10, 1), (\"Y\", 10, 2), (\"Z\", 10, 3)], 20) == ['Z', 'Y']\n    assert candidate([(\"One\", 1, 1)], 1) == ['One']\n    assert candidate([(\"A\", 5, 5), (\"B\", 4, 4), (\"C\", 3, 3), (\"D\", 2, 2), (\"E\", 1, 1)], 15) == ['A', 'B', 'C', 'D', 'E']\n    assert candidate([(\"A\", 1, 10), (\"B\", 2, 9), (\"C\", 3, 8), (\"D\", 4, 7), (\"E\", 5, 6)], 15) == ['A', 'B', 'C', 'D', 'E']\n    assert candidate([(\"Max\", 100, 1), (\"Mid\", 50, 2), (\"Min\", 1, 3)], 100) == ['Min', 'Mid']\n    assert candidate([], 1000) == []\n    assert candidate([(\"Same\", 5, 1), (\"Same\", 5, 1), (\"Same\", 5, 1), (\"Same\", 5, 1)], 20) == ['Same', 'Same', 'Same', 'Same']\n    assert candidate([(\"X\", 100, 1)], 50) == []\n    assert candidate([(\"Heavy\", 1000, 1), (\"Light\", 1, 2)], 1000) == ['Light']\n    assert candidate([(\"P1\", 1, 1), (\"P2\", 1, 2), (\"P3\", 1, 3), (\"P4\", 1, 4), (\"P5\", 1, 5)], 3) == ['P5', 'P4', 'P3']\n", "language": "python"}
{"task_id": "revision1a_problem597", "prompt": "from typing import List, Tuple\n\ndef optimize_schedule(tasks: List[Tuple[int, int, int]], max_time: int) -> int:\n    \"\"\"\n    A project manager needs to optimize a schedule of tasks to maximize productivity within a given time constraint.\n    Each task has a start time, duration, and value (representing its importance or revenue).\n    The function should return the maximum total value that can be achieved without exceeding the time limit.\n\n    Tasks cannot overlap, and once a task is started, it must be completed.\n\n    Parameters:\n    tasks (List[Tuple[int, int, int]]): A list of tuples, each containing (start_time, duration, value) for a task.\n    max_time (int): The maximum available time.\n\n    Returns:\n    int: The maximum total value achievable within the time constraint.\n\n    Example:\n    Input: [(0, 3, 10), (1, 2, 15), (3, 2, 12), (4, 1, 8)], 5\n    Output: 27\n\n    Explanation: The optimal schedule is to do the second task (value 15) and the fourth task (value 8),\n    which gives a total value of 27 within the 5-hour limit.\n    \"\"\"\n", "entry_point": "optimize_schedule", "solution": "    # Sort tasks by end time\n    sorted_tasks = sorted(tasks, key=lambda x: x[0] + x[1])\n    n = len(sorted_tasks)\n    \n    # Initialize dynamic programming array\n    dp = [0] * (n + 1)\n    \n    for i in range(1, n + 1):\n        start, duration, value = sorted_tasks[i-1]\n        end = start + duration\n        \n        if end <= max_time:\n            # Find the latest non-overlapping task\n            j = i - 1\n            while j > 0 and sorted_tasks[j-1][0] + sorted_tasks[j-1][1] > start:\n                j -= 1\n            \n            # Update dp[i] with the maximum value\n            dp[i] = max(dp[i-1], dp[j] + value)\n        else:\n            dp[i] = dp[i-1]\n    \n    return dp[n]\n", "test": "def check(candidate):\n    assert candidate([(0, 1, 10), (1, 1, 20), (2, 1, 30), (3, 1, 40)], 2) == 30\n    assert candidate([(0, 1, 1), (1, 1, 1), (2, 1, 1)], 3) == 3\n    assert candidate([(0, 1, 5), (1, 1, 10), (2, 1, 15), (3, 1, 20)], 4) == 50\n    assert candidate([(0, 10, 100), (5, 5, 50), (10, 1, 10)], 11) == 110\n    assert candidate([], 10) == 0\n    assert candidate([(0, 1, 10), (0, 1, 20), (0, 1, 30)], 1) == 30\n    assert candidate([(0, 5, 100)], 5) == 100\n    assert candidate([(0, 3, 10), (1, 2, 15), (3, 2, 12), (4, 1, 8)], 5) == 27\n    assert candidate([(0, 1, 10)], 0) == 0\n    assert candidate([(0, 5, 50), (1, 4, 40), (2, 3, 30), (3, 2, 20), (4, 1, 10)], 5) == 50\n", "language": "python"}
{"task_id": "revision1a_problem291", "prompt": "import random\nfrom typing import List, Tuple\n\ndef optimize_warehouse_layout(items: List[Tuple[str, int, int]]) -> List[str]:\n    \"\"\"\n    You are tasked with optimizing the layout of a warehouse to improve efficiency.\n    Each item in the warehouse has a name, frequency of access, and weight.\n    Your goal is to arrange the items so that frequently accessed items are closer to the front,\n    but also considering that heavier items should be placed lower for safety reasons.\n\n    Implement a function that takes a list of tuples (item_name, access_frequency, weight)\n    and returns a list of item names in their optimal order for warehouse placement.\n\n    Use a combination of sorting and weighting algorithms to balance these factors.\n    Also, implement a simple simulation to test your layout's efficiency.\n\n    Example:\n    Input: [(\"Box A\", 10, 50), (\"Box B\", 5, 30), (\"Box C\", 8, 40)]\n    Output: [\"Box A\", \"Box C\", \"Box B\"]\n\n    The function should use advanced Python concepts like lambda functions, \n    list comprehensions, and possibly custom sorting keys.\n    \"\"\"\n", "entry_point": "optimize_warehouse_layout", "solution": "    def calculate_score(item):\n        name, frequency, weight = item\n        return frequency / (weight ** 0.5)\n\n    sorted_items = sorted(items, key=calculate_score, reverse=True)\n    optimized_layout = [item[0] for item in sorted_items]\n\n    def simulate_efficiency(layout):\n        total_time = 0\n        for _ in range(1000):  # Simulate 1000 accesses\n            accessed_item = random.choices(items, weights=[item[1] for item in items])[0]\n            access_time = layout.index(accessed_item[0]) + 1  # Time increases with distance\n            total_time += access_time\n        return total_time\n\n    initial_time = simulate_efficiency([item[0] for item in items])\n    optimized_time = simulate_efficiency(optimized_layout)\n\n    efficiency_improvement = (initial_time - optimized_time) / initial_time * 100\n\n    print(f\"Efficiency improvement: {efficiency_improvement:.2f}%\")\n\n    return optimized_layout\n", "test": "def check(candidate):\n    assert candidate([(\"Product\", random.randint(1, 100), random.randint(1, 100)) for _ in range(10)]) == ['Product', 'Product', 'Product', 'Product', 'Product', 'Product', 'Product', 'Product', 'Product', 'Product']\n    assert candidate([(\"Box\", 10, 10)] * 5) == ['Box', 'Box', 'Box', 'Box', 'Box']\n    assert candidate([(\"Item\", i, i) for i in range(1, 11)]) == ['Item', 'Item', 'Item', 'Item', 'Item', 'Item', 'Item', 'Item', 'Item', 'Item']\n", "language": "python"}
{"task_id": "revision1a_problem147", "prompt": "from typing import List\nfrom itertools import permutations\n\ndef optimize_delivery_route(n: int, distances: List[List[int]], max_time: int) -> List[int]:\n    \"\"\"\n    As a delivery route planner for a package delivery company, you need to optimize the delivery route for a driver.\n    The driver needs to deliver packages to n locations, but has a maximum allowed driving time.\n\n    You are given:\n    - The number of locations (n)\n    - A 2D list of distances between locations (including the depot, which is location 0)\n    - The maximum allowed driving time\n\n    Your task is to find the optimal route that:\n    1. Starts and ends at the depot (location 0)\n    2. Visits as many locations as possible\n    3. Does not exceed the maximum allowed driving time\n\n    Return the optimal route as a list of location indices in the order they should be visited.\n    If no route is possible within the time limit, return an empty list.\n\n    Example:\n    Input: 5, [[0,10,15,20,25,30],[10,0,35,25,30,40],[15,35,0,30,35,25],[20,25,30,0,20,25],[25,30,35,20,0,30],[30,40,25,25,30,0]], 100\n    Output: [0, 1, 3, 4, 0]\n\n    Input: 3, [[0,50,75,100],[50,0,80,90],[75,80,0,60],[100,90,60,0]], 200\n    Output: [0, 1, 0]\n\n    Input: 4, [[0,100,150,200,250],[100,0,120,180,210],[150,120,0,100,140],[200,180,100,0,120],[250,210,140,120,0]], 150\n    Output: []\n    \"\"\"\n", "entry_point": "optimize_delivery_route", "solution": "    def dfs(current, visited, time_left, path):\n        nonlocal best_path\n        \n        if len(path) > len(best_path):\n            best_path = path.copy()\n        \n        for next_loc in range(1, n + 1):\n            if next_loc not in visited:\n                time_to_next = distances[current][next_loc]\n                time_back_to_depot = distances[next_loc][0]\n                \n                if time_left >= time_to_next + time_back_to_depot:\n                    visited.add(next_loc)\n                    path.append(next_loc)\n                    dfs(next_loc, visited, time_left - time_to_next, path)\n                    path.pop()\n                    visited.remove(next_loc)\n\n    best_path = []\n    dfs(0, set(), max_time, [0])\n    \n    if len(best_path) > 1:\n        best_path.append(0)  # Return to depot\n        return best_path\n    else:\n        return []  # No feasible route found\n", "test": "def check(candidate):\n    assert candidate(4, [[0,1,1,1,1],[1,0,1,1,1],[1,1,0,1,1],[1,1,1,0,1],[1,1,1,1,0]], 5) == [0, 1, 2, 3, 4, 0]\n    assert candidate(3, [[0,50,75,100],[50,0,80,90],[75,80,0,60],[100,90,60,0]], 200) == [0, 1, 0]\n    assert candidate(4, [[0,100,150,200,250],[100,0,120,180,210],[150,120,0,100,140],[200,180,100,0,120],[250,210,140,120,0]], 150) == []\n    assert candidate(5, [[0,10,20,30,40,50],[10,0,15,25,35,45],[20,15,0,20,30,40],[30,25,20,0,25,35],[40,35,30,25,0,30],[50,45,40,35,30,0]], 1000) == [0, 1, 2, 3, 4, 5, 0]\n    assert candidate(5, [[0,10,15,20,25,30],[10,0,35,25,30,40],[15,35,0,30,35,25],[20,25,30,0,20,25],[25,30,35,20,0,30],[30,40,25,25,30,0]], 100) == [0, 1, 3, 5, 2, 0]\n    assert candidate(3, [[0,100,200,300],[100,0,150,250],[200,150,0,100],[300,250,100,0]], 500) == [0, 1, 2, 0]\n    assert candidate(4, [[0,5,10,15,20],[5,0,8,12,18],[10,8,0,7,15],[15,12,7,0,10],[20,18,15,10,0]], 30) == [0, 1, 2, 0]\n    assert candidate(6, [[0,5,10,15,20,25,30],[5,0,8,12,18,22,28],[10,8,0,7,15,20,25],[15,12,7,0,10,15,20],[20,18,15,10,0,8,12],[25,22,20,15,8,0,7],[30,28,25,20,12,7,0]], 50) == [0, 1, 2, 3, 4, 0]\n    assert candidate(6, [[0,10,20,30,40,50,60],[10,0,15,25,35,45,55],[20,15,0,20,30,40,50],[30,25,20,0,25,35,45],[40,35,30,25,0,30,40],[50,45,40,35,30,0,35],[60,55,50,45,40,35,0]], 200) == [0, 1, 2, 3, 4, 5, 6, 0]\n    assert candidate(3, [[0,1000,2000,3000],[1000,0,1500,2500],[2000,1500,0,1000],[3000,2500,1000,0]], 5000) == [0, 1, 2, 0]\n", "language": "python"}
{"task_id": "revision1a_problem689", "prompt": "import math\nfrom typing import List, Tuple\n\ndef optimize_delivery_route(warehouses: List[Tuple[float, float]], packages: List[Tuple[float, float]]) -> List[int]:\n    \"\"\"\n    A logistics company needs to optimize its delivery routes. They have multiple warehouses and packages to be delivered.\n    Your task is to assign each package to the nearest warehouse to minimize overall travel distance.\n\n    Given the locations of warehouses and packages as (x, y) coordinates, determine the optimal assignment of packages to warehouses.\n    Return a list where the i-th element represents the index of the warehouse assigned to the i-th package.\n\n    Use the Euclidean distance formula to calculate distances between points.\n    Implement an efficient algorithm to solve this assignment problem, such as the Hungarian algorithm or a greedy approach.\n\n    Parameters:\n    warehouses (List[Tuple[float, float]]): List of (x, y) coordinates of warehouse locations\n    packages (List[Tuple[float, float]]): List of (x, y) coordinates of package destinations\n\n    Returns:\n    List[int]: A list where the i-th element is the index of the warehouse assigned to the i-th package\n\n    Example:\n    Input: \n    warehouses = [(0, 0), (5, 5), (10, 10)]\n    packages = [(1, 1), (6, 6), (11, 11), (3, 3), (8, 8)]\n    Output: [0, 1, 2, 0, 1]\n\n    Explanation: \n    Package 0 (1, 1) is closest to warehouse 0 (0, 0)\n    Package 1 (6, 6) is closest to warehouse 1 (5, 5)\n    Package 2 (11, 11) is closest to warehouse 2 (10, 10)\n    Package 3 (3, 3) is closest to warehouse 0 (0, 0)\n    Package 4 (8, 8) is closest to warehouse 1 (5, 5)\n    \"\"\"\n", "entry_point": "optimize_delivery_route", "solution": "    def euclidean_distance(point1: Tuple[float, float], point2: Tuple[float, float]) -> float:\n        return math.sqrt((point1[0] - point2[0])**2 + (point1[1] - point2[1])**2)\n\n    assignments = []\n\n    for package in packages:\n        min_distance = float('inf')\n        nearest_warehouse = -1\n\n        for i, warehouse in enumerate(warehouses):\n            distance = euclidean_distance(package, warehouse)\n            if distance < min_distance:\n                min_distance = distance\n                nearest_warehouse = i\n\n        assignments.append(nearest_warehouse)\n\n    return assignments\n", "test": "def check(candidate):\n    assert candidate([(0, 0), (1, 1)], [(0.5, 0.5)]) == [0]\n    assert candidate([(0, 0)], []) == []\n    assert candidate([(0, 0), (100, 100)], [(50, 50), (51, 49), (49, 51)]) == [0, 0, 0]\n    assert candidate([(0, 0), (10, 0)], [(5, 0), (5, 5), (0, 5), (10, 5)]) == [0, 0, 0, 1]\n    assert candidate([(0, 0), (0, 10), (10, 0), (10, 10)], [(5, 5)]) == [0]\n    assert candidate([(0, 0), (1, 0), (0, 1), (1, 1)], [(0.5, 0.5), (0.4, 0.6), (0.6, 0.4)]) == [0, 2, 1]\n    assert candidate([(-1, -1), (1, 1)], [(0, 0), (2, 2), (-2, -2)]) == [0, 1, 0]\n    assert candidate([(0, 0), (5, 5), (10, 10)], [(1, 1), (6, 6), (11, 11), (3, 3), (8, 8)]) == [0, 1, 2, 1, 2]\n    assert candidate([(0, 0)], [(1, 1), (2, 2), (3, 3)]) == [0, 0, 0]\n    assert candidate([(0, 0)], [(0, 0)]) == [0]\n", "language": "python"}
{"task_id": "revision1a_problem222", "prompt": "from typing import List, Tuple\n\ndef knapsack_solver(items: List[Tuple[str, int, int]], capacity: int) -> Tuple[List[str], int]:\n    \"\"\"\n    As a logistics manager for a space exploration mission, you need to optimize the \n    payload for a spacecraft. You have a list of items, each with a name, weight, and \n    value. Your task is to select items that maximize the total value while staying \n    within the weight capacity of the spacecraft.\n\n    Implement the 0/1 knapsack algorithm to solve this problem. The function should \n    take a list of items (each represented as a tuple of name, weight, and value) \n    and the weight capacity of the spacecraft. It should return a tuple containing \n    the list of selected item names and the total value.\n\n    Example:\n    Input: \n    items = [(\"Oxygen tank\", 4, 15), (\"Water purifier\", 3, 10), (\"Solar panel\", 2, 7),\n             (\"Communication device\", 1, 5), (\"Food rations\", 5, 18)]\n    capacity = 10\n\n    Output: ([\"Oxygen tank\", \"Water purifier\", \"Solar panel\"], 32)\n    \"\"\"\n", "entry_point": "knapsack_solver", "solution": "    n = len(items)\n    \n    # Create a 2D table to store the maximum values for different capacities and items\n    dp = [[0 for _ in range(capacity + 1)] for _ in range(n + 1)]\n    \n    # Fill the dp table\n    for i in range(1, n + 1):\n        for w in range(capacity + 1):\n            if items[i-1][1] <= w:\n                dp[i][w] = max(dp[i-1][w], dp[i-1][w-items[i-1][1]] + items[i-1][2])\n            else:\n                dp[i][w] = dp[i-1][w]\n    \n    # Backtrack to find the selected items\n    selected_items = []\n    w = capacity\n    for i in range(n, 0, -1):\n        if dp[i][w] != dp[i-1][w]:\n            selected_items.append(items[i-1][0])\n            w -= items[i-1][1]\n    \n    selected_items.reverse()\n    total_value = dp[n][capacity]\n    \n    return (selected_items, total_value)\n", "test": "def check(candidate):\n    assert candidate([(\"Item1\", 1, 1), (\"Item2\", 1, 2), (\"Item3\", 1, 3)], 2) == (['Item2', 'Item3'], 5)\n    assert candidate([(\"Tool1\", 5, 10), (\"Tool2\", 4, 40), (\"Tool3\", 6, 30), (\"Tool4\", 3, 50)], 10) == (['Tool2', 'Tool4'], 90)\n    assert candidate([(\"Oxygen tank\", 4, 15), (\"Water purifier\", 3, 10), (\"Solar panel\", 2, 7), (\"Communication device\", 1, 5), (\"Food rations\", 5, 18)], 10) == (['Oxygen tank', 'Communication device', 'Food rations'], 38)\n    assert candidate([(\"Feather\", 0, 1)], 1) == (['Feather'], 1)\n    assert candidate([(\"Book\", 1, 3), (\"Laptop\", 3, 10), (\"Camera\", 2, 7)], 5) == (['Laptop', 'Camera'], 17)\n    assert candidate([(\"Heavy item\", 10, 100)], 5) == ([], 0)\n    assert candidate([(\"Gold\", 5, 100), (\"Silver\", 3, 50), (\"Bronze\", 1, 10)], 8) == (['Gold', 'Silver'], 150)\n    assert candidate([(\"A\", 1, 1), (\"B\", 2, 2), (\"C\", 3, 3)], 3) == (['A', 'B'], 3)\n    assert candidate([(\"Rock\", 1, 0)], 1) == ([], 0)\n    assert candidate([(\"Light item\", 1, 1000)], 1) == (['Light item'], 1000)\n", "language": "python"}
{"task_id": "revision1a_problem89", "prompt": "from typing import List\nimport math\n\ndef optimize_delivery_route(n: int, m: int, warehouses: List[List[int]], orders: List[List[int]]) -> List[int]:\n    \"\"\"\n    As a logistics manager, you need to optimize the delivery route for a fleet of drones.\n    There are n warehouses and m customer orders. Your task is to find the most efficient route\n    that minimizes the total distance traveled by the drones.\n\n    Take input for n (number of warehouses), m (number of orders), \n    n lines of input for warehouse coordinates (x, y), \n    and m lines of input for order coordinates (x, y).\n\n    Return a list of integers representing the optimal order of visits (warehouse and order indices)\n    that minimizes the total distance traveled.\n\n    Assume each warehouse and order location starts with index 0.\n\n    Example:\n    Input: 3, 4, [[0,0], [5,5], [10,10]], [[2,2], [4,4], [7,7], [9,9]]\n    Output: [0, 0, 1, 1, 2, 2, 3]\n    \"\"\"\n", "entry_point": "optimize_delivery_route", "solution": "    def distance(point1, point2):\n        return math.sqrt((point1[0] - point2[0])**2 + (point1[1] - point2[1])**2)\n\n    def nearest_neighbor(start, points):\n        unvisited = set(range(len(points)))\n        path = []\n        current = start\n\n        while unvisited:\n            nearest = min(unvisited, key=lambda x: distance(points[current], points[x]))\n            path.append(nearest)\n            unvisited.remove(nearest)\n            current = nearest\n\n        return path\n\n    # Combine warehouses and orders into a single list of points\n    all_points = warehouses + orders\n\n    # Start from the first warehouse (index 0)\n    optimal_route = [0]\n\n    # Find the nearest neighbor path starting from the first warehouse\n    path = nearest_neighbor(0, all_points)\n\n    # Convert the path indices to warehouse and order indices\n    for idx in path:\n        if idx < n:\n            # It's a warehouse\n            optimal_route.append(idx)\n        else:\n            # It's an order, adjust the index\n            optimal_route.append(idx - n)\n\n    return optimal_route\n", "test": "def check(candidate):\n    assert candidate(2, 2, [[0,0], [10,10]], [[5,5], [15,15]]) == [0, 0, 0, 1, 1]\n    assert candidate(4, 3, [[0,0], [3,3], [6,6], [9,9]], [[1,1], [5,5], [8,8]]) == [0, 0, 0, 1, 1, 2, 2, 3]\n    assert candidate(1, 10, [[0,0]], [[i,i] for i in range(1, 11)]) == [0, 0, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9]\n    assert candidate(3, 3, [[0,0], [5,5], [10,10]], [[2,2], [7,7], [12,12]]) == [0, 0, 0, 1, 1, 2, 2]\n    assert candidate(2, 5, [[0,0], [10,10]], [[2,2], [4,4], [6,6], [8,8], [10,10]]) == [0, 0, 0, 1, 2, 3, 1, 4]\n    assert candidate(10, 1, [[i,i] for i in range(10)], [[5,5]]) == [0, 0, 1, 2, 3, 4, 5, 0, 6, 7, 8, 9]\n    assert candidate(1, 1, [[0,0]], [[1,1]]) == [0, 0, 0]\n    assert candidate(3, 4, [[0,0], [5,5], [10,10]], [[2,2], [4,4], [7,7], [9,9]]) == [0, 0, 0, 1, 1, 2, 3, 2]\n    assert candidate(5, 2, [[0,0], [2,2], [4,4], [6,6], [8,8]], [[3,3], [7,7]]) == [0, 0, 1, 0, 2, 3, 1, 4]\n    assert candidate(5, 5, [[0,0], [2,2], [4,4], [6,6], [8,8]], [[1,1], [3,3], [5,5], [7,7], [9,9]]) == [0, 0, 0, 1, 1, 2, 2, 3, 3, 4, 4]\n", "language": "python"}
{"task_id": "revision1a_problem294", "prompt": "from typing import List, Tuple, Dict\nimport math\n\ndef optimize_delivery_route(locations: List[Tuple[float, float]], packages: Dict[int, int]) -> List[int]:\n    \"\"\"\n    You are a delivery driver for an e-commerce company. Your task is to optimize the delivery route to minimize fuel consumption.\n\n    You are given a list of locations (as latitude and longitude coordinates) and a dictionary of package weights for each location.\n    Create a class 'DeliveryOptimizer' that calculates the most fuel-efficient route.\n    Implement methods for distance calculation, fuel consumption estimation, and route optimization.\n    Consider factors such as distance between locations, package weights, and vehicle fuel efficiency.\n    Return the optimized route as a list of location indices.\n\n    Example:\n    Input: \n    locations = [(40.7128, -74.0060), (34.0522, -118.2437), (41.8781, -87.6298), (29.7604, -95.3698)]\n    packages = {0: 5, 1: 10, 2: 7, 3: 3}\n    Output: [0, 3, 2, 1]  # This represents the optimized order of visiting locations\n    \"\"\"\n", "entry_point": "optimize_delivery_route", "solution": "\n    class DeliveryOptimizer:\n        def __init__(self, locations, packages):\n            self.locations = locations\n            self.packages = packages\n            self.num_locations = len(locations)\n            self.distance_matrix = self._calculate_distance_matrix()\n\n        def _calculate_distance_matrix(self):\n            matrix = [[0] * self.num_locations for _ in range(self.num_locations)]\n            for i in range(self.num_locations):\n                for j in range(i + 1, self.num_locations):\n                    distance = self._haversine_distance(self.locations[i], self.locations[j])\n                    matrix[i][j] = matrix[j][i] = distance\n            return matrix\n\n        def _haversine_distance(self, loc1, loc2):\n            lat1, lon1 = map(math.radians, loc1)\n            lat2, lon2 = map(math.radians, loc2)\n            dlat, dlon = lat2 - lat1, lon2 - lon1\n            a = math.sin(dlat/2)**2 + math.cos(lat1) * math.cos(lat2) * math.sin(dlon/2)**2\n            c = 2 * math.asin(math.sqrt(a))\n            return 6371 * c  # Earth's radius in km\n\n        def _estimate_fuel_consumption(self, route):\n            total_distance = sum(self.distance_matrix[route[i]][route[i+1]] for i in range(len(route)-1))\n            total_weight = sum(self.packages[i] for i in route)\n            # Simplified fuel consumption model: distance * (1 + 0.1 * total_weight)\n            return total_distance * (1 + 0.1 * total_weight)\n\n        def optimize_route(self):\n            best_route = list(range(self.num_locations))\n            best_fuel = self._estimate_fuel_consumption(best_route)\n\n            for _ in range(1000):  # Number of iterations for optimization\n                new_route = best_route.copy()\n                i, j = random.sample(range(1, self.num_locations), 2)\n                new_route[i], new_route[j] = new_route[j], new_route[i]\n                new_fuel = self._estimate_fuel_consumption(new_route)\n\n                if new_fuel < best_fuel:\n                    best_route, best_fuel = new_route, new_fuel\n\n            return best_route\n\n    import random\n    random.seed(42)  # For reproducibility\n    optimizer = DeliveryOptimizer(locations, packages)\n    return optimizer.optimize_route()\n", "test": "def check(candidate):\n    assert candidate([(0, 0), (1, 1), (2, 2), (3, 3)], {0: 1, 1: 2, 2: 3, 3: 4}) == [0, 1, 2, 3]\n    assert candidate([(51.5074, -0.1278), (48.8566, 2.3522), (52.5200, 13.4050)], {0: 2, 1: 5, 2: 3}) == [0, 1, 2]\n    assert candidate([(40.7128, -74.0060), (34.0522, -118.2437), (41.8781, -87.6298), (29.7604, -95.3698)], {0: 5, 1: 10, 2: 7, 3: 3}) == [0, 2, 3, 1]\n    assert candidate([(35.6762, 139.6503), (22.3193, 114.1694), (1.3521, 103.8198)], {0: 8, 1: 6, 2: 4}) == [0, 1, 2]\n", "language": "python"}
{"task_id": "revision1a_problem716", "prompt": "import re\nfrom typing import List\n\ndef parse_log_file(log_file: str) -> List[dict]:\n    \"\"\"\n    A system administrator needs to analyze server logs to identify potential security threats.\n    \n    Implement a function that parses a log file and extracts relevant information about each event.\n    The function should use regular expressions to extract the timestamp, IP address, and event type\n    from each log entry.\n    \n    Parameters:\n    log_file (str): Path to the log file\n    \n    Returns:\n    List[dict]: A list of dictionaries, where each dictionary contains the extracted information\n    for a single log entry\n    \n    Example log entry format:\n    [2023-04-15 14:23:17] 192.168.1.100 - Failed login attempt\n    \n    Example:\n    Input: \"server.log\"\n    Output: [\n        {\"timestamp\": \"2023-04-15 14:23:17\", \"ip\": \"192.168.1.100\", \"event\": \"Failed login attempt\"},\n        {\"timestamp\": \"2023-04-15 14:25:32\", \"ip\": \"192.168.1.101\", \"event\": \"Successful login\"},\n        ...\n    ]\n    \n    Note: Make sure to handle potential errors in the log file format and skip invalid entries.\n    \"\"\"\n", "entry_point": "parse_log_file", "solution": "    log_entries = []\n    log_pattern = r'\\[([\\d-]+ [\\d:]+)\\] ([\\d.]+) - (.+)'\n\n    try:\n        with open(log_file, 'r') as file:\n            for line in file:\n                match = re.match(log_pattern, line.strip())\n                if match:\n                    timestamp, ip, event = match.groups()\n                    log_entries.append({\n                        \"timestamp\": timestamp,\n                        \"ip\": ip,\n                        \"event\": event\n                    })\n                else:\n                    print(f\"Skipping invalid log entry: {line.strip()}\")\n    except FileNotFoundError:\n        print(f\"Error: The log file '{log_file}' was not found.\")\n    except IOError:\n        print(f\"Error: Unable to read the log file '{log_file}'.\")\n    except Exception as e:\n        print(f\"An unexpected error occurred: {str(e)}\")\n\n    return log_entries\n", "test": "def check(candidate):\n    assert candidate(\"invalid_format.log\") == []\n    assert candidate(\"special_characters.log\") == []\n    assert candidate(\"ipv6_addresses.log\") == []\n    assert candidate(\"multiple_events.log\") == []\n    assert candidate(\"server.log\") == []\n    assert candidate(\"/path/to/nonexistent/file.log\") == []\n    assert candidate(\"single_entry.log\") == []\n    assert candidate(\"empty.log\") == []\n    assert candidate(\"long_event_description.log\") == []\n    assert candidate(\"mixed_valid_invalid.log\") == []\n", "language": "python"}
{"task_id": "revision1a_problem496", "prompt": "from typing import List, Dict\n\ndef simulate_ecosystem(initial_population: Dict[str, int], years: int, interaction_matrix: Dict[str, Dict[str, float]]) -> Dict[str, List[int]]:\n    \"\"\"\n    You are an ecologist studying the dynamics of a complex ecosystem. Your task is to create a simulation\n    that predicts population changes over time based on species interactions.\n\n    Implement a function that simulates the ecosystem for a given number of years and returns the population\n    trends for each species. The simulation should account for:\n    1. Predator-prey relationships\n    2. Competition for resources\n    3. Reproduction rates\n    4. Carrying capacity of the environment\n\n    Take as input:\n    - initial_population: A dictionary of species names and their starting populations\n    - years: The number of years to simulate\n    - interaction_matrix: A nested dictionary representing the effect of each species on others\n\n    Return a dictionary with species names as keys and lists of population counts for each year as values.\n\n    Example:\n    Input: \n    initial_population = {\"Rabbits\": 1000, \"Foxes\": 100, \"Grass\": 5000}\n    years = 5\n    interaction_matrix = {\n        \"Rabbits\": {\"Rabbits\": -0.01, \"Foxes\": -0.05, \"Grass\": 0.1},\n        \"Foxes\": {\"Rabbits\": 0.01, \"Foxes\": -0.02, \"Grass\": 0},\n        \"Grass\": {\"Rabbits\": -0.05, \"Foxes\": 0, \"Grass\": 0.2}\n    }\n    Output: \n    {\n        \"Rabbits\": [1000, 1150, 1322, 1520, 1748],\n        \"Foxes\": [100, 110, 121, 133, 146],\n        \"Grass\": [5000, 5500, 6050, 6655, 7320]\n    }\n    \"\"\"\n", "entry_point": "simulate_ecosystem", "solution": "    population_trends = {species: [count] for species, count in initial_population.items()}\n    \n    for _ in range(years - 1):  # We already have the initial population, so we simulate for years - 1\n        current_population = {species: population_trends[species][-1] for species in initial_population}\n        new_population = {}\n        \n        for species in current_population:\n            change = 0\n            for interacting_species in interaction_matrix[species]:\n                change += (\n                    interaction_matrix[species][interacting_species] *\n                    current_population[interacting_species]\n                )\n            \n            # Apply the change and ensure the population doesn't go negative\n            new_count = max(0, int(current_population[species] * (1 + change)))\n            \n            # Apply a simple carrying capacity limit (e.g., 10 times the initial population)\n            carrying_capacity = initial_population[species] * 10\n            new_count = min(new_count, carrying_capacity)\n            \n            new_population[species] = new_count\n        \n        for species in new_population:\n            population_trends[species].append(new_population[species])\n    \n    return population_trends\n", "test": "def check(candidate):\n    assert candidate({\"Bacteria\": 1000000, \"Antibiotics\": 1000}, 5, {\"Bacteria\": {\"Bacteria\": 0.5, \"Antibiotics\": -0.8}, \"Antibiotics\": {\"Bacteria\": -0.3, \"Antibiotics\": -0.1}}) == {'Bacteria': [1000000, 10000000, 10000000, 10000000, 10000000], 'Antibiotics': [1000, 0, 0, 0, 0]}\n    assert candidate({\"Lions\": 50, \"Zebras\": 1000, \"Grass\": 10000}, 10, {\"Lions\": {\"Lions\": -0.02, \"Zebras\": 0.02, \"Grass\": 0}, \"Zebras\": {\"Lions\": -0.05, \"Zebras\": -0.01, \"Grass\": 0.1}, \"Grass\": {\"Lions\": 0, \"Zebras\": -0.1, \"Grass\": 0.15}}) == {'Lions': [50, 500, 500, 500, 500, 500, 500, 500, 500, 500], 'Zebras': [1000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000], 'Grass': [10000, 100000, 100000, 100000, 100000, 100000, 100000, 100000, 100000, 100000]}\n    assert candidate({\"Pandas\": 100, \"Bamboo\": 50000}, 20, {\"Pandas\": {\"Pandas\": -0.01, \"Bamboo\": 0.02}, \"Bamboo\": {\"Pandas\": -0.05, \"Bamboo\": 0.1}}) == {'Pandas': [100, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], 'Bamboo': [50000, 500000, 500000, 500000, 500000, 500000, 500000, 500000, 500000, 500000, 500000, 500000, 500000, 500000, 500000, 500000, 500000, 500000, 500000, 500000]}\n    assert candidate({\"Bees\": 10000, \"Flowers\": 50000}, 3, {\"Bees\": {\"Bees\": -0.01, \"Flowers\": 0.1}, \"Flowers\": {\"Bees\": 0.05, \"Flowers\": 0.02}}) == {'Bees': [10000, 100000, 100000], 'Flowers': [50000, 500000, 500000]}\n    assert candidate({\"Rabbits\": 1000, \"Foxes\": 100, \"Grass\": 5000}, 5, {\"Rabbits\": {\"Rabbits\": -0.01, \"Foxes\": -0.05, \"Grass\": 0.1}, \"Foxes\": {\"Rabbits\": 0.01, \"Foxes\": -0.02, \"Grass\": 0}, \"Grass\": {\"Rabbits\": -0.05, \"Foxes\": 0, \"Grass\": 0.2}}) == {'Rabbits': [1000, 10000, 10000, 10000, 10000], 'Foxes': [100, 900, 1000, 1000, 1000], 'Grass': [5000, 50000, 50000, 50000, 50000]}\n    assert candidate({\"Hawks\": 100, \"Snakes\": 500, \"Mice\": 10000}, 8, {\"Hawks\": {\"Hawks\": -0.02, \"Snakes\": 0.01, \"Mice\": 0.05}, \"Snakes\": {\"Hawks\": -0.03, \"Snakes\": -0.01, \"Mice\": 0.03}, \"Mice\": {\"Hawks\": -0.1, \"Snakes\": -0.05, \"Mice\": 0.2}}) == {'Hawks': [100, 1000, 1000, 1000, 1000, 1000, 1000, 1000], 'Snakes': [500, 5000, 5000, 5000, 5000, 5000, 5000, 5000], 'Mice': [10000, 100000, 100000, 100000, 100000, 100000, 100000, 100000]}\n    assert candidate({\"Algae\": 100000, \"Fish\": 5000}, 6, {\"Algae\": {\"Algae\": 0.3, \"Fish\": -0.1}, \"Fish\": {\"Algae\": 0.05, \"Fish\": -0.02}}) == {'Algae': [100000, 1000000, 1000000, 1000000, 1000000, 1000000], 'Fish': [5000, 50000, 50000, 50000, 50000, 50000]}\n    assert candidate({\"Fish\": 5000, \"Sharks\": 200, \"Plankton\": 50000}, 7, {\"Fish\": {\"Fish\": -0.01, \"Sharks\": -0.03, \"Plankton\": 0.05}, \"Sharks\": {\"Fish\": 0.02, \"Sharks\": -0.01, \"Plankton\": 0}, \"Plankton\": {\"Fish\": -0.02, \"Sharks\": 0, \"Plankton\": 0.1}}) == {'Fish': [5000, 50000, 50000, 50000, 50000, 50000, 50000], 'Sharks': [200, 2000, 2000, 2000, 2000, 2000, 2000], 'Plankton': [50000, 500000, 500000, 500000, 500000, 500000, 500000]}\n    assert candidate({\"Deer\": 500, \"Wolves\": 50, \"Trees\": 10000}, 15, {\"Deer\": {\"Deer\": -0.02, \"Wolves\": -0.05, \"Trees\": 0.03}, \"Wolves\": {\"Deer\": 0.03, \"Wolves\": -0.01, \"Trees\": 0}, \"Trees\": {\"Deer\": -0.01, \"Wolves\": 0, \"Trees\": 0.05}}) == {'Deer': [500, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000], 'Wolves': [50, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500], 'Trees': [10000, 100000, 100000, 100000, 100000, 100000, 100000, 100000, 100000, 100000, 100000, 100000, 100000, 100000, 100000]}\n", "language": "python"}
{"task_id": "revision1a_problem499", "prompt": "from typing import List\n\ndef optimize_study_schedule(subjects: List[str], hours: List[int], priorities: List[int]) -> List[str]:\n    \"\"\"\n    You are a student preparing for final exams and want to optimize your study schedule.\n    Given a list of subjects, the number of hours required to study each subject, and their priorities,\n    create a function that returns the optimal order of subjects to study.\n\n    The function should take three inputs:\n    1. A list of subject names\n    2. A list of hours required for each subject\n    3. A list of priorities for each subject (1-5, with 5 being highest priority)\n\n    The function should return a list of subjects in the optimal study order, \n    considering both the time required and the priority of each subject.\n\n    Example:\n    Input: \n    subjects = [\"Math\", \"History\", \"Physics\", \"Literature\"]\n    hours = [4, 2, 3, 2]\n    priorities = [5, 2, 4, 3]\n    \n    Output: [\"Math\", \"Physics\", \"Literature\", \"History\"]\n\n    Example:\n    Input:\n    subjects = [\"Biology\", \"Chemistry\", \"Economics\", \"Computer Science\"]\n    hours = [3, 4, 2, 5]\n    priorities = [3, 4, 2, 5]\n\n    Output: [\"Computer Science\", \"Chemistry\", \"Biology\", \"Economics\"]\n    \"\"\"\n", "entry_point": "optimize_study_schedule", "solution": "    # Combine subjects, hours, and priorities into a list of tuples\n    study_items = list(zip(subjects, hours, priorities))\n    \n    # Define a custom sorting key function\n    def sort_key(item):\n        subject, hours, priority = item\n        # Use negative priority to sort in descending order\n        # Use hours as a secondary sorting criterion\n        return (-priority, hours)\n    \n    # Sort the study items based on the custom key\n    sorted_items = sorted(study_items, key=sort_key)\n    \n    # Extract and return only the subject names in the optimal order\n    return [item[0] for item in sorted_items]\n", "test": "def check(candidate):\n    assert candidate([\"Algebra\", \"Geometry\", \"Calculus\"], [3, 2, 4], [4, 3, 5]) == ['Calculus', 'Algebra', 'Geometry']\n    assert candidate([\"Physics\", \"Chemistry\", \"Biology\", \"Math\"], [5, 5, 5, 5], [5, 5, 5, 5]) == ['Physics', 'Chemistry', 'Biology', 'Math']\n    assert candidate([\"Psychology\", \"Sociology\", \"Anthropology\"], [4, 3, 3], [5, 4, 3]) == ['Psychology', 'Sociology', 'Anthropology']\n    assert candidate([\"History\", \"Geography\", \"Civics\"], [3, 2, 1], [1, 2, 3]) == ['Civics', 'Geography', 'History']\n    assert candidate([\"English\", \"French\", \"Spanish\", \"German\", \"Chinese\"], [2, 3, 2, 4, 5], [3, 2, 4, 1, 5]) == ['Chinese', 'Spanish', 'English', 'French', 'German']\n    assert candidate([\"Art\", \"Music\", \"Dance\", \"Drama\"], [1, 2, 2, 1], [1, 3, 2, 1]) == ['Music', 'Dance', 'Art', 'Drama']\n    assert candidate([\"Math\", \"History\", \"Physics\", \"Literature\"], [4, 2, 3, 2], [5, 2, 4, 3]) == ['Math', 'Physics', 'Literature', 'History']\n    assert candidate([\"Biology\", \"Chemistry\", \"Economics\", \"Computer Science\"], [3, 4, 2, 5], [3, 4, 2, 5]) == ['Computer Science', 'Chemistry', 'Biology', 'Economics']\n    assert candidate([\"Java\", \"Python\", \"C++\", \"JavaScript\", \"Ruby\"], [5, 4, 6, 3, 2], [4, 5, 3, 2, 1]) == ['Python', 'Java', 'C++', 'JavaScript', 'Ruby']\n    assert candidate([\"Economics\", \"Business\", \"Accounting\"], [4, 3, 5], [3, 4, 5]) == ['Accounting', 'Business', 'Economics']\n", "language": "python"}
{"task_id": "revision1a_problem721", "prompt": "import heapq\nfrom typing import List, Tuple\n\ndef design_network(n: int, connections: List[Tuple[int, int]], bandwidth: List[int]) -> List[Tuple[int, int, int]]:\n    \"\"\"\n    As a network engineer, you're tasked with designing an efficient computer network for a large office building.\n    The building has n floors (numbered from 0 to n-1), and you need to connect all floors while maximizing bandwidth.\n\n    You're given a list of possible connections between floors and their respective installation costs.\n    You also have a list of required bandwidth for each floor.\n\n    Your task is to design a network that connects all floors with the minimum total installation cost,\n    while ensuring that each floor has access to its required bandwidth.\n\n    Take input from the user for:\n    - The number of floors (n)\n    - A list of possible connections, where each connection is a tuple (a, b, cost) representing a connection between floor a and b with installation cost\n    - A list of bandwidth requirements for each floor\n\n    Return a list of tuples (a, b, bandwidth) representing the connections in your final network design,\n    where 'a' and 'b' are floor numbers, and 'bandwidth' is the bandwidth allocated to that connection.\n\n    If no valid network design is possible, return an empty list.\n\n    Example:\n    Input: \n    n = 4\n    connections = [(0,1,10), (0,2,6), (0,3,5), (1,3,15), (2,3,4)]\n    bandwidth = [100, 200, 150, 300]\n    Output: [(0,1,200), (0,2,150), (0,3,300)]\n\n    Input:\n    n = 3\n    connections = [(0,1,10), (1,2,5)]\n    bandwidth = [100, 200, 300]\n    Output: []\n    \"\"\"\n", "entry_point": "design_network", "solution": "    \n    def find(parent, i):\n        if parent[i] == i:\n            return i\n        return find(parent, parent[i])\n\n    def union(parent, rank, x, y):\n        xroot = find(parent, x)\n        yroot = find(parent, y)\n        if rank[xroot] < rank[yroot]:\n            parent[xroot] = yroot\n        elif rank[xroot] > rank[yroot]:\n            parent[yroot] = xroot\n        else:\n            parent[yroot] = xroot\n            rank[xroot] += 1\n\n    # Sort connections by cost\n    connections.sort(key=lambda x: x[2])\n\n    parent = list(range(n))\n    rank = [0] * n\n    result = []\n    \n    for a, b, cost in connections:\n        x = find(parent, a)\n        y = find(parent, b)\n        if x != y:\n            result.append((a, b))\n            union(parent, rank, x, y)\n\n    if len(result) != n - 1:\n        return []  # Not all floors are connected\n\n    # Assign bandwidth to connections\n    network_design = []\n    for a, b in result:\n        max_bandwidth = max(bandwidth[a], bandwidth[b])\n        network_design.append((a, b, max_bandwidth))\n\n    return network_design\n\n", "test": "def check(candidate):\n    assert candidate(6, [(0,1,1), (1,2,1), (2,3,1), (3,4,1), (4,5,1), (5,0,1)], [10, 10, 10, 10, 10, 10]) == [(0, 1, 10), (1, 2, 10), (2, 3, 10), (3, 4, 10), (4, 5, 10)]\n    assert candidate(5, [(0,1,1), (1,2,2), (2,3,3), (3,4,4), (4,0,5)], [10, 20, 30, 40, 50]) == [(0, 1, 20), (1, 2, 30), (2, 3, 40), (3, 4, 50)]\n    assert candidate(2, [(0,1,100)], [50, 50]) == [(0, 1, 50)]\n    assert candidate(3, [(0,1,10), (1,2,5)], [100, 200, 300]) == [(1, 2, 300), (0, 1, 200)]\n    assert candidate(3, [(0,1,1), (1,2,1)], [1000, 1000, 1000]) == [(0, 1, 1000), (1, 2, 1000)]\n    assert candidate(3, [(0,1,10), (1,2,20), (0,2,15)], [50, 100, 75]) == [(0, 1, 100), (0, 2, 75)]\n    assert candidate(4, [(0,1,10), (0,2,6), (0,3,5), (1,3,15), (2,3,4)], [100, 200, 150, 300]) == [(2, 3, 300), (0, 3, 300), (0, 1, 200)]\n    assert candidate(5, [(0,1,5), (1,2,5), (2,3,5), (3,4,5)], [10, 20, 30, 40, 50]) == [(0, 1, 20), (1, 2, 30), (2, 3, 40), (3, 4, 50)]\n    assert candidate(4, [(0,1,10), (1,2,20), (2,3,30), (3,0,40)], [25, 50, 75, 100]) == [(0, 1, 50), (1, 2, 75), (2, 3, 100)]\n    assert candidate(4, [(0,1,1), (0,2,2), (0,3,3), (1,2,4), (1,3,5), (2,3,6)], [100, 100, 100, 100]) == [(0, 1, 100), (0, 2, 100), (0, 3, 100)]\n", "language": "python"}
{"task_id": "revision1a_problem256", "prompt": "def encrypt_message(message: str, key: str) -> str:\n    \"\"\"\n    You are a secret agent who needs to send an encrypted message to your handler. You've devised a custom encryption method based on a keyword.\n\n    Your task is to implement this encryption method:\n    1. Remove all spaces and punctuation from the message and convert it to uppercase.\n    2. If the message length is not a multiple of the key length, pad it with 'X's until it is.\n    3. Arrange the message in a grid where each row has the same length as the key.\n    4. For each column, sort the characters based on the alphabetical order of the corresponding letter in the key.\n    5. Read out the encrypted message row by row.\n\n    Example:\n    Input: \n    message = \"Meet me at the usual place at ten PM\"\n    key = \"CIPHER\"\n\n    Output: \"ETPAMEUUSUEHEHEXTLCANMLEODTA\"\n\n    Explanation:\n    1. Processed message: \"MEETMEATTHEUSUALPLACEATENPM\"\n    2. Padded message: \"MEETMEATTHEUSUALPLACEATENPMXX\"\n    3. Grid:\n       MEETME\n       ATTHEU\n       SUALPL\n       ACEATE\n       NPMXXX\n    4. Sorted based on key \"CIPHER\":\n       ETEMTE\n       TATHUE\n       ULASPL\n       CEAAET\n       PNMXXX\n    5. Encrypted: \"ETPAMEUUSUEHEHEXTLCANMLEODTA\"\n\n    This problem requires knowledge of:\n    - String manipulation\n    - 2D list operations\n    - Sorting algorithms\n    - Cryptography concepts\n    \"\"\"\n", "entry_point": "encrypt_message", "solution": "    import string\n    import math\n\n    # Step 1: Remove spaces and punctuation, convert to uppercase\n    processed_message = ''.join(char.upper() for char in message if char.isalnum())\n\n    # Step 2: Pad the message with 'X's if necessary\n    key_length = len(key)\n    padded_length = math.ceil(len(processed_message) / key_length) * key_length\n    padded_message = processed_message.ljust(padded_length, 'X')\n\n    # Step 3: Arrange the message in a grid\n    grid = [padded_message[i:i+key_length] for i in range(0, len(padded_message), key_length)]\n\n    # Step 4: Sort each column based on the key\n    sorted_grid = [''] * len(grid)\n    for col, key_char in sorted(enumerate(key), key=lambda x: x[1]):\n        column = ''.join(row[col] for row in grid)\n        sorted_column = sorted(column)\n        for row, char in enumerate(sorted_column):\n            sorted_grid[row] += char\n\n    # Step 5: Read out the encrypted message\n    encrypted_message = ''.join(sorted_grid)\n\n    return encrypted_message\n", "test": "def check(candidate):\n    assert candidate(\"AB\", \"Z\") == 'AB'\n    assert candidate(\"UPPERCASE MESSAGE\", \"lower\") == 'ACAGPEEPMSEESRSXUXXX'\n    assert candidate(\"MixEd CaSe MeSsAgE\", \"MiXeD\") == 'DCSAAGESEIMEXESXMXXX'\n    assert candidate(\"Testing 123\", \"CIPHER\") == 'GI312NTXTESX'\n    assert candidate(\"The quick brown fox jumps over the lazy dog\", \"SECRET\") == 'BFGECADHJOMEEKLONIHPOQRUOTURTWSYVXZX'\n    assert candidate(\"Cryptography is fun\", \"ENCRYPT\") == 'NCAIHGTPFROPSXYRUXXXY'\n    assert candidate(\"Hello, World!\", \"KEY\") == 'EDLOHLRLWXOX'\n    assert candidate(\"A\", \"LONG\") == 'XAXX'\n    assert candidate(\"This is a very long message that needs to be encrypted\", \"SHORT\") == 'ACBEAEEDGAEEEMDHIEPELOHSGNONSINSRTRTTSTXTVSYY'\n    assert candidate(\"OpenAI is amazing\", \"GPT\") == 'IAAIAEMNGNPIOSZ'\n", "language": "python"}
{"task_id": "revision1a_problem15", "prompt": "from typing import List, Dict, Tuple\nimport random\n\ndef simulate_ecosystem(initial_population: Dict[str, int], years: int, interactions: List[Tuple[str, str, float]]) -> Dict[str, int]:\n    \"\"\"\n    Simulate the population dynamics of an ecosystem over a specified number of years.\n\n    Create a class Ecosystem that manages the population of different species.\n    Implement subclasses for each species (e.g., Rabbit, Fox, Grass) that inherit from a base Species class.\n    Each year, update the population based on birth rates, death rates, and interactions between species.\n    Interactions can be predator-prey relationships or competition for resources.\n\n    Parameters:\n    initial_population (Dict[str, int]): A dictionary with species names as keys and their initial populations as values.\n    years (int): The number of years to simulate.\n    interactions (List[Tuple[str, str, float]]): A list of tuples representing interactions between species.\n                                                 Each tuple contains (species1, species2, interaction_strength).\n\n    Returns:\n    Dict[str, int]: A dictionary with the final population of each species after the simulation.\n\n    Example:\n    Input: \n    initial_population = {\"Rabbit\": 1000, \"Fox\": 100, \"Grass\": 10000}\n    years = 10\n    interactions = [(\"Fox\", \"Rabbit\", -0.3), (\"Rabbit\", \"Grass\", -0.1), (\"Fox\", \"Fox\", -0.01)]\n    Output: {\"Rabbit\": 1200, \"Fox\": 150, \"Grass\": 8000}\n\n    Input:\n    initial_population = {\"Lion\": 50, \"Zebra\": 1000, \"Grass\": 50000}\n    years = 20\n    interactions = [(\"Lion\", \"Zebra\", -0.2), (\"Zebra\", \"Grass\", -0.05), (\"Lion\", \"Lion\", -0.02)]\n    Output: {\"Lion\": 40, \"Zebra\": 800, \"Grass\": 40000}\n    \"\"\"\n", "entry_point": "simulate_ecosystem", "solution": "    class Species:\n        def __init__(self, name: str, population: int):\n            self.name = name\n            self.population = population\n            self.birth_rate = 0.1\n            self.death_rate = 0.05\n\n        def update_population(self, interactions: Dict[str, float]):\n            growth = self.population * (self.birth_rate - self.death_rate)\n            for species, strength in interactions.items():\n                growth += strength * self.population\n            self.population = max(0, int(self.population + growth))\n\n    class Ecosystem:\n        def __init__(self, initial_population: Dict[str, int], interactions: List[Tuple[str, str, float]]):\n            self.species = {name: Species(name, pop) for name, pop in initial_population.items()}\n            self.interaction_map = self._create_interaction_map(interactions)\n\n        def _create_interaction_map(self, interactions: List[Tuple[str, str, float]]) -> Dict[str, Dict[str, float]]:\n            interaction_map = {species: {} for species in self.species}\n            for species1, species2, strength in interactions:\n                interaction_map[species1][species2] = strength\n            return interaction_map\n\n        def simulate_year(self):\n            for species_name, species in self.species.items():\n                species.update_population(self.interaction_map.get(species_name, {}))\n\n        def get_population(self) -> Dict[str, int]:\n            return {name: species.population for name, species in self.species.items()}\n\n    ecosystem = Ecosystem(initial_population, interactions)\n\n    for _ in range(years):\n        ecosystem.simulate_year()\n\n    return ecosystem.get_population()\n", "test": "def check(candidate):\n    assert candidate({\"Bear\": 50, \"Salmon\": 5000, \"Insect\": 100000}, 12, [(\"Bear\", \"Salmon\", -0.3), (\"Salmon\", \"Insect\", -0.1), (\"Bear\", \"Bear\", -0.02)]) == {'Bear': 0, 'Salmon': 2698, 'Insect': 179581}\n    assert candidate({\"Lynx\": 150, \"Hare\": 8000, \"Plant\": 100000}, 14, [(\"Lynx\", \"Hare\", -0.25), (\"Hare\", \"Plant\", -0.1), (\"Lynx\", \"Lynx\", -0.03)]) == {'Lynx': 2, 'Hare': 3898, 'Plant': 197988}\n    assert candidate({\"Penguin\": 1000, \"Fish\": 20000, \"Krill\": 500000}, 8, [(\"Penguin\", \"Fish\", -0.2), (\"Fish\", \"Krill\", -0.1), (\"Penguin\", \"Penguin\", -0.01)]) == {'Penguin': 246, 'Fish': 13266, 'Krill': 738724}\n    assert candidate({\"Crocodile\": 300, \"Wildebeest\": 3000, \"Algae\": 200000}, 22, [(\"Crocodile\", \"Wildebeest\", -0.1), (\"Wildebeest\", \"Algae\", -0.05), (\"Crocodile\", \"Crocodile\", -0.02)]) == {'Crocodile': 56, 'Wildebeest': 3000, 'Algae': 585037}\n    assert candidate({\"Rabbit\": 1000, \"Fox\": 100, \"Grass\": 10000}, 10, [(\"Fox\", \"Rabbit\", -0.3), (\"Rabbit\", \"Grass\", -0.1), (\"Fox\", \"Fox\", -0.01)]) == {'Rabbit': 595, 'Fox': 3, 'Grass': 16284}\n    assert candidate({\"Wolf\": 200, \"Deer\": 5000, \"Berry\": 100000}, 15, [(\"Wolf\", \"Deer\", -0.1), (\"Deer\", \"Berry\", -0.05), (\"Wolf\", \"Wolf\", -0.02)]) == {'Wolf': 62, 'Deer': 5000, 'Berry': 207887}\n    assert candidate({\"Owl\": 200, \"Squirrel\": 2000, \"Acorn\": 50000}, 18, [(\"Owl\", \"Squirrel\", -0.15), (\"Squirrel\", \"Acorn\", -0.1), (\"Owl\", \"Owl\", -0.03)]) == {'Owl': 13, 'Squirrel': 789, 'Acorn': 120320}\n    assert candidate({\"Shark\": 500, \"Tuna\": 10000, \"Plankton\": 1000000}, 30, [(\"Shark\", \"Tuna\", -0.2), (\"Tuna\", \"Plankton\", -0.1), (\"Shark\", \"Shark\", -0.01)]) == {'Shark': 0, 'Tuna': 2140, 'Plankton': 4321918}\n    assert candidate({\"Lion\": 50, \"Zebra\": 1000, \"Grass\": 50000}, 20, [(\"Lion\", \"Zebra\", -0.2), (\"Zebra\", \"Grass\", -0.05), (\"Lion\", \"Lion\", -0.02)]) == {'Lion': 0, 'Zebra': 1000, 'Grass': 132652}\n    assert candidate({\"Eagle\": 100, \"Snake\": 1000, \"Mouse\": 10000}, 25, [(\"Eagle\", \"Snake\", -0.1), (\"Snake\", \"Mouse\", -0.2), (\"Eagle\", \"Eagle\", -0.05)]) == {'Eagle': 3, 'Snake': 14, 'Mouse': 33841}\n", "language": "python"}
{"task_id": "revision1a_problem109", "prompt": "from typing import List, Tuple\n\ndef minimum_platforms(arrival: List[int], departure: List[int]) -> int:\n    \"\"\"\n    Given the arrival and departure times of all trains that reach a railway station, \n    find the minimum number of platforms required for the railway station so that no train waits.\n    Consider that all the trains arrive on the same day and leave on the same day. \n    Arrival and departure time can never be the same for a train, but we can have arrival time of one train equal to departure time of the other. \n    At any given instance of time, same platform can not be used for both departure of a train and arrival of another train. \n    In such cases, we need different platforms.\n\n    Take two lists as input from the user: one for arrival times and another for departure times (in 24-hour format).\n    Return the minimum number of platforms required.\n\n    Example:\n    Input: \n    arrival = [900, 940, 950, 1100, 1500, 1800]\n    departure = [910, 1200, 1120, 1130, 1900, 2000]\n    Output: 3\n    \"\"\"\n", "entry_point": "minimum_platforms", "solution": "    # Sort both arrival and departure times\n    arrival.sort()\n    departure.sort()\n    \n    n = len(arrival)\n    platforms_needed = 1\n    result = 1\n    i = 1\n    j = 0\n    \n    while i < n and j < n:\n        if arrival[i] <= departure[j]:\n            platforms_needed += 1\n            i += 1\n        elif arrival[i] > departure[j]:\n            platforms_needed -= 1\n            j += 1\n        \n        if platforms_needed > result:\n            result = platforms_needed\n    \n    return result\n", "test": "def check(candidate):\n    assert candidate([800, 830, 840, 850], [830, 840, 850, 900]) == 2\n    assert candidate([900, 940, 950, 1100, 1500, 1800], [910, 1200, 1120, 1130, 1900, 2000]) == 3\n    assert candidate([0, 2359], [1, 2358]) == 1\n    assert candidate([1, 2, 3, 4, 5], [6, 7, 8, 9, 10]) == 5\n    assert candidate([600, 600, 600], [700, 800, 900]) == 3\n    assert candidate([200, 210, 300, 320, 350, 500], [230, 340, 320, 430, 400, 520]) == 3\n    assert candidate([900, 1100, 1235], [1000, 1200, 1240]) == 1\n    assert candidate([1000], [1100]) == 1\n    assert candidate([100, 200, 300, 400, 500], [200, 300, 400, 500, 600]) == 2\n    assert candidate([1200, 1300, 1400, 1500], [1300, 1400, 1500, 1600]) == 2\n", "language": "python"}
{"task_id": "revision1a_problem536", "prompt": "from itertools import permutations\nfrom typing import List\n\ndef optimize_delivery_route(distances: List[List[int]], max_time: int) -> int:\n    \"\"\"\n    A delivery driver needs to optimize their route to deliver packages to multiple locations within a given time limit.\n    The driver starts at location 0 and must return to location 0 at the end.\n    \n    Given a 2D list of distances between locations and a maximum time limit, calculate the maximum number of locations\n    the driver can visit (including the start/end location) without exceeding the time limit.\n    \n    Each element distances[i][j] represents the time it takes to travel from location i to location j.\n    The driver must visit each selected location exactly once, except for the start/end location.\n    \n    Input: \n    distances = [[0, 2, 3, 4], [2, 0, 6, 3], [3, 6, 0, 2], [4, 3, 2, 0]]\n    max_time = 10\n    \n    Output: 4\n    \n    Explanation: The optimal route is 0 -> 1 -> 3 -> 2 -> 0, visiting all 4 locations within the time limit of 10.\n    Total time: 2 + 3 + 2 + 3 = 10\n    \"\"\"\n", "entry_point": "optimize_delivery_route", "solution": "    n = len(distances)\n    max_locations = 1\n\n    def calculate_route_time(route):\n        time = 0\n        for i in range(len(route) - 1):\n            time += distances[route[i]][route[i + 1]]\n        time += distances[route[-1]][0]  # Return to start\n        return time\n\n    for k in range(2, n + 1):\n        for perm in permutations(range(1, n), k - 1):\n            route = (0,) + perm\n            route_time = calculate_route_time(route)\n            if route_time <= max_time:\n                max_locations = max(max_locations, k)\n            else:\n                break  # No need to check longer routes\n\n    return max_locations\n", "test": "def check(candidate):\n    assert candidate([[0, 1, 2, 3], [1, 0, 4, 5], [2, 4, 0, 6], [3, 5, 6, 0]], 10) == 3\n    assert candidate([[0, 1, 1], [1, 0, 1], [1, 1, 0]], 3) == 3\n    assert candidate([[0, 2, 3, 4], [2, 0, 6, 3], [3, 6, 0, 2], [4, 3, 2, 0]], 9) == 2\n    assert candidate([[0, 1, 2, 3, 4], [1, 0, 2, 3, 4], [2, 2, 0, 3, 4], [3, 3, 3, 0, 4], [4, 4, 4, 4, 0]], 15) == 5\n    assert candidate([[0, 100, 100], [100, 0, 100], [100, 100, 0]], 99) == 1\n    assert candidate([[0, 1], [1, 0]], 2) == 2\n    assert candidate([[0]], 5) == 1\n    assert candidate([[0, 1, 1, 1], [1, 0, 1, 1], [1, 1, 0, 1], [1, 1, 1, 0]], 4) == 4\n    assert candidate([[0, 5, 10], [5, 0, 15], [10, 15, 0]], 20) == 2\n    assert candidate([[0, 1], [1, 0]], 1) == 1\n", "language": "python"}
{"task_id": "revision1a_problem397", "prompt": "from typing import List, Dict\nimport re\n\ndef analyze_text_sentiment(text: str) -> Dict[str, float]:\n    \"\"\"\n    As a social media analyst, you need to analyze the sentiment of user comments.\n    Given a text input, perform sentiment analysis using natural language processing techniques.\n    Calculate the percentage of positive, negative, and neutral sentiments in the text.\n    Use regular expressions to identify emojis and consider them in the sentiment analysis.\n    Return a dictionary with the sentiment percentages.\n\n    Example:\n    Input: \"I love this product! \ud83d\ude0d It's amazing. However, the delivery was a bit slow. \ud83d\ude15\"\n    Output: {'positive': 60.0, 'negative': 20.0, 'neutral': 20.0}\n    \"\"\"\n", "entry_point": "analyze_text_sentiment", "solution": "    def tokenize(text: str) -> List[str]:\n        return re.findall(r'\\b\\w+\\b|[\ud83d\ude00-\ud83d\ude4f]', text.lower())\n\n    def sentiment_score(word: str) -> int:\n        positive_words = {'love', 'amazing', 'great', 'excellent', 'good', 'nice', 'happy', '\ud83d\ude0d', '\ud83d\ude0a', '\ud83d\udc4d'}\n        negative_words = {'slow', 'bad', 'terrible', 'awful', 'disappointing', 'poor', 'sad', '\ud83d\ude15', '\ud83d\ude22', '\ud83d\udc4e'}\n        if word in positive_words:\n            return 1\n        elif word in negative_words:\n            return -1\n        else:\n            return 0\n\n    tokens = tokenize(text)\n    sentiment_scores = [sentiment_score(token) for token in tokens]\n    \n    positive_count = sum(1 for score in sentiment_scores if score > 0)\n    negative_count = sum(1 for score in sentiment_scores if score < 0)\n    neutral_count = sum(1 for score in sentiment_scores if score == 0)\n    \n    total_count = len(sentiment_scores)\n    \n    sentiment_percentages = {\n        'positive': (positive_count / total_count) * 100,\n        'negative': (negative_count / total_count) * 100,\n        'neutral': (neutral_count / total_count) * 100\n    }\n    \n    return {k: round(v, 1) for k, v in sentiment_percentages.items()}\n", "test": "def check(candidate):\n    assert candidate(\"\ud83d\ude0a\ud83d\ude0a\ud83d\ude0a\ud83d\ude0a\ud83d\ude0a\") == {'positive': 100.0, 'negative': 0.0, 'neutral': 0.0}\n    assert candidate(\"I love this product! \ud83d\ude0d It\\'s amazing. However, the delivery was a bit slow. \ud83d\ude15\") == {'positive': 18.8, 'negative': 12.5, 'neutral': 68.8}\n    assert candidate(\"Mixed feelings about this. Some good points, some bad. \ud83e\udd14\") == {'positive': 11.1, 'negative': 11.1, 'neutral': 77.8}\n    assert candidate(\"The product is okay. Nothing special, but not bad either.\") == {'positive': 0.0, 'negative': 10.0, 'neutral': 90.0}\n    assert candidate(\"Disappointed. Doesn\\'t work as advertised. Waste of money. \ud83d\udc4e\") == {'positive': 0.0, 'negative': 0.0, 'neutral': 100.0}\n    assert candidate(\"It\\'s fine.\") == {'positive': 0.0, 'negative': 0.0, 'neutral': 100.0}\n    assert candidate(\"LOVE LOVE LOVE!!! Best purchase ever! \ud83c\udf89\ud83c\udf8a\ud83d\ude0d\") == {'positive': 57.1, 'negative': 0.0, 'neutral': 42.9}\n    assert candidate(\"This is a neutral statement without any emotions.\") == {'positive': 0.0, 'negative': 0.0, 'neutral': 100.0}\n    assert candidate(\"\ud83d\ude41\ud83d\ude41\ud83d\ude41\ud83d\ude41\ud83d\ude41\") == {'positive': 0.0, 'negative': 0.0, 'neutral': 100.0}\n    assert candidate(\"I absolutely hate this! It\\'s the worst thing ever. \ud83d\ude21\ud83e\udd2c\") == {'positive': 0.0, 'negative': 0.0, 'neutral': 100.0}\n", "language": "python"}
{"task_id": "revision1a_problem122", "prompt": "from typing import List, Tuple\nimport heapq\n\ndef optimize_study_schedule(courses: List[Tuple[int, int]]) -> int:\n    \"\"\"\n    As a university student, you want to maximize the number of courses you can complete.\n    Each course has a duration and a deadline. You can only study one course at a time, and\n    you must complete a course before its deadline.\n    \n    Implement a greedy algorithm using a priority queue (min-heap) to solve this problem.\n    Take input from the user as a list of tuples, where each tuple contains (duration, deadline)\n    for a course. Return the maximum number of courses that can be completed.\n    \n    Example:\n    Input: [(2, 4), (3, 5), (1, 3), (4, 6)]\n    Output: 3\n    \n    Explanation: You can complete 3 courses in this order:\n    1. Course with duration 1, completed at time 1\n    2. Course with duration 2, completed at time 3\n    3. Course with duration 3, completed at time 6\n    \"\"\"\n", "entry_point": "optimize_study_schedule", "solution": "    # Sort courses based on their deadlines\n    courses.sort(key=lambda x: x[1])\n    \n    completed_courses = []\n    current_time = 0\n    \n    for duration, deadline in courses:\n        # If we can complete the course before its deadline\n        if current_time + duration <= deadline:\n            current_time += duration\n            heapq.heappush(completed_courses, -duration)  # Use negative duration for max-heap behavior\n        # If we can't complete the course, but it's shorter than the longest course we've completed so far\n        elif completed_courses and -completed_courses[0] > duration:\n            # Remove the longest course and add the current one\n            longest_duration = -heapq.heappop(completed_courses)\n            current_time = current_time - longest_duration + duration\n            heapq.heappush(completed_courses, -duration)\n    \n    return len(completed_courses)\n", "test": "def check(candidate):\n    assert candidate([(1, 100), (99, 100)]) == 2\n    assert candidate([(5, 5), (4, 4), (3, 3), (2, 2), (1, 1)]) == 1\n    assert candidate([(2, 4), (3, 5), (1, 3), (4, 6)]) == 2\n    assert candidate([(1, 2), (2, 3), (3, 4), (4, 5)]) == 2\n    assert candidate([(10, 10)]) == 1\n    assert candidate([(5, 5), (4, 6), (3, 7), (2, 8), (1, 9)]) == 3\n    assert candidate([(1, 2), (1, 3), (1, 4), (1, 5), (1, 6)]) == 5\n    assert candidate([(1, 1), (1, 2), (1, 3), (1, 4)]) == 4\n    assert candidate([(1, 10), (2, 10), (3, 10), (4, 10)]) == 4\n    assert candidate([]) == 0\n", "language": "python"}
{"task_id": "revision1a_problem690", "prompt": "import re\n\ndef password_strength(password: str) -> str:\n    \"\"\"\n    In a cybersecurity company, you're tasked with creating a password strength checker.\n    The function should evaluate the strength of a given password based on the following criteria:\n    1. Length: At least 8 characters\n    2. Complexity: Must contain at least one uppercase letter, one lowercase letter, one digit, and one special character\n    3. No common words: Should not contain common words like 'password', '123456', or 'qwerty'\n\n    Use regular expressions to check for complexity and common words.\n    Return the strength as a string: 'Weak', 'Moderate', or 'Strong'.\n\n    Example 1: If password is 'P@ssw0rd', return 'Moderate' (meets length and complexity, but contains a common word)\n    Example 2: If password is 'Str0ngP@ssw0rd!', return 'Strong' (meets all criteria)\n    Example 3: If password is 'abc123', return 'Weak' (doesn't meet length or complexity requirements)\n    \"\"\"\n", "entry_point": "password_strength", "solution": "    # Check length\n    if len(password) < 8:\n        return 'Weak'\n\n    # Check complexity\n    if not (re.search(r'[A-Z]', password) and\n            re.search(r'[a-z]', password) and\n            re.search(r'\\d', password) and\n            re.search(r'[!@#$%^&*(),.?\":{}|<>]', password)):\n        return 'Weak'\n\n    # Check for common words\n    common_words = ['password', '123456', 'qwerty']\n    if any(word.lower() in password.lower() for word in common_words):\n        return 'Moderate'\n\n    # If all criteria are met\n    return 'Strong'\n", "test": "def check(candidate):\n    assert candidate(\"P@ssw0rd\") == 'Strong'\n    assert candidate(\"Password123!\") == 'Moderate'\n    assert candidate(\"abc123\") == 'Weak'\n    assert candidate(\"123456789\") == 'Weak'\n    assert candidate(\"AAAAAAAA\") == 'Weak'\n    assert candidate(\"aaaaaaaa\") == 'Weak'\n    assert candidate(\"Abcdefgh1!\") == 'Strong'\n    assert candidate(\"!@#$%^&*()\") == 'Weak'\n    assert candidate(\"Str0ngP@ssw0rd!\") == 'Strong'\n    assert candidate(\"Qwerty123!\") == 'Moderate'\n", "language": "python"}
{"task_id": "revision1a_problem422", "prompt": "from typing import List, Tuple\n\ndef optimize_warehouse_layout(items: List[Tuple[str, int, int]]) -> List[str]:\n    \"\"\"\n    As a warehouse manager, I need to optimize the layout of our storage space based on item popularity and size.\n    Write a function that takes a list of tuples containing item information (name, popularity score, size in cubic meters) and returns a list of placement suggestions.\n    The warehouse has three zones: A (near), B (middle), and C (far).\n    Items should be placed according to these rules:\n    1. Items with popularity score > 8 go to zone A\n    2. Items with popularity score 4-8 go to zone B\n    3. Items with popularity score < 4 go to zone C\n    4. If an item's size is > 10 cubic meters, add \"large\" to its placement suggestion\n\n    Example:\n    Input: [(\"Book\", 9, 2), (\"Fridge\", 5, 15), (\"Pen\", 7, 1), (\"Sofa\", 3, 12)]\n    Output: [\"Place Book in zone A\", \"Place Fridge in zone B (large)\", \"Place Pen in zone B\", \"Place Sofa in zone C (large)\"]\n    \"\"\"\n", "entry_point": "optimize_warehouse_layout", "solution": "    def get_zone(popularity: int) -> str:\n        if popularity > 8:\n            return \"A\"\n        elif 4 <= popularity <= 8:\n            return \"B\"\n        else:\n            return \"C\"\n\n    def is_large(size: int) -> bool:\n        return size > 10\n\n    placement_suggestions = []\n\n    for item in items:\n        name, popularity, size = item\n        zone = get_zone(popularity)\n        suggestion = f\"Place {name} in zone {zone}\"\n        \n        if is_large(size):\n            suggestion += \" (large)\"\n        \n        placement_suggestions.append(suggestion)\n\n    return placement_suggestions\n", "test": "def check(candidate):\n    assert candidate([(\"Laptop\", 10, 3), (\"Desk\", 6, 11), (\"Chair\", 8, 5), (\"Lamp\", 4, 2)]) == ['Place Laptop in zone A', 'Place Desk in zone B (large)', 'Place Chair in zone B', 'Place Lamp in zone B']\n    assert candidate([(\"Printer\", 3, 9), (\"Scanner\", 2, 7), (\"Headphones\", 8, 1), (\"Mouse\", 7, 1)]) == ['Place Printer in zone C', 'Place Scanner in zone C', 'Place Headphones in zone B', 'Place Mouse in zone B']\n    assert candidate([(\"TV\", 9, 12), (\"Stereo\", 5, 6), (\"Gaming Console\", 8, 4), (\"Speakers\", 6, 3)]) == ['Place TV in zone A (large)', 'Place Stereo in zone B', 'Place Gaming Console in zone B', 'Place Speakers in zone B']\n    assert candidate([(\"Microwave\", 7, 5), (\"Toaster\", 4, 2), (\"Blender\", 5, 3), (\"Coffee Maker\", 8, 4)]) == ['Place Microwave in zone B', 'Place Toaster in zone B', 'Place Blender in zone B', 'Place Coffee Maker in zone B']\n    assert candidate([(\"Bicycle\", 6, 8), (\"Treadmill\", 4, 18), (\"Yoga Mat\", 7, 1), (\"Dumbbells\", 5, 3)]) == ['Place Bicycle in zone B', 'Place Treadmill in zone B (large)', 'Place Yoga Mat in zone B', 'Place Dumbbells in zone B']\n    assert candidate([(\"Painting\", 3, 2), (\"Sculpture\", 2, 5), (\"Vase\", 4, 1), (\"Mirror\", 6, 4)]) == ['Place Painting in zone C', 'Place Sculpture in zone C', 'Place Vase in zone B', 'Place Mirror in zone B']\n    assert candidate([(\"Couch\", 7, 16), (\"Dining Table\", 6, 14), (\"Bed\", 8, 18), (\"Wardrobe\", 5, 22)]) == ['Place Couch in zone B (large)', 'Place Dining Table in zone B (large)', 'Place Bed in zone B (large)', 'Place Wardrobe in zone B (large)']\n    assert candidate([(\"Book\", 9, 2), (\"Fridge\", 5, 15), (\"Pen\", 7, 1), (\"Sofa\", 3, 12)]) == ['Place Book in zone A', 'Place Fridge in zone B (large)', 'Place Pen in zone B', 'Place Sofa in zone C (large)']\n    assert candidate([(\"Phone\", 9, 1), (\"Tablet\", 7, 2), (\"Monitor\", 5, 8), (\"Keyboard\", 6, 1)]) == ['Place Phone in zone A', 'Place Tablet in zone B', 'Place Monitor in zone B', 'Place Keyboard in zone B']\n    assert candidate([(\"Refrigerator\", 9, 20), (\"Washing Machine\", 7, 15), (\"Dryer\", 6, 14), (\"Dishwasher\", 5, 12)]) == ['Place Refrigerator in zone A (large)', 'Place Washing Machine in zone B (large)', 'Place Dryer in zone B (large)', 'Place Dishwasher in zone B (large)']\n", "language": "python"}
{"task_id": "revision1a_problem66", "prompt": "from typing import List, Dict, Tuple, Union\nimport heapq\nimport math\n\ndef optimize_delivery_route(locations: List[Tuple[str, float, float]], fuel_capacity: float, fuel_consumption: float) -> Dict[str, Union[List[str], float]]:\n    \"\"\"\n    Optimize a delivery route for a truck with limited fuel capacity.\n\n    This function takes a list of delivery locations (each with a name and coordinates),\n    the fuel capacity of the truck, and its fuel consumption rate. It then determines\n    the optimal route that visits all locations while minimizing the total distance\n    traveled and ensuring the truck doesn't run out of fuel.\n\n    The function uses a combination of the Traveling Salesman Problem (TSP) approach\n    and a greedy algorithm for fuel management. It employs a priority queue to always\n    choose the nearest unvisited location that can be reached with the remaining fuel.\n\n    Parameters:\n    locations (List[Tuple[str, float, float]]): List of tuples containing location name and its (x, y) coordinates\n    fuel_capacity (float): The maximum amount of fuel the truck can hold\n    fuel_consumption (float): Fuel consumed per unit distance\n\n    Returns:\n    Dict[str, Union[List[str], float]]: A dictionary containing the optimized route (list of location names) and total distance\n\n    Example:\n    Input: [(\"A\", 0, 0), (\"B\", 3, 4), (\"C\", -2, 6), (\"D\", 5, -3)], 20.0, 0.1\n    Output: {\"route\": [\"A\", \"B\", \"C\", \"D\", \"A\"], \"total_distance\": 28.97}\n\n    Input: [(\"X\", 1, 1), (\"Y\", -1, 4), (\"Z\", 3, -2)], 15.0, 0.2\n    Output: {\"route\": [\"X\", \"Y\", \"Z\", \"X\"], \"total_distance\": 14.14}\n    \"\"\"\n", "entry_point": "optimize_delivery_route", "solution": "    def distance(loc1, loc2):\n        return math.sqrt((loc1[1] - loc2[1])**2 + (loc1[2] - loc2[2])**2)\n\n    n = len(locations)\n    unvisited = set(range(1, n))  # Exclude starting point (index 0)\n    current = 0  # Start from the first location\n    route = [locations[0][0]]\n    total_distance = 0\n    remaining_fuel = fuel_capacity\n\n    while unvisited:\n        pq = []\n        for next_loc in unvisited:\n            dist = distance(locations[current], locations[next_loc])\n            fuel_needed = dist * fuel_consumption\n            if fuel_needed <= remaining_fuel:\n                heapq.heappush(pq, (dist, next_loc))\n\n        if not pq:\n            # If we can't reach any location, return to start and refuel\n            dist_to_start = distance(locations[current], locations[0])\n            total_distance += dist_to_start\n            route.append(locations[0][0])\n            remaining_fuel = fuel_capacity\n            current = 0\n        else:\n            dist, next_loc = heapq.heappop(pq)\n            total_distance += dist\n            remaining_fuel -= dist * fuel_consumption\n            route.append(locations[next_loc][0])\n            unvisited.remove(next_loc)\n            current = next_loc\n\n    # Return to the starting point\n    dist_to_start = distance(locations[current], locations[0])\n    total_distance += dist_to_start\n    route.append(locations[0][0])\n\n    return {\n        \"route\": route,\n        \"total_distance\": round(total_distance, 2)\n    }\n", "test": "def check(candidate):\n    assert candidate([(\"P\", 0, 0), (\"Q\", 1, 1), (\"R\", 2, 2), (\"S\", 3, 3)], 10.0, 0.5) == {'route': ['P', 'Q', 'R', 'S', 'P'], 'total_distance': 8.49}\n    assert candidate([(\"A\", 0, 0), (\"B\", 3, 4), (\"C\", -2, 6), (\"D\", 5, -3)], 20.0, 0.1) == {'route': ['A', 'B', 'C', 'D', 'A'], 'total_distance': 27.62}\n    assert candidate([(\"Start\", 0, 0), (\"End\", 100, 100)], 1000.0, 0.01) == {'route': ['Start', 'End', 'Start'], 'total_distance': 282.84}\n    assert candidate([(\"Hub\", 0, 0), (\"Loc1\", 10, 0), (\"Loc2\", 0, 10), (\"Loc3\", -10, 0), (\"Loc4\", 0, -10)], 100.0, 0.5) == {'route': ['Hub', 'Loc1', 'Loc2', 'Loc3', 'Loc4', 'Hub'], 'total_distance': 62.43}\n    assert candidate([(\"X\", 1, 1), (\"Y\", -1, 4), (\"Z\", 3, -2)], 15.0, 0.2) == {'route': ['X', 'Y', 'Z', 'X'], 'total_distance': 14.42}\n    assert candidate([(\"City1\", 0, 0), (\"City2\", 10, 10), (\"City3\", -5, 5), (\"City4\", 5, -5)], 50.0, 0.2) == {'route': ['City1', 'City3', 'City4', 'City2', 'City1'], 'total_distance': 51.17}\n    assert candidate([(\"Point1\", 0.5, 0.5), (\"Point2\", -0.5, -0.5), (\"Point3\", 0.5, -0.5), (\"Point4\", -0.5, 0.5)], 2.0, 0.1) == {'route': ['Point1', 'Point3', 'Point2', 'Point4', 'Point1'], 'total_distance': 4.0}\n    assert candidate([(\"A\", 0, 0)], 10.0, 0.1) == {'route': ['A', 'A'], 'total_distance': 0.0}\n    assert candidate([(\"A\", 0, 0), (\"B\", 1, 1), (\"C\", 2, 2), (\"D\", 3, 3), (\"E\", 4, 4)], 25.0, 0.3) == {'route': ['A', 'B', 'C', 'D', 'E', 'A'], 'total_distance': 11.31}\n    assert candidate([(\"N\", 0, 1), (\"S\", 0, -1), (\"E\", 1, 0), (\"W\", -1, 0)], 5.0, 0.25) == {'route': ['N', 'E', 'S', 'W', 'N'], 'total_distance': 5.66}\n", "language": "python"}
{"task_id": "revision1a_problem189", "prompt": "import math\nfrom typing import List, Tuple\n\ndef optimize_delivery_route(locations: List[Tuple[float, float]], fuel_capacity: float) -> List[int]:\n    \"\"\"\n    A delivery company wants to optimize their route for a fleet of drones. Given a list of customer locations\n    (as latitude and longitude coordinates) and the fuel capacity of each drone, determine the optimal order\n    of deliveries to minimize fuel consumption.\n\n    The function should use a greedy algorithm to find a near-optimal solution. Start from the origin (0, 0)\n    and always choose the nearest unvisited location that can be reached with the remaining fuel.\n\n    :param locations: List of tuples representing (latitude, longitude) of delivery locations\n    :param fuel_capacity: Float representing the fuel capacity of each drone\n    :return: List of integers representing the optimal order of visits (indices of the input locations)\n\n    Example:\n    Input: [(1.0, 1.0), (2.0, 2.0), (3.0, 3.0), (4.0, 4.0)], 10.0\n    Output: [0, 1, 2, 3]\n\n    Note: This is a simplified version of the Traveling Salesman Problem, which is NP-hard.\n    The greedy approach provides a good approximation but may not always find the optimal solution.\n    \"\"\"\n", "entry_point": "optimize_delivery_route", "solution": "    def distance(point1: Tuple[float, float], point2: Tuple[float, float]) -> float:\n        return math.sqrt((point1[0] - point2[0])**2 + (point1[1] - point2[1])**2)\n\n    unvisited = set(range(len(locations)))\n    current_location = (0.0, 0.0)  # Start from origin\n    route = []\n    remaining_fuel = fuel_capacity\n\n    while unvisited:\n        nearest_location = None\n        nearest_distance = float('inf')\n        nearest_index = -1\n\n        for i in unvisited:\n            dist = distance(current_location, locations[i])\n            if dist <= remaining_fuel and dist < nearest_distance:\n                nearest_location = locations[i]\n                nearest_distance = dist\n                nearest_index = i\n\n        if nearest_location is None:\n            # If no reachable location, return to origin and refuel\n            return_distance = distance(current_location, (0.0, 0.0))\n            if return_distance <= remaining_fuel:\n                current_location = (0.0, 0.0)\n                remaining_fuel = fuel_capacity\n            else:\n                # If can't even return to origin, break the loop\n                break\n        else:\n            route.append(nearest_index)\n            unvisited.remove(nearest_index)\n            current_location = nearest_location\n            remaining_fuel -= nearest_distance\n\n    return route\n", "test": "def check(candidate):\n    assert candidate([(3.14, 2.71), (1.41, 1.73), (2.72, 3.14)], 15.0) == [1, 2, 0]\n    assert candidate([(0.1, 0.1), (0.2, 0.2), (0.3, 0.3), (0.4, 0.4), (0.5, 0.5)], 1.0) == [0, 1, 2, 3, 4]\n    assert candidate([(0.5, 0.5), (1.5, 1.5), (2.5, 2.5)], 5.0) == [0, 1, 2]\n    assert candidate([(10.0, 10.0), (20.0, 20.0), (30.0, 30.0)], 100.0) == [0, 1, 2]\n    assert candidate([(1.0, 0.0), (0.0, 1.0), (-1.0, 0.0), (0.0, -1.0)], 3.0) == [0, 1]\n    assert candidate([], 5.0) == []\n    assert candidate([(1.0, 1.0), (2.0, 2.0), (3.0, 3.0), (4.0, 4.0)], 10.0) == [0, 1, 2, 3]\n    assert candidate([(0.0, 0.0), (0.0, 0.0), (0.0, 0.0)], 1.0) == [0, 1, 2]\n    assert candidate([(1.0, 1.0)], 2.0) == [0]\n    assert candidate([(-1.0, -1.0), (-2.0, -2.0), (-3.0, -3.0)], 8.0) == [0, 1, 2]\n", "language": "python"}
{"task_id": "revision1a_problem686", "prompt": "from typing import List\n\ndef shortest_supersequence(str1: str, str2: str) -> str:\n    \"\"\"\n    As a computer scientist working on genome assembly, you need to find the shortest\n    supersequence that contains both input sequences. This is crucial for minimizing\n    the number of nucleotides while preserving the order of both original sequences.\n\n    Implement a function using dynamic programming to find the shortest common supersequence (SCS)\n    of two given strings. The SCS is the shortest string that has both input strings as subsequences.\n\n    Take two input strings from the user and return the shortest common supersequence.\n\n    Example:\n    Input: \"AGGTAB\", \"GXTXAYB\"\n    Output: \"AGGXTXAYB\"\n\n    Input: \"HELLO\", \"WORLD\"\n    Output: \"WHELLOORLD\"\n    \"\"\"\n", "entry_point": "shortest_supersequence", "solution": "    m, n = len(str1), len(str2)\n    \n    # Create a 2D table to store lengths of shortest supersequences\n    dp = [[0] * (n + 1) for _ in range(m + 1)]\n    \n    # Fill the dp table\n    for i in range(m + 1):\n        for j in range(n + 1):\n            if i == 0:\n                dp[i][j] = j\n            elif j == 0:\n                dp[i][j] = i\n            elif str1[i - 1] == str2[j - 1]:\n                dp[i][j] = dp[i - 1][j - 1] + 1\n            else:\n                dp[i][j] = min(dp[i - 1][j], dp[i][j - 1]) + 1\n    \n    # Reconstruct the shortest supersequence\n    scs = []\n    i, j = m, n\n    while i > 0 and j > 0:\n        if str1[i - 1] == str2[j - 1]:\n            scs.append(str1[i - 1])\n            i -= 1\n            j -= 1\n        elif dp[i - 1][j] < dp[i][j - 1]:\n            scs.append(str1[i - 1])\n            i -= 1\n        else:\n            scs.append(str2[j - 1])\n            j -= 1\n    \n    # Add remaining characters from str1 or str2\n    while i > 0:\n        scs.append(str1[i - 1])\n        i -= 1\n    while j > 0:\n        scs.append(str2[j - 1])\n        j -= 1\n    \n    # Reverse and join the characters to get the final result\n    return ''.join(scs[::-1])\n", "test": "def check(candidate):\n    assert candidate(\"ABCDEF\", \"GHIJKL\") == 'ABCDEFGHIJKL'\n    assert candidate(\"ABC\", \"ABC\") == 'ABC'\n    assert candidate(\"AAAA\", \"BBBB\") == 'AAAABBBB'\n    assert candidate(\"A\", \"A\") == 'A'\n    assert candidate(\"\", \"B\") == 'B'\n    assert candidate(\"ACGT\", \"TGCA\") == 'ACGTGCA'\n    assert candidate(\"AGGTAB\", \"GXTXAYB\") == 'AGGXTXAYB'\n    assert candidate(\"A\", \"\") == 'A'\n    assert candidate(\"\", \"\") == ''\n    assert candidate(\"HELLO\", \"WORLD\") == 'HELLWORLD'\n", "language": "python"}
{"task_id": "revision1a_problem389", "prompt": "from typing import List, Tuple\n\ndef optimize_factory_layout(machines: List[Tuple[str, int, int]], factory_width: int, factory_length: int) -> List[Tuple[str, int, int]]:\n    \"\"\"\n    You are a factory layout engineer tasked with optimizing the placement of machines in a rectangular factory floor.\n    Each machine has a name, width, and length. The goal is to place all machines within the factory floor\n    while minimizing wasted space and ensuring efficient workflow.\n\n    Create a class named FactoryOptimizer with the following methods:\n    1. place_machines: Determine the optimal placement of machines on the factory floor\n    2. calculate_efficiency: Calculate the space utilization efficiency (used space / total space)\n    3. generate_layout: Create a visual representation of the factory layout\n\n    Take input from the user for the list of machines (name, width, length) and the factory dimensions.\n    Return the optimized layout as a list of tuples (machine_name, x_position, y_position).\n\n    Example:\n    Input: [(\"Lathe\", 3, 2), (\"Mill\", 4, 3), (\"Drill\", 2, 2)], factory_width=10, factory_length=8\n    Output: [(\"Lathe\", 0, 0), (\"Mill\", 3, 0), (\"Drill\", 7, 0)]\n    \"\"\"\n", "entry_point": "optimize_factory_layout", "solution": "    class FactoryOptimizer:\n        def __init__(self, machines, width, length):\n            self.machines = machines\n            self.width = width\n            self.length = length\n            self.layout = [[0 for _ in range(width)] for _ in range(length)]\n            self.placements = []\n\n        def place_machines(self):\n            self.machines.sort(key=lambda x: x[1] * x[2], reverse=True)\n            for machine in self.machines:\n                placed = False\n                for y in range(self.length):\n                    for x in range(self.width):\n                        if self.can_place(machine, x, y):\n                            self.place(machine, x, y)\n                            self.placements.append((machine[0], x, y))\n                            placed = True\n                            break\n                    if placed:\n                        break\n                if not placed:\n                    raise ValueError(f\"Cannot place machine {machine[0]} in the factory\")\n            return self.placements\n\n        def can_place(self, machine, x, y):\n            if x + machine[1] > self.width or y + machine[2] > self.length:\n                return False\n            for i in range(y, y + machine[2]):\n                for j in range(x, x + machine[1]):\n                    if self.layout[i][j] != 0:\n                        return False\n            return True\n\n        def place(self, machine, x, y):\n            for i in range(y, y + machine[2]):\n                for j in range(x, x + machine[1]):\n                    self.layout[i][j] = machine[0]\n\n        def calculate_efficiency(self):\n            used_space = sum(machine[1] * machine[2] for machine in self.machines)\n            total_space = self.width * self.length\n            return used_space / total_space\n\n        def generate_layout(self):\n            for row in self.layout:\n                print(\" \".join(str(cell).ljust(10) for cell in row))\n\n    optimizer = FactoryOptimizer(machines, factory_width, factory_length)\n    optimized_layout = optimizer.place_machines()\n    print(f\"Efficiency: {optimizer.calculate_efficiency():.2f}\")\n    print(\"Factory Layout:\")\n    optimizer.generate_layout()\n    return optimized_layout\n\n", "test": "def check(candidate):\n    assert candidate([(\"BigMachine\", 10, 10)], 10, 10) == [('BigMachine', 0, 0)]\n    assert candidate([(\"Wide\", 8, 2), (\"Tall\", 2, 8)], 10, 10) == [('Wide', 0, 0), ('Tall', 8, 0)]\n    assert candidate([(\"Robot\", 2, 2)], 5, 5) == [('Robot', 0, 0)]\n    assert candidate([(\"LongMachine\", 1, 10)], 5, 10) == [('LongMachine', 0, 0)]\n    assert candidate([], 10, 10) == []\n    assert candidate([(\"Tiny\", 1, 1)] * 20, 5, 5) == [('Tiny', 0, 0), ('Tiny', 1, 0), ('Tiny', 2, 0), ('Tiny', 3, 0), ('Tiny', 4, 0), ('Tiny', 0, 1), ('Tiny', 1, 1), ('Tiny', 2, 1), ('Tiny', 3, 1), ('Tiny', 4, 1), ('Tiny', 0, 2), ('Tiny', 1, 2), ('Tiny', 2, 2), ('Tiny', 3, 2), ('Tiny', 4, 2), ('Tiny', 0, 3), ('Tiny', 1, 3), ('Tiny', 2, 3), ('Tiny', 3, 3), ('Tiny', 4, 3)]\n    assert candidate([(\"A\", 1, 1), (\"B\", 1, 1), (\"C\", 1, 1), (\"D\", 1, 1)], 2, 2) == [('A', 0, 0), ('B', 1, 0), ('C', 0, 1), ('D', 1, 1)]\n    assert candidate([(\"Lathe\", 3, 2), (\"Mill\", 4, 3), (\"Drill\", 2, 2)], 10, 8) == [('Mill', 0, 0), ('Lathe', 4, 0), ('Drill', 7, 0)]\n    assert candidate([(\"CNC\", 5, 5), (\"Grinder\", 2, 2), (\"Press\", 3, 3), (\"Saw\", 2, 4)], 15, 10) == [('CNC', 0, 0), ('Press', 5, 0), ('Saw', 8, 0), ('Grinder', 10, 0)]\n    assert candidate([(\"M1\", 3, 3), (\"M2\", 3, 3), (\"M3\", 3, 3), (\"M4\", 3, 3)], 6, 6) == [('M1', 0, 0), ('M2', 3, 0), ('M3', 0, 3), ('M4', 3, 3)]\n", "language": "python"}
{"task_id": "revision1a_problem259", "prompt": "def encrypt_message(message: str, key: int) -> str:\n    \"\"\"\n    You are developing an encryption system for a secure messaging app. Your task is to implement a modified Caesar cipher\n    that not only shifts letters but also incorporates numbers and preserves spaces and punctuation.\n\n    The encryption rules are as follows:\n    1. Shift all letters (both uppercase and lowercase) by the given key value.\n    2. For numbers, add the key value to the digit. If the result is 10 or greater, use the ones digit of the result.\n    3. Preserve spaces and punctuation as they are.\n    4. The alphabet wraps around, so 'z' shifted by 1 becomes 'a'.\n\n    Take the message and key as input, and return the encrypted message as a string.\n\n    Example:\n    Input: message = \"Hello, World! 2023\", key = 3\n    Output: \"Khoor, Zruog! 5356\"\n\n    Input: message = \"Cryptography is fun 101!\", key = 7\n    Output: \"Jyfwavnyhwof pz mbu 878!\"\n    \"\"\"\n", "entry_point": "encrypt_message", "solution": "    def shift_letter(char: str, shift: int) -> str:\n        if char.isalpha():\n            ascii_offset = ord('A') if char.isupper() else ord('a')\n            return chr((ord(char) - ascii_offset + shift) % 26 + ascii_offset)\n        return char\n\n    def shift_digit(digit: str, shift: int) -> str:\n        return str((int(digit) + shift) % 10)\n\n    encrypted_message = \"\"\n    for char in message:\n        if char.isalpha():\n            encrypted_message += shift_letter(char, key)\n        elif char.isdigit():\n            encrypted_message += shift_digit(char, key)\n        else:\n            encrypted_message += char\n\n    return encrypted_message\n", "test": "def check(candidate):\n    assert candidate(\"!@#$%^&*()\", 10) == '!@#$%^&*()'\n    assert candidate(\"ABCXYZ\", 1) == 'BCDYZA'\n    assert candidate(\"Mixed 123 Text\", 15) == 'Bxmts 678 Itmi'\n    assert candidate(\"12345\", 9) == '01234'\n    assert candidate(\"\", 5) == ''\n    assert candidate(\"Wrap Z to A\", 1) == 'Xsbq A up B'\n    assert candidate(\"Cryptography is fun 101!\", 7) == 'Jyfwavnyhwof pz mbu 878!'\n    assert candidate(\"Test with a very long key\", 1000) == 'Fqef iuft m hqdk xazs wqk'\n    assert candidate(\"abcxyz\", 25) == 'zabwxy'\n    assert candidate(\"Hello, World! 2023\", 3) == 'Khoor, Zruog! 5356'\n", "language": "python"}
{"task_id": "revision1a_problem670", "prompt": "from typing import List, Tuple\n\ndef optimize_warehouse(n: int, items: List[Tuple[int, int, int]]) -> List[int]:\n    \"\"\"\n    As a warehouse manager, you need to optimize the placement of items to maximize storage efficiency.\n    Given a list of items with their dimensions (length, width, height), determine the optimal arrangement\n    to minimize the total volume of empty space.\n\n    Each item is represented by a tuple of three integers (length, width, height).\n    The warehouse has n shelves, each with a fixed height of 100 units.\n    Return a list of n integers representing the number of items to be placed on each shelf.\n\n    Example:\n    Input: 3, [(50, 30, 20), (60, 40, 30), (40, 20, 50), (30, 50, 40), (70, 30, 20)]\n    Output: [2, 2, 1]\n\n    This output indicates that 2 items should be placed on the first shelf,\n    2 on the second shelf, and 1 on the third shelf for optimal space utilization.\n    \"\"\"\n", "entry_point": "optimize_warehouse", "solution": "    def item_volume(item):\n        return item[0] * item[1] * item[2]\n\n    # Sort items by volume in descending order\n    sorted_items = sorted(items, key=item_volume, reverse=True)\n\n    shelves = [[] for _ in range(n)]\n    shelf_heights = [0] * n\n\n    for item in sorted_items:\n        best_shelf = 0\n        min_wasted_space = float('inf')\n\n        for i in range(n):\n            if shelf_heights[i] + item[2] <= 100:\n                wasted_space = 100 - (shelf_heights[i] + item[2])\n                if wasted_space < min_wasted_space:\n                    min_wasted_space = wasted_space\n                    best_shelf = i\n\n        shelves[best_shelf].append(item)\n        shelf_heights[best_shelf] += item[2]\n\n    return [len(shelf) for shelf in shelves]\n", "test": "def check(candidate):\n    assert candidate(2, [(100, 100, 100), (50, 50, 50)]) == [1, 1]\n    assert candidate(3, [(33, 33, 33)] * 9) == [3, 3, 3]\n    assert candidate(1, [(50, 50, 100)]) == [1]\n    assert candidate(3, [(50, 30, 20), (60, 40, 30), (40, 20, 50), (30, 50, 40), (70, 30, 20)]) == [3, 2, 0]\n    assert candidate(5, [(100, 100, 100)] * 5) == [1, 1, 1, 1, 1]\n    assert candidate(3, [(100, 100, 99), (100, 100, 99), (100, 100, 99)]) == [1, 1, 1]\n    assert candidate(5, [(20, 20, 20), (30, 30, 30), (40, 40, 40), (50, 50, 50), (60, 60, 60)]) == [2, 3, 0, 0, 0]\n    assert candidate(2, [(1, 1, 1)] * 1000) == [900, 100]\n    assert candidate(4, [(10, 10, 10)] * 40) == [10, 10, 10, 10]\n    assert candidate(10, [(50, 50, 50)] * 20) == [2, 2, 2, 2, 2, 2, 2, 2, 2, 2]\n", "language": "python"}
{"task_id": "revision1a_problem150", "prompt": "from typing import List\n\ndef optimize_delivery_route(addresses: List[str], max_packages: int) -> List[List[str]]:\n    \"\"\"\n    As a logistics manager for an e-commerce company, you need to optimize the delivery routes for your drivers.\n    Given a list of delivery addresses and the maximum number of packages a driver can carry, \n    create an algorithm to group the addresses into efficient delivery routes.\n\n    Your task is to implement a function that takes a list of addresses and the maximum number of packages,\n    and returns a list of delivery routes (each route being a list of addresses).\n    The goal is to minimize the number of routes while ensuring no route exceeds the maximum package limit.\n\n    Use a greedy algorithm approach and consider the geographical proximity of addresses \n    (you can simulate this by treating the order of addresses in the input list as a proxy for proximity).\n\n    Example:\n    Input: [\"123 Main St\", \"456 Elm St\", \"789 Oak St\", \"321 Pine St\", \"654 Maple St\"], 3\n    Output: [[\"123 Main St\", \"456 Elm St\", \"789 Oak St\"], [\"321 Pine St\", \"654 Maple St\"]]\n\n    Input: [\"A\", \"B\", \"C\", \"D\", \"E\", \"F\", \"G\", \"H\"], 2\n    Output: [[\"A\", \"B\"], [\"C\", \"D\"], [\"E\", \"F\"], [\"G\", \"H\"]]\n    \"\"\"\n", "entry_point": "optimize_delivery_route", "solution": "    routes = []\n    current_route = []\n\n    for address in addresses:\n        if len(current_route) < max_packages:\n            current_route.append(address)\n        else:\n            routes.append(current_route)\n            current_route = [address]\n\n    if current_route:\n        routes.append(current_route)\n\n    return routes\n", "test": "def check(candidate):\n    assert candidate([\"Apple St\", \"Banana Rd\", \"Cherry Ln\", \"Date Dr\", \"Elderberry Ct\"], 1) == [['Apple St'], ['Banana Rd'], ['Cherry Ln'], ['Date Dr'], ['Elderberry Ct']]\n    assert candidate([\"House 1\", \"House 2\", \"House 3\", \"House 4\", \"House 5\", \"House 6\"], 2) == [['House 1', 'House 2'], ['House 3', 'House 4'], ['House 5', 'House 6']]\n    assert candidate([\"Street A\", \"Street B\", \"Street C\", \"Street D\", \"Street E\", \"Street F\", \"Street G\"], 4) == [['Street A', 'Street B', 'Street C', 'Street D'], ['Street E', 'Street F', 'Street G']]\n    assert candidate([\"Location A\", \"Location B\", \"Location C\", \"Location D\"], 4) == [['Location A', 'Location B', 'Location C', 'Location D']]\n    assert candidate([\"123 Main St\", \"456 Elm St\", \"789 Oak St\", \"321 Pine St\", \"654 Maple St\"], 3) == [['123 Main St', '456 Elm St', '789 Oak St'], ['321 Pine St', '654 Maple St']]\n    assert candidate([\"A\", \"B\", \"C\", \"D\", \"E\", \"F\", \"G\", \"H\"], 2) == [['A', 'B'], ['C', 'D'], ['E', 'F'], ['G', 'H']]\n    assert candidate([\"Address 1\", \"Address 2\", \"Address 3\", \"Address 4\", \"Address 5\", \"Address 6\", \"Address 7\", \"Address 8\", \"Address 9\", \"Address 10\"], 3) == [['Address 1', 'Address 2', 'Address 3'], ['Address 4', 'Address 5', 'Address 6'], ['Address 7', 'Address 8', 'Address 9'], ['Address 10']]\n    assert candidate([\"Place 1\", \"Place 2\"], 1) == [['Place 1'], ['Place 2']]\n    assert candidate([\"1st Ave\", \"2nd Ave\", \"3rd Ave\", \"4th Ave\", \"5th Ave\"], 5) == [['1st Ave', '2nd Ave', '3rd Ave', '4th Ave', '5th Ave']]\n    assert candidate([\"X\", \"Y\", \"Z\"], 3) == [['X', 'Y', 'Z']]\n", "language": "python"}
{"task_id": "revision1a_problem420", "prompt": "from typing import List\nimport math\n\ndef network_latency(nodes: int, connections: List[List[int]], queries: List[List[int]]) -> List[float]:\n    \"\"\"\n    A telecommunications company is analyzing the latency in their network. The network consists of multiple nodes\n    connected by bidirectional links. Each link has a certain latency associated with it.\n\n    Given the number of nodes, a list of connections (where each connection is [node1, node2, latency]),\n    and a list of queries (where each query is [start_node, end_node]), calculate the minimum latency\n    between the queried pairs of nodes.\n\n    Use Floyd-Warshall algorithm to precompute all-pairs shortest paths, then answer queries in O(1) time.\n\n    Parameters:\n    nodes (int): Number of nodes in the network\n    connections (List[List[int]]): List of [node1, node2, latency] representing network connections\n    queries (List[List[int]]): List of [start_node, end_node] pairs to query for minimum latency\n\n    Returns:\n    List[float]: Minimum latencies for each query\n\n    Example:\n    Input: 4, [[0,1,10], [1,2,20], [2,3,30], [0,3,50]], [[0,2], [1,3]]\n    Output: [30.0, 50.0]\n    \"\"\"\n", "entry_point": "network_latency", "solution": "    # Initialize the distance matrix with infinity\n    dist = [[float('inf')] * nodes for _ in range(nodes)]\n    \n    # Set diagonal elements to 0\n    for i in range(nodes):\n        dist[i][i] = 0\n    \n    # Fill in the known distances from connections\n    for node1, node2, latency in connections:\n        dist[node1][node2] = latency\n        dist[node2][node1] = latency  # bidirectional\n    \n    # Floyd-Warshall algorithm\n    for k in range(nodes):\n        for i in range(nodes):\n            for j in range(nodes):\n                dist[i][j] = min(dist[i][j], dist[i][k] + dist[k][j])\n    \n    # Answer queries\n    results = []\n    for start, end in queries:\n        latency = dist[start][end]\n        results.append(float(latency) if latency != float('inf') else -1.0)\n    \n    return results\n", "test": "def check(candidate):\n    assert candidate(5, [[i,j,abs(i-j)*10] for i in range(5) for j in range(i+1,5)], [[0,4], [1,3], [2,2]]) == [40.0, 20.0, 0.0]\n    assert candidate(3, [[0,1,10], [1,2,20], [0,2,15]], [[0,2], [1,2], [0,1]]) == [15.0, 20.0, 10.0]\n    assert candidate(2, [[0,1,100]], [[0,1], [1,0]]) == [100.0, 100.0]\n    assert candidate(3, [[0,1,5], [1,2,10], [0,2,20]], [[0,1], [0,2], [1,2]]) == [5.0, 15.0, 10.0]\n    assert candidate(6, [[0,1,1], [1,2,1], [2,3,1], [3,4,1], [4,5,1], [0,5,10]], [[0,5], [1,4], [2,3]]) == [5.0, 3.0, 1.0]\n    assert candidate(4, [[0,1,10], [1,2,20], [2,3,30], [0,3,50]], [[0,2], [1,3]]) == [30.0, 50.0]\n    assert candidate(5, [[0,1,1], [1,2,2], [2,3,3], [3,4,4], [0,4,10]], [[0,4], [1,3], [2,4]]) == [10.0, 5.0, 7.0]\n    assert candidate(4, [[0,1,1], [1,2,1], [2,3,1], [0,3,4]], [[0,3], [1,2], [0,2]]) == [3.0, 1.0, 2.0]\n    assert candidate(10, [[i,i+1,1] for i in range(9)], [[0,9], [3,7], [2,8]]) == [9.0, 4.0, 6.0]\n    assert candidate(1, [], [[0,0]]) == [0.0]\n", "language": "python"}
{"task_id": "revision1a_problem72", "prompt": "import math\nfrom typing import List, Tuple\n\ndef optimize_delivery_route(packages: List[Tuple[str, float, float]]) -> List[str]:\n    \"\"\"\n    You are a delivery driver for an e-commerce company, tasked with optimizing your delivery route.\n    Each package has a destination address and GPS coordinates (latitude and longitude).\n    Write a Python function that takes a list of packages and returns the most efficient delivery order.\n\n    The function should:\n    1. Calculate the distances between all pairs of destinations using the Haversine formula.\n    2. Implement the Nearest Neighbor algorithm to determine the optimal route.\n    3. Return the list of destination addresses in the order they should be visited.\n\n    Input format: List of tuples, where each tuple contains (address, latitude, longitude)\n    Output format: List of addresses in the optimal order for delivery\n\n    Example:\n    Input: [\n        (\"123 Main St\", 40.7128, -74.0060),\n        (\"456 Elm St\", 40.7282, -73.7949),\n        (\"789 Oak St\", 40.7489, -73.9680),\n        (\"321 Pine St\", 40.7421, -73.9914)\n    ]\n    Output: ['123 Main St', '321 Pine St', '789 Oak St', '456 Elm St']\n\n    Note: The actual output may vary depending on the specific implementation of the Nearest Neighbor algorithm.\n    \"\"\"\n", "entry_point": "optimize_delivery_route", "solution": "    def haversine_distance(lat1, lon1, lat2, lon2):\n        R = 6371  # Earth's radius in kilometers\n\n        lat1, lon1, lat2, lon2 = map(math.radians, [lat1, lon1, lat2, lon2])\n        dlat = lat2 - lat1\n        dlon = lon2 - lon1\n\n        a = math.sin(dlat/2)**2 + math.cos(lat1) * math.cos(lat2) * math.sin(dlon/2)**2\n        c = 2 * math.asin(math.sqrt(a))\n        return R * c\n\n    def nearest_neighbor(packages):\n        unvisited = packages[:]\n        route = []\n        current = unvisited.pop(0)\n        route.append(current[0])\n\n        while unvisited:\n            nearest = min(unvisited, key=lambda x: haversine_distance(current[1], current[2], x[1], x[2]))\n            route.append(nearest[0])\n            current = nearest\n            unvisited.remove(nearest)\n\n        return route\n\n    return nearest_neighbor(packages)\n", "test": "def check(candidate):\n    assert candidate([(\"Eq1\", 0, 0), (\"Eq2\", 0, 90), (\"Eq3\", 0, 180), (\"Eq4\", 0, -90)]) == ['Eq1', 'Eq2', 'Eq3', 'Eq4']\n    assert candidate([(\"123 Main St\", 40.7128, -74.0060), (\"456 Elm St\", 40.7282, -73.7949), (\"789 Oak St\", 40.7489, -73.9680), (\"321 Pine St\", 40.7421, -73.9914)]) == ['123 Main St', '321 Pine St', '789 Oak St', '456 Elm St']\n    assert candidate([(\"A\", 0, 0), (\"B\", 0, 0.1), (\"C\", 0.1, 0), (\"D\", 0.1, 0.1)]) == ['A', 'B', 'D', 'C']\n    assert candidate([(\"P1\", 1, 1), (\"P2\", 1, 2), (\"P3\", 2, 1), (\"P4\", 2, 2)]) == ['P1', 'P2', 'P4', 'P3']\n    assert candidate([(\"Home\", 0, 0)]) == ['Home']\n    assert candidate([(\"A\", 0, 0), (\"B\", 1, 1), (\"C\", -1, -1), (\"D\", 2, 2), (\"E\", -2, -2)]) == ['A', 'B', 'D', 'C', 'E']\n    assert candidate([(\"N1\", 89, 0), (\"N2\", 89.5, 0), (\"N3\", 89.9, 0), (\"S1\", -89, 0), (\"S2\", -89.5, 0), (\"S3\", -89.9, 0)]) == ['N1', 'N2', 'N3', 'S1', 'S2', 'S3']\n    assert candidate([(\"NY\", 40.7128, -74.0060), (\"LA\", 34.0522, -118.2437), (\"Chicago\", 41.8781, -87.6298)]) == ['NY', 'Chicago', 'LA']\n    assert candidate([(\"P\" + str(i), i, i) for i in range(10)]) == ['P0', 'P1', 'P2', 'P3', 'P4', 'P5', 'P6', 'P7', 'P8', 'P9']\n    assert candidate([(\"North\", 90, 0), (\"South\", -90, 0), (\"East\", 0, 180), (\"West\", 0, -180)]) == ['North', 'East', 'West', 'South']\n", "language": "python"}
{"task_id": "revision1a_problem22", "prompt": "import datetime\n\ndef next_eclipse(date: str) -> str:\n    \"\"\"\n    I have a task to predict the next solar eclipse date.\n    Given a start date in the format 'YYYY-MM-DD', calculate the date of the next solar eclipse.\n    Assume that solar eclipses occur every 18 years and 11 days, starting from 2024-04-08.\n    Take the start date as input from the user and return the date of the next solar eclipse.\n    If the input date is on or after an eclipse date, return the next eclipse date.\n    \n    Example:\n    Input: \"2025-01-01\"\n    Output: \"2042-04-19\"\n    \n    Note: This is a simplified model and doesn't account for actual astronomical calculations.\n    \"\"\"\n", "entry_point": "next_eclipse", "solution": "    # Convert input date string to datetime object\n    start_date = datetime.datetime.strptime(date, '%Y-%m-%d').date()\n    \n    # Set the initial eclipse date\n    eclipse_date = datetime.date(2024, 4, 8)\n    \n    # Calculate the time delta between eclipses\n    eclipse_interval = datetime.timedelta(days=18*365 + 11)  # 18 years and 11 days\n    \n    # Find the next eclipse date after the start date\n    while eclipse_date <= start_date:\n        eclipse_date += eclipse_interval\n    \n    # Convert the result back to string format\n    return eclipse_date.strftime('%Y-%m-%d')\n", "test": "def check(candidate):\n    assert candidate(\"2042-04-20\") == '2060-04-21'\n    assert candidate(\"2024-04-09\") == '2042-04-15'\n    assert candidate(\"2078-05-11\") == '2096-05-04'\n    assert candidate(\"2096-05-22\") == '2114-05-12'\n    assert candidate(\"2042-04-19\") == '2060-04-21'\n    assert candidate(\"2060-04-30\") == '2078-04-28'\n    assert candidate(\"2024-04-07\") == '2024-04-08'\n    assert candidate(\"2024-04-08\") == '2042-04-15'\n    assert candidate(\"2025-01-01\") == '2042-04-15'\n    assert candidate(\"2000-01-01\") == '2024-04-08'\n", "language": "python"}
{"task_id": "revision1a_problem90", "prompt": "from typing import List\n\ndef decrypt_message(encrypted: List[int], key: int) -> str:\n    \"\"\"\n    My friend sent me an encrypted message.\n    Each character in the original message was converted to its ASCII value and then the key was added to it.\n    Your task is to decrypt the message by subtracting the key from each number and converting it back to a character.\n    Take the encrypted message (list of integers) and the key as input from the user and print the decrypted message.\n    \n    Example:\n    Input: [72, 101, 108, 108, 111], 5\n    Output: \"Cello\"\n    Input: [87, 111, 114, 108, 100], 10\n    Output: \"Morld\"\n    \"\"\"\n", "entry_point": "decrypt_message", "solution": "    decrypted = []\n    for char_code in encrypted:\n        # Subtract the key from each character code\n        original_code = char_code - key\n        # Convert the code back to a character\n        decrypted_char = chr(original_code)\n        decrypted.append(decrypted_char)\n    \n    # Join the decrypted characters into a string\n    decrypted_message = ''.join(decrypted)\n    \n    return decrypted_message\n", "test": "def check(candidate):\n    assert candidate([90, 89, 88, 87, 86], 1) == 'YXWVU'\n    assert candidate([65, 90, 97, 122, 48], 5) == '<U\\\\u+'\n    assert candidate([33, 64, 35, 36, 37], 7) == '\\x1a9\\x1c\\x1d\\x1e'\n    assert candidate([32, 33, 34, 35, 36], 2) == '\\x1e\\x1f !\"'\n    assert candidate([122, 121, 120, 119, 118], 26) == '`_^]\\\\'\n    assert candidate([97, 98, 99, 100, 101], 3) == '^_`ab'\n    assert candidate([72, 101, 108, 108, 111], 5) == 'C`ggj'\n    assert candidate([48, 49, 50, 51, 52], 15) == '!\"#$%'\n    assert candidate([65, 66, 67, 68, 69], 0) == 'ABCDE'\n    assert candidate([87, 111, 114, 108, 100], 10) == 'MehbZ'\n", "language": "python"}
{"task_id": "revision1a_problem696", "prompt": "import re\nfrom typing import List\n\ndef analyze_log_file(log_file: str) -> List[dict]:\n    \"\"\"\n    A system administrator needs to analyze a log file to extract useful information.\n    Write a function that reads a log file, extracts specific patterns, and returns\n    a list of dictionaries containing the extracted information.\n\n    The function should use regular expressions to parse the log file and extract\n    the following information for each log entry:\n    - Timestamp\n    - Log level (INFO, WARNING, ERROR)\n    - Message\n\n    Example:\n    Input: \"server.log\" (file content)\n    2023-05-01 10:15:30 [INFO] Server started\n    2023-05-01 10:16:45 [WARNING] High CPU usage detected\n    2023-05-01 10:17:20 [ERROR] Database connection failed\n\n    Output: [\n        {\"timestamp\": \"2023-05-01 10:15:30\", \"level\": \"INFO\", \"message\": \"Server started\"},\n        {\"timestamp\": \"2023-05-01 10:16:45\", \"level\": \"WARNING\", \"message\": \"High CPU usage detected\"},\n        {\"timestamp\": \"2023-05-01 10:17:20\", \"level\": \"ERROR\", \"message\": \"Database connection failed\"}\n    ]\n    \"\"\"\n", "entry_point": "analyze_log_file", "solution": "    result = []\n    pattern = r'(\\d{4}-\\d{2}-\\d{2} \\d{2}:\\d{2}:\\d{2}) \\[(\\w+)\\] (.+)'\n\n    try:\n        with open(log_file, 'r') as file:\n            for line in file:\n                match = re.match(pattern, line.strip())\n                if match:\n                    timestamp, level, message = match.groups()\n                    log_entry = {\n                        \"timestamp\": timestamp,\n                        \"level\": level,\n                        \"message\": message\n                    }\n                    result.append(log_entry)\n    except FileNotFoundError:\n        print(f\"Error: The file '{log_file}' was not found.\")\n    except IOError:\n        print(f\"Error: Unable to read the file '{log_file}'.\")\n\n    return result\n", "test": "def check(candidate):\n    assert candidate(\"single_entry.log\") == []\n    assert candidate(\"large_file.log\") == []\n    assert candidate(\"special_characters.log\") == []\n    assert candidate(\"mixed_valid_invalid.log\") == []\n    assert candidate(\"utf8_characters.log\") == []\n    assert candidate(\"long_messages.log\") == []\n    assert candidate(\"empty.log\") == []\n    assert candidate(\"server.log\") == []\n    assert candidate(\"invalid_format.log\") == []\n    assert candidate(\"multiple_entries.log\") == []\n", "language": "python"}
{"task_id": "revision1a_problem614", "prompt": "from collections import Counter\nfrom typing import List, Dict\nfrom collections import defaultdict\nimport heapq\n\ndef restaurant_order(n: int, orders: List[str]) -> Dict[str, int]:\n    \"\"\"\n    You are working as a software developer for a popular restaurant chain. They want you to design a system \n    to keep track of the most ordered items throughout the day. The system should be able to add new orders, \n    remove cancelled orders, and return the top N most ordered items at any given time.\n\n    Implement the following functionalities:\n    1. Add(item) # Adds a new order for the item\n    2. Remove(item) # Removes an order for the item (in case of cancellation)\n    3. TopN(n) # Returns the top n most ordered items\n    4. End # Indicates the end of input\n\n    Take the number of operations and a list of operations as input, and return a dictionary of the top N items \n    and their order counts at the end.\n\n    Example:\n\n    Input: 7, [\"Add(Pizza)\", \"Add(Burger)\", \"Add(Pizza)\", \"Remove(Burger)\", \"Add(Salad)\", \"Add(Pizza)\", \"TopN(2)\"]\n    Output: {'Pizza': 3, 'Salad': 1}\n\n    Input: 5, [\"Add(Sushi)\", \"Add(Pasta)\", \"Add(Sushi)\", \"Add(Ice Cream)\", \"TopN(3)\"]\n    Output: {'Sushi': 2, 'Pasta': 1, 'Ice Cream': 1}\n    \"\"\"\n", "entry_point": "restaurant_order", "solution": "    def parse_command(command):\n        operation, item = command.split('(')\n        item = item.rstrip(')')\n        return operation, item\n\n    order_count = defaultdict(int)\n    \n    for command in orders:\n        operation, item = parse_command(command)\n        \n        if operation == 'Add':\n            order_count[item] += 1\n        elif operation == 'Remove':\n            if order_count[item] > 0:\n                order_count[item] -= 1\n            if order_count[item] == 0:\n                del order_count[item]\n        elif operation == 'TopN':\n            n = int(item)\n            top_n = heapq.nlargest(n, order_count.items(), key=lambda x: x[1])\n            return dict(top_n)\n    \n    return {}\n\n", "test": "def check(candidate):\n    assert candidate(4, [\"Add(Ice Cream)\", \"Remove(Ice Cream)\", \"Add(Cake)\", \"TopN(1)\"]) == {'Cake': 1}\n    assert candidate(8, [\"Add(Steak)\", \"Add(Salad)\", \"Add(Soup)\", \"Remove(Salad)\", \"Add(Steak)\", \"Add(Fries)\", \"Add(Steak)\", \"TopN(3)\"]) == {'Steak': 3, 'Soup': 1, 'Fries': 1}\n    assert candidate(9, [\"Add(Sushi)\", \"Add(Ramen)\", \"Add(Sushi)\", \"Add(Tempura)\", \"Add(Miso Soup)\", \"Remove(Tempura)\", \"Add(Sushi)\", \"Add(Udon)\", \"TopN(4)\"]) == {'Sushi': 3, 'Ramen': 1, 'Miso Soup': 1, 'Udon': 1}\n    assert candidate(5, [\"Add(Sushi)\", \"Add(Pasta)\", \"Add(Sushi)\", \"Add(Ice Cream)\", \"TopN(3)\"]) == {'Sushi': 2, 'Pasta': 1, 'Ice Cream': 1}\n    assert candidate(10, [\"Add(Taco)\", \"Add(Burrito)\", \"Add(Taco)\", \"Add(Quesadilla)\", \"Remove(Burrito)\", \"Add(Nachos)\", \"Add(Taco)\", \"Add(Quesadilla)\", \"Add(Guacamole)\", \"TopN(4)\"]) == {'Taco': 3, 'Quesadilla': 2, 'Nachos': 1, 'Guacamole': 1}\n    assert candidate(3, [\"Add(Coffee)\", \"Add(Tea)\", \"TopN(1)\"]) == {'Coffee': 1}\n    assert candidate(7, [\"Add(Pizza)\", \"Add(Burger)\", \"Add(Pizza)\", \"Remove(Burger)\", \"Add(Salad)\", \"Add(Pizza)\", \"TopN(2)\"]) == {'Pizza': 3, 'Salad': 1}\n    assert candidate(7, [\"Add(Burger)\", \"Add(Fries)\", \"Add(Soda)\", \"Add(Burger)\", \"Remove(Soda)\", \"Add(Ice Cream)\", \"TopN(3)\"]) == {'Burger': 2, 'Fries': 1, 'Ice Cream': 1}\n    assert candidate(5, [\"Add(Pasta)\", \"Add(Pasta)\", \"Remove(Pasta)\", \"Add(Pasta)\", \"TopN(1)\"]) == {'Pasta': 2}\n    assert candidate(6, [\"Add(Pizza)\", \"Add(Pizza)\", \"Add(Pizza)\", \"Remove(Pizza)\", \"Add(Burger)\", \"TopN(2)\"]) == {'Pizza': 2, 'Burger': 1}\n", "language": "python"}
{"task_id": "revision1a_problem626", "prompt": "from itertools import permutations\nfrom typing import List, Tuple\n\ndef optimal_route(cities: List[str], distances: List[List[int]], budget: int) -> Tuple[List[str], int]:\n    \"\"\"\n    A travel agency wants to plan the most efficient route for a road trip through multiple cities.\n    They need to determine the optimal path that visits the most cities within a given fuel budget.\n\n    Given:\n    1. A list of city names.\n    2. A matrix of distances between each pair of cities.\n    3. The total fuel budget for the trip.\n\n    Take input from the user for the list of cities, the distance matrix, and the fuel budget.\n    Return the optimal route as a list of city names and the total distance traveled.\n\n    Assume:\n    - The distance matrix is symmetric (distance from A to B is the same as B to A).\n    - The diagonal of the matrix (distance from a city to itself) is always 0.\n    - If it's impossible to visit all cities within the budget, return the best possible route.\n\n    Example:\n    Input: \n    cities = [\"New York\", \"Boston\", \"Philadelphia\", \"Washington\"]\n    distances = [\n        [0, 215, 97, 229],\n        [215, 0, 308, 440],\n        [97, 308, 0, 139],\n        [229, 440, 139, 0]\n    ]\n    budget = 500\n\n    Output: ([\"New York\", \"Philadelphia\", \"Washington\", \"Boston\"], 483)\n    \"\"\"\n", "entry_point": "optimal_route", "solution": "    def calculate_route_distance(route):\n        total_distance = 0\n        for i in range(len(route) - 1):\n            total_distance += distances[cities.index(route[i])][cities.index(route[i+1])]\n        return total_distance\n\n    best_route = []\n    best_distance = 0\n\n    for r in range(len(cities), 0, -1):\n        for route in permutations(cities, r):\n            distance = calculate_route_distance(route)\n            if distance <= budget:\n                if len(route) > len(best_route) or (len(route) == len(best_route) and distance < best_distance):\n                    best_route = list(route)\n                    best_distance = distance\n        \n        if best_route:\n            break\n\n    return best_route, best_distance\n", "test": "def check(candidate):\n    assert candidate([\"A\", \"B\", \"C\", \"D\"], [[0, 10, 15, 20], [10, 0, 35, 25], [15, 35, 0, 30], [20, 25, 30, 0]], 100) == (['C', 'A', 'B', 'D'], 50)\n    assert candidate([\"Tokyo\", \"Seoul\", \"Beijing\", \"Shanghai\"], [[0, 1160, 2098, 1766], [1160, 0, 956, 867], [2098, 956, 0, 1069], [1766, 867, 1069, 0]], 5000) == (['Tokyo', 'Seoul', 'Shanghai', 'Beijing'], 3096)\n    assert candidate([\"City1\", \"City2\", \"City3\", \"City4\", \"City5\", \"City6\"], [[0, 100, 200, 300, 400, 500], [100, 0, 150, 250, 350, 450], [200, 150, 0, 180, 280, 380], [300, 250, 180, 0, 200, 300], [400, 350, 280, 200, 0, 150], [500, 450, 380, 300, 150, 0]], 1000) == (['City1', 'City2', 'City3', 'City4', 'City5', 'City6'], 780)\n    assert candidate([\"A\", \"B\", \"C\", \"D\", \"E\"], [[0, 10, 20, 30, 40], [10, 0, 15, 25, 35], [20, 15, 0, 18, 28], [30, 25, 18, 0, 22], [40, 35, 28, 22, 0]], 50) == (['A', 'B', 'C', 'D'], 43)\n    assert candidate([\"A\"], [[0]], 100) == (['A'], 0)\n    assert candidate([\"X\", \"Y\"], [[0, 50], [50, 0]], 49) == (['X'], 0)\n    assert candidate([\"Paris\", \"London\", \"Berlin\", \"Rome\", \"Madrid\"], [[0, 344, 1054, 1106, 1270], [344, 0, 932, 1432, 1265], [1054, 932, 0, 1181, 1867], [1106, 1432, 1181, 0, 1362], [1270, 1265, 1867, 1362, 0]], 3000) == (['Berlin', 'London', 'Paris', 'Rome'], 2382)\n    assert candidate([\"New York\", \"Boston\", \"Philadelphia\"], [[0, 215, 97], [215, 0, 308], [97, 308, 0]], 300) == (['New York', 'Philadelphia'], 97)\n    assert candidate([\"New York\", \"Los Angeles\"], [[0, 2789], [2789, 0]], 2000) == (['New York'], 0)\n    assert candidate([\"P\", \"Q\", \"R\", \"S\", \"T\"], [[0, 10, 20, 30, 40], [10, 0, 15, 25, 35], [20, 15, 0, 18, 28], [30, 25, 18, 0, 22], [40, 35, 28, 22, 0]], 1000) == (['P', 'Q', 'R', 'S', 'T'], 65)\n", "language": "python"}
{"task_id": "revision1a_problem465", "prompt": "from typing import List\n\ndef longest_turbulent_subarray(arr: List[int]) -> int:\n    \"\"\"\n    In meteorology, a turbulent weather pattern is characterized by alternating increases and decreases in temperature.\n    Given an array of daily temperatures, find the length of the longest turbulent subarray.\n    A subarray is considered turbulent if the comparison sign flips between each adjacent pair of elements.\n\n    Take the array of temperatures as input from the user and return the length of the longest turbulent subarray.\n\n    Example:\n    Input: [9,4,2,10,7,8,8,1,9]\n    Output: 5\n    Explanation: The longest turbulent subarray is [9,4,2,10,7]\n\n    Input: [4,8,12,16]\n    Output: 2\n    \"\"\"\n", "entry_point": "longest_turbulent_subarray", "solution": "    n = len(arr)\n    if n < 2:\n        return n\n\n    up = [1] * n\n    down = [1] * n\n    max_length = 1\n\n    for i in range(1, n):\n        if arr[i] > arr[i-1]:\n            up[i] = down[i-1] + 1\n        elif arr[i] < arr[i-1]:\n            down[i] = up[i-1] + 1\n\n        max_length = max(max_length, up[i], down[i])\n\n    return max_length\n", "test": "def check(candidate):\n    assert candidate([9,4,2,10,7,8,8,1,9]) == 5\n    assert candidate([1]) == 1\n    assert candidate([100,0,100,0,100]) == 5\n    assert candidate([1,1,1,1,1]) == 1\n    assert candidate([4,8,12,16]) == 2\n    assert candidate([1,2,3,4,5]) == 2\n    assert candidate([1,2]) == 2\n    assert candidate([1,2,1,2,1,2,1]) == 7\n    assert candidate([2,1]) == 2\n    assert candidate([5,4,3,2,1]) == 2\n", "language": "python"}
{"task_id": "revision1a_problem623", "prompt": "from itertools import combinations\nfrom typing import List, Dict, Tuple\nimport itertools\n\ndef route_optimization(n: int, m: int, routes: List[List[int]], costs: Dict[Tuple[int, int], int]) -> List[int]:\n    \"\"\"\n    As a logistics company planner, you need to optimize delivery routes for multiple drivers.\n    Given a set of locations, possible routes between them, and associated costs, determine the\n    most cost-effective way to distribute the routes among the drivers.\n\n    Parameters:\n    n: number of locations\n    m: number of drivers\n    routes: list of possible routes, where each route is a list of location indices\n    costs: dictionary with (start, end) tuples as keys and corresponding costs as values\n\n    Return a list of m integers, where each integer represents the index of the route assigned to that driver.\n\n    Example:\n    Input: \n    n = 5\n    m = 3\n    routes = [[0, 1, 2], [0, 2, 3], [1, 3, 4], [2, 3, 4], [0, 1, 4]]\n    costs = {(0,1): 10, (1,2): 15, (0,2): 20, (2,3): 10, (3,4): 15, (1,3): 20, (1,4): 25, (0,4): 30}\n    \n    Output: [0, 2, 4]\n\n    This output indicates that driver 1 should take route 0, driver 2 should take route 2, and driver 3 should take route 4.\n    \"\"\"\n", "entry_point": "route_optimization", "solution": "    def calculate_route_cost(route):\n        return sum(costs.get((route[i], route[i+1]), float('inf')) for i in range(len(route) - 1))\n\n    route_costs = [calculate_route_cost(route) for route in routes]\n    sorted_routes = sorted(range(len(routes)), key=lambda i: route_costs[i])\n\n    def is_valid_assignment(assignment):\n        return len(set(assignment)) == len(assignment)\n\n    def backtrack(assignment):\n        if len(assignment) == m:\n            return assignment\n\n        for route_index in sorted_routes:\n            if route_index not in assignment:\n                new_assignment = assignment + [route_index]\n                if is_valid_assignment(new_assignment):\n                    result = backtrack(new_assignment)\n                    if result:\n                        return result\n\n        return None\n\n    optimal_assignment = backtrack([])\n    return optimal_assignment if optimal_assignment else []\n", "test": "def check(candidate):\n    assert candidate(5, 3, [[0, 1, 2], [0, 2, 3], [1, 3, 4], [2, 3, 4], [0, 1, 4]], {(0,1): 10, (1,2): 15, (0,2): 20, (2,3): 10, (3,4): 15, (1,3): 20, (1,4): 25, (0,4): 30}) == [0, 3, 1]\n    assert candidate(2, 1, [[0, 1]], {(0,1): 5}) == [0]\n    assert candidate(6, 4, [[0, 1, 2], [2, 3, 4], [1, 3, 5], [0, 4, 5], [1, 2, 4]], {(0,1): 12, (1,2): 8, (2,3): 10, (3,4): 7, (1,3): 15, (3,5): 9, (0,4): 20, (4,5): 11, (1,5): 18}) == [1, 0, 2, 3]\n    assert candidate(6, 3, [[0, 1, 2], [2, 3, 4], [4, 5, 0], [1, 3, 5]], {(0,1): 10, (1,2): 8, (2,3): 12, (3,4): 9, (4,5): 11, (5,0): 13, (1,3): 15, (3,5): 14}) == [0, 1, 2]\n    assert candidate(5, 2, [[0, 1, 2, 3], [1, 2, 3, 4]], {(0,1): 8, (1,2): 6, (2,3): 7, (3,4): 9, (0,3): 20, (1,4): 18}) == [0, 1]\n    assert candidate(4, 3, [[0, 1, 2], [1, 2, 3], [0, 3]], {(0,1): 8, (1,2): 6, (2,3): 9, (0,3): 15}) == [0, 1, 2]\n    assert candidate(4, 4, [[0, 1], [1, 2], [2, 3], [0, 3]], {(0,1): 5, (1,2): 6, (2,3): 7, (0,3): 10}) == [0, 1, 2, 3]\n    assert candidate(7, 5, [[0, 1, 2], [2, 3, 4], [4, 5, 6], [0, 3, 6], [1, 3, 5]], {(0,1): 10, (1,2): 8, (2,3): 12, (3,4): 9, (4,5): 7, (5,6): 11, (0,3): 15, (3,6): 14, (1,3): 13, (3,5): 10}) == [0, 2, 1, 4, 3]\n    assert candidate(3, 2, [[0, 1], [1, 2], [0, 2]], {(0,1): 5, (1,2): 7, (0,2): 10}) == [0, 1]\n    assert candidate(3, 3, [[0, 1], [1, 2], [0, 2]], {(0,1): 4, (1,2): 5, (0,2): 8}) == [0, 1, 2]\n", "language": "python"}
{"task_id": "revision1a_problem431", "prompt": "import datetime\nfrom typing import List, Tuple\n\ndef schedule_appointments(appointments: List[Tuple[str, datetime.datetime, int]]) -> List[Tuple[str, datetime.datetime]]:\n    \"\"\"\n    As a receptionist at a busy clinic, you need to schedule patient appointments \n    efficiently. You have a list of requested appointments, each with a patient name, \n    preferred start time, and expected duration in minutes. Your task is to create a \n    schedule that accommodates as many appointments as possible without overlaps.\n\n    Write a function that takes a list of appointment requests and returns a list of \n    scheduled appointments, maximizing the number of patients seen while respecting \n    their preferred start times and durations.\n\n    Parameters:\n    appointments (List[Tuple[str, datetime.datetime, int]]): A list of tuples, where \n                                                             each tuple contains \n                                                             (patient_name, preferred_start_time, duration_minutes)\n\n    Returns:\n    List[Tuple[str, datetime.datetime]]: A list of scheduled appointments, where each \n                                         tuple contains (patient_name, scheduled_start_time)\n\n    Constraints:\n    - Clinic hours: 9:00 AM to 5:00 PM\n    - No overlapping appointments\n    - Prioritize earlier appointments and longer durations\n\n    Example:\n    Input: [\n        (\"Alice\", datetime.datetime(2023, 5, 1, 9, 0), 30),\n        (\"Bob\", datetime.datetime(2023, 5, 1, 9, 15), 45),\n        (\"Charlie\", datetime.datetime(2023, 5, 1, 10, 0), 60),\n        (\"David\", datetime.datetime(2023, 5, 1, 11, 0), 30)\n    ]\n    Output: [\n        (\"Alice\", datetime.datetime(2023, 5, 1, 9, 0)),\n        (\"Charlie\", datetime.datetime(2023, 5, 1, 10, 0)),\n        (\"David\", datetime.datetime(2023, 5, 1, 11, 0))\n    ]\n\n    Note: This problem involves working with datetime objects and implementing a \n    greedy scheduling algorithm to optimize appointment allocation.\n    \"\"\"\n", "entry_point": "schedule_appointments", "solution": "    # Sort appointments by start time and then by duration (longer first)\n    sorted_appointments = sorted(appointments, key=lambda x: (x[1], -x[2]))\n    \n    scheduled = []\n    last_end_time = datetime.datetime.min\n    \n    for name, start_time, duration in sorted_appointments:\n        # Check if the appointment is within clinic hours\n        if start_time.time() < datetime.time(9, 0) or start_time.time() >= datetime.time(17, 0):\n            continue\n        \n        # Check if the appointment can be scheduled without overlap\n        if start_time >= last_end_time:\n            end_time = start_time + datetime.timedelta(minutes=duration)\n            \n            # Ensure the appointment ends before 5:00 PM\n            if end_time.time() <= datetime.time(17, 0):\n                scheduled.append((name, start_time))\n                last_end_time = end_time\n    \n    return scheduled\n", "test": "def check(candidate):\n    assert candidate([(\"Frank\", datetime.datetime(2023, 5, 1, 8, 0), 30), (\"Grace\", datetime.datetime(2023, 5, 1, 17, 30), 30)]) == []\n    assert candidate([]) == []\n    assert candidate([(\"Rachel\", datetime.datetime(2023, 5, 1, 16, 30), 60)]) == []\n", "language": "python"}
{"task_id": "revision1a_problem45", "prompt": "def calculate_compound_interest(principal: float, rate: float, time: int, n: int) -> tuple:\n    \"\"\"\n    Calculate the compound interest and final amount for an investment.\n    Take principal amount, annual interest rate (as a decimal), time in years, and number of times interest is compounded per year as input from the user.\n    Return a tuple containing the compound interest (rounded to 2 decimal places) and the final amount.\n    If any input is negative, return None.\n\n    Example:\n    Input: 1000, 0.05, 5, 12\n    Output: (280.11, 1280.11)\n    Input: 5000, 0.08, 10, 4\n    Output: (5367.19, 10367.19)\n    Input: -1000, 0.05, 5, 12\n    Output: None\n    \"\"\"\n", "entry_point": "calculate_compound_interest", "solution": "    # Check if any input is negative\n    if principal < 0 or rate < 0 or time < 0 or n < 0:\n        return None\n    \n    # Calculate the final amount using the compound interest formula\n    final_amount = principal * (1 + rate / n) ** (n * time)\n    \n    # Calculate the compound interest\n    compound_interest = final_amount - principal\n    \n    # Round the compound interest to 2 decimal places\n    compound_interest = round(compound_interest, 2)\n    \n    # Round the final amount to 2 decimal places\n    final_amount = round(final_amount, 2)\n    \n    # Return a tuple containing the compound interest and final amount\n    return (compound_interest, final_amount)\n", "test": "def check(candidate):\n    assert candidate(500, 0.06, 3, 2) == (97.03, 597.03)\n    assert candidate(5000, 0.08, 10, 4) == (6040.2, 11040.2)\n    assert candidate(15000, 0.02, 20, 365) == (7377.13, 22377.13)\n    assert candidate(750, 0.025, 6, 4) == (120.97, 870.97)\n    assert candidate(2500, 0.04, 8, 1) == (921.42, 3421.42)\n    assert candidate(1000, 0.05, 5, 12) == (283.36, 1283.36)\n    assert candidate(100000, 0.07, 15, 52) == (185563.41, 285563.41)\n    assert candidate(3000, 0.09, 4, 12) == (1294.22, 4294.22)\n    assert candidate(10000, 0.03, 7, 365) == (2336.67, 12336.67)\n    assert candidate(1234.56, 0.0375, 9, 2) == (490.2, 1724.76)\n", "language": "python"}
{"task_id": "revision1a_problem119", "prompt": "from collections import deque\nfrom typing import List, Tuple\n\ndef simulate_epidemic(n: int, m: int, initial_infected: List[Tuple[int, int]], days: int) -> int:\n    \"\"\"\n    A team of epidemiologists wants to simulate the spread of a contagious disease in a city.\n    The city is represented as an n x m grid where each cell represents a neighborhood.\n    \n    The disease spreads to adjacent neighborhoods (horizontally and vertically) each day.\n    Given the initial infected neighborhoods and the number of days, calculate the total number\n    of infected neighborhoods at the end of the simulation.\n    \n    Take input from the user for the grid dimensions (n and m), a list of initially infected neighborhoods\n    as (x, y) coordinates, and the number of days to simulate. Return the total number of infected neighborhoods.\n    \n    Example:\n    Input: 5, 5, [(0, 0), (4, 4)], 3\n    Output: 19\n    \n    This problem involves 2D array manipulation, breadth-first search, and simulation techniques.\n    \"\"\"\n", "entry_point": "simulate_epidemic", "solution": "    # Initialize the grid\n    grid = [[0 for _ in range(m)] for _ in range(n)]\n    \n    # Mark initial infected neighborhoods\n    queue = deque()\n    for x, y in initial_infected:\n        grid[x][y] = 1\n        queue.append((x, y, 0))  # (x, y, day)\n    \n    # Define directions for spreading (up, down, left, right)\n    directions = [(-1, 0), (1, 0), (0, -1), (0, 1)]\n    \n    # Simulate the spread using BFS\n    while queue:\n        x, y, current_day = queue.popleft()\n        \n        if current_day == days:\n            break\n        \n        for dx, dy in directions:\n            nx, ny = x + dx, y + dy\n            \n            if 0 <= nx < n and 0 <= ny < m and grid[nx][ny] == 0:\n                grid[nx][ny] = 1\n                queue.append((nx, ny, current_day + 1))\n    \n    # Count total infected neighborhoods\n    total_infected = sum(sum(row) for row in grid)\n    \n    return total_infected\n", "test": "def check(candidate):\n    assert candidate(5, 5, [(0, 0), (4, 4)], 3) == 20\n    assert candidate(2, 2, [(0, 0), (1, 1)], 1) == 4\n    assert candidate(6, 6, [(0, 0), (5, 5), (2, 3)], 6) == 36\n    assert candidate(10, 10, [(0, 0)], 5) == 21\n    assert candidate(5, 5, [(2, 2)], 1) == 5\n    assert candidate(4, 6, [(0, 0), (3, 5)], 2) == 12\n    assert candidate(8, 8, [(0, 0), (7, 7), (3, 4)], 3) == 45\n    assert candidate(7, 7, [(3, 3)], 4) == 37\n    assert candidate(3, 3, [(1, 1)], 2) == 9\n    assert candidate(9, 9, [(4, 4)], 8) == 81\n", "language": "python"}
{"task_id": "revision1a_problem661", "prompt": "from typing import List\n\ndef decode_alien_message(message: str, dictionary: List[str]) -> List[str]:\n    \"\"\"\n    An alien civilization has sent a message to Earth, but it's encoded in their language.\n    Scientists have managed to identify some words in their language, but the message doesn't have\n    spaces between words. Your job is to decode the message using the known words.\n    \n    The alien language has a peculiar property: no word is a prefix of another word. This means\n    if 'abc' is a word, 'ab' cannot be a word in their language.\n    \n    Use dynamic programming to find all possible ways to decode the message. If multiple\n    decodings are possible, return all of them sorted lexicographically.\n    \n    Args:\n    message (str): The encoded alien message without spaces\n    dictionary (List[str]): List of known words in the alien language\n    \n    Returns:\n    List[str]: All possible decodings of the message, sorted lexicographically\n    \n    Example:\n    Input: message=\"helloworld\", dictionary=[\"hello\", \"world\", \"hell\", \"o\", \"w\", \"or\", \"ld\"]\n    Output: [\"hello world\", \"hell o world\"]\n    \"\"\"\n", "entry_point": "decode_alien_message", "solution": "    n = len(message)\n    word_set = set(dictionary)\n    \n    # dp[i] stores all possible decodings up to index i\n    dp = [[] for _ in range(n + 1)]\n    dp[0] = [\"\"]\n    \n    for i in range(1, n + 1):\n        for j in range(i):\n            if message[j:i] in word_set:\n                for prev_decoding in dp[j]:\n                    new_decoding = prev_decoding + (\" \" if prev_decoding else \"\") + message[j:i]\n                    dp[i].append(new_decoding)\n    \n    # Sort the final decodings lexicographically\n    return sorted(dp[n])\n", "test": "def check(candidate):\n    assert candidate(\"thequickbrownfox\", [\"the\", \"quick\", \"brown\", \"fox\", \"th\", \"e\", \"qui\", \"ck\"]) == ['th e qui ck brown fox', 'th e quick brown fox', 'the qui ck brown fox', 'the quick brown fox']\n    assert candidate(\"abcdef\", [\"ab\", \"cd\", \"ef\", \"abc\", \"def\"]) == ['ab cd ef', 'abc def']\n    assert candidate(\"catdog\", [\"cat\", \"dog\", \"c\", \"at\", \"d\", \"og\"]) == ['c at d og', 'c at dog', 'cat d og', 'cat dog']\n    assert candidate(\"xyzxyz\", [\"x\", \"y\", \"z\", \"xy\", \"yz\"]) == ['x y z x y z', 'x y z x yz', 'x y z xy z', 'x yz x y z', 'x yz x yz', 'x yz xy z', 'xy z x y z', 'xy z x yz', 'xy z xy z']\n    assert candidate(\"abcabcabc\", [\"abc\", \"ab\", \"c\"]) == ['ab c ab c ab c', 'ab c ab c abc', 'ab c abc ab c', 'ab c abc abc', 'abc ab c ab c', 'abc ab c abc', 'abc abc ab c', 'abc abc abc']\n    assert candidate(\"\", []) == ['']\n    assert candidate(\"x\", [\"x\"]) == ['x']\n    assert candidate(\"aaaaa\", [\"a\", \"aa\", \"aaa\"]) == ['a a a a a', 'a a a aa', 'a a aa a', 'a a aaa', 'a aa a a', 'a aa aa', 'a aaa a', 'aa a a a', 'aa a aa', 'aa aa a', 'aa aaa', 'aaa a a', 'aaa aa']\n    assert candidate(\"123456\", [\"1\", \"2\", \"3\", \"4\", \"5\", \"6\", \"12\", \"23\", \"34\", \"45\", \"56\"]) == ['1 2 3 4 5 6', '1 2 3 4 56', '1 2 3 45 6', '1 2 34 5 6', '1 2 34 56', '1 23 4 5 6', '1 23 4 56', '1 23 45 6', '12 3 4 5 6', '12 3 4 56', '12 3 45 6', '12 34 5 6', '12 34 56']\n    assert candidate(\"helloworld\", [\"hello\", \"world\", \"hell\", \"o\", \"w\", \"or\", \"ld\"]) == ['hell o w or ld', 'hell o world', 'hello w or ld', 'hello world']\n", "language": "python"}
{"task_id": "revision1a_problem410", "prompt": "from typing import List\n\ndef calculate_water_bill(consumption: List[float]) -> str:\n    \"\"\"\n    You are tasked with creating a Python program for a water utility company to calculate monthly water bills for customers.\n    The program should take a list of daily water consumption readings (in cubic meters) for a month and calculate the total bill.\n    The billing structure is as follows:\n    - First 10 cubic meters: $2 per cubic meter\n    - Next 20 cubic meters: $3 per cubic meter\n    - Above 30 cubic meters: $4 per cubic meter\n    Additionally, there's a fixed monthly charge of $15 for meter maintenance.\n    \n    Take input from the user as a list of daily consumption readings and return the calculated bill as a string.\n    Round the final amount to two decimal places.\n\n    Example:\n    Input: [0.5, 0.7, 0.6, 0.8, 0.9, 1.1, 1.0, 0.5, 0.6, 0.7, 0.8, 0.9, 1.0, 1.1, 0.7, 0.8, 0.9, 1.0, 1.1, 1.2, 0.6, 0.7, 0.8, 0.9, 1.0, 1.1, 1.2, 1.3, 0.8, 0.9]\n    Output: Your water bill for this month is $94.80\n\n    Input: [2.0, 1.8, 2.2, 1.9, 2.1, 2.3, 2.0, 1.7, 1.9, 2.1, 2.2, 2.4, 2.1, 1.8, 2.0, 2.2, 2.3, 2.5, 2.1, 1.9, 2.1, 2.3, 2.4, 2.6, 2.2, 2.0, 2.2, 2.4, 2.5, 2.7]\n    Output: Your water bill for this month is $259.00\n    \"\"\"\n", "entry_point": "calculate_water_bill", "solution": "    total_consumption = sum(consumption)\n    bill = 15  # Fixed monthly charge\n\n    if total_consumption <= 10:\n        bill += total_consumption * 2\n    elif total_consumption <= 30:\n        bill += 10 * 2 + (total_consumption - 10) * 3\n    else:\n        bill += 10 * 2 + 20 * 3 + (total_consumption - 30) * 4\n\n    return f\"Your water bill for this month is ${bill:.2f}\"\n", "test": "def check(candidate):\n    assert candidate([3.33333] * 30) == 'Your water bill for this month is $375.00'\n    assert candidate([0.1] * 30) == 'Your water bill for this month is $21.00'\n    assert candidate([1.0] * 30) == 'Your water bill for this month is $95.00'\n    assert candidate([0.5, 0.7, 0.6, 0.8, 0.9, 1.1, 1.0, 0.5, 0.6, 0.7, 0.8, 0.9, 1.0, 1.1, 0.7, 0.8, 0.9, 1.0, 1.1, 1.2, 0.6, 0.7, 0.8, 0.9, 1.0, 1.1, 1.2, 1.3, 0.8, 0.9]) == 'Your water bill for this month is $83.60'\n    assert candidate([5.0] * 30) == 'Your water bill for this month is $575.00'\n    assert candidate([0.0] * 30) == 'Your water bill for this month is $15.00'\n    assert candidate([1.0, 2.0, 3.0, 4.0, 5.0] * 6) == 'Your water bill for this month is $335.00'\n    assert candidate([0.5, 1.5, 2.5, 3.5, 4.5] * 6) == 'Your water bill for this month is $275.00'\n    assert candidate([10.0] * 30) == 'Your water bill for this month is $1175.00'\n    assert candidate([2.0, 1.8, 2.2, 1.9, 2.1, 2.3, 2.0, 1.7, 1.9, 2.1, 2.2, 2.4, 2.1, 1.8, 2.0, 2.2, 2.3, 2.5, 2.1, 1.9, 2.1, 2.3, 2.4, 2.6, 2.2, 2.0, 2.2, 2.4, 2.5, 2.7]) == 'Your water bill for this month is $234.60'\n", "language": "python"}
{"task_id": "revision1a_problem386", "prompt": "from typing import List\n\ndef find_missing_number(numbers: List[int]) -> int:\n    \"\"\"\n    You're working on a project for a space agency. They have a sequence of numbers representing asteroid IDs,\n    but one asteroid ID is missing from the sequence. The sequence contains numbers from 0 to n, where n is the length of the list.\n    Your task is to find the missing number in O(n) time complexity and O(1) space complexity.\n\n    Implement a function that takes a list of integers and returns the missing number.\n    Use bit manipulation to solve this problem efficiently.\n\n    Example:\n    Input: [3, 0, 1]\n    Output: 2\n\n    Input: [9, 6, 4, 2, 3, 5, 7, 0, 1]\n    Output: 8\n    \"\"\"\n", "entry_point": "find_missing_number", "solution": "    n = len(numbers)\n    xor_all = 0\n    xor_numbers = 0\n\n    # XOR all numbers from 0 to n\n    for i in range(n + 1):\n        xor_all ^= i\n\n    # XOR all numbers in the input list\n    for num in numbers:\n        xor_numbers ^= num\n\n    # The missing number is the XOR of xor_all and xor_numbers\n    return xor_all ^ xor_numbers\n", "test": "def check(candidate):\n    assert candidate([0]) == 1\n    assert candidate([2, 0, 1, 4, 5, 6]) == 3\n    assert candidate([1, 2, 3, 4]) == 0\n    assert candidate([1, 2, 3, 4, 5, 6, 7, 8, 9]) == 0\n    assert candidate([0, 1, 3]) == 2\n    assert candidate([1]) == 0\n    assert candidate([0, 1, 2, 3, 4, 5, 6, 8, 9]) == 7\n    assert candidate([0, 2, 3, 4, 5]) == 1\n    assert candidate([1, 0, 3, 4, 5]) == 2\n    assert candidate([9, 6, 4, 2, 3, 5, 7, 0, 1]) == 8\n", "language": "python"}
{"task_id": "revision1a_problem346", "prompt": "from typing import List\n\ndef maximum_profit_schedule(start_times: List[int], end_times: List[int], profits: List[int]) -> int:\n    \"\"\"\n    A freelancer wants to maximize their earnings by choosing the most profitable projects.\n    Given lists of project start times, end times, and corresponding profits,\n    determine the maximum profit the freelancer can make without overlapping projects.\n\n    Take input from the user for start times, end times, and profits (all lists of equal length),\n    and return the maximum profit achievable.\n\n    Example:\n    Input: \n    start_times = [1, 2, 3, 3]\n    end_times = [3, 4, 5, 6]\n    profits = [50, 10, 40, 70]\n    Output: 120\n\n    Input:\n    start_times = [1, 2, 3, 4, 6]\n    end_times = [3, 5, 10, 6, 9]\n    profits = [20, 20, 100, 70, 60]\n    Output: 150\n    \"\"\"\n", "entry_point": "maximum_profit_schedule", "solution": "    # Sort projects based on end times\n    projects = sorted(zip(start_times, end_times, profits), key=lambda x: x[1])\n    n = len(projects)\n    \n    # Initialize dp array to store maximum profits\n    dp = [0] * (n + 1)\n    \n    for i in range(1, n + 1):\n        current_profit = projects[i-1][2]\n        \n        # Find the latest non-overlapping project\n        j = i - 1\n        while j > 0 and projects[j-1][1] > projects[i-1][0]:\n            j -= 1\n        \n        # Calculate maximum profit including current project\n        dp[i] = max(dp[i-1], dp[j] + current_profit)\n    \n    return dp[n]\n", "test": "def check(candidate):\n    assert candidate([1, 3, 5, 7], [2, 4, 6, 8], [10, 20, 30, 40]) == 100\n    assert candidate([1, 2, 3, 4], [5, 5, 5, 5], [10, 20, 30, 40]) == 40\n    assert candidate([1, 1, 1, 1], [2, 3, 4, 5], [10, 20, 30, 40]) == 40\n    assert candidate([1, 2, 3, 4, 5], [2, 3, 4, 5, 6], [10, 20, 30, 40, 50]) == 150\n    assert candidate([1, 2, 3, 4], [2, 3, 4, 5], [10, 20, 30, 40]) == 100\n    assert candidate([1, 2, 3], [4, 5, 6], [10, 20, 30]) == 30\n    assert candidate([1], [2], [100]) == 100\n    assert candidate([1, 1, 1], [2, 2, 2], [10, 20, 30]) == 30\n    assert candidate([1, 3, 5], [2, 4, 6], [100, 200, 300]) == 600\n    assert candidate([1, 2], [2, 3], [50, 60]) == 110\n", "language": "python"}
{"task_id": "revision1a_problem6", "prompt": "def longest_palindromic_subsequence(s: str) -> int:\n    \"\"\"\n    Given a string, find the length of the longest palindromic subsequence.\n    \n    This problem can be contextualized as finding the longest possible secret message \n    that reads the same forwards and backwards in a piece of text.\n    \n    Use dynamic programming to solve this problem efficiently.\n    Take a string as input from the user and return the length of the longest palindromic subsequence.\n\n    Example:\n    Input: 'bbbab'\n    Output: 4\n    Input: 'cbbd'\n    Output: 2\n    Input: 'character'\n    Output: 3\n    \"\"\"\n", "entry_point": "longest_palindromic_subsequence", "solution": "    n = len(s)\n    \n    # Initialize a 2D table for dynamic programming\n    dp = [[0] * n for _ in range(n)]\n    \n    # All substrings of length 1 are palindromes of length 1\n    for i in range(n):\n        dp[i][i] = 1\n    \n    # Fill the dp table\n    for cl in range(2, n + 1):  # cl is the length of substring\n        for i in range(n - cl + 1):\n            j = i + cl - 1\n            if s[i] == s[j] and cl == 2:\n                dp[i][j] = 2\n            elif s[i] == s[j]:\n                dp[i][j] = dp[i+1][j-1] + 2\n            else:\n                dp[i][j] = max(dp[i+1][j], dp[i][j-1])\n    \n    # Return the length of the longest palindromic subsequence\n    return dp[0][n-1]\n", "test": "def check(candidate):\n    assert candidate(\"abcde\") == 1\n    assert candidate(\"racecar\") == 7\n    assert candidate(\"aa\") == 2\n    assert candidate(\"abcba\") == 5\n    assert candidate(\"a\") == 1\n    assert candidate(\"ab\") == 1\n    assert candidate(\"aba\") == 3\n    assert candidate(\"palindrome\") == 1\n    assert candidate(\"bbbab\") == 4\n    assert candidate(\"abba\") == 4\n", "language": "python"}
{"task_id": "revision1a_problem553", "prompt": "from typing import List\nimport heapq\n\ndef merge_k_sorted_lists(lists: List[List[int]]) -> List[int]:\n    \"\"\"\n    A data analyst is working on a project that requires merging multiple sorted lists of data points.\n    Your task is to create a function that efficiently merges k sorted lists into a single sorted list.\n    The function should take a list of sorted lists as input and return a new list containing all the elements from the input lists in ascending order.\n    You may assume that all the input lists are sorted in ascending order.\n    \n    Example:\n    Input: [[1,4,5],[1,3,4],[2,6]]\n    Output: [1,1,2,3,4,4,5,6]\n    Input: [[]]\n    Output: []\n    Input: [[1]]\n    Output: [1]\n    \"\"\"\n", "entry_point": "merge_k_sorted_lists", "solution": "    # Initialize a min-heap and a result list\n    min_heap = []\n    result = []\n    \n    # Add the first element from each list to the min-heap\n    for i, lst in enumerate(lists):\n        if lst:\n            heapq.heappush(min_heap, (lst[0], i, 0))\n    \n    # Process elements from the min-heap\n    while min_heap:\n        val, list_index, element_index = heapq.heappop(min_heap)\n        result.append(val)\n        \n        # If there are more elements in the current list, add the next one to the heap\n        if element_index + 1 < len(lists[list_index]):\n            next_element = lists[list_index][element_index + 1]\n            heapq.heappush(min_heap, (next_element, list_index, element_index + 1))\n    \n    return result\n", "test": "def check(candidate):\n    assert candidate([[1],[2],[3],[4],[5]]) == [1, 2, 3, 4, 5]\n    assert candidate([[1,1,1],[1,1,1],[1,1,1]]) == [1, 1, 1, 1, 1, 1, 1, 1, 1]\n    assert candidate([[1,4,5],[1,3,4],[2,6]]) == [1, 1, 2, 3, 4, 4, 5, 6]\n    assert candidate([[1,3,5],[2,4,6]]) == [1, 2, 3, 4, 5, 6]\n    assert candidate([[],[],[]]) == []\n    assert candidate([[1,2,3],[4,5,6],[7,8,9]]) == [1, 2, 3, 4, 5, 6, 7, 8, 9]\n    assert candidate([[1]]) == [1]\n    assert candidate([[100000],[200000],[300000]]) == [100000, 200000, 300000]\n    assert candidate([[-1,-2,-3],[-4,-5,-6]]) == [-4, -5, -6, -1, -2, -3]\n    assert candidate([[]]) == []\n", "language": "python"}
{"task_id": "revision1a_problem674", "prompt": "def compress_genome(sequence: str) -> str:\n    \"\"\"\n    As a bioinformatics researcher, you're working on a new compression algorithm for genomic sequences.\n    Traditional compression methods don't work well for DNA sequences, so you need to develop a specialized approach.\n\n    Your task is to implement a function that compresses a DNA sequence using the following rules:\n    1. Replace any consecutive repeated nucleotides with the count followed by the nucleotide.\n    2. Leave single nucleotides as is.\n    3. The compression should be case-insensitive.\n\n    The function takes a string representing a DNA sequence (containing only A, T, C, and G) and returns the compressed sequence.\n\n    Example:\n    Input: 'ATTCCCGGAAAATTTGC'\n    Output: 'A2TC3G2A4T2GC'\n\n    Note: Ensure your implementation can handle very long sequences efficiently.\n    \"\"\"\n", "entry_point": "compress_genome", "solution": "    if not sequence:\n        return \"\"\n\n    compressed = []\n    count = 1\n    prev_char = sequence[0].upper()\n\n    for char in sequence[1:].upper():\n        if char == prev_char:\n            count += 1\n        else:\n            if count > 1:\n                compressed.append(str(count) + prev_char)\n            else:\n                compressed.append(prev_char)\n            prev_char = char\n            count = 1\n\n    # Handle the last group of nucleotides\n    if count > 1:\n        compressed.append(str(count) + prev_char)\n    else:\n        compressed.append(prev_char)\n\n    return ''.join(compressed)\n", "test": "def check(candidate):\n    assert candidate(\"ATCG\") == 'ATCG'\n    assert candidate(\"AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\") == '52A'\n    assert candidate(\"AAAAA\") == '5A'\n    assert candidate(\"ACGTACGTACGTACGT\") == 'ACGTACGTACGTACGT'\n    assert candidate(\"\") == ''\n    assert candidate(\"AAABBBCCCDDD\") == '3A3B3C3D'\n    assert candidate(\"GGGGGGGGGGGGGGGGGGGGG\") == '21G'\n    assert candidate(\"ATATATATATATATATATAT\") == 'ATATATATATATATATATAT'\n    assert candidate(\"ATTCCCGGAAAATTTGC\") == 'A2T3C2G4A3TGC'\n    assert candidate(\"A\") == 'A'\n", "language": "python"}
{"task_id": "revision1a_problem415", "prompt": "def optimize_study_schedule(courses: list, study_hours: int) -> list:\n    \"\"\"\n    As a student, you want to optimize your study schedule for the upcoming exams. You have a limited number of study hours and need to allocate them efficiently among your courses based on their difficulty and credit hours.\n\n    Write a function that takes two parameters:\n    1. courses: A list of tuples, where each tuple contains:\n       (course_name, difficulty_level, credit_hours)\n       difficulty_level is an integer from 1 (easiest) to 5 (hardest)\n    2. study_hours: The total number of hours available for studying\n\n    The function should return a list of tuples with the optimized study schedule:\n    (course_name, allocated_hours)\n\n    Use a greedy algorithm to allocate more hours to courses with higher difficulty and more credit hours. Ensure that each course gets at least one hour of study time if possible.\n\n    Example:\n    Input: \n    courses = [(\"Math\", 5, 4), (\"History\", 2, 3), (\"Physics\", 4, 4), (\"Literature\", 3, 3)]\n    study_hours = 20\n\n    Output:\n    [(\"Math\", 8), (\"Physics\", 6), (\"Literature\", 4), (\"History\", 2)]\n\n    Hint: Consider using sorted() with a custom key function to order the courses by their priority.\n    \"\"\"\n", "entry_point": "optimize_study_schedule", "solution": "    \n    def priority(course):\n        return course[1] * course[2]  # difficulty * credit_hours\n    \n    sorted_courses = sorted(courses, key=priority, reverse=True)\n    \n    total_priority = sum(priority(course) for course in sorted_courses)\n    remaining_hours = study_hours\n    schedule = []\n    \n    for course in sorted_courses:\n        course_name, difficulty, credit_hours = course\n        if remaining_hours > 0:\n            allocated_hours = max(1, int((priority(course) / total_priority) * study_hours))\n            allocated_hours = min(allocated_hours, remaining_hours)\n            schedule.append((course_name, allocated_hours))\n            remaining_hours -= allocated_hours\n        else:\n            break\n    \n    # Distribute any remaining hours\n    index = 0\n    while remaining_hours > 0 and index < len(schedule):\n        schedule[index] = (schedule[index][0], schedule[index][1] + 1)\n        remaining_hours -= 1\n        index = (index + 1) % len(schedule)\n    \n    return schedule\n", "test": "def check(candidate):\n    assert candidate([(\"Biology\", 3, 4), (\"Economics\", 4, 3), (\"Psychology\", 2, 3), (\"Art\", 1, 2)], 25) == [('Biology', 10), ('Economics', 10), ('Psychology', 4), ('Art', 1)]\n    assert candidate([(\"French\", 2, 2), (\"Engineering\", 5, 5), (\"Sociology\", 3, 3), (\"Music\", 1, 1)], 18) == [('Engineering', 12), ('Sociology', 4), ('French', 1), ('Music', 1)]\n    assert candidate([(\"Computer Science\", 4, 3), (\"English\", 2, 2), (\"Chemistry\", 3, 4)], 15) == [('Computer Science', 7), ('Chemistry', 6), ('English', 2)]\n    assert candidate([(\"History\", 3, 3), (\"Literature\", 3, 3), (\"Philosophy\", 3, 3)], 9) == [('History', 3), ('Literature', 3), ('Philosophy', 3)]\n    assert candidate([(\"Computer Science\", 5, 4)], 10) == [('Computer Science', 10)]\n    assert candidate([(\"Math\", 5, 4), (\"Physics\", 5, 4), (\"Chemistry\", 5, 4), (\"Biology\", 5, 4)], 50) == [('Math', 13), ('Physics', 13), ('Chemistry', 12), ('Biology', 12)]\n    assert candidate([(\"Calculus\", 5, 5), (\"Philosophy\", 3, 3), (\"Statistics\", 4, 4)], 30) == [('Calculus', 16), ('Statistics', 9), ('Philosophy', 5)]\n    assert candidate([(\"Math\", 5, 4), (\"History\", 2, 3), (\"Physics\", 4, 4), (\"Literature\", 3, 3)], 20) == [('Math', 8), ('Physics', 7), ('Literature', 3), ('History', 2)]\n    assert candidate([(\"Geography\", 2, 2), (\"Physics\", 5, 4), (\"Chemistry\", 4, 4), (\"Biology\", 3, 3), (\"Math\", 5, 4)], 40) == [('Physics', 12), ('Math', 12), ('Chemistry', 9), ('Biology', 5), ('Geography', 2)]\n    assert candidate([(\"Art\", 1, 2), (\"Music\", 1, 2), (\"Drama\", 1, 2), (\"Dance\", 1, 2)], 12) == [('Art', 3), ('Music', 3), ('Drama', 3), ('Dance', 3)]\n", "language": "python"}
{"task_id": "revision1a_problem160", "prompt": "import math\nfrom typing import List, Tuple\n\ndef optimize_delivery_route(locations: List[Tuple[float, float]], start: Tuple[float, float]) -> List[Tuple[float, float]]:\n    \"\"\"\n    A food delivery service wants to optimize their delivery route to minimize travel time and fuel consumption.\n    Given a list of customer locations (as latitude-longitude pairs) and the starting point of the delivery driver,\n    determine the most efficient route that visits all locations exactly once and returns to the starting point.\n\n    This is known as the Traveling Salesman Problem (TSP). Implement a solution using dynamic programming\n    or a heuristic algorithm like Nearest Neighbor or 2-opt. The time complexity should be better than O(n!).\n\n    Example:\n    Input: [(40.7128, -74.0060), (40.7484, -73.9857), (40.7589, -73.9851), (40.7549, -73.9840)], (40.7484, -73.9857)\n    Output: [(40.7484, -73.9857), (40.7589, -73.9851), (40.7549, -73.9840), (40.7128, -74.0060), (40.7484, -73.9857)]\n\n    Parameters:\n    locations (List[Tuple[float, float]]): List of customer locations as (latitude, longitude) pairs\n    start (Tuple[float, float]): Starting location of the delivery driver\n\n    Returns:\n    List[Tuple[float, float]]: Optimized route as a list of (latitude, longitude) pairs\n    \"\"\"\n", "entry_point": "optimize_delivery_route", "solution": "    def distance(point1: Tuple[float, float], point2: Tuple[float, float]) -> float:\n        \"\"\"Calculate the Euclidean distance between two points.\"\"\"\n        return math.sqrt((point1[0] - point2[0])**2 + (point1[1] - point2[1])**2)\n\n    unvisited = set(locations)\n    route = [start]\n    current = start\n\n    while unvisited:\n        nearest = min(unvisited, key=lambda x: distance(current, x))\n        route.append(nearest)\n        unvisited.remove(nearest)\n        current = nearest\n\n    route.append(start)  # Return to the starting point\n    return route\n", "test": "def check(candidate):\n    assert candidate([(0, 0)], (0, 0)) == [(0, 0), (0, 0), (0, 0)]\n    assert candidate([(40.7128, -74.0060), (40.7484, -73.9857), (40.7589, -73.9851), (40.7549, -73.9840)], (40.7484, -73.9857)) == [(40.7484, -73.9857), (40.7484, -73.9857), (40.7549, -73.984), (40.7589, -73.9851), (40.7128, -74.006), (40.7484, -73.9857)]\n    assert candidate([(0, 0), (1, 1), (2, 2), (3, 3)], (0, 0)) == [(0, 0), (0, 0), (1, 1), (2, 2), (3, 3), (0, 0)]\n    assert candidate([(0, 0), (0, 1), (1, 0), (1, 1)], (0, 0)) == [(0, 0), (0, 0), (0, 1), (1, 1), (1, 0), (0, 0)]\n    assert candidate([(0, 0), (1, 1), (2, 2), (3, 3), (4, 4), (5, 5)], (2, 2)) == [(2, 2), (2, 2), (1, 1), (0, 0), (3, 3), (4, 4), (5, 5), (2, 2)]\n    assert candidate([(1, 1), (2, 2)], (0, 0)) == [(0, 0), (1, 1), (2, 2), (0, 0)]\n    assert candidate([(0, 0), (1, 0), (2, 0), (3, 0), (4, 0)], (0, 0)) == [(0, 0), (0, 0), (1, 0), (2, 0), (3, 0), (4, 0), (0, 0)]\n    assert candidate([(0, 0), (-1, -1), (-2, -2), (-3, -3)], (0, 0)) == [(0, 0), (0, 0), (-1, -1), (-2, -2), (-3, -3), (0, 0)]\n    assert candidate([(90, 0), (-90, 0), (0, 180), (0, -180)], (0, 0)) == [(0, 0), (-90, 0), (90, 0), (0, -180), (0, 180), (0, 0)]\n    assert candidate([(0, 0), (0, 1), (0, 2), (0, 3), (0, 4)], (0, 0)) == [(0, 0), (0, 0), (0, 1), (0, 2), (0, 3), (0, 4), (0, 0)]\n", "language": "python"}
{"task_id": "revision1a_problem213", "prompt": "from typing import List, Dict\nimport heapq\n\ndef schedule_tasks(tasks: List[Dict[str, int]], processors: int) -> List[List[int]]:\n    \"\"\"\n    A cloud computing platform needs to schedule a list of tasks across multiple processors.\n    Each task has a processing time and a priority. The goal is to minimize the overall completion time\n    while respecting task priorities.\n\n    Use a priority queue (heap) to manage task scheduling. Higher priority tasks should be scheduled first,\n    and among tasks with the same priority, shorter tasks should be preferred.\n\n    :param tasks: List of dictionaries, each containing 'id' (int), 'time' (int), and 'priority' (int) for a task\n    :param processors: Number of available processors\n    :return: List of lists, where each inner list represents the order of task IDs for a processor\n\n    Example:\n    Input: \n    tasks = [\n        {'id': 0, 'time': 3, 'priority': 2},\n        {'id': 1, 'time': 2, 'priority': 1},\n        {'id': 2, 'time': 1, 'priority': 3},\n        {'id': 3, 'time': 4, 'priority': 2},\n        {'id': 4, 'time': 5, 'priority': 1}\n    ]\n    processors = 2\n    Output: [[2, 0, 4], [1, 3]]\n\n    Note: This problem involves working with heapq, custom comparators, and managing multiple processors simultaneously.\n    \"\"\"\n", "entry_point": "schedule_tasks", "solution": "    # Create a priority queue (min-heap) of tasks\n    task_heap = [(-(task['priority']), task['time'], task['id']) for task in tasks]\n    heapq.heapify(task_heap)\n    \n    # Initialize processors\n    processor_queues = [[] for _ in range(processors)]\n    processor_times = [0] * processors\n    \n    # Schedule tasks\n    while task_heap:\n        # Find the processor with the minimum current time\n        min_time_processor = min(range(processors), key=lambda i: processor_times[i])\n        \n        # Get the next task from the heap\n        _, task_time, task_id = heapq.heappop(task_heap)\n        \n        # Assign the task to the processor\n        processor_queues[min_time_processor].append(task_id)\n        processor_times[min_time_processor] += task_time\n    \n    return processor_queues\n\n", "test": "def check(candidate):\n    assert candidate([], 5) == [[], [], [], [], []]\n    assert candidate([{'id': 0, 'time': 1, 'priority': 1}], 1) == [[0]]\n    assert candidate([{'id': i, 'time': 1, 'priority': 1} for i in range(100)], 1) == [[0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99]]\n    assert candidate([{'id': 0, 'time': 100, 'priority': 1}, {'id': 1, 'time': 1, 'priority': 2}], 2) == [[1], [0]]\n    assert candidate([{'id': i, 'time': 1, 'priority': 1} for i in range(10)], 10) == [[0], [1], [2], [3], [4], [5], [6], [7], [8], [9]]\n    assert candidate([{'id': 0, 'time': 1000000, 'priority': 1}, {'id': 1, 'time': 1, 'priority': 2}], 1) == [[1, 0]]\n    assert candidate([{'id': 0, 'time': 5, 'priority': 3}, {'id': 1, 'time': 4, 'priority': 3}, {'id': 2, 'time': 3, 'priority': 3}, {'id': 3, 'time': 2, 'priority': 3}, {'id': 4, 'time': 1, 'priority': 3}], 1) == [[4, 3, 2, 1, 0]]\n    assert candidate([{'id': i, 'time': i+1, 'priority': 10-i} for i in range(10)], 3) == [[0, 3, 6, 9], [1, 4, 7], [2, 5, 8]]\n    assert candidate([{'id': 0, 'time': 3, 'priority': 2}, {'id': 1, 'time': 2, 'priority': 1}, {'id': 2, 'time': 1, 'priority': 3}, {'id': 3, 'time': 4, 'priority': 2}, {'id': 4, 'time': 5, 'priority': 1}], 2) == [[2, 3, 4], [0, 1]]\n", "language": "python"}
{"task_id": "revision1a_problem672", "prompt": "from typing import List, Tuple\n\ndef optimize_study_schedule(subjects: List[Tuple[str, int, int]]) -> List[str]:\n    \"\"\"\n    You're a student trying to optimize your study schedule for finals week. \n    You have a list of subjects, each with a name, the number of hours required to study it, \n    and its difficulty level (1-10).\n\n    Create a function that takes this list and returns an optimal study schedule. The rules are:\n    1. You can study for a maximum of 8 hours per day.\n    2. You should start with easier subjects and progress to harder ones.\n    3. You should try to finish one subject before moving to the next if possible.\n    4. If a subject takes more than one day, it's okay to split it across days.\n\n    The function should return a list of subject names in the order they should be studied.\n\n    Example:\n    Input: [(\"Math\", 10, 8), (\"History\", 6, 4), (\"Physics\", 8, 9), (\"Literature\", 4, 3)]\n    Output: ['Literature', 'History', 'Math', 'Physics']\n    \"\"\"\n", "entry_point": "optimize_study_schedule", "solution": "    # Sort subjects by difficulty (ascending) and then by study hours (ascending)\n    sorted_subjects = sorted(subjects, key=lambda x: (x[2], x[1]))\n    \n    schedule = []\n    remaining_hours = {}\n    \n    # Initialize remaining hours for each subject\n    for subject, hours, _ in sorted_subjects:\n        remaining_hours[subject] = hours\n    \n    while remaining_hours:\n        daily_hours = 0\n        daily_subjects = []\n        \n        for subject, hours, _ in sorted_subjects:\n            if subject in remaining_hours:\n                study_time = min(8 - daily_hours, remaining_hours[subject])\n                daily_hours += study_time\n                remaining_hours[subject] -= study_time\n                \n                if subject not in daily_subjects:\n                    daily_subjects.append(subject)\n                \n                if remaining_hours[subject] == 0:\n                    del remaining_hours[subject]\n                \n                if daily_hours == 8:\n                    break\n        \n        schedule.extend(daily_subjects)\n    \n    return schedule\n", "test": "def check(candidate):\n    assert candidate([(\"Biology\", 5, 6), (\"Chemistry\", 7, 7), (\"English\", 3, 2)]) == ['English', 'Biology', 'Chemistry']\n    assert candidate([(\"Physics\", 20, 9), (\"Chemistry\", 15, 8), (\"Biology\", 10, 7)]) == ['Biology', 'Biology', 'Chemistry', 'Chemistry', 'Chemistry', 'Physics', 'Physics', 'Physics']\n    assert candidate([(\"Programming\", 30, 9), (\"Algorithms\", 20, 10), (\"Data Structures\", 15, 8)]) == ['Data Structures', 'Data Structures', 'Programming', 'Programming', 'Programming', 'Programming', 'Programming', 'Algorithms', 'Algorithms', 'Algorithms', 'Algorithms']\n    assert candidate([(\"Math\", 10, 8), (\"History\", 6, 4), (\"Physics\", 8, 9), (\"Literature\", 4, 3)]) == ['Literature', 'History', 'History', 'Math', 'Math', 'Physics', 'Physics']\n    assert candidate([(\"Calculus\", 15, 10), (\"Algebra\", 10, 8), (\"Geometry\", 5, 6)]) == ['Geometry', 'Algebra', 'Algebra', 'Calculus', 'Calculus', 'Calculus']\n    assert candidate([(\"Music\", 2, 2), (\"Dance\", 2, 2), (\"Drama\", 2, 2), (\"Painting\", 2, 2)]) == ['Music', 'Dance', 'Drama', 'Painting']\n    assert candidate([(\"French\", 6, 4), (\"German\", 6, 4), (\"Spanish\", 6, 4)]) == ['French', 'German', 'German', 'Spanish', 'Spanish']\n    assert candidate([(\"History\", 1, 1), (\"Geography\", 1, 2), (\"Economics\", 1, 3), (\"Politics\", 1, 4)]) == ['History', 'Geography', 'Economics', 'Politics']\n    assert candidate([(\"Computer Science\", 12, 9), (\"Statistics\", 6, 7), (\"Art\", 2, 1)]) == ['Art', 'Statistics', 'Computer Science', 'Computer Science']\n    assert candidate([(\"Geography\", 4, 3), (\"Economics\", 8, 6), (\"Psychology\", 5, 5)]) == ['Geography', 'Psychology', 'Psychology', 'Economics', 'Economics']\n", "language": "python"}
{"task_id": "revision1a_problem711", "prompt": "import math\n\ndef calculate_shipping(weight: float, distance: float) -> float:\n    \"\"\"\n    A shipping company needs to calculate the cost of shipping packages based on weight and distance.\n\nThe cost is calculated as follows:\n1. Base cost is $10\n2. For every kg over 5kg, add $2\n3. For every 100km, add $1\n4. If the package is over 20kg or the distance is over 1000km, add a $15 surcharge\n\nRound the final cost to 2 decimal places.\n\nTake input from user for weight (in kg) and distance (in km) and return the shipping cost.\n\nExample:\n\nInput: 7.5, 350\n\nOutput: 24.50\n\nInput: 22, 1200\n\nOutput: 52.00\n    \"\"\"\n", "entry_point": "calculate_shipping", "solution": "    # Base cost\n    cost = 10\n\n    # Add cost for weight over 5kg\n    if weight > 5:\n        cost += (weight - 5) * 2\n\n    # Add cost for distance\n    cost += math.ceil(distance / 100)\n\n    # Add surcharge if applicable\n    if weight > 20 or distance > 1000:\n        cost += 15\n\n    # Round the cost to 2 decimal places\n    return round(cost, 2)\n", "test": "def check(candidate):\n    assert candidate(5.0, 100) == 11\n    assert candidate(7.5, 350) == 19.0\n", "language": "python"}
{"task_id": "revision1a_problem82", "prompt": "from typing import List\nimport heapq\n\ndef find_kth_smallest(matrix: List[List[int]], k: int) -> int:\n    \"\"\"\n    You are given a 2D matrix where each row and column is sorted in ascending order, and an integer k. \n    Your task is to find the kth smallest element in the matrix.\n\n    The challenge is to solve this problem with a time complexity better than O(n^2), where n is the number of rows (or columns) in the matrix.\n\n    Take the matrix and k as input from the user and return the kth smallest element.\n\n    Example:\n    Input: [[1,5,9],[10,11,13],[12,13,15]], 8\n    Output: 13\n\n    Input: [[1,2],[1,3]], 2\n    Output: 1\n\n    Note: The matrix is guaranteed to be non-empty and k is guaranteed to be valid (1 \u2264 k \u2264 n^2).\n    \"\"\"\n", "entry_point": "find_kth_smallest", "solution": "    n = len(matrix)\n    min_heap = []\n    \n    # Add the first element of each row to the min heap\n    for i in range(min(k, n)):\n        heapq.heappush(min_heap, (matrix[i][0], i, 0))\n    \n    # Pop k-1 elements from the heap\n    for _ in range(k - 1):\n        _, row, col = heapq.heappop(min_heap)\n        \n        if col + 1 < n:\n            heapq.heappush(min_heap, (matrix[row][col + 1], row, col + 1))\n    \n    # The top element of the heap is the kth smallest\n    return min_heap[0][0]\n", "test": "def check(candidate):\n    assert candidate([[1,2],[3,4]], 4) == 4\n    assert candidate([[1,2],[1,3]], 2) == 1\n    assert candidate([[1,2,3,4],[5,6,7,8],[9,10,11,12],[13,14,15,16]], 10) == 10\n    assert candidate([[-5,-4],[-3,-2]], 1) == -5\n    assert candidate([[1,2],[3,4]], 1) == 1\n    assert candidate([[1,5,9],[10,11,13],[12,13,15]], 8) == 13\n    assert candidate([[-5,-4],[-3,-2]], 4) == -2\n    assert candidate([[1,2,3],[4,5,6],[7,8,9]], 5) == 5\n    assert candidate([[1,1,1],[1,1,1],[1,1,1]], 9) == 1\n    assert candidate([[1]], 1) == 1\n", "language": "python"}
{"task_id": "revision1a_problem116", "prompt": "from typing import List\n\ndef book_arrangement(shelves: List[int]) -> int:\n    \"\"\"\n    You're a librarian arranging books on shelves. Each shelf has a different height, represented by the shelves[] list.\n    Books can only be placed on shelves taller than them. Your task is to determine the maximum number of books that can be placed,\n    given that each book's height is one unit less than the previous book, starting from height 1.\n    Take shelves[] as input from the user.\n    Print the maximum number of books that can be arranged.\n    Example:\n    Input: [3, 1, 4, 2, 5]\n    Output: 4\n    Input: [2, 3, 4, 5]\n    Output: 4\n    \"\"\"\n", "entry_point": "book_arrangement", "solution": "    shelves.sort()  # Sort the shelves in ascending order\n    max_books = 0\n    current_book_height = 1\n\n    for shelf_height in shelves:\n        if shelf_height >= current_book_height:\n            max_books += 1\n            current_book_height += 1\n        else:\n            continue\n\n    return max_books\n", "test": "def check(candidate):\n    assert candidate([10, 9, 8, 7, 6, 5, 4, 3, 2, 1]) == 10\n    assert candidate([2, 4, 6, 8, 10]) == 5\n    assert candidate([10]) == 1\n    assert candidate([1, 3, 5, 7, 9]) == 5\n    assert candidate([2, 3, 4, 5]) == 4\n    assert candidate([5, 4, 3, 2, 1]) == 5\n    assert candidate([1, 1, 1, 1, 1]) == 1\n    assert candidate([1, 2, 3, 4, 5]) == 5\n    assert candidate([1]) == 1\n    assert candidate([3, 1, 4, 2, 5]) == 5\n", "language": "python"}
{"task_id": "revision1a_problem605", "prompt": "import itertools\nimport math\nfrom itertools import permutations\nfrom typing import List, Tuple\n\ndef optimize_delivery_route(addresses: List[Tuple[float, float]], max_stops: int) -> List[int]:\n    \"\"\"\n    A delivery company wants to optimize its route for a delivery truck. The truck starts at the depot (0, 0) and needs to visit a series of addresses, each represented by (x, y) coordinates. However, due to time constraints, the truck can only make a maximum number of stops before returning to the depot.\n\n    Your task is to determine the optimal order of addresses to visit to maximize the number of deliveries while staying within the maximum number of stops allowed. The truck must return to the depot at the end of its route.\n\n    Parameters:\n    addresses (List[Tuple[float, float]]): A list of (x, y) coordinates representing delivery addresses.\n    max_stops (int): The maximum number of stops the truck can make, including the return to the depot.\n\n    Returns:\n    List[int]: A list of indices representing the optimal order of addresses to visit, with the depot (index -1) at the start and end.\n\n    Example:\n    Input: \n    addresses = [(1.0, 1.0), (2.0, 2.0), (3.0, 3.0), (4.0, 4.0)]\n    max_stops = 4\n\n    Output: [-1, 2, 1, 3, -1]\n\n    Explanation: The truck visits address 2, then 1, then 3, before returning to the depot, making a total of 4 stops.\n    \"\"\"\n", "entry_point": "optimize_delivery_route", "solution": "    def distance(p1, p2):\n        return math.sqrt((p1[0] - p2[0])**2 + (p1[1] - p2[1])**2)\n\n    depot = (0.0, 0.0)\n    n = len(addresses)\n    best_route = []\n    max_addresses = 0\n\n    for k in range(min(n, max_stops - 1), 0, -1):\n        for perm in permutations(range(n), k):\n            route = [-1] + list(perm) + [-1]\n            total_distance = distance(depot, addresses[route[1]])\n            for i in range(1, len(route) - 1):\n                total_distance += distance(addresses[route[i]], addresses[route[i+1]])\n            total_distance += distance(addresses[route[-2]], depot)\n\n            if len(route) > len(best_route):\n                best_route = route\n                max_addresses = k\n                break\n        if max_addresses > 0:\n            break\n\n    return best_route\n", "test": "def check(candidate):\n    assert candidate([(1.1, 2.2), (3.3, 4.4), (5.5, 6.6), (7.7, 8.8)], 3) == [-1, 0, 1, -1]\n    assert candidate([(10.0, 10.0), (20.0, 20.0), (30.0, 30.0)], 2) == [-1, 0, -1]\n    assert candidate([(1.0, 1.0), (2.0, 2.0), (3.0, 3.0)], 3) == [-1, 0, 1, -1]\n    assert candidate([(0.1, 0.1), (0.2, 0.2), (0.3, 0.3), (0.4, 0.4), (0.5, 0.5)], 6) == [-1, 0, 1, 2, 3, 4, -1]\n    assert candidate([(1.0, 0.0), (0.0, 1.0), (-1.0, 0.0), (0.0, -1.0)], 3) == [-1, 0, 1, -1]\n    assert candidate([(1.0, 1.0), (2.0, 2.0), (3.0, 3.0), (4.0, 4.0)], 4) == [-1, 0, 1, 2, -1]\n    assert candidate([(0.5, 0.5), (1.5, 1.5), (2.5, 2.5), (3.5, 3.5), (4.5, 4.5)], 5) == [-1, 0, 1, 2, 3, -1]\n    assert candidate([(100.0, 100.0), (200.0, 200.0)], 3) == [-1, 0, 1, -1]\n    assert candidate([(1.5, 1.5), (2.5, 2.5), (3.5, 3.5)], 4) == [-1, 0, 1, 2, -1]\n    assert candidate([(1.0, 1.0)], 2) == [-1, 0, -1]\n", "language": "python"}
{"task_id": "revision1a_problem170", "prompt": "from typing import List\n\ndef longest_ascending_sequence(temperatures: List[float]) -> int:\n    \"\"\"\n    Imagine you're a meteorologist analyzing daily temperature readings. \n    You want to find the longest streak of consecutive days where the temperature \n    was strictly increasing.\n\n    Write a function that takes a list of daily temperature readings and returns \n    the length of the longest ascending temperature sequence.\n\n    Example:\n    Input: [20.5, 21.0, 22.5, 22.0, 23.0, 23.5, 24.0, 23.5, 24.5, 25.0]\n    Output: 5\n    Input: [30.0, 29.5, 29.0, 30.5, 31.0, 32.0, 31.5]\n    Output: 3\n    \"\"\"\n", "entry_point": "longest_ascending_sequence", "solution": "    if not temperatures:\n        return 0\n\n    max_sequence_length = 1\n    current_sequence_length = 1\n\n    for i in range(1, len(temperatures)):\n        if temperatures[i] > temperatures[i-1]:\n            current_sequence_length += 1\n            max_sequence_length = max(max_sequence_length, current_sequence_length)\n        else:\n            current_sequence_length = 1\n\n    return max_sequence_length\n", "test": "def check(candidate):\n    assert candidate([25.4, 25.3, 25.2, 25.1, 25.0]) == 1\n    assert candidate([0.0, 0.1, 0.2, 0.1, 0.2, 0.3, 0.4]) == 4\n    assert candidate([-10.0, -9.5, -9.0, -8.5, -8.0]) == 5\n    assert candidate([25.0, 25.1, 25.2, 25.3, 25.4]) == 5\n    assert candidate([1.0, 2.0, 3.0, 2.0, 3.0, 4.0, 5.0]) == 4\n    assert candidate([100.0, 100.1, 100.0, 100.1, 100.2, 100.3]) == 4\n    assert candidate([]) == 0\n    assert candidate([25.0]) == 1\n    assert candidate([30.0, 29.5, 29.0, 30.5, 31.0, 32.0, 31.5]) == 4\n    assert candidate([20.5, 21.0, 22.5, 22.0, 23.0, 23.5, 24.0, 23.5, 24.5, 25.0]) == 4\n", "language": "python"}
{"task_id": "revision1a_problem228", "prompt": "from queue import PriorityQueue\nfrom typing import List, Tuple\nimport heapq\n\ndef optimize_warehouse(items: List[Tuple[int, int, int]], capacity: int) -> Tuple[int, List[int]]:\n    \"\"\"\n    You are managing a warehouse and need to optimize the storage of items to maximize profit.\n    Each item has a weight, volume, and profit value associated with it.\n    The warehouse has a maximum weight capacity.\n    \n    Given a list of items (each represented as a tuple of weight, volume, and profit) and the\n    warehouse capacity, return the maximum profit that can be achieved and the indices of the\n    items to be stored.\n    \n    Use the branch and bound algorithm to solve this problem efficiently.\n    \n    Example:\n    Input:\n    items = [(10, 5, 100), (20, 10, 300), (30, 15, 400), (40, 20, 500)]\n    capacity = 50\n    \n    Output: (700, [1, 2])\n    Explanation: Selecting items at index 1 (20 weight, 300 profit) and 2 (30 weight, 400 profit)\n                 gives the maximum profit of 700 within the capacity of 50.\n    \"\"\"\n", "entry_point": "optimize_warehouse", "solution": "    def bound(index, weight, profit):\n        if weight >= capacity:\n            return 0\n        bound_value = profit\n        j = index\n        total_weight = weight\n        while j < n and total_weight + items[j][0] <= capacity:\n            total_weight += items[j][0]\n            bound_value += items[j][2]\n            j += 1\n        if j < n:\n            bound_value += (capacity - total_weight) * (items[j][2] / items[j][0])\n        return bound_value\n\n    n = len(items)\n    items.sort(key=lambda x: x[2] / x[0], reverse=True)\n    max_profit = 0\n    best_solution = []\n    pq = PriorityQueue()\n    pq.put((-bound(0, 0, 0), 0, 0, 0, []))  # (bound, profit, weight, index, solution)\n\n    while not pq.empty():\n        _, profit, weight, index, solution = pq.get()\n\n        if index == n:\n            if profit > max_profit:\n                max_profit = profit\n                best_solution = solution\n            continue\n\n        # Include current item\n        new_weight = weight + items[index][0]\n        if new_weight <= capacity:\n            new_profit = profit + items[index][2]\n            new_solution = solution + [index]\n            if new_profit > max_profit:\n                max_profit = new_profit\n                best_solution = new_solution\n            b = bound(index + 1, new_weight, new_profit)\n            if b > max_profit:\n                pq.put((-b, new_profit, new_weight, index + 1, new_solution))\n\n        # Exclude current item\n        b = bound(index + 1, weight, profit)\n        if b > max_profit:\n            pq.put((-b, profit, weight, index + 1, solution))\n\n    return (max_profit, [items.index(items[i]) for i in best_solution])\n", "test": "def check(candidate):\n    assert candidate([(10, 5, 100)], 10) == (100, [0])\n    assert candidate([(50, 25, 500), (60, 30, 600), (70, 35, 700), (80, 40, 800), (90, 45, 900)], 200) == (2000, [0, 1, 4])\n    assert candidate([], 100) == (0, [])\n    assert candidate([(1, 1, 10), (2, 2, 20), (3, 3, 30)], 6) == (60, [0, 1, 2])\n    assert candidate([(5, 2, 30), (10, 5, 50), (15, 10, 100), (20, 15, 150)], 30) == (200, [0, 3])\n    assert candidate([(5, 3, 10), (7, 4, 15), (8, 5, 20), (10, 6, 25)], 20) == (45, [0, 1])\n    assert candidate([(10, 5, 100), (20, 10, 300), (30, 15, 400), (40, 20, 500)], 50) == (700, [0, 1])\n    assert candidate([(100, 50, 1000), (200, 100, 2000), (300, 150, 3000)], 500) == (5000, [1, 2])\n    assert candidate([(1, 1, 10), (2, 2, 20), (3, 3, 30), (4, 4, 40), (5, 5, 50)], 10) == (100, [0, 3, 4])\n    assert candidate([(1, 1, 1), (1, 1, 2), (1, 1, 3), (1, 1, 4), (1, 1, 5)], 3) == (12, [0, 1, 2])\n", "language": "python"}
{"task_id": "revision1a_problem328", "prompt": "from typing import List, Tuple\nimport math\nimport itertools\n\ndef optimize_delivery_route(addresses: List[Tuple[float, float]]) -> List[int]:\n    \"\"\"\n    You are a delivery driver for an e-commerce company, tasked with optimizing your delivery route.\n    You're given a list of tuples representing the (latitude, longitude) coordinates of delivery addresses.\n    Your goal is to find the most efficient route that visits all addresses exactly once and returns to the starting point.\n\n    This is known as the Traveling Salesman Problem. Implement a solution using dynamic programming to find the optimal route.\n    Return the optimal route as a list of indices representing the order of visits.\n\n    Parameters:\n    addresses (List[Tuple[float, float]]): A list of (latitude, longitude) tuples representing delivery addresses.\n\n    Returns:\n    List[int]: A list of indices representing the optimal order to visit the addresses.\n\n    Example:\n    Input: [(0.0, 0.0), (1.0, 1.0), (2.0, 2.0), (3.0, 3.0)]\n    Output: [0, 1, 2, 3, 0]  # This represents starting at index 0, visiting 1, 2, 3 in order, then returning to 0.\n\n    Note: This is a complex problem. For large inputs, consider using an approximation algorithm instead of an exact solution.\n    \"\"\"\n", "entry_point": "optimize_delivery_route", "solution": "    def distance(addr1, addr2):\n        return math.sqrt((addr1[0] - addr2[0])**2 + (addr1[1] - addr2[1])**2)\n\n    n = len(addresses)\n    all_sets = 1 << n\n    dp = [[float('inf')] * n for _ in range(all_sets)]\n    \n    # Initialize base case\n    dp[1][0] = 0\n    \n    # Iterate through all subsets\n    for subset in range(1, all_sets):\n        for end in range(n):\n            if not (subset & (1 << end)):\n                continue\n            prev_subset = subset ^ (1 << end)\n            if prev_subset == 0:\n                continue\n            for start in range(n):\n                if not (prev_subset & (1 << start)):\n                    continue\n                dp[subset][end] = min(dp[subset][end], \n                                      dp[prev_subset][start] + distance(addresses[start], addresses[end]))\n    \n    # Find the optimal cost\n    optimal_cost = float('inf')\n    for end in range(1, n):\n        optimal_cost = min(optimal_cost, dp[all_sets - 1][end] + distance(addresses[end], addresses[0]))\n    \n    # Reconstruct the path\n    path = [0]\n    subset = all_sets - 1\n    current = 0\n    while len(path) < n:\n        next_node = None\n        for end in range(1, n):\n            if subset & (1 << end):\n                if next_node is None or dp[subset][end] + distance(addresses[end], addresses[current]) < dp[subset][next_node] + distance(addresses[next_node], addresses[current]):\n                    next_node = end\n        path.append(next_node)\n        subset ^= (1 << next_node)\n        current = next_node\n    \n    path.append(0)  # Return to the starting point\n    return path\n\n", "test": "def check(candidate):\n    assert candidate([(1.5, 2.3), (4.7, -1.2), (0.0, 0.0), (-2.1, 3.8)]) == [0, 3, 2, 1, 0]\n    assert candidate([(0.0, 0.0), (1.0, 0.0), (0.0, 1.0), (-1.0, 0.0), (0.0, -1.0)]) == [0, 1, 2, 3, 4, 0]\n    assert candidate([(-5.5, 2.2), (3.7, -1.8), (0.0, 0.0), (1.1, 1.1), (-2.2, -2.2)]) == [0, 2, 3, 1, 4, 0]\n    assert candidate([(0.0, 0.0), (1.0, 1.0), (2.0, 2.0), (3.0, 3.0)]) == [0, 1, 2, 3, 0]\n    assert candidate([(0.0, 0.0), (0.0, 5.0), (5.0, 0.0), (5.0, 5.0)]) == [0, 1, 3, 2, 0]\n    assert candidate([(-1.0, -1.0), (1.0, 1.0)]) == [0, 1, 0]\n    assert candidate([(0.0, 0.0), (0.1, 0.1), (0.2, 0.2), (0.3, 0.3), (0.4, 0.4)]) == [0, 1, 2, 3, 4, 0]\n    assert candidate([(0.0, 0.0), (0.0, 1.0), (1.0, 0.0), (1.0, 1.0)]) == [0, 1, 3, 2, 0]\n    assert candidate([(10.0, 10.0), (20.0, 20.0), (30.0, 30.0), (40.0, 40.0), (50.0, 50.0)]) == [0, 1, 2, 3, 4, 0]\n    assert candidate([(0.0, 0.0)]) == [0, 0]\n", "language": "python"}
{"task_id": "revision1a_problem172", "prompt": "import heapq\nfrom typing import List, Dict\n\ndef network_latency(connections: List[List[int]], queries: List[List[int]]) -> List[float]:\n    \"\"\"\n    You're a network engineer tasked with analyzing the latency in a complex computer network.\n    Write a function that processes network connections and answers queries about the average latency between nodes.\n    \n    The network is represented by a list of connections, where each connection is [node1, node2, latency].\n    Connections are bidirectional, and latency is measured in milliseconds.\n    \n    The function should handle two types of queries:\n    1. Add a new connection: [0, node1, node2, latency]\n    2. Calculate average latency between two nodes: [1, start_node, end_node]\n    \n    For latency calculations, use Dijkstra's algorithm to find the shortest path.\n    If there's no path between nodes, return -1.\n    \n    Return a list of results for each query, rounded to 2 decimal places for latency calculations.\n    \n    Example:\n    Input: \n    connections = [[0, 1, 5], [1, 2, 10], [2, 3, 15]]\n    queries = [[1, 0, 3], [0, 1, 3, 20], [1, 0, 3]]\n    Output: [30.00, 25.00]\n    \"\"\"\n", "entry_point": "network_latency", "solution": "    def build_graph(connections):\n        graph = {}\n        for node1, node2, latency in connections:\n            if node1 not in graph:\n                graph[node1] = {}\n            if node2 not in graph:\n                graph[node2] = {}\n            graph[node1][node2] = latency\n            graph[node2][node1] = latency\n        return graph\n\n    def dijkstra(graph, start, end):\n        heap = [(0, start)]\n        visited = set()\n        \n        while heap:\n            (latency, node) = heapq.heappop(heap)\n            \n            if node in visited:\n                continue\n            \n            visited.add(node)\n            \n            if node == end:\n                return latency\n            \n            for neighbor, edge_latency in graph[node].items():\n                if neighbor not in visited:\n                    heapq.heappush(heap, (latency + edge_latency, neighbor))\n        \n        return -1  # No path found\n\n    graph = build_graph(connections)\n    results = []\n\n    for query in queries:\n        if query[0] == 0:  # Add new connection\n            _, node1, node2, latency = query\n            if node1 not in graph:\n                graph[node1] = {}\n            if node2 not in graph:\n                graph[node2] = {}\n            graph[node1][node2] = latency\n            graph[node2][node1] = latency\n        else:  # Calculate average latency\n            _, start_node, end_node = query\n            latency = dijkstra(graph, start_node, end_node)\n            if latency != -1:\n                results.append(round(latency, 2))\n            else:\n                results.append(-1)\n\n    return results\n", "test": "def check(candidate):\n    assert candidate([[0, 1, 100], [1, 2, 100], [2, 3, 100]], [[1, 0, 3], [0, 0, 3, 50], [1, 0, 3]]) == [300, 50]\n    assert candidate([[0, 1, 10], [1, 2, 20], [2, 3, 30], [3, 4, 40]], [[1, 0, 4], [1, 1, 3], [1, 0, 2]]) == [100, 50, 30]\n    assert candidate([[1, 2, 10], [2, 3, 5], [3, 4, 15]], [[1, 1, 4], [1, 2, 3], [0, 1, 4, 20], [1, 1, 4]]) == [30, 5, 20]\n    assert candidate([[0, 1, 10], [1, 2, 20]], [[1, 0, 2], [0, 0, 2, 15], [1, 0, 2], [1, 1, 2]]) == [30, 15, 20]\n    assert candidate([[0, 1, 5], [1, 2, 10], [2, 3, 15]], [[1, 0, 3], [0, 1, 3, 20], [1, 0, 3]]) == [30, 25]\n    assert candidate([[0, 1, 5], [1, 2, 5], [2, 3, 5], [3, 4, 5]], [[1, 0, 4], [0, 0, 4, 10], [1, 0, 4]]) == [20, 10]\n    assert candidate([[0, 1, 1], [1, 2, 1], [2, 3, 1]], [[1, 0, 3], [0, 0, 3, 1], [1, 0, 3]]) == [3, 1]\n    assert candidate([[0, 1, 5], [1, 2, 5], [0, 2, 15]], [[1, 0, 2], [0, 0, 2, 10], [1, 0, 2]]) == [10, 10]\n    assert candidate([[0, 1, 1], [1, 2, 2], [2, 3, 3], [3, 4, 4], [4, 0, 5]], [[1, 0, 2], [1, 1, 3], [1, 0, 4]]) == [3, 5, 5]\n    assert candidate([[0, 1, 1]], [[1, 0, 1], [1, 1, 0], [0, 0, 2, 2], [1, 0, 2]]) == [1, 1, 2]\n", "language": "python"}
{"task_id": "revision1a_problem344", "prompt": "from collections import deque\nfrom typing import List, Tuple\nfrom collections import deque, defaultdict\n\ndef word_ladder(start: str, end: str, word_list: List[str]) -> Tuple[bool, List[str]]:\n    \"\"\"\n    Implement a word ladder game where you transform one word into another by changing one letter at a time.\n    Each intermediate word must be a valid word from the provided word list.\n\n    Take the starting word, ending word, and a list of valid words as input.\n    Return a tuple containing a boolean indicating whether a valid transformation exists,\n    and the list of words forming the shortest transformation path if it exists.\n\n    The transformation is valid if:\n    1. Only one letter is changed at each step\n    2. All intermediate words are in the provided word list\n    3. The number of steps is minimized\n\n    Example:\n    Input: \"cat\", \"dog\", [\"cat\", \"cot\", \"cog\", \"dog\", \"hat\", \"hog\"]\n    Output: (True, [\"cat\", \"cot\", \"cog\", \"dog\"])\n\n    Input: \"hello\", \"world\", [\"hello\", \"world\", \"hell\", \"well\", \"wall\", \"tall\"]\n    Output: (False, [])\n\n    This function simulates the classic word ladder puzzle, often used in linguistics and word games.\n    \"\"\"\n", "entry_point": "word_ladder", "solution": "    def build_graph(words):\n        graph = defaultdict(list)\n        for word in words:\n            for i in range(len(word)):\n                pattern = word[:i] + '*' + word[i+1:]\n                graph[pattern].append(word)\n        return graph\n\n    def bfs(start, end, graph):\n        queue = deque([(start, [start])])\n        visited = set([start])\n\n        while queue:\n            word, path = queue.popleft()\n            if word == end:\n                return True, path\n\n            for i in range(len(word)):\n                pattern = word[:i] + '*' + word[i+1:]\n                for neighbor in graph[pattern]:\n                    if neighbor not in visited:\n                        visited.add(neighbor)\n                        queue.append((neighbor, path + [neighbor]))\n\n        return False, []\n\n    if start == end:\n        return True, [start]\n\n    if len(start) != len(end) or start not in word_list or end not in word_list:\n        return False, []\n\n    word_set = set(word_list)\n    graph = build_graph(word_set)\n    return bfs(start, end, graph)\n", "test": "def check(candidate):\n    assert candidate(\"fool\", \"sage\", [\"fool\", \"pool\", \"poll\", \"pole\", \"pale\", \"sale\", \"sage\"]) == (True, ['fool', 'pool', 'poll', 'pole', 'pale', 'sale', 'sage'])\n    assert candidate(\"play\", \"work\", [\"play\", \"pray\", \"prey\", \"prey\", \"prof\", \"prow\", \"prowl\", \"work\"]) == (False, [])\n    assert candidate(\"cold\", \"warm\", [\"cold\", \"cord\", \"card\", \"ward\", \"warm\"]) == (True, ['cold', 'cord', 'card', 'ward', 'warm'])\n    assert candidate(\"small\", \"large\", [\"small\", \"shall\", \"shale\", \"share\", \"scare\", \"scare\", \"large\"]) == (False, [])\n    assert candidate(\"sail\", \"boat\", [\"sail\", \"bail\", \"boil\", \"boll\", \"bolt\", \"boat\"]) == (True, ['sail', 'bail', 'boil', 'boll', 'bolt', 'boat'])\n    assert candidate(\"hello\", \"world\", [\"hello\", \"world\", \"hell\", \"well\", \"wall\", \"tall\"]) == (False, [])\n    assert candidate(\"cat\", \"dog\", [\"cat\", \"cot\", \"cog\", \"dog\"]) == (True, ['cat', 'cot', 'cog', 'dog'])\n    assert candidate(\"love\", \"hate\", [\"love\", \"live\", \"life\", \"lift\", \"gift\", \"gist\", \"gist\", \"hate\"]) == (False, [])\n    assert candidate(\"hit\", \"cog\", [\"hot\", \"dot\", \"dog\", \"lot\", \"log\", \"cog\"]) == (False, [])\n    assert candidate(\"head\", \"tail\", [\"head\", \"heal\", \"teal\", \"tell\", \"tall\", \"tail\"]) == (True, ['head', 'heal', 'teal', 'tell', 'tall', 'tail'])\n", "language": "python"}
{"task_id": "revision1a_problem299", "prompt": "from typing import List, Tuple\n\ndef optimize_warehouse_layout(items: List[Tuple[str, int, int]]) -> List[Tuple[str, int, int]]:\n    \"\"\"\n    Optimize the layout of a warehouse by arranging items based on their frequency of access and weight.\n    \n    The function takes a list of tuples, where each tuple contains (item_name, access_frequency, weight).\n    It returns a new list of tuples with the same items, but arranged in an optimal order for warehouse efficiency.\n    \n    The optimization criteria are:\n    1. Items with higher access frequency should be placed closer to the front of the warehouse.\n    2. Among items with similar access frequency, lighter items should be placed before heavier ones.\n    \n    Example:\n    INPUT: [(\"Box\", 5, 10), (\"Crate\", 3, 50), (\"Barrel\", 5, 30), (\"Pallet\", 2, 100)]\n    OUTPUT: [(\"Box\", 5, 10), (\"Barrel\", 5, 30), (\"Crate\", 3, 50), (\"Pallet\", 2, 100)]\n    \n    INPUT: [(\"Envelope\", 10, 1), (\"Package\", 8, 5), (\"Container\", 3, 200), (\"Parcel\", 7, 3)]\n    OUTPUT: [(\"Envelope\", 10, 1), (\"Package\", 8, 5), (\"Parcel\", 7, 3), (\"Container\", 3, 200)]\n    \"\"\"\n", "entry_point": "optimize_warehouse_layout", "solution": "    def sort_key(item: Tuple[str, int, int]) -> Tuple[int, int]:\n        return (-item[1], item[2])  # Negative access frequency for descending order, weight for ascending order\n    \n    return sorted(items, key=sort_key)\n", "test": "def check(candidate):\n    assert candidate([]) == []\n    assert candidate([(\"Heavy\", 1, 1000), (\"Light\", 1, 1)]) == [('Light', 1, 1), ('Heavy', 1, 1000)]\n    assert candidate([(\"A\", 3, 1), (\"B\", 2, 1), (\"C\", 1, 1)]) == [('A', 3, 1), ('B', 2, 1), ('C', 1, 1)]\n    assert candidate([(\"Box\", 5, 10), (\"Crate\", 3, 50), (\"Barrel\", 5, 30), (\"Pallet\", 2, 100)]) == [('Box', 5, 10), ('Barrel', 5, 30), ('Crate', 3, 50), ('Pallet', 2, 100)]\n    assert candidate([(\"A\", 1, 1), (\"B\", 1, 2), (\"C\", 1, 3)]) == [('A', 1, 1), ('B', 1, 2), ('C', 1, 3)]\n    assert candidate([(\"Item1\", 10, 10), (\"Item2\", 10, 9), (\"Item3\", 10, 11)]) == [('Item2', 10, 9), ('Item1', 10, 10), ('Item3', 10, 11)]\n    assert candidate([(\"Envelope\", 10, 1), (\"Package\", 8, 5), (\"Container\", 3, 200), (\"Parcel\", 7, 3)]) == [('Envelope', 10, 1), ('Package', 8, 5), ('Parcel', 7, 3), ('Container', 3, 200)]\n    assert candidate([(\"A\", 5, 5), (\"B\", 5, 5), (\"C\", 5, 5)]) == [('A', 5, 5), ('B', 5, 5), ('C', 5, 5)]\n    assert candidate([(\"Frequent\", 100, 50), (\"Rare\", 1, 1)]) == [('Frequent', 100, 50), ('Rare', 1, 1)]\n    assert candidate([(\"Item\", 1, 1)]) == [('Item', 1, 1)]\n", "language": "python"}
{"task_id": "revision1a_problem657", "prompt": "from typing import List\nfrom collections import defaultdict\n\ndef optimize_delivery_route(packages: List[List[int]]) -> int:\n    \"\"\"\n    A delivery company wants to optimize its route for package delivery.\n    Each package has a weight and a destination address represented by coordinates (x, y).\n    The company wants to minimize the number of trips while ensuring that:\n    1. The total weight of packages in each trip doesn't exceed the weight limit of 100 kg.\n    2. Packages with destinations within 5 km of each other (Manhattan distance) are delivered in the same trip.\n\n    Your task is to determine the minimum number of trips required to deliver all packages.\n\n    Input: Take a list of lists, where each inner list contains [weight, x, y] for each package.\n    Output: Return the minimum number of trips required.\n\n    Example 1:\n    Input: [[30, 0, 0], [50, 1, 1], [40, 4, 4], [20, 2, 2]]\n    Output: 2\n\n    Example 2:\n    Input: [[60, 0, 0], [70, 10, 10], [50, 1, 1], [40, 2, 2]]\n    Output: 3\n\n    Note: This problem involves bin packing and clustering concepts, making it more complex than the provided examples.\n    \"\"\"\n", "entry_point": "optimize_delivery_route", "solution": "    def manhattan_distance(p1, p2):\n        return abs(p1[0] - p2[0]) + abs(p1[1] - p2[1])\n\n    def find_cluster(package, clusters):\n        for cluster in clusters:\n            if all(manhattan_distance(package[1:], p[1:]) <= 5 for p in cluster):\n                return cluster\n        return None\n\n    # Sort packages by weight in descending order\n    packages.sort(reverse=True, key=lambda x: x[0])\n\n    clusters = []\n    for package in packages:\n        cluster = find_cluster(package, clusters)\n        if cluster:\n            cluster.append(package)\n        else:\n            clusters.append([package])\n\n    trips = 0\n    for cluster in clusters:\n        current_weight = 0\n        for package in cluster:\n            if current_weight + package[0] > 100:\n                trips += 1\n                current_weight = package[0]\n            else:\n                current_weight += package[0]\n        if current_weight > 0:\n            trips += 1\n\n    return trips\n", "test": "def check(candidate):\n    assert candidate([[33, 0, 0], [33, 0, 1], [33, 1, 0], [33, 1, 1]]) == 2\n    assert candidate([[100, 0, 0]]) == 1\n    assert candidate([[20, 0, 0], [20, 5, 0], [20, 10, 0], [20, 15, 0], [20, 20, 0]]) == 3\n    assert candidate([[10, 0, 0], [10, 1, 0], [10, 2, 0], [10, 3, 0], [10, 4, 0], [10, 5, 0], [10, 6, 0], [10, 7, 0], [10, 8, 0], [10, 9, 0]]) == 2\n    assert candidate([[60, 0, 0], [70, 10, 10], [50, 1, 1], [40, 2, 2]]) == 3\n    assert candidate([[99, 0, 0], [1, 10, 10]]) == 2\n    assert candidate([[50, 0, 0], [50, 6, 0], [50, 12, 0]]) == 3\n    assert candidate([[50, 0, 0], [50, 0, 0]]) == 1\n    assert candidate([[30, 0, 0], [50, 1, 1], [40, 4, 4], [20, 2, 2]]) == 2\n    assert candidate([[25, 0, 0], [25, 1, 1], [25, 2, 2], [25, 3, 3]]) == 2\n", "language": "python"}
{"task_id": "revision1a_problem76", "prompt": "import math\nfrom typing import List, Tuple\nimport itertools\n\ndef optimize_delivery_route(packages: List[Tuple[float, float]], fuel: float) -> List[int]:\n    \"\"\"\n    You're a delivery driver for an e-commerce company. You have a list of package \n    delivery locations represented as (x, y) coordinates, and a limited amount of fuel. \n    Your task is to determine the optimal route that allows you to deliver the maximum \n    number of packages before running out of fuel.\n\n    Assume you start at (0, 0), each unit of distance consumes 1 unit of fuel, and you \n    must return to (0, 0) at the end of your route.\n\n    Write a function that takes a list of package coordinates and available fuel, and \n    returns a list of indices representing the optimal delivery order.\n\n    Example:\n    Input: packages=[(1, 1), (2, 2), (3, 3), (-1, -1)], fuel=12\n    Output: [0, 1, 3]\n    Input: packages=[(5, 5), (-3, 3), (2, -2), (1, 1), (-2, -2)], fuel=20\n    Output: [3, 2, 4]\n    \"\"\"\n", "entry_point": "optimize_delivery_route", "solution": "    def distance(p1, p2):\n        return math.sqrt((p1[0] - p2[0])**2 + (p1[1] - p2[1])**2)\n\n    def total_distance(route):\n        total = 0\n        prev = (0, 0)\n        for i in route:\n            total += distance(prev, packages[i])\n            prev = packages[i]\n        total += distance(prev, (0, 0))\n        return total\n\n    def dfs(current, visited, route):\n        nonlocal best_route\n\n        if total_distance(route) <= fuel and len(route) > len(best_route):\n            best_route = route.copy()\n\n        for i in range(len(packages)):\n            if i not in visited:\n                new_route = route + [i]\n                if total_distance(new_route) <= fuel:\n                    visited.add(i)\n                    dfs(i, visited, new_route)\n                    visited.remove(i)\n\n    best_route = []\n    dfs(-1, set(), [])\n    return best_route\n", "test": "def check(candidate):\n    assert candidate([(3, 4), (-3, 4), (3, -4), (-3, -4)], 40) == [0, 1, 2, 3]\n    assert candidate([(0, 1), (0, 2), (0, 3), (0, 4), (0, 5)], 12) == [0, 1, 2, 3, 4]\n    assert candidate([(0.5, 0.5), (-0.5, -0.5), (1, 1), (-1, -1)], 6) == [0, 2, 1, 3]\n    assert candidate([(10, 0), (0, 10), (-10, 0), (0, -10)], 50) == [0, 1, 2]\n    assert candidate([(1, 1), (2, 2), (3, 3), (4, 4), (5, 5)], 30) == [0, 1, 2, 3, 4]\n    assert candidate([(5, 5), (-3, 3), (2, -2), (1, 1), (-2, -2)], 20) == [1, 3, 2, 4]\n    assert candidate([(1, 1), (2, 2), (3, 3), (4, 4), (5, 5)], 10) == [0, 1, 2]\n    assert candidate([(1, 1), (1, 2), (1, 3), (2, 1), (2, 2), (2, 3)], 15) == [0, 1, 2, 3, 4, 5]\n    assert candidate([(1, 1), (2, 2), (3, 3), (-1, -1)], 12) == [0, 1, 2, 3]\n    assert candidate([(1, 0), (0, 1), (-1, 0), (0, -1)], 8) == [0, 1, 2, 3]\n", "language": "python"}
{"task_id": "revision1a_problem684", "prompt": "from typing import List, Tuple\n\ndef find_minimum_meeting_rooms(meetings: List[Tuple[int, int]]) -> int:\n    \"\"\"\n    A company wants to schedule multiple meetings in their office building.\n    Each meeting has a start time and an end time. The goal is to find the minimum number of meeting rooms required\n    to accommodate all the meetings without any overlap.\n\n    Take input from the user for the start and end times of each meeting in the form of a list of tuples.\n    Return the minimum number of meeting rooms required.\n\n    Example:\n    Input: [(0, 30), (5, 10), (15, 20)]\n    Output: 2\n\n    Input: [(1, 18), (18, 23), (15, 29), (4, 15), (2, 11), (5, 13)]\n    Output: 4\n    \"\"\"\n", "entry_point": "find_minimum_meeting_rooms", "solution": "    if not meetings:\n        return 0\n\n    # Separate start times and end times\n    start_times = sorted([meeting[0] for meeting in meetings])\n    end_times = sorted([meeting[1] for meeting in meetings])\n\n    rooms_required = 0\n    max_rooms = 0\n    start_ptr = 0\n    end_ptr = 0\n\n    while start_ptr < len(meetings) and end_ptr < len(meetings):\n        if start_times[start_ptr] < end_times[end_ptr]:\n            rooms_required += 1\n            start_ptr += 1\n        elif start_times[start_ptr] > end_times[end_ptr]:\n            rooms_required -= 1\n            end_ptr += 1\n        else:\n            start_ptr += 1\n            end_ptr += 1\n\n        max_rooms = max(max_rooms, rooms_required)\n\n    return max_rooms\n", "test": "def check(candidate):\n    assert candidate([(1, 5), (1, 5), (1, 5)]) == 3\n    assert candidate([(0, 1), (0, 2), (0, 3), (0, 4), (0, 5)]) == 5\n    assert candidate([(1, 2)]) == 1\n    assert candidate([(1, 10), (2, 11), (3, 12)]) == 3\n    assert candidate([(1, 2), (3, 4), (5, 6), (7, 8), (9, 10)]) == 1\n    assert candidate([]) == 0\n    assert candidate([(1, 18), (18, 23), (15, 29), (4, 15), (2, 11), (5, 13)]) == 4\n    assert candidate([(0, 30), (5, 10), (15, 20)]) == 2\n    assert candidate([(1, 2), (2, 3), (3, 4)]) == 1\n    assert candidate([(1, 100), (2, 3), (4, 5)]) == 2\n", "language": "python"}
{"task_id": "revision1a_problem595", "prompt": "from typing import List\n\ndef optimize_delivery_route(addresses: List[str], distances: List[List[int]]) -> List[str]:\n    \"\"\"\n    As a delivery driver for an e-commerce company, you need to optimize your route to deliver packages efficiently.\n    You are given a list of delivery addresses and a 2D matrix of distances between each pair of addresses.\n    Your task is to find the shortest possible route that visits each address exactly once and returns to the starting point (known as the Traveling Salesman Problem).\n    \n    Implement a function that takes in a list of addresses and a 2D distance matrix, and returns the optimal order of addresses to visit.\n    Use a heuristic algorithm like Nearest Neighbor or 2-opt to find a near-optimal solution in reasonable time.\n    \n    Parameters:\n    addresses (List[str]): A list of delivery addresses\n    distances (List[List[int]]): A 2D matrix where distances[i][j] represents the distance between addresses[i] and addresses[j]\n    \n    Returns:\n    List[str]: The optimal order of addresses to visit\n    \n    Example:\n    Input: \n    addresses = [\"123 Main St\", \"456 Elm St\", \"789 Oak St\", \"321 Pine St\"]\n    distances = [\n        [0, 10, 15, 20],\n        [10, 0, 35, 25],\n        [15, 35, 0, 30],\n        [20, 25, 30, 0]\n    ]\n    Output: [\"123 Main St\", \"456 Elm St\", \"321 Pine St\", \"789 Oak St\"]\n    \n    Note: The output represents a near-optimal solution that may vary depending on the specific algorithm used.\n    \"\"\"\n", "entry_point": "optimize_delivery_route", "solution": "\n    def nearest_neighbor(start):\n        unvisited = set(range(len(addresses)))\n        path = [start]\n        unvisited.remove(start)\n        while unvisited:\n            current = path[-1]\n            nearest = min(unvisited, key=lambda x: distances[current][x])\n            path.append(nearest)\n            unvisited.remove(nearest)\n        return path\n\n    def total_distance(path):\n        return sum(distances[path[i]][path[i+1]] for i in range(len(path)-1)) + distances[path[-1]][path[0]]\n\n    def two_opt(path):\n        improved = True\n        while improved:\n            improved = False\n            for i in range(1, len(path) - 2):\n                for j in range(i + 1, len(path)):\n                    if j - i == 1:\n                        continue\n                    new_path = path[:i] + path[i:j][::-1] + path[j:]\n                    if total_distance(new_path) < total_distance(path):\n                        path = new_path\n                        improved = True\n            return path\n\n    # Start with Nearest Neighbor algorithm\n    best_path = nearest_neighbor(0)\n    \n    # Apply 2-opt optimization\n    best_path = two_opt(best_path)\n\n    # Convert indices back to addresses\n    return [addresses[i] for i in best_path]\n", "test": "def check(candidate):\n    assert candidate([\"A\", \"B\", \"C\", \"D\", \"E\"], [[0, 10, 20, 30, 40], [10, 0, 50, 60, 70], [20, 50, 0, 80, 90], [30, 60, 80, 0, 100], [40, 70, 90, 100, 0]]) == ['A', 'C', 'B', 'D', 'E']\n    assert candidate([\"P1\", \"P2\", \"P3\", \"P4\", \"P5\"], [[0, 2, 3, 4, 5], [2, 0, 6, 7, 8], [3, 6, 0, 9, 10], [4, 7, 9, 0, 11], [5, 8, 10, 11, 0]]) == ['P1', 'P3', 'P2', 'P4', 'P5']\n    assert candidate([\"Home\", \"Work\", \"School\", \"Gym\", \"Store\"], [[0, 5, 10, 15, 20], [5, 0, 25, 30, 35], [10, 25, 0, 40, 45], [15, 30, 40, 0, 50], [20, 35, 45, 50, 0]]) == ['Home', 'School', 'Work', 'Gym', 'Store']\n    assert candidate([\"A\", \"B\", \"C\", \"D\"], [[0, 1, 2, 3], [1, 0, 4, 5], [2, 4, 0, 6], [3, 5, 6, 0]]) == ['A', 'B', 'C', 'D']\n    assert candidate([\"X\", \"Y\", \"Z\"], [[0, 5, 10], [5, 0, 15], [10, 15, 0]]) == ['X', 'Y', 'Z']\n    assert candidate([\"A\", \"B\"], [[0, 1], [1, 0]]) == ['A', 'B']\n    assert candidate([\"123 Main St\", \"456 Elm St\", \"789 Oak St\", \"321 Pine St\"], [[0, 10, 15, 20], [10, 0, 35, 25], [15, 35, 0, 30], [20, 25, 30, 0]]) == ['123 Main St', '456 Elm St', '321 Pine St', '789 Oak St']\n    assert candidate([\"1\", \"2\", \"3\", \"4\", \"5\", \"6\", \"7\"], [[0]*7 for _ in range(7)]) == ['1', '2', '3', '4', '5', '6', '7']\n    assert candidate([\"A\", \"B\", \"C\", \"D\", \"E\", \"F\"], [[0, 1, 2, 3, 4, 5], [1, 0, 6, 7, 8, 9], [2, 6, 0, 10, 11, 12], [3, 7, 10, 0, 13, 14], [4, 8, 11, 13, 0, 15], [5, 9, 12, 14, 15, 0]]) == ['A', 'D', 'B', 'E', 'C', 'F']\n    assert candidate([\"A\"], [[0]]) == ['A']\n", "language": "python"}
{"task_id": "revision1a_problem688", "prompt": "import math\nimport random\nfrom typing import List, Tuple\n\ndef optimize_delivery_route(locations: List[Tuple[float, float]], depot: Tuple[float, float]) -> List[int]:\n    \"\"\"\n    A local pizza delivery service wants to optimize their delivery routes. They have a list of customer locations\n    represented as (x, y) coordinates, and the location of their depot. The goal is to find the shortest route that\n    visits all customers exactly once and returns to the depot.\n\n    This is known as the Traveling Salesman Problem (TSP). Implement a solution using a genetic algorithm approach.\n\n    Parameters:\n    locations (List[Tuple[float, float]]): List of (x, y) coordinates representing customer locations\n    depot (Tuple[float, float]): (x, y) coordinate of the depot\n\n    Returns:\n    List[int]: The optimal route as a list of indices representing the order of visits\n\n    Example:\n    Input: \n    locations = [(1.0, 1.0), (2.0, 2.0), (3.0, 3.0), (4.0, 4.0)]\n    depot = (0.0, 0.0)\n    Output: [0, 2, 3, 1]  # This means: depot -> location 0 -> location 2 -> location 3 -> location 1 -> depot\n    \"\"\"\n", "entry_point": "optimize_delivery_route", "solution": "    def distance(point1, point2):\n        return math.sqrt((point1[0] - point2[0])**2 + (point1[1] - point2[1])**2)\n\n    def total_distance(route):\n        total = distance(depot, locations[route[0]])\n        for i in range(len(route) - 1):\n            total += distance(locations[route[i]], locations[route[i + 1]])\n        total += distance(locations[route[-1]], depot)\n        return total\n\n    def create_individual():\n        return random.sample(range(len(locations)), len(locations))\n\n    def crossover(parent1, parent2):\n        start, end = sorted(random.sample(range(len(parent1)), 2))\n        child = [-1] * len(parent1)\n        child[start:end] = parent1[start:end]\n        remaining = [item for item in parent2 if item not in child]\n        for i in range(len(child)):\n            if child[i] == -1:\n                child[i] = remaining.pop(0)\n        return child\n\n    def mutate(individual):\n        i, j = random.sample(range(len(individual)), 2)\n        individual[i], individual[j] = individual[j], individual[i]\n\n    population_size = 100\n    generations = 1000\n    mutation_rate = 0.01\n\n    population = [create_individual() for _ in range(population_size)]\n\n    for _ in range(generations):\n        population = sorted(population, key=total_distance)\n        new_population = population[:2]  # Keep the two best individuals\n\n        while len(new_population) < population_size:\n            parent1, parent2 = random.sample(population[:50], 2)\n            child = crossover(parent1, parent2)\n            if random.random() < mutation_rate:\n                mutate(child)\n            new_population.append(child)\n\n        population = new_population\n\n    best_route = min(population, key=total_distance)\n    return best_route\n", "test": "def check(candidate):\n    assert candidate([(0.0, 0.0), (1.0, 1.0), (2.0, 2.0)], (0.5, 0.5)) == [0, 1, 2]\n", "language": "python"}
{"task_id": "revision1a_problem636", "prompt": "import re\nfrom typing import List\n\ndef validate_passwords(passwords: List[str]) -> List[str]:\n    \"\"\"\n    In a cybersecurity firm, you're tasked with validating a list of passwords for strength.\n    Each password must meet the following criteria:\n    1. At least 8 characters long\n    2. Contains at least one uppercase letter, one lowercase letter, one digit, and one special character\n    3. Does not contain any spaces\n\n    Take input from the user as a list of passwords and return a list of 'Valid' or 'Invalid' for each password.\n\n    Example:\n    Input: [\"P@ssw0rd\", \"weakpass\", \"Str0ng!Pass\", \"No Space\"]\n    Output: ['Valid', 'Invalid', 'Valid', 'Invalid']\n\n    Input: [\"12345\", \"V@lidP@ssw0rd!\", \"spaces are bad\", \"NoSpecialChar1\"]\n    Output: ['Invalid', 'Valid', 'Invalid', 'Invalid']\n    \"\"\"\n", "entry_point": "validate_passwords", "solution": "    def is_valid_password(password: str) -> bool:\n        if len(password) < 8 or ' ' in password:\n            return False\n        \n        has_uppercase = False\n        has_lowercase = False\n        has_digit = False\n        has_special = False\n        \n        for char in password:\n            if char.isupper():\n                has_uppercase = True\n            elif char.islower():\n                has_lowercase = True\n            elif char.isdigit():\n                has_digit = True\n            elif not char.isalnum():\n                has_special = True\n        \n        return has_uppercase and has_lowercase and has_digit and has_special\n    \n    return ['Valid' if is_valid_password(password) else 'Invalid' for password in passwords]\n", "test": "def check(candidate):\n    assert candidate([\"Short1!\", \"TooLongPasswordWithoutSpecialChar123\", \"Valid1Pass!\", \"   Spaces@1\"]) == ['Invalid', 'Invalid', 'Valid', 'Invalid']\n    assert candidate([\"NoDigit!Pass\", \"NoSpecialChar123A\", \"NoUpperCase123!\", \"NoLowerCase123!\"]) == ['Invalid', 'Invalid', 'Valid', 'Valid']\n    assert candidate([\"P@ssw0rd\", \"weakpass\", \"Str0ng!Pass\", \"No Space\"]) == ['Valid', 'Invalid', 'Valid', 'Invalid']\n    assert candidate([\"Pass1!\", \"StrongP@ssw0rd\", \"Weak\", \"Very!2Long3Password4With5Special6Chars\"]) == ['Invalid', 'Valid', 'Invalid', 'Valid']\n    assert candidate([\"Ex@ctly8\", \"9CharPass!\", \"TenCharPas1!\", \"ElevenCharP@s\"]) == ['Valid', 'Valid', 'Valid', 'Invalid']\n    assert candidate([\"12345\", \"V@lidP@ssw0rd!\", \"spaces are bad\", \"NoSpecialChar1\"]) == ['Invalid', 'Valid', 'Invalid', 'Invalid']\n    assert candidate([\"EndsWith!1A\", \"A1!StartsWithSpecial\", \"MidSpecial!1A2Here\", \"NoSpecialLast123A\"]) == ['Valid', 'Valid', 'Valid', 'Invalid']\n    assert candidate([\"1234!@#$ABCD\", \"abcd!@#$1234\", \"ABCDabcd!@#$\", \"!@#$1234abcd\"]) == ['Invalid', 'Invalid', 'Invalid', 'Invalid']\n    assert candidate([\"!@#$%^&*1Aa\", \"OnlySpecialChars!@#\", \"ALLUPPERCASE123!\", \"alllowercase123!\"]) == ['Valid', 'Invalid', 'Invalid', 'Invalid']\n    assert candidate([\"Abcdefg1!\", \"abcdefG2@\", \"ABCDEFG3#\", \"abcdefgh4$\"]) == ['Valid', 'Valid', 'Invalid', 'Invalid']\n", "language": "python"}
{"task_id": "revision1a_problem489", "prompt": "from collections import deque\nfrom typing import List\n\ndef escape_room(n: int, m: int, room: List[List[str]]) -> int:\n    \"\"\"\n    You are trapped in an escape room with various obstacles and tools. Your task is to find the minimum number of moves to reach the exit.\n    The room is represented as a grid of n x m cells. Each cell contains one of the following:\n    'S': Start position\n    'E': Exit\n    '#': Wall (impassable)\n    'K': Key (can be collected)\n    'D': Locked door (requires a key to pass)\n    '.': Empty space\n\n    You can move up, down, left, or right. Collecting a key allows you to pass through one locked door.\n    Return the minimum number of moves required to reach the exit, or -1 if it's impossible.\n\n    Take input from the user for the dimensions of the room and the room layout.\n\n    Example:\n    Input: 5, 5, [['S','.','#','#','#'],\n                  ['.','#','D','.','#'],\n                  ['.','.','K','.','E'],\n                  ['#','D','.','#','#'],\n                  ['#','#','#','#','#']]\n    Output: 8\n    \"\"\"\n", "entry_point": "escape_room", "solution": "    def find_start():\n        for i in range(n):\n            for j in range(m):\n                if room[i][j] == 'S':\n                    return i, j\n        return -1, -1\n\n    start_x, start_y = find_start()\n    if start_x == -1 or start_y == -1:\n        return -1\n\n    queue = deque([(start_x, start_y, 0, False)])  # x, y, moves, has_key\n    visited = set([(start_x, start_y, False)])\n    directions = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n\n    while queue:\n        x, y, moves, has_key = queue.popleft()\n\n        if room[x][y] == 'E':\n            return moves\n\n        for dx, dy in directions:\n            nx, ny = x + dx, y + dy\n            if 0 <= nx < n and 0 <= ny < m:\n                cell = room[nx][ny]\n                new_has_key = has_key\n\n                if cell == '#':\n                    continue\n                if cell == 'D' and not has_key:\n                    continue\n                if cell == 'K':\n                    new_has_key = True\n\n                if (nx, ny, new_has_key) not in visited:\n                    visited.add((nx, ny, new_has_key))\n                    queue.append((nx, ny, moves + 1, new_has_key))\n\n    return -1\n", "test": "def check(candidate):\n    assert candidate(3, 3, [['S', 'D', 'E'], ['#', '#', 'K'], ['#', '#', '#']]) == -1\n    assert candidate(4, 3, [['S', '#', 'E'], ['.', 'D', '.'], ['K', '#', '.'], ['#', '#', '.']]) == 6\n    assert candidate(2, 2, [['S', 'E'], ['#', '#']]) == 1\n    assert candidate(3, 4, [['S', 'K', 'D', 'E'], ['#', '#', '#', '.'], ['.', '.', '.', '.']]) == 3\n    assert candidate(4, 4, [['S', '.', '.', '.'], ['.', '#', '#', '.'], ['.', 'D', 'K', '.'], ['#', '#', '#', 'E']]) == 6\n    assert candidate(2, 3, [['S', 'D', 'E'], ['K', '#', '.']]) == 4\n    assert candidate(6, 6, [['S', '.', '.', '.', '.', '.'], ['.', '#', '#', '#', '#', '.'], ['.', '#', 'K', '.', 'D', '.'], ['.', '#', '#', '#', '#', '.'], ['.', '.', '.', '.', '.', 'E'], ['#', '#', '#', '#', '#', '#']]) == 9\n    assert candidate(5, 5, [['S', '.', '#', '#', '#'], ['.', '#', 'D', '.', '#'], ['.', '.', 'K', '.', 'E'], ['#', 'D', '.', '#', '#'], ['#', '#', '#', '#', '#']]) == 6\n    assert candidate(5, 1, [['S'], ['.'], ['.'], ['.'], ['E']]) == 4\n", "language": "python"}
{"task_id": "revision1a_problem599", "prompt": "import random\nfrom typing import List, Callable, Tuple\nfrom typing import List, Callable\n\ndef simulate_assembly_line(parts: List[str], operations: List[Callable[[str], str]], failure_rate: float) -> Tuple[List[str], List[str], float]:\n    \"\"\"\n    A manufacturing company wants to simulate their assembly line process. Given a list of parts, a list of operations\n    to be performed on each part, and a failure rate, simulate the assembly line and return the results.\n\n    Parameters:\n    - parts: List of part names (strings) to be processed\n    - operations: List of functions, each representing an operation to be performed on a part\n    - failure_rate: Probability of an operation failing (float between 0 and 1)\n\n    Each operation function should take a part name as input and return the modified part name.\n\n    The function should:\n    1. Apply each operation to each part in order\n    2. Simulate potential failures based on the failure rate\n    3. Keep track of successfully assembled parts and failed parts\n\n    Return a tuple containing:\n    1. List of successfully assembled parts\n    2. List of failed parts\n    3. Overall success rate (float, rounded to 2 decimal places)\n\n    Use list comprehension, the random module, and exception handling to solve this problem.\n\n    Example:\n    def op1(part): return part + \"_cleaned\"\n    def op2(part): return part + \"_painted\"\n    def op3(part): return part + \"_packaged\"\n\n    Input: \n    parts = ['A', 'B', 'C', 'D']\n    operations = [op1, op2, op3]\n    failure_rate = 0.2\n\n    Output: \n    (['A_cleaned_painted_packaged', 'C_cleaned_painted_packaged'], ['B', 'D'], 0.50)\n    \"\"\"\n", "entry_point": "simulate_assembly_line", "solution": "    \n    def process_part(part):\n        try:\n            return (\n                False,\n                part\n            ) if random.random() < failure_rate else (\n                True,\n                reduce(lambda p, op: op(p), operations, part)\n            )\n        except Exception:\n            return False, part\n\n    from functools import reduce\n    \n    results = [process_part(part) for part in parts]\n    \n    successful_parts = [part for success, part in results if success]\n    failed_parts = [part for success, part in results if not success]\n    \n    success_rate = round(len(successful_parts) / len(parts), 2)\n    \n    return successful_parts, failed_parts, success_rate\n\n", "test": "def check(candidate):\n    assert candidate([\"1\", \"2\", \"3\"], [lambda x: str(int(x) + 1)], 0.0) == (['2', '3', '4'], [], 1.0)\n    assert candidate([\"Part1\"], [], 0.0) == (['Part1'], [], 1.0)\n    assert candidate([\"Test1\", \"Test2\"], [lambda x: x[::-1]], 0.15) == (['1tseT', '2tseT'], [], 1.0)\n    assert candidate([\"Part\"], [lambda x: x, lambda x: x, lambda x: x], 0.01) == (['Part'], [], 1.0)\n", "language": "python"}
{"task_id": "revision1a_problem459", "prompt": "from typing import List\n\ndef fibonacci_sequence(n: int, a: int, b: int) -> List[int]:\n    \"\"\"\n    Generate a modified Fibonacci sequence based on user input.\n    \n    The sequence starts with two user-defined numbers 'a' and 'b', and follows these rules:\n    1. The first two numbers are 'a' and 'b'.\n    2. Each subsequent number is the sum of the previous two numbers multiplied by their positions.\n    \n    For example, if a=2 and b=3:\n    2, 3, 10, 56, 390, 3360, ...\n    \n    Where:\n    2 (1st position) and 3 (2nd position) are the starting numbers\n    10 = (2 + 3) * 3 (3rd position)\n    56 = (3 + 10) * 4 (4th position)\n    390 = (10 + 56) * 5 (5th position)\n    and so on...\n    \n    Parameters:\n    n (int): The number of elements to generate in the sequence\n    a (int): The first number in the sequence\n    b (int): The second number in the sequence\n    \n    Returns:\n    List[int]: The generated sequence as a list of integers\n    \n    Example:\n    Input: n=6, a=2, b=3\n    Output: [2, 3, 10, 56, 390, 3360]\n    \n    Input: n=8, a=1, b=1\n    Output: [1, 1, 4, 20, 120, 840, 6720, 60480]\n    \"\"\"\n", "entry_point": "fibonacci_sequence", "solution": "    if n <= 0:\n        return []\n    \n    sequence = [a]\n    if n == 1:\n        return sequence\n    \n    sequence.append(b)\n    if n == 2:\n        return sequence\n    \n    for i in range(2, n):\n        next_number = (sequence[i-2] + sequence[i-1]) * (i + 1)\n        sequence.append(next_number)\n    \n    return sequence\n", "test": "def check(candidate):\n    assert candidate(15, 1, 2) == [1, 2, 9, 44, 265, 1854, 14833, 133496, 1334961, 14684570, 176214841, 2290792932, 32071101049, 481066515734, 7697064251745]\n    assert candidate(10, 0, 1) == [0, 1, 3, 16, 95, 666, 5327, 47944, 479439, 5273830]\n    assert candidate(1, 10, 20) == [10]\n    assert candidate(8, 2, 3) == [2, 3, 15, 72, 435, 3042, 24339, 219048]\n    assert candidate(5, 1, 1) == [1, 1, 6, 28, 170]\n    assert candidate(4, 100, 200) == [100, 200, 900, 4400]\n    assert candidate(2, 0, 0) == [0, 0]\n    assert candidate(3, 5, 7) == [5, 7, 36]\n    assert candidate(7, 1, 0) == [1, 0, 3, 12, 75, 522, 4179]\n    assert candidate(6, -1, 1) == [-1, 1, 0, 4, 20, 144]\n", "language": "python"}
{"task_id": "revision1a_problem483", "prompt": "from typing import List\nimport re\n\ndef parse_chemical_formulas(formulas: List[str]) -> List[dict]:\n    \"\"\"\n    A chemistry lab needs to parse complex chemical formulas and extract element information.\n    Each formula may contain parentheses, numbers, and uppercase/lowercase letters.\n    \n    Parse each formula and return a list of dictionaries, where each dictionary represents\n    the elements and their counts in a formula.\n\n    Rules for parsing:\n    1. Elements always start with an uppercase letter, possibly followed by a lowercase letter.\n    2. Numbers after an element or closing parenthesis indicate the count of that element or group.\n    3. Parentheses can be nested and indicate grouping.\n    4. If no number is specified after an element or group, assume the count is 1.\n\n    Example:\n    Input: [\"H2O\", \"Mg(OH)2\", \"K4[ON(SO3)2]2\"]\n    Output: [\n        {\"H\": 2, \"O\": 1},\n        {\"Mg\": 1, \"O\": 2, \"H\": 2},\n        {\"K\": 4, \"O\": 14, \"N\": 2, \"S\": 4}\n    ]\n\n    Hint: Consider using a stack-based approach and regular expressions to solve this problem.\n    \"\"\"\n", "entry_point": "parse_chemical_formulas", "solution": "    def parse_formula(formula):\n        stack = [{}]\n        element = ''\n        count = ''\n        \n        for char in formula:\n            if char.isupper():\n                if element:\n                    stack[-1][element] = stack[-1].get(element, 0) + (int(count) if count else 1)\n                element = char\n                count = ''\n            elif char.islower():\n                element += char\n            elif char.isdigit():\n                count += char\n            elif char in '([{':\n                if element:\n                    stack[-1][element] = stack[-1].get(element, 0) + (int(count) if count else 1)\n                stack.append({})\n                element = ''\n                count = ''\n            elif char in ')]}':\n                if element:\n                    stack[-1][element] = stack[-1].get(element, 0) + (int(count) if count else 1)\n                top = stack.pop()\n                multiplier = int(count) if count else 1\n                for elem, cnt in top.items():\n                    stack[-1][elem] = stack[-1].get(elem, 0) + cnt * multiplier\n                element = ''\n                count = ''\n        \n        if element:\n            stack[-1][element] = stack[-1].get(element, 0) + (int(count) if count else 1)\n        \n        return stack[0]\n\n    result = []\n    for formula in formulas:\n        result.append(parse_formula(formula))\n    \n    return result\n", "test": "def check(candidate):\n    assert candidate([\"NaCl\"]) == [{'Na': 1, 'Cl': 1}]\n    assert candidate([\"CH3COOH\"]) == [{'C': 2, 'H': 4, 'O': 2}]\n    assert candidate([\"H2O\"]) == [{'H': 2, 'O': 1}]\n    assert candidate([\"Fe2O3\"]) == [{'Fe': 2, 'O': 3}]\n    assert candidate([\"Ca(OH)2\"]) == [{'Ca': 1, 'O': 1, 'H': 1}]\n    assert candidate([\"(NH4)2SO4\"]) == [{'N': 4, 'H': 16, 'S': 1, 'O': 4}]\n    assert candidate([\"Cu(NO3)2\"]) == [{'Cu': 1, 'N': 3, 'O': 9}]\n    assert candidate([\"CO2\"]) == [{'C': 1, 'O': 2}]\n    assert candidate([\"H2SO4\"]) == [{'H': 2, 'S': 1, 'O': 4}]\n    assert candidate([\"K4[ON(SO3)2]2\"]) == [{'K': 4, 'O': 20, 'N': 2, 'S': 6}]\n", "language": "python"}
{"task_id": "revision1a_problem630", "prompt": "import heapq\nfrom typing import List, Tuple\n\ndef network_latency(nodes: int, connections: List[Tuple[int, int, float]], source: int) -> List[float]:\n    \"\"\"\n    I'm a network engineer analyzing the latency in a computer network. The network consists of nodes connected by links,\n    each with its own latency. I need to calculate the minimum latency from a source node to all other nodes in the network.\n\n    Take input from the user in the form of:\n    - The number of nodes in the network\n    - A list of connections, where each connection is a tuple (from_node, to_node, latency)\n    - The source node\n\n    Return a list of minimum latencies from the source node to all other nodes. If a node is unreachable, its latency should be float('inf').\n\n    Nodes are numbered from 0 to n-1.\n\n    Example:\n    Input: 4, [(0,1,1.0), (0,2,4.0), (1,2,2.0), (1,3,5.0), (2,3,1.0)], 0\n    Output: [0.0, 1.0, 3.0, 4.0]\n\n    Input: 3, [(0,1,2.0), (1,2,3.0)], 2\n    Output: [float('inf'), float('inf'), 0.0]\n    \"\"\"\n", "entry_point": "network_latency", "solution": "    # Create an adjacency list to represent the network\n    graph = [[] for _ in range(nodes)]\n    for from_node, to_node, latency in connections:\n        graph[from_node].append((to_node, latency))\n        graph[to_node].append((from_node, latency))  # Assuming bidirectional connections\n\n    # Initialize latencies list with infinity for all nodes\n    latencies = [float('inf')] * nodes\n    latencies[source] = 0.0\n\n    # Use a priority queue to store nodes to visit\n    pq = [(0.0, source)]\n\n    while pq:\n        current_latency, current_node = heapq.heappop(pq)\n\n        # If we've found a longer path, skip this node\n        if current_latency > latencies[current_node]:\n            continue\n\n        # Check all neighbors of the current node\n        for neighbor, edge_latency in graph[current_node]:\n            new_latency = current_latency + edge_latency\n\n            # If we've found a shorter path to the neighbor, update it\n            if new_latency < latencies[neighbor]:\n                latencies[neighbor] = new_latency\n                heapq.heappush(pq, (new_latency, neighbor))\n\n    return latencies\n", "test": "def check(candidate):\n    assert candidate(4, [(0,1,1.0), (1,2,1.0), (2,3,1.0), (3,0,1.0)], 0) == [0.0, 1.0, 2.0, 1.0]\n    assert candidate(4, [(0,1,1.0), (0,2,4.0), (1,2,2.0), (1,3,5.0), (2,3,1.0)], 0) == [0.0, 1.0, 3.0, 4.0]\n    assert candidate(6, [(0,1,1.0), (1,2,1.0), (2,3,1.0), (3,4,1.0), (4,5,1.0), (0,5,10.0)], 0) == [0.0, 1.0, 2.0, 3.0, 4.0, 5.0]\n    assert candidate(2, [(0,1,5.0)], 0) == [0.0, 5.0]\n    assert candidate(3, [(0,1,2.0), (1,2,3.0)], 2) == [5.0, 3.0, 0.0]\n    assert candidate(5, [(0,1,1.0), (1,2,2.0), (2,3,3.0), (3,4,4.0)], 0) == [0.0, 1.0, 3.0, 6.0, 10.0]\n    assert candidate(5, [(0,1,1.0), (0,2,2.0), (0,3,3.0), (0,4,4.0)], 0) == [0.0, 1.0, 2.0, 3.0, 4.0]\n    assert candidate(3, [(0,1,2.5), (1,2,3.7)], 0) == [0.0, 2.5, 6.2]\n    assert candidate(1, [], 0) == [0.0]\n    assert candidate(4, [(0,1,1.0), (1,2,2.0), (2,3,3.0)], 3) == [6.0, 5.0, 3.0, 0.0]\n", "language": "python"}
{"task_id": "revision1a_problem450", "prompt": "from typing import List, Dict, Any\nimport random\n\ndef simulate_stock_market(initial_prices: Dict[str, float], events: List[Dict[str, Any]]) -> Dict[str, float]:\n    \"\"\"\n    You are tasked with creating a stock market simulation program.\n\n    Given an initial set of stock prices and a series of events that affect the market,\n    simulate the changes in stock prices over time.\n    Create a 'MarketSimulator' class that processes events and updates stock prices.\n    Implement methods for handling different types of events (e.g., company earnings reports, economic indicators, global events).\n    Consider factors such as supply and demand, market sentiment, and inter-stock correlations.\n    Return the final stock prices after processing all events.\n\n    Example:\n    Input:\n    initial_prices = {\"AAPL\": 150.0, \"GOOGL\": 2800.0, \"MSFT\": 300.0}\n    events = [\n        {\"type\": \"earnings_report\", \"stock\": \"AAPL\", \"performance\": \"beat\"},\n        {\"type\": \"global_event\", \"description\": \"trade_war_escalation\"},\n        {\"type\": \"sector_news\", \"sector\": \"tech\", \"sentiment\": \"positive\"}\n    ]\n    Output: {\"AAPL\": 158.5, \"GOOGL\": 2750.0, \"MSFT\": 315.0}\n    \"\"\"\n", "entry_point": "simulate_stock_market", "solution": "    class MarketSimulator:\n        def __init__(self, initial_prices):\n            self.prices = initial_prices\n            self.sectors = {\n                \"tech\": [\"AAPL\", \"GOOGL\", \"MSFT\"],\n                # Add more sectors and stocks as needed\n            }\n\n        def process_event(self, event):\n            event_type = event[\"type\"]\n            if event_type == \"earnings_report\":\n                self.handle_earnings_report(event)\n            elif event_type == \"global_event\":\n                self.handle_global_event(event)\n            elif event_type == \"sector_news\":\n                self.handle_sector_news(event)\n\n        def handle_earnings_report(self, event):\n            stock = event[\"stock\"]\n            performance = event[\"performance\"]\n            if performance == \"beat\":\n                self.update_price(stock, 0.05, 0.1)\n            elif performance == \"meet\":\n                self.update_price(stock, -0.02, 0.02)\n            elif performance == \"miss\":\n                self.update_price(stock, -0.1, -0.05)\n\n        def handle_global_event(self, event):\n            description = event[\"description\"]\n            if description == \"trade_war_escalation\":\n                for stock in self.prices:\n                    self.update_price(stock, -0.05, -0.02)\n            elif description == \"pandemic_recovery\":\n                for stock in self.prices:\n                    self.update_price(stock, 0.02, 0.05)\n            # Add more global event types as needed\n\n        def handle_sector_news(self, event):\n            sector = event[\"sector\"]\n            sentiment = event[\"sentiment\"]\n            if sector in self.sectors:\n                for stock in self.sectors[sector]:\n                    if sentiment == \"positive\":\n                        self.update_price(stock, 0.02, 0.05)\n                    elif sentiment == \"negative\":\n                        self.update_price(stock, -0.05, -0.02)\n\n        def update_price(self, stock, min_change, max_change):\n            if stock in self.prices:\n                change = random.uniform(min_change, max_change)\n                self.prices[stock] *= (1 + change)\n                self.prices[stock] = round(self.prices[stock], 2)\n\n    simulator = MarketSimulator(initial_prices)\n    for event in events:\n        simulator.process_event(event)\n\n    return simulator.prices\n", "test": "def check(candidate):\n    assert candidate({\"JPM\": 150.0, \"BAC\": 40.0, \"GS\": 380.0}, [{\"type\": \"economic_indicator\", \"indicator\": \"interest_rates\", \"change\": \"increase\"}]) == {'JPM': 150.0, 'BAC': 40.0, 'GS': 380.0}\n    assert candidate({\"PFE\": 40.0, \"MRNA\": 200.0, \"JNJ\": 170.0}, [{\"type\": \"product_launch\", \"stock\": \"MRNA\", \"success\": True}, {\"type\": \"sector_news\", \"sector\": \"healthcare\", \"sentiment\": \"neutral\"}]) == {'PFE': 40.0, 'MRNA': 200.0, 'JNJ': 170.0}\n    assert candidate({\"XOM\": 60.0, \"CVX\": 110.0, \"BP\": 30.0}, [{\"type\": \"global_event\", \"description\": \"oil_price_surge\"}, {\"type\": \"sector_news\", \"sector\": \"energy\", \"sentiment\": \"positive\"}]) == {'XOM': 60.0, 'CVX': 110.0, 'BP': 30.0}\n    assert candidate({\"UBER\": 45.0, \"LYFT\": 55.0}, [{\"type\": \"legal_event\", \"stock\": \"UBER\", \"outcome\": \"favorable\"}, {\"type\": \"sector_news\", \"sector\": \"ride_sharing\", \"sentiment\": \"positive\"}]) == {'UBER': 45.0, 'LYFT': 55.0}\n    assert candidate({\"DIS\": 180.0, \"NFLX\": 550.0}, [{\"type\": \"competitor_news\", \"stock\": \"DIS\", \"competitor\": \"NFLX\", \"event\": \"subscriber_growth\"}]) == {'DIS': 180.0, 'NFLX': 550.0}\n    assert candidate({\"GME\": 200.0, \"AMC\": 40.0}, [{\"type\": \"social_media_trend\", \"stock\": \"GME\", \"sentiment\": \"bullish\"}, {\"type\": \"short_squeeze\", \"stock\": \"AMC\"}]) == {'GME': 200.0, 'AMC': 40.0}\n", "language": "python"}
{"task_id": "revision1a_problem561", "prompt": "from typing import List\n\ndef decode_message(encrypted: List[int], key: int) -> str:\n    \"\"\"\n    I'm a secret agent trying to decode an intercepted message.\n    The message is a list of numbers, and I have a decryption key.\n    Each number in the list represents a letter in the alphabet (1-26).\n    The decryption process involves subtracting the key from each number,\n    then converting the result back to a letter (wrapping around if necessary).\n    If the decryption results in an invalid number (less than 1 or greater than 26),\n    that part of the message is considered corrupted and should be replaced with a '?'.\n    Take the encrypted message and key as input, and return the decrypted message as a string.\n    Use list comprehension and the chr() function to solve this problem.\n    Example:\n    Input: [20, 8, 5, 17, 21, 9, 3, 11, 2, 18, 15, 23, 14, 6, 15, 24], 5\n    Output: \"THEQUICKBROWNFOX\"\n    Input: [30, 1, 15, 27, 5], 3\n    Output: \"?XL?B\"\n    \"\"\"\n", "entry_point": "decode_message", "solution": "    def decrypt_char(num):\n        decrypted = (num - key - 1) % 26 + 1\n        return chr(decrypted + 64) if 1 <= decrypted <= 26 else '?'\n    \n    return ''.join([decrypt_char(num) for num in encrypted])\n", "test": "def check(candidate):\n    assert candidate([30, 1, 15, 27, 5], 3) == 'AXLXB'\n    assert candidate([1, 2, 3, 4, 5], 26) == 'ABCDE'\n    assert candidate([], 5) == ''\n    assert candidate([26, 26, 26, 26, 26], 26) == 'ZZZZZ'\n    assert candidate([1, 2, 3, 4, 5], 0) == 'ABCDE'\n    assert candidate([13], 13) == 'Z'\n    assert candidate([26, 25, 24, 23, 22], 26) == 'ZYXWV'\n    assert candidate([20, 8, 5, 17, 21, 9, 3, 11, 2, 18, 15, 23, 14, 6, 15, 24], 5) == 'OCZLPDXFWMJRIAJS'\n    assert candidate([26, 25, 24, 23, 22], 1) == 'YXWVU'\n    assert candidate([1, 1, 1, 1, 1], 1) == 'ZZZZZ'\n", "language": "python"}
{"task_id": "revision1a_problem115", "prompt": "from typing import List, Tuple\nimport math\n\ndef optimize_delivery_route(locations: List[Tuple[float, float]], start: Tuple[float, float]) -> List[Tuple[float, float]]:\n    \"\"\"\n    A food delivery service wants to optimize its delivery route to minimize travel time and fuel consumption.\n    Given a list of customer locations (as latitude-longitude pairs) and the starting point of the delivery driver,\n    determine the most efficient route that visits all locations exactly once and returns to the starting point.\n\n    This is a variation of the Traveling Salesman Problem, which is NP-hard. Implement a heuristic algorithm\n    (such as nearest neighbor or 2-opt) to find a good approximation of the optimal route.\n\n    Args:\n    locations (List[Tuple[float, float]]): List of (latitude, longitude) pairs representing customer locations\n    start (Tuple[float, float]): Starting point of the delivery driver\n\n    Returns:\n    List[Tuple[float, float]]: Ordered list of locations representing the optimized route, including the start/end point\n\n    Example:\n    Input: \n    locations = [(40.7128, -74.0060), (34.0522, -118.2437), (41.8781, -87.6298), (29.7604, -95.3698)]\n    start = (38.9072, -77.0369)\n    Output: \n    [(38.9072, -77.0369), (40.7128, -74.0060), (41.8781, -87.6298), (29.7604, -95.3698), (34.0522, -118.2437), (38.9072, -77.0369)]\n    \"\"\"\n", "entry_point": "optimize_delivery_route", "solution": "    def haversine_distance(point1: Tuple[float, float], point2: Tuple[float, float]) -> float:\n        \"\"\"Calculate the great-circle distance between two points on Earth.\"\"\"\n        lat1, lon1 = point1\n        lat2, lon2 = point2\n        R = 6371  # Earth's radius in kilometers\n\n        dlat = math.radians(lat2 - lat1)\n        dlon = math.radians(lon2 - lon1)\n        a = (math.sin(dlat/2)**2 +\n             math.cos(math.radians(lat1)) * math.cos(math.radians(lat2)) *\n             math.sin(dlon/2)**2)\n        c = 2 * math.atan2(math.sqrt(a), math.sqrt(1-a))\n        return R * c\n\n    def nearest_neighbor(current: Tuple[float, float], unvisited: List[Tuple[float, float]]) -> Tuple[float, float]:\n        \"\"\"Find the nearest unvisited location.\"\"\"\n        return min(unvisited, key=lambda x: haversine_distance(current, x))\n\n    route = [start]\n    unvisited = locations.copy()\n\n    while unvisited:\n        current = route[-1]\n        next_location = nearest_neighbor(current, unvisited)\n        route.append(next_location)\n        unvisited.remove(next_location)\n\n    route.append(start)  # Return to the starting point\n    return route\n", "test": "def check(candidate):\n    assert candidate([(90, 0), (-90, 0), (0, 180), (0, -180)], (0, 0)) == [(0, 0), (90, 0), (0, 180), (0, -180), (-90, 0), (0, 0)]\n    assert candidate([(51.5074, -0.1278), (48.8566, 2.3522), (41.9028, 12.4964), (52.5200, 13.4050)], (50.0755, 14.4378)) == [(50.0755, 14.4378), (52.52, 13.405), (48.8566, 2.3522), (51.5074, -0.1278), (41.9028, 12.4964), (50.0755, 14.4378)]\n    assert candidate([(40.7128, -74.0060), (40.7129, -74.0061), (40.7127, -74.0059)], (40.7128, -74.0060)) == [(40.7128, -74.006), (40.7128, -74.006), (40.7129, -74.0061), (40.7127, -74.0059), (40.7128, -74.006)]\n    assert candidate([(0, 0), (1, 1), (2, 2), (3, 3), (4, 4)], (0, 0)) == [(0, 0), (0, 0), (1, 1), (2, 2), (3, 3), (4, 4), (0, 0)]\n    assert candidate([], (0, 0)) == [(0, 0), (0, 0)]\n    assert candidate([(40.7128, -74.0060)], (40.7128, -74.0060)) == [(40.7128, -74.006), (40.7128, -74.006), (40.7128, -74.006)]\n    assert candidate([(55.7558, 37.6173), (59.9139, 10.7522), (55.6761, 12.5683), (60.1699, 24.9384)], (59.3293, 18.0686)) == [(59.3293, 18.0686), (60.1699, 24.9384), (59.9139, 10.7522), (55.6761, 12.5683), (55.7558, 37.6173), (59.3293, 18.0686)]\n    assert candidate([(35.6762, 139.6503), (22.3193, 114.1694), (1.3521, 103.8198), (-33.8688, 151.2093)], (37.5665, 126.9780)) == [(37.5665, 126.978), (35.6762, 139.6503), (22.3193, 114.1694), (1.3521, 103.8198), (-33.8688, 151.2093), (37.5665, 126.978)]\n    assert candidate([(40.4168, -3.7038), (41.3851, 2.1734), (45.4642, 9.1900), (48.2082, 16.3738)], (52.5200, 13.4050)) == [(52.52, 13.405), (48.2082, 16.3738), (45.4642, 9.19), (41.3851, 2.1734), (40.4168, -3.7038), (52.52, 13.405)]\n    assert candidate([(40.7128, -74.0060), (34.0522, -118.2437), (41.8781, -87.6298), (29.7604, -95.3698)], (38.9072, -77.0369)) == [(38.9072, -77.0369), (40.7128, -74.006), (41.8781, -87.6298), (29.7604, -95.3698), (34.0522, -118.2437), (38.9072, -77.0369)]\n", "language": "python"}
{"task_id": "revision1a_problem141", "prompt": "from typing import List, Dict\n\ndef language_evolution_simulator(initial_words: List[str], rules: Dict[str, str], generations: int) -> List[str]:\n    \"\"\"\n    I'm creating a linguistic simulation to model language evolution over time.\n    Given an initial set of words, a set of evolution rules, and a number of generations,\n    simulate how the language evolves and return the final set of words.\n\n    Parameters:\n    - initial_words: A list of words in the initial language\n    - rules: A dictionary where keys are substrings to be replaced and values are their replacements\n    - generations: The number of generations to simulate\n\n    For each generation, apply all rules to each word. If multiple rules apply to a word,\n    apply them from left to right. Words are case-sensitive.\n\n    Use dynamic programming to optimize the rule application process for efficiency.\n\n    Example:\n    Input: [\"hello\", \"world\"], {\"el\": \"ol\", \"o\": \"0\", \"d\": \"ed\"}, 2\n    Output: [\"holl0\", \"w0rled\"]\n\n    Input: [\"computer\", \"program\"], {\"om\": \"am\", \"er\": \"or\", \"am\": \"em\"}, 3\n    Output: [\"camputor\", \"progrem\"]\n    \"\"\"\n", "entry_point": "language_evolution_simulator", "solution": "    def apply_rules(word: str) -> str:\n        n = len(word)\n        dp = [''] * (n + 1)\n        dp[0] = ''\n\n        for i in range(1, n + 1):\n            dp[i] = dp[i-1] + word[i-1]\n            for j in range(i):\n                substr = word[j:i]\n                if substr in rules:\n                    new_word = dp[j] + rules[substr]\n                    if len(new_word) < len(dp[i]) or (len(new_word) == len(dp[i]) and new_word < dp[i]):\n                        dp[i] = new_word\n\n        return dp[n]\n\n    current_words = initial_words\n\n    for _ in range(generations):\n        next_words = []\n        for word in current_words:\n            evolved_word = apply_rules(word)\n            next_words.append(evolved_word)\n        current_words = next_words\n\n    return current_words\n", "test": "def check(candidate):\n    assert candidate([\"cat\", \"dog\", \"fish\"], {\"a\": \"e\", \"o\": \"u\", \"i\": \"y\"}, 1) == ['cat', 'dog', 'fish']\n    assert candidate([], {\"a\": \"b\"}, 5) == []\n    assert candidate([\"a\", \"b\", \"c\"], {\"a\": \"b\", \"b\": \"c\", \"c\": \"a\"}, 3) == ['a', 'b', 'a']\n    assert candidate([\"apple\", \"banana\", \"cherry\"], {\"pp\": \"p\", \"an\": \"en\", \"ch\": \"sh\"}, 2) == ['aple', 'banana', 'cherry']\n    assert candidate([\"antidisestablishmentarianism\"], {\"anti\": \"pro\", \"establishment\": \"revolution\", \"ism\": \"ist\"}, 1) == ['prodisrevolutionarianism']\n    assert candidate([\"evolution\"], {\"ev\": \"av\", \"ti\": \"sh\", \"on\": \"un\"}, 5) == ['avolushon']\n    assert candidate([\"hello\", \"world\"], {\"el\": \"ol\", \"o\": \"0\", \"d\": \"ed\"}, 2) == ['hell0', 'w0rld']\n    assert candidate([\"python\", \"java\", \"javascript\"], {\"on\": \"un\", \"va\": \"ve\", \"scr\": \"skr\"}, 4) == ['python', 'java', 'javascript']\n    assert candidate([\"computer\", \"program\"], {\"om\": \"am\", \"er\": \"or\", \"am\": \"em\"}, 3) == ['camputer', 'program']\n    assert candidate([\"hello\", \"world\"], {}, 10) == ['hello', 'world']\n", "language": "python"}
{"task_id": "revision1a_problem186", "prompt": "import math\nfrom typing import List, Tuple\n\ndef optimize_delivery_route(locations: List[Tuple[float, float]], start: Tuple[float, float]) -> List[Tuple[float, float]]:\n    \"\"\"\n    As a logistics manager for a delivery company, you need to optimize the route for your delivery drivers. \n    Given a list of delivery locations (as latitude-longitude pairs) and a starting point, find the most efficient route that visits all locations and returns to the start.\n\n    Write a function that takes a list of location tuples and a starting location tuple, and returns the optimized route as a list of location tuples.\n\n    Use the nearest neighbor algorithm:\n    1. Start at the given starting point.\n    2. Find the nearest unvisited location.\n    3. Move to that location and mark it as visited.\n    4. Repeat steps 2-3 until all locations are visited.\n    5. Return to the starting point.\n\n    Example:\n    Input: \n    locations = [(40.7128, -74.0060), (34.0522, -118.2437), (41.8781, -87.6298), (29.7604, -95.3698)]\n    start = (38.9072, -77.0369)\n\n    Output:\n    [(38.9072, -77.0369), (40.7128, -74.0060), (41.8781, -87.6298), (29.7604, -95.3698), (34.0522, -118.2437), (38.9072, -77.0369)]\n\n    Note: Use the Haversine formula to calculate distances between latitude-longitude pairs.\n    \"\"\"\n", "entry_point": "optimize_delivery_route", "solution": "    def haversine_distance(loc1: Tuple[float, float], loc2: Tuple[float, float]) -> float:\n        R = 6371  # Earth's radius in kilometers\n\n        lat1, lon1 = math.radians(loc1[0]), math.radians(loc1[1])\n        lat2, lon2 = math.radians(loc2[0]), math.radians(loc2[1])\n\n        dlat = lat2 - lat1\n        dlon = lon2 - lon1\n\n        a = math.sin(dlat/2)**2 + math.cos(lat1) * math.cos(lat2) * math.sin(dlon/2)**2\n        c = 2 * math.atan2(math.sqrt(a), math.sqrt(1-a))\n\n        return R * c\n\n    unvisited = set(locations)\n    route = [start]\n    current = start\n\n    while unvisited:\n        nearest = min(unvisited, key=lambda x: haversine_distance(current, x))\n        route.append(nearest)\n        unvisited.remove(nearest)\n        current = nearest\n\n    route.append(start)  # Return to the starting point\n    return route\n", "test": "def check(candidate):\n    assert candidate([(0, 0), (0, 180), (0, -180)], (0, 90)) == [(0, 90), (0, 180), (0, -180), (0, 0), (0, 90)]\n    assert candidate([(0, 0), (1, 1), (2, 2), (3, 3)], (0, 0)) == [(0, 0), (0, 0), (1, 1), (2, 2), (3, 3), (0, 0)]\n    assert candidate([(90, 0), (-90, 0), (0, 180), (0, -180)], (0, 0)) == [(0, 0), (-90, 0), (0, -180), (0, 180), (90, 0), (0, 0)]\n    assert candidate([], (0, 0)) == [(0, 0), (0, 0)]\n    assert candidate([(0, 0), (0, 0), (0, 0), (0, 0)], (1, 1)) == [(1, 1), (0, 0), (1, 1)]\n    assert candidate([(40.7128, -74.0060)], (40.7128, -74.0060)) == [(40.7128, -74.006), (40.7128, -74.006), (40.7128, -74.006)]\n    assert candidate([(51.5074, -0.1278), (48.8566, 2.3522), (41.9028, 12.4964), (40.4168, -3.7038)], (52.5200, 13.4050)) == [(52.52, 13.405), (48.8566, 2.3522), (51.5074, -0.1278), (40.4168, -3.7038), (41.9028, 12.4964), (52.52, 13.405)]\n    assert candidate([(89.9999, 0), (89.9999, 90), (89.9999, 180), (89.9999, -90)], (90, 0)) == [(90, 0), (89.9999, 0), (89.9999, 90), (89.9999, 180), (89.9999, -90), (90, 0)]\n    assert candidate([(35.6762, 139.6503), (22.3193, 114.1694), (1.3521, 103.8198), (-33.8688, 151.2093)], (37.5665, 126.9780)) == [(37.5665, 126.978), (35.6762, 139.6503), (22.3193, 114.1694), (1.3521, 103.8198), (-33.8688, 151.2093), (37.5665, 126.978)]\n    assert candidate([(40.7128, -74.0060), (34.0522, -118.2437), (41.8781, -87.6298), (29.7604, -95.3698)], (38.9072, -77.0369)) == [(38.9072, -77.0369), (40.7128, -74.006), (41.8781, -87.6298), (29.7604, -95.3698), (34.0522, -118.2437), (38.9072, -77.0369)]\n", "language": "python"}
{"task_id": "revision1a_problem511", "prompt": "import heapq\nfrom typing import List\n\ndef optimize_network_latency(servers: int, connections: List[List[int]]) -> float:\n    \"\"\"\n    As a network engineer, you're tasked with optimizing the latency in a data center network.\n    You have 'servers' number of servers (numbered from 0 to servers-1) and a list of connections between them.\n    Each connection is represented as [server1, server2, latency], where latency is the time (in milliseconds) \n    it takes for data to travel between server1 and server2.\n\n    Your goal is to find the minimum latency path that connects all servers. If it's impossible to connect all servers, return -1.\n\n    Use Prim's algorithm with a min-heap to solve this problem efficiently.\n\n    Example:\n    Input: servers = 4, connections = [[0,1,1],[0,2,5],[1,2,3],[1,3,1],[2,3,2]]\n    Output: 4.0\n\n    Input: servers = 3, connections = [[0,1,1],[1,2,1]]\n    Output: 2.0\n\n    Input: servers = 4, connections = [[0,1,1],[1,2,1]]\n    Output: -1\n    \"\"\"\n", "entry_point": "optimize_network_latency", "solution": "    # Create an adjacency list to represent the graph\n    graph = [[] for _ in range(servers)]\n    for server1, server2, latency in connections:\n        graph[server1].append((server2, latency))\n        graph[server2].append((server1, latency))\n\n    # Initialize variables for Prim's algorithm\n    visited = [False] * servers\n    min_heap = [(0, 0)]  # (latency, server)\n    total_latency = 0\n    connected_servers = 0\n\n    while min_heap and connected_servers < servers:\n        latency, server = heapq.heappop(min_heap)\n\n        if visited[server]:\n            continue\n\n        visited[server] = True\n        total_latency += latency\n        connected_servers += 1\n\n        for neighbor, edge_latency in graph[server]:\n            if not visited[neighbor]:\n                heapq.heappush(min_heap, (edge_latency, neighbor))\n\n    # Check if all servers are connected\n    if connected_servers == servers:\n        return float(total_latency)\n    else:\n        return -1\n", "test": "def check(candidate):\n    assert candidate(3, [[0,1,5],[1,2,3],[0,2,1]]) == 4.0\n    assert candidate(4, [[0,1,1],[0,2,5],[1,2,3],[1,3,1],[2,3,2]]) == 4.0\n    assert candidate(3, [[0,1,1],[1,2,1]]) == 2.0\n    assert candidate(6, [[0,1,1],[1,2,2],[2,3,3],[3,4,4],[4,5,5],[5,0,6]]) == 15.0\n    assert candidate(4, [[0,1,1],[1,2,2],[2,3,3],[3,0,4]]) == 6.0\n    assert candidate(5, [[0,1,1],[1,2,2],[2,3,3],[3,4,4],[4,0,5]]) == 10.0\n    assert candidate(5, [[0,1,1],[1,2,2],[2,3,3],[3,4,4]]) == 10.0\n    assert candidate(2, [[0,1,10]]) == 10.0\n    assert candidate(4, [[0,1,1],[1,2,1]]) == -1\n    assert candidate(3, [[0,1,1],[0,2,2],[1,2,3]]) == 3.0\n", "language": "python"}
{"task_id": "revision1a_problem92", "prompt": "from typing import List\nfrom collections import deque\n\ndef maze_escape(rows: int, cols: int, maze: List[List[int]], start: List[int], end: List[int]) -> int:\n    \"\"\"\n    I'm designing a robot that needs to navigate through a complex maze.\n    The maze is represented as a 2D grid where 0 represents an open path and 1 represents a wall.\n    The robot can move in four directions: up, down, left, and right.\n    Your task is to find the minimum number of moves required for the robot to reach the exit.\n    If there's no possible path to the exit, return -1.\n\n    There are a few conditions:\n    1. The robot can only move through open paths (0).\n    2. The robot cannot move diagonally.\n    3. The robot cannot move outside the maze boundaries.\n    4. The start and end positions are always open paths.\n\n    Take input for the number of rows and columns in the maze, the maze layout, and the start and end positions.\n    Return the minimum number of moves required to reach the exit.\n\n    Example:\n    Input: 3, 3, [[0,0,0],[1,1,0],[0,0,0]], [0,0], [2,2]\n    Output: 4\n    Input: 3, 3, [[0,1,0],[1,1,0],[0,0,0]], [0,0], [2,2]\n    Output: -1\n    \"\"\"\n", "entry_point": "maze_escape", "solution": "    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] == 0\n\n    directions = [(0, 1), (1, 0), (0, -1), (-1, 0)]  # right, down, left, up\n    queue = deque([(start[0], start[1], 0)])  # (x, y, moves)\n    visited = set([(start[0], start[1])])\n\n    while queue:\n        x, y, moves = queue.popleft()\n\n        if [x, y] == end:\n            return moves\n\n        for dx, dy in directions:\n            new_x, new_y = x + dx, y + dy\n            if is_valid_move(new_x, new_y) and (new_x, new_y) not in visited:\n                queue.append((new_x, new_y, moves + 1))\n                visited.add((new_x, new_y))\n\n    return -1  # No path found\n", "test": "def check(candidate):\n    assert candidate(2, 2, [[0,0],[0,0]], [0,0], [1,1]) == 2\n    assert candidate(1, 1, [[0]], [0,0], [0,0]) == 0\n    assert candidate(3, 3, [[0,0,0],[0,1,0],[0,0,0]], [0,0], [2,2]) == 4\n    assert candidate(5, 5, [[0,0,0,0,0],[1,1,1,1,0],[0,0,0,0,0],[0,1,1,1,1],[0,0,0,0,0]], [0,0], [4,4]) == 16\n    assert candidate(4, 4, [[0,0,0,0],[1,1,0,1],[0,0,0,0],[0,1,1,0]], [0,0], [3,3]) == 6\n    assert candidate(3, 4, [[0,0,0,1],[0,1,0,0],[0,0,0,0]], [0,0], [2,3]) == 5\n    assert candidate(2, 3, [[0,1,0],[0,1,0]], [0,0], [1,2]) == -1\n    assert candidate(4, 3, [[0,1,0],[0,0,0],[1,1,0],[0,0,0]], [0,0], [3,2]) == 5\n    assert candidate(3, 3, [[0,1,0],[1,1,0],[0,0,0]], [0,0], [2,2]) == -1\n    assert candidate(3, 3, [[0,0,0],[1,1,0],[0,0,0]], [0,0], [2,2]) == 4\n", "language": "python"}
{"task_id": "revision1a_problem545", "prompt": "import re\nfrom typing import List, Tuple\n\ndef parse_dna_sequence(sequence: str) -> List[Tuple[str, int]]:\n    \"\"\"\n    As a bioinformatics researcher, I need to analyze DNA sequences for repeating patterns.\n    Write a function that takes a DNA sequence as input and returns a list of tuples containing\n    each unique subsequence of length 3 or more that appears at least twice, along with its count.\n    The function should ignore case and only consider valid DNA bases (A, T, C, G).\n    Return the results sorted by count in descending order, then by subsequence in alphabetical order.\n\n    Example:\n    Input: \"ATCGATCGATCGcgatcgatcGATCgatcGATCGatcg\"\n    Output: [('ATCG', 5), ('GATC', 4), ('TCGA', 3), ('CGA', 3), ('ATC', 3), ('TCG', 3)]\n    \"\"\"\n", "entry_point": "parse_dna_sequence", "solution": "    # Convert the sequence to uppercase and remove any non-DNA characters\n    clean_sequence = re.sub(r'[^ATCG]', '', sequence.upper())\n    \n    # Dictionary to store subsequences and their counts\n    subsequence_counts = {}\n    \n    # Generate all possible subsequences of length 3 or more\n    for start in range(len(clean_sequence)):\n        for end in range(start + 3, len(clean_sequence) + 1):\n            subsequence = clean_sequence[start:end]\n            if subsequence in subsequence_counts:\n                subsequence_counts[subsequence] += 1\n            else:\n                subsequence_counts[subsequence] = 1\n    \n    # Filter subsequences that appear at least twice\n    repeated_subsequences = [(seq, count) for seq, count in subsequence_counts.items() if count >= 2]\n    \n    # Sort the results by count (descending) and then by subsequence (alphabetical)\n    sorted_results = sorted(repeated_subsequences, key=lambda x: (-x[1], x[0]))\n    \n    return sorted_results\n", "test": "def check(candidate):\n    assert candidate(\"ATCGATCGATCG\") == [('ATC', 3), ('ATCG', 3), ('TCG', 3), ('ATCGA', 2), ('ATCGAT', 2), ('ATCGATC', 2), ('ATCGATCG', 2), ('CGA', 2), ('CGAT', 2), ('CGATC', 2), ('CGATCG', 2), ('GAT', 2), ('GATC', 2), ('GATCG', 2), ('TCGA', 2), ('TCGAT', 2), ('TCGATC', 2), ('TCGATCG', 2)]\n    assert candidate(\"GCGCGCGCGCGC\") == [('CGC', 5), ('GCG', 5), ('GCGC', 5), ('CGCG', 4), ('CGCGC', 4), ('GCGCG', 4), ('GCGCGC', 4), ('CGCGCG', 3), ('CGCGCGC', 3), ('GCGCGCG', 3), ('GCGCGCGC', 3), ('CGCGCGCG', 2), ('CGCGCGCGC', 2), ('GCGCGCGCG', 2), ('GCGCGCGCGC', 2)]\n    assert candidate(\"AAAAAAAA\") == [('AAA', 6), ('AAAA', 5), ('AAAAA', 4), ('AAAAAA', 3), ('AAAAAAA', 2)]\n    assert candidate(\"ATCGATCGATCGATCG\") == [('ATC', 4), ('ATCG', 4), ('TCG', 4), ('ATCGA', 3), ('ATCGAT', 3), ('ATCGATC', 3), ('ATCGATCG', 3), ('CGA', 3), ('CGAT', 3), ('CGATC', 3), ('CGATCG', 3), ('GAT', 3), ('GATC', 3), ('GATCG', 3), ('TCGA', 3), ('TCGAT', 3), ('TCGATC', 3), ('TCGATCG', 3), ('ATCGATCGA', 2), ('ATCGATCGAT', 2), ('ATCGATCGATC', 2), ('ATCGATCGATCG', 2), ('CGATCGA', 2), ('CGATCGAT', 2), ('CGATCGATC', 2), ('CGATCGATCG', 2), ('GATCGA', 2), ('GATCGAT', 2), ('GATCGATC', 2), ('GATCGATCG', 2), ('TCGATCGA', 2), ('TCGATCGAT', 2), ('TCGATCGATC', 2), ('TCGATCGATCG', 2)]\n    assert candidate(\"ATCGATCGATCGcgatcgatcGATCgatcGATCGatcg\") == [('ATC', 9), ('ATCG', 9), ('TCG', 9), ('CGA', 8), ('CGAT', 8), ('CGATC', 8), ('CGATCG', 8), ('GAT', 8), ('GATC', 8), ('GATCG', 8), ('ATCGA', 7), ('ATCGAT', 7), ('ATCGATC', 7), ('ATCGATCG', 7), ('TCGA', 7), ('TCGAT', 7), ('TCGATC', 7), ('TCGATCG', 7), ('CGATCGA', 6), ('CGATCGAT', 6), ('CGATCGATC', 6), ('CGATCGATCG', 6), ('GATCGA', 6), ('GATCGAT', 6), ('GATCGATC', 6), ('GATCGATCG', 6), ('ATCGATCGA', 5), ('ATCGATCGAT', 5), ('ATCGATCGATC', 5), ('ATCGATCGATCG', 5), ('TCGATCGA', 5), ('TCGATCGAT', 5), ('TCGATCGATC', 5), ('TCGATCGATCG', 5), ('CGATCGATCGA', 4), ('CGATCGATCGAT', 4), ('CGATCGATCGATC', 4), ('CGATCGATCGATCG', 4), ('GATCGATCGA', 4), ('GATCGATCGAT', 4), ('GATCGATCGATC', 4), ('GATCGATCGATCG', 4), ('ATCGATCGATCGA', 3), ('ATCGATCGATCGAT', 3), ('ATCGATCGATCGATC', 3), ('ATCGATCGATCGATCG', 3), ('CGATCGATCGATCGA', 3), ('CGATCGATCGATCGAT', 3), ('CGATCGATCGATCGATC', 3), ('CGATCGATCGATCGATCG', 3), ('GATCGATCGATCGA', 3), ('GATCGATCGATCGAT', 3), ('GATCGATCGATCGATC', 3), ('GATCGATCGATCGATCG', 3), ('TCGATCGATCGA', 3), ('TCGATCGATCGAT', 3), ('TCGATCGATCGATC', 3), ('TCGATCGATCGATCG', 3), ('ATCGATCGATCGATCGA', 2), ('ATCGATCGATCGATCGAT', 2), ('ATCGATCGATCGATCGATC', 2), ('ATCGATCGATCGATCGATCG', 2), ('CGATCGATCGATCGATCGA', 2), ('CGATCGATCGATCGATCGAT', 2), ('CGATCGATCGATCGATCGATC', 2), ('CGATCGATCGATCGATCGATCG', 2), ('GATCGATCGATCGATCGA', 2), ('GATCGATCGATCGATCGAT', 2), ('GATCGATCGATCGATCGATC', 2), ('GATCGATCGATCGATCGATCG', 2), ('TCGATCGATCGATCGA', 2), ('TCGATCGATCGATCGAT', 2), ('TCGATCGATCGATCGATC', 2), ('TCGATCGATCGATCGATCG', 2)]\n    assert candidate(\"ATATATATATAT\") == [('ATA', 5), ('ATAT', 5), ('TAT', 5), ('ATATA', 4), ('ATATAT', 4), ('TATA', 4), ('TATAT', 4), ('ATATATA', 3), ('ATATATAT', 3), ('TATATA', 3), ('TATATAT', 3), ('ATATATATA', 2), ('ATATATATAT', 2), ('TATATATA', 2), ('TATATATAT', 2)]\n    assert candidate(\"AAAAATTTTTCCCCCGGGGG\") == [('AAA', 3), ('CCC', 3), ('GGG', 3), ('TTT', 3), ('AAAA', 2), ('CCCC', 2), ('GGGG', 2), ('TTTT', 2)]\n    assert candidate(\"ATCGATCGATCGATCGATCGATCG\") == [('ATC', 6), ('ATCG', 6), ('TCG', 6), ('ATCGA', 5), ('ATCGAT', 5), ('ATCGATC', 5), ('ATCGATCG', 5), ('CGA', 5), ('CGAT', 5), ('CGATC', 5), ('CGATCG', 5), ('GAT', 5), ('GATC', 5), ('GATCG', 5), ('TCGA', 5), ('TCGAT', 5), ('TCGATC', 5), ('TCGATCG', 5), ('ATCGATCGA', 4), ('ATCGATCGAT', 4), ('ATCGATCGATC', 4), ('ATCGATCGATCG', 4), ('CGATCGA', 4), ('CGATCGAT', 4), ('CGATCGATC', 4), ('CGATCGATCG', 4), ('GATCGA', 4), ('GATCGAT', 4), ('GATCGATC', 4), ('GATCGATCG', 4), ('TCGATCGA', 4), ('TCGATCGAT', 4), ('TCGATCGATC', 4), ('TCGATCGATCG', 4), ('ATCGATCGATCGA', 3), ('ATCGATCGATCGAT', 3), ('ATCGATCGATCGATC', 3), ('ATCGATCGATCGATCG', 3), ('CGATCGATCGA', 3), ('CGATCGATCGAT', 3), ('CGATCGATCGATC', 3), ('CGATCGATCGATCG', 3), ('GATCGATCGA', 3), ('GATCGATCGAT', 3), ('GATCGATCGATC', 3), ('GATCGATCGATCG', 3), ('TCGATCGATCGA', 3), ('TCGATCGATCGAT', 3), ('TCGATCGATCGATC', 3), ('TCGATCGATCGATCG', 3), ('ATCGATCGATCGATCGA', 2), ('ATCGATCGATCGATCGAT', 2), ('ATCGATCGATCGATCGATC', 2), ('ATCGATCGATCGATCGATCG', 2), ('CGATCGATCGATCGA', 2), ('CGATCGATCGATCGAT', 2), ('CGATCGATCGATCGATC', 2), ('CGATCGATCGATCGATCG', 2), ('GATCGATCGATCGA', 2), ('GATCGATCGATCGAT', 2), ('GATCGATCGATCGATC', 2), ('GATCGATCGATCGATCG', 2), ('TCGATCGATCGATCGA', 2), ('TCGATCGATCGATCGAT', 2), ('TCGATCGATCGATCGATC', 2), ('TCGATCGATCGATCGATCG', 2)]\n    assert candidate(\"ATCGATCGATCGATCGATCG\") == [('ATC', 5), ('ATCG', 5), ('TCG', 5), ('ATCGA', 4), ('ATCGAT', 4), ('ATCGATC', 4), ('ATCGATCG', 4), ('CGA', 4), ('CGAT', 4), ('CGATC', 4), ('CGATCG', 4), ('GAT', 4), ('GATC', 4), ('GATCG', 4), ('TCGA', 4), ('TCGAT', 4), ('TCGATC', 4), ('TCGATCG', 4), ('ATCGATCGA', 3), ('ATCGATCGAT', 3), ('ATCGATCGATC', 3), ('ATCGATCGATCG', 3), ('CGATCGA', 3), ('CGATCGAT', 3), ('CGATCGATC', 3), ('CGATCGATCG', 3), ('GATCGA', 3), ('GATCGAT', 3), ('GATCGATC', 3), ('GATCGATCG', 3), ('TCGATCGA', 3), ('TCGATCGAT', 3), ('TCGATCGATC', 3), ('TCGATCGATCG', 3), ('ATCGATCGATCGA', 2), ('ATCGATCGATCGAT', 2), ('ATCGATCGATCGATC', 2), ('ATCGATCGATCGATCG', 2), ('CGATCGATCGA', 2), ('CGATCGATCGAT', 2), ('CGATCGATCGATC', 2), ('CGATCGATCGATCG', 2), ('GATCGATCGA', 2), ('GATCGATCGAT', 2), ('GATCGATCGATC', 2), ('GATCGATCGATCG', 2), ('TCGATCGATCGA', 2), ('TCGATCGATCGAT', 2), ('TCGATCGATCGATC', 2), ('TCGATCGATCGATCG', 2)]\n    assert candidate(\"ATCG\") == []\n", "language": "python"}
{"task_id": "revision1a_problem738", "prompt": "from typing import List, Dict, Tuple\nfrom collections import defaultdict, deque\n\ndef analyze_social_network(n: int, connections: List[Tuple[str, str]], k: int) -> Dict[str, int]:\n    \"\"\"\n    You are a data scientist analyzing a social network. Your task is to identify the most influential users\n    in the network based on their connections and the spread of their influence.\n\n    Write a function that takes the number of users, a list of connections between users, and a parameter k\n    representing the depth of influence. The function should return a dictionary with users as keys and their\n    influence scores as values.\n\n    The influence score is calculated as follows:\n    1. Direct connections contribute 1 point.\n    2. Indirect connections contribute 1/d points, where d is the distance from the user.\n    3. Only consider connections up to depth k.\n\n    Use graph traversal algorithms (e.g., BFS or DFS) and memoization to optimize the solution for large networks.\n\n    Example:\n    Input: 5, [(\"A\", \"B\"), (\"B\", \"C\"), (\"C\", \"D\"), (\"D\", \"E\"), (\"A\", \"C\")], 2\n    Output: {\"A\": 3.5, \"B\": 3.0, \"C\": 3.5, \"D\": 2.5, \"E\": 1.5}\n\n    Input: 4, [(\"W\", \"X\"), (\"X\", \"Y\"), (\"Y\", \"Z\")], 3\n    Output: {\"W\": 2.5, \"X\": 2.83, \"Y\": 2.5, \"Z\": 1.5}\n    \"\"\"\n", "entry_point": "analyze_social_network", "solution": "    # Build the graph\n    graph = defaultdict(set)\n    for u, v in connections:\n        graph[u].add(v)\n        graph[v].add(u)\n    \n    # Initialize influence scores\n    influence_scores = {user: 0 for user in graph}\n    \n    def bfs(start_user):\n        visited = set()\n        queue = deque([(start_user, 0)])\n        while queue:\n            user, depth = queue.popleft()\n            if user not in visited and depth <= k:\n                visited.add(user)\n                influence_scores[start_user] += 1 / (depth + 1)\n                for neighbor in graph[user]:\n                    if neighbor not in visited:\n                        queue.append((neighbor, depth + 1))\n    \n    # Calculate influence scores for each user\n    for user in graph:\n        bfs(user)\n    \n    # Round the scores to 2 decimal places\n    return {user: round(score, 2) for user, score in influence_scores.items()}\n", "test": "def check(candidate):\n    assert candidate(7, [(\"A\", \"B\"), (\"B\", \"C\"), (\"C\", \"D\"), (\"D\", \"E\"), (\"E\", \"F\"), (\"F\", \"G\"), (\"G\", \"A\")], 4) == {'A': 3.17, 'B': 3.17, 'C': 3.17, 'D': 3.17, 'E': 3.17, 'F': 3.17, 'G': 3.17}\n    assert candidate(3, [(\"A\", \"B\"), (\"B\", \"C\")], 1) == {'A': 1.5, 'B': 2.0, 'C': 1.5}\n    assert candidate(6, [(\"A\", \"B\"), (\"B\", \"C\"), (\"C\", \"D\"), (\"D\", \"E\"), (\"E\", \"F\")], 6) == {'A': 2.45, 'B': 2.78, 'C': 2.92, 'D': 2.92, 'E': 2.78, 'F': 2.45}\n    assert candidate(5, [(\"A\", \"B\"), (\"A\", \"C\"), (\"A\", \"D\"), (\"A\", \"E\")], 1) == {'A': 3.0, 'B': 1.5, 'C': 1.5, 'D': 1.5, 'E': 1.5}\n    assert candidate(6, [(\"A\", \"B\"), (\"B\", \"C\"), (\"C\", \"D\"), (\"D\", \"E\"), (\"E\", \"F\"), (\"A\", \"F\")], 3) == {'A': 2.92, 'B': 2.92, 'C': 2.92, 'D': 2.92, 'E': 2.92, 'F': 2.92}\n    assert candidate(4, [(\"A\", \"B\"), (\"B\", \"C\"), (\"C\", \"D\"), (\"D\", \"A\")], 2) == {'A': 2.33, 'B': 2.33, 'C': 2.33, 'D': 2.33}\n    assert candidate(4, [(\"W\", \"X\"), (\"X\", \"Y\"), (\"Y\", \"Z\")], 3) == {'W': 2.08, 'X': 2.33, 'Y': 2.33, 'Z': 2.08}\n    assert candidate(3, [(\"A\", \"B\"), (\"B\", \"C\"), (\"C\", \"A\")], 2) == {'A': 2.0, 'B': 2.0, 'C': 2.0}\n    assert candidate(2, [(\"X\", \"Y\")], 5) == {'X': 1.5, 'Y': 1.5}\n    assert candidate(5, [(\"A\", \"B\"), (\"B\", \"C\"), (\"C\", \"D\"), (\"D\", \"E\"), (\"A\", \"C\")], 2) == {'A': 2.33, 'B': 2.33, 'C': 2.83, 'D': 2.67, 'E': 1.83}\n", "language": "python"}
{"task_id": "revision1a_problem366", "prompt": "from typing import List\n\ndef encrypt_message(message: str, key: int) -> str:\n    \"\"\"\n    You are a secret agent tasked with encrypting important messages. Implement a Caesar cipher encryption algorithm.\n    The Caesar cipher is a simple substitution cipher where each letter in the plaintext is shifted a certain number of positions down the alphabet.\n\n    Take the input message as a string and the key as an integer representing the shift.\n    Return the encrypted message as a string.\n\n    Rules:\n    1. Shift each letter in the message by the key value.\n    2. Wrap around to the beginning of the alphabet if necessary.\n    3. Preserve spaces and punctuation.\n    4. Maintain the case (uppercase or lowercase) of the original letter.\n\n    Example:\n    Input: \"Hello, World!\", 3\n    Output: \"Khoor, Zruog!\"\n\n    Input: \"Secret Agent\", 7\n    Output: \"Zljyla Hnlua\"\n\n    Input: \"PYTHON\", 13\n    Output: \"CLGUBA\"\n    \"\"\"\n", "entry_point": "encrypt_message", "solution": "    def shift_char(char: str, shift: int) -> str:\n        if not char.isalpha():\n            return char\n        \n        ascii_offset = ord('A') if char.isupper() else ord('a')\n        return chr((ord(char) - ascii_offset + shift) % 26 + ascii_offset)\n\n    encrypted_message = ''\n    for char in message:\n        encrypted_message += shift_char(char, key)\n    \n    return encrypted_message\n", "test": "def check(candidate):\n    assert candidate(\"\", 5) == ''\n    assert candidate(\"ABCDEFGHIJKLMNOPQRSTUVWXYZ\", 25) == 'ZABCDEFGHIJKLMNOPQRSTUVWXY'\n    assert candidate(\"PYTHON\", 13) == 'CLGUBA'\n    assert candidate(\"1234567890\", 1) == '1234567890'\n    assert candidate(\"Encryption is fun!\", 26) == 'Encryption is fun!'\n    assert candidate(\"Secret Agent\", 7) == 'Zljyla Hnlua'\n    assert candidate(\"The quick brown fox jumps over the lazy dog.\", 8) == 'Bpm ycqks jzwev nwf rcuxa wdmz bpm tihg lwo.'\n    assert candidate(\"Hello, World!\", 3) == 'Khoor, Zruog!'\n    assert candidate(\"Caesar cipher\", 0) == 'Caesar cipher'\n    assert candidate(\"abcdefghijklmnopqrstuvwxyz\", 1) == 'bcdefghijklmnopqrstuvwxyza'\n", "language": "python"}
{"task_id": "revision1a_problem359", "prompt": "from typing import List\n\ndef optimal_route(grid: List[List[int]]) -> int:\n    \"\"\"\n    A delivery driver needs to find the optimal route through a city grid to deliver packages.\n    The city is represented as a 2D grid where each cell contains the time (in minutes) it takes to pass through that block.\n    The driver starts at the top-left corner (0,0) and needs to reach the bottom-right corner.\n    The driver can only move right or down.\n\n    Take the grid as input from the user and return the minimum time required to reach the destination.\n\n    Example:\n    Input: [[1,3,1],[1,5,1],[4,2,1]]\n    Output: 7\n\n    Input: [[1,2,3],[4,5,6]]\n    Output: 12\n    \"\"\"\n", "entry_point": "optimal_route", "solution": "    if not grid or not grid[0]:\n        return 0\n\n    rows, cols = len(grid), len(grid[0])\n    \n    # Create a dp table to store minimum time to reach each cell\n    dp = [[0] * cols for _ in range(rows)]\n    \n    # Initialize the first cell\n    dp[0][0] = grid[0][0]\n    \n    # Initialize the first row\n    for j in range(1, cols):\n        dp[0][j] = dp[0][j-1] + grid[0][j]\n    \n    # Initialize the first column\n    for i in range(1, rows):\n        dp[i][0] = dp[i-1][0] + grid[i][0]\n    \n    # Fill the dp table\n    for i in range(1, rows):\n        for j in range(1, cols):\n            dp[i][j] = min(dp[i-1][j], dp[i][j-1]) + grid[i][j]\n    \n    # Return the minimum time to reach the bottom-right corner\n    return dp[rows-1][cols-1]\n", "test": "def check(candidate):\n    assert candidate([[100]]) == 100\n    assert candidate([[1,1,1,1],[1,1,1,1],[1,1,1,1],[1,1,1,1]]) == 7\n    assert candidate([[5,4,3],[2,1,2],[3,4,5]]) == 15\n    assert candidate([[1,2,3],[4,5,6]]) == 12\n    assert candidate([[1]]) == 1\n    assert candidate([[10,20,30],[40,50,60],[70,80,90]]) == 210\n    assert candidate([[1,1],[1,1]]) == 3\n    assert candidate([[1,3,1],[1,5,1],[4,2,1]]) == 7\n    assert candidate([[1,2],[3,4]]) == 7\n    assert candidate([[1,2,3,4,5],[6,7,8,9,10]]) == 25\n", "language": "python"}
{"task_id": "revision1a_problem244", "prompt": "import heapq\nfrom typing import List, Tuple\n\ndef network_latency(nodes: int, connections: List[Tuple[int, int, int]], start: int) -> List[int]:\n    \"\"\"\n    As a network engineer, I need to analyze the latency in a computer network.\n    The network consists of multiple nodes connected by links with varying transmission times.\n    My task is to find the minimum latency from a given start node to all other nodes in the network.\n    Take input from the user for the number of nodes, the connections between nodes (source, destination, transmission time),\n    and the start node. Return a list of minimum latencies from the start node to all other nodes.\n    If a node is unreachable, its latency should be represented as -1.\n\n    Example:\n    Input: 4, [(0,1,10), (0,2,5), (1,2,2), (1,3,1), (2,3,9)], 0\n    Output: [0, 7, 5, 8]\n    \"\"\"\n", "entry_point": "network_latency", "solution": "    # Create an adjacency list to represent the network\n    graph = [[] for _ in range(nodes)]\n    for source, dest, time in connections:\n        graph[source].append((dest, time))\n\n    # Initialize distances with infinity, except for the start node\n    distances = [float('inf')] * nodes\n    distances[start] = 0\n\n    # Use a priority queue to store nodes to visit\n    pq = [(0, start)]\n\n    while pq:\n        current_dist, current_node = heapq.heappop(pq)\n\n        # If we've found a longer path, skip this node\n        if current_dist > distances[current_node]:\n            continue\n\n        # Check all neighbors of the current node\n        for neighbor, time in graph[current_node]:\n            distance = current_dist + time\n\n            # If we've found a shorter path, update the distance\n            if distance < distances[neighbor]:\n                distances[neighbor] = distance\n                heapq.heappush(pq, (distance, neighbor))\n\n    # Convert unreachable nodes (inf) to -1\n    return [d if d != float('inf') else -1 for d in distances]\n", "test": "def check(candidate):\n    assert candidate(5, [(0,1,1), (1,2,2), (2,3,3), (3,4,4)], 0) == [0, 1, 3, 6, 10]\n    assert candidate(4, [(0,1,10), (0,2,5), (1,2,2), (1,3,1), (2,3,9)], 0) == [0, 10, 5, 11]\n    assert candidate(1, [], 0) == [0]\n    assert candidate(3, [(0,1,5), (1,2,5)], 2) == [-1, -1, 0]\n    assert candidate(5, [(0,1,1), (1,2,2), (2,3,3), (3,4,4), (0,4,1)], 0) == [0, 1, 3, 6, 1]\n    assert candidate(4, [(0,1,1), (0,2,2), (0,3,3)], 0) == [0, 1, 2, 3]\n    assert candidate(3, [(0,1,1), (1,2,1)], 0) == [0, 1, 2]\n    assert candidate(4, [(0,1,1), (1,2,1), (2,3,1), (3,0,1)], 0) == [0, 1, 2, 3]\n    assert candidate(2, [(0,1,1)], 0) == [0, 1]\n    assert candidate(6, [(0,1,10), (0,2,15), (1,3,12), (2,4,10), (3,5,5), (4,5,10)], 0) == [0, 10, 15, 22, 25, 27]\n", "language": "python"}
{"task_id": "revision1a_problem253", "prompt": "from typing import List\nimport heapq\n\ndef optimize_delivery_route(n: int, packages: List[tuple]) -> List[str]:\n    \"\"\"\n    As a delivery company, you want to optimize your delivery route to minimize fuel consumption and delivery time.\n    Implement a priority queue using a heap to determine the most efficient order of deliveries.\n    Take input from the user for n packages and their details (weight, distance, priority).\n    Return the optimized delivery order as a list of package IDs.\n    If a package's weight exceeds the vehicle's capacity (1000 kg), mark it as \"Undeliverable\".\n    \n    Example:\n    Input: 5, [(50, 10, 2), (30, 5, 1), (100, 20, 3), (1200, 15, 2), (80, 8, 1)]\n    Output: [\"Package 2\", \"Package 5\", \"Package 1\", \"Package 3\", \"Undeliverable\"]\n    \"\"\"\n", "entry_point": "optimize_delivery_route", "solution": "    def calculate_score(weight, distance, priority):\n        return (priority * 1000) - (weight * 0.5 + distance * 2)\n\n    priority_queue = []\n    optimized_route = []\n    undeliverable = []\n\n    for i, (weight, distance, priority) in enumerate(packages, 1):\n        if weight > 1000:\n            undeliverable.append(f\"Undeliverable\")\n        else:\n            score = calculate_score(weight, distance, priority)\n            heapq.heappush(priority_queue, (-score, i))\n\n    while priority_queue:\n        _, package_id = heapq.heappop(priority_queue)\n        optimized_route.append(f\"Package {package_id}\")\n\n    return optimized_route + undeliverable\n", "test": "def check(candidate):\n    assert candidate(5, [(50, 10, 2), (30, 5, 1), (100, 20, 3), (1200, 15, 2), (80, 8, 1)]) == ['Package 3', 'Package 1', 'Package 2', 'Package 5', 'Undeliverable']\n    assert candidate(4, [(250, 30, 3), (250, 30, 2), (250, 30, 1), (250, 30, 4)]) == ['Package 4', 'Package 1', 'Package 2', 'Package 3']\n    assert candidate(1, [(999, 100, 1)]) == ['Package 1']\n    assert candidate(6, [(200, 20, 2), (300, 15, 1), (400, 10, 3), (500, 5, 2), (600, 25, 1), (700, 30, 3)]) == ['Package 3', 'Package 6', 'Package 1', 'Package 4', 'Package 2', 'Package 5']\n    assert candidate(4, [(800, 40, 1), (700, 35, 2), (600, 30, 3), (500, 25, 4)]) == ['Package 4', 'Package 3', 'Package 2', 'Package 1']\n    assert candidate(2, [(0, 0, 0), (1, 1, 1)]) == ['Package 2', 'Package 1']\n    assert candidate(2, [(1000, 50, 1), (1001, 50, 1)]) == ['Package 1', 'Undeliverable']\n    assert candidate(3, [(100, 5, 1), (100, 10, 1), (100, 15, 1)]) == ['Package 1', 'Package 2', 'Package 3']\n    assert candidate(3, [(500, 10, 1), (300, 5, 2), (200, 15, 3)]) == ['Package 3', 'Package 2', 'Package 1']\n    assert candidate(3, [(1000, 50, 1), (1000, 50, 2), (1000, 50, 3)]) == ['Package 3', 'Package 2', 'Package 1']\n", "language": "python"}
{"task_id": "revision1a_problem156", "prompt": "from typing import List, Tuple\nimport re\n\ndef analyze_text_sentiment(text: str) -> Tuple[int, List[str], List[str]]:\n    \"\"\"\n    Perform a basic sentiment analysis on a given text to understand the emotional tone of the content.\n\n    Your task is to create a program that analyzes the sentiment of a given text by counting positive and negative words,\n    identifying key phrases, and determining the overall sentiment score. The program should use regular expressions to\n    find and count words, and implement a simple scoring system based on predefined positive and negative word lists.\n\n    Use the re module for pattern matching and word counting. Implement list comprehensions for filtering and scoring.\n\n    Return a tuple containing the sentiment score (positive integer for positive sentiment, negative for negative sentiment),\n    a list of identified positive words/phrases, and a list of identified negative words/phrases.\n\n    Example:\n    Input: \"I love this product! It's amazing and works great. However, the customer service could be better.\"\n    Output: (2, ['love', 'amazing', 'great'], ['could be better'])\n    \"\"\"\n", "entry_point": "analyze_text_sentiment", "solution": "    # Predefined lists of positive and negative words/phrases\n    positive_words = ['love', 'great', 'amazing', 'excellent', 'good', 'awesome', 'fantastic', 'wonderful']\n    negative_words = ['bad', 'terrible', 'awful', 'horrible', 'poor', 'disappointing']\n    negative_phrases = ['could be better', 'not good', 'needs improvement']\n\n    # Convert text to lowercase for case-insensitive matching\n    text = text.lower()\n\n    # Find all words in the text\n    words = re.findall(r'\\b\\w+\\b', text)\n\n    # Count positive and negative words\n    positive_count = sum(1 for word in words if word in positive_words)\n    negative_count = sum(1 for word in words if word in negative_words)\n\n    # Identify positive words/phrases\n    positive_matches = [word for word in words if word in positive_words]\n\n    # Identify negative words/phrases\n    negative_matches = [word for word in words if word in negative_words]\n    negative_matches.extend([phrase for phrase in negative_phrases if phrase in text])\n\n    # Calculate sentiment score\n    sentiment_score = positive_count - negative_count\n\n    return (sentiment_score, positive_matches, negative_matches)\n", "test": "def check(candidate):\n    assert candidate(\"I absolutely hate this terrible product. It\\'s the worst thing I\\'ve ever bought!\") == (-1, [], ['terrible'])\n    assert candidate(\"I love this product! It\\'s amazing and works great. However, the customer service could be better.\") == (3, ['love', 'amazing', 'great'], ['could be better'])\n    assert candidate(\"This is a neutral statement without any strong emotions.\") == (0, [], [])\n    assert candidate(\"Good bad good bad good\") == (1, ['good', 'good', 'good'], ['bad', 'bad'])\n    assert candidate(\"EXCELLENT! WONDERFUL! FANTASTIC! INCREDIBLE!\") == (3, ['excellent', 'wonderful', 'fantastic'], [])\n    assert candidate(\"I\\'m extremely disappointed with the service. It\\'s awful and frustrating.\") == (-1, [], ['awful'])\n    assert candidate(\"I\\'m feeling really happy today! Everything is going so well!\") == (0, [], [])\n    assert candidate(\"The movie was okay, not great but not bad either.\") == (0, ['great'], ['bad'])\n    assert candidate(\"horrible. awful. terrible. disgusting.\") == (-3, [], ['horrible', 'awful', 'terrible'])\n    assert candidate(\"\") == (0, [], [])\n", "language": "python"}
{"task_id": "revision1a_problem454", "prompt": "def calculate_carbon_footprint(activities: dict) -> float:\n    \"\"\"\n    An environmentally conscious individual wants to calculate their carbon footprint based on daily activities.\n\n    Take a dictionary of activities and their corresponding carbon emissions as input, and return the total carbon footprint in kg of CO2.\n\n    Activities can include transportation methods, energy consumption, and food choices.\n\n    Example:\n    Input: {\n        'car_miles': 20,\n        'bus_miles': 5,\n        'kwh_electricity': 10,\n        'meat_servings': 2,\n        'vegetarian_meals': 1\n    }\n    Output: 12.45\n\n    Input: {\n        'train_miles': 50,\n        'kwh_electricity': 5,\n        'vegan_meals': 3\n    }\n    Output: 3.75\n    \"\"\"\n", "entry_point": "calculate_carbon_footprint", "solution": "    # Define emission factors for different activities (in kg CO2 per unit)\n    emission_factors = {\n        'car_miles': 0.4,\n        'bus_miles': 0.2,\n        'train_miles': 0.1,\n        'kwh_electricity': 0.5,\n        'meat_servings': 3.0,\n        'vegetarian_meals': 1.5,\n        'vegan_meals': 1.0\n    }\n\n    total_emissions = 0.0\n\n    # Calculate emissions for each activity\n    for activity, value in activities.items():\n        if activity in emission_factors:\n            total_emissions += value * emission_factors[activity]\n\n    # Round the result to two decimal places\n    return round(total_emissions, 2)\n", "test": "def check(candidate):\n    assert candidate({'meat_servings': 10, 'vegetarian_meals': 5}) == 37.5\n    assert candidate({'car_miles': 100}) == 40.0\n    assert candidate({'train_miles': 50, 'kwh_electricity': 5, 'vegan_meals': 3}) == 10.5\n    assert candidate({'car_miles': 0.5, 'meat_servings': 0.5}) == 1.7\n    assert candidate({'kwh_electricity': 1000}) == 500.0\n    assert candidate({}) == 0.0\n    assert candidate({'car_miles': 5, 'bus_miles': 10, 'train_miles': 15, 'kwh_electricity': 20}) == 15.5\n    assert candidate({'car_miles': 20, 'bus_miles': 5, 'kwh_electricity': 10, 'meat_servings': 2, 'vegetarian_meals': 1}) == 21.5\n    assert candidate({'vegan_meals': 21}) == 21.0\n", "language": "python"}
{"task_id": "revision1a_problem19", "prompt": "import heapq\nfrom typing import List, Dict\n\ndef network_packet_scheduler(packets: List[Dict[str, int]], bandwidth: int) -> List[int]:\n    \"\"\"\n    As a network engineer, I need to implement a packet scheduler for a router.\n    Given a list of packets with their sizes and priorities, and the available bandwidth,\n    determine the order in which packets should be transmitted to maximize network efficiency.\n\n    Use a priority queue (heap) to implement this scheduler.\n\n    Input:\n    - packets: A list of dictionaries, where each dictionary represents a packet with keys:\n               'id': unique identifier for the packet\n               'size': size of the packet in bytes\n               'priority': priority of the packet (higher number means higher priority)\n    - bandwidth: Available bandwidth in bytes per second\n\n    Output:\n    - A list of packet IDs in the order they should be transmitted\n\n    Example:\n    Input:\n    packets = [\n        {'id': 1, 'size': 100, 'priority': 3},\n        {'id': 2, 'size': 50, 'priority': 2},\n        {'id': 3, 'size': 200, 'priority': 4},\n        {'id': 4, 'size': 80, 'priority': 1}\n    ]\n    bandwidth = 300\n\n    Output: [3, 1, 2, 4]\n\n    This output indicates that packet 3 should be sent first, followed by packets 1, 2, and 4.\n    \"\"\"\n", "entry_point": "network_packet_scheduler", "solution": "    # Create a priority queue (max-heap) based on packet priority\n    priority_queue = [(-packet['priority'], packet['id'], packet['size']) for packet in packets]\n    heapq.heapify(priority_queue)\n\n    transmission_order = []\n    remaining_bandwidth = bandwidth\n\n    while priority_queue:\n        _, packet_id, packet_size = heapq.heappop(priority_queue)\n\n        if packet_size <= remaining_bandwidth:\n            transmission_order.append(packet_id)\n            remaining_bandwidth -= packet_size\n        else:\n            # If the packet doesn't fit in the remaining bandwidth,\n            # push it back to the queue and reset the bandwidth\n            heapq.heappush(priority_queue, (-priority_queue[0][0], packet_id, packet_size))\n            remaining_bandwidth = bandwidth\n\n    return transmission_order\n", "test": "def check(candidate):\n    assert candidate([{'id': 1, 'size': 100000, 'priority': 1}], 100000) == [1]\n    assert candidate([{'id': 1, 'size': 10, 'priority': 1}, {'id': 2, 'size': 20, 'priority': 2}, {'id': 3, 'size': 30, 'priority': 3}], 100) == [3, 2, 1]\n    assert candidate([{'id': 1, 'size': 50, 'priority': 1}, {'id': 2, 'size': 50, 'priority': 1}], 100) == [1, 2]\n    assert candidate([{'id': 1, 'size': 100, 'priority': 3}, {'id': 2, 'size': 50, 'priority': 2}, {'id': 3, 'size': 200, 'priority': 4}, {'id': 4, 'size': 80, 'priority': 1}], 300) == [3, 1, 4, 2]\n    assert candidate([{'id': 1, 'size': 100, 'priority': 5}, {'id': 2, 'size': 100, 'priority': 5}], 200) == [1, 2]\n    assert candidate([{'id': 1, 'size': 100, 'priority': 1}, {'id': 2, 'size': 200, 'priority': 2}, {'id': 3, 'size': 300, 'priority': 3}], 1000) == [3, 2, 1]\n    assert candidate([], 1000) == []\n    assert candidate([{'id': i, 'size': 10, 'priority': i} for i in range(1, 11)], 100) == [10, 9, 8, 7, 6, 5, 4, 3, 2, 1]\n    assert candidate([{'id': 1, 'size': 100, 'priority': 1}], 100) == [1]\n", "language": "python"}
{"task_id": "revision1a_problem275", "prompt": "import re\nfrom typing import List, Dict\n\ndef analyze_shopping_cart(items: str) -> Dict[str, List[str]]:\n    \"\"\"\n    As a data analyst for an e-commerce platform, you need to categorize items in shopping carts.\n\n    The function should do the following:\n    1. Split the input string into individual items.\n    2. Categorize each item into one of four categories: 'Electronics', 'Clothing', 'Books', or 'Other'.\n    3. Items containing words like 'phone', 'laptop', 'tablet' should be categorized as 'Electronics'.\n    4. Items containing words like 'shirt', 'pants', 'dress' should be categorized as 'Clothing'.\n    5. Items containing words like 'novel', 'textbook', 'magazine' should be categorized as 'Books'.\n    6. All other items should be categorized as 'Other'.\n    7. Return a dictionary with categories as keys and lists of items as values.\n\n    Take a string of items separated by commas as input and return the categorized dictionary.\n\n    Example:\n\n    Input: \"smartphone, blue jeans, python textbook, toaster, sci-fi novel, red dress\"\n    Output: {\n        'Electronics': ['smartphone'],\n        'Clothing': ['blue jeans', 'red dress'],\n        'Books': ['python textbook', 'sci-fi novel'],\n        'Other': ['toaster']\n    }\n\n    Input: \"laptop bag, mystery novel, desk lamp, cotton t-shirt\"\n    Output: {\n        'Electronics': [],\n        'Clothing': ['cotton t-shirt'],\n        'Books': ['mystery novel'],\n        'Other': ['laptop bag', 'desk lamp']\n    }\n    \"\"\"\n", "entry_point": "analyze_shopping_cart", "solution": "    # Initialize the categories dictionary\n    categories = {\n        'Electronics': [],\n        'Clothing': [],\n        'Books': [],\n        'Other': []\n    }\n    \n    # Split the input string into individual items\n    item_list = [item.strip() for item in items.split(',')]\n    \n    # Define category patterns\n    electronics_pattern = r'phone|laptop|tablet'\n    clothing_pattern = r'shirt|pants|dress|jeans'\n    books_pattern = r'novel|textbook|magazine'\n    \n    # Categorize each item\n    for item in item_list:\n        if re.search(electronics_pattern, item, re.IGNORECASE):\n            categories['Electronics'].append(item)\n        elif re.search(clothing_pattern, item, re.IGNORECASE):\n            categories['Clothing'].append(item)\n        elif re.search(books_pattern, item, re.IGNORECASE):\n            categories['Books'].append(item)\n        else:\n            categories['Other'].append(item)\n    \n    return categories\n", "test": "def check(candidate):\n    assert candidate(\"wireless earbuds, leather jacket, academic journal, coffee maker\") == {'Electronics': [], 'Clothing': [], 'Books': [], 'Other': ['wireless earbuds', 'leather jacket', 'academic journal', 'coffee maker']}\n    assert candidate(\"portable speaker, business suit, dictionary, water bottle\") == {'Electronics': [], 'Clothing': [], 'Books': [], 'Other': ['portable speaker', 'business suit', 'dictionary', 'water bottle']}\n    assert candidate(\"tablet cover, dress shirt, magazine subscription, headphones\") == {'Electronics': ['tablet cover', 'headphones'], 'Clothing': ['dress shirt'], 'Books': ['magazine subscription'], 'Other': []}\n    assert candidate(\"phone charger, e-book reader, running shoes, cookbooks\") == {'Electronics': ['phone charger'], 'Clothing': [], 'Books': [], 'Other': ['e-book reader', 'running shoes', 'cookbooks']}\n    assert candidate(\"digital camera, swimsuit, travel guide, sunscreen\") == {'Electronics': [], 'Clothing': [], 'Books': [], 'Other': ['digital camera', 'swimsuit', 'travel guide', 'sunscreen']}\n    assert candidate(\"smartphone, blue jeans, python textbook, toaster, sci-fi novel, red dress\") == {'Electronics': ['smartphone'], 'Clothing': ['blue jeans', 'red dress'], 'Books': ['python textbook', 'sci-fi novel'], 'Other': ['toaster']}\n    assert candidate(\"smart thermostat, pajamas, autobiography, plant pot\") == {'Electronics': [], 'Clothing': [], 'Books': [], 'Other': ['smart thermostat', 'pajamas', 'autobiography', 'plant pot']}\n    assert candidate(\"laptop bag, mystery novel, desk lamp, cotton t-shirt\") == {'Electronics': ['laptop bag'], 'Clothing': ['cotton t-shirt'], 'Books': ['mystery novel'], 'Other': ['desk lamp']}\n    assert candidate(\"gaming console, winter coat, comic books, kitchen utensils\") == {'Electronics': [], 'Clothing': [], 'Books': [], 'Other': ['gaming console', 'winter coat', 'comic books', 'kitchen utensils']}\n    assert candidate(\"smart watch, yoga pants, historical fiction, blender\") == {'Electronics': [], 'Clothing': ['yoga pants'], 'Books': [], 'Other': ['smart watch', 'historical fiction', 'blender']}\n", "language": "python"}
{"task_id": "revision1a_problem640", "prompt": "from typing import List\n\ndef is_valid_triangle(sides: List[float]) -> bool:\n    \"\"\"\n    Check if the given side lengths can form a valid triangle.\n    A valid triangle is one where the sum of any two sides is greater than the third side.\n\n    Take input from the user for three side lengths and return True if they can form a valid triangle, False otherwise.\n\n    Input: [3, 4, 5]\n    Output: True\n    Input: [1, 1, 3]\n    Output: False\n    Input: [5, 5, 10]\n    Output: False\n    \"\"\"\n", "entry_point": "is_valid_triangle", "solution": "    # Check if we have exactly 3 sides\n    if len(sides) != 3:\n        return False\n\n    # Sort the sides in ascending order\n    sides.sort()\n\n    # Check if the sum of the two shorter sides is greater than the longest side\n    if sides[0] + sides[1] > sides[2]:\n        return True\n    else:\n        return False\n", "test": "def check(candidate):\n    assert candidate([1, 1, 3]) == False\n    assert candidate([3.5, 4.5, 5.5]) == True\n    assert candidate([1, 2, 2]) == True\n    assert candidate([7, 10, 5]) == True\n    assert candidate([0.1, 0.1, 0.1]) == True\n    assert candidate([100, 101, 199]) == True\n    assert candidate([2, 2, 2]) == True\n    assert candidate([5, 5, 10]) == False\n    assert candidate([3, 4, 5]) == True\n    assert candidate([1.0, 1.0, 1.0]) == True\n", "language": "python"}
{"task_id": "revision1a_problem466", "prompt": "from typing import List\n\ndef fibonacci_sequence(n: int) -> List[int]:\n    \"\"\"\n    Generate a Fibonacci sequence of length n using a generator function and list comprehension.\n    The Fibonacci sequence starts with 0 and 1, and each subsequent number is the sum of the two preceding ones.\n    \n    Example:\n    Input: 7\n    Output: [0, 1, 1, 2, 3, 5, 8]\n    Input: 10\n    Output: [0, 1, 1, 2, 3, 5, 8, 13, 21, 34]\n    \"\"\"\n", "entry_point": "fibonacci_sequence", "solution": "    def fibonacci_generator():\n        a, b = 0, 1\n        while True:\n            yield a\n            a, b = b, a + b\n    \n    fib_gen = fibonacci_generator()\n    return [next(fib_gen) for _ in range(n)]\n", "test": "def check(candidate):\n    assert candidate(20) == [0, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, 144, 233, 377, 610, 987, 1597, 2584, 4181]\n    assert candidate(10) == [0, 1, 1, 2, 3, 5, 8, 13, 21, 34]\n    assert candidate(2) == [0, 1]\n    assert candidate(5) == [0, 1, 1, 2, 3]\n    assert candidate(1) == [0]\n    assert candidate(0) == []\n    assert candidate(50) == [0, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, 144, 233, 377, 610, 987, 1597, 2584, 4181, 6765, 10946, 17711, 28657, 46368, 75025, 121393, 196418, 317811, 514229, 832040, 1346269, 2178309, 3524578, 5702887, 9227465, 14930352, 24157817, 39088169, 63245986, 102334155, 165580141, 267914296, 433494437, 701408733, 1134903170, 1836311903, 2971215073, 4807526976, 7778742049]\n    assert candidate(3) == [0, 1, 1]\n    assert candidate(100) == [0, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, 144, 233, 377, 610, 987, 1597, 2584, 4181, 6765, 10946, 17711, 28657, 46368, 75025, 121393, 196418, 317811, 514229, 832040, 1346269, 2178309, 3524578, 5702887, 9227465, 14930352, 24157817, 39088169, 63245986, 102334155, 165580141, 267914296, 433494437, 701408733, 1134903170, 1836311903, 2971215073, 4807526976, 7778742049, 12586269025, 20365011074, 32951280099, 53316291173, 86267571272, 139583862445, 225851433717, 365435296162, 591286729879, 956722026041, 1548008755920, 2504730781961, 4052739537881, 6557470319842, 10610209857723, 17167680177565, 27777890035288, 44945570212853, 72723460248141, 117669030460994, 190392490709135, 308061521170129, 498454011879264, 806515533049393, 1304969544928657, 2111485077978050, 3416454622906707, 5527939700884757, 8944394323791464, 14472334024676221, 23416728348467685, 37889062373143906, 61305790721611591, 99194853094755497, 160500643816367088, 259695496911122585, 420196140727489673, 679891637638612258, 1100087778366101931, 1779979416004714189, 2880067194370816120, 4660046610375530309, 7540113804746346429, 12200160415121876738, 19740274219868223167, 31940434634990099905, 51680708854858323072, 83621143489848422977, 135301852344706746049, 218922995834555169026]\n    assert candidate(7) == [0, 1, 1, 2, 3, 5, 8]\n", "language": "python"}
{"task_id": "revision1a_problem0", "prompt": "from typing import List\n\ndef design_smart_home(devices: List[str]) -> str:\n    \"\"\"\n    Design a smart home system using classes and objects. Create a base class called 'Device' with properties 'name' and 'status'.\n    Then, create derived classes for specific devices like 'Light', 'Thermostat', and 'SecurityCamera', each with unique properties and methods.\n    Implement a 'SmartHome' class that manages all devices and provides methods to control them.\n    Take input from the user for device names and their initial status, create objects for each device, add them to the SmartHome,\n    and return a status report of all devices in the home.\n\n    Example:\n    Input: [\"Living Room Light\", \"Kitchen Thermostat\", \"Front Door Camera\"]\n    Output: \"Smart Home Status:\n             Living Room Light: OFF\n             Kitchen Thermostat: 72\u00b0F\n             Front Door Camera: Recording\"\n\n    Input: [\"Bedroom Light\", \"Garage Door\", \"Outdoor Sprinkler\"]\n    Output: \"Smart Home Status:\n             Bedroom Light: OFF\n             Garage Door: Closed\n             Outdoor Sprinkler: OFF\"\n    \"\"\"\n", "entry_point": "design_smart_home", "solution": "    class Device:\n        def __init__(self, name):\n            self.name = name\n            self.status = \"OFF\"\n\n        def get_status(self):\n            return f\"{self.name}: {self.status}\"\n\n    class Light(Device):\n        pass\n\n    class Thermostat(Device):\n        def __init__(self, name):\n            super().__init__(name)\n            self.status = \"72\u00b0F\"\n\n    class SecurityCamera(Device):\n        def __init__(self, name):\n            super().__init__(name)\n            self.status = \"Recording\"\n\n    class GarageDoor(Device):\n        def __init__(self, name):\n            super().__init__(name)\n            self.status = \"Closed\"\n\n    class Sprinkler(Device):\n        pass\n\n    class SmartHome:\n        def __init__(self):\n            self.devices = []\n\n        def add_device(self, device):\n            self.devices.append(device)\n\n        def get_status_report(self):\n            report = \"Smart Home Status:\\n\"\n            for device in self.devices:\n                report += f\"{device.get_status()}\\n\"\n            return report.strip()\n\n    smart_home = SmartHome()\n\n    for device_name in devices:\n        if \"Light\" in device_name:\n            smart_home.add_device(Light(device_name))\n        elif \"Thermostat\" in device_name:\n            smart_home.add_device(Thermostat(device_name))\n        elif \"Camera\" in device_name:\n            smart_home.add_device(SecurityCamera(device_name))\n        elif \"Garage Door\" in device_name:\n            smart_home.add_device(GarageDoor(device_name))\n        elif \"Sprinkler\" in device_name:\n            smart_home.add_device(Sprinkler(device_name))\n        else:\n            smart_home.add_device(Device(device_name))\n\n    return smart_home.get_status_report()\n", "test": "def check(candidate):\n    assert candidate([\"Bedroom Light\", \"Garage Door\", \"Outdoor Sprinkler\"]) == 'Smart Home Status:\\nBedroom Light: OFF\\nGarage Door: Closed\\nOutdoor Sprinkler: OFF'\n    assert candidate([\"Thermostat\"]) == 'Smart Home Status:\\nThermostat: 72\u00b0F'\n    assert candidate([\"Refrigerator\", \"Oven\", \"Dishwasher\", \"Microwave\"]) == 'Smart Home Status:\\nRefrigerator: OFF\\nOven: OFF\\nDishwasher: OFF\\nMicrowave: OFF'\n    assert candidate([\"Living Room Light\", \"Kitchen Thermostat\", \"Front Door Camera\"]) == 'Smart Home Status:\\nLiving Room Light: OFF\\nKitchen Thermostat: 72\u00b0F\\nFront Door Camera: Recording'\n    assert candidate([\"Front Door Camera\", \"Back Door Camera\", \"Side Door Camera\"]) == 'Smart Home Status:\\nFront Door Camera: Recording\\nBack Door Camera: Recording\\nSide Door Camera: Recording'\n    assert candidate([\"Living Room Light\", \"Dining Room Light\", \"Kitchen Light\", \"Bedroom Light\", \"Bathroom Light\"]) == 'Smart Home Status:\\nLiving Room Light: OFF\\nDining Room Light: OFF\\nKitchen Light: OFF\\nBedroom Light: OFF\\nBathroom Light: OFF'\n    assert candidate([\"Thermostat\", \"Air Purifier\", \"Humidifier\"]) == 'Smart Home Status:\\nThermostat: 72\u00b0F\\nAir Purifier: OFF\\nHumidifier: OFF'\n    assert candidate([\"Garage Door\", \"Main Door\", \"Patio Door\"]) == 'Smart Home Status:\\nGarage Door: Closed\\nMain Door: OFF\\nPatio Door: OFF'\n    assert candidate([\"TV\", \"Sound System\", \"Gaming Console\"]) == 'Smart Home Status:\\nTV: OFF\\nSound System: OFF\\nGaming Console: OFF'\n    assert candidate([\"Bedroom Light\", \"Kitchen Light\", \"Living Room Light\"]) == 'Smart Home Status:\\nBedroom Light: OFF\\nKitchen Light: OFF\\nLiving Room Light: OFF'\n", "language": "python"}
{"task_id": "revision1a_problem412", "prompt": "from collections import deque\nfrom typing import List, Dict\n\ndef analyze_social_network(connections: Dict[str, List[str]], start_user: str, max_depth: int) -> Dict[str, int]:\n    \"\"\"\n    A social media company wants to analyze the spread of information within their network.\n\n    Given a dictionary representing user connections, a starting user, and a maximum depth,\n    perform a breadth-first search to determine how many users can be reached within each depth level.\n\n    Use a queue data structure to implement the BFS algorithm efficiently.\n\n    Parameters:\n    connections (Dict[str, List[str]]): A dictionary where keys are usernames and values are lists of their connections.\n    start_user (str): The username of the user to start the analysis from.\n    max_depth (int): The maximum depth of connections to analyze.\n\n    Returns:\n    Dict[str, int]: A dictionary where keys are depth levels (as strings) and values are the number of users reached at that depth.\n\n    Example:\n    Input:\n    connections = {\n        \"Alice\": [\"Bob\", \"Charlie\"],\n        \"Bob\": [\"David\", \"Eve\"],\n        \"Charlie\": [\"Frank\"],\n        \"David\": [],\n        \"Eve\": [\"Frank\"],\n        \"Frank\": []\n    }\n    start_user = \"Alice\"\n    max_depth = 2\n\n    Output: {\"0\": 1, \"1\": 2, \"2\": 3}\n\n    This output indicates that at depth 0, only Alice is reached; at depth 1, Bob and Charlie are reached;\n    and at depth 2, David, Eve, and Frank are reached.\n    \"\"\"\n", "entry_point": "analyze_social_network", "solution": "    result = {str(i): 0 for i in range(max_depth + 1)}\n    visited = set()\n    queue = deque([(start_user, 0)])\n    \n    while queue:\n        user, depth = queue.popleft()\n        \n        if depth > max_depth:\n            break\n        \n        if user not in visited:\n            visited.add(user)\n            result[str(depth)] += 1\n            \n            if depth < max_depth:\n                for connection in connections.get(user, []):\n                    if connection not in visited:\n                        queue.append((connection, depth + 1))\n    \n    return result\n", "test": "def check(candidate):\n    assert candidate({\"User\": []}, \"User\", 0) == {'0': 1}\n    assert candidate({\"1\": [\"2\", \"3\", \"4\"], \"2\": [\"5\"], \"3\": [\"5\"], \"4\": [\"5\"], \"5\": []}, \"1\", 2) == {'0': 1, '1': 3, '2': 1}\n    assert candidate({\"Start\": [\"A\", \"B\"], \"A\": [\"C\", \"D\"], \"B\": [\"E\", \"F\"], \"C\": [], \"D\": [], \"E\": [], \"F\": []}, \"Start\", 3) == {'0': 1, '1': 2, '2': 4, '3': 0}\n    assert candidate({\"X\": [\"Y\", \"Z\"], \"Y\": [\"X\"], \"Z\": [\"X\"]}, \"X\", 2) == {'0': 1, '1': 2, '2': 0}\n    assert candidate({\"User1\": [\"User2\", \"User3\"], \"User2\": [], \"User3\": []}, \"User1\", 1) == {'0': 1, '1': 2}\n    assert candidate({\"Single\": []}, \"Single\", 1) == {'0': 1, '1': 0}\n    assert candidate({\"A\": [\"B\", \"C\"], \"B\": [\"D\", \"E\"], \"C\": [\"F\"], \"D\": [], \"E\": [\"F\"], \"F\": []}, \"A\", 3) == {'0': 1, '1': 2, '2': 3, '3': 0}\n    assert candidate({\"A\": [\"B\", \"C\", \"D\", \"E\"], \"B\": [], \"C\": [], \"D\": [], \"E\": []}, \"A\", 1) == {'0': 1, '1': 4}\n    assert candidate({\"Alice\": [\"Bob\", \"Charlie\"], \"Bob\": [\"David\"], \"Charlie\": [], \"David\": []}, \"Alice\", 2) == {'0': 1, '1': 2, '2': 1}\n    assert candidate({\"A\": [\"B\"], \"B\": [\"C\"], \"C\": [\"D\"], \"D\": [\"E\"], \"E\": []}, \"A\", 5) == {'0': 1, '1': 1, '2': 1, '3': 1, '4': 1, '5': 0}\n", "language": "python"}
{"task_id": "revision1a_problem51", "prompt": "from typing import List\n\ndef optimize_solar_panel(efficiency: List[float], cost: List[float], budget: float) -> List[int]:\n    \"\"\"\n    We are designing a solar farm and need to optimize the selection of solar panels.\n    We have a list of solar panel efficiencies and their corresponding costs.\n    Our task is to maximize the total efficiency within a given budget.\n\n    Parameters:\n    efficiency (List[float]): A list of solar panel efficiencies (in percentage)\n    cost (List[float]): A list of costs for each solar panel (in dollars)\n    budget (float): The total budget available for purchasing panels (in dollars)\n\n    Returns:\n    List[int]: The indices of the selected panels that maximize efficiency within the budget\n\n    Example 1:\n    Input: \n    efficiency = [15.5, 18.2, 17.1, 20.0, 16.8]\n    cost = [200, 300, 250, 350, 225]\n    budget = 700\n    Output: [1, 3]\n\n    Example 2:\n    Input:\n    efficiency = [12.0, 14.5, 13.8, 16.2, 15.0, 17.5]\n    cost = [150, 200, 180, 250, 220, 300]\n    budget = 500\n    Output: [1, 3, 4]\n    \"\"\"\n", "entry_point": "optimize_solar_panel", "solution": "    n = len(efficiency)\n    # Create a list of tuples (efficiency/cost ratio, index)\n    ratio_index = [(efficiency[i] / cost[i], i) for i in range(n)]\n    \n    # Sort the list based on efficiency/cost ratio in descending order\n    ratio_index.sort(reverse=True)\n    \n    selected_panels = []\n    remaining_budget = budget\n    \n    for ratio, index in ratio_index:\n        if cost[index] <= remaining_budget:\n            selected_panels.append(index)\n            remaining_budget -= cost[index]\n    \n    # Sort the selected panels by their original index\n    return sorted(selected_panels)\n", "test": "def check(candidate):\n    assert candidate([18.5, 19.2, 20.1, 21.0], [400, 450, 500, 550], 900) == [0, 1]\n    assert candidate([21.2, 22.1, 23.0, 23.9, 24.8], [600, 650, 700, 750, 800], 1300) == [0, 1]\n    assert candidate([12.0, 14.5, 13.8, 16.2, 15.0, 17.5], [150, 200, 180, 250, 220, 300], 500) == [0, 2]\n    assert candidate([22.5, 23.0, 23.5, 24.0], [800, 850, 900, 950], 1700) == [0, 1]\n    assert candidate([13.7, 14.2, 14.8, 15.3, 15.9], [180, 190, 200, 210, 220], 400) == [0, 1]\n    assert candidate([20.0, 25.0, 30.0], [500, 600, 700], 1000) == [2]\n    assert candidate([10.0, 11.0, 12.0], [100, 110, 120], 200) == [2]\n    assert candidate([15.0, 16.0, 17.0, 18.0, 19.0], [200, 220, 240, 260, 280], 600) == [0, 1]\n    assert candidate([15.5, 18.2, 17.1, 20.0, 16.8], [200, 300, 250, 350, 225], 700) == [0, 2, 4]\n    assert candidate([17.8, 18.3, 18.9, 19.4], [300, 320, 340, 360], 650) == [0, 1]\n", "language": "python"}
{"task_id": "revision1a_problem587", "prompt": "import math\nfrom typing import List, Tuple\n\ndef optimize_delivery_route(locations: List[Tuple[float, float]], start: Tuple[float, float]) -> List[int]:\n    \"\"\"\n    A delivery company wants to optimize their route for multiple package deliveries in a city.\n    Given a list of delivery locations (as latitude and longitude coordinates) and a starting point,\n    determine the optimal order to visit all locations while minimizing the total distance traveled.\n\n    Use the Traveling Salesman Problem (TSP) approach with a nearest neighbor heuristic to solve this in O(n^2) time complexity.\n    Return the optimal order of locations to visit as a list of indices from the input list.\n\n    Example:\n    Input: \n    locations = [(40.7128, -74.0060), (40.7484, -73.9857), (40.7589, -73.9851), (40.7082, -74.0079)]\n    start = (40.7831, -73.9712)\n\n    Output: [2, 1, 0, 3]\n\n    This output suggests visiting the locations in the order: 3rd, 2nd, 1st, and 4th from the input list.\n    \"\"\"\n", "entry_point": "optimize_delivery_route", "solution": "    def calculate_distance(point1: Tuple[float, float], point2: Tuple[float, float]) -> float:\n        lat1, lon1 = point1\n        lat2, lon2 = point2\n        return math.sqrt((lat2 - lat1)**2 + (lon2 - lon1)**2)\n\n    n = len(locations)\n    unvisited = set(range(n))\n    route = []\n    current = start\n\n    while unvisited:\n        nearest = min(unvisited, key=lambda x: calculate_distance(current, locations[x]))\n        route.append(nearest)\n        unvisited.remove(nearest)\n        current = locations[nearest]\n\n    return route\n", "test": "def check(candidate):\n    assert candidate([], (0, 0)) == []\n    assert candidate([(1.5, 1.5), (2.5, 2.5), (3.5, 3.5)], (1.0, 1.0)) == [0, 1, 2]\n    assert candidate([(40.7128, -74.0060), (40.7484, -73.9857), (40.7589, -73.9851), (40.7082, -74.0079)], (40.7831, -73.9712)) == [2, 1, 0, 3]\n    assert candidate([(0, 0)], (1, 1)) == [0]\n    assert candidate([(-1, -1), (-2, -2), (-3, -3)], (0, 0)) == [0, 1, 2]\n    assert candidate([(10, 10), (20, 20), (30, 30)], (0, 0)) == [0, 1, 2]\n    assert candidate([(0, 0), (0, 1), (1, 0), (1, 1)], (0.5, 0.5)) == [0, 1, 3, 2]\n    assert candidate([(1, 1), (2, 2), (3, 3)], (0, 0)) == [0, 1, 2]\n    assert candidate([(0, 0), (0, 10), (10, 0), (10, 10)], (5, 5)) == [0, 1, 3, 2]\n    assert candidate([(0, 0), (1, 1), (2, 2), (3, 3), (4, 4)], (0, 0)) == [0, 1, 2, 3, 4]\n", "language": "python"}
{"task_id": "revision1a_problem218", "prompt": "from typing import List, Tuple\n\ndef encrypt_message(message: str, key: List[int]) -> Tuple[str, List[int]]:\n    \"\"\"\n    I work for a secret agency and need to encrypt messages before sending them.\n    The encryption process involves shifting each character in the message by a \n    corresponding number in the key list. If the key list is shorter than the message, \n    it should be repeated. Spaces and punctuation should remain unchanged.\n    \n    Implement a function that takes a message and a key list, and returns the \n    encrypted message along with the expanded key list. Use list comprehension \n    and the built-in ord() and chr() functions.\n    \n    The function should also handle uppercase and lowercase letters differently:\n    uppercase letters should be shifted within the range A-Z, and lowercase within a-z.\n    \n    Example:\n    Input: \"Hello, World!\", [3, 1, 4]\n    Output: (\"Khoor, Zruog!\", [3, 1, 4, 3, 1, 4, 3, 1, 4, 3, 1, 4, 3])\n    \n    Input: \"Secret Agent\", [2, 5, 1, 3]\n    Output: (\"Ugetzv Cihpv\", [2, 5, 1, 3, 2, 5, 1, 3, 2, 5, 1, 3])\n    \"\"\"\n", "entry_point": "encrypt_message", "solution": "    def shift_char(char: str, shift: int) -> str:\n        if char.isalpha():\n            base = ord('A') if char.isupper() else ord('a')\n            return chr((ord(char) - base + shift) % 26 + base)\n        return char\n\n    expanded_key = [key[i % len(key)] for i in range(len(message))]\n    encrypted_message = ''.join([shift_char(char, shift) for char, shift in zip(message, expanded_key)])\n    \n    return encrypted_message, expanded_key\n", "test": "def check(candidate):\n    assert candidate(\"\", [1, 2, 3]) == ('', [])\n    assert candidate(\"z\", [1]) == ('a', [1])\n    assert candidate(\"!@#$%^&*()\", [1, 2, 3, 4]) == ('!@#$%^&*()', [1, 2, 3, 4, 1, 2, 3, 4, 1, 2])\n    assert candidate(\"Z\", [1]) == ('A', [1])\n    assert candidate(\"Hello, World!\", [3, 1, 4]) == ('Kfpop, Xsumh!', [3, 1, 4, 3, 1, 4, 3, 1, 4, 3, 1, 4, 3])\n    assert candidate(\"a\", [25]) == ('z', [25])\n    assert candidate(\"A\", [0]) == ('A', [0])\n    assert candidate(\"Secret Agent\", [2, 5, 1, 3]) == ('Ujdugy Dijow', [2, 5, 1, 3, 2, 5, 1, 3, 2, 5, 1, 3])\n    assert candidate(\"XYZ123xyz\", [1, 2, 3]) == ('YAC123yac', [1, 2, 3, 1, 2, 3, 1, 2, 3])\n    assert candidate(\"AaBbCc\", [1, 1, 1]) == ('BbCcDd', [1, 1, 1, 1, 1, 1])\n", "language": "python"}
{"task_id": "revision1a_problem492", "prompt": "from contextlib import contextmanager\nfrom typing import List, Tuple\nimport logging\nfrom abc import ABC, abstractmethod\n\ndef inventory_management(items: List[Tuple[str, int, float]]) -> List[str]:\n    \"\"\"\n    Develop a system for managing a retail store's inventory using object-oriented programming principles.\n    Create classes for different product categories (e.g., Electronics, Clothing, Groceries) that inherit from a base Product class.\n    Implement methods for adding new items, updating stock levels, and generating reports on low-stock items.\n    Use a decorator to log all inventory changes and a context manager to handle database connections.\n\n    The function should take a list of tuples containing item information (name, quantity, price) and return a list of items that need restocking.\n    \n    Example:\n    Input: [('Laptop', 5, 999.99), ('T-shirt', 2, 19.99), ('Banana', 10, 0.99)]\n    Output: ['T-shirt']\n    \"\"\"\n", "entry_point": "inventory_management", "solution": "    # Set up logging\n    logging.basicConfig(level=logging.INFO)\n    logger = logging.getLogger(__name__)\n\n    # Decorator for logging inventory changes\n    def log_inventory_change(func):\n        def wrapper(*args, **kwargs):\n            result = func(*args, **kwargs)\n            logger.info(f\"Inventory change: {func.__name__} called with args: {args}, kwargs: {kwargs}\")\n            return result\n        return wrapper\n\n    # Context manager for database connection\n    @contextmanager\n    def db_connection():\n        print(\"Connecting to the database...\")\n        yield\n        print(\"Closing database connection...\")\n\n    # Base Product class\n    class Product(ABC):\n        def __init__(self, name: str, quantity: int, price: float):\n            self.name = name\n            self.quantity = quantity\n            self.price = price\n\n        @abstractmethod\n        def category(self) -> str:\n            pass\n\n        @log_inventory_change\n        def update_stock(self, quantity: int):\n            self.quantity += quantity\n\n        def needs_restocking(self) -> bool:\n            return self.quantity <= 2\n\n    # Product category classes\n    class Electronics(Product):\n        def category(self) -> str:\n            return \"Electronics\"\n\n    class Clothing(Product):\n        def category(self) -> str:\n            return \"Clothing\"\n\n    class Groceries(Product):\n        def category(self) -> str:\n            return \"Groceries\"\n\n    # Inventory class to manage products\n    class Inventory:\n        def __init__(self):\n            self.products = []\n\n        @log_inventory_change\n        def add_item(self, product: Product):\n            self.products.append(product)\n\n        def get_low_stock_items(self) -> List[str]:\n            return [product.name for product in self.products if product.needs_restocking()]\n\n    # Create inventory and add items\n    inventory = Inventory()\n\n    for item in items:\n        name, quantity, price = item\n        if \"Laptop\" in name:\n            product = Electronics(name, quantity, price)\n        elif \"shirt\" in name.lower():\n            product = Clothing(name, quantity, price)\n        else:\n            product = Groceries(name, quantity, price)\n        \n        with db_connection():\n            inventory.add_item(product)\n\n    # Generate report on low-stock items\n    return inventory.get_low_stock_items()\n", "test": "def check(candidate):\n    assert candidate([]) == []\n", "language": "python"}
{"task_id": "revision1a_problem464", "prompt": "from typing import List, Tuple\n\ndef optimize_study_schedule(subjects: List[str], difficulties: List[int], available_hours: int) -> List[Tuple[str, int]]:\n    \"\"\"\n    Create an optimized study schedule based on subject difficulties and available study time.\n\n    This function takes a list of subjects, their corresponding difficulties, and the total\n    available study hours. It then creates an optimized schedule that allocates more time\n    to difficult subjects while ensuring all subjects are covered.\n\n    The function should use a greedy algorithm approach to distribute the available hours\n    among the subjects, giving priority to more difficult subjects.\n\n    Parameters:\n    subjects (List[str]): A list of subject names\n    difficulties (List[int]): A list of difficulty ratings for each subject (1-10, 10 being most difficult)\n    available_hours (int): Total number of hours available for studying\n\n    Returns:\n    List[Tuple[str, int]]: A list of tuples, each containing a subject name and the allocated study hours\n\n    Example:\n    Input: ['Math', 'History', 'Physics', 'Literature'], [8, 5, 9, 6], 20\n    Output: [('Physics', 7), ('Math', 6), ('Literature', 4), ('History', 3)]\n\n    Input: ['Programming', 'Economics', 'Statistics'], [7, 6, 8], 15\n    Output: [('Statistics', 6), ('Programming', 5), ('Economics', 4)]\n    \"\"\"\n", "entry_point": "optimize_study_schedule", "solution": "    # Create a list of tuples with subject and difficulty\n    subject_difficulty = list(zip(subjects, difficulties))\n    \n    # Sort the list based on difficulty in descending order\n    subject_difficulty.sort(key=lambda x: x[1], reverse=True)\n    \n    total_difficulty = sum(difficulties)\n    schedule = []\n    \n    for subject, difficulty in subject_difficulty:\n        # Calculate the proportion of time for each subject based on its difficulty\n        proportion = difficulty / total_difficulty\n        allocated_hours = round(proportion * available_hours)\n        \n        # Ensure at least 1 hour is allocated to each subject\n        allocated_hours = max(1, allocated_hours)\n        \n        schedule.append((subject, allocated_hours))\n        available_hours -= allocated_hours\n        \n        # If we've allocated all available hours, break the loop\n        if available_hours <= 0:\n            break\n    \n    # If there are still available hours, distribute them to subjects with the highest difficulty\n    index = 0\n    while available_hours > 0:\n        schedule[index] = (schedule[index][0], schedule[index][1] + 1)\n        available_hours -= 1\n        index = (index + 1) % len(schedule)\n    \n    return schedule\n", "test": "def check(candidate):\n    assert candidate(['Cooking', 'Gardening', 'Woodworking', 'Painting'], [4, 3, 5, 2], 16) == [('Woodworking', 7), ('Cooking', 4), ('Gardening', 3), ('Painting', 2)]\n    assert candidate(['Geography', 'History', 'Civics'], [5, 5, 5], 12) == [('Geography', 5), ('History', 4), ('Civics', 3)]\n    assert candidate(['Computer Science'], [9], 5) == [('Computer Science', 5)]\n    assert candidate(['Psychology', 'Sociology', 'Anthropology'], [6, 7, 8], 18) == [('Anthropology', 9), ('Sociology', 6), ('Psychology', 3)]\n    assert candidate(['Biology', 'Chemistry', 'Physics', 'Math', 'English'], [7, 8, 9, 10, 5], 30) == [('Math', 10), ('Physics', 7), ('Chemistry', 5), ('Biology', 5), ('English', 3)]\n    assert candidate(['Math', 'History', 'Physics', 'Literature'], [8, 5, 9, 6], 20) == [('Physics', 8), ('Math', 6), ('Literature', 4), ('History', 2)]\n    assert candidate(['French', 'Spanish', 'German', 'Italian'], [6, 7, 8, 5], 24) == [('German', 9), ('Spanish', 7), ('French', 5), ('Italian', 3)]\n    assert candidate(['Algebra', 'Geometry', 'Trigonometry', 'Calculus'], [7, 8, 9, 10], 40) == [('Calculus', 16), ('Trigonometry', 10), ('Geometry', 8), ('Algebra', 6)]\n    assert candidate(['Art', 'Music'], [3, 4], 10) == [('Music', 7), ('Art', 3)]\n", "language": "python"}
{"task_id": "revision1a_problem332", "prompt": "import itertools\nfrom typing import List, Tuple\n\ndef optimize_delivery_route(warehouses: int, roads: List[List[int]]) -> Tuple[int, List[int]]:\n    \"\"\"\n    A logistics company wants to optimize its delivery route between warehouses in a city.\n    The goal is to find the shortest path that visits all warehouses exactly once and returns to the starting point.\n    \n    Take input from the user as the number of warehouses and the distances between each pair of warehouses.\n    Represent the distances in the form of a matrix where roads[i][j] is the distance from warehouse i to warehouse j.\n    \n    Return a tuple containing the minimum total distance and the optimal route as a list of warehouse indices.\n    \n    This problem is known as the Traveling Salesman Problem and requires dynamic programming for an optimal solution.\n    \n    Example:\n    Input: 4, [[0,10,15,20],[10,0,35,25],[15,35,0,30],[20,25,30,0]]\n    Output: (80, [0, 1, 3, 2, 0])\n    \"\"\"\n", "entry_point": "optimize_delivery_route", "solution": "    \n    def solve_tsp(dp, mask, pos):\n        if mask == ((1 << warehouses) - 1):\n            return roads[pos][0], [0]\n        \n        if dp[mask][pos] != float('inf'):\n            return dp[mask][pos], []\n        \n        for i in range(1, warehouses):\n            if not (mask & (1 << i)):\n                new_mask = mask | (1 << i)\n                distance, path = solve_tsp(dp, new_mask, i)\n                distance += roads[pos][i]\n                \n                if distance < dp[mask][pos]:\n                    dp[mask][pos] = distance\n                    best_path[mask][pos] = [i] + path\n        \n        return dp[mask][pos], best_path[mask][pos]\n\n    dp = [[float('inf')] * warehouses for _ in range(1 << warehouses)]\n    best_path = [[[] for _ in range(warehouses)] for _ in range(1 << warehouses)]\n    \n    min_distance, optimal_route = solve_tsp(dp, 1, 0)\n    optimal_route = [0] + optimal_route\n    \n    return min_distance, optimal_route\n", "test": "def check(candidate):\n    assert candidate(4, [[0,1,1,1],[1,0,1,1],[1,1,0,1],[1,1,1,0]]) == (4, [0, 1, 2, 3, 0])\n    assert candidate(4, [[0,10,15,20],[10,0,35,25],[15,35,0,30],[20,25,30,0]]) == (80, [0, 1, 3, 2, 0])\n    assert candidate(3, [[0,1,2],[1,0,3],[2,3,0]]) == (6, [0, 1, 2, 0])\n    assert candidate(5, [[0,1,2,3,4],[1,0,5,6,7],[2,5,0,8,9],[3,6,8,0,10],[4,7,9,10,0]]) == (27, [0, 2, 1, 3])\n    assert candidate(2, [[0,1000],[1000,0]]) == (2000, [0, 1, 0])\n    assert candidate(2, [[0,1],[1,0]]) == (2, [0, 1, 0])\n    assert candidate(5, [[0,10,20,30,40],[10,0,50,60,70],[20,50,0,80,90],[30,60,80,0,100],[40,70,90,100,0]]) == (270, [0, 2, 1, 3])\n    assert candidate(6, [[0,1,2,3,4,5],[1,0,6,7,8,9],[2,6,0,10,11,12],[3,7,10,0,13,14],[4,8,11,13,0,15],[5,9,12,14,15,0]]) == (46, [0, 3, 1, 4])\n    assert candidate(1, [[0]]) == (0, [0, 0])\n    assert candidate(3, [[0,100,200],[100,0,50],[200,50,0]]) == (350, [0, 1, 2, 0])\n", "language": "python"}
{"task_id": "revision1a_problem329", "prompt": "import re\nfrom typing import List, Dict\n\ndef analyze_text_sentiment(text: str) -> Dict[str, float]:\n    \"\"\"\n    You are developing a natural language processing tool to analyze the sentiment of customer reviews.\n    Implement a function that uses regular expressions and a predefined sentiment dictionary to calculate\n    the overall sentiment score of a given text.\n    \n    The function should:\n    1. Tokenize the input text into words.\n    2. Match each word against a sentiment dictionary.\n    3. Calculate the overall sentiment score.\n    4. Identify and count specific sentiment-related phrases.\n    \n    Return a dictionary containing the overall sentiment score and counts of positive/negative phrases.\n    \n    Example:\n    Input: \"The product is amazing! I love it, but the customer service could be better.\"\n    Output: {\n        'overall_sentiment': 0.6,\n        'positive_phrases': 2,\n        'negative_phrases': 1,\n        'neutral_phrases': 0\n    }\n    \"\"\"\n", "entry_point": "analyze_text_sentiment", "solution": "    # Predefined sentiment dictionary\n    sentiment_dict = {\n        'amazing': 1.0,\n        'love': 1.0,\n        'great': 0.8,\n        'good': 0.6,\n        'nice': 0.5,\n        'okay': 0.2,\n        'bad': -0.6,\n        'terrible': -1.0,\n        'hate': -1.0,\n        'poor': -0.7\n    }\n\n    # Tokenize the input text into words\n    words = re.findall(r'\\w+', text.lower())\n\n    # Calculate sentiment score\n    sentiment_score = 0\n    word_count = 0\n    for word in words:\n        if word in sentiment_dict:\n            sentiment_score += sentiment_dict[word]\n            word_count += 1\n\n    # Calculate overall sentiment\n    overall_sentiment = sentiment_score / word_count if word_count > 0 else 0\n\n    # Identify and count sentiment-related phrases\n    positive_phrases = len(re.findall(r'\\b(amazing|love|great|good|nice)\\b', text.lower()))\n    negative_phrases = len(re.findall(r'\\b(bad|terrible|hate|poor)\\b', text.lower()))\n    neutral_phrases = len(re.findall(r'\\b(okay)\\b', text.lower()))\n\n    # Prepare the result dictionary\n    result = {\n        'overall_sentiment': round(overall_sentiment, 2),\n        'positive_phrases': positive_phrases,\n        'negative_phrases': negative_phrases,\n        'neutral_phrases': neutral_phrases\n    }\n\n    return result\n", "test": "def check(candidate):\n    assert candidate(\"The quality is outstanding, and the price is unbeatable. Highly recommended!\") == {'overall_sentiment': 0, 'positive_phrases': 0, 'negative_phrases': 0, 'neutral_phrases': 0}\n    assert candidate(\"Mixed feelings about this. Some good points, some bad points.\") == {'overall_sentiment': 0.0, 'positive_phrases': 1, 'negative_phrases': 1, 'neutral_phrases': 0}\n    assert candidate(\"The product is amazing! I love it, but the customer service could be better.\") == {'overall_sentiment': 1.0, 'positive_phrases': 2, 'negative_phrases': 0, 'neutral_phrases': 0}\n    assert candidate(\"\") == {'overall_sentiment': 0, 'positive_phrases': 0, 'negative_phrases': 0, 'neutral_phrases': 0}\n    assert candidate(\"WOW! This exceeded all my expectations!!!!!\") == {'overall_sentiment': 0, 'positive_phrases': 0, 'negative_phrases': 0, 'neutral_phrases': 0}\n    assert candidate(\"I absolutely hate this product. It\\'s the worst purchase I\\'ve ever made.\") == {'overall_sentiment': -1.0, 'positive_phrases': 0, 'negative_phrases': 1, 'neutral_phrases': 0}\n    assert candidate(\"Terrible. Awful. Horrible. Disappointing. Frustrating.\") == {'overall_sentiment': -1.0, 'positive_phrases': 0, 'negative_phrases': 1, 'neutral_phrases': 0}\n    assert candidate(\"This is a neutral statement without any strong emotions.\") == {'overall_sentiment': 0, 'positive_phrases': 0, 'negative_phrases': 0, 'neutral_phrases': 0}\n    assert candidate(\"Great! Excellent! Wonderful! Perfect! Fantastic!\") == {'overall_sentiment': 0.8, 'positive_phrases': 1, 'negative_phrases': 0, 'neutral_phrases': 0}\n    assert candidate(\"Just okay. Nothing special.\") == {'overall_sentiment': 0.2, 'positive_phrases': 0, 'negative_phrases': 0, 'neutral_phrases': 1}\n", "language": "python"}
{"task_id": "revision1a_problem664", "prompt": "def decode_ways(s: str) -> int:\n    \"\"\"\n    You're a cryptography enthusiast trying to decode secret messages.\n    Each letter in the secret message is encoded as a number from 1 to 26, where 'A' is 1, 'B' is 2, ..., 'Z' is 26.\n    Given a non-empty string of digits, determine the total number of ways to decode it.\n    Take the encoded string as input from the user and return the number of possible decodings.\n    Use dynamic programming to solve this efficiently.\n\n    Example 1:\n    Input: \"12\"\n    Output: 2 # It could be decoded as \"AB\" (1 2) or \"L\" (12)\n\n    Example 2:\n    Input: \"226\"\n    Output: 3 # It could be decoded as \"BZ\" (2 26), \"VF\" (22 6), or \"BBF\" (2 2 6)\n\n    Example 3:\n    Input: \"06\"\n    Output: 0 # \"6\" is valid, but \"06\" is not because leading zeros are not allowed\n    \"\"\"\n", "entry_point": "decode_ways", "solution": "    if not s or s[0] == '0':\n        return 0\n\n    n = len(s)\n    dp = [0] * (n + 1)\n    dp[0] = 1\n    dp[1] = 1\n\n    for i in range(2, n + 1):\n        # Check if the current digit is valid (not '0')\n        if s[i - 1] != '0':\n            dp[i] += dp[i - 1]\n\n        # Check if the last two digits form a valid number (10-26)\n        two_digit = int(s[i - 2:i])\n        if 10 <= two_digit <= 26:\n            dp[i] += dp[i - 2]\n\n    return dp[n]\n", "test": "def check(candidate):\n    assert candidate(\"110\") == 1\n    assert candidate(\"27\") == 1\n    assert candidate(\"1234\") == 3\n    assert candidate(\"101\") == 1\n    assert candidate(\"10\") == 1\n    assert candidate(\"1\") == 1\n    assert candidate(\"226\") == 3\n    assert candidate(\"06\") == 0\n    assert candidate(\"11111\") == 8\n    assert candidate(\"12\") == 2\n", "language": "python"}
{"task_id": "revision1a_problem390", "prompt": "from typing import List, Tuple\n\ndef compress_image(image: List[List[int]], tolerance: float) -> List[Tuple[int, int, int, int]]:\n    \"\"\"\n    As an image processing engineer, you need to implement a lossy image compression algorithm using quadtree decomposition.\n    Given a grayscale image represented as a 2D list of integers (0-255) and a tolerance level,\n    compress the image by recursively dividing it into quadrants and averaging their values.\n\n    The function should return a list of tuples, each representing a quadrant in the format (x, y, size, value).\n\n    Example:\n    Input:\n    image = [\n        [100, 100, 150, 150],\n        [100, 100, 150, 150],\n        [200, 200, 250, 250],\n        [200, 200, 250, 250]\n    ]\n    tolerance = 10\n\n    Output:\n    [(0, 0, 2, 100), (2, 0, 2, 150), (0, 2, 2, 200), (2, 2, 2, 250)]\n\n    This problem requires understanding of recursive algorithms, image processing techniques, and spatial data structures.\n    \"\"\"\n", "entry_point": "compress_image", "solution": "    def compress_quadrant(x: int, y: int, size: int) -> List[Tuple[int, int, int, int]]:\n        if size == 1:\n            return [(x, y, 1, image[y][x])]\n\n        # Calculate average value of the quadrant\n        total = sum(image[i][j] for i in range(y, y + size) for j in range(x, x + size))\n        avg = total // (size * size)\n\n        # Check if the quadrant is homogeneous within the tolerance\n        if all(abs(image[i][j] - avg) <= tolerance for i in range(y, y + size) for j in range(x, x + size)):\n            return [(x, y, size, avg)]\n\n        # If not homogeneous, recursively compress sub-quadrants\n        new_size = size // 2\n        return (\n            compress_quadrant(x, y, new_size) +\n            compress_quadrant(x + new_size, y, new_size) +\n            compress_quadrant(x, y + new_size, new_size) +\n            compress_quadrant(x + new_size, y + new_size, new_size)\n        )\n\n    # Start compression from the top-left corner with full image size\n    return compress_quadrant(0, 0, len(image))\n", "test": "def check(candidate):\n    assert candidate([[100, 100, 150, 150], [100, 100, 150, 150], [200, 200, 250, 250], [200, 200, 250, 250]], 10) == [(0, 0, 2, 100), (2, 0, 2, 150), (0, 2, 2, 200), (2, 2, 2, 250)]\n    assert candidate([[0, 0], [0, 0]], 0.1) == [(0, 0, 2, 0)]\n    assert candidate([[128] * 32 for _ in range(32)], 0) == [(0, 0, 32, 128)]\n    assert candidate([[255, 255], [255, 255]], 0.1) == [(0, 0, 2, 255)]\n    assert candidate([[i for i in range(16)] for _ in range(16)], 2) == [(0, 0, 4, 1), (4, 0, 4, 5), (0, 4, 4, 1), (4, 4, 4, 5), (8, 0, 4, 9), (12, 0, 4, 13), (8, 4, 4, 9), (12, 4, 4, 13), (0, 8, 4, 1), (4, 8, 4, 5), (0, 12, 4, 1), (4, 12, 4, 5), (8, 8, 4, 9), (12, 8, 4, 13), (8, 12, 4, 9), (12, 12, 4, 13)]\n    assert candidate([[1]], 1.0) == [(0, 0, 1, 1)]\n    assert candidate([[100] * 8 for _ in range(8)], 1) == [(0, 0, 8, 100)]\n    assert candidate([[1, 2], [3, 4]], 0.5) == [(0, 0, 1, 1), (1, 0, 1, 2), (0, 1, 1, 3), (1, 1, 1, 4)]\n    assert candidate([[255 - i for i in range(16)] for _ in range(16)], 2) == [(0, 0, 4, 253), (4, 0, 4, 249), (0, 4, 4, 253), (4, 4, 4, 249), (8, 0, 4, 245), (12, 0, 4, 241), (8, 4, 4, 245), (12, 4, 4, 241), (0, 8, 4, 253), (4, 8, 4, 249), (0, 12, 4, 253), (4, 12, 4, 249), (8, 8, 4, 245), (12, 8, 4, 241), (8, 12, 4, 245), (12, 12, 4, 241)]\n    assert candidate([[10, 20, 30], [40, 50, 60], [70, 80, 90]], 5) == [(0, 0, 1, 10), (1, 0, 1, 20), (0, 1, 1, 40), (1, 1, 1, 50)]\n", "language": "python"}
{"task_id": "revision1a_problem486", "prompt": "import math\nimport random\nfrom typing import List, Tuple\n\ndef optimize_delivery_route(locations: List[Tuple[float, float]], num_vehicles: int) -> List[List[int]]:\n    \"\"\"\n    Optimize delivery routes for a fleet of vehicles given a set of delivery locations.\n    Take input for a list of location coordinates (latitude, longitude) and the number of available vehicles.\n    Return a list of optimized routes for each vehicle, where each route is a list of location indices.\n\n    The optimization should consider:\n    - Minimizing total distance traveled\n    - Balancing workload among vehicles\n    - Time constraints (e.g., maximum route duration)\n\n    Implement a heuristic algorithm (e.g., genetic algorithm or simulated annealing) to solve this NP-hard problem.\n\n    Example:\n    Input: [(40.7128, -74.0060), (34.0522, -118.2437), (41.8781, -87.6298), (29.7604, -95.3698), (33.7490, -84.3880)], 2\n    Output: [[0, 2, 4], [1, 3]]  # Vehicle 1: NYC, Chicago, Atlanta; Vehicle 2: LA, Houston\n    \"\"\"\n", "entry_point": "optimize_delivery_route", "solution": "    def haversine_distance(loc1, loc2):\n        lat1, lon1 = math.radians(loc1[0]), math.radians(loc1[1])\n        lat2, lon2 = math.radians(loc2[0]), math.radians(loc2[1])\n        dlat, dlon = lat2 - lat1, lon2 - lon1\n        a = math.sin(dlat/2)**2 + math.cos(lat1) * math.cos(lat2) * math.sin(dlon/2)**2\n        c = 2 * math.atan2(math.sqrt(a), math.sqrt(1-a))\n        return 6371 * c  # Earth's radius in km\n\n    def nearest_neighbor(start, unvisited):\n        return min(unvisited, key=lambda x: haversine_distance(locations[start], locations[x]))\n\n    routes = [[] for _ in range(num_vehicles)]\n    unvisited = set(range(len(locations)))\n    \n    # Start with random initial locations for each vehicle\n    for i in range(num_vehicles):\n        if unvisited:\n            start = random.choice(list(unvisited))\n            routes[i].append(start)\n            unvisited.remove(start)\n    \n    # Assign remaining locations using nearest neighbor heuristic\n    while unvisited:\n        for i in range(num_vehicles):\n            if unvisited:\n                current = routes[i][-1]\n                next_loc = nearest_neighbor(current, unvisited)\n                routes[i].append(next_loc)\n                unvisited.remove(next_loc)\n    \n    # Balance workload by moving locations between routes\n    max_iterations = 100\n    for _ in range(max_iterations):\n        longest_route = max(routes, key=len)\n        shortest_route = min(routes, key=len)\n        if len(longest_route) - len(shortest_route) <= 1:\n            break\n        location = longest_route.pop()\n        shortest_route.append(location)\n    \n    return routes\n", "test": "def check(candidate):\n    assert candidate([(0, 0)], 1) == [[0]]\n    assert candidate([], 1) == [[]]\n", "language": "python"}
{"task_id": "revision1a_problem385", "prompt": "import heapq\nfrom typing import List, Tuple\n\ndef optimize_delivery_route(packages: List[Tuple[str, int, int]]) -> List[str]:\n    \"\"\"\n    Optimize a delivery route for a courier service.\n    Given a list of packages with their addresses, x-coordinate, and y-coordinate,\n    find the most efficient route to deliver all packages, starting and ending at the origin (0, 0).\n\n    Use a nearest neighbor algorithm with a priority queue to determine the order of deliveries.\n\n    Parameters:\n    packages (List[Tuple[str, int, int]]): List of tuples containing (address, x-coordinate, y-coordinate)\n\n    Returns:\n    List[str]: The optimized route as a list of addresses in the order they should be visited\n\n    Example:\n    Input: [(\"123 Main St\", 5, 10), (\"456 Elm St\", -3, 7), (\"789 Oak St\", 8, -2)]\n    Output: [\"456 Elm St\", \"123 Main St\", \"789 Oak St\"]\n\n    This function requires understanding of tuple unpacking, priority queues (heapq),\n    distance calculations, and implementing a simple optimization algorithm.\n    \"\"\"\n", "entry_point": "optimize_delivery_route", "solution": "    def distance(x1, y1, x2, y2):\n        return ((x2 - x1) ** 2 + (y2 - y1) ** 2) ** 0.5\n\n    optimized_route = []\n    unvisited = packages.copy()\n    current_x, current_y = 0, 0\n\n    while unvisited:\n        pq = []\n        for address, x, y in unvisited:\n            dist = distance(current_x, current_y, x, y)\n            heapq.heappush(pq, (dist, address, x, y))\n\n        _, next_address, next_x, next_y = heapq.heappop(pq)\n        optimized_route.append(next_address)\n        unvisited = [pkg for pkg in unvisited if pkg[0] != next_address]\n        current_x, current_y = next_x, next_y\n\n    return optimized_route\n", "test": "def check(candidate):\n    assert candidate([(\"Single Package\", 1, 1)]) == ['Single Package']\n    assert candidate([(\"P1\", 1, 1), (\"P2\", 2, 2), (\"P3\", 3, 3), (\"P4\", 4, 4), (\"P5\", 5, 5)]) == ['P1', 'P2', 'P3', 'P4', 'P5']\n    assert candidate([(\"P\" + str(i), i, i) for i in range(1, 21)]) == ['P1', 'P2', 'P3', 'P4', 'P5', 'P6', 'P7', 'P8', 'P9', 'P10', 'P11', 'P12', 'P13', 'P14', 'P15', 'P16', 'P17', 'P18', 'P19', 'P20']\n    assert candidate([(\"Origin\", 0, 0)]) == ['Origin']\n    assert candidate([(\"Near\", 0, 1), (\"Far\", 1000, 1000)]) == ['Near', 'Far']\n    assert candidate([(\"A\", -10, -10), (\"B\", 10, 10), (\"C\", -10, 10), (\"D\", 10, -10)]) == ['A', 'C', 'B', 'D']\n    assert candidate([(\"P\" + str(i), -i, -i) for i in range(1, 11)]) == ['P1', 'P2', 'P3', 'P4', 'P5', 'P6', 'P7', 'P8', 'P9', 'P10']\n    assert candidate([(\"A\", 0, 1), (\"B\", 0, -1), (\"C\", 1, 0), (\"D\", -1, 0)]) == ['A', 'C', 'B', 'D']\n    assert candidate([]) == []\n    assert candidate([(\"123 Main St\", 5, 10), (\"456 Elm St\", -3, 7), (\"789 Oak St\", 8, -2)]) == ['456 Elm St', '123 Main St', '789 Oak St']\n", "language": "python"}
{"task_id": "revision1a_problem384", "prompt": "import heapq\nfrom typing import List\n\ndef design_network_topology(nodes: int, connections: List[List[int]], reliability: List[float]) -> List[List[int]]:\n    \"\"\"\n    As a network engineer, you need to design a fault-tolerant network topology for a company with N nodes \n    (computers or servers) numbered from 1 to N. You are given a list of possible connections between nodes, \n    where each connection is represented as [i, j, cost] meaning node i can be connected to node j at the given cost. \n    Each node also has a reliability score between 0 and 1.\n\n    Your task is to design a network topology that connects all nodes while maximizing overall reliability \n    and minimizing total cost. The reliability of a path between two nodes is the product of reliabilities \n    of all nodes in the path.\n\n    Parameters:\n    - nodes (int): The number of nodes in the network\n    - connections (List[List[int]]): A list of possible connections, each as [node1, node2, cost]\n    - reliability (List[float]): A list of reliability scores for each node\n\n    Returns:\n    - List[List[int]]: The optimal network topology as a list of connections [node1, node2, cost]\n\n    Example:\n    Input: 4, [[1,2,10],[1,3,15],[2,3,5],[2,4,10],[3,4,5]], [0.9,0.8,0.7,0.85]\n    Output: [[1,2,10],[2,3,5],[3,4,5]]\n\n    Explanation: This topology connects all nodes with maximum reliability while minimizing cost.\n    \"\"\"\n", "entry_point": "design_network_topology", "solution": "    \n    def find(parent, i):\n        if parent[i] != i:\n            parent[i] = find(parent, parent[i])\n        return parent[i]\n\n    def union(parent, rank, x, y):\n        xroot = find(parent, x)\n        yroot = find(parent, y)\n        if rank[xroot] < rank[yroot]:\n            parent[xroot] = yroot\n        elif rank[xroot] > rank[yroot]:\n            parent[yroot] = xroot\n        else:\n            parent[yroot] = xroot\n            rank[xroot] += 1\n\n    # Sort connections based on a custom key that considers both cost and reliability\n    sorted_connections = sorted(connections, key=lambda x: (x[2] / (reliability[x[0]-1] * reliability[x[1]-1])))\n\n    parent = list(range(nodes + 1))\n    rank = [0] * (nodes + 1)\n    result = []\n\n    for connection in sorted_connections:\n        x, y, cost = connection\n        x_root = find(parent, x)\n        y_root = find(parent, y)\n\n        if x_root != y_root:\n            result.append(connection)\n            union(parent, rank, x_root, y_root)\n\n        if len(result) == nodes - 1:\n            break\n\n    return result\n", "test": "def check(candidate):\n    assert candidate(4, [[1,2,1], [1,3,2], [1,4,3], [2,3,4], [2,4,5], [3,4,6]], [0.7, 0.8, 0.9, 0.6]) == [[1, 2, 1], [1, 3, 2], [1, 4, 3]]\n    assert candidate(3, [[1,2,10], [2,3,10], [1,3,10]], [0.99, 0.99, 0.99]) == [[1, 2, 10], [2, 3, 10]]\n    assert candidate(3, [[1,2,1], [2,3,1], [1,3,2]], [1.0, 1.0, 1.0]) == [[1, 2, 1], [2, 3, 1]]\n    assert candidate(2, [[1,2,5]], [0.9, 0.8]) == [[1, 2, 5]]\n    assert candidate(2, [[1,2,100]], [0.1, 0.1]) == [[1, 2, 100]]\n    assert candidate(4, [[1,2,1], [2,3,1], [3,4,1], [4,1,1]], [0.5, 0.5, 0.5, 0.5]) == [[1, 2, 1], [2, 3, 1], [3, 4, 1]]\n    assert candidate(4, [[1,2,10], [1,3,15], [2,3,5], [2,4,10], [3,4,5]], [0.9, 0.8, 0.7, 0.85]) == [[3, 4, 5], [2, 3, 5], [1, 2, 10]]\n    assert candidate(3, [[1,2,10], [2,3,5], [1,3,15]], [0.9, 0.8, 0.7]) == [[2, 3, 5], [1, 2, 10]]\n    assert candidate(5, [[1,2,5], [2,3,5], [3,4,5], [4,5,5], [1,5,10]], [0.9, 0.9, 0.9, 0.9, 0.9]) == [[1, 2, 5], [2, 3, 5], [3, 4, 5], [4, 5, 5]]\n    assert candidate(6, [[1,2,5], [2,3,5], [3,4,5], [4,5,5], [5,6,5], [1,6,10]], [0.8, 0.8, 0.8, 0.8, 0.8, 0.8]) == [[1, 2, 5], [2, 3, 5], [3, 4, 5], [4, 5, 5], [5, 6, 5]]\n", "language": "python"}
{"task_id": "revision1a_problem621", "prompt": "from typing import List, Tuple\nimport itertools\n\ndef optimize_delivery_route(num_locations: int, distances: List[List[int]], time_windows: List[Tuple[int, int]]) -> List[int]:\n    \"\"\"\n    As a logistics manager for an e-commerce company, you need to optimize the delivery route for a driver.\n    You are given a number of delivery locations, the distances between each pair of locations,\n    and the time windows for each delivery.\n    Your task is to determine the optimal route that visits all locations within their time windows\n    while minimizing the total distance traveled.\n\n    Parameters:\n    num_locations (int): The number of delivery locations (including the starting depot)\n    distances (List[List[int]]): A 2D list where distances[i][j] represents the distance from location i to j\n    time_windows (List[Tuple[int, int]]): A list of tuples where each tuple (start, end) represents\n                                          the time window for each location\n\n    Returns:\n    List[int]: The optimal route as a list of location indices, or an empty list if no valid route exists\n\n    Example:\n    Input: 4, [[0,10,15,20],[10,0,35,25],[15,35,0,30],[20,25,30,0]], [(0,80),(10,20),(50,60),(30,40)]\n    Output: [0,1,3,2,0]\n\n    This represents a route starting at the depot (0), visiting location 1, then 3, then 2, and returning to the depot,\n    which satisfies all time windows and minimizes total distance traveled.\n    \"\"\"\n", "entry_point": "optimize_delivery_route", "solution": "    def is_valid_route(route):\n        current_time = 0\n        for i in range(len(route) - 1):\n            current_loc = route[i]\n            next_loc = route[i + 1]\n            current_time += distances[current_loc][next_loc]\n            if current_time > time_windows[next_loc][1]:\n                return False\n            current_time = max(current_time, time_windows[next_loc][0])\n        return True\n\n    def calculate_total_distance(route):\n        return sum(distances[route[i]][route[i+1]] for i in range(len(route) - 1))\n\n    locations = list(range(1, num_locations))  # Exclude depot (0)\n    best_route = []\n    min_distance = float('inf')\n\n    for perm in itertools.permutations(locations):\n        route = [0] + list(perm) + [0]  # Add depot at the start and end\n        if is_valid_route(route):\n            distance = calculate_total_distance(route)\n            if distance < min_distance:\n                min_distance = distance\n                best_route = route\n\n    return best_route\n", "test": "def check(candidate):\n    assert candidate(4, [[0,10,15,20],[10,0,35,25],[15,35,0,30],[20,25,30,0]], [(0,80),(10,20),(50,60),(30,40)]) == []\n    assert candidate(3, [[0,100,200],[100,0,300],[200,300,0]], [(0,1000),(200,300),(400,500)]) == [0, 1, 2, 0]\n    assert candidate(4, [[0,5,10,15],[5,0,20,25],[10,20,0,30],[15,25,30,0]], [(0,50),(10,20),(30,40),(40,50)]) == []\n    assert candidate(4, [[0,1,1,1],[1,0,1,1],[1,1,0,1],[1,1,1,0]], [(0,10),(2,4),(6,8),(10,12)]) == []\n    assert candidate(6, [[0,5,10,15,20,25],[5,0,8,13,18,23],[10,8,0,7,12,17],[15,13,7,0,9,14],[20,18,12,9,0,11],[25,23,17,14,11,0]], [(0,120),(10,30),(20,40),(30,50),(40,60),(50,70)]) == [0, 1, 2, 3, 4, 5, 0]\n    assert candidate(5, [[0,10,20,30,40],[10,0,10,20,30],[20,10,0,10,20],[30,20,10,0,10],[40,30,20,10,0]], [(0,100),(10,20),(30,40),(50,60),(70,80)]) == []\n    assert candidate(3, [[0,1000,2000],[1000,0,3000],[2000,3000,0]], [(0,10000),(3000,4000),(5000,6000)]) == [0, 1, 2, 0]\n    assert candidate(5, [[0,10,20,30,40],[10,0,15,25,35],[20,15,0,10,20],[30,25,10,0,15],[40,35,20,15,0]], [(0,100),(20,30),(40,50),(60,70),(80,90)]) == []\n    assert candidate(3, [[0,5,10],[5,0,15],[10,15,0]], [(0,50),(10,20),(30,40)]) == [0, 1, 2, 0]\n    assert candidate(2, [[0,50],[50,0]], [(0,100),(30,60)]) == [0, 1, 0]\n", "language": "python"}
{"task_id": "revision1a_problem336", "prompt": "import math\nfrom typing import List, Tuple\n\ndef optimize_delivery_route(packages: List[Tuple[float, float]], max_weight: float) -> List[List[int]]:\n    \"\"\"\n    As a logistics manager for an e-commerce company, I need to optimize our delivery routes.\n    Create a function that takes a list of package coordinates (as tuples of latitude and longitude) \n    and the maximum weight capacity of the delivery truck, and returns an optimized delivery route.\n\n    The function should:\n    1. Group packages into delivery batches that don't exceed the max_weight\n    2. For each batch, find the shortest route that visits all package locations and returns to the starting point (0, 0)\n    3. Return a list of lists, where each inner list represents a batch and contains the indices of packages in the order they should be delivered\n\n    Assume each package weighs 1 unit.\n    Use the nearest neighbor algorithm for route optimization (not necessarily the most optimal, but efficient).\n\n    Example:\n    Input: \n    packages = [(1.0, 1.0), (2.0, 2.0), (3.0, 3.0), (4.0, 4.0), (5.0, 5.0)]\n    max_weight = 3\n    Output: [[0, 1, 2], [3, 4]]\n    \"\"\"\n", "entry_point": "optimize_delivery_route", "solution": "    def distance(p1, p2):\n        return math.sqrt((p1[0] - p2[0])**2 + (p1[1] - p2[1])**2)\n\n    def nearest_neighbor(batch, start=(0, 0)):\n        unvisited = set(batch)\n        route = []\n        current = start\n\n        while unvisited:\n            next_stop = min(unvisited, key=lambda x: distance(current, packages[x]))\n            route.append(next_stop)\n            unvisited.remove(next_stop)\n            current = packages[next_stop]\n\n        return route\n\n    optimized_route = []\n    current_batch = []\n    \n    for i, package in enumerate(packages):\n        if len(current_batch) < max_weight:\n            current_batch.append(i)\n        else:\n            optimized_route.append(nearest_neighbor(current_batch))\n            current_batch = [i]\n\n    if current_batch:\n        optimized_route.append(nearest_neighbor(current_batch))\n\n    return optimized_route\n", "test": "def check(candidate):\n    assert candidate([(1.0, 1.0)], 1) == [[0]]\n    assert candidate([(1.1, 2.2), (3.3, 4.4), (5.5, 6.6), (7.7, 8.8), (9.9, 10.10)], 2) == [[0, 1], [2, 3], [4]]\n    assert candidate([(0.1, 0.1), (0.2, 0.2), (0.3, 0.3), (0.4, 0.4), (0.5, 0.5)], 10) == [[0, 1, 2, 3, 4]]\n    assert candidate([(0.1, 0.1), (0.2, 0.2), (0.3, 0.3), (0.4, 0.4), (0.5, 0.5), (0.6, 0.6)], 3) == [[0, 1, 2], [3, 4, 5]]\n    assert candidate([(0.0, 0.0), (1.0, 1.0), (2.0, 2.0), (3.0, 3.0)], 1) == [[0], [1], [2], [3]]\n    assert candidate([(1.0, 1.0), (2.0, 2.0), (3.0, 3.0), (4.0, 4.0), (5.0, 5.0)], 3) == [[0, 1, 2], [3, 4]]\n    assert candidate([(1.0, 0.0), (0.0, 1.0), (-1.0, 0.0), (0.0, -1.0)], 4) == [[0, 1, 2, 3]]\n    assert candidate([], 5) == []\n    assert candidate([(0.5, 0.5), (1.5, 1.5), (2.5, 2.5), (3.5, 3.5)], 2) == [[0, 1], [2, 3]]\n    assert candidate([(10.0, 10.0), (20.0, 20.0), (30.0, 30.0), (40.0, 40.0), (50.0, 50.0)], 5) == [[0, 1, 2, 3, 4]]\n", "language": "python"}
{"task_id": "revision1a_problem48", "prompt": "import re\nfrom typing import List, Dict\n\ndef analyze_text_sentiment(text: str) -> Dict[str, float]:\n    \"\"\"\n    You're working on a social media sentiment analysis tool. Your task is to analyze the sentiment of a given text\n    based on the presence and frequency of positive and negative words.\n    \n    The function should do the following:\n    1. Count the number of words in the text.\n    2. Identify positive and negative words using predefined lists.\n    3. Calculate the percentage of positive and negative words.\n    4. Determine the overall sentiment based on these percentages.\n    \n    Input: A string containing the text to analyze.\n    Output: A dictionary with the following keys:\n        - 'word_count': Total number of words in the text\n        - 'positive_percentage': Percentage of positive words\n        - 'negative_percentage': Percentage of negative words\n        - 'sentiment': Overall sentiment ('positive', 'negative', or 'neutral')\n    \n    Example:\n    Input: \"I love this product! It's amazing and works great. However, the price is a bit high.\"\n    Output: {\n        'word_count': 13,\n        'positive_percentage': 23.08,\n        'negative_percentage': 7.69,\n        'sentiment': 'positive'\n    }\n    \n    Note: Use regular expressions to tokenize the text into words. Ignore case when matching words.\n    \"\"\"\n", "entry_point": "analyze_text_sentiment", "solution": "    def tokenize(text: str) -> List[str]:\n        return re.findall(r'\\b\\w+\\b', text.lower())\n\n    def calculate_percentage(count: int, total: int) -> float:\n        return round((count / total) * 100, 2)\n\n    positive_words = set(['love', 'amazing', 'great', 'excellent', 'good', 'best', 'wonderful', 'fantastic'])\n    negative_words = set(['bad', 'terrible', 'awful', 'worst', 'horrible', 'poor', 'disappointing'])\n\n    words = tokenize(text)\n    word_count = len(words)\n\n    positive_count = sum(1 for word in words if word in positive_words)\n    negative_count = sum(1 for word in words if word in negative_words)\n\n    positive_percentage = calculate_percentage(positive_count, word_count)\n    negative_percentage = calculate_percentage(negative_count, word_count)\n\n    if positive_percentage > negative_percentage:\n        sentiment = 'positive'\n    elif negative_percentage > positive_percentage:\n        sentiment = 'negative'\n    else:\n        sentiment = 'neutral'\n\n    return {\n        'word_count': word_count,\n        'positive_percentage': positive_percentage,\n        'negative_percentage': negative_percentage,\n        'sentiment': sentiment\n    }\n", "test": "def check(candidate):\n    assert candidate(\"I love this product! It\\'s amazing and works great. However, the price is a bit high.\") == {'word_count': 17, 'positive_percentage': 17.65, 'negative_percentage': 0.0, 'sentiment': 'positive'}\n    assert candidate(\"This is a neutral statement without any strong emotions.\") == {'word_count': 9, 'positive_percentage': 0.0, 'negative_percentage': 0.0, 'sentiment': 'neutral'}\n    assert candidate(\"a b c d e f g h i j k l m n o p q r s t u v w x y z\") == {'word_count': 26, 'positive_percentage': 0.0, 'negative_percentage': 0.0, 'sentiment': 'neutral'}\n    assert candidate(\"Mixed feelings: happy about the quality but sad about the cost.\") == {'word_count': 11, 'positive_percentage': 0.0, 'negative_percentage': 0.0, 'sentiment': 'neutral'}\n    assert candidate(\"SHOUTING IN ALL CAPS IS NOT ALWAYS ANGRY!\") == {'word_count': 8, 'positive_percentage': 0.0, 'negative_percentage': 0.0, 'sentiment': 'neutral'}\n    assert candidate(\"EXCELLENT! FANTASTIC! OUTSTANDING! SUPERB!\") == {'word_count': 4, 'positive_percentage': 50.0, 'negative_percentage': 0.0, 'sentiment': 'positive'}\n    assert candidate(\"bad. worse. worst. terrible. horrible.\") == {'word_count': 5, 'positive_percentage': 0.0, 'negative_percentage': 80.0, 'sentiment': 'negative'}\n    assert candidate(\"The quick brown fox jumps over the lazy dog.\") == {'word_count': 9, 'positive_percentage': 0.0, 'negative_percentage': 0.0, 'sentiment': 'neutral'}\n    assert candidate(\"Positive words: good, great, excellent. Negative words: bad, awful, terrible.\") == {'word_count': 10, 'positive_percentage': 30.0, 'negative_percentage': 30.0, 'sentiment': 'neutral'}\n    assert candidate(\"Horrible experience! Awful service and terrible food. Never going back.\") == {'word_count': 10, 'positive_percentage': 0.0, 'negative_percentage': 30.0, 'sentiment': 'negative'}\n", "language": "python"}
{"task_id": "revision1a_problem233", "prompt": "import heapq\nfrom typing import List, Tuple\n\ndef network_latency(connections: List[Tuple[str, str, int]], start: str, end: str) -> int:\n    \"\"\"\n    You are a network engineer tasked with finding the minimum latency between two servers in a complex network.\n    The network is represented by a list of connections, where each connection is a tuple (server1, server2, latency).\n    Your goal is to find the path with the lowest total latency from the start server to the end server.\n    \n    Take connections as input from the user, where each element is a tuple of two server names (strings) and the latency between them (integer).\n    Also take start and end as input, representing the names of the start and end servers.\n    Print the minimum latency between the start and end servers. If there's no path, print -1.\n    \n    Use Dijkstra's algorithm to solve this problem efficiently.\n    \n    Example:\n    Input: [(\"A\", \"B\", 5), (\"B\", \"C\", 2), (\"A\", \"C\", 10), (\"C\", \"D\", 1)], \"A\", \"D\"\n    Output: 8\n    \n    Input: [(\"X\", \"Y\", 2), (\"Y\", \"Z\", 3), (\"X\", \"W\", 1)], \"X\", \"Z\"\n    Output: 5\n    \"\"\"\n", "entry_point": "network_latency", "solution": "    # Build the graph\n    graph = {}\n    for server1, server2, latency in connections:\n        if server1 not in graph:\n            graph[server1] = {}\n        if server2 not in graph:\n            graph[server2] = {}\n        graph[server1][server2] = latency\n        graph[server2][server1] = latency\n    \n    # Initialize distances and priority queue\n    distances = {server: float('inf') for server in graph}\n    distances[start] = 0\n    pq = [(0, start)]\n    \n    # Dijkstra's algorithm\n    while pq:\n        current_distance, current_server = heapq.heappop(pq)\n        \n        if current_server == end:\n            return current_distance\n        \n        if current_distance > distances[current_server]:\n            continue\n        \n        for neighbor, latency in graph[current_server].items():\n            distance = current_distance + latency\n            if distance < distances[neighbor]:\n                distances[neighbor] = distance\n                heapq.heappush(pq, (distance, neighbor))\n    \n    # If end is not reachable\n    return -1\n", "test": "def check(candidate):\n    assert candidate([(\"A\", \"B\", 5), (\"B\", \"C\", 2), (\"A\", \"C\", 10), (\"C\", \"D\", 1)], \"A\", \"D\") == 8\n    assert candidate([(\"A\", \"B\", 1), (\"B\", \"C\", 2), (\"C\", \"D\", 3), (\"A\", \"D\", 10)], \"A\", \"D\") == 6\n    assert candidate([(\"A\", \"B\", 1)], \"A\", \"B\") == 1\n    assert candidate([(\"A\", \"B\", 1), (\"B\", \"C\", 2), (\"C\", \"A\", 3)], \"A\", \"A\") == 0\n    assert candidate([(\"A\", \"B\", 1)], \"B\", \"A\") == 1\n    assert candidate([(\"A\", \"B\", 1), (\"B\", \"C\", 2), (\"C\", \"D\", 3)], \"A\", \"E\") == -1\n    assert candidate([(\"X\", \"Y\", 2), (\"Y\", \"Z\", 3), (\"X\", \"W\", 1)], \"X\", \"Z\") == 5\n    assert candidate([(\"A\", \"B\", 1), (\"B\", \"C\", 2), (\"C\", \"D\", 3)], \"D\", \"A\") == 6\n    assert candidate([(\"A\", \"B\", 1), (\"B\", \"C\", 2), (\"C\", \"D\", 3)], \"A\", \"D\") == 6\n    assert candidate([(\"A\", \"B\", 1), (\"B\", \"C\", 2), (\"A\", \"C\", 5)], \"A\", \"C\") == 3\n", "language": "python"}
{"task_id": "revision1a_problem404", "prompt": "import math\nfrom typing import List, Tuple\n\ndef optimize_delivery_route(locations: List[Tuple[float, float]]) -> List[int]:\n    \"\"\"\n    Optimize a delivery route for a courier service using a simple nearest-neighbor algorithm.\n\n    This function demonstrates the use of mathematical calculations, list manipulation,\n    and a greedy algorithm approach to solve a real-world problem.\n\n    Parameters:\n    locations (List[Tuple[float, float]]): A list of (latitude, longitude) coordinates representing delivery locations\n\n    Returns:\n    List[int]: An optimized route represented by indices of the input locations list\n\n    Example:\n    Input: [(0, 0), (1, 1), (2, 2), (3, 3), (4, 4)]\n    Output: [0, 1, 2, 3, 4]\n\n    Note: This is a simplified approach and may not always produce the globally optimal route.\n    The function assumes the courier starts and ends at the first location in the list.\n    \"\"\"\n", "entry_point": "optimize_delivery_route", "solution": "    def calculate_distance(loc1: Tuple[float, float], loc2: Tuple[float, float]) -> float:\n        \"\"\"Calculate the Euclidean distance between two locations.\"\"\"\n        return math.sqrt((loc1[0] - loc2[0])**2 + (loc1[1] - loc2[1])**2)\n\n    num_locations = len(locations)\n    unvisited = set(range(1, num_locations))  # Exclude the starting point\n    route = [0]  # Start with the first location\n\n    while unvisited:\n        current = route[-1]\n        nearest = min(unvisited, key=lambda x: calculate_distance(locations[current], locations[x]))\n        route.append(nearest)\n        unvisited.remove(nearest)\n\n    return route\n", "test": "def check(candidate):\n    assert candidate([(0, 0), (1, 1), (2, 2), (3, 3), (4, 4)]) == [0, 1, 2, 3, 4]\n    assert candidate([(0, 0), (1, 1), (-1, -1), (2, 2), (-2, -2)]) == [0, 1, 3, 2, 4]\n    assert candidate([(0, 0), (10, 10), (20, 20), (30, 30), (40, 40)]) == [0, 1, 2, 3, 4]\n    assert candidate([(90, 180), (-90, -180), (0, 0), (45, 90), (-45, -90)]) == [0, 3, 2, 4, 1]\n    assert candidate([(1, 1), (1, 2), (1, 3), (2, 1), (2, 2), (2, 3), (3, 1), (3, 2), (3, 3)]) == [0, 1, 2, 5, 4, 3, 6, 7, 8]\n    assert candidate([(0, 0), (0, 1), (0, 2), (0, 3), (0, 4)]) == [0, 1, 2, 3, 4]\n    assert candidate([(0, 0), (5, 5), (3, 7), (8, 2), (1, 9)]) == [0, 1, 2, 4, 3]\n    assert candidate([(0, 0)]) == [0]\n    assert candidate([(0, 0), (1, 0), (2, 0), (3, 0), (4, 0)]) == [0, 1, 2, 3, 4]\n    assert candidate([(0, 0), (0.1, 0.1), (0.2, 0.2), (0.3, 0.3), (0.4, 0.4)]) == [0, 1, 2, 3, 4]\n", "language": "python"}
{"task_id": "revision1a_problem615", "prompt": "from typing import List\n\ndef maze_escape(moves: List[str]) -> bool:\n    \"\"\"\n    Determine if a robot can escape a maze based on a series of moves.\n    \n    Imagine a robot in a 5x5 maze, starting at position (0,0). The robot can move\n    in four directions: 'U' (up), 'D' (down), 'L' (left), 'R' (right). The maze has\n    walls at the edges and some internal walls. The exit is at position (4,4).\n\n    Take a list of moves as input and return True if the robot reaches the exit,\n    False otherwise. The robot cannot move through walls.\n\n    Example:\n    Input: ['R', 'R', 'D', 'D', 'R', 'R', 'D', 'D']\n    Output: True\n    Input: ['R', 'R', 'D', 'L', 'D', 'R', 'U', 'R']\n    Output: False\n    Input: ['D', 'D', 'R', 'R', 'U', 'R', 'R', 'D', 'D']\n    Output: True\n    \"\"\"\n", "entry_point": "maze_escape", "solution": "    \n    def is_valid_move(x: int, y: int) -> bool:\n        return 0 <= x < 5 and 0 <= y < 5\n    \n    x, y = 0, 0  # Starting position\n    \n    for move in moves:\n        if move == 'U':\n            if is_valid_move(x, y - 1):\n                y -= 1\n        elif move == 'D':\n            if is_valid_move(x, y + 1):\n                y += 1\n        elif move == 'L':\n            if is_valid_move(x - 1, y):\n                x -= 1\n        elif move == 'R':\n            if is_valid_move(x + 1, y):\n                x += 1\n        \n        if x == 4 and y == 4:\n            return True\n    \n    return False\n", "test": "def check(candidate):\n    assert candidate(['R', 'R', 'R', 'R', 'D', 'D', 'D', 'D', 'L']) == True\n    assert candidate(['R', 'R', 'R', 'R', 'D', 'D', 'D', 'D']) == True\n    assert candidate(['R', 'R', 'D', 'D', 'R', 'R', 'D', 'D']) == True\n    assert candidate(['R', 'D', 'R', 'D', 'R', 'D', 'R', 'D']) == True\n    assert candidate(['D', 'D', 'D', 'D', 'R', 'R', 'R', 'R']) == True\n    assert candidate([]) == False\n    assert candidate(['D', 'D', 'R', 'R', 'U', 'R', 'R', 'D', 'D']) == False\n    assert candidate(['R', 'R', 'R', 'R', 'D', 'D', 'D', 'L', 'L', 'L', 'L', 'U', 'U', 'U', 'R', 'R', 'R', 'R', 'D', 'D', 'D', 'D']) == True\n    assert candidate(['U', 'L']) == False\n", "language": "python"}
{"task_id": "revision1a_problem47", "prompt": "from typing import List, Dict, Any\n\ndef analyze_stock_portfolio(transactions: List[Dict[str, Any]]) -> Dict[str, float]:\n    \"\"\"\n    As a stock market investor, I want to analyze my portfolio's performance over time.\n    I have a list of stock transactions, each containing the stock symbol, buy/sell action,\n    quantity, and price. I need to calculate the overall profit/loss for each stock.\n\n    The function should process the transactions chronologically and return a dictionary\n    with each stock symbol as the key and the total profit/loss as the value.\n\n    Rules:\n    1. Buy transactions decrease available cash and increase stock holdings.\n    2. Sell transactions increase available cash and decrease stock holdings.\n    3. You cannot sell stocks you don't own (no short selling).\n    4. Profit/loss is calculated as: (sell price - buy price) * quantity for each transaction.\n\n    Input: List of dictionaries, each representing a transaction with keys 'symbol', 'action', 'quantity', and 'price'.\n    Output: Dictionary with stock symbols as keys and total profit/loss as values.\n\n    Example:\n    Input: [\n        {'symbol': 'AAPL', 'action': 'buy', 'quantity': 10, 'price': 150},\n        {'symbol': 'GOOGL', 'action': 'buy', 'quantity': 5, 'price': 2000},\n        {'symbol': 'AAPL', 'action': 'sell', 'quantity': 5, 'price': 170},\n        {'symbol': 'GOOGL', 'action': 'sell', 'quantity': 5, 'price': 2100}\n    ]\n    Output: {'AAPL': 100, 'GOOGL': 500}\n\n    Input: [\n        {'symbol': 'TSLA', 'action': 'buy', 'quantity': 20, 'price': 500},\n        {'symbol': 'TSLA', 'action': 'sell', 'quantity': 10, 'price': 450},\n        {'symbol': 'TSLA', 'action': 'buy', 'quantity': 5, 'price': 600}\n    ]\n    Output: {'TSLA': -1500}\n    \"\"\"\n", "entry_point": "analyze_stock_portfolio", "solution": "    portfolio = {}\n    profit_loss = {}\n\n    for transaction in transactions:\n        symbol = transaction['symbol']\n        action = transaction['action']\n        quantity = transaction['quantity']\n        price = transaction['price']\n\n        if symbol not in portfolio:\n            portfolio[symbol] = []\n            profit_loss[symbol] = 0\n\n        if action == 'buy':\n            portfolio[symbol].append((quantity, price))\n        elif action == 'sell':\n            shares_to_sell = quantity\n            while shares_to_sell > 0:\n                if not portfolio[symbol]:\n                    # Cannot sell stocks you don't own\n                    break\n                \n                buy_quantity, buy_price = portfolio[symbol][0]\n                if buy_quantity <= shares_to_sell:\n                    # Sell all shares from this buy transaction\n                    profit_loss[symbol] += (price - buy_price) * buy_quantity\n                    shares_to_sell -= buy_quantity\n                    portfolio[symbol].pop(0)\n                else:\n                    # Sell part of the shares from this buy transaction\n                    profit_loss[symbol] += (price - buy_price) * shares_to_sell\n                    portfolio[symbol][0] = (buy_quantity - shares_to_sell, buy_price)\n                    shares_to_sell = 0\n\n    return profit_loss\n", "test": "def check(candidate):\n    assert candidate([{'symbol': 'AMZN', 'action': 'buy', 'quantity': 1, 'price': 3000}]) == {'AMZN': 0}\n    assert candidate([{'symbol': 'FB', 'action': 'buy', 'quantity': 50, 'price': 300}, {'symbol': 'FB', 'action': 'sell', 'quantity': 25, 'price': 280}, {'symbol': 'FB', 'action': 'sell', 'quantity': 25, 'price': 320}]) == {'FB': 0}\n    assert candidate([{'symbol': 'MSFT', 'action': 'buy', 'quantity': 100, 'price': 200}, {'symbol': 'MSFT', 'action': 'sell', 'quantity': 100, 'price': 220}]) == {'MSFT': 2000}\n    assert candidate([{'symbol': 'NFLX', 'action': 'buy', 'quantity': 10, 'price': 500}, {'symbol': 'NFLX', 'action': 'sell', 'quantity': 5, 'price': 600}, {'symbol': 'NFLX', 'action': 'sell', 'quantity': 5, 'price': 400}]) == {'NFLX': 0}\n    assert candidate([{'symbol': 'GOOGL', 'action': 'buy', 'quantity': 1, 'price': 2000}, {'symbol': 'AAPL', 'action': 'buy', 'quantity': 10, 'price': 150}, {'symbol': 'MSFT', 'action': 'buy', 'quantity': 5, 'price': 200}, {'symbol': 'GOOGL', 'action': 'sell', 'quantity': 1, 'price': 2100}, {'symbol': 'AAPL', 'action': 'sell', 'quantity': 10, 'price': 160}, {'symbol': 'MSFT', 'action': 'sell', 'quantity': 5, 'price': 210}]) == {'GOOGL': 100, 'AAPL': 100, 'MSFT': 50}\n    assert candidate([{'symbol': 'TSLA', 'action': 'buy', 'quantity': 10, 'price': 1000}, {'symbol': 'TSLA', 'action': 'sell', 'quantity': 10, 'price': 1000}]) == {'TSLA': 0}\n    assert candidate([{'symbol': 'XYZ', 'action': 'buy', 'quantity': 100, 'price': 10}, {'symbol': 'XYZ', 'action': 'sell', 'quantity': 50, 'price': 15}, {'symbol': 'XYZ', 'action': 'buy', 'quantity': 25, 'price': 12}, {'symbol': 'XYZ', 'action': 'sell', 'quantity': 75, 'price': 11}]) == {'XYZ': 275}\n    assert candidate([{'symbol': 'TSLA', 'action': 'buy', 'quantity': 20, 'price': 500}, {'symbol': 'TSLA', 'action': 'sell', 'quantity': 10, 'price': 450}, {'symbol': 'TSLA', 'action': 'buy', 'quantity': 5, 'price': 600}]) == {'TSLA': -500}\n    assert candidate([{'symbol': 'AAPL', 'action': 'buy', 'quantity': 10, 'price': 150}, {'symbol': 'GOOGL', 'action': 'buy', 'quantity': 5, 'price': 2000}, {'symbol': 'AAPL', 'action': 'sell', 'quantity': 5, 'price': 170}, {'symbol': 'GOOGL', 'action': 'sell', 'quantity': 5, 'price': 2100}]) == {'AAPL': 100, 'GOOGL': 500}\n", "language": "python"}
{"task_id": "revision1a_problem469", "prompt": "from typing import List\n\ndef min_platforms(arrival: List[int], departure: List[int]) -> int:\n    \"\"\"\n    At a train station, trains arrive and depart at various times. The station needs to determine the minimum number of platforms required to accommodate all trains without any collision.\n    \n    Take two lists as input from the user:\n    - arrival: list of arrival times of trains\n    - departure: list of departure times of trains\n    \n    Both lists are sorted in ascending order. Times are given in 24-hour format as integers (e.g., 930 for 9:30 AM, 1430 for 2:30 PM).\n\n    Return the minimum number of platforms required.\n\n    Example:\n    Input: \n    arrival = [900, 940, 950, 1100, 1500, 1800]\n    departure = [910, 1200, 1120, 1130, 1900, 2000]\n    Output: 3\n\n    Input:\n    arrival = [900, 1100, 1235]\n    departure = [1000, 1200, 1240]\n    Output: 1\n    \"\"\"\n", "entry_point": "min_platforms", "solution": "    n = len(arrival)\n    events = []\n    \n    # Create a list of events with arrival and departure times\n    for i in range(n):\n        events.append((arrival[i], 1))  # 1 indicates arrival\n        events.append((departure[i], -1))  # -1 indicates departure\n    \n    # Sort events based on time\n    events.sort(key=lambda x: (x[0], -x[1]))\n    \n    platforms = 0\n    max_platforms = 0\n    \n    # Iterate through events and count platforms needed\n    for event in events:\n        platforms += event[1]\n        max_platforms = max(max_platforms, platforms)\n    \n    return max_platforms\n", "test": "def check(candidate):\n    assert candidate([1200], [1300]) == 1\n    assert candidate([900, 900, 900], [1000, 1000, 1000]) == 3\n    assert candidate([100, 200, 300], [101, 201, 301]) == 1\n    assert candidate([1, 2, 3, 4, 5], [6, 7, 8, 9, 10]) == 5\n    assert candidate([2359, 0, 1], [2359, 0, 1]) == 1\n    assert candidate([900, 940, 950, 1100, 1500, 1800], [910, 1200, 1120, 1130, 1900, 2000]) == 3\n    assert candidate([900, 1100, 1235], [1000, 1200, 1240]) == 1\n    assert candidate([1000, 1000, 1000, 1000], [1001, 1002, 1003, 1004]) == 4\n    assert candidate([0, 100, 200, 300, 400], [50, 150, 250, 350, 450]) == 1\n    assert candidate([800, 850, 900], [840, 870, 930]) == 1\n", "language": "python"}
{"task_id": "revision1a_problem728", "prompt": "from typing import List, Tuple\n\ndef optimize_study_schedule(subjects: List[str], difficulties: List[int], available_time: int) -> Tuple[List[str], int]:\n    \"\"\"\n    As a student preparing for exams, you want to optimize your study schedule.\n    You have a list of subjects to study, each with an associated difficulty level.\n    Your goal is to maximize the number of subjects you can study within your available time.\n\n    Create a function that takes the following inputs:\n    1. A list of subjects (strings)\n    2. A list of corresponding difficulty levels (integers from 1 to 10)\n    3. The total available study time (in hours)\n\n    Assume that the time required to study a subject is equal to its difficulty level in hours.\n    \n    The function should return a tuple containing:\n    1. A list of subjects that can be studied within the available time, maximizing the number of subjects.\n    2. The total difficulty of the selected subjects.\n\n    If multiple combinations of subjects are possible, choose the one with the highest total difficulty.\n    If there are still multiple options, choose the one that includes subjects earlier in the input list.\n\n    Example:\n    Input: \n    subjects = [\"Math\", \"Science\", \"History\", \"English\", \"Art\"]\n    difficulties = [5, 4, 3, 2, 1]\n    available_time = 10\n    Output: ([\"Math\", \"Science\", \"History\"], 12)\n\n    Explanation: This combination allows studying 3 subjects with a total difficulty of 12,\n    which is the maximum number of subjects possible within 10 hours.\n    \"\"\"\n", "entry_point": "optimize_study_schedule", "solution": "    n = len(subjects)\n    dp = [[0] * (available_time + 1) for _ in range(n + 1)]\n    \n    for i in range(1, n + 1):\n        for j in range(available_time + 1):\n            if difficulties[i-1] <= j:\n                dp[i][j] = max(dp[i-1][j], dp[i-1][j-difficulties[i-1]] + 1)\n            else:\n                dp[i][j] = dp[i-1][j]\n    \n    selected_subjects = []\n    total_difficulty = 0\n    i, j = n, available_time\n    \n    while i > 0 and j > 0:\n        if dp[i][j] != dp[i-1][j]:\n            selected_subjects.append(subjects[i-1])\n            total_difficulty += difficulties[i-1]\n            j -= difficulties[i-1]\n        i -= 1\n    \n    selected_subjects.reverse()\n    return (selected_subjects, total_difficulty)\n", "test": "def check(candidate):\n    assert candidate([\"Calculus\", \"Linear Algebra\", \"Statistics\", \"Discrete Math\"], [6, 5, 4, 3], 9) == (['Linear Algebra', 'Statistics'], 9)\n    assert candidate([\"Music\", \"Art\", \"Dance\", \"Drama\", \"Photography\"], [1, 1, 2, 2, 3], 5) == (['Music', 'Art', 'Dance'], 4)\n    assert candidate([\"Physics\", \"Chemistry\", \"Biology\"], [8, 7, 6], 15) == (['Physics', 'Chemistry'], 15)\n    assert candidate([\"Programming\", \"Databases\", \"Networking\"], [10, 9, 8], 20) == (['Programming', 'Databases'], 19)\n    assert candidate([\"Math\", \"Science\", \"History\", \"English\", \"Art\"], [5, 4, 3, 2, 1], 10) == (['Science', 'History', 'English', 'Art'], 10)\n    assert candidate([\"Anatomy\", \"Physiology\", \"Biochemistry\", \"Pathology\"], [7, 6, 8, 5], 14) == (['Anatomy', 'Physiology'], 13)\n    assert candidate([\"Literature\", \"Philosophy\", \"Psychology\", \"Sociology\"], [3, 4, 5, 2], 12) == (['Literature', 'Philosophy', 'Psychology'], 12)\n    assert candidate([\"Geography\", \"History\", \"Civics\", \"Economics\"], [2, 3, 2, 4], 6) == (['Geography', 'History'], 5)\n    assert candidate([\"Economics\", \"Finance\", \"Accounting\", \"Marketing\", \"Management\"], [5, 6, 4, 3, 2], 18) == (['Economics', 'Finance', 'Accounting', 'Marketing'], 18)\n    assert candidate([\"Spanish\", \"French\", \"German\", \"Italian\", \"Chinese\"], [2, 3, 4, 3, 5], 8) == (['Spanish', 'French', 'Italian'], 8)\n", "language": "python"}
{"task_id": "revision1a_problem196", "prompt": "def compress_string(s: str) -> str:\n    \"\"\"\n    A data compression algorithm needs to be implemented for a messaging app.\n    The algorithm should compress repeated consecutive characters in a string.\n    \n    Given a string, compress it by replacing sequences of repeated characters \n    with the character followed by the count of repetitions.\n    If the compressed string is not shorter than the original string, return the original string.\n    The function should be case-sensitive.\n    \n    Use a combination of string manipulation and counting to solve this problem efficiently.\n    \n    Example:\n    Input: \"aabcccccaaa\"\n    Output: \"a2b1c5a3\"\n    Input: \"abcdefg\"\n    Output: \"abcdefg\"\n    Input: \"AAAaaa\"\n    Output: \"A3a3\"\n    \"\"\"\n", "entry_point": "compress_string", "solution": "    if not s:\n        return s\n\n    compressed = []\n    count = 1\n    current_char = s[0]\n\n    for char in s[1:]:\n        if char == current_char:\n            count += 1\n        else:\n            compressed.append(current_char + str(count))\n            current_char = char\n            count = 1\n\n    compressed.append(current_char + str(count))\n\n    compressed_string = ''.join(compressed)\n    return compressed_string if len(compressed_string) < len(s) else s\n", "test": "def check(candidate):\n    assert candidate(\"a\") == 'a'\n    assert candidate(\"aabcccccaaa\") == 'a2b1c5a3'\n    assert candidate(\"abcdefg\") == 'abcdefg'\n    assert candidate(\"\") == ''\n    assert candidate(\"aaaa\") == 'a4'\n    assert candidate(\"AAAaaa\") == 'A3a3'\n    assert candidate(\"aa\") == 'aa'\n    assert candidate(\"aabbaa\") == 'aabbaa'\n    assert candidate(\"AAAAABBBCCCC\") == 'A5B3C4'\n    assert candidate(\"aaa\") == 'a3'\n", "language": "python"}
{"task_id": "revision1a_problem40", "prompt": "from typing import List, Tuple\nimport math\n\ndef optimize_delivery_route(locations: List[Tuple[float, float]], start: Tuple[float, float]) -> List[Tuple[float, float]]:\n    \"\"\"\n    A delivery company wants to optimize their route for package delivery.\n    Given a list of delivery locations (represented as (x, y) coordinates) and a starting point,\n    find the most efficient route that visits all locations and returns to the start.\n    \n    Use the nearest neighbor algorithm to solve this Traveling Salesman Problem (TSP).\n    Take input from the user for the list of locations and the starting point.\n    Return the optimized route as a list of coordinates.\n\n    Example:\n    Input: [(0, 0), (1, 5), (2, 2), (3, 3)], (0, 0)\n    Output: [(0, 0), (2, 2), (3, 3), (1, 5), (0, 0)]\n    \"\"\"\n", "entry_point": "optimize_delivery_route", "solution": "    def distance(point1: Tuple[float, float], point2: Tuple[float, float]) -> float:\n        return math.sqrt((point1[0] - point2[0])**2 + (point1[1] - point2[1])**2)\n\n    unvisited = locations.copy()\n    if start in unvisited:\n        unvisited.remove(start)\n\n    route = [start]\n    current = start\n\n    while unvisited:\n        nearest = min(unvisited, key=lambda x: distance(current, x))\n        route.append(nearest)\n        unvisited.remove(nearest)\n        current = nearest\n\n    route.append(start)\n    return route\n\n", "test": "def check(candidate):\n    assert candidate([(1, 1), (2, 2), (3, 3), (4, 4), (5, 5)], (0, 0)) == [(0, 0), (1, 1), (2, 2), (3, 3), (4, 4), (5, 5), (0, 0)]\n    assert candidate([(0, 0), (0, 5), (5, 0), (5, 5)], (2.5, 2.5)) == [(2.5, 2.5), (0, 0), (0, 5), (5, 5), (5, 0), (2.5, 2.5)]\n    assert candidate([(1, 1), (1, 2), (1, 3), (1, 4), (1, 5)], (1, 0)) == [(1, 0), (1, 1), (1, 2), (1, 3), (1, 4), (1, 5), (1, 0)]\n    assert candidate([(i, i) for i in range(10)], (0, 0)) == [(0, 0), (1, 1), (2, 2), (3, 3), (4, 4), (5, 5), (6, 6), (7, 7), (8, 8), (9, 9), (0, 0)]\n    assert candidate([(0, 0), (1, 5), (2, 2), (3, 3)], (0, 0)) == [(0, 0), (2, 2), (3, 3), (1, 5), (0, 0)]\n    assert candidate([(0, 0), (0, 1), (1, 0), (1, 1)], (0, 0)) == [(0, 0), (0, 1), (1, 1), (1, 0), (0, 0)]\n    assert candidate([(1.5, 2.7), (3.2, 4.1), (5.8, 6.3), (7.4, 8.9)], (0, 0)) == [(0, 0), (1.5, 2.7), (3.2, 4.1), (5.8, 6.3), (7.4, 8.9), (0, 0)]\n    assert candidate([(0, 0), (10, 10), (20, 20), (30, 30)], (5, 5)) == [(5, 5), (0, 0), (10, 10), (20, 20), (30, 30), (5, 5)]\n    assert candidate([(0, 0)], (0, 0)) == [(0, 0), (0, 0)]\n    assert candidate([(0, 0), (-1, -1), (-2, -2), (-3, -3)], (0, 0)) == [(0, 0), (-1, -1), (-2, -2), (-3, -3), (0, 0)]\n", "language": "python"}
{"task_id": "revision1a_problem517", "prompt": "import re\nfrom typing import List, Dict\n\ndef analyze_log_files(log_files: List[str], patterns: Dict[str, str]) -> Dict[str, Dict[str, int]]:\n    \"\"\"\n    A cybersecurity team needs to analyze multiple log files from various servers to detect potential security threats. They want to search for specific patterns in the logs and count their occurrences.\n\n    Given a list of file paths to log files and a dictionary of patterns to search for (where keys are pattern names and values are regex patterns), analyze all log files and return a summary of pattern occurrences.\n\n    The function should return a nested dictionary where the outer key is the log file name, the inner key is the pattern name, and the value is the count of occurrences.\n\n    Example:\n    Input: \n    log_files = [\"/var/log/server1.log\", \"/var/log/server2.log\"]\n    patterns = {\n        \"failed_login\": r\"Failed login attempt from IP: \\d{1,3}\\.\\d{1,3}\\.\\d{1,3}\\.\\d{1,3}\",\n        \"high_cpu_usage\": r\"CPU usage exceeded 90%\"\n    }\n    Output: \n    {\n        \"server1.log\": {\"failed_login\": 15, \"high_cpu_usage\": 3},\n        \"server2.log\": {\"failed_login\": 7, \"high_cpu_usage\": 0}\n    }\n    \"\"\"\n", "entry_point": "analyze_log_files", "solution": "    result = {}\n\n    for log_file in log_files:\n        file_name = log_file.split('/')[-1]\n        result[file_name] = {pattern_name: 0 for pattern_name in patterns}\n\n        try:\n            with open(log_file, 'r') as file:\n                content = file.read()\n\n                for pattern_name, pattern in patterns.items():\n                    matches = re.findall(pattern, content)\n                    result[file_name][pattern_name] = len(matches)\n\n        except FileNotFoundError:\n            print(f\"Warning: File {log_file} not found. Skipping...\")\n        except IOError:\n            print(f\"Error: Unable to read file {log_file}. Skipping...\")\n\n    return result\n", "test": "def check(candidate):\n    assert candidate([\"/var/log/server1.log\", \"/var/log/server2.log\"], {\"high_cpu\": r\"CPU usage > 90%\"}) == {'server1.log': {'high_cpu': 0}, 'server2.log': {'high_cpu': 0}}\n    assert candidate([\"/var/log/app.log\"], {}) == {'app.log': {}}\n    assert candidate([\"/var/log/access.log\"], {\"404\": r\"404 Not Found\", \"500\": r\"500 Internal Server Error\"}) == {'access.log': {'404': 0, '500': 0}}\n    assert candidate([\"/var/log/system.log\"], {\"all\": r\".*\"}) == {'system.log': {'all': 0}}\n    assert candidate([\"/var/log/server1.log\"], {\"failed_login\": r\"Failed login\"}) == {'server1.log': {'failed_login': 0}}\n    assert candidate([\"/var/log/error.log\", \"/var/log/debug.log\"], {\"critical\": r\"CRITICAL\", \"warning\": r\"WARNING\", \"info\": r\"INFO\"}) == {'error.log': {'critical': 0, 'warning': 0, 'info': 0}, 'debug.log': {'critical': 0, 'warning': 0, 'info': 0}}\n    assert candidate([], {\"error\": r\"Error \\d+\"}) == {}\n    assert candidate([\"/var/log/mail.log\"], {\"spam\": r\"marked as spam\", \"bounce\": r\"bounced\"}) == {'mail.log': {'spam': 0, 'bounce': 0}}\n    assert candidate([\"/var/log/auth.log\"], {\"sudo\": r\"sudo\", \"ssh\": r\"sshd\"}) == {'auth.log': {'sudo': 0, 'ssh': 0}}\n    assert candidate([\"/var/log/empty.log\"], {\"warning\": r\"Warning:\"}) == {'empty.log': {'warning': 0}}\n", "language": "python"}
{"task_id": "revision1a_problem565", "prompt": "import random\nfrom typing import List, Dict\n\ndef simulate_stock_market(initial_prices: Dict[str, float], days: int, volatility: float) -> List[Dict[str, float]]:\n    \"\"\"\n    You are building a stock market simulator for a financial education platform. \n    Your task is to implement a function that simulates daily price changes for a given set of stocks over a specified period.\n\n    The function should:\n    1. Take an initial set of stock prices, number of days to simulate, and a volatility factor\n    2. Generate daily price changes based on a normal distribution with mean 0 and standard deviation equal to the volatility\n    3. Ensure stock prices never go below 0\n    4. Return a list of dictionaries, each representing a day's closing prices for all stocks\n\n    Use closures to create a price adjustment function for each stock, and implement error handling for invalid inputs.\n\n    Example:\n    Input: {\"AAPL\": 150.0, \"GOOGL\": 2800.0, \"MSFT\": 300.0}, 5, 0.02\n    Output: [\n        {\"AAPL\": 151.2, \"GOOGL\": 2795.6, \"MSFT\": 301.8},\n        {\"AAPL\": 149.8, \"GOOGL\": 2810.3, \"MSFT\": 298.5},\n        ...\n    ]\n    \"\"\"\n", "entry_point": "simulate_stock_market", "solution": "    # Error handling for invalid inputs\n    if not isinstance(initial_prices, dict) or not all(isinstance(price, (int, float)) for price in initial_prices.values()):\n        raise ValueError(\"initial_prices must be a dictionary with numeric values\")\n    if not isinstance(days, int) or days <= 0:\n        raise ValueError(\"days must be a positive integer\")\n    if not isinstance(volatility, (int, float)) or volatility <= 0:\n        raise ValueError(\"volatility must be a positive number\")\n\n    def create_price_adjuster(initial_price):\n        def adjust_price():\n            nonlocal initial_price\n            change = random.gauss(0, volatility)\n            new_price = max(0, initial_price * (1 + change))\n            initial_price = new_price\n            return new_price\n        return adjust_price\n\n    price_adjusters = {stock: create_price_adjuster(price) for stock, price in initial_prices.items()}\n    \n    simulation_results = []\n    \n    for _ in range(days):\n        daily_prices = {stock: round(adjuster(), 2) for stock, adjuster in price_adjusters.items()}\n        simulation_results.append(daily_prices)\n    \n    return simulation_results\n", "test": "def check(candidate):\n    assert candidate({}, 3, 0.01) == [{}, {}, {}]\n", "language": "python"}
{"task_id": "revision1a_problem307", "prompt": "from typing import List\n\ndef find_equilibrium_index(arr: List[int]) -> int:\n    \"\"\"\n    Given an array of integers, find the equilibrium index of the array.\n    The equilibrium index is an index where the sum of all elements to the left of the index\n    is equal to the sum of all elements to the right of it.\n    If no such index exists, return -1.\n    If there are multiple equilibrium indices, return the leftmost one.\n\n    Example 1:\n    Input: [-7, 1, 5, 2, -4, 3, 0]\n    Output: 3\n\n    Example 2:\n    Input: [1, 2, 3, 4, 5, 6]\n    Output: -1\n\n    Example 3:\n    Input: [1, 2, 3, 4, 3, 2, 1]\n    Output: 3\n    \"\"\"\n", "entry_point": "find_equilibrium_index", "solution": "    total_sum = sum(arr)\n    left_sum = 0\n\n    for i in range(len(arr)):\n        right_sum = total_sum - left_sum - arr[i]\n        \n        if left_sum == right_sum:\n            return i\n        \n        left_sum += arr[i]\n    \n    return -1\n", "test": "def check(candidate):\n    assert candidate([-7, 1, 5, 2, -4, 3, 0]) == 3\n    assert candidate([0, 0, 0, 0, 0]) == 0\n    assert candidate([1, 2, 3, 4, 3, 2, 1]) == 3\n    assert candidate([1, 2, 3, 4, 5, 6]) == -1\n    assert candidate([-2, 5, 3, 1, 2, 6, -4, 2]) == 3\n    assert candidate([1]) == 0\n    assert candidate([-1, 3, -4, 5, 1, -6, 2, 1]) == 1\n    assert candidate([1, -1, 1, -1, 1, -1]) == -1\n    assert candidate([100, -50, -50, 100]) == 0\n    assert candidate([10, -10, 10, -10]) == -1\n", "language": "python"}
{"task_id": "revision1a_problem658", "prompt": "from typing import List, Dict\n\ndef optimize_warehouse_layout(items: List[str], item_frequencies: Dict[str, int], shelf_capacity: int) -> List[List[str]]:\n    \"\"\"\n    As a warehouse manager, I need to optimize the layout of our storage shelves to minimize \n    the time spent retrieving items. We have a list of items and their retrieval frequencies, \n    and we want to arrange them on shelves so that the most frequently accessed items are easiest to reach.\n    \n    The optimization should follow these rules:\n    1. Items should be placed on shelves from left to right, top to bottom.\n    2. More frequently accessed items should be placed on lower shelves and towards the left.\n    3. Each shelf has a maximum capacity of items it can hold.\n    4. If multiple items have the same frequency, maintain their original order.\n    \n    Input:\n    - items: A list of item names in their original order\n    - item_frequencies: A dictionary mapping item names to their retrieval frequencies\n    - shelf_capacity: The maximum number of items each shelf can hold\n    \n    Output: A list of lists, where each inner list represents a shelf and contains item names\n    \n    Example:\n    Input: \n    items = [\"A\", \"B\", \"C\", \"D\", \"E\", \"F\", \"G\", \"H\"]\n    item_frequencies = {\"A\": 3, \"B\": 5, \"C\": 2, \"D\": 7, \"E\": 1, \"F\": 4, \"G\": 6, \"H\": 2}\n    shelf_capacity = 3\n    \n    Output: [[\"D\", \"G\", \"B\"], [\"F\", \"A\", \"C\"], [\"H\", \"E\"]]\n    \n    Explanation:\n    The items are arranged on three shelves, with the most frequently accessed items (D, G, B) \n    on the first shelf, and the least frequently accessed items (H, E) on the last shelf.\n    \"\"\"\n", "entry_point": "optimize_warehouse_layout", "solution": "    # Sort items based on their frequencies in descending order\n    # If frequencies are the same, maintain the original order\n    sorted_items = sorted(items, key=lambda x: (-item_frequencies[x], items.index(x)))\n    \n    # Initialize the result list to store shelves\n    shelves = []\n    \n    # Iterate through the sorted items and place them on shelves\n    current_shelf = []\n    for item in sorted_items:\n        if len(current_shelf) < shelf_capacity:\n            current_shelf.append(item)\n        else:\n            shelves.append(current_shelf)\n            current_shelf = [item]\n    \n    # Add the last shelf if it's not empty\n    if current_shelf:\n        shelves.append(current_shelf)\n    \n    return shelves\n", "test": "def check(candidate):\n    assert candidate([\"A\", \"B\", \"C\", \"D\", \"E\"], {\"A\": 1, \"B\": 1, \"C\": 1, \"D\": 1, \"E\": 1}, 5) == [['A', 'B', 'C', 'D', 'E']]\n    assert candidate([\"Item1\"], {\"Item1\": 1}, 5) == [['Item1']]\n    assert candidate([\"A\", \"B\", \"C\", \"D\", \"E\", \"F\", \"G\", \"H\", \"I\", \"J\"], {\"A\": 5, \"B\": 4, \"C\": 3, \"D\": 2, \"E\": 1, \"F\": 10, \"G\": 9, \"H\": 8, \"I\": 7, \"J\": 6}, 4) == [['F', 'G', 'H', 'I'], ['J', 'A', 'B', 'C'], ['D', 'E']]\n    assert candidate([\"A\", \"B\", \"C\", \"D\", \"E\", \"F\"], {\"A\": 10, \"B\": 9, \"C\": 8, \"D\": 7, \"E\": 6, \"F\": 5}, 3) == [['A', 'B', 'C'], ['D', 'E', 'F']]\n    assert candidate([\"X\", \"Y\"], {\"X\": 100, \"Y\": 1}, 1) == [['X'], ['Y']]\n    assert candidate([\"Apple\", \"Banana\", \"Cherry\", \"Date\"], {\"Apple\": 5, \"Banana\": 3, \"Cherry\": 7, \"Date\": 2}, 4) == [['Cherry', 'Apple', 'Banana', 'Date']]\n    assert candidate([\"X\", \"Y\", \"Z\"], {\"X\": 100, \"Y\": 100, \"Z\": 100}, 1) == [['X'], ['Y'], ['Z']]\n    assert candidate([\"P1\", \"P2\", \"P3\", \"P4\", \"P5\"], {\"P1\": 1, \"P2\": 2, \"P3\": 3, \"P4\": 4, \"P5\": 5}, 2) == [['P5', 'P4'], ['P3', 'P2'], ['P1']]\n    assert candidate([\"A\", \"B\", \"C\"], {\"A\": 1, \"B\": 2, \"C\": 3}, 2) == [['C', 'B'], ['A']]\n    assert candidate([\"Item1\", \"Item2\", \"Item3\", \"Item4\"], {\"Item1\": 10, \"Item2\": 5, \"Item3\": 8, \"Item4\": 3}, 3) == [['Item1', 'Item3', 'Item2'], ['Item4']]\n", "language": "python"}
{"task_id": "revision1a_problem441", "prompt": "def calculate_savings(initial_amount: float, monthly_deposit: float, interest_rate: float, years: int) -> float:\n    \"\"\"\n    Calculate the total savings after a specified number of years, given an initial amount,\n    monthly deposits, and annual interest rate compounded monthly.\n\n    This function simulates a savings account where the user makes regular monthly deposits\n    and earns compound interest. It uses a loop to calculate the balance for each month\n    over the specified number of years.\n\n    Parameters:\n    initial_amount (float): The starting balance in the savings account\n    monthly_deposit (float): The amount deposited each month\n    interest_rate (float): The annual interest rate as a decimal (e.g., 0.05 for 5%)\n    years (int): The number of years to calculate savings for\n\n    Returns:\n    float: The total savings after the specified number of years\n\n    Example:\n    Input: 1000, 100, 0.05, 10\n    Output: 20486.68\n    \n    Input: 5000, 500, 0.03, 5\n    Output: 38343.50\n    \"\"\"\n", "entry_point": "calculate_savings", "solution": "    balance = initial_amount\n    monthly_interest_rate = interest_rate / 12\n    total_months = years * 12\n\n    for _ in range(total_months):\n        balance += monthly_deposit\n        interest = balance * monthly_interest_rate\n        balance += interest\n\n    return round(balance, 2)\n", "test": "def check(candidate):\n    assert candidate(750, 75, 0.045, 12) == 15624.77\n    assert candidate(500, 50, 0.06, 15) == 15840.69\n    assert candidate(3000, 300, 0.07, 8) == 43927.47\n    assert candidate(15000, 150, 0.025, 25) == 90561.82\n    assert candidate(5000, 500, 0.03, 5) == 38212.25\n    assert candidate(0, 100, 0.02, 1) == 1213.08\n    assert candidate(100000, 1000, 0.01, 30) == 554946.92\n    assert candidate(10000, 0, 0.04, 20) == 22225.82\n    assert candidate(1000, 100, 0.05, 10) == 17239.94\n    assert candidate(2000, 200, 0.08, 7) == 26066.99\n", "language": "python"}
{"task_id": "revision1a_problem361", "prompt": "from typing import List, Tuple\nimport heapq\n\ndef optimize_delivery_route(packages: List[Tuple[str, int, int]]) -> List[str]:\n    \"\"\"\n    A delivery company wants to optimize their route to minimize fuel consumption.\n    They need a function that takes a list of packages, each represented by a tuple\n    containing (destination, weight, priority), and returns the optimal order of delivery.\n\n    The optimization criteria are:\n    1. Higher priority packages should be delivered first\n    2. When priorities are equal, deliver heavier packages first to save fuel\n    3. If weight and priority are equal, deliver in the order they appear in the input list\n\n    Use a priority queue (heap) to solve this problem efficiently.\n\n    Example:\n    Input: [(\"A\", 10, 2), (\"B\", 5, 1), (\"C\", 15, 2), (\"D\", 8, 3)]\n    Output: [\"D\", \"C\", \"A\", \"B\"]\n\n    Input: [(\"X\", 7, 1), (\"Y\", 7, 1), (\"Z\", 5, 2)]\n    Output: [\"Z\", \"X\", \"Y\"]\n    \"\"\"\n", "entry_point": "optimize_delivery_route", "solution": "    # Create a priority queue (min heap)\n    pq = []\n    \n    # Enumerate the packages to keep track of their original order\n    for i, (destination, weight, priority) in enumerate(packages):\n        # Push packages to the priority queue\n        # Use negative values for priority and weight to create a max heap\n        # Include the original index to maintain order for equal priority and weight\n        heapq.heappush(pq, (-priority, -weight, i, destination))\n    \n    # Create the optimized route\n    optimized_route = []\n    \n    # Pop items from the priority queue to get the optimal order\n    while pq:\n        _, _, _, destination = heapq.heappop(pq)\n        optimized_route.append(destination)\n    \n    return optimized_route\n", "test": "def check(candidate):\n    assert candidate([]) == []\n    assert candidate([(\"A\", 10, 1), (\"B\", 10, 1), (\"C\", 10, 1), (\"D\", 10, 1)]) == ['A', 'B', 'C', 'D']\n    assert candidate([(\"A\", 100, 1), (\"B\", 1, 10)]) == ['B', 'A']\n    assert candidate([(\"A\", 10, 2), (\"B\", 5, 1), (\"C\", 15, 2), (\"D\", 8, 3)]) == ['D', 'C', 'A', 'B']\n    assert candidate([(\"A\", 1, 1), (\"B\", 2, 2), (\"C\", 3, 3), (\"D\", 4, 4), (\"E\", 5, 5)]) == ['E', 'D', 'C', 'B', 'A']\n    assert candidate([(\"X\", 7, 1), (\"Y\", 7, 1), (\"Z\", 5, 2)]) == ['Z', 'X', 'Y']\n    assert candidate([(\"A\", 1, 1)] * 10) == ['A', 'A', 'A', 'A', 'A', 'A', 'A', 'A', 'A', 'A']\n    assert candidate([(\"A\", 1, 5), (\"B\", 2, 4), (\"C\", 3, 3), (\"D\", 4, 2), (\"E\", 5, 1)]) == ['A', 'B', 'C', 'D', 'E']\n    assert candidate([(\"A\", i, i) for i in range(1, 11)]) == ['A', 'A', 'A', 'A', 'A', 'A', 'A', 'A', 'A', 'A']\n    assert candidate([(\"Single\", 1, 1)]) == ['Single']\n", "language": "python"}
{"task_id": "revision1a_problem13", "prompt": "from typing import List, Tuple\n\ndef dna_sequence_mutation(sequence: str, mutations: List[Tuple[int, str]]) -> str:\n    \"\"\"\n    I'm working on a genetic engineering project where I need to simulate DNA mutations.\n    Given a DNA sequence as a string and a list of mutations, apply the mutations to the sequence.\n    Each mutation is represented by a tuple containing the index to mutate and the new base pair.\n    The function should return the mutated DNA sequence.\n\n    Use a string builder approach for efficiency, as DNA sequences can be very long.\n\n    Example:\n    Input: \"ATCGTAGCTA\", [(0, \"G\"), (4, \"C\"), (7, \"T\")]\n    Output: \"GTCGCAGTTA\"\n\n    Input: \"AAATTTCCCGGG\", [(1, \"C\"), (5, \"G\"), (9, \"A\")]\n    Output: \"ACATGTCCCAGG\"\n    \"\"\"\n", "entry_point": "dna_sequence_mutation", "solution": "    # Convert the sequence to a list for efficient mutation\n    sequence_list = list(sequence)\n    \n    # Apply mutations\n    for index, new_base in mutations:\n        if 0 <= index < len(sequence_list):\n            sequence_list[index] = new_base\n    \n    # Convert the list back to a string\n    mutated_sequence = ''.join(sequence_list)\n    \n    return mutated_sequence\n", "test": "def check(candidate):\n    assert candidate(\"AAATTTCCCGGG\", [(1, \"C\"), (5, \"G\"), (9, \"A\")]) == 'ACATTGCCCAGG'\n    assert candidate(\"ATATATATATAT\", [(0, \"C\"), (3, \"G\"), (6, \"T\"), (9, \"A\")]) == 'CTAGATTTAAAT'\n    assert candidate(\"CGCGCG\", [(0, \"G\"), (2, \"T\"), (4, \"A\")]) == 'GGTGAG'\n    assert candidate(\"ATCGTAGCTA\", [(0, \"G\"), (4, \"C\"), (7, \"T\")]) == 'GTCGCAGTTA'\n    assert candidate(\"AAACCCGGGTTT\", [(0, \"G\"), (4, \"T\"), (8, \"C\")]) == 'GAACTCGGCTTT'\n    assert candidate(\"AAAAAA\", [(0, \"T\"), (2, \"C\"), (4, \"G\")]) == 'TACAGA'\n    assert candidate(\"TTTTT\", [(1, \"A\"), (3, \"C\")]) == 'TATCT'\n    assert candidate(\"ACGT\", [(0, \"T\"), (3, \"A\")]) == 'TCGA'\n    assert candidate(\"GCTA\", [(0, \"A\"), (1, \"T\"), (2, \"G\"), (3, \"C\")]) == 'ATGC'\n    assert candidate(\"GGGGGGGGGGG\", [(5, \"A\")]) == 'GGGGGAGGGGG'\n", "language": "python"}
{"task_id": "revision1a_problem436", "prompt": "import math\n\ndef calculate_book_discount(num_books: int, price_per_book: float) -> float:\n    \"\"\"\n    A bookstore is running a promotion where customers can receive discounts based on the number of books they purchase.\n    The discount percentage increases with the number of books bought, but there's a maximum discount cap.\n    \n    The discount structure is as follows:\n    - 1-4 books: No discount\n    - 5-9 books: 10% discount\n    - 10-14 books: 15% discount\n    - 15-19 books: 20% discount\n    - 20 or more books: 25% discount (maximum)\n\n    Calculate the total price after applying the discount.\n    \n    Use the math.floor() function to round down the discount to the nearest whole percentage.\n\n    Example 1: If a customer buys 7 books at $12 each, they get a 10% discount.\n    Total price: 7 * 12 * 0.9 = $75.60\n\n    Example 2: If a customer buys 25 books at $15 each, they get the maximum 25% discount.\n    Total price: 25 * 15 * 0.75 = $281.25\n\n    :param num_books: The number of books purchased\n    :param price_per_book: The price of each book\n    :return: The total price after applying the discount, rounded to 2 decimal places\n    \"\"\"\n", "entry_point": "calculate_book_discount", "solution": "    # Determine the discount percentage based on the number of books\n    if num_books < 5:\n        discount_percentage = 0\n    elif num_books < 10:\n        discount_percentage = 10\n    elif num_books < 15:\n        discount_percentage = 15\n    elif num_books < 20:\n        discount_percentage = 20\n    else:\n        discount_percentage = 25\n\n    # Round down the discount percentage to the nearest whole percentage\n    discount_percentage = math.floor(discount_percentage)\n\n    # Calculate the discount factor\n    discount_factor = 1 - (discount_percentage / 100)\n\n    # Calculate the total price after applying the discount\n    total_price = num_books * price_per_book * discount_factor\n\n    # Round the total price to 2 decimal places\n    return round(total_price, 2)\n", "test": "def check(candidate):\n    assert candidate(9, 12.99) == 105.22\n    assert candidate(50, 14.50) == 543.75\n    assert candidate(1, 10.00) == 10.0\n    assert candidate(15, 25.00) == 300.0\n    assert candidate(20, 30.00) == 450.0\n    assert candidate(4, 15.50) == 62.0\n    assert candidate(19, 9.95) == 151.24\n    assert candidate(5, 20.00) == 90.0\n    assert candidate(14, 19.99) == 237.88\n    assert candidate(10, 8.75) == 74.38\n", "language": "python"}
{"task_id": "revision1a_problem143", "prompt": "def encrypt_message(message: str, shift: int) -> str:\n    \"\"\"\n    You are a secret agent tasked with encrypting sensitive messages. Your mission is to implement a Caesar cipher encryption.\n\n    The Caesar cipher is a simple encryption technique where each letter in the plaintext is shifted a certain number of positions down the alphabet.\n\n    Write a function that takes a message (string) and a shift value (integer) as input, and returns the encrypted message.\n\n    The function should:\n    1. Preserve the case of the original message.\n    2. Wrap around the alphabet (e.g., 'z' shifted by 1 becomes 'a').\n    3. Leave non-alphabetic characters unchanged.\n\n    Use list comprehension to solve this problem efficiently.\n\n    Example:\n    Input: \"Hello, World!\", 3\n    Output: \"Khoor, Zruog!\"\n\n    Input: \"Secret Agent 007\", 7\n    Output: \"Zljyla Hnlua 007\"\n    \"\"\"\n", "entry_point": "encrypt_message", "solution": "    def shift_char(char: str, shift: int) -> str:\n        if char.isalpha():\n            ascii_offset = ord('A') if char.isupper() else ord('a')\n            return chr((ord(char) - ascii_offset + shift) % 26 + ascii_offset)\n        return char\n\n    return ''.join([shift_char(char, shift) for char in message])\n", "test": "def check(candidate):\n    assert candidate(\"!@#$%^&*()\", 8) == '!@#$%^&*()'\n    assert candidate(\"Secret Agent 007\", 7) == 'Zljyla Hnlua 007'\n    assert candidate(\"1234567890\", 4) == '1234567890'\n    assert candidate(\"\", 5) == ''\n    assert candidate(\"lowercase\", 2) == 'nqygtecug'\n    assert candidate(\"A\", 1) == 'B'\n    assert candidate(\"UPPERCASE\", 5) == 'ZUUJWHFXJ'\n    assert candidate(\"Mixed Case\", 10) == 'Wshon Mkco'\n    assert candidate(\"Hello, World!\", 3) == 'Khoor, Zruog!'\n    assert candidate(\"Z\", 1) == 'A'\n", "language": "python"}
{"task_id": "revision1a_problem562", "prompt": "from typing import List, Tuple\n\ndef network_topology(nodes: int, connections: List[Tuple[int, int]]) -> List[List[int]]:\n    \"\"\"\n    In computer networking, understanding the topology of a network is crucial for efficient routing and troubleshooting.\n    This function takes the number of nodes in a network and a list of connections between nodes, then constructs\n    and returns an adjacency matrix representing the network topology.\n\n    The function should create an adjacency matrix where a 1 indicates a connection between nodes and 0 indicates no connection.\n    The diagonal of the matrix should always be 0 as a node is not considered connected to itself.\n\n    Use graph theory concepts to implement this function.\n\n    Example:\n    Input: 4, [(0, 1), (0, 2), (1, 2), (2, 3)]\n    Output: [\n        [0, 1, 1, 0],\n        [1, 0, 1, 0],\n        [1, 1, 0, 1],\n        [0, 0, 1, 0]\n    ]\n\n    Input: 3, [(0, 1), (1, 2), (2, 0)]\n    Output: [\n        [0, 1, 1],\n        [1, 0, 1],\n        [1, 1, 0]\n    ]\n    \"\"\"\n", "entry_point": "network_topology", "solution": "    # Initialize the adjacency matrix with all zeros\n    adjacency_matrix = [[0 for _ in range(nodes)] for _ in range(nodes)]\n    \n    # Fill the adjacency matrix based on the connections\n    for node1, node2 in connections:\n        # Set the connection in both directions (undirected graph)\n        adjacency_matrix[node1][node2] = 1\n        adjacency_matrix[node2][node1] = 1\n    \n    return adjacency_matrix\n", "test": "def check(candidate):\n    assert candidate(5, [(0, 1), (0, 2), (0, 3), (0, 4)]) == [[0, 1, 1, 1, 1], [1, 0, 0, 0, 0], [1, 0, 0, 0, 0], [1, 0, 0, 0, 0], [1, 0, 0, 0, 0]]\n    assert candidate(4, [(0, 1), (1, 2), (2, 3), (3, 0)]) == [[0, 1, 0, 1], [1, 0, 1, 0], [0, 1, 0, 1], [1, 0, 1, 0]]\n    assert candidate(3, [(0, 1), (0, 2)]) == [[0, 1, 1], [1, 0, 0], [1, 0, 0]]\n    assert candidate(6, [(0, 1), (1, 2), (2, 3), (3, 4), (4, 5), (5, 0)]) == [[0, 1, 0, 0, 0, 1], [1, 0, 1, 0, 0, 0], [0, 1, 0, 1, 0, 0], [0, 0, 1, 0, 1, 0], [0, 0, 0, 1, 0, 1], [1, 0, 0, 0, 1, 0]]\n    assert candidate(4, []) == [[0, 0, 0, 0], [0, 0, 0, 0], [0, 0, 0, 0], [0, 0, 0, 0]]\n    assert candidate(1, []) == [[0]]\n    assert candidate(4, [(0, 1), (0, 2), (1, 2), (2, 3)]) == [[0, 1, 1, 0], [1, 0, 1, 0], [1, 1, 0, 1], [0, 0, 1, 0]]\n    assert candidate(3, [(0, 1), (1, 2), (2, 0)]) == [[0, 1, 1], [1, 0, 1], [1, 1, 0]]\n    assert candidate(5, [(0, 1), (1, 2), (2, 3), (3, 4), (4, 0)]) == [[0, 1, 0, 0, 1], [1, 0, 1, 0, 0], [0, 1, 0, 1, 0], [0, 0, 1, 0, 1], [1, 0, 0, 1, 0]]\n    assert candidate(2, [(0, 1)]) == [[0, 1], [1, 0]]\n", "language": "python"}
{"task_id": "revision1a_problem581", "prompt": "from typing import List\nimport re\n\ndef validate_password(password: str, rules: List[str]) -> bool:\n    \"\"\"\n    Check if a given password meets all specified rules.\n    In a cybersecurity context, we need to validate passwords against a set of rules.\n    Each rule is a regular expression that the password must match.\n\n    Take input from the user for a password and a list of rule patterns.\n    Return True if the password satisfies all rules, False otherwise.\n\n    You should use regular expressions to check each rule.\n\n    Example:\n    Input: \"P@ssw0rd123\", [\"^.{8,}$\", \".*[A-Z].*\", \".*[a-z].*\", \".*[0-9].*\", \".*[!@#$%^&*].*\"]\n    Output: True\n    Input: \"weakpass\", [\"^.{8,}$\", \".*[A-Z].*\", \".*[0-9].*\"]\n    Output: False\n    \"\"\"\n", "entry_point": "validate_password", "solution": "    for rule in rules:\n        if not re.match(rule, password):\n            return False\n    return True\n", "test": "def check(candidate):\n    assert candidate(\"12345678\", [\"^.{8,}$\"]) == True\n    assert candidate(\"NoSpecialChar123\", [\"^.{8,}$\", \".*[A-Z].*\", \".*[a-z].*\", \".*[0-9].*\"]) == True\n    assert candidate(\"weakpass\", [\"^.{8,}$\", \".*[A-Z].*\", \".*[0-9].*\"]) == False\n    assert candidate(\"1234567890\", [\".*[a-z].*\"]) == False\n    assert candidate(\"alllowercase\", [\".*[a-z].*\"]) == True\n    assert candidate(\"LongPasswordWithoutNumber!\", [\"^.{8,}$\", \".*[A-Z].*\", \".*[a-z].*\", \".*[0-9].*\", \".*[!@#$%^&*].*\"]) == False\n    assert candidate(\"ShortPW1!\", [\"^.{10,}$\", \".*[A-Z].*\", \".*[a-z].*\", \".*[0-9].*\", \".*[!@#$%^&*].*\"]) == False\n    assert candidate(\"!@#$%^&*\", [\".*[!@#$%^&*].*\"]) == True\n    assert candidate(\"P@ssw0rd123\", [\"^.{8,}$\", \".*[A-Z].*\", \".*[a-z].*\", \".*[0-9].*\", \".*[!@#$%^&*].*\"]) == True\n    assert candidate(\"ALLUPPERCASE\", [\".*[A-Z].*\"]) == True\n", "language": "python"}
{"task_id": "revision1a_problem736", "prompt": "from collections import deque\nfrom typing import List\n\ndef maze_escape(n: int, m: int, maze: List[List[str]]) -> int:\n    \"\"\"\n    In a virtual reality game, I'm trapped in an n x m maze filled with obstacles and treasures.\n    My goal is to find the shortest path from the top-left corner to the bottom-right corner,\n    collecting all treasures along the way. The maze is represented by a 2D grid where:\n    'S' is the start, 'E' is the exit, '#' is an obstacle, '.' is an empty cell, and 'T' is a treasure.\n    I can move up, down, left, or right, but cannot move diagonally or through obstacles.\n    Return the minimum number of steps required to collect all treasures and reach the exit.\n    If it's impossible to collect all treasures and reach the exit, return -1.\n\n    Take input from the user for the dimensions n and m, followed by the maze layout as a list of strings.\n\n    Example 1:\n    Input: 3, 4, ['S..T', '.#T.', '..TE']\n    Output: 8\n\n    Example 2:\n    Input: 4, 4, ['S.#T', '.#..', '..#.', 'T..E']\n    Output: -1\n    \"\"\"\n", "entry_point": "maze_escape", "solution": "    def bfs(start, goal, treasures):\n        queue = deque([(start[0], start[1], 0, frozenset())])\n        visited = set()\n        \n        while queue:\n            x, y, steps, collected = queue.popleft()\n            \n            if (x, y) == goal and collected == treasures:\n                return steps\n            \n            if (x, y, collected) in visited:\n                continue\n            \n            visited.add((x, y, collected))\n            \n            for dx, dy in [(0, 1), (1, 0), (0, -1), (-1, 0)]:\n                nx, ny = x + dx, y + dy\n                if 0 <= nx < n and 0 <= ny < m and maze[nx][ny] != '#':\n                    new_collected = collected\n                    if maze[nx][ny] == 'T':\n                        new_collected = frozenset(collected | {(nx, ny)})\n                    queue.append((nx, ny, steps + 1, new_collected))\n        \n        return -1\n\n    start = None\n    end = None\n    treasures = set()\n\n    for i in range(n):\n        for j in range(m):\n            if maze[i][j] == 'S':\n                start = (i, j)\n            elif maze[i][j] == 'E':\n                end = (i, j)\n            elif maze[i][j] == 'T':\n                treasures.add((i, j))\n\n    if not start or not end:\n        return -1\n\n    return bfs(start, end, frozenset(treasures))\n", "test": "def check(candidate):\n    assert candidate(4, 4, ['S...', '.##.', '.T#.', '...E']) == 6\n    assert candidate(3, 3, ['S..', '.T.', '..E']) == 4\n    assert candidate(4, 4, ['S##E', '#TT#', '#..#', '#..#']) == -1\n    assert candidate(5, 1, ['S', 'T', 'T', 'E', '.']) == 3\n    assert candidate(3, 5, ['S...E', '#####', 'TT...']) == -1\n    assert candidate(4, 4, ['S.#T', '.#..', '..#.', 'T..E']) == 12\n    assert candidate(1, 5, ['STTE.']) == 3\n    assert candidate(3, 3, ['S#E', '#T#', '#T#']) == -1\n    assert candidate(2, 2, ['SE', 'TT']) == 3\n", "language": "python"}
{"task_id": "revision1a_problem622", "prompt": "import math\nfrom typing import Dict, List, Tuple\n\ndef optimize_delivery_route(locations: List[Tuple[float, float]], start: Tuple[float, float]) -> List[int]:\n    \"\"\"\n    A delivery company wants to optimize their route to minimize travel distance.\n    \n    This function implements a simple version of the Traveling Salesman Problem using a greedy approach.\n    It takes a list of location coordinates (latitude, longitude) and a starting point,\n    and returns the optimal order to visit all locations.\n\n    Parameters:\n    locations (List[Tuple[float, float]]): List of (latitude, longitude) coordinates for each delivery location\n    start (Tuple[float, float]): The starting point (latitude, longitude) for the delivery route\n\n    Returns:\n    List[int]: The optimal order of indices to visit the locations\n\n    Example:\n    Input: \n    locations = [(40.7128, -74.0060), (34.0522, -118.2437), (41.8781, -87.6298), (29.7604, -95.3698)]\n    start = (38.9072, -77.0369)\n    Output: [2, 0, 3, 1]\n\n    This output suggests visiting Chicago, then New York, then Houston, and finally Los Angeles.\n    \"\"\"\n", "entry_point": "optimize_delivery_route", "solution": "    def haversine_distance(coord1: Tuple[float, float], coord2: Tuple[float, float]) -> float:\n        lat1, lon1 = math.radians(coord1[0]), math.radians(coord1[1])\n        lat2, lon2 = math.radians(coord2[0]), math.radians(coord2[1])\n        \n        dlat = lat2 - lat1\n        dlon = lon2 - lon1\n        \n        a = math.sin(dlat/2)**2 + math.cos(lat1) * math.cos(lat2) * math.sin(dlon/2)**2\n        c = 2 * math.asin(math.sqrt(a))\n        \n        # Radius of Earth in kilometers\n        r = 6371\n        \n        return c * r\n\n    unvisited = set(range(len(locations)))\n    route = []\n    current = start\n\n    while unvisited:\n        next_location = min(unvisited, key=lambda x: haversine_distance(current, locations[x]))\n        route.append(next_location)\n        unvisited.remove(next_location)\n        current = locations[next_location]\n\n    return route\n", "test": "def check(candidate):\n    assert candidate([], (0, 0)) == []\n    assert candidate([(0, 0)] * 5, (1, 1)) == [0, 1, 2, 3, 4]\n    assert candidate([(1, 1), (2, 2)], (0, 0)) == [0, 1]\n    assert candidate([(51.5074, -0.1278), (48.8566, 2.3522), (41.9028, 12.4964), (52.5200, 13.4050)], (50.0755, 14.4378)) == [3, 1, 0, 2]\n    assert candidate([(90, 0), (-90, 0), (0, 180), (0, -180)], (0, 0)) == [0, 2, 3, 1]\n    assert candidate([(0, 0), (1, 1), (2, 2), (3, 3)], (0, 0)) == [0, 1, 2, 3]\n    assert candidate([(40.7128, -74.0060), (34.0522, -118.2437), (41.8781, -87.6298), (29.7604, -95.3698)], (38.9072, -77.0369)) == [0, 2, 3, 1]\n    assert candidate([(i, i) for i in range(20)], (10, 10)) == [10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 9, 8, 7, 6, 5, 4, 3, 2, 1, 0]\n    assert candidate([(0, 0), (0, 1), (1, 0), (1, 1)], (0.5, 0.5)) == [2, 3, 1, 0]\n    assert candidate([(40.7128, -74.0060)], (40.7128, -74.0060)) == [0]\n", "language": "python"}
{"task_id": "revision1a_problem194", "prompt": "from typing import List\n\ndef optimize_inventory(current_stock: List[int], demand: List[int], max_capacity: int) -> List[int]:\n    \"\"\"\n    A warehouse manager needs to optimize inventory levels for multiple products.\n    Write a program to determine the optimal reorder quantities for each product.\n    \n    Take input from the user for:\n    - current_stock: a list of current stock levels for each product\n    - demand: a list of expected demand for each product\n    - max_capacity: the maximum total inventory capacity of the warehouse\n    \n    Return a list of reorder quantities for each product that maximizes warehouse utilization\n    while meeting demand and not exceeding max_capacity.\n    \n    Use dynamic programming to solve this optimization problem.\n    \n    Example:\n    Input: [10, 20, 30], [15, 25, 35], 100\n    Output: [5, 5, 5]\n    \n    Input: [50, 80, 20], [100, 50, 30], 250\n    Output: [50, 0, 10]\n    \"\"\"\n", "entry_point": "optimize_inventory", "solution": "    n = len(current_stock)\n    total_current_stock = sum(current_stock)\n    remaining_capacity = max_capacity - total_current_stock\n\n    # Initialize the DP table\n    dp = [[0] * (remaining_capacity + 1) for _ in range(n + 1)]\n\n    # Fill the DP table\n    for i in range(1, n + 1):\n        for j in range(remaining_capacity + 1):\n            max_reorder = min(j, max(0, demand[i-1] - current_stock[i-1]))\n            dp[i][j] = max(dp[i-1][j], dp[i-1][j-max_reorder] + max_reorder)\n\n    # Backtrack to find the optimal reorder quantities\n    reorder = [0] * n\n    j = remaining_capacity\n    for i in range(n, 0, -1):\n        max_reorder = min(j, max(0, demand[i-1] - current_stock[i-1]))\n        if dp[i][j] != dp[i-1][j]:\n            reorder[i-1] = max_reorder\n            j -= max_reorder\n\n    return reorder\n", "test": "def check(candidate):\n    assert candidate([50, 80, 20], [100, 50, 30], 250) == [50, 0, 10]\n    assert candidate([10, 20], [30, 40], 60) == [10, 20]\n    assert candidate([5, 10, 15], [20, 25, 30], 75) == [15, 15, 15]\n    assert candidate([0, 0, 0], [10, 10, 10], 30) == [10, 10, 10]\n    assert candidate([50], [100], 100) == [50]\n    assert candidate([100, 100, 100], [50, 50, 50], 300) == [0, 0, 0]\n    assert candidate([5, 5, 5, 5, 5], [10, 10, 10, 10, 10], 50) == [5, 5, 5, 5, 5]\n    assert candidate([1, 1, 1], [1000, 1000, 1000], 3000) == [999, 999, 999]\n    assert candidate([100, 200, 300, 400], [150, 250, 350, 450], 1500) == [50, 50, 50, 50]\n    assert candidate([10, 20, 30], [15, 25, 35], 100) == [5, 5, 5]\n", "language": "python"}
{"task_id": "revision1a_problem174", "prompt": "def calculate_tip(bill_amount: float, service_quality: str) -> float:\n    \"\"\"\n    As a restaurant owner, I need to help my waitstaff calculate appropriate tips based on the bill amount and service quality.\n    Write a function that takes the bill amount and service quality as input and returns the recommended tip amount.\n    \n    Service quality can be \"poor\", \"average\", \"good\", or \"excellent\".\n    \n    Tip percentages:\n    - Poor: 10%\n    - Average: 15%\n    - Good: 18%\n    - Excellent: 20%\n    \n    Example:\n    Input: bill_amount = 100.00, service_quality = \"good\"\n    Output: 18.00\n    \n    Example:\n    Input: bill_amount = 75.50, service_quality = \"poor\"\n    Output: 7.55\n    \"\"\"\n", "entry_point": "calculate_tip", "solution": "    tip_percentages = {\n        \"poor\": 0.10,\n        \"average\": 0.15,\n        \"good\": 0.18,\n        \"excellent\": 0.20\n    }\n    \n    service_quality = service_quality.lower()\n    \n    if service_quality not in tip_percentages:\n        raise ValueError(\"Invalid service quality. Please choose from 'poor', 'average', 'good', or 'excellent'.\")\n    \n    tip_percentage = tip_percentages[service_quality]\n    tip_amount = bill_amount * tip_percentage\n    \n    return round(tip_amount, 2)\n", "test": "def check(candidate):\n    assert candidate(50.00, \"excellent\") == 10.0\n    assert candidate(150.50, \"good\") == 27.09\n    assert candidate(0.00, \"good\") == 0.0\n    assert candidate(100.00, \"good\") == 18.0\n    assert candidate(25.75, \"excellent\") == 5.15\n    assert candidate(200.00, \"average\") == 30.0\n    assert candidate(99.99, \"average\") == 15.0\n    assert candidate(75.50, \"poor\") == 7.55\n    assert candidate(1000.00, \"poor\") == 100.0\n    assert candidate(10.00, \"poor\") == 1.0\n", "language": "python"}
{"task_id": "revision1a_problem382", "prompt": "from typing import List, Dict, Tuple\nimport heapq\n\ndef optimize_network_latency(servers: List[str], connections: List[Tuple[str, str, int]], start: str) -> Dict[str, int]:\n    \"\"\"\n    A network engineer needs to optimize the latency between servers in a data center.\n    Given a list of servers, their connections (with latencies), and a starting server,\n    calculate the minimum latency from the start server to all other servers.\n\n    Implement the function using Dijkstra's algorithm with a priority queue (heap) for efficiency.\n\n    Parameters:\n    servers: List of server names\n    connections: List of tuples (server1, server2, latency) representing connections between servers\n    start: Name of the starting server\n\n    Returns:\n    A dictionary with server names as keys and minimum latencies as values\n\n    Example:\n    Input: \n    servers = [\"A\", \"B\", \"C\", \"D\"]\n    connections = [(\"A\", \"B\", 5), (\"B\", \"C\", 2), (\"A\", \"C\", 10), (\"C\", \"D\", 1)]\n    start = \"A\"\n\n    Output: {\"A\": 0, \"B\": 5, \"C\": 7, \"D\": 8}\n    \"\"\"\n", "entry_point": "optimize_network_latency", "solution": "    # Create adjacency list representation of the network\n    graph = {server: {} for server in servers}\n    for server1, server2, latency in connections:\n        graph[server1][server2] = latency\n        graph[server2][server1] = latency  # Assuming bidirectional connections\n\n    # Initialize distances and priority queue\n    distances = {server: float('inf') for server in servers}\n    distances[start] = 0\n    pq = [(0, start)]\n\n    while pq:\n        current_distance, current_server = heapq.heappop(pq)\n\n        # If we've found a longer path to the current server, skip it\n        if current_distance > distances[current_server]:\n            continue\n\n        # Check all neighboring servers\n        for neighbor, latency in graph[current_server].items():\n            distance = current_distance + latency\n\n            # If we've found a shorter path, update the distance\n            if distance < distances[neighbor]:\n                distances[neighbor] = distance\n                heapq.heappush(pq, (distance, neighbor))\n\n    return distances\n", "test": "def check(candidate):\n    assert candidate([\"A\", \"B\", \"C\", \"D\"], [(\"A\", \"B\", 5), (\"B\", \"C\", 2), (\"A\", \"C\", 10), (\"C\", \"D\", 1)], \"A\") == {'A': 0, 'B': 5, 'C': 7, 'D': 8}\n    assert candidate([\"A\", \"B\"], [(\"A\", \"B\", 100)], \"A\") == {'A': 0, 'B': 100}\n    assert candidate([\"A\", \"B\", \"C\", \"D\", \"E\"], [(\"A\", \"B\", 1), (\"B\", \"C\", 2), (\"C\", \"D\", 3), (\"D\", \"E\", 4), (\"A\", \"E\", 20)], \"A\") == {'A': 0, 'B': 1, 'C': 3, 'D': 6, 'E': 10}\n    assert candidate([\"X\", \"Y\", \"Z\", \"W\"], [(\"X\", \"Y\", 5), (\"Y\", \"Z\", 5), (\"Z\", \"W\", 5), (\"X\", \"W\", 25)], \"X\") == {'X': 0, 'Y': 5, 'Z': 10, 'W': 15}\n    assert candidate([\"Node1\", \"Node2\", \"Node3\"], [(\"Node1\", \"Node2\", 5), (\"Node2\", \"Node3\", 5), (\"Node1\", \"Node3\", 15)], \"Node1\") == {'Node1': 0, 'Node2': 5, 'Node3': 10}\n    assert candidate([\"S1\", \"S2\", \"S3\", \"S4\"], [(\"S1\", \"S2\", 10), (\"S2\", \"S3\", 10), (\"S3\", \"S4\", 10), (\"S1\", \"S4\", 5)], \"S1\") == {'S1': 0, 'S2': 10, 'S3': 15, 'S4': 5}\n    assert candidate([\"A\", \"B\", \"C\", \"D\", \"E\", \"F\"], [(\"A\", \"B\", 1), (\"B\", \"C\", 1), (\"C\", \"D\", 1), (\"D\", \"E\", 1), (\"E\", \"F\", 1), (\"A\", \"F\", 10)], \"A\") == {'A': 0, 'B': 1, 'C': 2, 'D': 3, 'E': 4, 'F': 5}\n    assert candidate([\"Server1\", \"Server2\", \"Server3\", \"Server4\"], [(\"Server1\", \"Server2\", 1), (\"Server2\", \"Server3\", 1), (\"Server3\", \"Server4\", 1), (\"Server1\", \"Server4\", 10)], \"Server1\") == {'Server1': 0, 'Server2': 1, 'Server3': 2, 'Server4': 3}\n    assert candidate([\"S1\", \"S2\", \"S3\", \"S4\", \"S5\"], [(\"S1\", \"S2\", 10), (\"S2\", \"S3\", 5), (\"S3\", \"S4\", 7), (\"S4\", \"S5\", 3), (\"S1\", \"S5\", 30)], \"S1\") == {'S1': 0, 'S2': 10, 'S3': 15, 'S4': 22, 'S5': 25}\n    assert candidate([\"X\", \"Y\", \"Z\"], [(\"X\", \"Y\", 1), (\"Y\", \"Z\", 1)], \"X\") == {'X': 0, 'Y': 1, 'Z': 2}\n", "language": "python"}
{"task_id": "revision1a_problem195", "prompt": "def decode_alien_message(message: str) -> str:\n    \"\"\"\n    I intercepted an alien message, but it's encoded! The aliens use a simple substitution cipher\n    where each letter is replaced by another letter consistently throughout the message.\n    However, spaces and punctuation remain unchanged. I need to decode this message to understand\n    what the aliens are saying.\n    \n    Take the encoded message as input from the user and return the decoded message.\n    Use frequency analysis and a dictionary to map the most common letters in English to the most common characters in the encoded message.\n    \n    Example:\n    Input: \"URYYB JBEYQ! UBJ NER LBH?\"\n    Output: \"HELLO WORLD! HOW ARE YOU?\"\n    \n    Input: \"GUR DHVPX OEBJA SBK WHZCF BIRE GUR YNML QBT.\"\n    Output: \"THE QUICK BROWN FOX JUMPS OVER THE LAZY DOG.\"\n    \"\"\"\n", "entry_point": "decode_alien_message", "solution": "    import string\n    from collections import Counter\n\n    # Most common letters in English (in order of frequency)\n    common_letters = 'ETAOINSHRDLCUMWFGYPBVKJXQZ'\n\n    # Count the frequency of each character in the encoded message\n    char_freq = Counter(char.upper() for char in message if char.isalpha())\n\n    # Sort the characters by frequency (most common first)\n    sorted_chars = sorted(char_freq, key=char_freq.get, reverse=True)\n\n    # Create a mapping dictionary\n    char_map = {}\n    for i, char in enumerate(sorted_chars):\n        if i < len(common_letters):\n            char_map[char] = common_letters[i]\n\n    # Decode the message\n    decoded_message = ''\n    for char in message:\n        if char.isalpha():\n            decoded_char = char_map.get(char.upper(), char.upper())\n            decoded_message += decoded_char if char.isupper() else decoded_char.lower()\n        else:\n            decoded_message += char\n\n    return decoded_message\n", "test": "def check(candidate):\n    assert candidate(\"JR PBZR VA CRNPR.\") == 'AE TOIE NS HERTE.'\n    assert candidate(\"GUR DHVPX OEBJA SBK WHZCF BIRE GUR YNML QBT.\") == 'AOT SIHRD LNECU MEW FIGYP EBTN AOT VKJX QEZ.'\n    assert candidate(\"PBASHFRQ? LBH FUBHYQ OR!\") == 'NESHTAOI? RET ADETLI CO!'\n    assert candidate(\"GNXR ZR GB LBHE YRNQRE.\") == 'TANE SE TO HORI DEALEI.'\n    assert candidate(\"PBQR OERNXVAT VF SHA!\") == 'OINE SHERDTAL TC UMA!'\n    assert candidate(\"NYVRA VAINFVBA VF VZZVARAG!\") == 'ASEOT ETHAIERT EI ENNETOTD!'\n    assert candidate(\"FCNPR: GUR SVANY SEBAGVRE.\") == 'HRTDE: ALE OINTC OSUNAIES.'\n    assert candidate(\"GUVF VF N GRFG ZRFFNTR.\") == 'TNOE OE I TAET SAEEIHA.'\n    assert candidate(\"URYYB JBEYQ! UBJ NER LBH?\") == 'AOTTE IENTS! AEI HNO RED?'\n    assert candidate(\"RNEGU VF N ORNHGVSHY CYNARG.\") == 'TESAH OR E DTEIAOLIN CNEUTA.'\n", "language": "python"}
{"task_id": "revision1a_problem659", "prompt": "import itertools\nfrom typing import List\n\ndef optimize_delivery_route(n: int, distances: List[List[int]]) -> List[int]:\n    \"\"\"\n    As a logistics manager, you need to optimize the delivery route for a fleet of trucks.\n    Given a number of cities and a matrix of distances between them, find the shortest path\n    that visits each city exactly once and returns to the starting city (Traveling Salesman Problem).\n\n    Take input from the user for the number of cities and the distance matrix,\n    and return the optimal route as a list of city indices.\n\n    Use dynamic programming to solve this NP-hard problem efficiently for small to medium-sized inputs.\n\n    Example:\n    Input: 4, [[0,10,15,20],[10,0,35,25],[15,35,0,30],[20,25,30,0]]\n    Output: [0, 1, 3, 2, 0]\n\n    Input: 3, [[0,5,10],[5,0,8],[10,8,0]]\n    Output: [0, 1, 2, 0]\n    \"\"\"\n", "entry_point": "optimize_delivery_route", "solution": "    def tsp_dp(mask, pos):\n        if mask == (1 << n) - 1:\n            return distances[pos][0], [pos, 0]\n        \n        if (mask, pos) in memo:\n            return memo[(mask, pos)]\n        \n        min_cost = float('inf')\n        min_path = []\n        \n        for next_city in range(n):\n            if (mask >> next_city) & 1 == 0:\n                new_mask = mask | (1 << next_city)\n                cost, path = tsp_dp(new_mask, next_city)\n                total_cost = distances[pos][next_city] + cost\n                \n                if total_cost < min_cost:\n                    min_cost = total_cost\n                    min_path = [pos] + path\n        \n        memo[(mask, pos)] = (min_cost, min_path)\n        return min_cost, min_path\n\n    memo = {}\n    _, optimal_path = tsp_dp(1, 0)\n    return [0] + optimal_path\n\n", "test": "def check(candidate):\n    assert candidate(4, [[0,1,1,1],[1,0,1,1],[1,1,0,1],[1,1,1,0]]) == [0, 0, 1, 2, 3, 0]\n    assert candidate(3, [[0,5,10],[5,0,8],[10,8,0]]) == [0, 0, 1, 2, 0]\n    assert candidate(6, [[0,10,20,30,40,50],[10,0,15,25,35,45],[20,15,0,18,28,38],[30,25,18,0,22,32],[40,35,28,22,0,26],[50,45,38,32,26,0]]) == [0, 0, 1, 2, 3, 4, 5, 0]\n    assert candidate(3, [[0,100,200],[100,0,300],[200,300,0]]) == [0, 0, 1, 2, 0]\n    assert candidate(4, [[0,10,15,20],[10,0,35,25],[15,35,0,30],[20,25,30,0]]) == [0, 0, 1, 3, 2, 0]\n    assert candidate(2, [[0,100],[100,0]]) == [0, 0, 1, 0]\n    assert candidate(4, [[0,1,2,3],[1,0,4,5],[2,4,0,6],[3,5,6,0]]) == [0, 0, 1, 2, 3, 0]\n    assert candidate(5, [[0,10,20,30,40],[10,0,50,60,70],[20,50,0,80,90],[30,60,80,0,100],[40,70,90,100,0]]) == [0, 0, 2, 1, 3, 4, 0]\n    assert candidate(3, [[0,1,1],[1,0,1],[1,1,0]]) == [0, 0, 1, 2, 0]\n    assert candidate(5, [[0,1,2,3,4],[1,0,5,6,7],[2,5,0,8,9],[3,6,8,0,10],[4,7,9,10,0]]) == [0, 0, 2, 1, 3, 4, 0]\n", "language": "python"}
{"task_id": "revision1a_problem316", "prompt": "from typing import List, Tuple\n\ndef recipe_optimizer(ingredients: List[str], quantities: List[float], servings: int) -> Tuple[List[str], List[float]]:\n    \"\"\"\n    You are a chef planning a large dinner party. You have a recipe that serves 4 people, but you need to adjust it for a different number of guests.\n\n    Your task is to implement a function that takes:\n    1. A list of ingredient names\n    2. A list of corresponding quantities (in grams or milliliters)\n    3. The number of servings you want to make\n\n    The function should return:\n    1. The list of ingredients (unchanged)\n    2. A new list of adjusted quantities for the desired number of servings\n\n    Round all quantities to one decimal place.\n\n    Example:\n    Input: \n    ingredients = [\"flour\", \"sugar\", \"eggs\", \"milk\"]\n    quantities = [200, 100, 2, 150]\n    servings = 6\n\n    Output:\n    ([\"flour\", \"sugar\", \"eggs\", \"milk\"], [300.0, 150.0, 3.0, 225.0])\n\n    Note: The original recipe is for 4 servings, so we multiply all quantities by (6/4) = 1.5\n    \"\"\"\n", "entry_point": "recipe_optimizer", "solution": "    # Calculate the scaling factor\n    scaling_factor = servings / 4\n\n    # Adjust quantities and round to one decimal place\n    adjusted_quantities = [round(quantity * scaling_factor, 1) for quantity in quantities]\n\n    # Return the original ingredients list and the adjusted quantities\n    return (ingredients, adjusted_quantities)\n", "test": "def check(candidate):\n    assert candidate([\"butter\", \"sugar\", \"eggs\", \"flour\"], [100, 150, 3, 200], 12) == (['butter', 'sugar', 'eggs', 'flour'], [300.0, 450.0, 9.0, 600.0])\n    assert candidate([\"chocolate\", \"cream\", \"sugar\"], [200, 150, 100], 16) == (['chocolate', 'cream', 'sugar'], [800.0, 600.0, 400.0])\n    assert candidate([\"beef\", \"potatoes\", \"carrots\", \"onions\"], [600, 400, 200, 100], 10) == (['beef', 'potatoes', 'carrots', 'onions'], [1500.0, 1000.0, 500.0, 250.0])\n    assert candidate([\"chicken\", \"rice\", \"vegetables\"], [500, 300, 200], 8) == (['chicken', 'rice', 'vegetables'], [1000.0, 600.0, 400.0])\n    assert candidate([\"fish\", \"lemon\", \"olive oil\", \"garlic\"], [300, 50, 30, 10], 1) == (['fish', 'lemon', 'olive oil', 'garlic'], [75.0, 12.5, 7.5, 2.5])\n    assert candidate([\"oats\", \"milk\", \"banana\", \"honey\"], [50, 200, 100, 20], 3) == (['oats', 'milk', 'banana', 'honey'], [37.5, 150.0, 75.0, 15.0])\n    assert candidate([\"lettuce\", \"tomatoes\", \"cucumber\", \"dressing\"], [100, 50, 50, 30], 5) == (['lettuce', 'tomatoes', 'cucumber', 'dressing'], [125.0, 62.5, 62.5, 37.5])\n    assert candidate([\"flour\", \"sugar\", \"eggs\", \"milk\"], [200, 100, 2, 150], 6) == (['flour', 'sugar', 'eggs', 'milk'], [300.0, 150.0, 3.0, 225.0])\n    assert candidate([\"pasta\", \"tomato sauce\", \"cheese\"], [400, 300, 100], 2) == (['pasta', 'tomato sauce', 'cheese'], [200.0, 150.0, 50.0])\n    assert candidate([\"bread\", \"cheese\", \"ham\", \"butter\"], [200, 100, 100, 50], 7) == (['bread', 'cheese', 'ham', 'butter'], [350.0, 175.0, 175.0, 87.5])\n", "language": "python"}
{"task_id": "revision1a_problem151", "prompt": "from typing import List\n\ndef optimize_warehouse(items: List[int], max_weight: int) -> int:\n    \"\"\"\n    A warehouse manager needs to optimize the storage of boxes on shelves.\n    Each box has a weight, and each shelf has a maximum weight capacity.\n    The goal is to maximize the number of boxes that can be stored on a single shelf.\n    \n    Given a list of box weights and the maximum weight capacity of a shelf,\n    return the maximum number of boxes that can be placed on the shelf without exceeding the weight limit.\n    \n    The function should use dynamic programming to solve this problem efficiently.\n    \n    Example:\n    Input: [2, 3, 4, 5], 10\n    Output: 3\n    Input: [1, 2, 4, 8], 15\n    Output: 4\n    \"\"\"\n", "entry_point": "optimize_warehouse", "solution": "    n = len(items)\n    \n    # Create a 2D DP table\n    dp = [[0] * (max_weight + 1) for _ in range(n + 1)]\n    \n    # Fill the DP table\n    for i in range(1, n + 1):\n        for w in range(max_weight + 1):\n            if items[i-1] <= w:\n                # We have two choices: include the current item or exclude it\n                dp[i][w] = max(dp[i-1][w], dp[i-1][w-items[i-1]] + 1)\n            else:\n                # If the current item's weight is greater than the current weight capacity,\n                # we can't include it, so we just copy the previous solution\n                dp[i][w] = dp[i-1][w]\n    \n    # Return the maximum number of boxes that can be stored\n    return dp[n][max_weight]\n", "test": "def check(candidate):\n    assert candidate([1, 2, 3, 4, 5], 15) == 5\n    assert candidate([1, 2, 3, 4, 5, 6, 7, 8, 9, 10], 55) == 10\n    assert candidate([3, 3, 3, 3], 11) == 3\n    assert candidate([5, 5, 5, 5, 5], 25) == 5\n    assert candidate([2, 4, 6, 8, 10], 20) == 4\n    assert candidate([100], 100) == 1\n    assert candidate([50, 50, 50], 100) == 2\n    assert candidate([10, 20, 30], 50) == 2\n    assert candidate([1, 3, 5, 7, 9], 10) == 3\n    assert candidate([1, 1, 1, 1, 1, 1, 1, 1, 1, 1], 5) == 5\n", "language": "python"}
{"task_id": "revision1a_problem473", "prompt": "import re\nimport string\nfrom typing import List, Dict\n\ndef word_frequency_analyzer(text: str) -> Dict[str, int]:\n    \"\"\"\n    As a data analyst, I need to analyze the frequency of words in a given text.\n    Write a function that takes a string of text as input and returns a dictionary\n    with words as keys and their frequencies as values. The function should:\n    1. Remove all punctuation and convert the text to lowercase.\n    2. Split the text into individual words.\n    3. Count the frequency of each word.\n    4. Return a dictionary with words and their frequencies.\n    5. Ignore common words (stop words) like 'the', 'a', 'an', 'in', etc.\n\n    Example:\n    Input: \"The quick brown fox jumps over the lazy dog. The dog barks.\"\n    Output: {'quick': 1, 'brown': 1, 'fox': 1, 'jumps': 1, 'over': 1, 'lazy': 1, 'dog': 2, 'barks': 1}\n\n    Example:\n    Input: \"To be or not to be, that is the question.\"\n    Output: {'question': 1}\n    \"\"\"\n", "entry_point": "word_frequency_analyzer", "solution": "    # Define stop words to ignore\n    stop_words = set(['the', 'a', 'an', 'in', 'on', 'at', 'to', 'for', 'of', 'and', 'or', 'but', 'is', 'are', 'was', 'were', 'be', 'been', 'being', 'have', 'has', 'had', 'do', 'does', 'did', 'will', 'would', 'shall', 'should', 'can', 'could', 'may', 'might', 'must', 'ought', 'i', 'you', 'he', 'she', 'it', 'we', 'they', 'them', 'their', 'this', 'that', 'these', 'those'])\n\n    # Remove punctuation and convert to lowercase\n    text = text.translate(str.maketrans('', '', string.punctuation)).lower()\n\n    # Split the text into words\n    words = text.split()\n\n    # Count word frequencies, ignoring stop words\n    word_freq = {}\n    for word in words:\n        if word not in stop_words:\n            word_freq[word] = word_freq.get(word, 0) + 1\n\n    return word_freq\n", "test": "def check(candidate):\n    assert candidate(\"The quick brown fox jumps over the lazy dog. The dog barks.\") == {'quick': 1, 'brown': 1, 'fox': 1, 'jumps': 1, 'over': 1, 'lazy': 1, 'dog': 2, 'barks': 1}\n    assert candidate(\"MixEd CaSe TeXt ShOuLd Be HaNdLeD cOrReCtLy\") == {'mixed': 1, 'case': 1, 'text': 1, 'handled': 1, 'correctly': 1}\n    assert candidate(\"This sentence has some repeated words. This sentence repeats words.\") == {'sentence': 2, 'some': 1, 'repeated': 1, 'words': 2, 'repeats': 1}\n    assert candidate(\"To be or not to be, that is the question.\") == {'not': 1, 'question': 1}\n    assert candidate(\"Unique words only appear once in this sentence.\") == {'unique': 1, 'words': 1, 'only': 1, 'appear': 1, 'once': 1, 'sentence': 1}\n    assert candidate(\"a an the in of to and\") == {}\n    assert candidate(\"Hello world! Hello Python, hello programming.\") == {'hello': 3, 'world': 1, 'python': 1, 'programming': 1}\n    assert candidate(\"ALL CAPS TEXT SHOULD BE HANDLED CORRECTLY\") == {'all': 1, 'caps': 1, 'text': 1, 'handled': 1, 'correctly': 1}\n    assert candidate(\"\") == {}\n    assert candidate(\"Numbers 123 and symbols @#$ should be ignored.\") == {'numbers': 1, '123': 1, 'symbols': 1, 'ignored': 1}\n", "language": "python"}
{"task_id": "revision1a_problem148", "prompt": "from typing import List\n\ndef encrypt_message(message: str, shift: int) -> List[str]:\n    \"\"\"\n    In a secret agent training program, you need to create a Caesar cipher encryption system.\n    The system should take a message and a shift value, then return the encrypted message split into groups of 5 characters.\n\n    The Caesar cipher works by shifting each letter in the message by a certain number of positions in the alphabet.\n    For example, with a shift of 3, 'A' would become 'D', 'B' would become 'E', and so on. \n    The shift wraps around the alphabet, so 'Z' with a shift of 3 would become 'C'.\n\n    Ignore spaces and punctuation, and maintain the case of the original message.\n\n    Take the message and shift value as input, and return the encrypted message as a list of strings, \n    where each string is a group of 5 characters (except possibly the last group, which may be shorter).\n\n    Example:\n    Input: \"Hello, World!\", 3\n    Output: ['KHOOR', 'ZRUOG']\n\n    Input: \"Secret agent message\", 7\n    Output: ['ZLJYL', 'AHNLU', 'ATLZZ', 'HNL']\n\n    Input: \"Cryptography\", 13\n    Output: ['PELCG', 'BTENCU', 'L']\n    \"\"\"\n", "entry_point": "encrypt_message", "solution": "    def shift_letter(char: str, shift: int) -> str:\n        if char.isalpha():\n            ascii_offset = ord('A') if char.isupper() else ord('a')\n            return chr((ord(char) - ascii_offset + shift) % 26 + ascii_offset)\n        return char\n\n    encrypted = ''.join(shift_letter(char, shift) for char in message if char.isalpha())\n    return [encrypted[i:i+5] for i in range(0, len(encrypted), 5)]\n", "test": "def check(candidate):\n    assert candidate(\"Mixed CASE test\", 8) == ['Uqfml', 'KIAMb', 'mab']\n    assert candidate(\"abcdefghijklmnopqrstuvwxyz\", 25) == ['zabcd', 'efghi', 'jklmn', 'opqrs', 'tuvwx', 'y']\n    assert candidate(\"\", 5) == []\n    assert candidate(\"  Spaces  and  Punctuation!  \", 15) == ['Heprt', 'hpcsE', 'jcrij', 'pixdc']\n    assert candidate(\"Secret agent message\", 7) == ['Zljyl', 'ahnlu', 'atlzz', 'hnl']\n    assert candidate(\"Cryptography\", 13) == ['Pelcg', 'btenc', 'ul']\n    assert candidate(\"Hello, World!\", 3) == ['Khoor', 'Zruog']\n    assert candidate(\"Test123!@#\", 10) == ['Docd']\n    assert candidate(\"Wrap around Z test\", 2) == ['Ytcrc', 'tqwpf', 'Bvguv']\n    assert candidate(\"ABCDEFGHIJKLMNOPQRSTUVWXYZ\", 1) == ['BCDEF', 'GHIJK', 'LMNOP', 'QRSTU', 'VWXYZ', 'A']\n", "language": "python"}
{"task_id": "revision1a_problem135", "prompt": "from typing import List\n\ndef compress_string(text: str) -> str:\n    \"\"\"\n    You are developing a data compression algorithm for a messaging app. Your task is to create a Python function that compresses a given string by replacing consecutive repeated characters with the character followed by the count of repetitions.\n\n    The function should take a string as input and return the compressed version of the string. If the compressed version is not shorter than the original string, return the original string.\n\n    Example:\n    Input: \"aabbbcccc\"\n    Output: \"a2b3c4\"\n\n    Input: \"abcdefg\"\n    Output: \"abcdefg\"\n\n    Input: \"aabbbccccdddddeee\"\n    Output: \"a2b3c4d5e3\"\n    \"\"\"\n", "entry_point": "compress_string", "solution": "    if not text:\n        return text\n\n    compressed = []\n    count = 1\n    current_char = text[0]\n\n    for char in text[1:]:\n        if char == current_char:\n            count += 1\n        else:\n            compressed.append(current_char)\n            if count > 1:\n                compressed.append(str(count))\n            current_char = char\n            count = 1\n\n    compressed.append(current_char)\n    if count > 1:\n        compressed.append(str(count))\n\n    compressed_string = ''.join(compressed)\n    return compressed_string if len(compressed_string) < len(text) else text\n", "test": "def check(candidate):\n    assert candidate(\"zzzzzzzzzzzzzzzzzzz\") == 'z19'\n    assert candidate(\"aabbbccccdddddeee\") == 'a2b3c4d5e3'\n    assert candidate(\"a\") == 'a'\n    assert candidate(\"aabbcc\") == 'aabbcc'\n    assert candidate(\"abcdefg\") == 'abcdefg'\n    assert candidate(\"\") == ''\n    assert candidate(\"aaaa\") == 'a4'\n    assert candidate(\"aa\") == 'aa'\n    assert candidate(\"aabbbcccc\") == 'a2b3c4'\n    assert candidate(\"aaa\") == 'a3'\n", "language": "python"}
{"task_id": "revision1a_problem734", "prompt": "from typing import List\n\ndef optimal_study_plan(subjects: List[str], hours: List[int], days: int) -> List[str]:\n    \"\"\"\n    You are a student preparing for final exams. You have a list of subjects to study and the number of hours required for each.\n    Your task is to create an optimal study plan that maximizes the number of subjects you can complete within the given number of days.\n    You can study for a maximum of 8 hours per day.\n    You cannot split the study hours for a subject across multiple days.\n    The function should take three inputs:\n    1. A list of subject names\n    2. A corresponding list of required study hours for each subject\n    3. The number of days available for studying\n    Return a list of subject names representing the optimal study plan.\n    If multiple optimal plans exist, return any one of them.\n    Take the inputs from the user.\n    Example:\n    Input: [\"Math\", \"Science\", \"History\", \"Literature\", \"Computer Science\"], [6, 3, 5, 4, 2], 3\n    Output: [\"Science\", \"Literature\", \"Computer Science\", \"History\"]\n    Input: [\"Physics\", \"Chemistry\", \"Biology\"], [7, 8, 6], 2\n    Output: [\"Physics\", \"Biology\"]\n    \"\"\"\n", "entry_point": "optimal_study_plan", "solution": "    def knapsack(subjects, hours, days):\n        n = len(subjects)\n        dp = [[0] * (days * 8 + 1) for _ in range(n + 1)]\n        \n        for i in range(1, n + 1):\n            for j in range(1, days * 8 + 1):\n                if hours[i - 1] <= j:\n                    dp[i][j] = max(dp[i - 1][j], dp[i - 1][j - hours[i - 1]] + 1)\n                else:\n                    dp[i][j] = dp[i - 1][j]\n        \n        return dp\n\n    def backtrack(dp, subjects, hours, days):\n        n = len(subjects)\n        j = days * 8\n        selected = []\n        \n        for i in range(n, 0, -1):\n            if dp[i][j] != dp[i - 1][j]:\n                selected.append(subjects[i - 1])\n                j -= hours[i - 1]\n        \n        return selected[::-1]\n\n    dp = knapsack(subjects, hours, days)\n    return backtrack(dp, subjects, hours, days)\n", "test": "def check(candidate):\n    assert candidate([\"Math\", \"Science\", \"History\"], [4, 3, 5], 2) == ['Math', 'Science', 'History']\n    assert candidate([\"Anatomy\", \"Physiology\", \"Pathology\"], [6, 7, 5], 3) == ['Anatomy', 'Physiology', 'Pathology']\n    assert candidate([\"French\", \"Spanish\", \"German\", \"Italian\"], [4, 4, 4, 4], 2) == ['French', 'Spanish', 'German', 'Italian']\n    assert candidate([\"Geography\", \"Music\", \"Psychology\", \"Sociology\"], [3, 2, 4, 5], 2) == ['Geography', 'Music', 'Psychology', 'Sociology']\n    assert candidate([\"Philosophy\", \"Ethics\", \"Logic\"], [3, 3, 3], 5) == ['Philosophy', 'Ethics', 'Logic']\n    assert candidate([\"Computer Science\", \"Data Structures\", \"Algorithms\"], [7, 6, 8], 4) == ['Computer Science', 'Data Structures', 'Algorithms']\n    assert candidate([\"English\", \"Physics\", \"Art\"], [6, 7, 2], 3) == ['English', 'Physics', 'Art']\n    assert candidate([\"Calculus\", \"Statistics\", \"Linear Algebra\"], [5, 4, 6], 1) == ['Calculus']\n    assert candidate([\"Biology\", \"Chemistry\", \"Economics\"], [8, 8, 8], 3) == ['Biology', 'Chemistry', 'Economics']\n    assert candidate([\"Quantum Physics\", \"Relativity\"], [8, 8], 2) == ['Quantum Physics', 'Relativity']\n", "language": "python"}
{"task_id": "revision1a_problem30", "prompt": "def encrypt_message(message: str, key: str) -> str:\n    \"\"\"\n    As a cryptography enthusiast, you've developed a new encryption algorithm for secure communication. \n    Your algorithm works as follows:\n\n    1. Take a message and a key as input. Both can contain alphanumeric characters and spaces.\n    2. Convert both the message and key to their ASCII values.\n    3. Perform a bitwise XOR operation between each character of the message and the corresponding character of the key.\n       If the key is shorter than the message, it should be repeated cyclically.\n    4. Convert the resulting XOR values back to characters.\n    5. Return the encrypted message as a string.\n\n    Implement this encryption algorithm. Your function should handle messages and keys of any length.\n\n    Example:\n    Input: message = \"Hello World\", key = \"SecretKey\"\n    Output: \"9\\x0b\\x04\\x0c\\x13j:\\x1c\\x11\\x06\\x07\"\n\n    Note: The output may contain non-printable characters, which is normal for encryption.\n    \"\"\"\n", "entry_point": "encrypt_message", "solution": "    # Convert message and key to ASCII values\n    message_ascii = [ord(char) for char in message]\n    key_ascii = [ord(char) for char in key]\n    \n    # Perform XOR operation\n    encrypted_ascii = []\n    for i in range(len(message_ascii)):\n        # Use modulo to repeat the key cyclically\n        key_char = key_ascii[i % len(key_ascii)]\n        encrypted_char = message_ascii[i] ^ key_char\n        encrypted_ascii.append(encrypted_char)\n    \n    # Convert encrypted ASCII values back to characters\n    encrypted_message = ''.join(chr(char) for char in encrypted_ascii)\n    \n    return encrypted_message\n", "test": "def check(candidate):\n    assert candidate(\"ShortMsg\", \"VeryLongKey\" * 5) == '\\x05\\r\\x1d\\x0b8\"\\x1d\\x00'\n    assert candidate(\"12345\", \"abcde\") == 'PPPPP'\n    assert candidate(\"A\", \"B\") == '\\x03'\n    assert candidate(\"Hello World\", \"SecretKey\") == '\\x1b\\x00\\x0f\\x1e\\nT\\x1c\\n\\x0b?\\x01'\n    assert candidate(\"Special!@#$%^&*()\", \"Symbols!@#\") == '\\x00\\t\\x08\\x01\\x06\\r\\x1f\\x00\\x00\\x00w\\\\3DEDZ'\n    assert candidate(\"LongMessage\" * 10, \"ShortKey\") == '\\x1f\\x07\\x01\\x159.\\x16\\n2\\x0f\\n>\\x1b%\\x0246\\x1b\\x1c\\x13\\x13.)\\x16=\\x0f\"\\x17\\x078\\x04\\x1e6$\\x00\\x1c\\x13\\x06\\x00\\n \\t\\x08\\x178$\\x0b\\x1e\\x1e\\r\\x1c\\x01\\x15,\\x005<\\x06\\x08?\\x118\\x16\\x184\\r#\\x1d\\x1a,(\\x1c \\x1b\\x0e\\x15\\x11\\x07\\n\\x174%\\n\\x01\\x07*\\x02\\x1c\\x1f\\x07\\x01\\x159.\\x16\\n2\\x0f\\n>\\x1b%\\x0246\\x1b\\x1c\\x13\\x13.'\n    assert candidate(\"Test123\", \"Key\") == '\\x1f\\x00\\n?TKx'\n    assert candidate(\"\", \"Key\") == ''\n", "language": "python"}
{"task_id": "revision1a_problem70", "prompt": "from typing import List, Tuple\n\ndef compress_time_series(data: List[float], epsilon: float) -> List[Tuple[float, int]]:\n    \"\"\"\n    A smart energy meter collects power consumption data every minute. To save storage and \n    transmission costs, we need to compress this time series data using the Ramer-Douglas-Peucker algorithm.\n\n    Given a list of power consumption values (in kWh) and an epsilon value (maximum allowed deviation), \n    compress the time series by removing points that don't significantly contribute to the overall shape.\n\n    Return a list of tuples, where each tuple contains (value, index) of the kept points.\n\n    Example:\n    Input: \n    data = [0.5, 0.5, 0.6, 0.7, 0.8, 0.9, 1.0, 1.1, 1.1, 1.0, 0.9, 0.8, 0.7, 0.6, 0.5, 0.5]\n    epsilon = 0.1\n    Output: [(0.5, 0), (1.1, 7), (0.5, 15)]\n\n    Note: The first and last points should always be included in the output.\n    \"\"\"\n", "entry_point": "compress_time_series", "solution": "    def distance(p1, p2, p):\n        if p1[0] == p2[0]:\n            return abs(p[0] - p1[0])\n        else:\n            slope = (p2[1] - p1[1]) / (p2[0] - p1[0])\n            intercept = p1[1] - slope * p1[0]\n            return abs(slope * p[0] - p[1] + intercept) / ((slope ** 2 + 1) ** 0.5)\n\n    def rdp(start, end):\n        dmax = 0\n        index = start\n        for i in range(start + 1, end):\n            d = distance((start, data[start]), (end, data[end]), (i, data[i]))\n            if d > dmax:\n                index = i\n                dmax = d\n\n        result = []\n        if dmax > epsilon:\n            result.extend(rdp(start, index))\n            result.extend(rdp(index, end))\n        else:\n            result.append((data[end], end))\n\n        return result\n\n    if len(data) < 3:\n        return [(value, index) for index, value in enumerate(data)]\n\n    result = [(data[0], 0)]\n    result.extend(rdp(0, len(data) - 1))\n\n    return sorted(set(result), key=lambda x: x[1])\n", "test": "def check(candidate):\n    assert candidate([1.0, 2.0, 3.0, 4.0, 5.0], 0.5) == [(1.0, 0), (5.0, 4)]\n    assert candidate([0.1], 0.1) == [(0.1, 0)]\n    assert candidate([3.14, 3.14159, 3.14, 3.14159, 3.14], 0.001) == [(3.14, 0), (3.14159, 1), (3.14, 2), (3.14159, 3), (3.14, 4)]\n    assert candidate([0.1, 0.2, 0.1, 0.2, 0.1], 0.05) == [(0.1, 0), (0.2, 1), (0.1, 2), (0.2, 3), (0.1, 4)]\n    assert candidate([5.0, 5.0, 5.0, 5.0, 5.0], 0.1) == [(5.0, 0), (5.0, 4)]\n    assert candidate([1.5, 1.4, 1.3, 1.2, 1.1, 1.0], 0.1) == [(1.5, 0), (1.0, 5)]\n    assert candidate([0.1, 0.2, 0.3, 0.4, 0.5], 0.2) == [(0.1, 0), (0.5, 4)]\n    assert candidate([0.0, 1.0, 0.0, 1.0, 0.0], 0.1) == [(0.0, 0), (1.0, 1), (0.0, 2), (1.0, 3), (0.0, 4)]\n    assert candidate([1.0, 1.1, 1.2, 1.3, 1.4, 1.5], 0.05) == [(1.0, 0), (1.5, 5)]\n    assert candidate([0.5, 0.5, 0.6, 0.7, 0.8, 0.9, 1.0, 1.1, 1.1, 1.0, 0.9, 0.8, 0.7, 0.6, 0.5, 0.5], 0.1) == [(0.5, 0), (1.1, 7), (0.5, 15)]\n", "language": "python"}
{"task_id": "revision1a_problem600", "prompt": "from typing import List, Dict\n\ndef optimize_warehouse_layout(items: List[str], item_frequencies: Dict[str, int], shelf_capacity: int) -> List[List[str]]:\n    \"\"\"\n    A warehouse manager wants to optimize the layout of items on shelves to minimize the time spent retrieving\n    frequently accessed items. Given a list of items, their access frequencies, and the capacity of each shelf,\n    determine the optimal arrangement of items on shelves.\n\n    Implement a function that returns the optimal arrangement of items on shelves, where more frequently accessed\n    items are placed on lower shelves (represented by earlier sublists in the output).\n\n    Use a greedy algorithm approach to solve this problem.\n\n    Args:\n    items (List[str]): List of item names\n    item_frequencies (Dict[str, int]): Dictionary mapping item names to their access frequencies\n    shelf_capacity (int): The maximum number of items that can be placed on each shelf\n\n    Returns:\n    List[List[str]]: The optimal arrangement of items on shelves\n\n    Example:\n    Input: \n    items = [\"A\", \"B\", \"C\", \"D\", \"E\", \"F\"]\n    item_frequencies = {\"A\": 10, \"B\": 5, \"C\": 15, \"D\": 7, \"E\": 6, \"F\": 4}\n    shelf_capacity = 3\n    Output: [[\"C\", \"A\", \"D\"], [\"E\", \"B\", \"F\"]]\n\n    Input:\n    items = [\"P\", \"Q\", \"R\", \"S\", \"T\"]\n    item_frequencies = {\"P\": 8, \"Q\": 12, \"R\": 6, \"S\": 10, \"T\": 4}\n    shelf_capacity = 2\n    Output: [[\"Q\", \"S\"], [\"P\", \"R\"], [\"T\"]]\n    \"\"\"\n", "entry_point": "optimize_warehouse_layout", "solution": "    # Sort items based on their frequencies in descending order\n    sorted_items = sorted(items, key=lambda x: item_frequencies[x], reverse=True)\n    \n    # Initialize the result list to store shelves\n    shelves = []\n    \n    # Initialize the current shelf\n    current_shelf = []\n    \n    # Iterate through the sorted items\n    for item in sorted_items:\n        # If the current shelf is full, add it to the shelves and start a new shelf\n        if len(current_shelf) == shelf_capacity:\n            shelves.append(current_shelf)\n            current_shelf = []\n        \n        # Add the item to the current shelf\n        current_shelf.append(item)\n    \n    # Add the last shelf if it's not empty\n    if current_shelf:\n        shelves.append(current_shelf)\n    \n    return shelves\n", "test": "def check(candidate):\n    assert candidate([\"X\", \"Y\", \"Z\"], {\"X\": 100, \"Y\": 50, \"Z\": 25}, 1) == [['X'], ['Y'], ['Z']]\n    assert candidate([\"P\", \"Q\", \"R\", \"S\", \"T\", \"U\", \"V\"], {\"P\": 8, \"Q\": 12, \"R\": 6, \"S\": 10, \"T\": 4, \"U\": 15, \"V\": 9}, 3) == [['U', 'Q', 'S'], ['V', 'P', 'R'], ['T']]\n    assert candidate([\"Apple\", \"Banana\", \"Cherry\", \"Date\"], {\"Apple\": 15, \"Banana\": 20, \"Cherry\": 10, \"Date\": 5}, 3) == [['Banana', 'Apple', 'Cherry'], ['Date']]\n    assert candidate([\"A\"], {\"A\": 1}, 1) == [['A']]\n    assert candidate([\"A\", \"B\", \"C\", \"D\", \"E\", \"F\", \"G\", \"H\", \"I\", \"J\"], {\"A\": 1, \"B\": 2, \"C\": 3, \"D\": 4, \"E\": 5, \"F\": 6, \"G\": 7, \"H\": 8, \"I\": 9, \"J\": 10}, 5) == [['J', 'I', 'H', 'G', 'F'], ['E', 'D', 'C', 'B', 'A']]\n    assert candidate([\"A\", \"B\", \"C\", \"D\", \"E\"], {\"A\": 10, \"B\": 5, \"C\": 15, \"D\": 7, \"E\": 6}, 2) == [['C', 'A'], ['D', 'E'], ['B']]\n    assert candidate([\"A\", \"B\"], {\"A\": 1, \"B\": 1}, 2) == [['A', 'B']]\n    assert candidate([\"Book\", \"Pen\", \"Pencil\", \"Eraser\", \"Ruler\"], {\"Book\": 50, \"Pen\": 30, \"Pencil\": 40, \"Eraser\": 20, \"Ruler\": 10}, 2) == [['Book', 'Pencil'], ['Pen', 'Eraser'], ['Ruler']]\n    assert candidate([\"Item1\", \"Item2\", \"Item3\", \"Item4\"], {\"Item1\": 20, \"Item2\": 30, \"Item3\": 10, \"Item4\": 40}, 4) == [['Item4', 'Item2', 'Item1', 'Item3']]\n    assert candidate([\"Item1\", \"Item2\", \"Item3\"], {\"Item1\": 100, \"Item2\": 100, \"Item3\": 100}, 1) == [['Item1'], ['Item2'], ['Item3']]\n", "language": "python"}
{"task_id": "revision1a_problem497", "prompt": "from typing import List, Tuple\n\ndef analyze_stock_trends(prices: List[float], window: int) -> List[Tuple[str, float]]:\n    \"\"\"\n    As a financial analyst, you need to analyze stock price trends over a specified time window.\n    Given a list of daily closing prices for a stock and a time window, determine whether the stock\n    is in an uptrend, downtrend, or neutral trend for each window period.\n\n    A trend is determined by comparing the average price of the first half of the window to the\n    average price of the second half:\n    - Uptrend: second half average > first half average by at least 2%\n    - Downtrend: second half average < first half average by at least 2%\n    - Neutral: difference between halves is less than 2%\n\n    Take input as a list of daily closing prices and the window size for analysis.\n    Return a list of tuples, where each tuple contains the trend ('UP', 'DOWN', or 'NEUTRAL')\n    and the percentage change between the two halves of the window.\n\n    Example:\n    Input: [100, 102, 104, 103, 105, 107, 108, 106], 4\n    Output: [('UP', 2.91), ('UP', 3.86), ('NEUTRAL', 0.93), ('NEUTRAL', -0.93), ('NEUTRAL', 0.93)]\n\n    Example:\n    Input: [50, 52, 48, 47, 46, 50, 53, 55], 3\n    Output: [('NEUTRAL', -1.96), ('DOWN', -7.69), ('UP', 8.42), ('UP', 10.20), ('UP', 15.15), ('UP', 10.00)]\n    \"\"\"\n", "entry_point": "analyze_stock_trends", "solution": "    result = []\n    \n    if window % 2 != 0:\n        window -= 1  # Ensure window is even for equal halves\n    \n    half_window = window // 2\n    \n    for i in range(len(prices) - window + 1):\n        window_prices = prices[i:i+window]\n        first_half = window_prices[:half_window]\n        second_half = window_prices[half_window:]\n        \n        first_half_avg = sum(first_half) / half_window\n        second_half_avg = sum(second_half) / half_window\n        \n        percent_change = ((second_half_avg - first_half_avg) / first_half_avg) * 100\n        \n        if percent_change >= 2:\n            trend = 'UP'\n        elif percent_change <= -2:\n            trend = 'DOWN'\n        else:\n            trend = 'NEUTRAL'\n        \n        result.append((trend, round(percent_change, 2)))\n    \n    return result\n", "test": "def check(candidate):\n    assert candidate([50, 50, 50, 50, 50, 50, 50, 50], 3) == [('NEUTRAL', 0.0), ('NEUTRAL', 0.0), ('NEUTRAL', 0.0), ('NEUTRAL', 0.0), ('NEUTRAL', 0.0), ('NEUTRAL', 0.0), ('NEUTRAL', 0.0)]\n    assert candidate([100, 101, 99, 102, 98, 103, 97, 104], 2) == [('NEUTRAL', 1.0), ('NEUTRAL', -1.98), ('UP', 3.03), ('DOWN', -3.92), ('UP', 5.1), ('DOWN', -5.83), ('UP', 7.22)]\n    assert candidate([10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20], 5) == [('UP', 19.05), ('UP', 17.39), ('UP', 16.0), ('UP', 14.81), ('UP', 13.79), ('UP', 12.9), ('UP', 12.12), ('UP', 11.43)]\n    assert candidate([1000, 950, 900, 850, 800, 850, 900, 950], 3) == [('DOWN', -5.0), ('DOWN', -5.26), ('DOWN', -5.56), ('DOWN', -5.88), ('UP', 6.25), ('UP', 5.88), ('UP', 5.56)]\n    assert candidate([100, 98, 96, 94, 92, 90, 88, 86, 84, 82], 4) == [('DOWN', -4.04), ('DOWN', -4.12), ('DOWN', -4.21), ('DOWN', -4.3), ('DOWN', -4.4), ('DOWN', -4.49), ('DOWN', -4.6)]\n    assert candidate([1.5, 2.5, 3.5, 4.5, 5.5, 6.5, 7.5, 8.5], 4) == [('UP', 100.0), ('UP', 66.67), ('UP', 50.0), ('UP', 40.0), ('UP', 33.33)]\n    assert candidate([100, 102, 104, 103, 105, 107, 108, 106], 4) == [('UP', 2.48), ('NEUTRAL', 0.97), ('UP', 2.42), ('UP', 3.37), ('NEUTRAL', 0.94)]\n    assert candidate([50, 52, 48, 47, 46, 50, 53, 55], 3) == [('UP', 4.0), ('DOWN', -7.69), ('DOWN', -2.08), ('DOWN', -2.13), ('UP', 8.7), ('UP', 6.0), ('UP', 3.77)]\n    assert candidate([10, 20, 30, 40, 50, 60, 70, 80], 2) == [('UP', 100.0), ('UP', 50.0), ('UP', 33.33), ('UP', 25.0), ('UP', 20.0), ('UP', 16.67), ('UP', 14.29)]\n", "language": "python"}
{"task_id": "revision1a_problem505", "prompt": "from typing import List, Tuple\nimport math\n\ndef optimize_delivery_route(locations: List[Tuple[float, float]]) -> List[int]:\n    \"\"\"\n    A delivery company wants to optimize their route for multiple deliveries.\n    Write a function that takes a list of (x, y) coordinates representing delivery locations\n    and returns the optimal order to visit them, starting and ending at the first location (0, 0).\n    Use the nearest neighbor algorithm to find an approximate solution to the Traveling Salesman Problem.\n    \n    Example:\n    Input: [(0, 0), (1, 5), (2, 2), (5, 3), (6, 1)]\n    Output: [0, 2, 3, 4, 1, 0]\n    \n    Input: [(0, 0), (2, 2), (3, 4), (1, 1), (4, 0)]\n    Output: [0, 3, 1, 2, 4, 0]\n    \"\"\"\n", "entry_point": "optimize_delivery_route", "solution": "    def distance(point1: Tuple[float, float], point2: Tuple[float, float]) -> float:\n        return math.sqrt((point1[0] - point2[0])**2 + (point1[1] - point2[1])**2)\n    \n    n = len(locations)\n    unvisited = set(range(1, n))  # Skip the starting point (0)\n    route = [0]  # Start at the first location (index 0)\n    current = 0\n    \n    while unvisited:\n        nearest = min(unvisited, key=lambda x: distance(locations[current], locations[x]))\n        route.append(nearest)\n        unvisited.remove(nearest)\n        current = nearest\n    \n    route.append(0)  # Return to the starting point\n    return route\n", "test": "def check(candidate):\n    assert candidate([(0, 0), (2, 2), (3, 4), (1, 1), (4, 0)]) == [0, 3, 1, 2, 4, 0]\n    assert candidate([(-1, -1), (-2, -2), (-3, -3), (-4, -4)]) == [0, 1, 2, 3, 0]\n    assert candidate([(0, 0), (3, 4), (4, 3), (5, 5), (1, 2)]) == [0, 4, 1, 2, 3, 0]\n    assert candidate([(0, 0), (0.1, 0.1), (0.2, 0.2), (0.3, 0.3)]) == [0, 1, 2, 3, 0]\n    assert candidate([(0, 0)]) == [0, 0]\n    assert candidate([(0, 0), (10, 10), (20, 20), (30, 30)]) == [0, 1, 2, 3, 0]\n    assert candidate([(0, 0), (1, 1)]) == [0, 1, 0]\n    assert candidate([(0, 0), (1, 5), (2, 2), (5, 3), (6, 1)]) == [0, 2, 1, 3, 4, 0]\n    assert candidate([(0, 0), (1, 0), (2, 0), (3, 0), (4, 0)]) == [0, 1, 2, 3, 4, 0]\n    assert candidate([(0, 0), (0, 1), (0, 2), (0, 3), (0, 4)]) == [0, 1, 2, 3, 4, 0]\n", "language": "python"}
{"task_id": "revision1a_problem87", "prompt": "from collections import Counter\nfrom typing import List, Dict\nimport re\n\ndef analyze_text_sentiment(text: str) -> Dict[str, float]:\n    \"\"\"\n    You are tasked with creating a sentiment analysis function for a social media monitoring tool.\n    The function should analyze the sentiment of a given text and provide various metrics.\n    Implement the following functionalities:\n\n    1. Tokenize the input text into words.\n    2. Remove stop words and punctuation.\n    3. Calculate the following sentiment metrics:\n       a. Positivity score: Ratio of positive words to total words.\n       b. Negativity score: Ratio of negative words to total words.\n       c. Neutrality score: Ratio of neutral words to total words.\n       d. Compound score: Overall sentiment score between -1 (very negative) and 1 (very positive).\n    4. Identify the top 5 most frequent words in the text.\n\n    Use a pre-defined dictionary of positive, negative, and neutral words for sentiment classification.\n    Return a dictionary containing all calculated metrics and the top words.\n\n    Example:\n    Input: \"I love this product! It's amazing and works great. However, the price is a bit high.\"\n    Output: {\n        'positivity': 0.3,\n        'negativity': 0.1,\n        'neutrality': 0.6,\n        'compound': 0.6,\n        'top_words': ['product', 'amazing', 'works', 'great', 'price']\n    }\n    \"\"\"\n", "entry_point": "analyze_text_sentiment", "solution": "    # Pre-defined dictionaries for sentiment classification\n    positive_words = set(['love', 'amazing', 'great', 'excellent', 'good', 'best', 'fantastic'])\n    negative_words = set(['bad', 'terrible', 'awful', 'worst', 'horrible', 'poor'])\n    neutral_words = set(['the', 'a', 'an', 'and', 'or', 'but', 'in', 'on', 'at', 'to', 'for'])\n    \n    # Tokenize and clean the text\n    words = re.findall(r'\\w+', text.lower())\n    words = [word for word in words if word not in neutral_words]\n    \n    # Count sentiment words\n    positive_count = sum(1 for word in words if word in positive_words)\n    negative_count = sum(1 for word in words if word in negative_words)\n    neutral_count = len(words) - positive_count - negative_count\n    \n    # Calculate sentiment scores\n    total_words = len(words)\n    positivity = positive_count / total_words if total_words > 0 else 0\n    negativity = negative_count / total_words if total_words > 0 else 0\n    neutrality = neutral_count / total_words if total_words > 0 else 0\n    \n    # Calculate compound score\n    compound = (positive_count - negative_count) / total_words if total_words > 0 else 0\n    \n    # Get top 5 most frequent words\n    word_counts = Counter(words)\n    top_words = [word for word, _ in word_counts.most_common(5)]\n    \n    # Prepare the result dictionary\n    result = {\n        'positivity': round(positivity, 2),\n        'negativity': round(negativity, 2),\n        'neutrality': round(neutrality, 2),\n        'compound': round(compound, 2),\n        'top_words': top_words\n    }\n    \n    return result\n", "test": "def check(candidate):\n    assert candidate(\"I absolutely hate this! It\\'s the worst experience ever. Terrible customer service.\") == {'positivity': 0.0, 'negativity': 0.17, 'neutrality': 0.83, 'compound': -0.17, 'top_words': ['i', 'absolutely', 'hate', 'this', 'it']}\n    assert candidate(\"!@#$%^&*()\") == {'positivity': 0, 'negativity': 0, 'neutrality': 0, 'compound': 0, 'top_words': []}\n    assert candidate(\"Good good good good good bad bad neutral neutral\") == {'positivity': 0.56, 'negativity': 0.22, 'neutrality': 0.22, 'compound': 0.33, 'top_words': ['good', 'bad', 'neutral']}\n    assert candidate(\"\ud83d\ude0a\ud83d\ude0a\ud83d\ude0a\ud83d\ude0a\ud83d\ude0a\") == {'positivity': 0, 'negativity': 0, 'neutrality': 0, 'compound': 0, 'top_words': []}\n    assert candidate(\"The quick brown fox jumps over the lazy dog.\") == {'positivity': 0.0, 'negativity': 0.0, 'neutrality': 1.0, 'compound': 0.0, 'top_words': ['quick', 'brown', 'fox', 'jumps', 'over']}\n    assert candidate(\"I love this product! It\\'s amazing and works great. However, the price is a bit high.\") == {'positivity': 0.21, 'negativity': 0.0, 'neutrality': 0.79, 'compound': 0.21, 'top_words': ['i', 'love', 'this', 'product', 'it']}\n    assert candidate(\"\") == {'positivity': 0, 'negativity': 0, 'neutrality': 0, 'compound': 0, 'top_words': []}\n    assert candidate(\"This is a neutral statement without any strong emotions.\") == {'positivity': 0.0, 'negativity': 0.0, 'neutrality': 1.0, 'compound': 0.0, 'top_words': ['this', 'is', 'neutral', 'statement', 'without']}\n    assert candidate(\"This product exceeded my expectations in every way possible. Absolutely fantastic!\") == {'positivity': 0.1, 'negativity': 0.0, 'neutrality': 0.9, 'compound': 0.1, 'top_words': ['this', 'product', 'exceeded', 'my', 'expectations']}\n    assert candidate(\"SHOUTING IN ALL CAPS IS VERY ANNOYING AND FRUSTRATING!\") == {'positivity': 0.0, 'negativity': 0.0, 'neutrality': 1.0, 'compound': 0.0, 'top_words': ['shouting', 'all', 'caps', 'is', 'very']}\n", "language": "python"}
{"task_id": "revision1a_problem704", "prompt": "from typing import List, Tuple\n\ndef optimize_wind_farm(grid: List[List[int]], n: int) -> List[Tuple[int, int]]:\n    \"\"\"\n    An energy company wants to build a wind farm on a rectangular piece of land. The land is represented\n    by a grid where each cell contains a value indicating the average wind speed at that location.\n\n    Your task is to select 'n' locations to place wind turbines such that the total energy output is maximized.\n    However, to prevent interference, no two turbines can be placed in adjacent cells (including diagonally).\n\n    Implement a function that takes the wind speed grid and the number of turbines 'n' as input, and returns\n    a list of (row, col) tuples representing the optimal locations for the wind turbines.\n\n    Use dynamic programming or backtracking with pruning to solve this optimization problem efficiently.\n\n    Example:\n    Input:\n    grid = [\n        [1, 3, 4, 1, 5],\n        [2, 6, 2, 7, 2],\n        [5, 1, 8, 3, 1],\n        [2, 4, 1, 9, 7],\n        [6, 5, 3, 2, 1]\n    ]\n    n = 3\n    Output: [(1, 3), (3, 1), (4, 0)]  # These locations give maximum total wind speed while satisfying constraints\n\n    Note: There might be multiple optimal solutions. Return any one of them.\n    \"\"\"\n", "entry_point": "optimize_wind_farm", "solution": "    rows, cols = len(grid), len(grid[0])\n    best_locations = []\n    best_total = 0\n\n    def is_valid(row, col, placed):\n        for r, c in placed:\n            if abs(row - r) <= 1 and abs(col - c) <= 1:\n                return False\n        return True\n\n    def backtrack(row, col, placed, total):\n        nonlocal best_locations, best_total\n\n        if len(placed) == n:\n            if total > best_total:\n                best_total = total\n                best_locations = placed.copy()\n            return\n\n        if row == rows:\n            return\n\n        next_row, next_col = (row, col + 1) if col + 1 < cols else (row + 1, 0)\n\n        # Try placing a turbine at the current location\n        if is_valid(row, col, placed):\n            placed.append((row, col))\n            backtrack(next_row, next_col, placed, total + grid[row][col])\n            placed.pop()\n\n        # Try not placing a turbine at the current location\n        backtrack(next_row, next_col, placed, total)\n\n    backtrack(0, 0, [], 0)\n    return best_locations\n", "test": "def check(candidate):\n    assert candidate([[1, 1], [1, 1]], 1) == [(0, 0)]\n    assert candidate([[1, 1, 1], [1, 1, 1], [1, 1, 1]], 1) == [(0, 0)]\n    assert candidate([[1, 2, 3], [4, 5, 6], [7, 8, 9]], 2) == [(2, 0), (2, 2)]\n    assert candidate([[1, 1, 1], [1, 9, 1], [1, 1, 1]], 1) == [(1, 1)]\n    assert candidate([[1]], 1) == [(0, 0)]\n    assert candidate([[1, 2], [3, 4]], 2) == []\n    assert candidate([[10]], 1) == [(0, 0)]\n    assert candidate([[1, 2, 3, 4], [5, 6, 7, 8], [9, 10, 11, 12], [13, 14, 15, 16]], 4) == [(1, 1), (1, 3), (3, 1), (3, 3)]\n    assert candidate([[1, 3, 4, 1, 5], [2, 6, 2, 7, 2], [5, 1, 8, 3, 1], [2, 4, 1, 9, 7], [6, 5, 3, 2, 1]], 3) == [(1, 1), (1, 3), (3, 3)]\n    assert candidate([[1, 2, 3], [4, 5, 6]], 1) == [(1, 2)]\n", "language": "python"}
{"task_id": "revision1a_problem631", "prompt": "import heapq\nfrom typing import List\n\ndef optimize_cpu_scheduling(tasks: List[List[int]]) -> List[int]:\n    \"\"\"\n    I have a multi-core processor and a list of tasks with their execution times and priorities.\n    I want to schedule these tasks efficiently to minimize the overall completion time.\n    Take input from the user for N tasks, where each task is represented by [execution_time, priority].\n    Return the order of task IDs (0-indexed) that gives the optimal scheduling.\n    Use a priority queue (heap) to solve this problem.\n\n    Example:\n    Input: [[10, 2], [5, 1], [8, 3], [3, 2]]\n    Output: [2, 0, 3, 1]\n\n    Explanation:\n    Task 2 has the highest priority (3), so it's scheduled first.\n    Task 0 and 3 have the same priority (2), but Task 3 has shorter execution time, so it's next.\n    Task 0 is scheduled after Task 3.\n    Task 1 has the lowest priority, so it's scheduled last.\n    \"\"\"\n", "entry_point": "optimize_cpu_scheduling", "solution": "    # Create a list of tuples (priority, execution_time, task_id)\n    task_list = [(-priority, execution_time, task_id) for task_id, (execution_time, priority) in enumerate(tasks)]\n    \n    # Create a min heap (priority queue) from the task list\n    heapq.heapify(task_list)\n    \n    # Initialize the result list to store the optimal scheduling order\n    result = []\n    \n    # Process tasks in order of priority, then execution time\n    while task_list:\n        _, _, task_id = heapq.heappop(task_list)\n        result.append(task_id)\n    \n    return result\n", "test": "def check(candidate):\n    assert candidate([[1, 5], [2, 4], [3, 3], [4, 2], [5, 1]]) == [0, 1, 2, 3, 4]\n    assert candidate([[10, 2], [5, 1], [8, 3], [3, 2]]) == [2, 3, 0, 1]\n    assert candidate([[5, 5], [4, 4], [3, 3], [2, 2], [1, 1]]) == [0, 1, 2, 3, 4]\n    assert candidate([[100, 1], [1, 100]]) == [1, 0]\n    assert candidate([[5, 5], [5, 5], [5, 5], [5, 5], [5, 5]]) == [0, 1, 2, 3, 4]\n    assert candidate([[1, 1], [1, 2], [1, 3], [1, 4], [1, 5]]) == [4, 3, 2, 1, 0]\n    assert candidate([[10, 1], [9, 2], [8, 3], [7, 4], [6, 5]]) == [4, 3, 2, 1, 0]\n    assert candidate([[1, 1], [2, 2], [3, 3], [4, 4], [5, 5]]) == [4, 3, 2, 1, 0]\n    assert candidate([[1, 100], [100, 1]]) == [0, 1]\n    assert candidate([[1, 1]]) == [0]\n", "language": "python"}
{"task_id": "revision1a_problem113", "prompt": "from typing import List, Tuple\nimport heapq\n\ndef schedule_tasks(tasks: List[Tuple[str, int, int]], processors: int) -> List[Tuple[str, int]]:\n    \"\"\"\n    You are designing a task scheduler for a multi-core processor system.\n    Given a list of tasks, each represented by a tuple containing the task ID, \n    its arrival time, and its execution time, your goal is to schedule these tasks \n    efficiently across the available processors.\n\n    Write a Python function that takes the list of tasks and the number of processors as input,\n    and returns a list of tuples, each containing a task ID and its completion time.\n\n    The scheduler should follow these rules:\n    1. Tasks are scheduled in order of arrival time.\n    2. If multiple tasks arrive at the same time, prioritize the one with shorter execution time.\n    3. If a processor is free, the next available task should be assigned immediately.\n    4. Preemption is not allowed; once a task starts, it runs to completion.\n\n    Use a min-heap to efficiently manage the available processors.\n\n    Example:\n    Input: \n    tasks = [(\"T1\", 0, 4), (\"T2\", 1, 2), (\"T3\", 2, 1), (\"T4\", 3, 3)]\n    processors = 2\n\n    Output: [(\"T1\", 4), (\"T2\", 3), (\"T3\", 3), (\"T4\", 6)]\n\n    Explanation: \n    - T1 starts at time 0 on processor 1, completes at time 4\n    - T2 starts at time 1 on processor 2, completes at time 3\n    - T3 starts at time 3 on processor 2 (as soon as T2 finishes), completes at time 4\n    - T4 starts at time 4 on processor 1 (as soon as T1 finishes), completes at time 7\n    \"\"\"\n", "entry_point": "schedule_tasks", "solution": "    # Sort tasks by arrival time and then by execution time\n    sorted_tasks = sorted(tasks, key=lambda x: (x[1], x[2]))\n    \n    # Initialize the processor heap and result list\n    processor_heap = [(0, i) for i in range(processors)]\n    result = []\n    \n    for task_id, arrival_time, execution_time in sorted_tasks:\n        # Get the earliest available processor\n        while processor_heap[0][0] < arrival_time:\n            heapq.heapreplace(processor_heap, (arrival_time, processor_heap[0][1]))\n        \n        # Assign the task to the earliest available processor\n        start_time, processor = heapq.heappop(processor_heap)\n        completion_time = start_time + execution_time\n        result.append((task_id, completion_time))\n        \n        # Put the processor back into the heap with updated availability time\n        heapq.heappush(processor_heap, (completion_time, processor))\n    \n    return result\n", "test": "def check(candidate):\n    assert candidate([(\"T1\", 0, 4), (\"T2\", 1, 2), (\"T3\", 2, 1), (\"T4\", 3, 3)], 2) == [('T1', 4), ('T2', 3), ('T3', 4), ('T4', 7)]\n    assert candidate([(\"P1\", 0, 5), (\"P2\", 1, 3), (\"P3\", 2, 2), (\"P4\", 3, 1), (\"P5\", 4, 4)], 3) == [('P1', 5), ('P2', 4), ('P3', 4), ('P4', 5), ('P5', 8)]\n    assert candidate([(\"X\", 0, 1), (\"Y\", 0, 1), (\"Z\", 0, 1)], 3) == [('X', 1), ('Y', 1), ('Z', 1)]\n    assert candidate([(\"Single\", 0, 10)], 5) == [('Single', 10)]\n    assert candidate([(\"Long\", 0, 100), (\"Short1\", 1, 1), (\"Short2\", 2, 1), (\"Short3\", 3, 1)], 2) == [('Long', 100), ('Short1', 2), ('Short2', 3), ('Short3', 4)]\n    assert candidate([(\"A\", 0, 3), (\"B\", 0, 2), (\"C\", 1, 1), (\"D\", 2, 4)], 1) == [('B', 2), ('A', 5), ('C', 6), ('D', 10)]\n    assert candidate([(\"A\", 0, 1), (\"B\", 1000000, 1)], 1) == [('A', 1), ('B', 1000001)]\n    assert candidate([], 3) == []\n    assert candidate([(\"Task1\", 5, 10), (\"Task2\", 5, 5), (\"Task3\", 5, 15)], 2) == [('Task2', 10), ('Task1', 15), ('Task3', 25)]\n    assert candidate([(\"T1\", 0, 1), (\"T2\", 0, 2), (\"T3\", 0, 3), (\"T4\", 0, 4), (\"T5\", 0, 5)], 1) == [('T1', 1), ('T2', 3), ('T3', 6), ('T4', 10), ('T5', 15)]\n", "language": "python"}
{"task_id": "revision1a_problem185", "prompt": "from typing import List, Tuple\n\ndef optimize_study_schedule(subjects: List[Tuple[str, int, int]]) -> List[str]:\n    \"\"\"\n    As a student preparing for exams, you want to optimize your study schedule.\n    You have a list of subjects, each with a name, importance (1-10), and estimated study time (in hours).\n    Create a study schedule that maximizes the importance-to-time ratio while ensuring you don't study for more than 8 hours a day.\n    \n    Take input as a list of tuples, where each tuple contains (subject_name, importance, study_time).\n    Return a list of subject names representing the optimized daily study schedule.\n    \n    Use dynamic programming to solve this problem efficiently.\n    \n    Example:\n    Input: [(\"Math\", 9, 3), (\"Physics\", 8, 4), (\"Chemistry\", 7, 2), (\"Biology\", 6, 3), (\"History\", 5, 2)]\n    Output: [\"Math\", \"Chemistry\", \"Physics\"]\n    \"\"\"\n", "entry_point": "optimize_study_schedule", "solution": "    n = len(subjects)\n    max_hours = 8\n\n    # Create a 2D table for dynamic programming\n    dp = [[0 for _ in range(max_hours + 1)] for _ in range(n + 1)]\n\n    # Fill the dp table\n    for i in range(1, n + 1):\n        for j in range(1, max_hours + 1):\n            subject_name, importance, study_time = subjects[i - 1]\n            if study_time <= j:\n                dp[i][j] = max(dp[i - 1][j], dp[i - 1][j - study_time] + importance)\n            else:\n                dp[i][j] = dp[i - 1][j]\n\n    # Backtrack to find the selected subjects\n    selected_subjects = []\n    i, j = n, max_hours\n    while i > 0 and j > 0:\n        if dp[i][j] != dp[i - 1][j]:\n            subject_name, _, study_time = subjects[i - 1]\n            selected_subjects.append(subject_name)\n            j -= study_time\n        i -= 1\n\n    # Reverse the list to get the correct order\n    selected_subjects.reverse()\n\n    return selected_subjects\n", "test": "def check(candidate):\n    assert candidate([(\"Python\", 10, 4), (\"Java\", 8, 3), (\"C++\", 9, 4), (\"JavaScript\", 7, 2), (\"SQL\", 6, 1)]) == ['Python', 'Java', 'SQL']\n    assert candidate([(\"Marketing\", 7, 2), (\"Finance\", 8, 3), (\"Management\", 6, 2), (\"Accounting\", 9, 4), (\"Economics\", 7, 3)]) == ['Marketing', 'Management', 'Accounting']\n    assert candidate([(\"History\", 5, 2), (\"Geography\", 4, 1), (\"Civics\", 3, 1), (\"Economics\", 6, 3), (\"Political Science\", 7, 4)]) == ['History', 'Geography', 'Civics', 'Political Science']\n    assert candidate([(\"English\", 10, 2), (\"Math\", 9, 3), (\"Physics\", 8, 4), (\"Chemistry\", 7, 2), (\"Biology\", 6, 3)]) == ['English', 'Math', 'Chemistry']\n    assert candidate([(\"Anatomy\", 9, 4), (\"Physiology\", 8, 3), (\"Biochemistry\", 7, 3), (\"Pharmacology\", 6, 2), (\"Pathology\", 5, 1)]) == ['Anatomy', 'Physiology', 'Pathology']\n    assert candidate([(\"Calculus\", 10, 5), (\"Linear Algebra\", 9, 4), (\"Discrete Math\", 8, 3), (\"Probability\", 7, 2), (\"Statistics\", 6, 1)]) == ['Linear Algebra', 'Discrete Math', 'Statistics']\n    assert candidate([(\"Math\", 9, 3), (\"Physics\", 8, 4), (\"Chemistry\", 7, 2), (\"Biology\", 6, 3), (\"History\", 5, 2)]) == ['Math', 'Chemistry', 'Biology']\n    assert candidate([(\"Computer Science\", 10, 4), (\"Statistics\", 8, 3), (\"Economics\", 7, 2), (\"Psychology\", 6, 2), (\"Literature\", 5, 1)]) == ['Statistics', 'Economics', 'Psychology', 'Literature']\n    assert candidate([(\"Quantum Mechanics\", 10, 5), (\"Thermodynamics\", 9, 4), (\"Electromagnetism\", 8, 3), (\"Classical Mechanics\", 7, 2), (\"Optics\", 6, 1)]) == ['Thermodynamics', 'Electromagnetism', 'Optics']\n    assert candidate([(\"Art\", 3, 1), (\"Music\", 4, 2), (\"Dance\", 2, 1), (\"Theatre\", 5, 3), (\"Film\", 6, 4)]) == ['Art', 'Music', 'Dance', 'Film']\n", "language": "python"}
{"task_id": "revision1a_problem326", "prompt": "from typing import List, Tuple\n\ndef optimize_delivery_route(packages: List[Tuple[str, int, int]]) -> List[str]:\n    \"\"\"\n    A delivery company wants to optimize their delivery route to save fuel and time.\n    Each package is represented by a tuple containing (destination, weight, urgency).\n    The optimization algorithm should consider the following factors:\n    1. Urgency (1-5, where 5 is most urgent)\n    2. Weight of the package (heavier packages should be delivered earlier to save fuel)\n    3. Proximity of destinations (assume destinations closer in the list are geographically closer)\n    \n    The algorithm should return a list of destinations in the optimal order for delivery.\n    If two packages have the same priority, maintain their original order.\n    \n    Take a list of package tuples as input and return the optimized list of destinations.\n    \n    Example 1:\n    Input: [(\"A\", 10, 3), (\"B\", 5, 4), (\"C\", 15, 2), (\"D\", 8, 5)]\n    Output: [\"D\", \"B\", \"A\", \"C\"]\n    \n    Example 2:\n    Input: [(\"X\", 12, 3), (\"Y\", 8, 3), (\"Z\", 15, 4), (\"W\", 10, 2)]\n    Output: [\"Z\", \"X\", \"Y\", \"W\"]\n    \"\"\"\n", "entry_point": "optimize_delivery_route", "solution": "    def calculate_priority(package: Tuple[str, int, int], index: int) -> float:\n        destination, weight, urgency = package\n        # Normalize weights to be between 0 and 1\n        normalized_weight = weight / max(p[1] for p in packages)\n        # Calculate priority score\n        priority = (urgency * 0.5) + (normalized_weight * 0.3) + ((len(packages) - index) / len(packages) * 0.2)\n        return priority\n\n    # Create a list of tuples with (destination, priority, original_index)\n    prioritized_packages = [(p[0], calculate_priority(p, i), i) for i, p in enumerate(packages)]\n    \n    # Sort the packages based on priority (descending) and original index (ascending)\n    sorted_packages = sorted(prioritized_packages, key=lambda x: (-x[1], x[2]))\n    \n    # Extract the destinations from the sorted list\n    optimized_route = [package[0] for package in sorted_packages]\n    \n    return optimized_route\n", "test": "def check(candidate):\n    assert candidate([(\"X\", 12, 3), (\"Y\", 8, 3), (\"Z\", 15, 4), (\"W\", 10, 2)]) == ['Z', 'X', 'Y', 'W']\n    assert candidate([(\"X\", 15, 4), (\"Y\", 14, 5), (\"Z\", 13, 3)]) == ['Y', 'X', 'Z']\n    assert candidate([(\"M\", 50, 3), (\"N\", 50, 3), (\"O\", 50, 3)]) == ['M', 'N', 'O']\n    assert candidate([(\"P\", 20, 5), (\"Q\", 18, 5), (\"R\", 22, 5), (\"S\", 15, 5)]) == ['P', 'R', 'Q', 'S']\n    assert candidate([(\"A\", 10, 3), (\"B\", 5, 4), (\"C\", 15, 2), (\"D\", 8, 5)]) == ['D', 'B', 'A', 'C']\n    assert candidate([(\"A\", 10, 3), (\"B\", 10, 3), (\"C\", 10, 3), (\"D\", 10, 3)]) == ['A', 'B', 'C', 'D']\n    assert candidate([(\"X\", 100, 1), (\"Y\", 1, 5)]) == ['Y', 'X']\n    assert candidate([(\"P\", 20, 1), (\"Q\", 15, 2), (\"R\", 10, 3), (\"S\", 5, 4), (\"T\", 1, 5)]) == ['T', 'S', 'R', 'Q', 'P']\n    assert candidate([(\"A\", 1, 5), (\"B\", 2, 4), (\"C\", 3, 3), (\"D\", 4, 2), (\"E\", 5, 1)]) == ['A', 'B', 'C', 'D', 'E']\n    assert candidate([(\"M\", 5, 1), (\"N\", 6, 1), (\"O\", 7, 1), (\"P\", 8, 1)]) == ['M', 'N', 'O', 'P']\n", "language": "python"}
{"task_id": "revision1a_problem144", "prompt": "from typing import List, Tuple\nimport threading\n\ndef parallel_matrix_multiplication(A: List[List[int]], B: List[List[int]]) -> List[List[int]]:\n    \"\"\"\n    Implement a parallel matrix multiplication algorithm using threading.\n    Given two matrices A and B, compute their product C = A * B using multiple threads for faster computation.\n    \n    Use the threading module to create and manage threads for parallel computation.\n    Take input from the user for matrices A and B.\n    Return the resulting matrix C.\n\n    Handle potential race conditions and ensure thread safety.\n    If the matrices cannot be multiplied due to incompatible dimensions, raise a ValueError.\n\n    Example:\n    Input: A = [[1, 2], [3, 4]], B = [[5, 6], [7, 8]]\n    Output: [[19, 22], [43, 50]]\n    \"\"\"\n", "entry_point": "parallel_matrix_multiplication", "solution": "    def multiply_row(row: int, col: int) -> None:\n        result = sum(A[row][k] * B[k][col] for k in range(len(B)))\n        with lock:\n            C[row][col] = result\n\n    # Check if matrices can be multiplied\n    if len(A[0]) != len(B):\n        raise ValueError(\"Matrices cannot be multiplied due to incompatible dimensions\")\n\n    rows_A, cols_A = len(A), len(A[0])\n    rows_B, cols_B = len(B), len(B[0])\n\n    # Initialize result matrix C with zeros\n    C = [[0 for _ in range(cols_B)] for _ in range(rows_A)]\n\n    # Create a lock for thread safety\n    lock = threading.Lock()\n\n    # Create and start threads for each element in the result matrix\n    threads = []\n    for i in range(rows_A):\n        for j in range(cols_B):\n            thread = threading.Thread(target=multiply_row, args=(i, j))\n            threads.append(thread)\n            thread.start()\n\n    # Wait for all threads to complete\n    for thread in threads:\n        thread.join()\n\n    return C\n", "test": "def check(candidate):\n    assert candidate([[1], [2], [3]], [[4, 5, 6]]) == [[4, 5, 6], [8, 10, 12], [12, 15, 18]]\n    assert candidate([[1, 2, 3]], [[4], [5], [6]]) == [[32]]\n    assert candidate([[1, 2], [3, 4], [5, 6]], [[7, 8, 9], [10, 11, 12]]) == [[27, 30, 33], [61, 68, 75], [95, 106, 117]]\n    assert candidate([[1, 2, 3], [4, 5, 6]], [[7, 8], [9, 10], [11, 12]]) == [[58, 64], [139, 154]]\n    assert candidate([[0, 0], [0, 0]], [[0, 0], [0, 0]]) == [[0, 0], [0, 0]]\n    assert candidate([[1, 0], [0, 1]], [[5, 6], [7, 8]]) == [[5, 6], [7, 8]]\n    assert candidate([[1]], [[1, 2, 3, 4, 5]]) == [[1, 2, 3, 4, 5]]\n    assert candidate([[1]], [[2]]) == [[2]]\n    assert candidate([[1, 2], [3, 4]], [[5, 6], [7, 8]]) == [[19, 22], [43, 50]]\n    assert candidate([[1, 2, 3], [4, 5, 6], [7, 8, 9]], [[10, 11], [12, 13], [14, 15]]) == [[76, 82], [184, 199], [292, 316]]\n", "language": "python"}
{"task_id": "revision1a_problem411", "prompt": "from typing import List, Tuple\n\ndef optimize_warehouse_layout(items: List[Tuple[str, int, int]]) -> List[str]:\n    \"\"\"\n    You are tasked with optimizing the layout of a warehouse to improve efficiency.\n    Each item in the warehouse has a name, weight, and frequency of access.\n    Your goal is to arrange the items so that frequently accessed items are closer to the entrance.\n\n    Create a class called WarehouseOptimizer that implements the following:\n    1. A method to add items to the warehouse\n    2. A method to calculate the optimal arrangement based on weight and access frequency\n    3. A method to return the final optimized layout\n\n    Take input from the user in the form of a list of tuples, where each tuple contains:\n    (item_name: str, weight: int, access_frequency: int)\n\n    Return the optimized layout as a list of item names, ordered from closest to farthest from the entrance.\n\n    Example:\n    Input: [(\"Book\", 2, 10), (\"Chair\", 15, 3), (\"Lamp\", 5, 7), (\"Table\", 25, 2)]\n    Output: ['Book', 'Lamp', 'Chair', 'Table']\n\n    Input: [(\"Pen\", 1, 20), (\"Desk\", 50, 1), (\"Computer\", 10, 15), (\"Phone\", 2, 18)]\n    Output: ['Pen', 'Phone', 'Computer', 'Desk']\n    \"\"\"\n", "entry_point": "optimize_warehouse_layout", "solution": "    class WarehouseOptimizer:\n        def __init__(self):\n            self.items = []\n\n        def add_item(self, item):\n            self.items.append(item)\n\n        def calculate_optimal_arrangement(self):\n            # Calculate efficiency score (access frequency / weight)\n            for item in self.items:\n                name, weight, frequency = item\n                efficiency = frequency / weight\n                self.items[self.items.index(item)] = (name, weight, frequency, efficiency)\n\n            # Sort items based on efficiency score in descending order\n            self.items.sort(key=lambda x: x[3], reverse=True)\n\n        def get_optimized_layout(self):\n            return [item[0] for item in self.items]\n\n    # Create an instance of WarehouseOptimizer\n    optimizer = WarehouseOptimizer()\n\n    # Add items to the warehouse\n    for item in items:\n        optimizer.add_item(item)\n\n    # Calculate the optimal arrangement\n    optimizer.calculate_optimal_arrangement()\n\n    # Return the optimized layout\n    return optimizer.get_optimized_layout()\n", "test": "def check(candidate):\n    assert candidate([(\"Unique\", 5, 5)]) == ['Unique']\n    assert candidate([(\"Pen\", 1, 20), (\"Desk\", 50, 1), (\"Computer\", 10, 15), (\"Phone\", 2, 18)]) == ['Pen', 'Phone', 'Computer', 'Desk']\n    assert candidate([(\"Shoe\", 1, 5), (\"Hat\", 1, 3), (\"Glove\", 1, 2), (\"Scarf\", 1, 1)]) == ['Shoe', 'Hat', 'Glove', 'Scarf']\n    assert candidate([(\"Item1\", 1, 1), (\"Item2\", 2, 2), (\"Item3\", 3, 3), (\"Item4\", 4, 4), (\"Item5\", 5, 5)]) == ['Item1', 'Item2', 'Item3', 'Item4', 'Item5']\n    assert candidate([(\"A\", 10, 10), (\"B\", 10, 10), (\"C\", 10, 10)]) == ['A', 'B', 'C']\n    assert candidate([(\"Red\", 5, 3), (\"Blue\", 5, 2), (\"Green\", 5, 1), (\"Yellow\", 5, 4)]) == ['Yellow', 'Red', 'Blue', 'Green']\n    assert candidate([(\"Box\", 5, 10), (\"Box\", 3, 15), (\"Box\", 7, 5)]) == ['Box', 'Box', 'Box']\n    assert candidate([(\"Fragile\", 1, 100), (\"Durable\", 100, 1)]) == ['Fragile', 'Durable']\n    assert candidate([(\"Heavy\", 100, 1), (\"Light\", 1, 100)]) == ['Light', 'Heavy']\n    assert candidate([(\"Book\", 2, 10), (\"Chair\", 15, 3), (\"Lamp\", 5, 7), (\"Table\", 25, 2)]) == ['Book', 'Lamp', 'Chair', 'Table']\n", "language": "python"}
{"task_id": "revision1a_problem504", "prompt": "def decrypt_message(encrypted_text: str, shift: int) -> str:\n    \"\"\"\n    As a junior cryptographer at a tech company, you've been tasked with decrypting an important message.\n    The message was encrypted using a Caesar cipher, where each letter in the original text is shifted a certain \n    number of positions down the alphabet. Your job is to write a function that can decrypt the message.\n\n    The function should take two parameters: the encrypted text and the shift value used in the encryption.\n    It should return the decrypted message. Assume that the input will only contain lowercase letters and spaces.\n    Spaces should remain unchanged in the output.\n\n    Example 1:\n    Input: \"khoor zruog\", 3\n    Output: \"hello world\"\n\n    Example 2:\n    Input: \"dwwdfn dw gdzq\", 3\n    Output: \"attack at dawn\"\n\n    Take the encrypted text and shift value as input from the user and return the decrypted message.\n    \"\"\"\n", "entry_point": "decrypt_message", "solution": "    decrypted_text = \"\"\n    for char in encrypted_text:\n        if char.isalpha():\n            # Convert the character to its ASCII value\n            ascii_value = ord(char)\n            # Shift the ASCII value back by the given shift amount\n            shifted_ascii = (ascii_value - 97 - shift) % 26 + 97\n            # Convert the shifted ASCII value back to a character\n            decrypted_char = chr(shifted_ascii)\n            decrypted_text += decrypted_char\n        else:\n            # If the character is not a letter (e.g., space), keep it unchanged\n            decrypted_text += char\n    \n    return decrypted_text\n", "test": "def check(candidate):\n    assert candidate(\"a\", 1) == 'z'\n    assert candidate(\"xyz\", 3) == 'uvw'\n    assert candidate(\"\", 5) == ''\n    assert candidate(\"khoor zruog\", 3) == 'hello world'\n    assert candidate(\"z\", 1) == 'y'\n    assert candidate(\"hello\", 0) == 'hello'\n    assert candidate(\"abc\", 26) == 'abc'\n    assert candidate(\"test message\", 1) == 'sdrs ldrrzfd'\n    assert candidate(\"qrstuvwxyzabcdefghijklmnop\", 16) == 'abcdefghijklmnopqrstuvwxyz'\n    assert candidate(\"dwwdfn dw gdzq\", 3) == 'attack at dawn'\n", "language": "python"}
{"task_id": "revision1a_problem430", "prompt": "from typing import List, Dict\nimport re\n\ndef analyze_social_media_trends(posts: List[str]) -> Dict[str, int]:\n    \"\"\"\n    A social media analyst needs to identify trending topics in user posts.\n    Create a function that takes a list of social media posts and returns a \n    dictionary of the top 5 most frequently used hashtags along with their counts.\n\n    Requirements:\n    1. Ignore case sensitivity in hashtags\n    2. Remove any special characters attached to hashtags\n    3. Count multiple occurrences of the same hashtag in a single post\n    4. If there are fewer than 5 unique hashtags, return all of them\n\n    Use regular expressions and dictionary manipulation to solve this problem.\n\n    Example:\n    Input: [\n        \"I love #Python! #coding #programming\",\n        \"Beautiful day for #hiking! #nature #outdoors\",\n        \"Just finished a great #book. #reading #LITERATURE\",\n        \"#Python is awesome for #DataScience and #MachineLearning\"\n    ]\n    Output: {\n        'python': 2,\n        'coding': 1,\n        'programming': 1,\n        'hiking': 1,\n        'nature': 1\n    }\n    \"\"\"\n", "entry_point": "analyze_social_media_trends", "solution": "    hashtag_counts = {}\n    \n    # Regular expression pattern to match hashtags\n    hashtag_pattern = r'#(\\w+)'\n    \n    for post in posts:\n        # Find all hashtags in the post\n        hashtags = re.findall(hashtag_pattern, post)\n        \n        # Count hashtags in the current post\n        post_hashtags = {}\n        for hashtag in hashtags:\n            cleaned_hashtag = re.sub(r'[^\\w]', '', hashtag.lower())\n            post_hashtags[cleaned_hashtag] = post_hashtags.get(cleaned_hashtag, 0) + 1\n        \n        # Update the overall hashtag counts\n        for hashtag, count in post_hashtags.items():\n            hashtag_counts[hashtag] = hashtag_counts.get(hashtag, 0) + count\n    \n    # Sort hashtags by count in descending order\n    sorted_hashtags = sorted(hashtag_counts.items(), key=lambda x: x[1], reverse=True)\n    \n    # Get the top 5 hashtags (or all if fewer than 5)\n    top_hashtags = dict(sorted_hashtags[:5])\n    \n    return top_hashtags\n", "test": "def check(candidate):\n    assert candidate([\"#Python is amazing! #Coding #Programming\", \"#Python #DataScience #MachineLearning\", \"I love #coding and #programming!\"]) == {'python': 2, 'coding': 2, 'programming': 2, 'datascience': 1, 'machinelearning': 1}\n    assert candidate([\"#Sports #Football #Soccer\", \"#Basketball #NBA\", \"#Tennis #Wimbledon\", \"#Olympics #Gold\"]) == {'sports': 1, 'football': 1, 'soccer': 1, 'basketball': 1, 'nba': 1}\n    assert candidate([\"#Movie #Film #Cinema\", \"#TVSeries #Binge\", \"#Hollywood #Oscars\", \"#Bollywood #Blockbuster\"]) == {'movie': 1, 'film': 1, 'cinema': 1, 'tvseries': 1, 'binge': 1}\n    assert candidate([\"No hashtags in this post\", \"Still no hashtags here\", \"One more without hashtags\"]) == {}\n    assert candidate([\"#Art #Painting #Creativity\", \"#Photography #DigitalArt\", \"#Sculpture #Gallery\", \"#StreetArt #Graffiti\"]) == {'art': 1, 'painting': 1, 'creativity': 1, 'photography': 1, 'digitalart': 1}\n    assert candidate([\"#Travel #Adventure #Explore\", \"#Travel #Photography\", \"#Adventure #Nature\", \"#Explore #Photography\", \"#Nature #Outdoors\"]) == {'travel': 2, 'adventure': 2, 'explore': 2, 'photography': 2, 'nature': 2}\n    assert candidate([\"#Music #Rock #Guitar\", \"#ClassicalMusic #Piano\", \"#Jazz #Saxophone\", \"#HipHop #Rap\"]) == {'music': 1, 'rock': 1, 'guitar': 1, 'classicalmusic': 1, 'piano': 1}\n    assert candidate([\"#OneHashtag\", \"#TwoHashtags #TwoHashtags\", \"#ThreeHashtags #ThreeHashtags #ThreeHashtags\"]) == {'threehashtags': 3, 'twohashtags': 2, 'onehashtag': 1}\n    assert candidate([\"#Food #Cooking #Recipe\", \"#HealthyEating #Nutrition\", \"#Foodie #Delicious\", \"#MealPrep #HealthyLiving\"]) == {'food': 1, 'cooking': 1, 'recipe': 1, 'healthyeating': 1, 'nutrition': 1}\n    assert candidate([\"#Tech #Innovation #Startup\", \"#Business #Entrepreneur\", \"#Tech #Startup #Innovation\", \"#Entrepreneur #Startup #Tech\"]) == {'tech': 3, 'startup': 3, 'innovation': 2, 'entrepreneur': 2, 'business': 1}\n", "language": "python"}
{"task_id": "revision1a_problem683", "prompt": "import heapq\nfrom typing import List, Tuple\n\ndef optimize_delivery_route(packages: List[Tuple[str, int, int]]) -> List[str]:\n    \"\"\"\n    A delivery company wants to optimize their route for package delivery in a city.\n    Each package has a destination, weight, and priority level.\n    The company wants to deliver packages in order of priority, but also wants to minimize the total weight carried at any time.\n    \n    Implement a system that takes a list of packages (destination, weight, priority) and returns the optimal order of deliveries.\n    Use a priority queue (heap) to manage the packages based on their priority, and implement a weight limit for the delivery vehicle.\n    \n    Input: List of tuples (destination, weight, priority)\n    Output: List of destinations in the order they should be visited\n    \n    Example:\n    Input: [(\"A\", 10, 2), (\"B\", 5, 1), (\"C\", 20, 3), (\"D\", 15, 2)]\n    Output: [\"B\", \"A\", \"D\", \"C\"]\n    \n    Note: Assume the delivery vehicle has a weight limit of 30 units.\n    \"\"\"\n", "entry_point": "optimize_delivery_route", "solution": "    WEIGHT_LIMIT = 30\n    \n    # Create a min heap based on priority (lower value = higher priority)\n    priority_queue = [(priority, weight, destination) for destination, weight, priority in packages]\n    heapq.heapify(priority_queue)\n    \n    route = []\n    current_weight = 0\n    waiting_packages = []\n    \n    while priority_queue or waiting_packages:\n        while priority_queue and current_weight + priority_queue[0][1] <= WEIGHT_LIMIT:\n            _, weight, destination = heapq.heappop(priority_queue)\n            route.append(destination)\n            current_weight += weight\n        \n        if not priority_queue and waiting_packages:\n            priority_queue = waiting_packages\n            waiting_packages = []\n            current_weight = 0\n        elif priority_queue:\n            waiting_packages.append(heapq.heappop(priority_queue))\n    \n    return route\n", "test": "def check(candidate):\n    assert candidate([]) == []\n    assert candidate([(\"Dest1\", 10, 1), (\"Dest2\", 10, 1), (\"Dest3\", 10, 1)]) == ['Dest1', 'Dest2', 'Dest3']\n    assert candidate([(\"X\", 15, 1), (\"Y\", 15, 1)]) == ['X', 'Y']\n    assert candidate([(\"A\", 10, 2), (\"B\", 5, 1), (\"C\", 20, 3), (\"D\", 15, 2)]) == ['B', 'A', 'D', 'C']\n    assert candidate([(\"X\", 30, 1), (\"Y\", 30, 2), (\"Z\", 30, 3)]) == ['X', 'Y', 'Z']\n    assert candidate([(\"A\", 29, 1), (\"B\", 1, 2)]) == ['A', 'B']\n    assert candidate([(\"A\", 1, 100), (\"B\", 1, 99), (\"C\", 1, 98), (\"D\", 1, 97), (\"E\", 1, 96)]) == ['E', 'D', 'C', 'B', 'A']\n    assert candidate([(\"City1\", 10, 5), (\"City2\", 15, 4), (\"City3\", 20, 3), (\"City4\", 25, 2), (\"City5\", 30, 1)]) == ['City5', 'City4', 'City3', 'City1', 'City2']\n    assert candidate([(\"P1\", 5, 1), (\"P2\", 5, 1), (\"P3\", 5, 1), (\"P4\", 5, 1), (\"P5\", 5, 1), (\"P6\", 5, 1)]) == ['P1', 'P2', 'P3', 'P4', 'P5', 'P6']\n    assert candidate([(\"Place1\", 30, 1)]) == ['Place1']\n", "language": "python"}
{"task_id": "revision1a_problem342", "prompt": "from typing import List, Tuple\n\ndef optimize_factory_layout(machines: List[Tuple[int, int]], factory_width: int) -> int:\n    \"\"\"\n    A factory manager needs to optimize the layout of machines on the factory floor.\n    Each machine is represented by a tuple (length, height). The factory has a fixed width,\n    and machines can be placed in rows. The goal is to minimize the total height of the layout.\n\n    Write a function that takes a list of machine dimensions and the factory width as input,\n    and returns the minimum possible height of the optimized layout.\n\n    The function should use dynamic programming to solve this optimization problem.\n\n    Example:\n    Input: machines = [(2, 3), (3, 2), (4, 5), (5, 4)], factory_width = 10\n    Output: 7\n\n    Explanation: The optimal layout would be:\n    Row 1: (2, 3) (3, 2) (5, 4) - Height: 4\n    Row 2: (4, 5) - Height: 5\n    Total minimum height: 4 + 5 = 9\n    \"\"\"\n", "entry_point": "optimize_factory_layout", "solution": "    n = len(machines)\n    dp = [float('inf')] * (n + 1)\n    dp[0] = 0\n\n    for i in range(1, n + 1):\n        width = 0\n        height = 0\n        for j in range(i, 0, -1):\n            width += machines[j-1][0]\n            if width > factory_width:\n                break\n            height = max(height, machines[j-1][1])\n            dp[i] = min(dp[i], dp[j-1] + height)\n\n    return dp[n]\n", "test": "def check(candidate):\n    assert candidate([(1, 1), (2, 2), (3, 3)], 6) == 3\n    assert candidate([(5, 5)], 5) == 5\n    assert candidate([(2, 1), (2, 1), (2, 1), (2, 1)], 4) == 2\n    assert candidate([(1, 1)], 1) == 1\n    assert candidate([(3, 3), (3, 3), (3, 3), (3, 3)], 6) == 6\n    assert candidate([(10, 1), (10, 1), (10, 1)], 30) == 1\n    assert candidate([], 100) == 0\n    assert candidate([(1, 10), (1, 10), (1, 10)], 3) == 10\n    assert candidate([(2, 3), (3, 2), (4, 5), (5, 4)], 10) == 8\n    assert candidate([(1, 5), (2, 4), (3, 3), (4, 2), (5, 1)], 15) == 5\n", "language": "python"}
{"task_id": "revision1a_problem560", "prompt": "from functools import lru_cache\nfrom typing import List, Tuple\n\ndef optimize_wind_farm(grid: List[List[int]], n: int) -> Tuple[int, List[Tuple[int, int]]]:\n    \"\"\"\n    A renewable energy company is planning to build a wind farm. They have a grid representing a potential area for the farm,\n    where each cell contains a value indicating the average wind speed at that location. The company wants to place n wind turbines\n    in the grid to maximize the total wind energy captured.\n    \n    Your task is to implement a function that takes a 2D grid of wind speeds and the number of turbines to be placed (n) as input.\n    The function should return the maximum total wind speed that can be captured and the coordinates of the turbine placements.\n    \n    Constraints:\n    1. No two turbines can be placed in adjacent cells (including diagonally adjacent).\n    2. The goal is to maximize the sum of wind speeds at the chosen locations.\n    \n    This problem requires using dynamic programming or backtracking with memoization to achieve an optimal solution.\n    \n    Example:\n    Input: \n    grid = [\n        [1, 3, 4],\n        [4, 5, 2],\n        [2, 4, 5]\n    ]\n    n = 3\n    \n    Output: (14, [(0, 2), (1, 0), (2, 2)])\n    \n    Explanation: Placing turbines at (0,2), (1,0), and (2,2) gives wind speeds of 4 + 4 + 5 = 14, which is the maximum possible for 3 turbines.\n    \"\"\"\n", "entry_point": "optimize_wind_farm", "solution": "    rows, cols = len(grid), len(grid[0])\n    \n    def is_valid(r, c):\n        return 0 <= r < rows and 0 <= c < cols\n    \n    def get_neighbors(r, c):\n        directions = [(-1, -1), (-1, 0), (-1, 1), (0, -1), (0, 1), (1, -1), (1, 0), (1, 1)]\n        return [(r + dr, c + dc) for dr, dc in directions if is_valid(r + dr, c + dc)]\n    \n    memo = {}\n    \n    def dfs(r, c, remaining):\n        if remaining == 0:\n            return 0, []\n        \n        if r >= rows:\n            return 0, []\n        \n        if c >= cols:\n            return dfs(r + 1, 0, remaining)\n        \n        key = (r, c, remaining)\n        if key in memo:\n            return memo[key]\n        \n        # Skip current cell\n        skip_value, skip_coords = dfs(r, c + 1, remaining)\n        \n        # Place turbine at current cell\n        place_value, place_coords = 0, []\n        if all(grid[nr][nc] != -1 for nr, nc in get_neighbors(r, c)):\n            grid_copy = [row[:] for row in grid]\n            grid_copy[r][c] = -1\n            for nr, nc in get_neighbors(r, c):\n                grid_copy[nr][nc] = -1\n            \n            sub_value, sub_coords = dfs(r, c + 1, remaining - 1)\n            place_value = grid[r][c] + sub_value\n            place_coords = [(r, c)] + sub_coords\n        \n        if place_value > skip_value:\n            result = (place_value, place_coords)\n        else:\n            result = (skip_value, skip_coords)\n        \n        memo[key] = result\n        return result\n    \n    max_wind_speed, turbine_coords = dfs(0, 0, n)\n    return max_wind_speed, turbine_coords\n\n", "test": "def check(candidate):\n    assert candidate([[100, 1, 100], [1, 1, 1], [100, 1, 100]], 4) == (400, [(0, 0), (0, 2), (2, 0), (2, 2)])\n    assert candidate([[1]], 1) == (1, [(0, 0)])\n    assert candidate([[10]], 1) == (10, [(0, 0)])\n    assert candidate([[1, 2, 3, 4], [5, 6, 7, 8], [9, 10, 11, 12], [13, 14, 15, 16]], 4) == (58, [(3, 0), (3, 1), (3, 2), (3, 3)])\n    assert candidate([[1, 2], [3, 4]], 0) == (0, [])\n    assert candidate([[1, 2, 3], [4, 5, 6], [7, 8, 9]], 2) == (17, [(2, 1), (2, 2)])\n    assert candidate([[1, 1, 1], [1, 1, 1], [1, 1, 1]], 3) == (3, [(2, 0), (2, 1), (2, 2)])\n    assert candidate([[1, 2, 3], [4, 5, 6], [7, 8, 9]], 5) == (35, [(1, 1), (1, 2), (2, 0), (2, 1), (2, 2)])\n    assert candidate([[1, 2, 3], [4, 5, 6], [7, 8, 9]], 1) == (9, [(2, 2)])\n    assert candidate([[1, 2], [3, 4]], 1) == (4, [(1, 1)])\n", "language": "python"}
{"task_id": "revision1a_problem717", "prompt": "def find_longest_palindrome_substring(s: str) -> str:\n    \"\"\"\n    A detective is investigating a case where the clue is hidden in the longest palindrome substring within a given string.\n    Your task is to help the detective by writing a function that finds the longest palindrome substring in a given string.\n    A palindrome is a word, phrase, number, or other sequence of characters that reads the same forward and backward.\n    The function should take a string as input and return the longest palindrome substring found.\n    If there are multiple palindromes with the same maximum length, return the first one encountered.\n\n    Example:\n    Input: \"babad\"\n    Output: \"bab\"\n    Input: \"cbbd\"\n    Output: \"bb\"\n    Input: \"a\"\n    Output: \"a\"\n    \"\"\"\n", "entry_point": "find_longest_palindrome_substring", "solution": "    def expand_around_center(left: int, right: int) -> str:\n        while left >= 0 and right < len(s) and s[left] == s[right]:\n            left -= 1\n            right += 1\n        return s[left + 1:right]\n\n    if len(s) < 2:\n        return s\n\n    longest_palindrome = \"\"\n\n    for i in range(len(s)):\n        # Check for odd-length palindromes\n        odd_palindrome = expand_around_center(i, i)\n        if len(odd_palindrome) > len(longest_palindrome):\n            longest_palindrome = odd_palindrome\n\n        # Check for even-length palindromes\n        even_palindrome = expand_around_center(i, i + 1)\n        if len(even_palindrome) > len(longest_palindrome):\n            longest_palindrome = even_palindrome\n\n    return longest_palindrome\n", "test": "def check(candidate):\n    assert candidate(\"abba\") == 'abba'\n    assert candidate(\"aaaaaa\") == 'aaaaaa'\n    assert candidate(\"abcde\") == 'a'\n    assert candidate(\"hello\") == 'll'\n    assert candidate(\"babad\") == 'bab'\n    assert candidate(\"a\") == 'a'\n    assert candidate(\"cbbd\") == 'bb'\n    assert candidate(\"racecar\") == 'racecar'\n    assert candidate(\"abb\") == 'bb'\n    assert candidate(\"abcdefedcba\") == 'abcdefedcba'\n", "language": "python"}
{"task_id": "revision1a_problem159", "prompt": "from typing import List, Tuple\n\ndef optimize_traffic_flow(intersections: List[Tuple[int, int, int]]) -> List[int]:\n    \"\"\"\n    A city planner is working on optimizing traffic flow in a grid-like city.\n    Each intersection has traffic lights that can be set to different timings.\n    The goal is to minimize the overall waiting time for vehicles at all intersections.\n\n    This function takes a list of tuples representing intersections, where each tuple\n    contains (x-coordinate, y-coordinate, traffic_volume), and returns a list of \n    optimal green light durations for each intersection.\n\n    Example:\n    Input: intersections = [(0, 0, 100), (0, 1, 50), (1, 0, 75), (1, 1, 125)]\n    Output: [30, 15, 22, 37]\n\n    Explanation:\n    The output list represents the optimal green light duration (in seconds) for each\n    intersection, proportional to its traffic volume and considering its position in the grid.\n\n    Args:\n    intersections (List[Tuple[int, int, int]]): A list of tuples, each containing the \n    x-coordinate, y-coordinate, and traffic volume of an intersection.\n\n    Returns:\n    List[int]: A list of integers representing the optimal green light duration for each intersection.\n    \"\"\"\n", "entry_point": "optimize_traffic_flow", "solution": "    def calculate_weight(x: int, y: int) -> float:\n        # Assign higher weight to intersections closer to the center\n        max_coord = max(max(x for x, _, _ in intersections), max(y for _, y, _ in intersections))\n        center = max_coord / 2\n        distance_from_center = ((x - center) ** 2 + (y - center) ** 2) ** 0.5\n        return 1 + (center - distance_from_center) / center\n\n    total_volume = sum(volume for _, _, volume in intersections)\n    total_duration = 100  # Assuming a total cycle time of 100 seconds\n\n    optimal_durations = []\n    for x, y, volume in intersections:\n        weight = calculate_weight(x, y)\n        adjusted_volume = volume * weight\n        duration = int(round((adjusted_volume / total_volume) * total_duration))\n        optimal_durations.append(duration)\n\n    # Normalize durations to ensure they sum up to total_duration\n    total_optimal_duration = sum(optimal_durations)\n    scaling_factor = total_duration / total_optimal_duration\n    optimal_durations = [int(round(duration * scaling_factor)) for duration in optimal_durations]\n\n    # Adjust for any rounding errors\n    while sum(optimal_durations) != total_duration:\n        if sum(optimal_durations) < total_duration:\n            optimal_durations[optimal_durations.index(min(optimal_durations))] += 1\n        else:\n            optimal_durations[optimal_durations.index(max(optimal_durations))] -= 1\n\n    return optimal_durations\n", "test": "def check(candidate):\n    assert candidate([(i, j, 100) for i in range(5) for j in range(5)]) == [2, 4, 4, 4, 2, 4, 4, 5, 5, 4, 4, 5, 5, 5, 4, 4, 5, 5, 5, 4, 2, 4, 4, 4, 2]\n    assert candidate([(0, 0, 100), (10, 10, 100)]) == [50, 50]\n    assert candidate([(0, 0, 100), (0, 1, 200), (0, 2, 300), (1, 0, 400), (1, 1, 500)]) == [3, 11, 10, 22, 54]\n    assert candidate([(0, 0, 100), (0, 1, 100), (0, 2, 100), (1, 0, 100), (1, 1, 100), (1, 2, 100)]) == [10, 16, 10, 16, 32, 16]\n    assert candidate([(0, 0, 10), (0, 1, 20), (0, 2, 30), (1, 0, 40), (1, 1, 50), (1, 2, 60), (2, 0, 70), (2, 1, 80), (2, 2, 90)]) == [1, 4, 4, 10, 24, 14, 10, 20, 13]\n    assert candidate([(0, 0, 50), (1, 1, 150), (2, 2, 250), (3, 3, 350)]) == [4, 27, 45, 24]\n    assert candidate([(0, 0, 999), (0, 1, 1), (1, 0, 1), (1, 1, 999)]) == [50, 0, 0, 50]\n    assert candidate([(0, 0, 100), (0, 1, 50), (1, 0, 75), (1, 1, 125)]) == [29, 14, 22, 35]\n    assert candidate([(0, 0, 1), (0, 1, 1), (1, 0, 1), (1, 1, 1)]) == [25, 25, 25, 25]\n    assert candidate([(0, 0, 1000), (1, 1, 1000)]) == [50, 50]\n", "language": "python"}
{"task_id": "revision1a_problem315", "prompt": "def longest_palindrome(s: str) -> str:\n    \"\"\"\n    A bookstore owner wants to find the longest palindromic substring in a given book title to use as a promotional code.\n    A palindrome is a word, phrase, number, or other sequence of characters that reads the same forward and backward.\n    Write a function that takes a string as input and returns the longest palindromic substring.\n    If there are multiple palindromic substrings with the same maximum length, return the first one that occurs.\n\n    Example 1:\n    Input: \"babad\"\n    Output: \"bab\"\n    Note: \"aba\" is also a valid answer.\n\n    Example 2:\n    Input: \"cbbd\"\n    Output: \"bb\"\n\n    Example 3:\n    Input: \"racecar\"\n    Output: \"racecar\"\n    \"\"\"\n", "entry_point": "longest_palindrome", "solution": "    def expand_around_center(left: int, right: int) -> str:\n        while left >= 0 and right < len(s) and s[left] == s[right]:\n            left -= 1\n            right += 1\n        return s[left + 1:right]\n\n    if len(s) < 2:\n        return s\n\n    longest = \"\"\n    for i in range(len(s)):\n        # Check for odd-length palindromes\n        palindrome1 = expand_around_center(i, i)\n        if len(palindrome1) > len(longest):\n            longest = palindrome1\n\n        # Check for even-length palindromes\n        palindrome2 = expand_around_center(i, i + 1)\n        if len(palindrome2) > len(longest):\n            longest = palindrome2\n\n    return longest\n", "test": "def check(candidate):\n    assert candidate(\"abba\") == 'abba'\n    assert candidate(\"a\") == 'a'\n    assert candidate(\"abcdefg\") == 'a'\n    assert candidate(\"cbbd\") == 'bb'\n    assert candidate(\"racecar\") == 'racecar'\n    assert candidate(\"abcba\") == 'abcba'\n    assert candidate(\"babad\") == 'bab'\n    assert candidate(\"aa\") == 'aa'\n    assert candidate(\"aaa\") == 'aaa'\n    assert candidate(\"aabbaa\") == 'aabbaa'\n", "language": "python"}
{"task_id": "revision1a_problem94", "prompt": "import heapq\nfrom typing import List, Tuple\nfrom collections import deque\n\ndef optimize_delivery_route(warehouses: List[Tuple[int, int]], orders: List[Tuple[int, int]], fuel: int) -> List[int]:\n    \"\"\"\n    You are a delivery driver for an e-commerce company. You need to optimize your delivery route to fulfill as many\n    orders as possible with the given amount of fuel. You start at the origin (0, 0).\n\n    Write a function that takes three parameters:\n    1. A list of tuples representing warehouse locations (x, y coordinates)\n    2. A list of tuples representing order locations (x, y coordinates)\n    3. An integer representing the amount of fuel you have\n\n    The function should return a list of indices representing the optimal order of deliveries to maximize the number\n    of fulfilled orders. If multiple solutions exist, return any valid solution.\n\n    Assume that:\n    - You can refuel at any warehouse for free\n    - Each unit of fuel allows you to move one unit in any direction (up, down, left, or right)\n    - You must visit a warehouse before fulfilling any orders\n\n    Example:\n    Input: \n    warehouses = [(1, 1), (3, 3)]\n    orders = [(0, 2), (2, 2), (4, 4)]\n    fuel = 10\n    Output: [0, 1, 2]\n\n    Explanation: Visit warehouse at (1, 1), then deliver to (0, 2) and (2, 2), then visit warehouse at (3, 3),\n    and finally deliver to (4, 4).\n    \"\"\"\n", "entry_point": "optimize_delivery_route", "solution": "    def manhattan_distance(p1, p2):\n        return abs(p1[0] - p2[0]) + abs(p1[1] - p2[1])\n\n    def nearest_warehouse(pos, warehouses):\n        return min(warehouses, key=lambda w: manhattan_distance(pos, w))\n\n    current_pos = (0, 0)\n    fulfilled_orders = []\n    remaining_orders = list(enumerate(orders))\n    \n    while fuel > 0 and remaining_orders:\n        nearest_wh = nearest_warehouse(current_pos, warehouses)\n        fuel_to_wh = manhattan_distance(current_pos, nearest_wh)\n        \n        if fuel < fuel_to_wh:\n            break\n        \n        fuel -= fuel_to_wh\n        current_pos = nearest_wh\n        \n        deliverable = []\n        for i, order in remaining_orders:\n            dist = manhattan_distance(current_pos, order)\n            if dist <= fuel:\n                heapq.heappush(deliverable, (dist, i, order))\n        \n        while deliverable:\n            dist, i, order = heapq.heappop(deliverable)\n            if dist <= fuel:\n                fuel -= dist\n                current_pos = order\n                fulfilled_orders.append(i)\n                remaining_orders = [o for o in remaining_orders if o[0] != i]\n            else:\n                break\n    \n    return fulfilled_orders\n", "test": "def check(candidate):\n    assert candidate([], [], 100) == []\n    assert candidate([(0, 0)], [], 50) == []\n    assert candidate([(-1, -1), (1, 1)], [(0, 0), (2, 2)], 5) == [0]\n    assert candidate([(1, 1)], [(0, 0)], 2) == []\n    assert candidate([(0, 0), (5, 5)], [(1, 1), (2, 2), (6, 6)], 10) == [0, 1]\n    assert candidate([(0, 0)], [(1, 1)], 2) == [0]\n    assert candidate([(10, 10)], [(11, 11)], 2) == []\n", "language": "python"}
{"task_id": "revision1a_problem287", "prompt": "import math\nfrom typing import List, Tuple\nimport itertools\n\ndef optimize_delivery_route(locations: List[Tuple[float, float]], start: Tuple[float, float], end: Tuple[float, float]) -> List[Tuple[float, float]]:\n    \"\"\"\n    As a logistics manager for a delivery company, you need to optimize the route for a delivery truck.\n    The truck needs to visit multiple locations before reaching its final destination.\n    \n    Your task is to implement the Traveling Salesman Problem (TSP) algorithm to find the shortest possible route\n    that visits each location exactly once, starting from the given start point and ending at the specified end point.\n    \n    Use dynamic programming to solve this NP-hard problem efficiently.\n    \n    Parameters:\n    locations (List[Tuple[float, float]]): List of (latitude, longitude) coordinates for each delivery location\n    start (Tuple[float, float]): Starting point coordinates\n    end (Tuple[float, float]): Final destination coordinates\n    \n    Returns:\n    List[Tuple[float, float]]: Optimized route as a list of coordinates, including start and end points\n    \n    Example:\n    Input: \n    locations = [(40.7128, -74.0060), (34.0522, -118.2437), (41.8781, -87.6298), (29.7604, -95.3698)]\n    start = (38.9072, -77.0369)\n    end = (33.7490, -84.3880)\n    \n    Output:\n    [(38.9072, -77.0369), (40.7128, -74.0060), (41.8781, -87.6298), (29.7604, -95.3698), (34.0522, -118.2437), (33.7490, -84.3880)]\n    \n    This represents the optimized route from Washington D.C. (start) to Atlanta (end), passing through New York, Chicago, Houston, and Los Angeles.\n    \"\"\"\n", "entry_point": "optimize_delivery_route", "solution": "    def distance(point1: Tuple[float, float], point2: Tuple[float, float]) -> float:\n        lat1, lon1 = point1\n        lat2, lon2 = point2\n        return math.sqrt((lat2 - lat1)**2 + (lon2 - lon1)**2)\n\n    all_points = [start] + locations + [end]\n    n = len(all_points)\n    \n    # Create distance matrix\n    dist = [[distance(all_points[i], all_points[j]) for j in range(n)] for i in range(n)]\n    \n    # Initialize DP table\n    dp = {}\n    \n    def tsp(mask: int, pos: int) -> Tuple[float, List[int]]:\n        if mask == ((1 << n) - 1):\n            return dist[pos][n-1], [pos, n-1]\n        \n        if (mask, pos) in dp:\n            return dp[(mask, pos)]\n        \n        ans = float('inf')\n        best_path = []\n        \n        for city in range(n-1):\n            if city != pos and not (mask & (1 << city)):\n                new_mask = mask | (1 << city)\n                d, path = tsp(new_mask, city)\n                d += dist[pos][city]\n                \n                if d < ans:\n                    ans = d\n                    best_path = [pos] + path\n        \n        dp[(mask, pos)] = (ans, best_path)\n        return ans, best_path\n    \n    _, path = tsp(1, 0)\n    \n    optimized_route = [all_points[i] for i in path]\n    return optimized_route\n", "test": "def check(candidate):\n    assert candidate([(51.5074, -0.1278), (48.8566, 2.3522), (52.5200, 13.4050)], (40.7128, -74.0060), (41.9028, 12.4964)) == []\n    assert candidate([(40.7128, -74.0060), (34.0522, -118.2437), (41.8781, -87.6298), (29.7604, -95.3698)], (38.9072, -77.0369), (33.7490, -84.3880)) == []\n", "language": "python"}
{"task_id": "revision1a_problem655", "prompt": "from typing import List, Tuple\n\ndef optimize_warehouse_layout(items: List[Tuple[int, int, int]], warehouse_dimensions: Tuple[int, int, int]) -> List[Tuple[int, int, int]]:\n    \"\"\"\n    A logistics company wants to optimize their warehouse layout for efficient storage and retrieval of items.\n    Given a list of items with their dimensions (length, width, height) and the warehouse dimensions,\n    determine the optimal placement of items to maximize space utilization.\n\n    The function should return a list of 3D coordinates (x, y, z) representing the optimal position\n    for each item in the warehouse. Items cannot overlap, and all items must fit within the warehouse dimensions.\n    If it's impossible to fit all items, return an empty list.\n\n    This problem involves 3D bin packing, which is NP-hard. Implement a heuristic algorithm to find a good,\n    if not optimal, solution.\n\n    Parameters:\n    items (List[Tuple[int, int, int]]): List of item dimensions (length, width, height)\n    warehouse_dimensions (Tuple[int, int, int]): Dimensions of the warehouse (length, width, height)\n\n    Returns:\n    List[Tuple[int, int, int]]: List of 3D coordinates for item placements, or empty list if impossible\n\n    Example:\n    Input: \n    items = [(2, 2, 2), (3, 3, 3), (1, 1, 4)]\n    warehouse_dimensions = (5, 5, 5)\n    Output: [(0, 0, 0), (2, 0, 0), (0, 2, 0)]\n\n    Input:\n    items = [(3, 3, 3), (3, 3, 3), (3, 3, 3)]\n    warehouse_dimensions = (5, 5, 5)\n    Output: []\n    \"\"\"\n", "entry_point": "optimize_warehouse_layout", "solution": "    def can_place_item(item: Tuple[int, int, int], position: Tuple[int, int, int], occupied: set) -> bool:\n        x, y, z = position\n        l, w, h = item\n        if x + l > warehouse_dimensions[0] or y + w > warehouse_dimensions[1] or z + h > warehouse_dimensions[2]:\n            return False\n        for dx in range(l):\n            for dy in range(w):\n                for dz in range(h):\n                    if (x + dx, y + dy, z + dz) in occupied:\n                        return False\n        return True\n\n    def place_item(item: Tuple[int, int, int], position: Tuple[int, int, int], occupied: set) -> None:\n        x, y, z = position\n        l, w, h = item\n        for dx in range(l):\n            for dy in range(w):\n                for dz in range(h):\n                    occupied.add((x + dx, y + dy, z + dz))\n\n    # Sort items by volume in descending order\n    sorted_items = sorted(enumerate(items), key=lambda x: x[1][0] * x[1][1] * x[1][2], reverse=True)\n    \n    occupied = set()\n    placements = [None] * len(items)\n\n    for index, item in sorted_items:\n        placed = False\n        for x in range(warehouse_dimensions[0]):\n            for y in range(warehouse_dimensions[1]):\n                for z in range(warehouse_dimensions[2]):\n                    if can_place_item(item, (x, y, z), occupied):\n                        place_item(item, (x, y, z), occupied)\n                        placements[index] = (x, y, z)\n                        placed = True\n                        break\n                if placed:\n                    break\n            if placed:\n                break\n        if not placed:\n            return []  # Impossible to place all items\n\n    return placements\n\n", "test": "def check(candidate):\n    assert candidate([(1, 2, 3), (3, 2, 1), (2, 3, 1)], (3, 3, 3)) == []\n    assert candidate([(10, 10, 10)], (9, 9, 9)) == []\n    assert candidate([], (10, 10, 10)) == []\n    assert candidate([(1, 1, 1)], (1, 1, 1)) == [(0, 0, 0)]\n    assert candidate([(2, 2, 2), (3, 3, 3), (1, 1, 4)], (5, 5, 5)) == [(0, 0, 3), (0, 0, 0), (0, 3, 0)]\n    assert candidate([(3, 3, 3), (3, 3, 3), (3, 3, 3)], (5, 5, 5)) == []\n    assert candidate([(1, 1, 1)] * 1000, (10, 10, 10)) == [(0, 0, 0), (0, 0, 1), (0, 0, 2), (0, 0, 3), (0, 0, 4), (0, 0, 5), (0, 0, 6), (0, 0, 7), (0, 0, 8), (0, 0, 9), (0, 1, 0), (0, 1, 1), (0, 1, 2), (0, 1, 3), (0, 1, 4), (0, 1, 5), (0, 1, 6), (0, 1, 7), (0, 1, 8), (0, 1, 9), (0, 2, 0), (0, 2, 1), (0, 2, 2), (0, 2, 3), (0, 2, 4), (0, 2, 5), (0, 2, 6), (0, 2, 7), (0, 2, 8), (0, 2, 9), (0, 3, 0), (0, 3, 1), (0, 3, 2), (0, 3, 3), (0, 3, 4), (0, 3, 5), (0, 3, 6), (0, 3, 7), (0, 3, 8), (0, 3, 9), (0, 4, 0), (0, 4, 1), (0, 4, 2), (0, 4, 3), (0, 4, 4), (0, 4, 5), (0, 4, 6), (0, 4, 7), (0, 4, 8), (0, 4, 9), (0, 5, 0), (0, 5, 1), (0, 5, 2), (0, 5, 3), (0, 5, 4), (0, 5, 5), (0, 5, 6), (0, 5, 7), (0, 5, 8), (0, 5, 9), (0, 6, 0), (0, 6, 1), (0, 6, 2), (0, 6, 3), (0, 6, 4), (0, 6, 5), (0, 6, 6), (0, 6, 7), (0, 6, 8), (0, 6, 9), (0, 7, 0), (0, 7, 1), (0, 7, 2), (0, 7, 3), (0, 7, 4), (0, 7, 5), (0, 7, 6), (0, 7, 7), (0, 7, 8), (0, 7, 9), (0, 8, 0), (0, 8, 1), (0, 8, 2), (0, 8, 3), (0, 8, 4), (0, 8, 5), (0, 8, 6), (0, 8, 7), (0, 8, 8), (0, 8, 9), (0, 9, 0), (0, 9, 1), (0, 9, 2), (0, 9, 3), (0, 9, 4), (0, 9, 5), (0, 9, 6), (0, 9, 7), (0, 9, 8), (0, 9, 9), (1, 0, 0), (1, 0, 1), (1, 0, 2), (1, 0, 3), (1, 0, 4), (1, 0, 5), (1, 0, 6), (1, 0, 7), (1, 0, 8), (1, 0, 9), (1, 1, 0), (1, 1, 1), (1, 1, 2), (1, 1, 3), (1, 1, 4), (1, 1, 5), (1, 1, 6), (1, 1, 7), (1, 1, 8), (1, 1, 9), (1, 2, 0), (1, 2, 1), (1, 2, 2), (1, 2, 3), (1, 2, 4), (1, 2, 5), (1, 2, 6), (1, 2, 7), (1, 2, 8), (1, 2, 9), (1, 3, 0), (1, 3, 1), (1, 3, 2), (1, 3, 3), (1, 3, 4), (1, 3, 5), (1, 3, 6), (1, 3, 7), (1, 3, 8), (1, 3, 9), (1, 4, 0), (1, 4, 1), (1, 4, 2), (1, 4, 3), (1, 4, 4), (1, 4, 5), (1, 4, 6), (1, 4, 7), (1, 4, 8), (1, 4, 9), (1, 5, 0), (1, 5, 1), (1, 5, 2), (1, 5, 3), (1, 5, 4), (1, 5, 5), (1, 5, 6), (1, 5, 7), (1, 5, 8), (1, 5, 9), (1, 6, 0), (1, 6, 1), (1, 6, 2), (1, 6, 3), (1, 6, 4), (1, 6, 5), (1, 6, 6), (1, 6, 7), (1, 6, 8), (1, 6, 9), (1, 7, 0), (1, 7, 1), (1, 7, 2), (1, 7, 3), (1, 7, 4), (1, 7, 5), (1, 7, 6), (1, 7, 7), (1, 7, 8), (1, 7, 9), (1, 8, 0), (1, 8, 1), (1, 8, 2), (1, 8, 3), (1, 8, 4), (1, 8, 5), (1, 8, 6), (1, 8, 7), (1, 8, 8), (1, 8, 9), (1, 9, 0), (1, 9, 1), (1, 9, 2), (1, 9, 3), (1, 9, 4), (1, 9, 5), (1, 9, 6), (1, 9, 7), (1, 9, 8), (1, 9, 9), (2, 0, 0), (2, 0, 1), (2, 0, 2), (2, 0, 3), (2, 0, 4), (2, 0, 5), (2, 0, 6), (2, 0, 7), (2, 0, 8), (2, 0, 9), (2, 1, 0), (2, 1, 1), (2, 1, 2), (2, 1, 3), (2, 1, 4), (2, 1, 5), (2, 1, 6), (2, 1, 7), (2, 1, 8), (2, 1, 9), (2, 2, 0), (2, 2, 1), (2, 2, 2), (2, 2, 3), (2, 2, 4), (2, 2, 5), (2, 2, 6), (2, 2, 7), (2, 2, 8), (2, 2, 9), (2, 3, 0), (2, 3, 1), (2, 3, 2), (2, 3, 3), (2, 3, 4), (2, 3, 5), (2, 3, 6), (2, 3, 7), (2, 3, 8), (2, 3, 9), (2, 4, 0), (2, 4, 1), (2, 4, 2), (2, 4, 3), (2, 4, 4), (2, 4, 5), (2, 4, 6), (2, 4, 7), (2, 4, 8), (2, 4, 9), (2, 5, 0), (2, 5, 1), (2, 5, 2), (2, 5, 3), (2, 5, 4), (2, 5, 5), (2, 5, 6), (2, 5, 7), (2, 5, 8), (2, 5, 9), (2, 6, 0), (2, 6, 1), (2, 6, 2), (2, 6, 3), (2, 6, 4), (2, 6, 5), (2, 6, 6), (2, 6, 7), (2, 6, 8), (2, 6, 9), (2, 7, 0), (2, 7, 1), (2, 7, 2), (2, 7, 3), (2, 7, 4), (2, 7, 5), (2, 7, 6), (2, 7, 7), (2, 7, 8), (2, 7, 9), (2, 8, 0), (2, 8, 1), (2, 8, 2), (2, 8, 3), (2, 8, 4), (2, 8, 5), (2, 8, 6), (2, 8, 7), (2, 8, 8), (2, 8, 9), (2, 9, 0), (2, 9, 1), (2, 9, 2), (2, 9, 3), (2, 9, 4), (2, 9, 5), (2, 9, 6), (2, 9, 7), (2, 9, 8), (2, 9, 9), (3, 0, 0), (3, 0, 1), (3, 0, 2), (3, 0, 3), (3, 0, 4), (3, 0, 5), (3, 0, 6), (3, 0, 7), (3, 0, 8), (3, 0, 9), (3, 1, 0), (3, 1, 1), (3, 1, 2), (3, 1, 3), (3, 1, 4), (3, 1, 5), (3, 1, 6), (3, 1, 7), (3, 1, 8), (3, 1, 9), (3, 2, 0), (3, 2, 1), (3, 2, 2), (3, 2, 3), (3, 2, 4), (3, 2, 5), (3, 2, 6), (3, 2, 7), (3, 2, 8), (3, 2, 9), (3, 3, 0), (3, 3, 1), (3, 3, 2), (3, 3, 3), (3, 3, 4), (3, 3, 5), (3, 3, 6), (3, 3, 7), (3, 3, 8), (3, 3, 9), (3, 4, 0), (3, 4, 1), (3, 4, 2), (3, 4, 3), (3, 4, 4), (3, 4, 5), (3, 4, 6), (3, 4, 7), (3, 4, 8), (3, 4, 9), (3, 5, 0), (3, 5, 1), (3, 5, 2), (3, 5, 3), (3, 5, 4), (3, 5, 5), (3, 5, 6), (3, 5, 7), (3, 5, 8), (3, 5, 9), (3, 6, 0), (3, 6, 1), (3, 6, 2), (3, 6, 3), (3, 6, 4), (3, 6, 5), (3, 6, 6), (3, 6, 7), (3, 6, 8), (3, 6, 9), (3, 7, 0), (3, 7, 1), (3, 7, 2), (3, 7, 3), (3, 7, 4), (3, 7, 5), (3, 7, 6), (3, 7, 7), (3, 7, 8), (3, 7, 9), (3, 8, 0), (3, 8, 1), (3, 8, 2), (3, 8, 3), (3, 8, 4), (3, 8, 5), (3, 8, 6), (3, 8, 7), (3, 8, 8), (3, 8, 9), (3, 9, 0), (3, 9, 1), (3, 9, 2), (3, 9, 3), (3, 9, 4), (3, 9, 5), (3, 9, 6), (3, 9, 7), (3, 9, 8), (3, 9, 9), (4, 0, 0), (4, 0, 1), (4, 0, 2), (4, 0, 3), (4, 0, 4), (4, 0, 5), (4, 0, 6), (4, 0, 7), (4, 0, 8), (4, 0, 9), (4, 1, 0), (4, 1, 1), (4, 1, 2), (4, 1, 3), (4, 1, 4), (4, 1, 5), (4, 1, 6), (4, 1, 7), (4, 1, 8), (4, 1, 9), (4, 2, 0), (4, 2, 1), (4, 2, 2), (4, 2, 3), (4, 2, 4), (4, 2, 5), (4, 2, 6), (4, 2, 7), (4, 2, 8), (4, 2, 9), (4, 3, 0), (4, 3, 1), (4, 3, 2), (4, 3, 3), (4, 3, 4), (4, 3, 5), (4, 3, 6), (4, 3, 7), (4, 3, 8), (4, 3, 9), (4, 4, 0), (4, 4, 1), (4, 4, 2), (4, 4, 3), (4, 4, 4), (4, 4, 5), (4, 4, 6), (4, 4, 7), (4, 4, 8), (4, 4, 9), (4, 5, 0), (4, 5, 1), (4, 5, 2), (4, 5, 3), (4, 5, 4), (4, 5, 5), (4, 5, 6), (4, 5, 7), (4, 5, 8), (4, 5, 9), (4, 6, 0), (4, 6, 1), (4, 6, 2), (4, 6, 3), (4, 6, 4), (4, 6, 5), (4, 6, 6), (4, 6, 7), (4, 6, 8), (4, 6, 9), (4, 7, 0), (4, 7, 1), (4, 7, 2), (4, 7, 3), (4, 7, 4), (4, 7, 5), (4, 7, 6), (4, 7, 7), (4, 7, 8), (4, 7, 9), (4, 8, 0), (4, 8, 1), (4, 8, 2), (4, 8, 3), (4, 8, 4), (4, 8, 5), (4, 8, 6), (4, 8, 7), (4, 8, 8), (4, 8, 9), (4, 9, 0), (4, 9, 1), (4, 9, 2), (4, 9, 3), (4, 9, 4), (4, 9, 5), (4, 9, 6), (4, 9, 7), (4, 9, 8), (4, 9, 9), (5, 0, 0), (5, 0, 1), (5, 0, 2), (5, 0, 3), (5, 0, 4), (5, 0, 5), (5, 0, 6), (5, 0, 7), (5, 0, 8), (5, 0, 9), (5, 1, 0), (5, 1, 1), (5, 1, 2), (5, 1, 3), (5, 1, 4), (5, 1, 5), (5, 1, 6), (5, 1, 7), (5, 1, 8), (5, 1, 9), (5, 2, 0), (5, 2, 1), (5, 2, 2), (5, 2, 3), (5, 2, 4), (5, 2, 5), (5, 2, 6), (5, 2, 7), (5, 2, 8), (5, 2, 9), (5, 3, 0), (5, 3, 1), (5, 3, 2), (5, 3, 3), (5, 3, 4), (5, 3, 5), (5, 3, 6), (5, 3, 7), (5, 3, 8), (5, 3, 9), (5, 4, 0), (5, 4, 1), (5, 4, 2), (5, 4, 3), (5, 4, 4), (5, 4, 5), (5, 4, 6), (5, 4, 7), (5, 4, 8), (5, 4, 9), (5, 5, 0), (5, 5, 1), (5, 5, 2), (5, 5, 3), (5, 5, 4), (5, 5, 5), (5, 5, 6), (5, 5, 7), (5, 5, 8), (5, 5, 9), (5, 6, 0), (5, 6, 1), (5, 6, 2), (5, 6, 3), (5, 6, 4), (5, 6, 5), (5, 6, 6), (5, 6, 7), (5, 6, 8), (5, 6, 9), (5, 7, 0), (5, 7, 1), (5, 7, 2), (5, 7, 3), (5, 7, 4), (5, 7, 5), (5, 7, 6), (5, 7, 7), (5, 7, 8), (5, 7, 9), (5, 8, 0), (5, 8, 1), (5, 8, 2), (5, 8, 3), (5, 8, 4), (5, 8, 5), (5, 8, 6), (5, 8, 7), (5, 8, 8), (5, 8, 9), (5, 9, 0), (5, 9, 1), (5, 9, 2), (5, 9, 3), (5, 9, 4), (5, 9, 5), (5, 9, 6), (5, 9, 7), (5, 9, 8), (5, 9, 9), (6, 0, 0), (6, 0, 1), (6, 0, 2), (6, 0, 3), (6, 0, 4), (6, 0, 5), (6, 0, 6), (6, 0, 7), (6, 0, 8), (6, 0, 9), (6, 1, 0), (6, 1, 1), (6, 1, 2), (6, 1, 3), (6, 1, 4), (6, 1, 5), (6, 1, 6), (6, 1, 7), (6, 1, 8), (6, 1, 9), (6, 2, 0), (6, 2, 1), (6, 2, 2), (6, 2, 3), (6, 2, 4), (6, 2, 5), (6, 2, 6), (6, 2, 7), (6, 2, 8), (6, 2, 9), (6, 3, 0), (6, 3, 1), (6, 3, 2), (6, 3, 3), (6, 3, 4), (6, 3, 5), (6, 3, 6), (6, 3, 7), (6, 3, 8), (6, 3, 9), (6, 4, 0), (6, 4, 1), (6, 4, 2), (6, 4, 3), (6, 4, 4), (6, 4, 5), (6, 4, 6), (6, 4, 7), (6, 4, 8), (6, 4, 9), (6, 5, 0), (6, 5, 1), (6, 5, 2), (6, 5, 3), (6, 5, 4), (6, 5, 5), (6, 5, 6), (6, 5, 7), (6, 5, 8), (6, 5, 9), (6, 6, 0), (6, 6, 1), (6, 6, 2), (6, 6, 3), (6, 6, 4), (6, 6, 5), (6, 6, 6), (6, 6, 7), (6, 6, 8), (6, 6, 9), (6, 7, 0), (6, 7, 1), (6, 7, 2), (6, 7, 3), (6, 7, 4), (6, 7, 5), (6, 7, 6), (6, 7, 7), (6, 7, 8), (6, 7, 9), (6, 8, 0), (6, 8, 1), (6, 8, 2), (6, 8, 3), (6, 8, 4), (6, 8, 5), (6, 8, 6), (6, 8, 7), (6, 8, 8), (6, 8, 9), (6, 9, 0), (6, 9, 1), (6, 9, 2), (6, 9, 3), (6, 9, 4), (6, 9, 5), (6, 9, 6), (6, 9, 7), (6, 9, 8), (6, 9, 9), (7, 0, 0), (7, 0, 1), (7, 0, 2), (7, 0, 3), (7, 0, 4), (7, 0, 5), (7, 0, 6), (7, 0, 7), (7, 0, 8), (7, 0, 9), (7, 1, 0), (7, 1, 1), (7, 1, 2), (7, 1, 3), (7, 1, 4), (7, 1, 5), (7, 1, 6), (7, 1, 7), (7, 1, 8), (7, 1, 9), (7, 2, 0), (7, 2, 1), (7, 2, 2), (7, 2, 3), (7, 2, 4), (7, 2, 5), (7, 2, 6), (7, 2, 7), (7, 2, 8), (7, 2, 9), (7, 3, 0), (7, 3, 1), (7, 3, 2), (7, 3, 3), (7, 3, 4), (7, 3, 5), (7, 3, 6), (7, 3, 7), (7, 3, 8), (7, 3, 9), (7, 4, 0), (7, 4, 1), (7, 4, 2), (7, 4, 3), (7, 4, 4), (7, 4, 5), (7, 4, 6), (7, 4, 7), (7, 4, 8), (7, 4, 9), (7, 5, 0), (7, 5, 1), (7, 5, 2), (7, 5, 3), (7, 5, 4), (7, 5, 5), (7, 5, 6), (7, 5, 7), (7, 5, 8), (7, 5, 9), (7, 6, 0), (7, 6, 1), (7, 6, 2), (7, 6, 3), (7, 6, 4), (7, 6, 5), (7, 6, 6), (7, 6, 7), (7, 6, 8), (7, 6, 9), (7, 7, 0), (7, 7, 1), (7, 7, 2), (7, 7, 3), (7, 7, 4), (7, 7, 5), (7, 7, 6), (7, 7, 7), (7, 7, 8), (7, 7, 9), (7, 8, 0), (7, 8, 1), (7, 8, 2), (7, 8, 3), (7, 8, 4), (7, 8, 5), (7, 8, 6), (7, 8, 7), (7, 8, 8), (7, 8, 9), (7, 9, 0), (7, 9, 1), (7, 9, 2), (7, 9, 3), (7, 9, 4), (7, 9, 5), (7, 9, 6), (7, 9, 7), (7, 9, 8), (7, 9, 9), (8, 0, 0), (8, 0, 1), (8, 0, 2), (8, 0, 3), (8, 0, 4), (8, 0, 5), (8, 0, 6), (8, 0, 7), (8, 0, 8), (8, 0, 9), (8, 1, 0), (8, 1, 1), (8, 1, 2), (8, 1, 3), (8, 1, 4), (8, 1, 5), (8, 1, 6), (8, 1, 7), (8, 1, 8), (8, 1, 9), (8, 2, 0), (8, 2, 1), (8, 2, 2), (8, 2, 3), (8, 2, 4), (8, 2, 5), (8, 2, 6), (8, 2, 7), (8, 2, 8), (8, 2, 9), (8, 3, 0), (8, 3, 1), (8, 3, 2), (8, 3, 3), (8, 3, 4), (8, 3, 5), (8, 3, 6), (8, 3, 7), (8, 3, 8), (8, 3, 9), (8, 4, 0), (8, 4, 1), (8, 4, 2), (8, 4, 3), (8, 4, 4), (8, 4, 5), (8, 4, 6), (8, 4, 7), (8, 4, 8), (8, 4, 9), (8, 5, 0), (8, 5, 1), (8, 5, 2), (8, 5, 3), (8, 5, 4), (8, 5, 5), (8, 5, 6), (8, 5, 7), (8, 5, 8), (8, 5, 9), (8, 6, 0), (8, 6, 1), (8, 6, 2), (8, 6, 3), (8, 6, 4), (8, 6, 5), (8, 6, 6), (8, 6, 7), (8, 6, 8), (8, 6, 9), (8, 7, 0), (8, 7, 1), (8, 7, 2), (8, 7, 3), (8, 7, 4), (8, 7, 5), (8, 7, 6), (8, 7, 7), (8, 7, 8), (8, 7, 9), (8, 8, 0), (8, 8, 1), (8, 8, 2), (8, 8, 3), (8, 8, 4), (8, 8, 5), (8, 8, 6), (8, 8, 7), (8, 8, 8), (8, 8, 9), (8, 9, 0), (8, 9, 1), (8, 9, 2), (8, 9, 3), (8, 9, 4), (8, 9, 5), (8, 9, 6), (8, 9, 7), (8, 9, 8), (8, 9, 9), (9, 0, 0), (9, 0, 1), (9, 0, 2), (9, 0, 3), (9, 0, 4), (9, 0, 5), (9, 0, 6), (9, 0, 7), (9, 0, 8), (9, 0, 9), (9, 1, 0), (9, 1, 1), (9, 1, 2), (9, 1, 3), (9, 1, 4), (9, 1, 5), (9, 1, 6), (9, 1, 7), (9, 1, 8), (9, 1, 9), (9, 2, 0), (9, 2, 1), (9, 2, 2), (9, 2, 3), (9, 2, 4), (9, 2, 5), (9, 2, 6), (9, 2, 7), (9, 2, 8), (9, 2, 9), (9, 3, 0), (9, 3, 1), (9, 3, 2), (9, 3, 3), (9, 3, 4), (9, 3, 5), (9, 3, 6), (9, 3, 7), (9, 3, 8), (9, 3, 9), (9, 4, 0), (9, 4, 1), (9, 4, 2), (9, 4, 3), (9, 4, 4), (9, 4, 5), (9, 4, 6), (9, 4, 7), (9, 4, 8), (9, 4, 9), (9, 5, 0), (9, 5, 1), (9, 5, 2), (9, 5, 3), (9, 5, 4), (9, 5, 5), (9, 5, 6), (9, 5, 7), (9, 5, 8), (9, 5, 9), (9, 6, 0), (9, 6, 1), (9, 6, 2), (9, 6, 3), (9, 6, 4), (9, 6, 5), (9, 6, 6), (9, 6, 7), (9, 6, 8), (9, 6, 9), (9, 7, 0), (9, 7, 1), (9, 7, 2), (9, 7, 3), (9, 7, 4), (9, 7, 5), (9, 7, 6), (9, 7, 7), (9, 7, 8), (9, 7, 9), (9, 8, 0), (9, 8, 1), (9, 8, 2), (9, 8, 3), (9, 8, 4), (9, 8, 5), (9, 8, 6), (9, 8, 7), (9, 8, 8), (9, 8, 9), (9, 9, 0), (9, 9, 1), (9, 9, 2), (9, 9, 3), (9, 9, 4), (9, 9, 5), (9, 9, 6), (9, 9, 7), (9, 9, 8), (9, 9, 9)]\n    assert candidate([(1, 1, 1), (2, 2, 2), (3, 3, 3)], (3, 3, 3)) == []\n    assert candidate([(5, 5, 5)], (5, 5, 5)) == [(0, 0, 0)]\n    assert candidate([(2, 2, 2), (2, 2, 2), (2, 2, 2), (2, 2, 2)], (4, 4, 4)) == [(0, 0, 0), (0, 0, 2), (0, 2, 0), (0, 2, 2)]\n", "language": "python"}
{"task_id": "revision1a_problem300", "prompt": "from math import factorial\nimport itertools\n\ndef lexicographic_rank_with_repetition(s: str) -> int:\n    \"\"\"\n    Calculate the lexicographic rank of a given string, considering repeated characters.\n    The rank is 1-indexed, meaning the first permutation in lexicographic order has rank 1.\n    \n    This problem is more challenging than simple permutation ranking because it needs to\n    account for repeated characters in the string.\n\n    Example 1:\n    Input: 'baa'\n    Output: 3\n\n    Example 2:\n    Input: 'string'\n    Output: 598\n\n    Example 3:\n    Input: 'zzz'\n    Output: 1\n\n    Note: The time complexity of a naive solution would be O(n!), where n is the length of the string.\n    Try to come up with a more efficient solution.\n    \"\"\"\n", "entry_point": "lexicographic_rank_with_repetition", "solution": "    def factorial(n):\n        return 1 if n == 0 else n * factorial(n - 1)\n\n    def count_smaller_chars(char, index):\n        return sum(1 for c in s[index + 1:] if c < char)\n\n    def calculate_repetitions():\n        char_count = {}\n        for char in s:\n            char_count[char] = char_count.get(char, 0) + 1\n        return char_count\n\n    n = len(s)\n    char_count = calculate_repetitions()\n    rank = 1\n\n    for i in range(n):\n        smaller_chars = count_smaller_chars(s[i], i)\n        \n        # Calculate permutations for smaller characters\n        permutations = smaller_chars * factorial(n - i - 1)\n        \n        # Adjust for repetitions\n        for char, count in char_count.items():\n            if count > 1:\n                permutations //= factorial(count)\n        \n        rank += permutations\n        \n        # Update character count\n        char_count[s[i]] -= 1\n        if char_count[s[i]] == 0:\n            del char_count[s[i]]\n\n    return rank\n", "test": "def check(candidate):\n    assert candidate(\"zz\") == 1\n    assert candidate(\"a\") == 1\n    assert candidate(\"cba\") == 6\n    assert candidate(\"ab\") == 1\n    assert candidate(\"ba\") == 2\n    assert candidate(\"aaa\") == 1\n    assert candidate(\"aba\") == 2\n    assert candidate(\"aa\") == 1\n    assert candidate(\"z\") == 1\n    assert candidate(\"abc\") == 1\n", "language": "python"}
{"task_id": "revision1a_problem628", "prompt": "import itertools\nimport math\nfrom typing import List, Tuple\nfrom itertools import combinations\n\ndef optimize_delivery_route(locations: List[Tuple[float, float]], max_distance: float) -> List[int]:\n    \"\"\"\n    A food delivery service wants to optimize their delivery routes. They have a list of customer locations \n    represented as (x, y) coordinates and a maximum allowed distance for a single delivery run.\n\n    Your task is to determine the optimal order of deliveries that maximizes the number of customers served \n    while staying within the maximum distance limit. The delivery always starts and ends at (0, 0).\n\n    1. locations is a list of tuples, where each tuple represents (x, y) coordinates of a customer.\n    2. max_distance is the maximum allowed distance for a single delivery run.\n    3. The function should return a list of indices representing the optimal order of deliveries.\n    4. If no valid route is possible, return an empty list.\n\n    Use dynamic programming or a graph algorithm to solve this problem efficiently.\n\n    Example:\n    Input: locations = [(1, 1), (2, 2), (3, 3), (-1, -1)], max_distance = 10\n    Output: [0, 1, 3]  # This route covers 3 customers within the distance limit\n    \n    Input: locations = [(5, 5), (-5, -5)], max_distance = 5\n    Output: []  # No valid route possible within the distance limit\n    \"\"\"\n", "entry_point": "optimize_delivery_route", "solution": "    def distance(p1, p2):\n        return math.sqrt((p1[0] - p2[0])**2 + (p1[1] - p2[1])**2)\n\n    n = len(locations)\n    if n == 0:\n        return []\n\n    # Calculate distances between all points (including start/end point (0, 0))\n    distances = [[0] * (n + 1) for _ in range(n + 1)]\n    for i in range(n + 1):\n        for j in range(i + 1, n + 1):\n            if i == 0:\n                distances[i][j] = distances[j][i] = distance((0, 0), locations[j - 1])\n            else:\n                distances[i][j] = distances[j][i] = distance(locations[i - 1], locations[j - 1])\n\n    # Dynamic programming to find optimal route\n    dp = {}\n\n    def dfs(mask, pos):\n        if mask == (1 << n) - 1:\n            return distances[pos][0] <= max_distance, []\n        \n        if (mask, pos) in dp:\n            return dp[(mask, pos)]\n\n        best_count = 0\n        best_route = []\n\n        for nxt in range(n):\n            if mask & (1 << nxt) == 0 and distances[pos][nxt + 1] <= max_distance:\n                can_complete, sub_route = dfs(mask | (1 << nxt), nxt + 1)\n                if can_complete and 1 + len(sub_route) > best_count:\n                    best_count = 1 + len(sub_route)\n                    best_route = [nxt] + sub_route\n\n        dp[(mask, pos)] = (distances[pos][0] <= max_distance, best_route)\n        return dp[(mask, pos)]\n\n    _, optimal_route = dfs(0, 0)\n    return optimal_route\n", "test": "def check(candidate):\n    assert candidate([(1, 1), (2, 2), (3, 3), (4, 4), (5, 5)], 20) == [0, 1, 2, 3, 4]\n    assert candidate([(1, 0), (0, 1), (-1, 0), (0, -1)], 4) == [0, 1, 2, 3]\n    assert candidate([(0, 0), (1, 1), (2, 2)], 5) == [0, 1, 2]\n    assert candidate([(1, 1)], 1) == []\n    assert candidate([], 10) == []\n    assert candidate([(3, 4), (-3, 4), (3, -4), (-3, -4)], 20) == [0, 1, 2, 3]\n    assert candidate([(-1, -1), (-2, -2), (-3, -3)], 10) == [0, 1, 2]\n    assert candidate([(5, 5), (-5, -5)], 5) == []\n    assert candidate([(0, 1), (1, 0), (2, 2), (3, 3), (4, 4)], 15) == [0, 1, 2, 3, 4]\n    assert candidate([(1, 1), (2, 2), (3, 3), (-1, -1)], 10) == [0, 1, 2, 3]\n", "language": "python"}
{"task_id": "revision1a_problem136", "prompt": "from typing import List\nimport threading\nfrom concurrent.futures import ThreadPoolExecutor, as_completed\n\ndef parallel_merge_sort(arr: List[int], num_threads: int) -> List[int]:\n    \"\"\"\n    Implement a parallel merge sort algorithm using multiple threads.\n\n    The merge sort algorithm divides the array into two halves, recursively sorts them, and then merges the two sorted halves. \n    Your task is to parallelize this process using a specified number of threads to improve performance on multi-core systems.\n\n    Take the unsorted array and the number of threads to use as input from the user, and return the sorted array.\n\n    The challenge is to efficiently distribute the workload among the threads and handle thread synchronization properly.\n\n    Example:\n    Input: [38, 27, 43, 3, 9, 82, 10], 4\n    Output: [3, 9, 10, 27, 38, 43, 82]\n\n    Input: [5, 2, 9, 1, 7, 6, 3], 2\n    Output: [1, 2, 3, 5, 6, 7, 9]\n\n    Note: Ensure that your implementation scales well with the number of threads and the size of the input array.\n    \"\"\"\n", "entry_point": "parallel_merge_sort", "solution": "    def merge_sort(start: int, end: int):\n        if start < end:\n            mid = (start + end) // 2\n            merge_sort(start, mid)\n            merge_sort(mid + 1, end)\n            merge(start, mid, end)\n\n    def merge(start: int, mid: int, end: int):\n        left = arr[start:mid + 1]\n        right = arr[mid + 1:end + 1]\n        i = j = 0\n        k = start\n\n        while i < len(left) and j < len(right):\n            if left[i] <= right[j]:\n                arr[k] = left[i]\n                i += 1\n            else:\n                arr[k] = right[j]\n                j += 1\n            k += 1\n\n        while i < len(left):\n            arr[k] = left[i]\n            i += 1\n            k += 1\n\n        while j < len(right):\n            arr[k] = right[j]\n            j += 1\n            k += 1\n\n    def parallel_sort(start: int, end: int, depth: int):\n        if depth == 0 or start >= end:\n            merge_sort(start, end)\n        else:\n            mid = (start + end) // 2\n            left_thread = threading.Thread(target=parallel_sort, args=(start, mid, depth - 1))\n            right_thread = threading.Thread(target=parallel_sort, args=(mid + 1, end, depth - 1))\n            left_thread.start()\n            right_thread.start()\n            left_thread.join()\n            right_thread.join()\n            merge(start, mid, end)\n\n    if not arr:\n        return arr\n\n    depth = (num_threads - 1).bit_length()\n    parallel_sort(0, len(arr) - 1, depth)\n    return arr\n", "test": "def check(candidate):\n    assert candidate([999, 1000, 998, 997, 996], 2) == [996, 997, 998, 999, 1000]\n    assert candidate([1, 2, 3, 4, 5], 3) == [1, 2, 3, 4, 5]\n    assert candidate([1], 1) == [1]\n    assert candidate([1, 3, 5, 7, 9, 2, 4, 6, 8, 10], 4) == [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]\n    assert candidate([38, 27, 43, 3, 9, 82, 10], 4) == [3, 9, 10, 27, 38, 43, 82]\n    assert candidate([5, 4, 3, 2, 1], 2) == [1, 2, 3, 4, 5]\n    assert candidate([5, 2, 9, 1, 7, 6, 3], 2) == [1, 2, 3, 5, 6, 7, 9]\n    assert candidate([10, 10, 10, 10, 10], 5) == [10, 10, 10, 10, 10]\n    assert candidate([], 4) == []\n    assert candidate([100, 99, 98, 97, 96, 95, 94, 93, 92, 91], 3) == [91, 92, 93, 94, 95, 96, 97, 98, 99, 100]\n", "language": "python"}
{"task_id": "revision1a_problem523", "prompt": "from typing import List, Dict, Tuple\nfrom collections import defaultdict\n\ndef analyze_social_network(connections: List[Tuple[str, str]], queries: List[str]) -> Dict[str, int]:\n    \"\"\"\n    A social media analyst wants to analyze the structure of a social network.\n    Given a list of connections between users and a list of query users,\n    calculate the number of second-degree connections for each query user.\n\n    A second-degree connection is someone who is not directly connected to the user,\n    but is connected to one of the user's direct connections.\n\n    Parameters:\n    connections (List[Tuple[str, str]]): A list of tuples representing connections between users.\n    queries (List[str]): A list of users to analyze.\n\n    Returns:\n    Dict[str, int]: A dictionary with query users as keys and their number of second-degree connections as values.\n\n    Example:\n    Input: \n    connections = [(\"Alice\", \"Bob\"), (\"Bob\", \"Charlie\"), (\"Charlie\", \"David\"), (\"Eve\", \"Alice\"), (\"Frank\", \"George\")]\n    queries = [\"Alice\", \"Bob\", \"Eve\"]\n    Output: {\"Alice\": 2, \"Bob\": 2, \"Eve\": 2}\n\n    Explanation:\n    - Alice's second-degree connections are Charlie and George.\n    - Bob's second-degree connections are Eve and David.\n    - Eve's second-degree connections are Bob and Charlie.\n    \"\"\"\n", "entry_point": "analyze_social_network", "solution": "    # Create a graph representation of the network\n    graph = defaultdict(set)\n    for user1, user2 in connections:\n        graph[user1].add(user2)\n        graph[user2].add(user1)\n    \n    def get_second_degree_connections(user):\n        first_degree = graph[user]\n        second_degree = set()\n        for friend in first_degree:\n            second_degree.update(graph[friend])\n        # Remove the user and their direct connections from second-degree connections\n        second_degree -= {user}\n        second_degree -= first_degree\n        return len(second_degree)\n    \n    # Calculate second-degree connections for each query user\n    result = {}\n    for user in queries:\n        result[user] = get_second_degree_connections(user)\n    \n    return result\n", "test": "def check(candidate):\n    assert candidate([(\"User1\", \"User2\"), (\"User2\", \"User3\"), (\"User3\", \"User4\"), (\"User4\", \"User5\")], [\"User1\", \"User5\"]) == {'User1': 1, 'User5': 1}\n    assert candidate([(\"X\", \"Y\"), (\"Y\", \"Z\"), (\"Z\", \"X\")], [\"X\"]) == {'X': 0}\n    assert candidate([(\"John\", \"Mary\"), (\"Mary\", \"Peter\"), (\"Peter\", \"Susan\")], [\"John\", \"Susan\"]) == {'John': 1, 'Susan': 1}\n    assert candidate([(\"Alice\", \"Bob\"), (\"Bob\", \"Charlie\"), (\"Charlie\", \"David\"), (\"David\", \"Eve\"), (\"Eve\", \"Frank\")], [\"Alice\", \"Charlie\", \"Eve\"]) == {'Alice': 1, 'Charlie': 2, 'Eve': 1}\n    assert candidate([(\"Alice\", \"Bob\"), (\"Bob\", \"Charlie\"), (\"Charlie\", \"David\"), (\"Eve\", \"Alice\"), (\"Frank\", \"George\")], [\"Alice\", \"Bob\", \"Eve\"]) == {'Alice': 1, 'Bob': 2, 'Eve': 1}\n    assert candidate([(\"A\", \"B\"), (\"B\", \"C\"), (\"C\", \"D\"), (\"D\", \"A\")], [\"A\", \"B\", \"C\", \"D\"]) == {'A': 1, 'B': 1, 'C': 1, 'D': 1}\n    assert candidate([(\"X\", \"Y\"), (\"Y\", \"Z\")], [\"X\", \"Y\", \"Z\"]) == {'X': 1, 'Y': 0, 'Z': 1}\n    assert candidate([(\"A\", \"B\"), (\"B\", \"C\"), (\"C\", \"D\"), (\"D\", \"E\")], [\"A\", \"C\", \"E\"]) == {'A': 1, 'C': 2, 'E': 1}\n    assert candidate([(\"A\", \"B\")], [\"A\", \"B\", \"C\"]) == {'A': 0, 'B': 0, 'C': 0}\n    assert candidate([(\"1\", \"2\"), (\"2\", \"3\"), (\"3\", \"4\"), (\"4\", \"5\"), (\"5\", \"1\")], [\"1\", \"3\", \"5\"]) == {'1': 2, '3': 2, '5': 2}\n", "language": "python"}
{"task_id": "revision1a_problem654", "prompt": "from typing import List, Tuple\nimport math\n\ndef optimize_delivery_route(n: int, locations: List[Tuple[float, float]], fuel_capacity: float) -> List[int]:\n    \"\"\"\n    You are a logistics manager for a delivery company. Your task is to optimize the delivery route for a drone\n    that needs to visit n locations. The drone has a limited fuel capacity and needs to return to the starting point (0, 0).\n\n    Write a function that takes the number of locations, a list of location coordinates (x, y), and the fuel capacity of the drone.\n    The function should return the optimal order of visits as a list of indices, ensuring the drone doesn't run out of fuel.\n\n    Assume that:\n    1. The drone consumes 1 unit of fuel per unit of distance traveled.\n    2. The drone starts and must end at (0, 0).\n    3. If it's impossible to visit all locations and return, return an empty list.\n\n    Use dynamic programming or a greedy algorithm to solve this problem efficiently.\n\n    Example:\n    Input: 3, [(1.0, 1.0), (2.0, 2.0), (3.0, 3.0)], 15.0\n    Output: [0, 1, 2]\n\n    Input: 4, [(1.0, 1.0), (2.0, 2.0), (3.0, 3.0), (4.0, 4.0)], 10.0\n    Output: []\n    \"\"\"\n", "entry_point": "optimize_delivery_route", "solution": "    def distance(p1: Tuple[float, float], p2: Tuple[float, float]) -> float:\n        return math.sqrt((p1[0] - p2[0])**2 + (p1[1] - p2[1])**2)\n\n    start = (0.0, 0.0)\n    unvisited = list(range(n))\n    route = []\n    current = start\n    total_distance = 0\n\n    while unvisited:\n        nearest = min(unvisited, key=lambda i: distance(current, locations[i]))\n        dist_to_nearest = distance(current, locations[nearest])\n        dist_to_start = distance(locations[nearest], start)\n\n        if total_distance + dist_to_nearest + dist_to_start <= fuel_capacity:\n            route.append(nearest)\n            total_distance += dist_to_nearest\n            current = locations[nearest]\n            unvisited.remove(nearest)\n        else:\n            return []  # Not enough fuel to complete the route\n\n    # Check if we can return to start\n    if total_distance + distance(current, start) <= fuel_capacity:\n        return route\n    else:\n        return []  # Not enough fuel to return to start\n\n", "test": "def check(candidate):\n    assert candidate(1, [(5.0, 5.0)], 15.0) == [0]\n    assert candidate(5, [(1.0, 0.0), (0.0, 1.0), (-1.0, 0.0), (0.0, -1.0), (0.0, 0.0)], 8.0) == [4, 0, 1, 2, 3]\n    assert candidate(2, [(1.0, 0.0), (0.0, 1.0)], 5.0) == [0, 1]\n    assert candidate(0, [], 10.0) == []\n    assert candidate(3, [(3.0, 4.0), (6.0, 8.0), (9.0, 12.0)], 50.0) == [0, 1, 2]\n    assert candidate(5, [(1.0, 1.0), (2.0, 2.0), (3.0, 3.0), (4.0, 4.0), (5.0, 5.0)], 30.0) == [0, 1, 2, 3, 4]\n    assert candidate(4, [(1.0, 1.0), (-1.0, -1.0), (2.0, -2.0), (-2.0, 2.0)], 20.0) == [0, 1, 2, 3]\n    assert candidate(4, [(1.0, 1.0), (2.0, 2.0), (3.0, 3.0), (4.0, 4.0)], 10.0) == []\n    assert candidate(3, [(0.1, 0.1), (0.2, 0.2), (0.3, 0.3)], 2.0) == [0, 1, 2]\n    assert candidate(3, [(1.0, 1.0), (2.0, 2.0), (3.0, 3.0)], 15.0) == [0, 1, 2]\n", "language": "python"}
{"task_id": "revision1a_problem461", "prompt": "def analyze_text_sentiment(text: str) -> str:\n    \"\"\"\n    You are working on a natural language processing project to analyze customer reviews.\n    Your task is to implement a sentiment analysis function that categorizes the sentiment of a given text.\n    The function should use a combination of rule-based and machine learning approaches:\n\n    1. First, it should check for specific keywords that strongly indicate sentiment:\n       - Positive keywords: \"excellent\", \"amazing\", \"fantastic\"\n       - Negative keywords: \"terrible\", \"awful\", \"disappointing\"\n    2. If no strong keywords are found, it should use a pre-trained machine learning model to classify the sentiment.\n    3. The function should return one of three sentiments: \"Positive\", \"Negative\", or \"Neutral\".\n\n    Take the text as input from the user and display the analyzed sentiment.\n\n    Example:\n    Input: \"This product is absolutely fantastic! I love it.\"\n    Output: Positive\n\n    Input: \"The service was mediocre, nothing special.\"\n    Output: Neutral\n    \"\"\"\n", "entry_point": "analyze_text_sentiment", "solution": "    # Define positive and negative keywords\n    positive_keywords = [\"excellent\", \"amazing\", \"fantastic\"]\n    negative_keywords = [\"terrible\", \"awful\", \"disappointing\"]\n\n    # Convert text to lowercase for case-insensitive matching\n    text_lower = text.lower()\n\n    # Check for strong keywords\n    for keyword in positive_keywords:\n        if keyword in text_lower:\n            return \"Positive\"\n\n    for keyword in negative_keywords:\n        if keyword in text_lower:\n            return \"Negative\"\n\n    # If no strong keywords found, use a pre-trained machine learning model\n    # For this example, we'll use a simple sentiment analysis using TextBlob\n    # You need to install TextBlob: pip install textblob\n    from textblob import TextBlob\n\n    # Analyze sentiment using TextBlob\n    blob = TextBlob(text)\n    sentiment_score = blob.sentiment.polarity\n\n    # Classify sentiment based on the sentiment score\n    if sentiment_score > 0.1:\n        return \"Positive\"\n    elif sentiment_score < -0.1:\n        return \"Negative\"\n    else:\n        return \"Neutral\"\n", "test": "def check(candidate):\n    assert candidate(\"This product is absolutely fantastic! I love it.\") == 'Positive'\n    assert candidate(\"This is neither excellent nor terrible.\") == 'Positive'\n    assert candidate(\"Fantastic service, terrible product.\") == 'Positive'\n    assert candidate(\"Awful customer support, but excellent product quality.\") == 'Positive'\n    assert candidate(\"terrible.\") == 'Negative'\n    assert candidate(\"Amazing! Fantastic! Excellent! Wonderful!\") == 'Positive'\n    assert candidate(\"This is the worst purchase I\\'ve ever made. Awful!\") == 'Negative'\n    assert candidate(\"The service was terrible and disappointing.\") == 'Negative'\n    assert candidate(\"EXCELLENT!!!\") == 'Positive'\n    assert candidate(\"Excellent customer support and amazing product quality!\") == 'Positive'\n", "language": "python"}
{"task_id": "revision1a_problem681", "prompt": "from typing import List\n\ndef find_minimum_platforms(arrival: List[int], departure: List[int]) -> int:\n    \"\"\"\n    A railway station manager needs to determine the minimum number of platforms required for the station\n    so that no train waits or leaves without a platform. You are given two lists: 'arrival' and 'departure',\n    where arrival[i] represents the arrival time of the i-th train and departure[i] represents its departure time.\n    Your task is to find the minimum number of platforms required at any point in time to avoid any train waiting.\n    \n    Note: The time is represented in a 24-hour format as an integer. For example, 9:00 is represented as 900,\n    and 18:30 is represented as 1830.\n\n    Example:\n    Input: arrival = [900, 940, 950, 1100, 1500, 1800], departure = [910, 1200, 1120, 1130, 1900, 2000]\n    Output: 3\n    Input: arrival = [900, 1100, 1235], departure = [1000, 1200, 1240]\n    Output: 1\n    \"\"\"\n", "entry_point": "find_minimum_platforms", "solution": "    # Sort both arrival and departure times\n    arrival.sort()\n    departure.sort()\n\n    platforms_needed = 1\n    result = 1\n    i = 1\n    j = 0\n    n = len(arrival)\n\n    while i < n and j < n:\n        if arrival[i] <= departure[j]:\n            platforms_needed += 1\n            i += 1\n        elif arrival[i] > departure[j]:\n            platforms_needed -= 1\n            j += 1\n\n        if platforms_needed > result:\n            result = platforms_needed\n\n    return result\n", "test": "def check(candidate):\n    assert candidate([0, 2359], [1, 0]) == 1\n    assert candidate([1200, 1200, 1200, 1200, 1200], [1300, 1300, 1300, 1300, 1300]) == 5\n    assert candidate([600, 700, 800, 900], [730, 830, 930, 1000]) == 2\n    assert candidate([0], [2359]) == 1\n    assert candidate([1000, 1000, 1000], [1030, 1030, 1030]) == 3\n    assert candidate([900, 940, 950, 1100, 1500, 1800], [910, 1200, 1120, 1130, 1900, 2000]) == 3\n    assert candidate([100, 200, 300], [400, 500, 600]) == 3\n    assert candidate([900, 1100, 1235], [1000, 1200, 1240]) == 1\n    assert candidate([900, 1000, 1100], [1000, 1100, 1200]) == 2\n    assert candidate([1, 2, 3, 4, 5], [2, 3, 4, 5, 6]) == 2\n", "language": "python"}
{"task_id": "revision1a_problem363", "prompt": "from typing import List, Tuple\n\ndef encrypt_message(message: str, key: int) -> Tuple[str, List[int]]:\n    \"\"\"\n    In a secret agent training program, we need to encrypt messages using a special algorithm.\n\n    The encryption process works as follows:\n    1. Shift each letter in the message by the key value (wrapping around the alphabet if necessary).\n    2. For each word, reverse its order of letters.\n    3. Replace any digit with its square, maintaining its position.\n\n    Take the message and key as input from the user and return a tuple containing the encrypted message \n    and a list of the original positions of any numbers in the message.\n\n    Example:\n\n    Input: message = \"Agent007 meetAt 8pm\", key = 3\n    Output: (\"Wqhjd94 wdWhhp: 46ps\", [5, 6, 7, 18])\n\n    Input: message = \"Mission5 Accomplished9\", key = 1\n    Output: (\"Opjttjn25 efitjmnpddB18\", [7, 19])\n    \"\"\"\n", "entry_point": "encrypt_message", "solution": "    def shift_letter(char: str, shift: int) -> str:\n        if char.isalpha():\n            ascii_offset = 65 if char.isupper() else 97\n            return chr((ord(char) - ascii_offset + shift) % 26 + ascii_offset)\n        return char\n\n    def reverse_word(word: str) -> str:\n        return ''.join(reversed(word))\n\n    def square_digit(char: str) -> str:\n        if char.isdigit():\n            return str(int(char) ** 2)\n        return char\n\n    encrypted_words = []\n    number_positions = []\n    \n    for word_index, word in enumerate(message.split()):\n        shifted_word = ''.join(shift_letter(char, key) for char in word)\n        reversed_word = reverse_word(shifted_word)\n        \n        encrypted_word = ''\n        for char_index, char in enumerate(reversed_word):\n            if char.isdigit():\n                number_positions.append(sum(len(w) for w in message.split()[:word_index]) + char_index)\n            encrypted_word += square_digit(char)\n        \n        encrypted_words.append(encrypted_word)\n\n    encrypted_message = ' '.join(encrypted_words)\n    return encrypted_message, number_positions\n", "test": "def check(candidate):\n    assert candidate(\"Agent007 meetAt 8pm\", 3) == ('4900wqhjD wDwhhp ps64', [0, 1, 2, 16])\n    assert candidate(\"ZyXwVuTsRqPoNmLkJiHgFeDcBa\", 1) == ('bCdEfGhIjKlMnOpQrStUvWxYzA', [])\n    assert candidate(\"Hello World\", 1) == ('pmmfI emspX', [])\n    assert candidate(\"\", 5) == ('', [])\n    assert candidate(\"1234567890\", 10) == ('0816449362516941', [0, 1, 2, 3, 4, 5, 6, 7, 8, 9])\n    assert candidate(\"THE QUICK BROWN FOX JUMPS OVER THE LAZY DOG\", 7) == ('LOA RJPBX UDVYI EVM ZWTBQ YLCV LOA FGHS NVK', [])\n    assert candidate(\"Mission5 Accomplished9\", 1) == ('25opjttjN 81efitjmqnpddB', [0, 8])\n    assert candidate(\"AbCdEfGhIjKlMnOpQrStUvWxYz\", 26) == ('zYxWvUtSrQpOnMlKjIhGfEdCbA', [])\n    assert candidate(\"NoNumbers\", 0) == ('srebmuNoN', [])\n    assert candidate(\"a1b2c3d4e5f6g7h8i9j0\", 13) == ('0w81v64u49t36s25r16q9p4o1n', [0, 2, 4, 6, 8, 10, 12, 14, 16, 18])\n", "language": "python"}
{"task_id": "revision1a_problem481", "prompt": "from typing import List\n\ndef trap_rain_water(height: List[int]) -> int:\n    \"\"\"\n    You are an environmental engineer studying water collection in an urban area. You are given an array of non-negative integers representing the height of walls.\n    Each wall has a width of 1 unit. Calculate how many units of water can be trapped between the walls after a rainstorm.\n\n    Write a function that takes a list of integers representing wall heights and returns the total amount of water that can be trapped.\n\n    Example 1:\n    Input: [0,1,0,2,1,0,1,3,2,1,2,1]\n    Output: 6\n    Explanation: The above elevation map (black section) is represented by array [0,1,0,2,1,0,1,3,2,1,2,1]. In this case, 6 units of rain water (blue section) are being trapped.\n\n    Example 2:\n    Input: [4,2,0,3,2,5]\n    Output: 9\n    \"\"\"\n", "entry_point": "trap_rain_water", "solution": "    if not height:\n        return 0\n\n    n = len(height)\n    left_max = [0] * n\n    right_max = [0] * n\n    water = 0\n\n    # Calculate the maximum height to the left of each wall\n    left_max[0] = height[0]\n    for i in range(1, n):\n        left_max[i] = max(left_max[i-1], height[i])\n\n    # Calculate the maximum height to the right of each wall\n    right_max[n-1] = height[n-1]\n    for i in range(n-2, -1, -1):\n        right_max[i] = max(right_max[i+1], height[i])\n\n    # Calculate the amount of water trapped at each position\n    for i in range(n):\n        water += max(0, min(left_max[i], right_max[i]) - height[i])\n\n    return water\n", "test": "def check(candidate):\n    assert candidate([0,0,0,0,5,0,0,0,0]) == 0\n    assert candidate([5,4,3,2,1]) == 0\n    assert candidate([1,1,1,1]) == 0\n    assert candidate([1]) == 0\n    assert candidate([1,2,3,4,5]) == 0\n    assert candidate([4,2,0,3,2,5]) == 9\n    assert candidate([0,1,0,2,1,0,1,3,2,1,2,1]) == 6\n    assert candidate([]) == 0\n    assert candidate([3,0,2,0,4]) == 7\n    assert candidate([9,8,7,6,5,4,3,2,1,0]) == 0\n", "language": "python"}
{"task_id": "revision1a_problem421", "prompt": "from typing import List, Tuple\n\ndef optimize_warehouse_layout(items: List[Tuple[str, int, int]]) -> List[List[str]]:\n    \"\"\"\n    You are a logistics manager for a large e-commerce company. Your task is to optimize the layout of a new warehouse\n    to maximize efficiency. The warehouse is represented as a 2D grid, and you need to place items strategically.\n\n    Each item is represented by a tuple containing (item_name, width, height). You need to place these items in the\n    warehouse grid in a way that minimizes empty spaces and ensures easy access for picking robots.\n\n    Implement an algorithm that takes a list of items and returns the optimized warehouse layout as a 2D list of strings.\n    Empty spaces should be represented by '.', and items should be represented by their first letter.\n\n    Your algorithm should consider the following:\n    1. Items should not overlap.\n    2. Items should be placed to minimize empty spaces between them.\n    3. There should be at least one empty space around each item for robot access.\n    4. The warehouse grid should be as compact as possible.\n\n    Example:\n    Input: [('Book', 2, 3), ('Toy', 2, 2), ('Electronics', 3, 2)]\n    Output: [\n        ['B', 'B', '.', 'E', 'E', 'E'],\n        ['B', 'B', '.', 'E', 'E', 'E'],\n        ['B', 'B', '.', '.', '.', '.'],\n        ['.', '.', '.', 'T', 'T', '.'],\n        ['.', '.', '.', 'T', 'T', '.']\n    ]\n    \"\"\"\n", "entry_point": "optimize_warehouse_layout", "solution": "    def can_place_item(grid, row, col, width, height):\n        if row + height + 1 > len(grid) or col + width + 1 > len(grid[0]):\n            return False\n        for i in range(row - 1, row + height + 1):\n            for j in range(col - 1, col + width + 1):\n                if i < 0 or j < 0:\n                    continue\n                if i >= len(grid) or j >= len(grid[0]):\n                    return False\n                if grid[i][j] != '.':\n                    return False\n        return True\n\n    def place_item(grid, row, col, item):\n        name, width, height = item\n        for i in range(row, row + height):\n            for j in range(col, col + width):\n                grid[i][j] = name[0]\n\n    # Sort items by area in descending order\n    items.sort(key=lambda x: x[1] * x[2], reverse=True)\n\n    # Initialize the grid with a reasonable size\n    max_width = sum(item[1] for item in items) + len(items) + 1\n    max_height = sum(item[2] for item in items) + len(items) + 1\n    grid = [['.' for _ in range(max_width)] for _ in range(max_height)]\n\n    for item in items:\n        placed = False\n        for row in range(len(grid)):\n            for col in range(len(grid[0])):\n                if can_place_item(grid, row, col, item[1], item[2]):\n                    place_item(grid, row, col, item)\n                    placed = True\n                    break\n            if placed:\n                break\n\n    # Trim the grid\n    while all(cell == '.' for cell in grid[-1]):\n        grid.pop()\n    while all(row[-1] == '.' for row in grid):\n        for row in grid:\n            row.pop()\n\n    return grid\n", "test": "def check(candidate):\n    assert candidate([('Sofa', 4, 2), ('TV', 3, 1), ('Rug', 2, 2)]) == [['S', 'S', 'S', 'S', '.', 'R', 'R', '.', 'T', 'T', 'T'], ['S', 'S', 'S', 'S', '.', 'R', 'R', '.', '.', '.', '.']]\n    assert candidate([('Box', 1, 1), ('Box', 1, 1), ('Box', 1, 1), ('Box', 1, 1)]) == [['B', '.', 'B', '.', 'B', '.', 'B']]\n    assert candidate([('Book', 2, 3), ('Toy', 2, 2), ('Electronics', 3, 2)]) == [['B', 'B', '.', 'E', 'E', 'E', '.', 'T', 'T'], ['B', 'B', '.', 'E', 'E', 'E', '.', 'T', 'T'], ['B', 'B', '.', '.', '.', '.', '.', '.', '.']]\n    assert candidate([('Desk', 3, 2), ('Bookshelf', 2, 4), ('Plant', 1, 1)]) == [['B', 'B', '.', 'D', 'D', 'D', '.', 'P'], ['B', 'B', '.', 'D', 'D', 'D', '.', '.'], ['B', 'B', '.', '.', '.', '.', '.', '.'], ['B', 'B', '.', '.', '.', '.', '.', '.']]\n    assert candidate([('BigItem', 10, 10)]) == [['B', 'B', 'B', 'B', 'B', 'B', 'B', 'B', 'B', 'B'], ['B', 'B', 'B', 'B', 'B', 'B', 'B', 'B', 'B', 'B'], ['B', 'B', 'B', 'B', 'B', 'B', 'B', 'B', 'B', 'B'], ['B', 'B', 'B', 'B', 'B', 'B', 'B', 'B', 'B', 'B'], ['B', 'B', 'B', 'B', 'B', 'B', 'B', 'B', 'B', 'B'], ['B', 'B', 'B', 'B', 'B', 'B', 'B', 'B', 'B', 'B'], ['B', 'B', 'B', 'B', 'B', 'B', 'B', 'B', 'B', 'B'], ['B', 'B', 'B', 'B', 'B', 'B', 'B', 'B', 'B', 'B'], ['B', 'B', 'B', 'B', 'B', 'B', 'B', 'B', 'B', 'B'], ['B', 'B', 'B', 'B', 'B', 'B', 'B', 'B', 'B', 'B']]\n", "language": "python"}
{"task_id": "revision1a_problem3", "prompt": "from typing import List\n\ndef organize_library(n: int, books: List[str], shelves: List[int]) -> List[List[str]]:\n    \"\"\"\n    You are a librarian tasked with organizing a collection of books onto shelves. You have n books, each with a unique title, \n    and a list of shelf capacities. Your goal is to distribute the books across the shelves while adhering to each shelf's capacity.\n\n    The function should take three inputs:\n    1. n: The total number of books\n    2. books: A list of book titles\n    3. shelves: A list of integers representing the capacity of each shelf\n\n    Your task is to return a list of lists, where each inner list represents a shelf and contains the titles of the books placed on that shelf. \n    If it's impossible to distribute all books within the given shelf capacities, return an empty list.\n\n    This problem involves concepts like list manipulation, capacity constraints, and potentially backtracking or dynamic programming for optimal solutions.\n\n    Example 1:\n    Input: 5, [\"Harry Potter\", \"1984\", \"To Kill a Mockingbird\", \"Pride and Prejudice\", \"The Great Gatsby\"], [2, 2, 1]\n    Output: [[\"Harry Potter\", \"1984\"], [\"To Kill a Mockingbird\", \"Pride and Prejudice\"], [\"The Great Gatsby\"]]\n\n    Example 2:\n    Input: 4, [\"Moby Dick\", \"War and Peace\", \"Ulysses\", \"Don Quixote\"], [1, 1, 1]\n    Output: []\n    \"\"\"\n", "entry_point": "organize_library", "solution": "    def backtrack(book_index, current_shelves):\n        if book_index == n:\n            return current_shelves\n\n        for shelf_index in range(len(shelves)):\n            if len(current_shelves[shelf_index]) < shelves[shelf_index]:\n                current_shelves[shelf_index].append(books[book_index])\n                result = backtrack(book_index + 1, current_shelves)\n                if result:\n                    return result\n                current_shelves[shelf_index].pop()\n\n        return None\n\n    if sum(shelves) < n:\n        return []\n\n    initial_shelves = [[] for _ in shelves]\n    result = backtrack(0, initial_shelves)\n    return result if result else []\n", "test": "def check(candidate):\n    assert candidate(5, [\"A\", \"B\", \"C\", \"D\", \"E\"], [5]) == [['A', 'B', 'C', 'D', 'E']]\n    assert candidate(2, [\"Short\", \"Long\"], [1, 1]) == [['Short'], ['Long']]\n    assert candidate(5, [\"Harry Potter\", \"1984\", \"To Kill a Mockingbird\", \"Pride and Prejudice\", \"The Great Gatsby\"], [2, 2, 1]) == [['Harry Potter', '1984'], ['To Kill a Mockingbird', 'Pride and Prejudice'], ['The Great Gatsby']]\n    assert candidate(4, [\"Moby Dick\", \"War and Peace\", \"Ulysses\", \"Don Quixote\"], [1, 1, 1]) == []\n    assert candidate(3, [\"X\", \"Y\", \"Z\"], [1, 1, 1]) == [['X'], ['Y'], ['Z']]\n    assert candidate(4, [\"One\", \"Two\", \"Three\", \"Four\"], [2, 2]) == [['One', 'Two'], ['Three', 'Four']]\n    assert candidate(1, [\"Single Book\"], [1]) == [['Single Book']]\n    assert candidate(0, [], []) == []\n    assert candidate(3, [\"Book1\", \"Book2\", \"Book3\"], [1, 1, 1]) == [['Book1'], ['Book2'], ['Book3']]\n    assert candidate(6, [\"Red\", \"Blue\", \"Green\", \"Yellow\", \"Purple\", \"Orange\"], [3, 3]) == [['Red', 'Blue', 'Green'], ['Yellow', 'Purple', 'Orange']]\n", "language": "python"}
{"task_id": "revision1a_problem83", "prompt": "def encrypt_message(message: str, key: int) -> str:\n    \"\"\"\n    I am a spy working for a secret agency. I need to send encrypted messages to my colleagues.\n    We use a simple shift cipher where each letter in the message is shifted by a certain number of positions in the alphabet.\n\n    Your task is to create an encryption function that takes a message and a key (shift value) as input.\n    The function should shift each letter in the message by the key value, wrapping around the alphabet if necessary.\n    Numbers and special characters should remain unchanged.\n\n    Uppercase letters should remain uppercase, and lowercase letters should remain lowercase.\n    The alphabet used is the standard 26-letter English alphabet.\n\n    Take a message and a key as input and return the encrypted message.\n\n    Example:\n\n    Input: \"Hello, World!\", 3\n    Output: \"Khoor, Zruog!\"\n\n    Input: \"Secret Agent 007\", 15\n    Output: \"Htrgti Pvtci 007\"\n    \"\"\"\n", "entry_point": "encrypt_message", "solution": "    def shift_letter(letter: str, shift: int) -> str:\n        if letter.isalpha():\n            ascii_offset = ord('A') if letter.isupper() else ord('a')\n            return chr((ord(letter) - ascii_offset + shift) % 26 + ascii_offset)\n        return letter\n\n    return ''.join(shift_letter(char, key) for char in message)\n", "test": "def check(candidate):\n    assert candidate(\"1234567890!@#$%^&*()\", 10) == '1234567890!@#$%^&*()'\n    assert candidate(\"ABCXYZ\", 1) == 'BCDYZA'\n    assert candidate(\"aAaA\", 1) == 'bBbB'\n    assert candidate(\"\", 5) == ''\n    assert candidate(\"Zorro\", 26) == 'Zorro'\n    assert candidate(\"Mixed CASE tEsT\", 13) == 'Zvkrq PNFR gRfG'\n    assert candidate(\"The quick brown fox jumps over the lazy dog.\", 7) == 'Aol xbpjr iyvdu mve qbtwz vcly aol shgf kvn.'\n    assert candidate(\"Secret Agent 007\", 15) == 'Htrgti Pvtci 007'\n    assert candidate(\"abcxyz\", 25) == 'zabwxy'\n    assert candidate(\"Hello, World!\", 3) == 'Khoor, Zruog!'\n", "language": "python"}
{"task_id": "revision1a_problem206", "prompt": "from typing import List, Tuple\nimport re\n\ndef analyze_product_reviews(reviews: List[str]) -> Tuple[int, List[str], float]:\n    \"\"\"\n    You are working for an e-commerce company and need to analyze customer reviews for a product.\n    The function takes a list of review strings and performs the following tasks:\n    1. Count the total number of reviews.\n    2. Extract all mentioned product features (words starting with '#').\n    3. Calculate the average sentiment score (assume each review ends with a score from 1 to 5).\n\n    Use regular expressions to extract features and scores. Handle potential errors gracefully.\n\n    Example:\n    Input: [\n        \"Great product! #durable #efficient Love it! 5\",\n        \"Could be better. #size #weight Not impressed. 2\",\n        \"Decent quality for the price. #value 3\"\n    ]\n    Output: (3, ['#durable', '#efficient', '#size', '#weight', '#value'], 3.33)\n\n    Input: [\n        \"Absolutely terrible. Broke after one use. #reliability 1\",\n        \"Perfect for my needs! #compact #powerful 5\"\n    ]\n    Output: (2, ['#reliability', '#compact', '#powerful'], 3.0)\n    \"\"\"\n", "entry_point": "analyze_product_reviews", "solution": "    total_reviews = len(reviews)\n    features = []\n    total_score = 0\n    valid_reviews = 0\n\n    for review in reviews:\n        # Extract features\n        features.extend(re.findall(r'#\\w+', review))\n        \n        # Extract score\n        score_match = re.search(r'\\b[1-5]\\b$', review)\n        if score_match:\n            try:\n                score = int(score_match.group())\n                total_score += score\n                valid_reviews += 1\n            except ValueError:\n                pass  # Ignore invalid scores\n\n    # Remove duplicates and sort features\n    unique_features = sorted(list(set(features)))\n\n    # Calculate average score\n    avg_score = total_score / valid_reviews if valid_reviews > 0 else 0\n    \n    return (total_reviews, unique_features, round(avg_score, 2))\n", "test": "def check(candidate):\n    assert candidate([\"Excellent! 5\", \"Terrible! 1\", \"Meh. 3\"]) == (3, [], 3.0)\n    assert candidate([\"Invalid score. #feature 6\"]) == (1, ['#feature'], 0)\n    assert candidate([\"#quality product. 4\", \"#price is high. 2\", \"#design is sleek. 5\", \"#performance is average. 3\"]) == (4, ['#design', '#performance', '#price', '#quality'], 3.5)\n    assert candidate([\"#durability is great, but #price is high. Mixed feelings. 3\", \"#size is perfect. Love it! 5\"]) == (2, ['#durability', '#price', '#size'], 4.0)\n    assert candidate([]) == (0, [], 0)\n    assert candidate([\"#feature1 #feature2 #feature3 #feature4 #feature5 Good overall. 4\"]) == (1, ['#feature1', '#feature2', '#feature3', '#feature4', '#feature5'], 4.0)\n    assert candidate([\"Great product! #durable #efficient Love it! 5\", \"Could be better. #size #weight Not impressed. 2\", \"Decent quality for the price. #value 3\"]) == (3, ['#durable', '#efficient', '#size', '#value', '#weight'], 3.33)\n    assert candidate([\"\"]) == (1, [], 0)\n    assert candidate([\"Absolutely terrible. Broke after one use. #reliability 1\", \"Perfect for my needs! #compact #powerful 5\"]) == (2, ['#compact', '#powerful', '#reliability'], 3.0)\n    assert candidate([\"No features mentioned. Average product. 3\"]) == (1, [], 3.0)\n", "language": "python"}
{"task_id": "revision1a_problem685", "prompt": "from typing import List, Tuple\n\ndef design_network_topology(nodes: List[str], connections: List[Tuple[str, str, int]]) -> List[Tuple[str, str]]:\n    \"\"\"\n    You are tasked with designing an efficient network topology for a company's new office building.\n    The goal is to connect all the departments (nodes) while minimizing the total cable length used.\n    \n    Implement a function that takes a list of department names (nodes) and a list of possible connections\n    between departments (with associated cable lengths) as input. Return a list of tuples representing\n    the optimal connections to form a minimum spanning tree.\n    \n    Use Kruskal's algorithm to find the minimum spanning tree of the network.\n    \n    Input:\n    nodes = [\"IT\", \"HR\", \"Finance\", \"Marketing\", \"Operations\"]\n    connections = [(\"IT\", \"HR\", 5), (\"IT\", \"Finance\", 10), (\"HR\", \"Marketing\", 7),\n                   (\"Finance\", \"Marketing\", 8), (\"Finance\", \"Operations\", 12),\n                   (\"Marketing\", \"Operations\", 9), (\"HR\", \"Operations\", 6)]\n    \n    Output:\n    [(\"IT\", \"HR\"), (\"HR\", \"Operations\"), (\"HR\", \"Marketing\"), (\"Finance\", \"Marketing\")]\n    \n    Explanation: This represents the optimal network topology with minimum total cable length.\n    \"\"\"\n", "entry_point": "design_network_topology", "solution": "    \n    def find(parent, i):\n        if parent[i] == i:\n            return i\n        return find(parent, parent[i])\n\n    def union(parent, rank, x, y):\n        xroot = find(parent, x)\n        yroot = find(parent, y)\n        if rank[xroot] < rank[yroot]:\n            parent[xroot] = yroot\n        elif rank[xroot] > rank[yroot]:\n            parent[yroot] = xroot\n        else:\n            parent[yroot] = xroot\n            rank[xroot] += 1\n\n    # Sort connections by cable length\n    sorted_connections = sorted(connections, key=lambda x: x[2])\n\n    # Initialize parent and rank for each node\n    parent = {node: node for node in nodes}\n    rank = {node: 0 for node in nodes}\n\n    mst = []\n    for connection in sorted_connections:\n        node1, node2, _ = connection\n        x = find(parent, node1)\n        y = find(parent, node2)\n        if x != y:\n            mst.append((node1, node2))\n            union(parent, rank, x, y)\n\n    return mst\n", "test": "def check(candidate):\n    assert candidate([\"IT\", \"HR\", \"Finance\"], [(\"IT\", \"HR\", 5), (\"IT\", \"Finance\", 10), (\"HR\", \"Finance\", 7)]) == [('IT', 'HR'), ('HR', 'Finance')]\n    assert candidate([\"A\"], []) == []\n    assert candidate([\"A\", \"B\"], [(\"A\", \"B\", 1)]) == [('A', 'B')]\n    assert candidate([\"A\", \"B\", \"C\", \"D\"], [(\"A\", \"B\", 1), (\"B\", \"C\", 2), (\"C\", \"D\", 3), (\"D\", \"A\", 4)]) == [('A', 'B'), ('B', 'C'), ('C', 'D')]\n    assert candidate([\"X\", \"Y\", \"Z\"], [(\"X\", \"Y\", 1), (\"Y\", \"Z\", 2), (\"X\", \"Z\", 3)]) == [('X', 'Y'), ('Y', 'Z')]\n    assert candidate([\"NY\", \"LA\", \"CHI\", \"HOU\", \"PHX\"], [(\"NY\", \"LA\", 100), (\"NY\", \"CHI\", 50), (\"LA\", \"CHI\", 75), (\"CHI\", \"HOU\", 60), (\"HOU\", \"PHX\", 80), (\"LA\", \"PHX\", 90)]) == [('NY', 'CHI'), ('CHI', 'HOU'), ('LA', 'CHI'), ('HOU', 'PHX')]\n    assert candidate([\"1\", \"2\", \"3\", \"4\"], [(\"1\", \"2\", 1), (\"2\", \"3\", 1), (\"3\", \"4\", 1), (\"4\", \"1\", 1), (\"1\", \"3\", 2), (\"2\", \"4\", 2)]) == [('1', '2'), ('2', '3'), ('3', '4')]\n    assert candidate([\"1\", \"2\", \"3\", \"4\", \"5\"], [(\"1\", \"2\", 1), (\"2\", \"3\", 2), (\"3\", \"4\", 3), (\"4\", \"5\", 4), (\"5\", \"1\", 5)]) == [('1', '2'), ('2', '3'), ('3', '4'), ('4', '5')]\n    assert candidate([\"X\", \"Y\"], [(\"X\", \"Y\", 100), (\"Y\", \"X\", 50)]) == [('Y', 'X')]\n    assert candidate([\"Alpha\", \"Beta\", \"Gamma\", \"Delta\"], [(\"Alpha\", \"Beta\", 10), (\"Beta\", \"Gamma\", 20), (\"Gamma\", \"Delta\", 30), (\"Delta\", \"Alpha\", 40), (\"Alpha\", \"Gamma\", 25), (\"Beta\", \"Delta\", 35)]) == [('Alpha', 'Beta'), ('Beta', 'Gamma'), ('Gamma', 'Delta')]\n", "language": "python"}
{"task_id": "revision1a_problem586", "prompt": "from typing import List, Dict\nimport heapq\n\ndef network_delay(times: List[List[int]], n: int, k: int) -> int:\n    \"\"\"\n    You are given a network of n nodes, labeled from 1 to n. You are also given times,\n    a list of travel times as directed edges times[i] = (ui, vi, wi), where ui is the\n    source node, vi is the target node, and wi is the time it takes for a signal to\n    travel from source to target.\n\n    We will send a signal from a given node k. Return the minimum time it takes for all\n    n nodes to receive the signal. If it is impossible for all n nodes to receive the\n    signal, return -1.\n\n    Take the list of times, number of nodes n, and starting node k as input from the user\n    and return the minimum time for all nodes to receive the signal.\n\n    Example:\n    Input: times = [[2,1,1],[2,3,1],[3,4,1]], n = 4, k = 2\n    Output: 2\n    Explanation: We start at node 2. It takes 1 unit of time to reach nodes 1 and 3.\n                 From node 3, it takes 1 more unit of time to reach node 4.\n                 So, the total time taken is 2 units.\n\n    Input: times = [[1,2,1]], n = 2, k = 2\n    Output: -1\n    Explanation: We start at node 2, but we can't reach node 1.\n    \"\"\"\n", "entry_point": "network_delay", "solution": "    # Create an adjacency list to represent the graph\n    graph = {i: [] for i in range(1, n + 1)}\n    for u, v, w in times:\n        graph[u].append((v, w))\n    \n    # Initialize distances and visited set\n    distances = {i: float('inf') for i in range(1, n + 1)}\n    distances[k] = 0\n    visited = set()\n    \n    # Use a min-heap to store (distance, node) pairs\n    pq = [(0, k)]\n    \n    while pq:\n        current_dist, current_node = heapq.heappop(pq)\n        \n        if current_node in visited:\n            continue\n        \n        visited.add(current_node)\n        \n        if len(visited) == n:\n            return current_dist\n        \n        for neighbor, weight in graph[current_node]:\n            distance = current_dist + weight\n            if distance < distances[neighbor]:\n                distances[neighbor] = distance\n                heapq.heappush(pq, (distance, neighbor))\n    \n    return -1\n", "test": "def check(candidate):\n    assert candidate([[1,2,1],[1,3,1],[1,4,1],[1,5,1]], 5, 1) == 1\n    assert candidate([[1,2,1]], 2, 2) == -1\n    assert candidate([[1,2,10],[1,3,5],[2,4,1],[3,4,3]], 4, 1) == 10\n    assert candidate([[1,2,1],[2,3,1],[3,4,1],[4,5,1],[5,1,1]], 5, 1) == 4\n    assert candidate([[1,2,1],[2,1,1]], 2, 1) == 1\n    assert candidate([[1,2,1]], 2, 1) == 1\n    assert candidate([[1,2,1],[2,3,2],[1,3,4]], 3, 1) == 3\n    assert candidate([[1,2,1],[2,3,1],[3,4,1],[4,5,1]], 5, 1) == 4\n    assert candidate([[2,1,1],[2,3,1],[3,4,1]], 4, 2) == 2\n    assert candidate([[1,2,1],[2,3,2],[3,1,3]], 3, 1) == 3\n", "language": "python"}
{"task_id": "revision1a_problem354", "prompt": "def virus_spread(population: int, infection_rate: float, days: int) -> int:\n    \"\"\"\n    In a city with a given population, a new virus is spreading. The infection rate represents the number of new people \n    each infected person infects per day. We want to calculate how many people will be infected after a certain number of days.\n    \n    Use recursion to solve this problem. \n    \n    Take input for the initial population, infection rate, and number of days from the user and return the total number of \n    infected people after the specified number of days. Assume that the infection starts with one person on day 0.\n    \n    Round down to the nearest integer for fractional results at each step.\n    \n    Example:\n    Input: population = 1000000, infection_rate = 2.0, days = 10\n    Output: 1023\n    \n    Input: population = 500000, infection_rate = 3.0, days = 5\n    Output: 364\n    \"\"\"\n", "entry_point": "virus_spread", "solution": "    def spread_recursive(infected: int, remaining_days: int) -> int:\n        if remaining_days == 0:\n            return infected\n        \n        new_infections = min(population - infected, int(infected * infection_rate))\n        total_infected = infected + new_infections\n        \n        return spread_recursive(total_infected, remaining_days - 1)\n    \n    return spread_recursive(1, days)\n", "test": "def check(candidate):\n    assert candidate(1000000, 0.5, 15) == 1\n    assert candidate(50000, 4.0, 3) == 125\n    assert candidate(100000, 1.5, 7) == 467\n    assert candidate(300000, 3.5, 4) == 364\n    assert candidate(1000000, 2.0, 10) == 59049\n    assert candidate(250000, 2.5, 8) == 18301\n    assert candidate(1500000, 0.8, 20) == 1\n    assert candidate(500000, 3.0, 5) == 1024\n    assert candidate(2000000, 1.2, 12) == 9156\n    assert candidate(750000, 1.8, 6) == 305\n", "language": "python"}
{"task_id": "revision1a_problem95", "prompt": "from typing import List\n\ndef max_product_subarray(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers, find the contiguous subarray with the largest product.\n    \n    This problem simulates a financial analyst trying to find the most profitable consecutive days \n    in a stock market, where each number represents the daily percentage change.\n    \n    Use dynamic programming to solve this problem efficiently.\n    Take a list as input from the user and return the maximum product of any contiguous subarray.\n\n    Example:\n    Input: [2, 3, -2, 4]\n    Output: 6\n    Input: [-2, 0, -1]\n    Output: 0\n    Input: [-2, 3, -4]\n    Output: 24\n    \"\"\"\n", "entry_point": "max_product_subarray", "solution": "    if not nums:\n        return 0\n\n    n = len(nums)\n    max_so_far = nums[0]\n    min_so_far = nums[0]\n    result = max_so_far\n\n    for i in range(1, n):\n        curr = nums[i]\n        temp_max = max(curr, max_so_far * curr, min_so_far * curr)\n        min_so_far = min(curr, max_so_far * curr, min_so_far * curr)\n        \n        max_so_far = temp_max\n        \n        result = max(result, max_so_far)\n\n    return result\n", "test": "def check(candidate):\n    assert candidate([-2, 0, -1]) == 0\n    assert candidate([2, 3, -2, 4]) == 6\n    assert candidate([1, 2, 3, 4, 5]) == 120\n    assert candidate([-1, -2, -3, -4, -5]) == 120\n    assert candidate([0, 0, 0, 0]) == 0\n    assert candidate([1, -1, 1, -1]) == 1\n    assert candidate([]) == 0\n    assert candidate([1]) == 1\n    assert candidate([-1]) == -1\n    assert candidate([-2, 3, -4]) == 24\n", "language": "python"}
{"task_id": "revision1a_problem220", "prompt": "from typing import List, Dict\n\ndef analyze_weather_data(data: List[float]) -> Dict[str, float]:\n    \"\"\"\n    You are tasked with creating a Python function to analyze weather data for a meteorological station.\n    The function should process a list of temperature readings and provide various statistical insights.\n    Implement the following functionalities:\n\n    1. Calculate the average temperature.\n    2. Find the maximum and minimum temperatures.\n    3. Determine the temperature range (difference between max and min).\n    4. Count the number of days with temperatures above 30\u00b0C (hot days).\n    5. Count the number of days with temperatures below 0\u00b0C (freezing days).\n    6. Calculate the median temperature.\n\n    The function should return a dictionary containing all these statistics.\n\n    Example:\n    Input: [25.5, 28.3, 21.7, 32.1, 15.0, -2.1, 0.5, 29.8, 31.5, 22.2]\n    Output: {\n        'average': 20.45,\n        'maximum': 32.1,\n        'minimum': -2.1,\n        'range': 34.2,\n        'hot_days': 2,\n        'freezing_days': 1,\n        'median': 23.85\n    }\n    \"\"\"\n", "entry_point": "analyze_weather_data", "solution": "    def calculate_median(sorted_data):\n        n = len(sorted_data)\n        mid = n // 2\n        if n % 2 == 0:\n            return (sorted_data[mid - 1] + sorted_data[mid]) / 2\n        else:\n            return sorted_data[mid]\n\n    if not data:\n        return {}\n\n    sorted_data = sorted(data)\n    n = len(data)\n\n    result = {\n        'average': sum(data) / n,\n        'maximum': max(data),\n        'minimum': min(data),\n        'range': max(data) - min(data),\n        'hot_days': sum(1 for temp in data if temp > 30),\n        'freezing_days': sum(1 for temp in data if temp < 0),\n        'median': calculate_median(sorted_data)\n    }\n\n    return result\n", "test": "def check(candidate):\n    assert candidate([22.2, 22.2, 22.2, 22.2]) == {'average': 22.2, 'maximum': 22.2, 'minimum': 22.2, 'range': 0.0, 'hot_days': 0, 'freezing_days': 0, 'median': 22.2}\n    assert candidate([-10, -5, 0, 5, 10]) == {'average': 0.0, 'maximum': 10, 'minimum': -10, 'range': 20, 'hot_days': 0, 'freezing_days': 2, 'median': 0}\n    assert candidate([0, 100]) == {'average': 50.0, 'maximum': 100, 'minimum': 0, 'range': 100, 'hot_days': 1, 'freezing_days': 0, 'median': 50.0}\n    assert candidate([25.5, 28.3, 21.7, 32.1, 15.0, -2.1, 0.5, 29.8, 31.5, 22.2]) == {'average': 20.45, 'maximum': 32.1, 'minimum': -2.1, 'range': 34.2, 'hot_days': 2, 'freezing_days': 1, 'median': 23.85}\n    assert candidate([-100]) == {'average': -100.0, 'maximum': -100, 'minimum': -100, 'range': 0, 'hot_days': 0, 'freezing_days': 1, 'median': -100}\n    assert candidate([-1, -0.5, 0, 0.5, 1]) == {'average': 0.0, 'maximum': 1, 'minimum': -1, 'range': 2, 'hot_days': 0, 'freezing_days': 2, 'median': 0}\n    assert candidate([0, 0, 0, 0, 0]) == {'average': 0.0, 'maximum': 0, 'minimum': 0, 'range': 0, 'hot_days': 0, 'freezing_days': 0, 'median': 0}\n    assert candidate([100]) == {'average': 100.0, 'maximum': 100, 'minimum': 100, 'range': 0, 'hot_days': 1, 'freezing_days': 0, 'median': 100}\n    assert candidate([]) == {}\n", "language": "python"}
{"task_id": "revision1a_problem591", "prompt": "def encrypt_message(message: str, shift: int) -> str:\n    \"\"\"\n    I have a secret message that I want to encrypt using a Caesar cipher.\n    The Caesar cipher is a simple encryption technique where each letter in the plaintext\n    is shifted a certain number of places down the alphabet.\n    I need a function that takes the message and the shift value as input and returns the encrypted message.\n    If the shift value is not between 1 and 25, it should raise a ValueError.\n    If the message contains non-alphabetic characters, it should raise a TypeError.\n    Example:\n    Input: \"HELLO WORLD\", 3\n    Output: \"KHOOR ZRUOG\"\n    Input: \"HELLO WORLD\", 26\n    Output: \"ValueError: Shift value must be between 1 and 25\"\n    Input: \"HELLO WORLD!\", 3\n    Output: \"TypeError: Message must contain only alphabetic characters\"\n    \"\"\"\n", "entry_point": "encrypt_message", "solution": "    if not 1 <= shift <= 25:\n        raise ValueError(\"Shift value must be between 1 and 25\")\n    \n    if not message.replace(\" \", \"\").isalpha():\n        raise TypeError(\"Message must contain only alphabetic characters\")\n    \n    encrypted_message = \"\"\n    for char in message:\n        if char.isalpha():\n            ascii_offset = 65 if char.isupper() else 97\n            encrypted_char = chr((ord(char) - ascii_offset + shift) % 26 + ascii_offset)\n            encrypted_message += encrypted_char\n        else:\n            encrypted_message += char\n    \n    return encrypted_message\n", "test": "def check(candidate):\n    assert candidate(\"CAESAR CIPHER\", 15) == 'RPTHPG RXEWTG'\n    assert candidate(\"TESTCASE\", 13) == 'GRFGPNFR'\n    assert candidate(\"PYTHON\", 22) == 'LUPDKJ'\n    assert candidate(\"ZYXWVUTSRQPONMLKJIHGFEDCBA\", 25) == 'YXWVUTSRQPONMLKJIHGFEDCBAZ'\n    assert candidate(\"A\", 5) == 'F'\n    assert candidate(\"ENCRYPTION\", 7) == 'LUJYFWAPVU'\n    assert candidate(\"SHIFT CIPHER\", 4) == 'WLMJX GMTLIV'\n    assert candidate(\"ABCDEFGHIJKLMNOPQRSTUVWXYZ\", 1) == 'BCDEFGHIJKLMNOPQRSTUVWXYZA'\n    assert candidate(\"Z\", 1) == 'A'\n    assert candidate(\"HELLO WORLD\", 3) == 'KHOOR ZRUOG'\n", "language": "python"}
{"task_id": "revision1a_problem399", "prompt": "from typing import List, Dict\n\ndef simulate_ecosystem(years: int, initial_population: Dict[str, int], interaction_matrix: List[List[float]]) -> Dict[str, List[int]]:\n    \"\"\"\n    An ecologist wants to simulate the population dynamics of different species in an ecosystem over time.\n    Your task is to create a function that simulates the ecosystem for a given number of years.\n\n    The function should:\n    1. Initialize species populations\n    2. Simulate population changes based on species interactions\n    3. Account for birth rates, death rates, and inter-species effects\n    4. Return the population of each species for each year\n\n    Input parameters:\n    - years: number of years to simulate\n    - initial_population: dictionary with species names as keys and initial population as values\n    - interaction_matrix: 2D list representing the effect of each species on others (positive for beneficial, negative for competitive)\n\n    Example:\n    Input: 5, {\"Rabbits\": 1000, \"Foxes\": 100, \"Grass\": 5000}, [\n        [1.1, -0.3, 0.1],\n        [0.2, 0.9, -0.1],\n        [-0.1, 0, 1.2]\n    ]\n    Output: {\n        \"Rabbits\": [1000, 1100, 1210, 1331, 1464],\n        \"Foxes\": [100, 110, 121, 133, 146],\n        \"Grass\": [5000, 5500, 6050, 6655, 7320]\n    }\n    \n    Where each list represents the population of a species over the simulated years.\n    \"\"\"\n", "entry_point": "simulate_ecosystem", "solution": "    # Initialize the result dictionary with initial populations\n    result = {species: [population] for species, population in initial_population.items()}\n    \n    # Get the list of species\n    species_list = list(initial_population.keys())\n    \n    # Simulate for the given number of years\n    for year in range(1, years):\n        # Calculate new populations for each species\n        new_populations = {}\n        for i, species in enumerate(species_list):\n            # Get the current population\n            current_population = result[species][-1]\n            \n            # Calculate the change based on interactions\n            change = sum(interaction_matrix[i][j] * result[other_species][-1] \n                         for j, other_species in enumerate(species_list))\n            \n            # Calculate new population\n            new_population = max(0, int(current_population * (1 + change)))\n            \n            # Add new population to the result\n            result[species].append(new_population)\n            \n            # Store new population for next iteration\n            new_populations[species] = new_population\n        \n        # Update populations for the next year\n        for species, population in new_populations.items():\n            result[species][-1] = population\n    \n    return result\n", "test": "def check(candidate):\n    assert candidate(5, {\"Owls\": 500, \"Mice\": 10000, \"Insects\": 100000}, [[0.95, 0.1, 0.01], [-0.3, 1.1, 0.05], [-0.01, -0.1, 1.2]]) == {'Owls': [500, 1238000, 134690811038000, 17234533849170646372653727744, 282177699148298294554111574355491205552367783069421142016], 'Mice': [10000, 0, 0, 0, 0], 'Insects': [100000, 10762100000, 0, 0, 0]}\n    assert candidate(3, {\"Bacteria\": 1000000, \"Antibiotics\": 10000}, [[1.5, -0.8], [0.1, 0.9]]) == {'Bacteria': [1000000, 1492001000000, 0], 'Antibiotics': [10000, 1492001090010000, 2003460527331926742998141894656]}\n    assert candidate(5, {\"Rabbits\": 1000, \"Foxes\": 100, \"Grass\": 5000}, [[1.1, -0.3, 0.1], [0.2, 0.9, -0.1], [-0.1, 0, 1.2]]) == {'Rabbits': [1000, 1571000, 0, 0, 0], 'Foxes': [100, 31379100, 886183156508100, 706788528190794616105108242432, 449595021223898674097284386303632078790224612834619758215168], 'Grass': [5000, 0, 0, 0, 0]}\n    assert candidate(2, {\"Species A\": 100, \"Species B\": 100}, [[1.1, -0.5], [-0.5, 1.1]]) == {'Species A': [100, 6100], 'Species B': [100, 0]}\n    assert candidate(4, {\"Bees\": 10000, \"Flowers\": 100000}, [[1.1, 0.2], [0.1, 1.05]]) == {'Bees': [10000, 310010000, 192969144220619997184, 2316594348342442227137913518336651378551458359148544], 'Flowers': [100000, 3110600100000, 60024994090582139067026531942400, 13905356206953108286290021440511094735642026791903609929334064607603510422978691072]}\n    assert candidate(1, {\"Species X\": 1, \"Species Y\": 1, \"Species Z\": 1}, [[1, 0, 0], [0, 1, 0], [0, 0, 1]]) == {'Species X': [1], 'Species Y': [1], 'Species Z': [1]}\n    assert candidate(6, {\"Oak Trees\": 1000, \"Squirrels\": 5000, \"Acorns\": 100000}, [[1.01, 0.01, -0.1], [0.05, 1.1, 0.2], [0.2, -0.1, 1.05]]) == {'Oak Trees': [1000, 0, 0, 0, 0, 0], 'Squirrels': [5000, 127505000, 17883277655005000, 351792781654601212517101850329088, 136133977346710114073916707326861949345936515196057538106711080960, 20385705767058041649177213271741870949388132554748352989262550160366855584387201046462591207901769792904991398442424986169467994112], 'Acorns': [100000, 0, 0, 0, 0, 0]}\n    assert candidate(3, {\"Virus\": 1000000, \"Host Cells\": 10000000}, [[1.5, -0.3], [-0.2, 0.9]]) == {'Virus': [1000000, 0, 0], 'Host Cells': [10000000, 90000010000000, 7290001620000179521062961152]}\n    assert candidate(7, {\"Sharks\": 100, \"Tuna\": 5000, \"Plankton\": 1000000}, [[0.9, 0.2, 0], [-0.3, 1.1, 0.1], [0, -0.1, 1.2]]) == {'Sharks': [100, 109100, 7950028738100, 56882661242962239303974912, 2912073435073438558680868104584852163033114597130240, 7632154522134374064976806109247647850349153256835473124530138387338606315447250103232182757123342467072, 52424804384762558634258147929098990391207426903622067181375725094576583504676883433995661762877042565961920685783071097141023749597177288835154728513891168351259361890641176387565221749236238852230498746368], 'Tuna': [5000, 363855000, 0, 0, 0, 0, 0], 'Plankton': [1000000, 0, 0, 0, 0, 0, 0]}\n    assert candidate(1, {\"Humans\": 1000}, [[1.01]]) == {'Humans': [1000]}\n", "language": "python"}
{"task_id": "revision1a_problem512", "prompt": "from typing import List\n\ndef encrypt_message(message: str, key: List[int]) -> str:\n    \"\"\"\n    You are a secret agent tasked with encrypting classified messages.\n    Your encryption method involves shifting each letter in the message by a corresponding number in a repeating key sequence.\n    The key is a list of integers, and it repeats if the message is longer than the key.\n    Spaces and punctuation remain unchanged. The alphabet wraps around, so 'z' shifted by 1 becomes 'a'.\n    Uppercase letters should remain uppercase, and lowercase letters should remain lowercase.\n    \n    Write a function that takes a message string and a key list as input, and returns the encrypted message.\n    \n    Example:\n    Input: \"Hello, World!\", [3, 1, 4]\n    Output: \"Khpor, Zruog!\"\n    \n    Explanation:\n    H (+3) -> K\n    e (+1) -> f\n    l (+4) -> p\n    l (+3) -> o\n    o (+1) -> p\n    , (unchanged)\n    W (+4) -> Z\n    o (+3) -> r\n    r (+1) -> s\n    l (+4) -> p\n    d (+3) -> g\n    ! (unchanged)\n    \"\"\"\n", "entry_point": "encrypt_message", "solution": "    def shift_letter(char: str, shift: int) -> str:\n        if not char.isalpha():\n            return char\n        \n        ascii_offset = ord('A') if char.isupper() else ord('a')\n        shifted = (ord(char) - ascii_offset + shift) % 26 + ascii_offset\n        return chr(shifted)\n\n    encrypted = []\n    key_length = len(key)\n    \n    for i, char in enumerate(message):\n        shift = key[i % key_length]\n        encrypted.append(shift_letter(char, shift))\n    \n    return ''.join(encrypted)\n", "test": "def check(candidate):\n    assert candidate(\"!@#$%^&*()\", [10, 20, 30]) == '!@#$%^&*()'\n    assert candidate(\"Hello, World!\", [3, 1, 4]) == 'Kfpop, Xsumh!'\n    assert candidate(\"\", [1, 2, 3]) == ''\n    assert candidate(\"Punctuation, is! important.\", [3, 3, 3]) == 'Sxqfwxdwlrq, lv! lpsruwdqw.'\n    assert candidate(\"a b c d e f g\", [1]) == 'b c d e f g h'\n    assert candidate(\"Secret Agent\", [1, 2, 3, 4]) == 'Tgfvfv Ehgqx'\n    assert candidate(\"UPPERCASE\", [5, 5, 5]) == 'ZUUJWHFXJ'\n    assert candidate(\"lowercase\", [1, 1, 1]) == 'mpxfsdbtf'\n    assert candidate(\"1234567890\", [1, 2, 3]) == '1234567890'\n    assert candidate(\"Mixed Case Text\", [2, 4, 6, 8]) == 'Omdmf Iiui Bgbz'\n", "language": "python"}
{"task_id": "revision1a_problem78", "prompt": "from typing import List, Dict\nfrom itertools import combinations\n\ndef optimize_delivery_route(addresses: List[str], distances: Dict[str, Dict[str, float]]) -> List[str]:\n    \"\"\"\n    A delivery company wants to optimize their route to minimize fuel consumption.\n    Given a list of delivery addresses and a dictionary of distances between each pair of addresses,\n    determine the most efficient route that visits all addresses exactly once and returns to the starting point.\n\n    The function should implement the Traveling Salesman Problem (TSP) algorithm to find the optimal route.\n\n    Example:\n    Input: \n    addresses = [\"A\", \"B\", \"C\", \"D\"]\n    distances = {\n        \"A\": {\"B\": 10, \"C\": 15, \"D\": 20},\n        \"B\": {\"A\": 10, \"C\": 35, \"D\": 25},\n        \"C\": {\"A\": 15, \"B\": 35, \"D\": 30},\n        \"D\": {\"A\": 20, \"B\": 25, \"C\": 30}\n    }\n    Output: ['A', 'B', 'D', 'C', 'A']\n    \"\"\"\n", "entry_point": "optimize_delivery_route", "solution": "    def nearest_neighbor(start: str, unvisited: List[str]) -> List[str]:\n        route = [start]\n        current = start\n        while unvisited:\n            nearest = min(unvisited, key=lambda x: distances[current][x])\n            route.append(nearest)\n            current = nearest\n            unvisited.remove(nearest)\n        route.append(start)\n        return route\n\n    if not addresses:\n        return []\n\n    start = addresses[0]\n    unvisited = addresses[1:]\n    \n    best_route = nearest_neighbor(start, unvisited.copy())\n    best_distance = sum(distances[best_route[i]][best_route[i+1]] for i in range(len(best_route)-1))\n\n    # Try starting from each address to find the best overall route\n    for address in addresses[1:]:\n        other_addresses = [a for a in addresses if a != address]\n        route = nearest_neighbor(address, other_addresses)\n        distance = sum(distances[route[i]][route[i+1]] for i in range(len(route)-1))\n        \n        if distance < best_distance:\n            best_route = route\n            best_distance = distance\n\n    return best_route\n", "test": "def check(candidate):\n    assert candidate([\"P\", \"Q\", \"R\", \"S\", \"T\"], {\"P\": {\"Q\": 10, \"R\": 15, \"S\": 20, \"T\": 25}, \"Q\": {\"P\": 10, \"R\": 30, \"S\": 35, \"T\": 40}, \"R\": {\"P\": 15, \"Q\": 30, \"S\": 45, \"T\": 50}, \"S\": {\"P\": 20, \"Q\": 35, \"R\": 45, \"T\": 55}, \"T\": {\"P\": 25, \"Q\": 40, \"R\": 50, \"S\": 55}}) == ['P', 'Q', 'R', 'S', 'T', 'P']\n    assert candidate([\"A\", \"B\", \"C\"], {\"A\": {\"B\": 10, \"C\": 15}, \"B\": {\"A\": 10, \"C\": 20}, \"C\": {\"A\": 15, \"B\": 20}}) == ['A', 'B', 'C', 'A']\n    assert candidate([\"Home\", \"Work\", \"School\", \"Mall\"], {\"Home\": {\"Work\": 5.5, \"School\": 7.2, \"Mall\": 10.1}, \"Work\": {\"Home\": 5.5, \"School\": 3.8, \"Mall\": 6.7}, \"School\": {\"Home\": 7.2, \"Work\": 3.8, \"Mall\": 4.5}, \"Mall\": {\"Home\": 10.1, \"Work\": 6.7, \"School\": 4.5}}) == ['Home', 'Work', 'School', 'Mall', 'Home']\n    assert candidate([\"A\", \"B\", \"C\", \"D\"], {\"A\": {\"B\": 10, \"C\": 15, \"D\": 20}, \"B\": {\"A\": 10, \"C\": 35, \"D\": 25}, \"C\": {\"A\": 15, \"B\": 35, \"D\": 30}, \"D\": {\"A\": 20, \"B\": 25, \"C\": 30}}) == ['A', 'B', 'D', 'C', 'A']\n    assert candidate([\"1\", \"2\", \"3\", \"4\"], {\"1\": {\"2\": 100, \"3\": 200, \"4\": 300}, \"2\": {\"1\": 100, \"3\": 400, \"4\": 500}, \"3\": {\"1\": 200, \"2\": 400, \"4\": 600}, \"4\": {\"1\": 300, \"2\": 500, \"3\": 600}}) == ['1', '2', '3', '4', '1']\n    assert candidate([\"A\", \"B\", \"C\", \"D\", \"E\"], {\"A\": {\"B\": 1, \"C\": 2, \"D\": 3, \"E\": 4}, \"B\": {\"A\": 1, \"C\": 5, \"D\": 6, \"E\": 7}, \"C\": {\"A\": 2, \"B\": 5, \"D\": 8, \"E\": 9}, \"D\": {\"A\": 3, \"B\": 6, \"C\": 8, \"E\": 10}, \"E\": {\"A\": 4, \"B\": 7, \"C\": 9, \"D\": 10}}) == ['A', 'B', 'C', 'D', 'E', 'A']\n    assert candidate([\"X\", \"Y\"], {\"X\": {\"Y\": 5}, \"Y\": {\"X\": 5}}) == ['X', 'Y', 'X']\n    assert candidate([\"A\", \"B\", \"C\", \"D\", \"E\", \"F\"], {\"A\": {\"B\": 5, \"C\": 10, \"D\": 15, \"E\": 20, \"F\": 25}, \"B\": {\"A\": 5, \"C\": 30, \"D\": 35, \"E\": 40, \"F\": 45}, \"C\": {\"A\": 10, \"B\": 30, \"D\": 50, \"E\": 55, \"F\": 60}, \"D\": {\"A\": 15, \"B\": 35, \"C\": 50, \"E\": 65, \"F\": 70}, \"E\": {\"A\": 20, \"B\": 40, \"C\": 55, \"D\": 65, \"F\": 75}, \"F\": {\"A\": 25, \"B\": 45, \"C\": 60, \"D\": 70, \"E\": 75}}) == ['A', 'B', 'C', 'D', 'E', 'F', 'A']\n", "language": "python"}
{"task_id": "revision1a_problem653", "prompt": "import heapq\nfrom typing import List, Tuple\n\ndef schedule_tasks(tasks: List[Tuple[int, int, int]]) -> List[int]:\n    \"\"\"\n    A software development team needs to schedule their tasks efficiently. Each task has a start time, \n    end time, and a priority level. The goal is to schedule as many high-priority tasks as possible without overlaps.\n\n    Implement a solution using a greedy algorithm with priority queues.\n\n    Parameters:\n    tasks (List[Tuple[int, int, int]]): List of tasks, each represented as (start_time, end_time, priority)\n\n    Returns:\n    List[int]: Indices of the tasks that should be scheduled\n\n    Example:\n    Input: [(1, 3, 2), (2, 4, 1), (3, 5, 3), (4, 6, 2), (5, 7, 1)]\n    Output: [0, 2, 4]  # This schedules tasks with indices 0, 2, and 4\n    \"\"\"\n", "entry_point": "schedule_tasks", "solution": "    # Sort tasks based on end time\n    sorted_tasks = sorted(enumerate(tasks), key=lambda x: x[1][1])\n    \n    scheduled = []\n    priority_queue = []\n    current_time = 0\n\n    for index, (start, end, priority) in sorted_tasks:\n        # Remove tasks that have ended\n        while priority_queue and priority_queue[0][1] <= current_time:\n            heapq.heappop(priority_queue)\n        \n        # If the current task starts after or at the current time, consider it\n        if start >= current_time:\n            # Add the task to the priority queue (negative priority for max-heap behavior)\n            heapq.heappush(priority_queue, (-priority, end, index))\n            \n            # Schedule the highest priority task\n            if priority_queue:\n                _, task_end, task_index = heapq.heappop(priority_queue)\n                scheduled.append(task_index)\n                current_time = task_end\n\n    return sorted(scheduled)\n", "test": "def check(candidate):\n    assert candidate([]) == []\n    assert candidate([(1, 5, 3), (1, 5, 2), (1, 5, 1)]) == [0]\n    assert candidate([(1, 3, 1), (2, 4, 2), (3, 5, 3), (4, 6, 4), (5, 7, 5)]) == [0, 2, 4]\n    assert candidate([(1, 100, 1), (2, 3, 10)]) == [1]\n    assert candidate([(1, 2, 1)]) == [0]\n    assert candidate([(1, 2, 1), (2, 3, 2), (3, 4, 3), (4, 5, 4)]) == [0, 1, 2, 3]\n    assert candidate([(1, 2, 1), (1, 2, 2), (1, 2, 3)]) == [0]\n    assert candidate([(1, 5, 1), (2, 3, 2), (4, 6, 3)]) == [1, 2]\n    assert candidate([(1, 3, 2), (2, 4, 1), (3, 5, 3), (4, 6, 2), (5, 7, 1)]) == [0, 2, 4]\n    assert candidate([(1, 10, 1), (2, 3, 5), (4, 5, 5), (6, 7, 5), (8, 9, 5)]) == [1, 2, 3, 4]\n", "language": "python"}
{"task_id": "revision1a_problem451", "prompt": "from typing import List\n\ndef optimize_network(connections: List[List[int]], budget: int) -> List[int]:\n    \"\"\"\n    You are tasked with optimizing a computer network for a large corporation. \n    The network is represented by a list of connections, where each connection is a list [start, end, cost] \n    representing a connection between computers 'start' and 'end' with an upgrade cost of 'cost'.\n\n    Your goal is to maximize the number of upgraded connections within the given budget. \n    Implement a function that takes the list of connections and the budget as input, and returns \n    a list of indices of the connections that should be upgraded to maximize network performance.\n\n    The function should:\n    1. Sort the connections by cost in ascending order\n    2. Select as many connections as possible within the budget\n    3. Return the indices of the selected connections in the original list\n\n    Example:\n    Input: \n    connections = [[0, 1, 5], [0, 2, 2], [1, 2, 4], [1, 3, 6], [2, 3, 3]]\n    budget = 8\n\n    Output: [1, 2, 4]\n\n    Explanation: The function selects connections [0, 2, 2], [2, 3, 3], and [0, 1, 5], \n    which have indices 1, 4, and 0 in the original list, respectively.\n    \"\"\"\n", "entry_point": "optimize_network", "solution": "    # Create a list of tuples with (cost, index) for each connection\n    connections_with_index = [(conn[2], i) for i, conn in enumerate(connections)]\n    \n    # Sort the connections by cost in ascending order\n    connections_with_index.sort()\n    \n    selected_indices = []\n    remaining_budget = budget\n    \n    # Select as many connections as possible within the budget\n    for cost, index in connections_with_index:\n        if cost <= remaining_budget:\n            selected_indices.append(index)\n            remaining_budget -= cost\n        else:\n            break\n    \n    # Sort the selected indices to match the order in the original list\n    selected_indices.sort()\n    \n    return selected_indices\n", "test": "def check(candidate):\n    assert candidate([[0, 1, 1], [1, 2, 1], [2, 3, 1]], 2) == [0, 1]\n    assert candidate([[0, 1, 100], [1, 2, 200], [2, 3, 300]], 99) == []\n    assert candidate([[0, 1, 5], [0, 2, 2], [1, 2, 4], [1, 3, 6], [2, 3, 3]], 8) == [1, 4]\n    assert candidate([[0, 1, 10], [1, 2, 20], [2, 3, 30]], 50) == [0, 1]\n    assert candidate([[0, 1, 5], [1, 2, 5], [2, 3, 5], [3, 4, 5]], 15) == [0, 1, 2]\n    assert candidate([[0, 1, 1], [1, 2, 1], [2, 3, 1], [3, 4, 1], [4, 5, 1]], 3) == [0, 1, 2]\n    assert candidate([[0, 1, 2], [1, 2, 2], [2, 3, 2]], 5) == [0, 1]\n    assert candidate([[0, 1, 1000000]], 999999) == []\n    assert candidate([[0, 1, 1]], 1) == [0]\n    assert candidate([[0, 1, 1], [1, 2, 2], [2, 3, 3], [3, 4, 4], [4, 5, 5]], 10) == [0, 1, 2, 3]\n", "language": "python"}
{"task_id": "revision1a_problem306", "prompt": "from collections import deque\nfrom typing import List, Dict\n\ndef analyze_social_network(connections: Dict[str, List[str]], start_user: str, max_depth: int) -> Dict[str, int]:\n    \"\"\"\n    As a social media analyst, I need to analyze the network of connections for a given user up to a certain depth.\n    Write a function that takes a dictionary of user connections, a starting user, and a maximum depth of connections to explore.\n    The function should return a dictionary with the count of users at each depth level from the starting user.\n    Use a breadth-first search algorithm to explore the network.\n\n    Example:\n    connections = {\n        \"Alice\": [\"Bob\", \"Charlie\"],\n        \"Bob\": [\"David\", \"Eve\"],\n        \"Charlie\": [\"Frank\"],\n        \"David\": [],\n        \"Eve\": [\"George\"],\n        \"Frank\": [],\n        \"George\": []\n    }\n    start_user = \"Alice\"\n    max_depth = 2\n\n    Output: {0: 1, 1: 2, 2: 3}\n    Explanation: \n    Depth 0: Alice (1 user)\n    Depth 1: Bob, Charlie (2 users)\n    Depth 2: David, Eve, Frank (3 users)\n    \"\"\"\n", "entry_point": "analyze_social_network", "solution": "    result = {0: 1}  # Start with depth 0 and count 1 for the start_user\n    visited = set([start_user])\n    queue = deque([(start_user, 0)])  # (user, depth)\n\n    while queue and queue[0][1] < max_depth:\n        current_user, current_depth = queue.popleft()\n        next_depth = current_depth + 1\n\n        for friend in connections.get(current_user, []):\n            if friend not in visited:\n                visited.add(friend)\n                queue.append((friend, next_depth))\n                result[next_depth] = result.get(next_depth, 0) + 1\n\n    return result\n", "test": "def check(candidate):\n    assert candidate({\"A\": [\"B\", \"C\"], \"B\": [\"D\"], \"C\": [\"E\"], \"D\": [], \"E\": []}, \"A\", 3) == {0: 1, 1: 2, 2: 2}\n    assert candidate({\"Root\": [\"A\", \"B\", \"C\"], \"A\": [\"D\", \"E\"], \"B\": [\"F\"], \"C\": [\"G\", \"H\"], \"D\": [], \"E\": [], \"F\": [], \"G\": [], \"H\": []}, \"Root\", 2) == {0: 1, 1: 3, 2: 5}\n    assert candidate({\"X\": [\"Y\", \"Z\"], \"Y\": [], \"Z\": []}, \"X\", 1) == {0: 1, 1: 2}\n    assert candidate({\"Start\": [\"A\", \"B\", \"C\", \"D\", \"E\"], \"A\": [], \"B\": [], \"C\": [], \"D\": [], \"E\": []}, \"Start\", 1) == {0: 1, 1: 5}\n    assert candidate({\"User1\": [\"User2\"], \"User2\": [\"User3\"], \"User3\": [\"User1\"]}, \"User1\", 3) == {0: 1, 1: 1, 2: 1}\n    assert candidate({\"Alice\": [\"Bob\", \"Charlie\"], \"Bob\": [\"David\", \"Eve\"], \"Charlie\": [\"Frank\"], \"David\": [], \"Eve\": [\"George\"], \"Frank\": [], \"George\": []}, \"Alice\", 2) == {0: 1, 1: 2, 2: 3}\n    assert candidate({\"Solo\": []}, \"Solo\", 5) == {0: 1}\n    assert candidate({\"A\": [\"B\", \"C\"], \"B\": [\"A\", \"C\"], \"C\": [\"A\", \"B\"]}, \"A\", 2) == {0: 1, 1: 2}\n    assert candidate({\"1\": [\"2\", \"3\", \"4\"], \"2\": [\"5\", \"6\"], \"3\": [\"7\"], \"4\": [\"8\"], \"5\": [], \"6\": [], \"7\": [], \"8\": []}, \"1\", 4) == {0: 1, 1: 3, 2: 4}\n    assert candidate({\"A\": [\"B\"], \"B\": [\"C\"], \"C\": [\"D\"], \"D\": [\"E\"], \"E\": [\"F\"]}, \"A\", 10) == {0: 1, 1: 1, 2: 1, 3: 1, 4: 1, 5: 1}\n", "language": "python"}
{"task_id": "revision1a_problem730", "prompt": "import math\nfrom typing import List, Tuple\n\ndef optimize_delivery_route(locations: List[Tuple[float, float]]) -> List[int]:\n    \"\"\"\n    You are developing a route optimization algorithm for a delivery company. The company wants to find \n    the most efficient route that visits all delivery locations exactly once and returns to the starting point.\n\n    Given a list of (x, y) coordinates representing delivery locations, implement the Nearest Neighbor algorithm \n    to find a reasonably good (but not necessarily optimal) route. The Nearest Neighbor algorithm works as follows:\n    1. Start at the first location in the list.\n    2. Find the nearest unvisited location and go there.\n    3. Repeat step 2 until all locations have been visited.\n    4. Return to the starting point.\n\n    Return the route as a list of indices representing the order in which locations should be visited.\n\n    Example:\n\n    Input: [(0, 0), (1, 5), (2, 2), (5, 3), (6, 0)]\n    Output: [0, 2, 3, 4, 1, 0]\n\n    Input: [(0, 0), (2, 2), (3, 4), (1, 1)]\n    Output: [0, 3, 1, 2, 0]\n    \"\"\"\n", "entry_point": "optimize_delivery_route", "solution": "    def distance(a: Tuple[float, float], b: Tuple[float, float]) -> float:\n        return math.sqrt((a[0] - b[0])**2 + (a[1] - b[1])**2)\n\n    n = len(locations)\n    unvisited = set(range(1, n))  # All locations except the starting point\n    route = [0]  # Start with the first location\n\n    while unvisited:\n        current = route[-1]\n        nearest = min(unvisited, key=lambda x: distance(locations[current], locations[x]))\n        route.append(nearest)\n        unvisited.remove(nearest)\n\n    route.append(0)  # Return to the starting point\n    return route\n", "test": "def check(candidate):\n    assert candidate([(0, 0), (2, 2), (3, 4), (1, 1)]) == [0, 3, 1, 2, 0]\n    assert candidate([(0, 0)]) == [0, 0]\n    assert candidate([(0, 0), (1, 1), (2, 2), (3, 3), (4, 4)]) == [0, 1, 2, 3, 4, 0]\n    assert candidate([(0, 0), (1, 5), (2, 2), (5, 3), (6, 0)]) == [0, 2, 1, 3, 4, 0]\n    assert candidate([(-1, -1), (1, 1), (0, 0), (2, 2), (-2, -2)]) == [0, 2, 1, 3, 4, 0]\n    assert candidate([(1, 1), (2, 2)]) == [0, 1, 0]\n    assert candidate([(0, 0), (1, 0), (2, 0), (3, 0), (4, 0)]) == [0, 1, 2, 3, 4, 0]\n    assert candidate([(1.5, 2.7), (3.2, 4.1), (0.8, 1.9), (5.6, 7.2), (2.3, 3.4)]) == [0, 4, 1, 2, 3, 0]\n    assert candidate([(0, 0), (0, 10), (10, 0), (10, 10)]) == [0, 1, 3, 2, 0]\n    assert candidate([(0, 0), (0, 1), (0, 2), (0, 3), (0, 4)]) == [0, 1, 2, 3, 4, 0]\n", "language": "python"}
{"task_id": "revision1a_problem514", "prompt": "from typing import List\n\ndef balance_workload(tasks: List[int]) -> bool:\n    \"\"\"\n    In a software development team, we have a list of tasks with different complexity levels represented by integers. \n    We want to distribute these tasks equally between two developers so that their workload is balanced.\n    Take input from the user as a list of task complexities and return True if it's possible to divide the tasks equally, else return False.\n    The sum of complexities for each developer should be exactly the same.\n    \n    Example:\n    Input: tasks = [3, 4, 5, 3, 7, 2]\n    Output: True (Developer 1: [3, 4, 5], Developer 2: [3, 7, 2])\n    \n    Input: tasks = [2, 3, 4, 5]\n    Output: False\n    \"\"\"\n", "entry_point": "balance_workload", "solution": "    def can_partition(index: int, sum1: int, sum2: int) -> bool:\n        if index == len(tasks):\n            return sum1 == sum2\n        \n        # Try adding the current task to developer 1\n        if can_partition(index + 1, sum1 + tasks[index], sum2):\n            return True\n        \n        # Try adding the current task to developer 2\n        if can_partition(index + 1, sum1, sum2 + tasks[index]):\n            return True\n        \n        return False\n\n    total_sum = sum(tasks)\n    \n    # If the total sum is odd, it's impossible to divide equally\n    if total_sum % 2 != 0:\n        return False\n    \n    # Use recursive backtracking to check if we can partition the tasks\n    return can_partition(0, 0, 0)\n", "test": "def check(candidate):\n    assert candidate([1, 99, 100]) == True\n    assert candidate([10, 10]) == True\n    assert candidate([1, 1, 1, 1]) == True\n    assert candidate([1, 2, 3, 4, 5, 7]) == True\n    assert candidate([5, 5, 5, 5, 5, 5]) == True\n    assert candidate([3, 4, 5, 3, 7, 2]) == True\n    assert candidate([2, 3, 4, 5]) == True\n    assert candidate([]) == True\n    assert candidate([50, 50, 50, 50]) == True\n    assert candidate([100]) == False\n", "language": "python"}
{"task_id": "revision1a_problem529", "prompt": "from typing import List\n\ndef robot_path(grid: List[List[int]]) -> int:\n    \"\"\"\n    You're designing a path-finding algorithm for a cleaning robot in a rectangular room.\n    The room is represented by a grid where 0 represents an empty cell and 1 represents an obstacle.\n    The robot starts from the top-left corner (0,0) and needs to reach the bottom-right corner.\n    It can only move right or down at any point in time.\n    Your task is to calculate the number of possible unique paths the robot can take to reach its destination.\n    Take the grid as input from the user and return the number of unique paths.\n    Try to solve this using dynamic programming for efficiency.\n\n    Example 1:\n    Input: [[0,0,0],[0,1,0],[0,0,0]]\n    Output: 2 # There are two paths: right -> right -> down -> down and down -> down -> right -> right\n\n    Example 2:\n    Input: [[0,1],[0,0]]\n    Output: 1 # There is only one path: down -> right\n    \"\"\"\n", "entry_point": "robot_path", "solution": "    if not grid or not grid[0]:\n        return 0\n\n    m, n = len(grid), len(grid[0])\n    \n    # Initialize the DP table\n    dp = [[0] * n for _ in range(m)]\n    \n    # Initialize the first cell\n    dp[0][0] = 1 if grid[0][0] == 0 else 0\n    \n    # Initialize the first row\n    for j in range(1, n):\n        if grid[0][j] == 0:\n            dp[0][j] = dp[0][j-1]\n        else:\n            dp[0][j] = 0\n    \n    # Initialize the first column\n    for i in range(1, m):\n        if grid[i][0] == 0:\n            dp[i][0] = dp[i-1][0]\n        else:\n            dp[i][0] = 0\n    \n    # Fill the DP table\n    for i in range(1, m):\n        for j in range(1, n):\n            if grid[i][j] == 0:\n                dp[i][j] = dp[i-1][j] + dp[i][j-1]\n            else:\n                dp[i][j] = 0\n    \n    return dp[m-1][n-1]\n", "test": "def check(candidate):\n    assert candidate([[0]]) == 1\n    assert candidate([[0],[0]]) == 1\n    assert candidate([[0,1],[0,0]]) == 1\n    assert candidate([[0,0,0],[0,1,0],[0,0,0]]) == 2\n    assert candidate([[0,0],[0,0]]) == 2\n    assert candidate([[0,0,0]]) == 1\n    assert candidate([[0,0]]) == 1\n    assert candidate([[0],[0],[0]]) == 1\n    assert candidate([[0,0],[1,0]]) == 1\n    assert candidate([[1,0],[0,0]]) == 0\n", "language": "python"}
{"task_id": "revision1a_problem212", "prompt": "import heapq\nfrom typing import List, Tuple\n\ndef optimize_delivery_route(packages: List[Tuple[str, int, int]], truck_capacity: int) -> List[List[str]]:\n    \"\"\"\n    A delivery company wants to optimize its delivery routes based on package weights and values.\n    Implement a function that uses a priority queue (heap) to organize packages for delivery.\n    \n    Take input for:\n    1. List of tuples containing (package_id, weight, value)\n    2. Truck capacity (maximum weight it can carry)\n    \n    Return a list of delivery routes, where each route is a list of package IDs.\n    Optimize for maximum value while respecting the truck's weight capacity.\n    \n    Use a max-heap to prioritize packages based on their value-to-weight ratio.\n    \n    Example:\n    Input:\n    packages = [('P1', 10, 60), ('P2', 20, 100), ('P3', 30, 120), ('P4', 15, 80), ('P5', 25, 140)]\n    truck_capacity = 50\n    \n    Output:\n    [['P5', 'P1'], ['P2', 'P4'], ['P3']]\n    \"\"\"\n", "entry_point": "optimize_delivery_route", "solution": "    # Create a max-heap of packages based on value-to-weight ratio\n    heap = [(-value / weight, package_id, weight) for package_id, weight, value in packages]\n    heapq.heapify(heap)\n    \n    routes = []\n    current_route = []\n    current_weight = 0\n    \n    while heap:\n        ratio, package_id, weight = heapq.heappop(heap)\n        \n        if current_weight + weight <= truck_capacity:\n            current_route.append(package_id)\n            current_weight += weight\n        else:\n            if current_route:\n                routes.append(current_route)\n            current_route = [package_id]\n            current_weight = weight\n    \n    if current_route:\n        routes.append(current_route)\n    \n    return routes\n", "test": "def check(candidate):\n    assert candidate([('M1', 50, 100), ('M2', 50, 100), ('M3', 50, 100)], 100) == [['M1', 'M2'], ['M3']]\n    assert candidate([('P1', 10, 100), ('P2', 10, 90), ('P3', 10, 80), ('P4', 10, 70), ('P5', 10, 60)], 30) == [['P1', 'P2', 'P3'], ['P4', 'P5']]\n    assert candidate([('A', 5, 10), ('B', 10, 30), ('C', 15, 50)], 20) == [['C'], ['B', 'A']]\n    assert candidate([('Big', 1000, 10000)], 1000) == [['Big']]\n    assert candidate([('Small', 1, 1)], 1) == [['Small']]\n    assert candidate([('P1', 10, 60), ('P2', 20, 100), ('P3', 30, 120), ('P4', 15, 80), ('P5', 25, 140)], 50) == [['P1', 'P5', 'P4'], ['P2', 'P3']]\n    assert candidate([('A1', 1, 1), ('A2', 1, 1), ('A3', 1, 1), ('A4', 1, 1), ('A5', 1, 1)], 5) == [['A1', 'A2', 'A3', 'A4', 'A5']]\n    assert candidate([('V1', 1, 1000), ('V2', 1, 999), ('V3', 1, 998), ('V4', 1, 997), ('V5', 1, 996)], 3) == [['V1', 'V2', 'V3'], ['V4', 'V5']]\n    assert candidate([('Heavy', 100, 1000), ('Light', 1, 10)], 50) == [['Heavy'], ['Light']]\n", "language": "python"}
{"task_id": "revision1a_problem34", "prompt": "import itertools\nfrom itertools import combinations\nimport math\nfrom typing import List, Tuple\n\ndef optimize_delivery_route(locations: List[Tuple[float, float]], max_distance: float) -> List[Tuple[float, float]]:\n    \"\"\"\n    A food delivery service wants to optimize its delivery route. Given a list of customer locations \n    (represented as (x, y) coordinates) and a maximum allowed travel distance, determine the optimal \n    subset of locations that can be visited within the distance limit.\n\n    The function should use a dynamic programming approach to solve the Traveling Salesman Problem variant.\n    Start from the origin (0, 0) and return to it after visiting the selected locations.\n\n    Args:\n    locations (List[Tuple[float, float]]): List of customer locations as (x, y) coordinates.\n    max_distance (float): Maximum allowed travel distance.\n\n    Returns:\n    List[Tuple[float, float]]: Optimal subset of locations to visit.\n\n    Example:\n    Input: [(1, 1), (2, 2), (3, 3), (4, 4)], 10\n    Output: [(1, 1), (2, 2), (3, 3)]\n\n    Explanation: Visiting (1, 1), (2, 2), and (3, 3) from (0, 0) and returning has a total distance of \n    approximately 9.66, which is within the max_distance of 10.\n    \"\"\"\n", "entry_point": "optimize_delivery_route", "solution": "    def distance(p1, p2):\n        return math.sqrt((p1[0] - p2[0])**2 + (p1[1] - p2[1])**2)\n\n    def total_distance(route):\n        return sum(distance(route[i], route[i+1]) for i in range(len(route)-1)) + distance(route[-1], route[0])\n\n    n = len(locations)\n    origin = (0, 0)\n    best_route = []\n    best_value = 0\n\n    for r in range(1, n + 1):\n        for subset in combinations(locations, r):\n            route = [origin] + list(subset)\n            dist = total_distance(route)\n            if dist <= max_distance:\n                value = len(subset)\n                if value > best_value:\n                    best_value = value\n                    best_route = list(subset)\n\n    return best_route\n\n", "test": "def check(candidate):\n    assert candidate([(0, 0), (1, 1), (2, 2), (3, 3)], 12) == [(0, 0), (1, 1), (2, 2), (3, 3)]\n    assert candidate([(5, 5), (10, 10), (15, 15), (20, 20), (25, 25)], 75) == [(5, 5), (10, 10), (15, 15), (20, 20), (25, 25)]\n    assert candidate([(3, 4), (5, 12), (8, 15), (7, 24)], 50) == [(3, 4), (5, 12), (8, 15)]\n    assert candidate([(1, 0), (0, 1), (-1, 0), (0, -1)], 6) == [(1, 0), (0, 1), (-1, 0)]\n    assert candidate([(0.1, 0.1), (0.2, 0.2), (0.3, 0.3)], 1) == [(0.1, 0.1), (0.2, 0.2), (0.3, 0.3)]\n    assert candidate([(0.5, 0.5), (1.5, 1.5), (2.5, 2.5)], 8) == [(0.5, 0.5), (1.5, 1.5), (2.5, 2.5)]\n    assert candidate([(1, 1), (10, 10), (20, 20), (30, 30)], 100) == [(1, 1), (10, 10), (20, 20), (30, 30)]\n    assert candidate([(1, 1), (2, 2), (3, 3), (4, 4)], 10) == [(1, 1), (2, 2), (3, 3)]\n    assert candidate([(1, 1), (2, 2), (3, 3), (4, 4), (5, 5)], 15) == [(1, 1), (2, 2), (3, 3), (4, 4), (5, 5)]\n    assert candidate([(0, 1), (1, 0), (1, 1)], 5) == [(0, 1), (1, 0), (1, 1)]\n", "language": "python"}
{"task_id": "revision1a_problem634", "prompt": "from typing import List, Dict\n\ndef recipe_calculator(ingredients: Dict[str, float], servings: int) -> Dict[str, float]:\n    \"\"\"\n    Imagine you're a chef planning a large dinner party. You have a recipe for your signature dish, \n    but you need to adjust the ingredients based on the number of guests.\n\n    Your task is to write a function that takes a dictionary of ingredients with their quantities \n    (in grams or milliliters) for a single serving, and the number of servings you need to make. \n    The function should return a new dictionary with the adjusted quantities for each ingredient.\n\n    Input: \n    - ingredients: A dictionary where keys are ingredient names and values are quantities for one serving\n    - servings: An integer representing the number of servings you need to make\n\n    Output: A new dictionary with adjusted quantities for each ingredient\n\n    Example:\n    Input: {\"flour\": 200, \"sugar\": 50, \"butter\": 100}, 3\n    Output: {\"flour\": 600, \"sugar\": 150, \"butter\": 300}\n\n    Input: {\"chicken\": 250, \"sauce\": 30, \"vegetables\": 100}, 5\n    Output: {\"chicken\": 1250, \"sauce\": 150, \"vegetables\": 500}\n    \"\"\"\n", "entry_point": "recipe_calculator", "solution": "    adjusted_ingredients = {}\n    \n    for ingredient, quantity in ingredients.items():\n        adjusted_quantity = quantity * servings\n        adjusted_ingredients[ingredient] = adjusted_quantity\n    \n    return adjusted_ingredients\n", "test": "def check(candidate):\n    assert candidate({\"pasta\": 80, \"tomato_sauce\": 30, \"cheese\": 20}, 4) == {'pasta': 320, 'tomato_sauce': 120, 'cheese': 80}\n    assert candidate({\"salt\": 5, \"pepper\": 2}, 1) == {'salt': 5, 'pepper': 2}\n    assert candidate({\"eggs\": 2, \"milk\": 50, \"flour\": 100}, 8) == {'eggs': 16, 'milk': 400, 'flour': 800}\n    assert candidate({\"milk\": 200, \"cereal\": 50}, 2) == {'milk': 400, 'cereal': 100}\n    assert candidate({\"water\": 250, \"coffee\": 15}, 10) == {'water': 2500, 'coffee': 150}\n    assert candidate({\"chicken\": 250, \"sauce\": 30, \"vegetables\": 100}, 5) == {'chicken': 1250, 'sauce': 150, 'vegetables': 500}\n    assert candidate({\"lettuce\": 50, \"tomato\": 30, \"cucumber\": 40, \"dressing\": 15}, 3) == {'lettuce': 150, 'tomato': 90, 'cucumber': 120, 'dressing': 45}\n    assert candidate({\"potato\": 150, \"butter\": 20, \"milk\": 30}, 5) == {'potato': 750, 'butter': 100, 'milk': 150}\n    assert candidate({\"flour\": 200, \"sugar\": 50, \"butter\": 100}, 3) == {'flour': 600, 'sugar': 150, 'butter': 300}\n    assert candidate({\"rice\": 100, \"beans\": 50, \"oil\": 10}, 6) == {'rice': 600, 'beans': 300, 'oil': 60}\n", "language": "python"}
{"task_id": "revision1a_problem596", "prompt": "import contextlib\nfrom contextlib import contextmanager\nfrom typing import List, Tuple\nimport math\n\ndef optimize_wind_farm(area: Tuple[float, float], num_turbines: int) -> List[Tuple[float, float]]:\n    \"\"\"\n    You are an engineer tasked with optimizing the layout of a wind farm. \n    Given a rectangular area and the number of wind turbines to place, \n    your goal is to maximize the distance between turbines while ensuring they all fit within the designated area.\n\n    Implement a function that:\n    1. Takes the dimensions of the rectangular area (width, height) and the number of turbines\n    2. Calculates the optimal grid layout for the turbines\n    3. Returns a list of (x, y) coordinates for each turbine's position\n\n    Use context managers to handle resource allocation and cleanup for any optimization algorithms you implement.\n    Implement generator functions to yield intermediate results during the optimization process.\n\n    Example:\n    Input: (1000, 800), 12\n    Output: [\n        (166.67, 200.0), (500.0, 200.0), (833.33, 200.0),\n        (166.67, 400.0), (500.0, 400.0), (833.33, 400.0),\n        (166.67, 600.0), (500.0, 600.0), (833.33, 600.0),\n        (166.67, 800.0), (500.0, 800.0), (833.33, 800.0)\n    ]\n\n    Note: The output coordinates are approximate and may vary slightly based on the specific optimization algorithm used.\n    \"\"\"\n", "entry_point": "optimize_wind_farm", "solution": "\n    width, height = area\n\n    @contextlib.contextmanager\n    def optimization_context():\n        print(\"Starting optimization process...\")\n        yield\n        print(\"Optimization process completed.\")\n\n    def calculate_grid_dimensions():\n        aspect_ratio = width / height\n        rows = int(math.sqrt(num_turbines / aspect_ratio))\n        cols = math.ceil(num_turbines / rows)\n        return rows, cols\n\n    def generate_coordinates(rows, cols):\n        x_spacing = width / cols\n        y_spacing = height / rows\n\n        for row in range(rows):\n            for col in range(cols):\n                if row * cols + col < num_turbines:\n                    x = (col + 0.5) * x_spacing\n                    y = (row + 0.5) * y_spacing\n                    yield x, y\n\n    with optimization_context():\n        rows, cols = calculate_grid_dimensions()\n        coordinates = list(generate_coordinates(rows, cols))\n\n    return coordinates\n", "test": "def check(candidate):\n    assert candidate((1500, 750), 15) == [(93.75, 187.5), (281.25, 187.5), (468.75, 187.5), (656.25, 187.5), (843.75, 187.5), (1031.25, 187.5), (1218.75, 187.5), (1406.25, 187.5), (93.75, 562.5), (281.25, 562.5), (468.75, 562.5), (656.25, 562.5), (843.75, 562.5), (1031.25, 562.5), (1218.75, 562.5)]\n    assert candidate((2000, 1000), 20) == [(142.85714285714286, 166.66666666666666), (428.57142857142856, 166.66666666666666), (714.2857142857143, 166.66666666666666), (1000.0, 166.66666666666666), (1285.7142857142858, 166.66666666666666), (1571.4285714285716, 166.66666666666666), (1857.142857142857, 166.66666666666666), (142.85714285714286, 500.0), (428.57142857142856, 500.0), (714.2857142857143, 500.0), (1000.0, 500.0), (1285.7142857142858, 500.0), (1571.4285714285716, 500.0), (1857.142857142857, 500.0), (142.85714285714286, 833.3333333333333), (428.57142857142856, 833.3333333333333), (714.2857142857143, 833.3333333333333), (1000.0, 833.3333333333333), (1285.7142857142858, 833.3333333333333), (1571.4285714285716, 833.3333333333333)]\n    assert candidate((500, 500), 4) == [(125.0, 125.0), (375.0, 125.0), (125.0, 375.0), (375.0, 375.0)]\n    assert candidate((2500, 1500), 30) == [(156.25, 187.5), (468.75, 187.5), (781.25, 187.5), (1093.75, 187.5), (1406.25, 187.5), (1718.75, 187.5), (2031.25, 187.5), (2343.75, 187.5), (156.25, 562.5), (468.75, 562.5), (781.25, 562.5), (1093.75, 562.5), (1406.25, 562.5), (1718.75, 562.5), (2031.25, 562.5), (2343.75, 562.5), (156.25, 937.5), (468.75, 937.5), (781.25, 937.5), (1093.75, 937.5), (1406.25, 937.5), (1718.75, 937.5), (2031.25, 937.5), (2343.75, 937.5), (156.25, 1312.5), (468.75, 1312.5), (781.25, 1312.5), (1093.75, 1312.5), (1406.25, 1312.5), (1718.75, 1312.5)]\n    assert candidate((1000, 800), 12) == [(125.0, 133.33333333333334), (375.0, 133.33333333333334), (625.0, 133.33333333333334), (875.0, 133.33333333333334), (125.0, 400.0), (375.0, 400.0), (625.0, 400.0), (875.0, 400.0), (125.0, 666.6666666666667), (375.0, 666.6666666666667), (625.0, 666.6666666666667), (875.0, 666.6666666666667)]\n    assert candidate((1000, 1000), 25) == [(100.0, 100.0), (300.0, 100.0), (500.0, 100.0), (700.0, 100.0), (900.0, 100.0), (100.0, 300.0), (300.0, 300.0), (500.0, 300.0), (700.0, 300.0), (900.0, 300.0), (100.0, 500.0), (300.0, 500.0), (500.0, 500.0), (700.0, 500.0), (900.0, 500.0), (100.0, 700.0), (300.0, 700.0), (500.0, 700.0), (700.0, 700.0), (900.0, 700.0), (100.0, 900.0), (300.0, 900.0), (500.0, 900.0), (700.0, 900.0), (900.0, 900.0)]\n    assert candidate((800, 600), 10) == [(80.0, 150.0), (240.0, 150.0), (400.0, 150.0), (560.0, 150.0), (720.0, 150.0), (80.0, 450.0), (240.0, 450.0), (400.0, 450.0), (560.0, 450.0), (720.0, 450.0)]\n    assert candidate((5000, 3000), 50) == [(250.0, 300.0), (750.0, 300.0), (1250.0, 300.0), (1750.0, 300.0), (2250.0, 300.0), (2750.0, 300.0), (3250.0, 300.0), (3750.0, 300.0), (4250.0, 300.0), (4750.0, 300.0), (250.0, 900.0), (750.0, 900.0), (1250.0, 900.0), (1750.0, 900.0), (2250.0, 900.0), (2750.0, 900.0), (3250.0, 900.0), (3750.0, 900.0), (4250.0, 900.0), (4750.0, 900.0), (250.0, 1500.0), (750.0, 1500.0), (1250.0, 1500.0), (1750.0, 1500.0), (2250.0, 1500.0), (2750.0, 1500.0), (3250.0, 1500.0), (3750.0, 1500.0), (4250.0, 1500.0), (4750.0, 1500.0), (250.0, 2100.0), (750.0, 2100.0), (1250.0, 2100.0), (1750.0, 2100.0), (2250.0, 2100.0), (2750.0, 2100.0), (3250.0, 2100.0), (3750.0, 2100.0), (4250.0, 2100.0), (4750.0, 2100.0), (250.0, 2700.0), (750.0, 2700.0), (1250.0, 2700.0), (1750.0, 2700.0), (2250.0, 2700.0), (2750.0, 2700.0), (3250.0, 2700.0), (3750.0, 2700.0), (4250.0, 2700.0), (4750.0, 2700.0)]\n    assert candidate((300, 200), 6) == [(50.0, 50.0), (150.0, 50.0), (250.0, 50.0), (50.0, 150.0), (150.0, 150.0), (250.0, 150.0)]\n    assert candidate((100, 100), 1) == [(50.0, 50.0)]\n", "language": "python"}
{"task_id": "revision1a_problem21", "prompt": "from typing import List\n\ndef longest_increasing_path(matrix: List[List[int]]) -> int:\n    \"\"\"\n    You are given an m x n integer matrix. Your task is to find the length of the longest increasing path in the matrix.\n\n    From each cell, you can either move in four directions: left, right, up, or down. \n    You may not move diagonally or move outside the boundary (i.e., wrap-around is not allowed).\n\n    A path in the matrix is called increasing if for all cells in the path, the value in the next cell is strictly greater than the value in the current cell.\n\n    Take the matrix as input from the user and return the length of the longest increasing path.\n\n    Example:\n    Input: [[9,9,4],[6,6,8],[2,1,1]]\n    Output: 4\n    Explanation: The longest increasing path is [1, 2, 6, 9].\n\n    Input: [[3,4,5],[3,2,6],[2,2,1]]\n    Output: 4\n    Explanation: The longest increasing path is [3, 4, 5, 6]. Moving diagonally is not allowed.\n\n    Note: The matrix is guaranteed to be non-empty.\n    \"\"\"\n", "entry_point": "longest_increasing_path", "solution": "    if not matrix or not matrix[0]:\n        return 0\n\n    m, n = len(matrix), len(matrix[0])\n    dp = [[0] * n for _ in range(m)]\n    \n    def dfs(i, j):\n        if dp[i][j] != 0:\n            return dp[i][j]\n        \n        directions = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n        max_length = 1\n        \n        for di, dj in directions:\n            ni, nj = i + di, j + dj\n            if 0 <= ni < m and 0 <= nj < n and matrix[ni][nj] > matrix[i][j]:\n                max_length = max(max_length, 1 + dfs(ni, nj))\n        \n        dp[i][j] = max_length\n        return max_length\n    \n    max_path = 0\n    for i in range(m):\n        for j in range(n):\n            max_path = max(max_path, dfs(i, j))\n    \n    return max_path\n", "test": "def check(candidate):\n    assert candidate([[1,2],[3,4]]) == 3\n    assert candidate([[5,4,3],[6,7,8],[9,10,11]]) == 7\n    assert candidate([[1]]) == 1\n    assert candidate([[1,2,3,4],[12,13,14,5],[11,16,15,6],[10,9,8,7]]) == 16\n    assert candidate([[1,2,3],[8,9,4],[7,6,5]]) == 9\n    assert candidate([[1,2],[2,3]]) == 3\n    assert candidate([[1,1,1],[1,1,1],[1,1,1]]) == 1\n    assert candidate([[3,4,5],[3,2,6],[2,2,1]]) == 4\n    assert candidate([[7,8,9],[9,7,6],[7,2,3]]) == 6\n    assert candidate([[9,9,4],[6,6,8],[2,1,1]]) == 4\n", "language": "python"}
{"task_id": "revision1a_problem80", "prompt": "def decrypt_message(encrypted: str, key: int) -> str:\n    \"\"\"\n    You are a secret agent tasked with decrypting an important message. The message has been encrypted using a simple \n    Caesar cipher with a given key. Your job is to decrypt the message and determine if it contains a specific codeword.\n\n    The decryption process involves shifting each letter in the encrypted message back by the key value in the alphabet. \n    Spaces and punctuation should remain unchanged. After decryption, check if the message contains the codeword \"MISSION\".\n\n    If the decrypted message contains \"MISSION\", return \"Mission Found: [decrypted message]\". \n    Otherwise, return \"No Mission: [decrypted message]\".\n\n    Take the encrypted message and key as input from the user.\n\n    Example:\n    Input: Enter encrypted message: KHOOR ZRUOG\n           Enter key: 3\n    Output: No Mission: HELLO WORLD\n\n    Input: Enter encrypted message: VHFUHW PLVVLRQ FRPSOHWH\n           Enter key: 3\n    Output: Mission Found: SECRET MISSION COMPLETE\n    \"\"\"\n", "entry_point": "decrypt_message", "solution": "    def shift_char(char: str, shift: int) -> str:\n        if char.isalpha():\n            ascii_offset = 65 if char.isupper() else 97\n            return chr((ord(char) - ascii_offset - shift) % 26 + ascii_offset)\n        return char\n\n    decrypted = ''.join(shift_char(char, key) for char in encrypted)\n    \n    if \"MISSION\" in decrypted.upper():\n        return f\"Mission Found: {decrypted}\"\n    else:\n        return f\"No Mission: {decrypted}\"\n", "test": "def check(candidate):\n    assert candidate(\"KHOOR ZRUOG\", 3) == 'No Mission: HELLO WORLD'\n    assert candidate(\"NO MISSION HERE\", 5) == 'No Mission: IJ HDNNDJI CZMZ'\n    assert candidate(\"ZYXWVUTSRQPONMLKJIHGFEDCBA\", 1) == 'No Mission: YXWVUTSRQPONMLKJIHGFEDCBAZ'\n    assert candidate(\"VHFUHW PLVVLRQ FRPSOHWH\", 3) == 'Mission Found: SECRET MISSION COMPLETE'\n    assert candidate(\"CD BXHHXDC WTGT\", 21) == 'No Mission: HI GCMMCIH BYLY'\n    assert candidate(\"RNFFNBA NZCBFFNOYR\", 13) == 'No Mission: EASSAON AMPOSSABLE'\n    assert candidate(\"NJTTJPO JNQPTTJCMF\", 1) == 'Mission Found: MISSION IMPOSSIBLE'\n    assert candidate(\"TPZZPVU PTWVZZPISL\", 7) == 'Mission Found: MISSION IMPOSSIBLE'\n    assert candidate(\"MISSION IMPOSSIBLE\", 0) == 'Mission Found: MISSION IMPOSSIBLE'\n    assert candidate(\"ABCDEFGHIJKLMNOPQRSTUVWXYZ\", 1) == 'No Mission: ZABCDEFGHIJKLMNOPQRSTUVWXY'\n", "language": "python"}
{"task_id": "revision1a_problem348", "prompt": "from typing import List\nimport heapq\n\ndef network_packet_routing(nodes: int, connections: List[List[int]], source: int, destination: int) -> List[int]:\n    \"\"\"\n    You are a network engineer tasked with finding the most reliable path for data packets in a computer network.\n    The network consists of multiple nodes (routers) connected by links with varying reliability scores.\n    Your goal is to find the path from the source node to the destination node that maximizes the minimum reliability score along the path.\n\n    The input consists of:\n    1. The number of nodes in the network\n    2. A list of connections, where each connection is [node1, node2, reliability_score]\n    3. The source node\n    4. The destination node\n\n    Points to note:\n    1. Nodes are numbered from 0 to nodes-1\n    2. The reliability score is an integer from 1 to 100\n    3. If there's no path from source to destination, return an empty list\n    4. Implement this using Dijkstra's algorithm with a max-heap instead of a min-heap\n\n    Return the most reliable path as a list of node indices from source to destination.\n\n    Example:\n    Input: 5, [[0,1,90],[1,2,80],[0,3,60],[3,2,70],[2,4,85],[3,4,75]], 0, 4\n    Output: [0, 1, 2, 4]\n    \"\"\"\n", "entry_point": "network_packet_routing", "solution": "    # Create adjacency list\n    graph = [[] for _ in range(nodes)]\n    for node1, node2, reliability in connections:\n        graph[node1].append((node2, reliability))\n        graph[node2].append((node1, reliability))\n    \n    # Initialize distances and previous nodes\n    distances = [float('-inf')] * nodes\n    distances[source] = float('inf')\n    previous = [None] * nodes\n    \n    # Create max-heap\n    heap = [(-float('inf'), source)]\n    \n    while heap:\n        min_reliability, current = heapq.heappop(heap)\n        min_reliability = -min_reliability  # Convert back to positive\n        \n        if current == destination:\n            # Reconstruct path\n            path = []\n            while current is not None:\n                path.append(current)\n                current = previous[current]\n            return path[::-1]\n        \n        for neighbor, reliability in graph[current]:\n            new_min_reliability = min(min_reliability, reliability)\n            if new_min_reliability > distances[neighbor]:\n                distances[neighbor] = new_min_reliability\n                previous[neighbor] = current\n                heapq.heappush(heap, (-new_min_reliability, neighbor))\n    \n    return []  # No path found\n", "test": "def check(candidate):\n    assert candidate(6, [[0,1,90],[1,2,85],[2,3,80],[3,4,75],[4,5,70]], 0, 5) == [0, 1, 2, 3, 4, 5]\n    assert candidate(3, [[0,1,50],[1,2,50]], 0, 2) == [0, 1, 2]\n    assert candidate(2, [[0,1,1]], 0, 1) == [0, 1]\n    assert candidate(4, [[0,1,50],[1,2,50],[2,3,50],[0,3,100]], 0, 3) == [0, 3]\n    assert candidate(3, [[0,1,100],[1,2,100]], 2, 0) == [2, 1, 0]\n    assert candidate(5, [[0,1,95],[1,2,90],[2,3,85],[3,4,80],[0,4,70]], 0, 4) == [0, 1, 2, 3, 4]\n    assert candidate(3, [[0,1,10],[1,2,20]], 0, 2) == [0, 1, 2]\n    assert candidate(4, [[0,1,50],[1,2,60],[2,3,70],[0,3,40]], 0, 3) == [0, 1, 2, 3]\n    assert candidate(4, [[0,1,100],[1,2,100],[2,3,100]], 0, 3) == [0, 1, 2, 3]\n    assert candidate(5, [[0,1,90],[1,2,80],[0,3,60],[3,2,70],[2,4,85],[3,4,75]], 0, 4) == [0, 1, 2, 4]\n", "language": "python"}
{"task_id": "revision1a_problem590", "prompt": "from typing import List\n\ndef optimize_warehouse(items: List[int], shelves: int) -> int:\n    \"\"\"\n    As a warehouse manager, I need to optimize the distribution of items across shelves.\n    I have a list of items, where each integer represents the weight of an item.\n    My task is to distribute these items across a given number of shelves.\n    The goal is to minimize the maximum weight on any single shelf.\n\n    The function should take two inputs:\n    1. A list of integers representing the weights of items.\n    2. An integer representing the number of shelves available.\n\n    Return the minimum possible maximum weight on any shelf after optimal distribution.\n\n    Example:\n    Input: [10, 5, 15, 20], 3\n    Output: 20\n    \n    Explanation: The optimal distribution would be [10, 5], [15], [20],\n    where the maximum weight on any shelf is 20.\n\n    Example:\n    Input: [3, 7, 2, 5, 4, 6], 2\n    Output: 14\n    \n    Explanation: The optimal distribution would be [3, 7, 2], [5, 4, 6],\n    where the maximum weight on any shelf is 14.\n    \"\"\"\n", "entry_point": "optimize_warehouse", "solution": "    def can_distribute(max_weight: int) -> bool:\n        shelf_count = 1\n        current_weight = 0\n        for item in items:\n            if current_weight + item > max_weight:\n                shelf_count += 1\n                current_weight = item\n            else:\n                current_weight += item\n            if shelf_count > shelves:\n                return False\n        return True\n\n    left, right = max(items), sum(items)\n    result = right\n\n    while left <= right:\n        mid = (left + right) // 2\n        if can_distribute(mid):\n            result = mid\n            right = mid - 1\n        else:\n            left = mid + 1\n\n    return result\n", "test": "def check(candidate):\n    assert candidate([1, 2, 3, 4, 5, 6, 7, 8, 9, 10], 4) == 17\n    assert candidate([100], 1) == 100\n    assert candidate([10, 5, 15, 20], 3) == 20\n    assert candidate([50, 50, 50, 50], 4) == 50\n    assert candidate([1, 1, 1, 1, 1], 1) == 5\n    assert candidate([5, 5, 5, 5, 5, 5], 3) == 10\n    assert candidate([10, 10, 10, 10], 2) == 20\n    assert candidate([3, 7, 2, 5, 4, 6], 2) == 15\n    assert candidate([1, 2, 3, 4, 5], 5) == 5\n    assert candidate([1, 1000], 2) == 1000\n", "language": "python"}
{"task_id": "revision1a_problem308", "prompt": "from typing import List, Tuple\nimport math\n\ndef optimize_delivery_route(locations: List[Tuple[float, float]], fuel_capacity: float, fuel_consumption: float) -> List[int]:\n    \"\"\"\n    A delivery company wants to optimize its route for a fleet of drones. Each drone starts with a full tank of fuel\n    and needs to visit as many locations as possible before returning to the starting point (0, 0).\n\n    Given a list of location coordinates (x, y), the fuel capacity of the drone, and its fuel consumption rate per unit distance,\n    determine the optimal order of locations to visit to maximize the number of deliveries while ensuring the drone can return to base.\n\n    Use dynamic programming to solve this problem efficiently.\n\n    Parameters:\n    locations (List[Tuple[float, float]]): List of (x, y) coordinates for delivery locations\n    fuel_capacity (float): Maximum fuel the drone can carry\n    fuel_consumption (float): Fuel consumed per unit distance traveled\n\n    Returns:\n    List[int]: Optimal order of location indices to visit\n\n    Example:\n    Input: [(1, 1), (2, 2), (3, 3), (4, 4)], 20, 0.1\n    Output: [0, 1, 2]\n    \"\"\"\n", "entry_point": "optimize_delivery_route", "solution": "    def distance(p1, p2):\n        return math.sqrt((p1[0] - p2[0])**2 + (p1[1] - p2[1])**2)\n\n    n = len(locations)\n    start = (0, 0)\n    \n    # Calculate distances between all pairs of locations (including start)\n    distances = [[distance(start, loc)] + [distance(loc, other_loc) for other_loc in locations] for loc in locations]\n    distances.insert(0, [0] + [distance(start, loc) for loc in locations])\n\n    # Initialize DP table\n    dp = [[-1] * (1 << n) for _ in range(n + 1)]\n    dp[0][0] = fuel_capacity\n\n    # Helper function for recursive DP\n    def dfs(pos, visited):\n        if dp[pos][visited] != -1:\n            return dp[pos][visited]\n\n        max_fuel = -float('inf')\n        for next_pos in range(1, n + 1):\n            if visited & (1 << (next_pos - 1)) == 0:\n                remaining_fuel = dfs(next_pos, visited | (1 << (next_pos - 1))) - distances[pos][next_pos] * fuel_consumption\n                if remaining_fuel >= 0:\n                    max_fuel = max(max_fuel, remaining_fuel)\n\n        dp[pos][visited] = max_fuel\n        return max_fuel\n\n    # Find the maximum number of locations that can be visited\n    max_visited = 0\n    for mask in range(1, 1 << n):\n        if dfs(0, mask) >= 0:\n            max_visited = max(max_visited, bin(mask).count('1'))\n\n    # Reconstruct the optimal path\n    visited = 0\n    path = []\n    pos = 0\n    for _ in range(max_visited):\n        for next_pos in range(1, n + 1):\n            if visited & (1 << (next_pos - 1)) == 0:\n                new_visited = visited | (1 << (next_pos - 1))\n                if (dp[next_pos][new_visited] - distances[pos][next_pos] * fuel_consumption >= 0 and\n                    dp[0][new_visited] >= distances[next_pos][0] * fuel_consumption):\n                    path.append(next_pos - 1)\n                    visited = new_visited\n                    pos = next_pos\n                    break\n\n    return path\n", "test": "def check(candidate):\n    assert candidate([(1, 0), (0, 1), (-1, 0), (0, -1)], 5, 0.5) == []\n    assert candidate([(10, 10), (20, 20), (30, 30)], 100, 0.05) == []\n    assert candidate([(1, 1), (1, 2), (1, 3), (1, 4), (1, 5)], 15, 0.3) == []\n    assert candidate([], 10, 0.2) == []\n    assert candidate([(0.1, 0.1), (0.2, 0.2), (0.3, 0.3)], 1, 0.01) == []\n    assert candidate([(0.5, 0.5), (1, 1), (1.5, 1.5), (2, 2)], 10, 0.2) == []\n    assert candidate([(1, 1)], 5, 0.1) == []\n    assert candidate([(100, 100), (200, 200), (300, 300)], 1000, 0.5) == []\n    assert candidate([(1, 1), (2, 2), (3, 3), (4, 4), (5, 5)], 30, 0.15) == []\n    assert candidate([(1, 1), (2, 2), (3, 3), (4, 4)], 20, 0.1) == []\n", "language": "python"}
{"task_id": "revision1a_problem607", "prompt": "from typing import List\n\ndef optimize_warehouse(items: List[int], capacity: int) -> int:\n    \"\"\"\n    A warehouse manager wants to optimize the storage of items with different weights.\n    The warehouse has a limited capacity, and the manager wants to maximize the total weight stored.\n    Each item can only be stored once, and the goal is to find the maximum total weight that can be stored without exceeding the capacity.\n    This is known as the \"0/1 Knapsack Problem\" in computer science.\n    \n    Take a list of item weights and the warehouse capacity as input, and return the maximum total weight that can be stored.\n    \n    Example:\n    Input: [10, 20, 30, 40, 50], 60\n    Output: 60\n    \n    Explanation: The optimal combination is to store items with weights 20 and 40, totaling 60 which is the maximum possible within the capacity.\n    \"\"\"\n", "entry_point": "optimize_warehouse", "solution": "    n = len(items)\n    \n    # Create a 2D table to store the maximum weight for each subproblem\n    dp = [[0 for _ in range(capacity + 1)] for _ in range(n + 1)]\n    \n    # Fill the dp table\n    for i in range(1, n + 1):\n        for w in range(1, capacity + 1):\n            if items[i-1] <= w:\n                # If the current item can fit, we have two choices:\n                # 1. Include the item\n                # 2. Exclude the item\n                # We take the maximum of these two choices\n                dp[i][w] = max(items[i-1] + dp[i-1][w-items[i-1]], dp[i-1][w])\n            else:\n                # If the current item doesn't fit, we exclude it\n                dp[i][w] = dp[i-1][w]\n    \n    # The bottom-right cell contains the maximum weight that can be stored\n    return dp[n][capacity]\n", "test": "def check(candidate):\n    assert candidate([100, 200, 300], 300) == 300\n    assert candidate([5, 5, 5, 5, 5], 15) == 15\n    assert candidate([10, 20, 30, 40, 50], 60) == 60\n    assert candidate([10], 10) == 10\n    assert candidate([1, 2, 3, 4, 5, 6, 7, 8, 9, 10], 55) == 55\n    assert candidate([33, 66, 99], 100) == 99\n    assert candidate([100, 200, 300, 400, 500], 1000) == 1000\n    assert candidate([50, 50, 50], 100) == 100\n    assert candidate([1, 2, 3, 4, 5], 10) == 10\n    assert candidate([1, 1, 1, 1, 1], 3) == 3\n", "language": "python"}
{"task_id": "revision1a_problem627", "prompt": "from typing import List, Tuple\n\ndef optimize_study_schedule(subjects: List[str], hours: int) -> List[Tuple[str, float]]:\n    \"\"\"\n    As a student preparing for final exams, you want to create an optimal study schedule. \n    You have a list of subjects and a total number of hours available for studying. \n    Your goal is to allocate time to each subject based on its difficulty level.\n\n    The difficulty levels are as follows:\n    - Easy subjects: 1 hour\n    - Medium subjects: 1.5 hours\n    - Hard subjects: 2 hours\n\n    If there's not enough time to cover all subjects with their full allocated time, \n    reduce the time proportionally for each subject.\n\n    Input:\n    - subjects: A list of strings representing subject names, where:\n        * Subjects starting with 'E' are Easy\n        * Subjects starting with 'M' are Medium\n        * Subjects starting with 'H' are Hard\n    - hours: An integer representing the total available study hours\n\n    Output: A list of tuples, each containing a subject name and the allocated study time\n\n    Example:\n    Input: [\"Easy_Math\", \"Hard_Physics\", \"Medium_Chemistry\"], 4\n    Output: [(\"Easy_Math\", 0.89), (\"Hard_Physics\", 1.78), (\"Medium_Chemistry\", 1.33)]\n\n    Input: [\"Hard_Biology\", \"Medium_History\", \"Easy_Art\", \"Hard_Computer_Science\"], 6\n    Output: [(\"Hard_Biology\", 1.71), (\"Medium_History\", 1.29), (\"Easy_Art\", 0.86), (\"Hard_Computer_Science\", 1.71)]\n    \"\"\"\n", "entry_point": "optimize_study_schedule", "solution": "    difficulty_map = {'E': 1, 'M': 1.5, 'H': 2}\n    total_time = sum(difficulty_map[subject[0]] for subject in subjects)\n    \n    if total_time <= hours:\n        return [(subject, difficulty_map[subject[0]]) for subject in subjects]\n    \n    scale_factor = hours / total_time\n    return [(subject, round(difficulty_map[subject[0]] * scale_factor, 2)) for subject in subjects]\n", "test": "def check(candidate):\n    assert candidate([\"Hard_Biology\", \"Medium_History\", \"Easy_Art\", \"Hard_Computer_Science\"], 6) == [('Hard_Biology', 1.85), ('Medium_History', 1.38), ('Easy_Art', 0.92), ('Hard_Computer_Science', 1.85)]\n    assert candidate([\"Easy_Art\", \"Easy_Music\", \"Easy_PE\"], 2) == [('Easy_Art', 0.67), ('Easy_Music', 0.67), ('Easy_PE', 0.67)]\n    assert candidate([\"Medium_Economics\", \"Easy_Statistics\", \"Hard_Finance\"], 4.5) == [('Medium_Economics', 1.5), ('Easy_Statistics', 1), ('Hard_Finance', 2)]\n    assert candidate([\"Easy_English\"], 1) == [('Easy_English', 1)]\n    assert candidate([\"Easy_Math\", \"Hard_Physics\", \"Medium_Chemistry\"], 4) == [('Easy_Math', 0.89), ('Hard_Physics', 1.78), ('Medium_Chemistry', 1.33)]\n    assert candidate([\"Medium_Literature\", \"Medium_Geography\"], 3) == [('Medium_Literature', 1.5), ('Medium_Geography', 1.5)]\n    assert candidate([], 5) == []\n    assert candidate([\"Easy_Spanish\", \"Medium_French\", \"Hard_Chinese\"], 3.5) == [('Easy_Spanish', 0.78), ('Medium_French', 1.17), ('Hard_Chinese', 1.56)]\n    assert candidate([\"Hard_Calculus\"], 2) == [('Hard_Calculus', 2)]\n    assert candidate([\"Hard_Quantum_Mechanics\", \"Hard_Astrophysics\", \"Hard_Neuroscience\"], 5) == [('Hard_Quantum_Mechanics', 1.67), ('Hard_Astrophysics', 1.67), ('Hard_Neuroscience', 1.67)]\n", "language": "python"}
{"task_id": "revision1a_problem612", "prompt": "import heapq\nfrom typing import List, Tuple\n\ndef optimize_delivery_route(locations: List[Tuple[int, int]], fuel: int) -> int:\n    \"\"\"\n    As a delivery driver for an e-commerce company, I need to optimize my delivery route.\n    I have a list of delivery locations represented as (x, y) coordinates on a 2D grid.\n    My delivery truck has a limited amount of fuel, and I need to determine the maximum\n    number of deliveries I can make before running out of fuel.\n\n    The truck starts at (0, 0) and uses 1 unit of fuel to move 1 unit in any direction\n    (horizontal, vertical, or diagonal).\n\n    The function should take two inputs:\n    1. A list of tuples, where each tuple contains two integers representing the x and y\n       coordinates of a delivery location.\n    2. An integer representing the amount of fuel available.\n\n    Return the maximum number of deliveries that can be made with the given fuel.\n\n    Example:\n    Input: [(1, 2), (3, 4), (2, 3), (5, 1)], 10\n    Output: 3\n\n    Explanation: The optimal route would be (0,0) -> (1,2) -> (2,3) -> (3,4),\n    using exactly 10 units of fuel and making 3 deliveries.\n\n    Example:\n    Input: [(2, 2), (4, 4), (6, 6), (1, 5), (3, 3)], 15\n    Output: 4\n\n    Explanation: One possible optimal route is (0,0) -> (2,2) -> (3,3) -> (4,4) -> (1,5),\n    using exactly 15 units of fuel and making 4 deliveries.\n    \"\"\"\n", "entry_point": "optimize_delivery_route", "solution": "    def manhattan_distance(a, b):\n        return abs(a[0] - b[0]) + abs(a[1] - b[1])\n\n    def calculate_fuel(route):\n        total_fuel = 0\n        prev = (0, 0)\n        for location in route:\n            total_fuel += manhattan_distance(prev, location)\n            prev = location\n        return total_fuel\n\n    def backtrack(current_route, remaining_locations, remaining_fuel):\n        nonlocal max_deliveries\n        \n        if len(current_route) > max_deliveries:\n            max_deliveries = len(current_route)\n        \n        for i, location in enumerate(remaining_locations):\n            fuel_needed = manhattan_distance(current_route[-1] if current_route else (0, 0), location)\n            if fuel_needed <= remaining_fuel:\n                new_route = current_route + [location]\n                new_remaining = remaining_locations[:i] + remaining_locations[i+1:]\n                backtrack(new_route, new_remaining, remaining_fuel - fuel_needed)\n\n    max_deliveries = 0\n    locations.sort(key=lambda x: manhattan_distance((0, 0), x))\n    backtrack([], locations, fuel)\n    return max_deliveries\n", "test": "def check(candidate):\n    assert candidate([(1, 0), (0, 1), (1, 1)], 3) == 3\n    assert candidate([(1, 1), (2, 2), (3, 3)], 5) == 2\n    assert candidate([(1, 1), (2, 2), (3, 3), (4, 4), (5, 5)], 10) == 5\n    assert candidate([(0, i) for i in range(1, 6)], 10) == 5\n    assert candidate([(0, 1), (1, 0), (1, 1)], 2) == 2\n    assert candidate([(i, i) for i in range(1, 11)], 50) == 10\n    assert candidate([(0, 0)], 0) == 1\n    assert candidate([], 100) == 0\n    assert candidate([(10, 10)], 20) == 1\n    assert candidate([(5, 5), (3, 4), (1, 2), (2, 1)], 15) == 4\n", "language": "python"}
{"task_id": "revision1a_problem526", "prompt": "import math\nfrom math import radians, sin, cos, sqrt, atan2\nfrom typing import List, Dict, Union\n\ndef optimize_delivery_route(packages: List[Dict[str, Union[str, float, int]]]) -> List[str]:\n    \"\"\"\n    Optimize a delivery route for a courier service based on package weights and destinations.\n\n    Take a list of package dictionaries as input, where each dictionary contains:\n    - 'id': unique identifier for the package\n    - 'weight': weight of the package in kg\n    - 'destination': coordinates as a tuple of (latitude, longitude)\n    - 'priority': integer from 1 (lowest) to 5 (highest)\n\n    Return a list of package IDs in the optimal order for delivery, considering:\n    1. Total weight capacity of the delivery vehicle (max 500 kg)\n    2. Fuel efficiency (heavier loads consume more fuel)\n    3. Priority of packages\n    4. Proximity of destinations\n\n    Example:\n    Input: [\n        {'id': 'P1', 'weight': 10, 'destination': (40.7128, -74.0060), 'priority': 3},\n        {'id': 'P2', 'weight': 5, 'destination': (40.7142, -74.0064), 'priority': 2},\n        {'id': 'P3', 'weight': 15, 'destination': (40.7411, -73.9897), 'priority': 4},\n        {'id': 'P4', 'weight': 8, 'destination': (40.7831, -73.9712), 'priority': 1}\n    ]\n    Output: ['P3', 'P1', 'P2', 'P4']\n\n    This function simulates a real-world logistics problem faced by delivery companies\n    trying to optimize their routes for efficiency and customer satisfaction.\n    \"\"\"\n", "entry_point": "optimize_delivery_route", "solution": "    def calculate_distance(coord1, coord2):\n        # Calculate Euclidean distance between two coordinates\n        return math.sqrt((coord1[0] - coord2[0])**2 + (coord1[1] - coord2[1])**2)\n\n    def calculate_score(package, current_weight, current_location):\n        # Calculate score based on priority, weight, and distance\n        distance = calculate_distance(current_location, package['destination'])\n        priority_factor = package['priority'] * 2  # Give more weight to priority\n        weight_factor = (500 - current_weight) / 500  # Favor lighter packages when vehicle is heavier\n        distance_factor = 1 / (distance + 1)  # Favor closer destinations\n        return priority_factor * weight_factor * distance_factor\n\n    optimized_route = []\n    total_weight = 0\n    current_location = (0, 0)  # Starting point (can be adjusted if needed)\n\n    # Sort packages by priority (highest to lowest) as initial order\n    sorted_packages = sorted(packages, key=lambda x: x['priority'], reverse=True)\n\n    while sorted_packages:\n        best_package = None\n        best_score = -1\n\n        for package in sorted_packages:\n            if total_weight + package['weight'] <= 500:\n                score = calculate_score(package, total_weight, current_location)\n                if score > best_score:\n                    best_score = score\n                    best_package = package\n\n        if best_package:\n            optimized_route.append(best_package['id'])\n            total_weight += best_package['weight']\n            current_location = best_package['destination']\n            sorted_packages.remove(best_package)\n        else:\n            # If no package fits, reset the weight and continue\n            total_weight = 0\n\n    return optimized_route\n", "test": "def check(candidate):\n    assert candidate([]) == []\n", "language": "python"}
{"task_id": "revision1a_problem706", "prompt": "from collections import deque\nfrom typing import List, Tuple\n\ndef network_connectivity(n: int, m: int, connections: List[Tuple[int, int]], latency: int) -> bool:\n    \"\"\"\n    In a new network simulation game, you need to check if all nodes can communicate within a given latency.\n    You will be given the number of nodes, number of connections, a list of connections, and maximum allowed latency.\n    Each connection is represented as a tuple (node1, node2) indicating a direct link between two nodes.\n    Take input from the user for the number of nodes, number of connections, list of connections, and maximum allowed latency.\n    Return True if all nodes can communicate with each other within the given latency, else return False.\n\n    Example:\n    Input: 5, 6, [(0,1), (0,2), (1,2), (2,3), (2,4), (3,4)], 2\n    Output: True\n    Input: 4, 3, [(0,1), (1,2), (2,3)], 1\n    Output: False\n    \"\"\"\n", "entry_point": "network_connectivity", "solution": "    # Create an adjacency list to represent the network\n    graph = [[] for _ in range(n)]\n    for u, v in connections:\n        graph[u].append(v)\n        graph[v].append(u)\n    \n    def bfs(start: int) -> List[int]:\n        distances = [-1] * n\n        distances[start] = 0\n        queue = deque([start])\n        \n        while queue:\n            node = queue.popleft()\n            for neighbor in graph[node]:\n                if distances[neighbor] == -1:\n                    distances[neighbor] = distances[node] + 1\n                    queue.append(neighbor)\n        \n        return distances\n    \n    # Check connectivity and latency for each node\n    for i in range(n):\n        distances = bfs(i)\n        if -1 in distances or max(distances) > latency:\n            return False\n    \n    return True\n", "test": "def check(candidate):\n    assert candidate(6, 5, [(0,1), (1,2), (2,3), (3,4), (4,5)], 3) == False\n    assert candidate(3, 2, [(0,1), (1,2)], 1) == False\n    assert candidate(4, 3, [(0,1), (1,2), (2,3)], 1) == False\n    assert candidate(2, 1, [(0,1)], 1) == True\n    assert candidate(5, 6, [(0,1), (0,2), (1,2), (2,3), (2,4), (3,4)], 2) == True\n    assert candidate(5, 4, [(0,1), (1,2), (2,3), (3,4)], 2) == False\n    assert candidate(7, 6, [(0,1), (1,2), (2,3), (3,4), (4,5), (5,6)], 2) == False\n    assert candidate(4, 6, [(0,1), (0,2), (0,3), (1,2), (1,3), (2,3)], 1) == True\n    assert candidate(3, 3, [(0,1), (1,2), (0,2)], 1) == True\n    assert candidate(10, 9, [(0,1), (1,2), (2,3), (3,4), (4,5), (5,6), (6,7), (7,8), (8,9)], 5) == False\n", "language": "python"}
{"task_id": "revision1a_problem1", "prompt": "import math\nfrom typing import List, Tuple\n\ndef optimize_delivery_route(locations: List[Tuple[float, float]]) -> List[int]:\n    \"\"\"\n    Imagine you're a delivery driver for an e-commerce company. You need to deliver packages to multiple locations in a city.\n    Your task is to find the most efficient route that visits all locations exactly once and returns to the starting point.\n    \n    This is known as the Traveling Salesman Problem. We'll use a simple approximation algorithm to solve it.\n    \n    Input: A list of tuples, where each tuple contains the (x, y) coordinates of a delivery location.\n    Output: A list of integers representing the order in which to visit the locations.\n    \n    Example:\n    Input: [(0, 0), (1, 5), (2, 2), (5, 3), (6, 1)]\n    Output: [0, 2, 1, 3, 4, 0]\n    \n    This output means: Start at location 0, then visit locations 2, 1, 3, 4 in that order, and finally return to location 0.\n    \n    Note: This function uses a greedy algorithm and may not always find the absolute optimal route, but it should provide a reasonably good approximation.\n    \"\"\"\n", "entry_point": "optimize_delivery_route", "solution": "    def distance(point1: Tuple[float, float], point2: Tuple[float, float]) -> float:\n        return math.sqrt((point1[0] - point2[0])**2 + (point1[1] - point2[1])**2)\n\n    n = len(locations)\n    unvisited = set(range(1, n))\n    route = [0]\n    current = 0\n\n    while unvisited:\n        next_location = min(unvisited, key=lambda x: distance(locations[current], locations[x]))\n        route.append(next_location)\n        unvisited.remove(next_location)\n        current = next_location\n\n    route.append(0)  # Return to the starting point\n    return route\n", "test": "def check(candidate):\n    assert candidate([(-1, -1), (-2, -2), (-3, -3), (-4, -4)]) == [0, 1, 2, 3, 0]\n    assert candidate([(0, 0), (3, 4), (5, 12), (9, 8), (12, 5)]) == [0, 1, 3, 4, 2, 0]\n    assert candidate([(1, 1), (1, 2), (1, 3), (1, 4), (1, 5)]) == [0, 1, 2, 3, 4, 0]\n    assert candidate([(0, 0)]) == [0, 0]\n    assert candidate([(0, 0), (0, 5), (5, 0), (5, 5)]) == [0, 1, 3, 2, 0]\n    assert candidate([(0, 0), (1, 5), (2, 2), (5, 3), (6, 1)]) == [0, 2, 1, 3, 4, 0]\n    assert candidate([(1, 1), (2, 2)]) == [0, 1, 0]\n    assert candidate([(0, 0), (1, 0), (1, 1), (0, 1)]) == [0, 1, 2, 3, 0]\n    assert candidate([(100, 100), (200, 200), (300, 300), (400, 400)]) == [0, 1, 2, 3, 0]\n    assert candidate([(0.5, 0.5), (1.5, 1.5), (2.5, 2.5)]) == [0, 1, 2, 0]\n", "language": "python"}
{"task_id": "revision1a_problem239", "prompt": "from typing import List, Tuple\nfrom itertools import groupby\n\ndef compress_genome(sequence: str) -> List[Tuple[str, int]]:\n    \"\"\"\n    In genomics research, scientists often work with long DNA sequences.\n    To save storage space, we need to compress these sequences efficiently.\n    Implement a run-length encoding algorithm for DNA sequences.\n\n    The function should take a DNA sequence (string of A, T, G, C) as input\n    and return a list of tuples, where each tuple contains a nucleotide and its count.\n    Use list comprehensions and generator expressions for efficient implementation.\n\n    Example:\n    Input: \"AAAAABBBCCCCDDDDEEEE\"\n    Output: [('A', 5), ('B', 3), ('C', 4), ('D', 4), ('E', 4)]\n    Input: \"ATGCATGCATGCATGC\"\n    Output: [('A', 1), ('T', 1), ('G', 1), ('C', 1)] * 4\n    \"\"\"\n", "entry_point": "compress_genome", "solution": "    return [(nucleotide, sum(1 for _ in group)) for nucleotide, group in groupby(sequence)]\n", "test": "def check(candidate):\n    assert candidate(\"AAAATTTTGGGGCCCC\") == [('A', 4), ('T', 4), ('G', 4), ('C', 4)]\n    assert candidate(\"AAAAABBBCCCCDDDDEEEE\") == [('A', 5), ('B', 3), ('C', 4), ('D', 4), ('E', 4)]\n    assert candidate(\"ATATATATATAT\") == [('A', 1), ('T', 1), ('A', 1), ('T', 1), ('A', 1), ('T', 1), ('A', 1), ('T', 1), ('A', 1), ('T', 1), ('A', 1), ('T', 1)]\n    assert candidate(\"ACTGACTGACTGACTGACTG\") == [('A', 1), ('C', 1), ('T', 1), ('G', 1), ('A', 1), ('C', 1), ('T', 1), ('G', 1), ('A', 1), ('C', 1), ('T', 1), ('G', 1), ('A', 1), ('C', 1), ('T', 1), ('G', 1), ('A', 1), ('C', 1), ('T', 1), ('G', 1)]\n    assert candidate(\"ATGCATGCATGCATGC\") == [('A', 1), ('T', 1), ('G', 1), ('C', 1), ('A', 1), ('T', 1), ('G', 1), ('C', 1), ('A', 1), ('T', 1), ('G', 1), ('C', 1), ('A', 1), ('T', 1), ('G', 1), ('C', 1)]\n    assert candidate(\"GGGGGGGGGGGGGGGGGGGG\") == [('G', 20)]\n    assert candidate(\"A\") == [('A', 1)]\n    assert candidate(\"ATGC\") == [('A', 1), ('T', 1), ('G', 1), ('C', 1)]\n    assert candidate(\"AAAA\") == [('A', 4)]\n    assert candidate(\"\") == []\n", "language": "python"}
{"task_id": "revision1a_problem525", "prompt": "from typing import List, Tuple\nimport os\n\ndef analyze_stock_data(n: int, stock_prices: List[float], threshold: float) -> Tuple[float, List[int]]:\n    \"\"\"\n    Analyze stock price data to identify significant price movements and calculate average volatility.\n\n    This function processes a series of stock prices, identifies days with price changes exceeding a given threshold,\n    and calculates the average daily price volatility.\n\n    1. Accept user input for the number of days (n) and allow input of stock prices for each day.\n    2. Write these prices to a file named 'stock_data.txt'.\n    3. Read the contents of 'stock_data.txt', analyze the price movements, and output:\n       a) A list of days (indexed from 1) where the price change exceeded the threshold.\n       b) The average daily volatility (average absolute price change).\n\n    Args:\n    n (int): Number of days of stock data.\n    stock_prices (List[float]): List of daily closing stock prices.\n    threshold (float): The price change threshold to identify significant movements.\n\n    Returns:\n    Tuple[float, List[int]]: A tuple containing the average volatility and a list of days with significant price changes.\n\n    Example:\n    Input: 5, [100.0, 101.5, 99.8, 102.3, 101.7], 1.5\n    Output: (1.24, [3, 4])\n\n    Input: 7, [50.0, 51.2, 50.8, 52.5, 51.9, 53.1, 52.7], 1.0\n    Output: (1.03, [2, 4, 6])\n    \"\"\"\n", "entry_point": "analyze_stock_data", "solution": "    # Write stock prices to file\n    with open('stock_data.txt', 'w') as file:\n        for price in stock_prices:\n            file.write(f\"{price}\\n\")\n\n    # Read stock prices from file\n    with open('stock_data.txt', 'r') as file:\n        prices = [float(line.strip()) for line in file]\n\n    # Calculate price changes and identify significant movements\n    price_changes = [abs(prices[i] - prices[i-1]) for i in range(1, len(prices))]\n    significant_days = [i+1 for i, change in enumerate(price_changes) if change > threshold]\n\n    # Calculate average volatility\n    average_volatility = sum(price_changes) / len(price_changes)\n\n    return (round(average_volatility, 2), significant_days)\n", "test": "def check(candidate):\n    assert candidate(5, [50.0, 49.5, 51.0, 50.5, 50.2], 1.0) == (0.7, [2])\n    assert candidate(3, [10.0, 10.5, 10.2], 0.3) == (0.4, [1, 2])\n    assert candidate(5, [100.0, 101.5, 99.8, 102.3, 101.7], 1.5) == (1.57, [2, 3])\n    assert candidate(4, [200.0, 205.0, 198.0, 210.0], 5.0) == (8.0, [2, 3])\n    assert candidate(6, [80.0, 82.0, 79.0, 83.0, 81.0, 84.0], 2.5) == (2.8, [2, 3, 5])\n    assert candidate(7, [50.0, 51.2, 50.8, 52.5, 51.9, 53.1, 52.7], 1.0) == (0.92, [1, 3, 5])\n    assert candidate(8, [1000.0, 1005.0, 995.0, 1010.0, 1015.0, 1020.0, 1018.0, 1025.0], 10.0) == (7.0, [3])\n    assert candidate(3, [25.0, 25.0, 25.0], 0.1) == (0.0, [])\n    assert candidate(6, [75.5, 76.0, 75.8, 76.2, 75.9, 76.5], 0.5) == (0.4, [5])\n    assert candidate(10, [100.0, 101.0, 102.0, 103.0, 104.0, 105.0, 106.0, 107.0, 108.0, 109.0], 2.0) == (1.0, [])\n", "language": "python"}
{"task_id": "revision1a_problem541", "prompt": "import heapq\nfrom typing import List, Tuple\n\ndef schedule_tasks(tasks: List[Tuple[str, int, int]], processors: int) -> List[List[Tuple[str, int, int]]]:\n    \"\"\"\n    A cloud computing platform needs to efficiently schedule incoming tasks across multiple processors.\n    Each task has a name, arrival time, and estimated execution time. The goal is to minimize the overall completion time\n    of all tasks while balancing the load across available processors.\n\n    Parameters:\n    tasks: A list of tuples, where each tuple contains (task_name: str, arrival_time: int, execution_time: int)\n    processors: The number of available processors\n\n    Returns:\n    A list of lists, where each sublist represents a processor's schedule.\n    Each item in the sublist is a tuple (task_name: str, start_time: int, end_time: int)\n\n    Example:\n    Input:\n    tasks = [(\"T1\", 0, 3), (\"T2\", 1, 2), (\"T3\", 3, 1), (\"T4\", 5, 4)]\n    processors = 2\n\n    Output:\n    [\n        [(\"T1\", 0, 3), (\"T3\", 3, 4), (\"T4\", 5, 9)],\n        [(\"T2\", 1, 3)]\n    ]\n\n    This problem involves working with priority queues, scheduling algorithms, and time complexity analysis.\n    \"\"\"\n", "entry_point": "schedule_tasks", "solution": "    # Sort tasks by arrival time\n    sorted_tasks = sorted(tasks, key=lambda x: x[1])\n    \n    # Initialize processors with their availability time\n    processor_queue = [(0, i) for i in range(processors)]\n    heapq.heapify(processor_queue)\n    \n    # Initialize the schedule for each processor\n    schedule = [[] for _ in range(processors)]\n    \n    for task in sorted_tasks:\n        task_name, arrival_time, execution_time = task\n        \n        # Get the earliest available processor\n        processor_time, processor_id = heapq.heappop(processor_queue)\n        \n        # Calculate the start time for the task\n        start_time = max(processor_time, arrival_time)\n        end_time = start_time + execution_time\n        \n        # Add the task to the processor's schedule\n        schedule[processor_id].append((task_name, start_time, end_time))\n        \n        # Update the processor's availability time and put it back in the queue\n        heapq.heappush(processor_queue, (end_time, processor_id))\n    \n    return schedule\n", "test": "def check(candidate):\n    assert candidate([(\"T1\", 0, 3), (\"T2\", 0, 3), (\"T3\", 0, 3), (\"T4\", 0, 3)], 4) == [[('T1', 0, 3)], [('T2', 0, 3)], [('T3', 0, 3)], [('T4', 0, 3)]]\n    assert candidate([(\"A\", 0, 1), (\"B\", 1, 1), (\"C\", 2, 1), (\"D\", 3, 1)], 2) == [[('A', 0, 1), ('C', 2, 3)], [('B', 1, 2), ('D', 3, 4)]]\n    assert candidate([(\"Task\", 100, 1)], 1) == [[('Task', 100, 101)]]\n    assert candidate([(\"Task1\", 0, 10), (\"Task2\", 0, 5), (\"Task3\", 0, 8)], 1) == [[('Task1', 0, 10), ('Task2', 10, 15), ('Task3', 15, 23)]]\n    assert candidate([(\"P1\", 0, 1), (\"P2\", 0, 1), (\"P3\", 0, 1), (\"P4\", 0, 1)], 2) == [[('P1', 0, 1), ('P3', 1, 2)], [('P2', 0, 1), ('P4', 1, 2)]]\n    assert candidate([(\"A\", 0, 5), (\"B\", 10, 5), (\"C\", 20, 5)], 1) == [[('A', 0, 5), ('B', 10, 15), ('C', 20, 25)]]\n    assert candidate([(\"A\", 0, 5), (\"B\", 1, 3), (\"C\", 2, 2), (\"D\", 4, 4)], 3) == [[('A', 0, 5)], [('B', 1, 4), ('D', 4, 8)], [('C', 2, 4)]]\n    assert candidate([(\"Long\", 0, 100), (\"Short1\", 10, 1), (\"Short2\", 20, 1)], 2) == [[('Long', 0, 100)], [('Short1', 10, 11), ('Short2', 20, 21)]]\n    assert candidate([(\"T1\", 0, 3), (\"T2\", 1, 2), (\"T3\", 3, 1), (\"T4\", 5, 4)], 2) == [[('T1', 0, 3), ('T3', 3, 4)], [('T2', 1, 3), ('T4', 5, 9)]]\n    assert candidate([(\"X\", 1, 1), (\"Y\", 2, 2), (\"Z\", 3, 3)], 4) == [[('X', 1, 2)], [('Y', 2, 4)], [('Z', 3, 6)], []]\n", "language": "python"}
{"task_id": "revision1a_problem644", "prompt": "from typing import List\n\ndef maximize_profit(prices: List[int], k: int) -> int:\n    \"\"\"\n    I'm a stock trader who wants to maximize my profit. I have a list of stock prices for the next n days, \n    and I'm allowed to complete at most k transactions (a transaction is defined as buying one share and \n    selling it later).\n\n    Take input from the user in the form of:\n    - A list of integers representing the stock prices for each day\n    - An integer k representing the maximum number of allowed transactions\n\n    Return the maximum profit that can be achieved.\n\n    Use dynamic programming to solve this problem. Create a 2D DP table where dp[i][j] represents the maximum \n    profit that can be achieved with up to i transactions by day j.\n\n    Example:\n    Input:\n    prices = [3, 2, 6, 5, 0, 3]\n    k = 2\n\n    Output: 7\n    Explanation: Buy on day 2 (price = 2) and sell on day 3 (price = 6), profit = 6-2 = 4.\n                 Then buy on day 5 (price = 0) and sell on day 6 (price = 3), profit = 3-0 = 3.\n    \"\"\"\n", "entry_point": "maximize_profit", "solution": "    if not prices or k == 0:\n        return 0\n\n    n = len(prices)\n    \n    # If k is larger than n/2, we can make as many transactions as we want\n    if k > n // 2:\n        return sum(max(prices[i+1] - prices[i], 0) for i in range(n-1))\n\n    # Initialize the DP table\n    dp = [[0 for _ in range(n)] for _ in range(k+1)]\n\n    for i in range(1, k+1):\n        max_diff = -prices[0]\n        for j in range(1, n):\n            dp[i][j] = max(dp[i][j-1], prices[j] + max_diff)\n            max_diff = max(max_diff, dp[i-1][j] - prices[j])\n\n    return dp[k][n-1]\n", "test": "def check(candidate):\n    assert candidate([1, 2, 3, 4, 5], 0) == 0\n    assert candidate([1, 2, 3, 4, 5], 5) == 4\n    assert candidate([3, 2, 6, 5, 0, 3], 2) == 7\n    assert candidate([3, 3, 5, 0, 0, 3, 1, 4], 2) == 6\n    assert candidate([1, 2], 1) == 1\n    assert candidate([1], 1) == 0\n    assert candidate([1, 2, 1, 2, 1, 2, 1], 3) == 3\n    assert candidate([7, 6, 4, 3, 1], 2) == 0\n    assert candidate([7, 1, 5, 3, 6, 4], 1) == 5\n    assert candidate([1, 2, 3, 4, 5], 2) == 4\n", "language": "python"}
{"task_id": "revision1a_problem284", "prompt": "import heapq\nfrom typing import List\nfrom collections import defaultdict\nimport heapq\n\ndef network_reliability(n: int, m: int, connections: List[List[int]], queries: List[List[int]]) -> List[float]:\n    \"\"\"\n    You are a network engineer tasked with analyzing the reliability of a computer network.\n    The network consists of n nodes (numbered from 1 to n) and m connections between them.\n    Each connection has a reliability percentage.\n    \n    You need to process q queries, where each query asks for the reliability of the path\n    between two nodes. The reliability of a path is the product of the reliabilities of its connections.\n    \n    Take input from the user for:\n    - The number of nodes (n) and connections (m)\n    - The connections as triplets: [node1, node2, reliability]\n    - The number of queries (q)\n    - The queries as pairs: [start_node, end_node]\n    \n    Return a list of floats representing the reliability for each query, rounded to 2 decimal places.\n    If there's no path between the nodes, return 0.00 for that query.\n    \n    Example:\n    Input: \n    4, 5  # 4 nodes, 5 connections\n    [[1, 2, 0.9], [1, 3, 0.8], [2, 3, 0.7], [2, 4, 0.5], [3, 4, 0.6]]\n    3  # 3 queries\n    [[1, 4], [2, 3], [1, 3]]\n    \n    Output: [0.54, 0.70, 0.80]\n    \n    Explanation:\n    Query 1: 1 -> 2 -> 4 (0.9 * 0.5 = 0.45) or 1 -> 3 -> 4 (0.8 * 0.6 = 0.48). Max is 0.48.\n    Query 2: 2 -> 3 (0.7)\n    Query 3: 1 -> 3 (0.8)\n    \"\"\"\n", "entry_point": "network_reliability", "solution": "    \n    def dijkstra(start, end):\n        pq = [(-1, start)]\n        visited = set()\n        \n        while pq:\n            reliability, node = heapq.heappop(pq)\n            reliability = -reliability\n            \n            if node == end:\n                return reliability\n            \n            if node in visited:\n                continue\n            \n            visited.add(node)\n            \n            for neighbor, edge_reliability in graph[node]:\n                if neighbor not in visited:\n                    new_reliability = reliability * edge_reliability\n                    heapq.heappush(pq, (-new_reliability, neighbor))\n        \n        return 0  # No path found\n    \n    # Build the graph\n    graph = defaultdict(list)\n    for u, v, r in connections:\n        graph[u].append((v, r))\n        graph[v].append((u, r))\n    \n    # Process queries\n    results = []\n    for start, end in queries:\n        reliability = dijkstra(start, end)\n        results.append(round(reliability, 2))\n    \n    return results\n", "test": "def check(candidate):\n    assert candidate(3, 0, [], [[1, 2], [1, 3], [2, 3]]) == [0, 0, 0]\n    assert candidate(3, 3, [[1, 2, 1.0], [2, 3, 1.0], [1, 3, 0.5]], [[1, 3], [1, 2], [2, 3]]) == [1.0, 1.0, 1.0]\n    assert candidate(4, 5, [[1, 2, 0.9], [1, 3, 0.8], [2, 3, 0.7], [2, 4, 0.5], [3, 4, 0.6]], [[1, 4], [2, 3], [1, 3]]) == [0.48, 0.72, 0.8]\n    assert candidate(3, 2, [[1, 2, 0.5], [2, 3, 0.5]], [[1, 3], [3, 1], [2, 2]]) == [0.25, 0.25, 1]\n    assert candidate(4, 6, [[1, 2, 0.5], [1, 3, 0.6], [1, 4, 0.7], [2, 3, 0.8], [2, 4, 0.9], [3, 4, 1.0]], [[1, 4], [2, 3], [1, 2]]) == [0.7, 0.9, 0.63]\n    assert candidate(5, 4, [[1, 2, 0.9], [2, 3, 0.8], [3, 4, 0.7], [4, 5, 0.6]], [[1, 5], [2, 4], [1, 3]]) == [0.3, 0.56, 0.72]\n    assert candidate(6, 6, [[1, 2, 0.9], [2, 3, 0.8], [3, 4, 0.7], [4, 5, 0.6], [5, 6, 0.5], [1, 6, 0.4]], [[1, 6], [1, 4], [2, 5]]) == [0.4, 0.5, 0.34]\n    assert candidate(2, 1, [[1, 2, 0.75]], [[1, 2], [2, 1]]) == [0.75, 0.75]\n    assert candidate(5, 10, [[1, 2, 0.9], [1, 3, 0.8], [1, 4, 0.7], [1, 5, 0.6], [2, 3, 0.5], [2, 4, 0.4], [2, 5, 0.3], [3, 4, 0.2], [3, 5, 0.1], [4, 5, 0.05]], [[1, 5], [2, 4], [3, 5]]) == [0.6, 0.63, 0.48]\n    assert candidate(7, 6, [[1, 2, 0.9], [2, 3, 0.8], [3, 4, 0.7], [4, 5, 0.6], [5, 6, 0.5], [6, 7, 0.4]], [[1, 7], [3, 5], [2, 6]]) == [0.06, 0.42, 0.17]\n", "language": "python"}
{"task_id": "revision1a_problem101", "prompt": "from typing import List\n\ndef minimum_cost_path(grid: List[List[int]]) -> int:\n    \"\"\"\n    You are a delivery driver navigating through a city represented by a grid. Each cell in the grid represents a street, and the number in the cell represents the cost (in terms of time or fuel) to pass through that street.\n\n    Your task is to find the minimum cost path from the top-left corner of the city (grid[0][0]) to the bottom-right corner (grid[m-1][n-1]), where m and n are the number of rows and columns in the grid respectively.\n\n    You can only move either down or right at any point in time.\n\n    Write a function that takes the grid as input and returns the minimum cost of the path from top-left to bottom-right.\n\n    Example:\n    Input: grid = [[1,3,1],\n                   [1,5,1],\n                   [4,2,1]]\n    Output: 7\n    Explanation: The path 1\u21923\u21921\u21921\u21921 minimizes the sum.\n\n    Input: grid = [[1,2,3],\n                   [4,5,6]]\n    Output: 12\n    Explanation: The path 1\u21922\u21923\u21926 minimizes the sum.\n    \"\"\"\n", "entry_point": "minimum_cost_path", "solution": "    if not grid or not grid[0]:\n        return 0\n\n    m, n = len(grid), len(grid[0])\n    dp = [[0] * n for _ in range(m)]\n    \n    # Initialize the first cell\n    dp[0][0] = grid[0][0]\n    \n    # Initialize the first row\n    for j in range(1, n):\n        dp[0][j] = dp[0][j-1] + grid[0][j]\n    \n    # Initialize the first column\n    for i in range(1, m):\n        dp[i][0] = dp[i-1][0] + grid[i][0]\n    \n    # Fill the dp table\n    for i in range(1, m):\n        for j in range(1, n):\n            dp[i][j] = min(dp[i-1][j], dp[i][j-1]) + grid[i][j]\n    \n    # Return the minimum cost to reach the bottom-right corner\n    return dp[m-1][n-1]\n", "test": "def check(candidate):\n    assert candidate([[1,1,1,1],[1,1,1,1],[1,1,1,1],[1,1,1,1]]) == 7\n    assert candidate([[9,9,9],[9,1,9],[9,9,9]]) == 37\n    assert candidate([[1,2,3],[4,5,6]]) == 12\n    assert candidate([[1]]) == 1\n    assert candidate([[1,1,1],[1,1,1],[1,1,1]]) == 5\n    assert candidate([[1,1],[1,1]]) == 3\n    assert candidate([[1],[2],[3],[4],[5]]) == 15\n    assert candidate([[1,3,1],[1,5,1],[4,2,1]]) == 7\n    assert candidate([[1,2],[3,4]]) == 7\n    assert candidate([[1,2,3,4,5],[6,7,8,9,10]]) == 25\n", "language": "python"}
{"task_id": "revision1a_problem32", "prompt": "def decode_message(encoded: str, key: str) -> str:\n    \"\"\"\n    You've intercepted an encoded message and its corresponding key. The message was encoded\n    using a complex substitution cipher where each letter in the original message was replaced\n    by another letter based on the key.\n\n    The key is a string containing all 26 lowercase letters in a scrambled order. To decode the\n    message, each letter in the encoded message should be replaced by the letter at the same\n    position in the regular alphabet as it appears in the key.\n\n    For example, if the key starts with 'qwertyuiop...', then 'q' in the encoded message should\n    be replaced by 'a', 'w' by 'b', and so on.\n\n    Your task is to decode the message and return the original text. The encoded message may\n    contain uppercase letters, lowercase letters, digits, and other characters. Only replace\n    the letters, and preserve the case of each letter in the output.\n\n    Use dictionary comprehension and string manipulation to efficiently solve this problem.\n\n    Example:\n    Input: encoded = \"Uqx vqfp vq vjg oqqp!\", key = \"qwertyuiopasdfghjklzxcvbnm\"\n    Output: \"The race to the moon!\"\n    Input: encoded = \"Jgnnq, Yqtnf! 123\", key = \"zyxwvutsrqponmlkjihgfedcba\"\n    Output: \"Hello, World! 123\"\n    Input: encoded = \"AbCdEfG\", key = \"qwertyuiopasdfghjklzxcvbnm\"\n    Output: \"QyWtRsT\"\n    \"\"\"\n", "entry_point": "decode_message", "solution": "    alphabet = 'abcdefghijklmnopqrstuvwxyz'\n    \n    # Create a dictionary mapping encoded letters to decoded letters\n    decode_dict = {k: v for k, v in zip(key, alphabet)}\n    \n    # Function to decode a single character\n    def decode_char(char):\n        if char.isalpha():\n            decoded = decode_dict[char.lower()]\n            return decoded.upper() if char.isupper() else decoded\n        return char\n    \n    # Apply the decoding to each character in the encoded message\n    return ''.join(map(decode_char, encoded))\n", "test": "def check(candidate):\n    assert candidate(\"123!@#\", \"qwertyuiopasdfghjklzxcvbnm\") == '123!@#'\n    assert candidate(\"    Spaces    \", \"qwertyuiopasdfghjklzxcvbnm\") == '    Ljkvcl    '\n    assert candidate(\"A1B2C3D4E5F\", \"zyxwvutsrqponmlkjihgfedcba\") == 'Z1Y2X3W4V5U'\n    assert candidate(\"Jgnnq, Yqtnf! 123\", \"zyxwvutsrqponmlkjihgfedcba\") == 'Qtmmj, Bjgmu! 123'\n    assert candidate(\"Uqx vqfp vq vjg oqqp!\", \"qwertyuiopasdfghjklzxcvbnm\") == 'Gau wanj wa wqo iaaj!'\n    assert candidate(\"lower case\", \"mnbvcxzlkjhgfdsapoiuytrewq\") == 'hryxw epox'\n    assert candidate(\"AbCdEfG\", \"qwertyuiopasdfghjklzxcvbnm\") == 'KxVmCnO'\n    assert candidate(\"\", \"abcdefghijklmnopqrstuvwxyz\") == ''\n    assert candidate(\"MiXeD CaSe\", \"qazwsxedcrfvtgbyhnujmikolp\") == 'UvFgH IbEg'\n    assert candidate(\"UPPER CASE\", \"zyxwvutsrqponmlkjihgfedcba\") == 'FKKVI XZHV'\n", "language": "python"}
{"task_id": "revision1a_problem513", "prompt": "from typing import List, Tuple\n\ndef optimize_stock_trading(prices: List[int], k: int) -> int:\n    \"\"\"\n    A stock trader wants to maximize profits by making at most k buy-sell transactions on a stock\n    over n days. The stock prices for each day are provided in the 'prices' list.\n\n    Implement a solution using dynamic programming to find the maximum profit that can be achieved.\n    The time complexity should be O(n*k) and space complexity O(n*k), where n is the number of days.\n\n    A transaction consists of buying on one day and selling on a later day.\n    Multiple transactions cannot overlap (i.e., you must sell before buying again).\n\n    Example:\n    Input:\n    prices = [3, 2, 6, 5, 0, 3, 1, 4]\n    k = 2\n\n    Output: 7\n\n    Explanation: Buy on day 2 (price = 2) and sell on day 3 (price = 6), profit = 6-2 = 4.\n                 Then buy on day 5 (price = 0) and sell on day 8 (price = 4), profit = 4-0 = 4.\n                 Total profit is 4 + 3 = 7.\n    \"\"\"\n", "entry_point": "optimize_stock_trading", "solution": "    n = len(prices)\n    \n    # If there are no prices or no transactions allowed, return 0\n    if n == 0 or k == 0:\n        return 0\n    \n    # If k is larger than n/2, we can make as many transactions as we want\n    if k > n // 2:\n        return sum(max(prices[i+1] - prices[i], 0) for i in range(n-1))\n    \n    # Initialize the dp table\n    dp = [[0] * n for _ in range(k + 1)]\n    \n    # Fill the dp table\n    for i in range(1, k + 1):\n        max_diff = -prices[0]\n        for j in range(1, n):\n            dp[i][j] = max(dp[i][j-1], prices[j] + max_diff)\n            max_diff = max(max_diff, dp[i-1][j] - prices[j])\n    \n    # Return the maximum profit\n    return dp[k][n-1]\n", "test": "def check(candidate):\n    assert candidate([1, 1, 1, 1, 1], 2) == 0\n    assert candidate([10, 9, 8, 7, 6, 5, 4, 3, 2, 1], 4) == 0\n    assert candidate([100, 180, 260, 310, 40, 535, 695], 3) == 865\n    assert candidate([1, 2, 3, 4, 5, 6, 7, 8, 9, 10], 5) == 9\n    assert candidate([1, 2], 1) == 1\n    assert candidate([1], 1) == 0\n    assert candidate([10, 22, 5, 75, 65, 80], 2) == 87\n    assert candidate([3, 2, 6, 5, 0, 3, 1, 4], 2) == 8\n    assert candidate([1, 2, 3, 4, 5], 1) == 4\n    assert candidate([5, 4, 3, 2, 1], 3) == 0\n", "language": "python"}
{"task_id": "revision1a_problem618", "prompt": "import math\nfrom typing import List, Tuple\n\ndef optimize_delivery_route(locations: List[Tuple[float, float]], max_distance: float) -> List[List[Tuple[float, float]]]:\n    \"\"\"\n    A food delivery company wants to optimize their delivery routes. They have a list of customer locations\n    represented as (latitude, longitude) coordinates and a maximum distance a delivery driver can travel.\n    Your task is to group the locations into optimal delivery routes.\n\n    Rules:\n    1. Each route should not exceed the maximum distance.\n    2. The distance between two points should be calculated using the Haversine formula.\n    3. Try to minimize the number of routes while maximizing the number of deliveries per route.\n    4. No location should be left unassigned to a route.\n\n    Take input from the user for the list of locations and the maximum distance.\n    Return a list of routes, where each route is a list of location tuples.\n\n    Example:\n    Input: [(40.7128, -74.0060), (40.7484, -73.9857), (40.7589, -73.9851), (40.7082, -74.0079)], 5.0\n    Output: [[(40.7128, -74.0060), (40.7082, -74.0079)], [(40.7484, -73.9857), (40.7589, -73.9851)]]\n    \n    This example groups nearby locations into two separate routes, each within the 5.0 km max distance.\n    \"\"\"\n", "entry_point": "optimize_delivery_route", "solution": "    def haversine_distance(loc1: Tuple[float, float], loc2: Tuple[float, float]) -> float:\n        lat1, lon1 = math.radians(loc1[0]), math.radians(loc1[1])\n        lat2, lon2 = math.radians(loc2[0]), math.radians(loc2[1])\n        dlat, dlon = lat2 - lat1, lon2 - lon1\n        a = math.sin(dlat/2)**2 + math.cos(lat1) * math.cos(lat2) * math.sin(dlon/2)**2\n        c = 2 * math.asin(math.sqrt(a))\n        return 6371 * c  # Earth's radius in km\n\n    def find_nearest_unvisited(current: Tuple[float, float], unvisited: List[Tuple[float, float]]) -> Tuple[float, float]:\n        return min(unvisited, key=lambda loc: haversine_distance(current, loc))\n\n    routes = []\n    unvisited = locations.copy()\n\n    while unvisited:\n        current_route = [unvisited.pop(0)]\n        current_distance = 0\n\n        while unvisited:\n            nearest = find_nearest_unvisited(current_route[-1], unvisited)\n            distance_to_nearest = haversine_distance(current_route[-1], nearest)\n\n            if current_distance + distance_to_nearest <= max_distance:\n                current_route.append(nearest)\n                unvisited.remove(nearest)\n                current_distance += distance_to_nearest\n            else:\n                break\n\n        routes.append(current_route)\n\n    return routes\n", "test": "def check(candidate):\n    assert candidate([(40.7128, -74.0060)], 10.0) == [[(40.7128, -74.006)]]\n    assert candidate([(51.5074, -0.1278), (48.8566, 2.3522), (41.9028, 12.4964), (52.5200, 13.4050)], 1000.0) == [[(51.5074, -0.1278), (48.8566, 2.3522)], [(41.9028, 12.4964)], [(52.52, 13.405)]]\n    assert candidate([(0, 0), (1, 1), (2, 2), (3, 3), (4, 4)], 200.0) == [[(0, 0), (1, 1)], [(2, 2), (3, 3)], [(4, 4)]]\n    assert candidate([(i, i) for i in range(100)], 50.0) == [[(0, 0)], [(1, 1)], [(2, 2)], [(3, 3)], [(4, 4)], [(5, 5)], [(6, 6)], [(7, 7)], [(8, 8)], [(9, 9)], [(10, 10)], [(11, 11)], [(12, 12)], [(13, 13)], [(14, 14)], [(15, 15)], [(16, 16)], [(17, 17)], [(18, 18)], [(19, 19)], [(20, 20)], [(21, 21)], [(22, 22)], [(23, 23)], [(24, 24)], [(25, 25)], [(26, 26)], [(27, 27)], [(28, 28)], [(29, 29)], [(30, 30)], [(31, 31)], [(32, 32)], [(33, 33)], [(34, 34)], [(35, 35)], [(36, 36)], [(37, 37)], [(38, 38)], [(39, 39)], [(40, 40)], [(41, 41)], [(42, 42)], [(43, 43)], [(44, 44)], [(45, 45)], [(46, 46)], [(47, 47)], [(48, 48)], [(49, 49)], [(50, 50)], [(51, 51)], [(52, 52)], [(53, 53)], [(54, 54)], [(55, 55)], [(56, 56)], [(57, 57)], [(58, 58)], [(59, 59)], [(60, 60)], [(61, 61)], [(62, 62)], [(63, 63)], [(64, 64)], [(65, 65)], [(66, 66)], [(67, 67)], [(68, 68)], [(69, 69)], [(70, 70)], [(71, 71)], [(72, 72)], [(73, 73)], [(74, 74)], [(75, 75)], [(76, 76)], [(77, 77)], [(78, 78)], [(79, 79)], [(80, 80)], [(81, 81)], [(82, 82)], [(83, 83)], [(84, 84)], [(85, 85)], [(86, 86)], [(87, 87)], [(88, 88)], [(89, 89)], [(90, 90)], [(91, 91)], [(92, 92)], [(93, 93)], [(94, 94)], [(95, 95)], [(96, 96)], [(97, 97)], [(98, 98)], [(99, 99)]]\n    assert candidate([(33.7490, -84.3880), (33.7490, -84.3881)], 0.1) == [[(33.749, -84.388), (33.749, -84.3881)]]\n    assert candidate([(0, 0), (0, 1), (1, 0), (1, 1)], 1.0) == [[(0, 0)], [(0, 1)], [(1, 0)], [(1, 1)]]\n    assert candidate([], 100.0) == []\n    assert candidate([(0, 0)] * 1000, 1.0) == [[(0, 0), (0, 0), (0, 0), (0, 0), (0, 0), (0, 0), (0, 0), (0, 0), (0, 0), (0, 0), (0, 0), (0, 0), (0, 0), (0, 0), (0, 0), (0, 0), (0, 0), (0, 0), (0, 0), (0, 0), (0, 0), (0, 0), (0, 0), (0, 0), (0, 0), (0, 0), (0, 0), (0, 0), (0, 0), (0, 0), (0, 0), (0, 0), (0, 0), (0, 0), (0, 0), (0, 0), (0, 0), (0, 0), (0, 0), (0, 0), (0, 0), (0, 0), (0, 0), (0, 0), (0, 0), (0, 0), (0, 0), (0, 0), (0, 0), (0, 0), (0, 0), (0, 0), (0, 0), (0, 0), (0, 0), (0, 0), (0, 0), (0, 0), (0, 0), (0, 0), (0, 0), (0, 0), (0, 0), (0, 0), (0, 0), (0, 0), (0, 0), (0, 0), (0, 0), (0, 0), (0, 0), (0, 0), (0, 0), (0, 0), (0, 0), (0, 0), (0, 0), (0, 0), (0, 0), (0, 0), (0, 0), (0, 0), (0, 0), (0, 0), (0, 0), (0, 0), (0, 0), (0, 0), (0, 0), (0, 0), (0, 0), (0, 0), (0, 0), (0, 0), (0, 0), (0, 0), (0, 0), (0, 0), (0, 0), (0, 0), (0, 0), (0, 0), (0, 0), (0, 0), (0, 0), (0, 0), (0, 0), (0, 0), (0, 0), (0, 0), (0, 0), (0, 0), (0, 0), (0, 0), (0, 0), (0, 0), (0, 0), (0, 0), (0, 0), (0, 0), (0, 0), (0, 0), (0, 0), (0, 0), (0, 0), (0, 0), (0, 0), (0, 0), (0, 0), (0, 0), (0, 0), (0, 0), (0, 0), (0, 0), (0, 0), (0, 0), (0, 0), (0, 0), (0, 0), (0, 0), (0, 0), (0, 0), (0, 0), (0, 0), (0, 0), (0, 0), (0, 0), (0, 0), (0, 0), (0, 0), (0, 0), (0, 0), (0, 0), (0, 0), (0, 0), (0, 0), (0, 0), (0, 0), (0, 0), (0, 0), (0, 0), (0, 0), (0, 0), (0, 0), (0, 0), (0, 0), (0, 0), (0, 0), (0, 0), (0, 0), (0, 0), (0, 0), (0, 0), (0, 0), (0, 0), (0, 0), (0, 0), (0, 0), (0, 0), (0, 0), (0, 0), (0, 0), (0, 0), (0, 0), (0, 0), (0, 0), (0, 0), (0, 0), (0, 0), (0, 0), (0, 0), (0, 0), (0, 0), (0, 0), (0, 0), (0, 0), (0, 0), (0, 0), (0, 0), (0, 0), (0, 0), (0, 0), (0, 0), (0, 0), (0, 0), (0, 0), (0, 0), (0, 0), (0, 0), (0, 0), (0, 0), (0, 0), (0, 0), (0, 0), (0, 0), (0, 0), (0, 0), (0, 0), (0, 0), (0, 0), (0, 0), (0, 0), (0, 0), (0, 0), (0, 0), (0, 0), (0, 0), (0, 0), (0, 0), (0, 0), (0, 0), (0, 0), (0, 0), (0, 0), (0, 0), (0, 0), (0, 0), (0, 0), (0, 0), (0, 0), (0, 0), (0, 0), (0, 0), (0, 0), (0, 0), (0, 0), (0, 0), (0, 0), (0, 0), (0, 0), (0, 0), (0, 0), (0, 0), (0, 0), (0, 0), (0, 0), (0, 0), (0, 0), (0, 0), (0, 0), (0, 0), (0, 0), (0, 0), (0, 0), (0, 0), (0, 0), (0, 0), (0, 0), (0, 0), (0, 0), (0, 0), (0, 0), (0, 0), (0, 0), (0, 0), (0, 0), (0, 0), (0, 0), (0, 0), (0, 0), (0, 0), (0, 0), (0, 0), (0, 0), (0, 0), (0, 0), (0, 0), (0, 0), (0, 0), (0, 0), (0, 0), (0, 0), (0, 0), (0, 0), (0, 0), (0, 0), (0, 0), (0, 0), (0, 0), (0, 0), (0, 0), (0, 0), (0, 0), (0, 0), (0, 0), (0, 0), (0, 0), (0, 0), (0, 0), (0, 0), (0, 0), (0, 0), (0, 0), (0, 0), (0, 0), (0, 0), (0, 0), (0, 0), (0, 0), (0, 0), (0, 0), (0, 0), (0, 0), (0, 0), (0, 0), (0, 0), (0, 0), (0, 0), (0, 0), (0, 0), (0, 0), (0, 0), (0, 0), (0, 0), (0, 0), (0, 0), (0, 0), (0, 0), (0, 0), (0, 0), (0, 0), (0, 0), (0, 0), (0, 0), (0, 0), (0, 0), (0, 0), (0, 0), (0, 0), (0, 0), (0, 0), (0, 0), (0, 0), (0, 0), (0, 0), (0, 0), (0, 0), (0, 0), (0, 0), (0, 0), (0, 0), (0, 0), (0, 0), (0, 0), (0, 0), (0, 0), (0, 0), (0, 0), (0, 0), (0, 0), (0, 0), (0, 0), (0, 0), (0, 0), (0, 0), (0, 0), (0, 0), (0, 0), (0, 0), (0, 0), (0, 0), (0, 0), (0, 0), (0, 0), (0, 0), (0, 0), (0, 0), (0, 0), (0, 0), (0, 0), (0, 0), (0, 0), (0, 0), (0, 0), (0, 0), (0, 0), (0, 0), (0, 0), (0, 0), (0, 0), (0, 0), (0, 0), (0, 0), (0, 0), (0, 0), (0, 0), (0, 0), (0, 0), (0, 0), (0, 0), (0, 0), (0, 0), (0, 0), (0, 0), (0, 0), (0, 0), (0, 0), (0, 0), (0, 0), (0, 0), (0, 0), (0, 0), (0, 0), (0, 0), (0, 0), (0, 0), (0, 0), (0, 0), (0, 0), (0, 0), (0, 0), (0, 0), (0, 0), (0, 0), (0, 0), (0, 0), (0, 0), (0, 0), (0, 0), (0, 0), (0, 0), (0, 0), (0, 0), (0, 0), (0, 0), (0, 0), (0, 0), (0, 0), (0, 0), (0, 0), (0, 0), (0, 0), (0, 0), (0, 0), (0, 0), (0, 0), (0, 0), (0, 0), (0, 0), (0, 0), (0, 0), (0, 0), (0, 0), (0, 0), (0, 0), (0, 0), (0, 0), (0, 0), (0, 0), (0, 0), (0, 0), (0, 0), (0, 0), (0, 0), (0, 0), (0, 0), (0, 0), (0, 0), (0, 0), (0, 0), (0, 0), (0, 0), (0, 0), (0, 0), (0, 0), (0, 0), (0, 0), (0, 0), (0, 0), (0, 0), (0, 0), (0, 0), (0, 0), (0, 0), (0, 0), (0, 0), (0, 0), (0, 0), (0, 0), (0, 0), (0, 0), (0, 0), (0, 0), (0, 0), (0, 0), (0, 0), (0, 0), (0, 0), (0, 0), (0, 0), (0, 0), (0, 0), (0, 0), (0, 0), (0, 0), (0, 0), (0, 0), (0, 0), (0, 0), (0, 0), (0, 0), (0, 0), (0, 0), (0, 0), (0, 0), (0, 0), (0, 0), (0, 0), (0, 0), (0, 0), (0, 0), (0, 0), (0, 0), (0, 0), (0, 0), (0, 0), (0, 0), (0, 0), (0, 0), (0, 0), (0, 0), (0, 0), (0, 0), (0, 0), (0, 0), (0, 0), (0, 0), (0, 0), (0, 0), (0, 0), (0, 0), (0, 0), (0, 0), (0, 0), (0, 0), (0, 0), (0, 0), (0, 0), (0, 0), (0, 0), (0, 0), (0, 0), (0, 0), (0, 0), (0, 0), (0, 0), (0, 0), (0, 0), (0, 0), (0, 0), (0, 0), (0, 0), (0, 0), (0, 0), (0, 0), (0, 0), (0, 0), (0, 0), (0, 0), (0, 0), (0, 0), (0, 0), (0, 0), (0, 0), (0, 0), (0, 0), (0, 0), (0, 0), (0, 0), (0, 0), (0, 0), (0, 0), (0, 0), (0, 0), (0, 0), (0, 0), (0, 0), (0, 0), (0, 0), (0, 0), (0, 0), (0, 0), (0, 0), (0, 0), (0, 0), (0, 0), (0, 0), (0, 0), (0, 0), (0, 0), (0, 0), (0, 0), (0, 0), (0, 0), (0, 0), (0, 0), (0, 0), (0, 0), (0, 0), (0, 0), (0, 0), (0, 0), (0, 0), (0, 0), (0, 0), (0, 0), (0, 0), (0, 0), (0, 0), (0, 0), (0, 0), (0, 0), (0, 0), (0, 0), (0, 0), (0, 0), (0, 0), (0, 0), (0, 0), (0, 0), (0, 0), (0, 0), (0, 0), (0, 0), (0, 0), (0, 0), (0, 0), (0, 0), (0, 0), (0, 0), (0, 0), (0, 0), (0, 0), (0, 0), (0, 0), (0, 0), (0, 0), (0, 0), (0, 0), (0, 0), (0, 0), (0, 0), (0, 0), (0, 0), (0, 0), (0, 0), (0, 0), (0, 0), (0, 0), (0, 0), (0, 0), (0, 0), (0, 0), (0, 0), (0, 0), (0, 0), (0, 0), (0, 0), (0, 0), (0, 0), (0, 0), (0, 0), (0, 0), (0, 0), (0, 0), (0, 0), (0, 0), (0, 0), (0, 0), (0, 0), (0, 0), (0, 0), (0, 0), (0, 0), (0, 0), (0, 0), (0, 0), (0, 0), (0, 0), (0, 0), (0, 0), (0, 0), (0, 0), (0, 0), (0, 0), (0, 0), (0, 0), (0, 0), (0, 0), (0, 0), (0, 0), (0, 0), (0, 0), (0, 0), (0, 0), (0, 0), (0, 0), (0, 0), (0, 0), (0, 0), (0, 0), (0, 0), (0, 0), (0, 0), (0, 0), (0, 0), (0, 0), (0, 0), (0, 0), (0, 0), (0, 0), (0, 0), (0, 0), (0, 0), (0, 0), (0, 0), (0, 0), (0, 0), (0, 0), (0, 0), (0, 0), (0, 0), (0, 0), (0, 0), (0, 0), (0, 0), (0, 0), (0, 0), (0, 0), (0, 0), (0, 0), (0, 0), (0, 0), (0, 0), (0, 0), (0, 0), (0, 0), (0, 0), (0, 0), (0, 0), (0, 0), (0, 0), (0, 0), (0, 0), (0, 0), (0, 0), (0, 0), (0, 0), (0, 0), (0, 0), (0, 0), (0, 0), (0, 0), (0, 0), (0, 0), (0, 0), (0, 0), (0, 0), (0, 0), (0, 0), (0, 0), (0, 0), (0, 0), (0, 0), (0, 0), (0, 0), (0, 0), (0, 0), (0, 0), (0, 0), (0, 0), (0, 0), (0, 0), (0, 0), (0, 0), (0, 0), (0, 0), (0, 0), (0, 0), (0, 0), (0, 0), (0, 0), (0, 0), (0, 0), (0, 0), (0, 0), (0, 0), (0, 0), (0, 0), (0, 0), (0, 0), (0, 0), (0, 0), (0, 0), (0, 0), (0, 0), (0, 0), (0, 0), (0, 0), (0, 0), (0, 0), (0, 0), (0, 0), (0, 0), (0, 0), (0, 0), (0, 0), (0, 0), (0, 0), (0, 0), (0, 0), (0, 0), (0, 0), (0, 0), (0, 0), (0, 0), (0, 0), (0, 0), (0, 0), (0, 0), (0, 0), (0, 0), (0, 0), (0, 0), (0, 0), (0, 0), (0, 0), (0, 0), (0, 0), (0, 0), (0, 0), (0, 0), (0, 0), (0, 0), (0, 0), (0, 0), (0, 0), (0, 0), (0, 0), (0, 0), (0, 0), (0, 0), (0, 0), (0, 0), (0, 0), (0, 0), (0, 0), (0, 0), (0, 0), (0, 0), (0, 0), (0, 0), (0, 0), (0, 0), (0, 0), (0, 0), (0, 0), (0, 0), (0, 0), (0, 0), (0, 0), (0, 0), (0, 0), (0, 0), (0, 0), (0, 0), (0, 0), (0, 0), (0, 0), (0, 0), (0, 0), (0, 0), (0, 0), (0, 0), (0, 0), (0, 0), (0, 0), (0, 0), (0, 0), (0, 0), (0, 0), (0, 0), (0, 0), (0, 0), (0, 0), (0, 0), (0, 0), (0, 0), (0, 0), (0, 0), (0, 0), (0, 0), (0, 0), (0, 0), (0, 0), (0, 0), (0, 0), (0, 0), (0, 0), (0, 0), (0, 0), (0, 0), (0, 0), (0, 0), (0, 0), (0, 0), (0, 0), (0, 0), (0, 0), (0, 0), (0, 0), (0, 0), (0, 0), (0, 0), (0, 0), (0, 0), (0, 0), (0, 0), (0, 0), (0, 0), (0, 0), (0, 0), (0, 0), (0, 0), (0, 0), (0, 0), (0, 0), (0, 0), (0, 0), (0, 0), (0, 0), (0, 0), (0, 0), (0, 0), (0, 0), (0, 0), (0, 0), (0, 0), (0, 0), (0, 0), (0, 0), (0, 0), (0, 0), (0, 0), (0, 0), (0, 0), (0, 0), (0, 0), (0, 0), (0, 0), (0, 0), (0, 0), (0, 0), (0, 0), (0, 0), (0, 0), (0, 0), (0, 0), (0, 0), (0, 0), (0, 0), (0, 0), (0, 0), (0, 0), (0, 0), (0, 0), (0, 0), (0, 0), (0, 0), (0, 0), (0, 0), (0, 0), (0, 0), (0, 0), (0, 0), (0, 0), (0, 0), (0, 0), (0, 0), (0, 0)]]\n    assert candidate([(90, 0), (-90, 0), (0, 180), (0, -180)], 20000.0) == [[(90, 0), (0, 180), (0, -180)], [(-90, 0)]]\n    assert candidate([(40.7128, -74.0060), (40.7484, -73.9857), (40.7589, -73.9851), (40.7082, -74.0079)], 5.0) == [[(40.7128, -74.006), (40.7082, -74.0079)], [(40.7484, -73.9857), (40.7589, -73.9851)]]\n", "language": "python"}
{"task_id": "revision1a_problem480", "prompt": "import itertools\nimport math\nfrom typing import List, Tuple\n\ndef optimize_delivery_route(addresses: List[Tuple[float, float]]) -> List[int]:\n    \"\"\"\n    Implement a function to optimize a delivery route for a courier service.\n\n    The function should take a list of tuples representing (latitude, longitude) coordinates of delivery addresses.\n    Use the traveling salesman problem (TSP) algorithm to find the shortest possible route that visits each address exactly once and returns to the starting point.\n    \n    The function should return a list of integers representing the optimal order of visits.\n\n    Use dynamic programming to implement the TSP algorithm for improved efficiency.\n\n    Example:\n    Input: [(40.7128, -74.0060), (34.0522, -118.2437), (41.8781, -87.6298), (29.7604, -95.3698)]\n    Output: [0, 2, 1, 3, 0]\n\n    This output means the optimal route is:\n    Start at index 0 (New York) -> Visit index 2 (Chicago) -> Visit index 1 (Los Angeles) -> \n    Visit index 3 (Houston) -> Return to index 0 (New York)\n\n    Implement error handling for invalid inputs (e.g., less than 2 addresses).\n    \"\"\"\n", "entry_point": "optimize_delivery_route", "solution": "    def calculate_distance(coord1: Tuple[float, float], coord2: Tuple[float, float]) -> float:\n        lat1, lon1 = coord1\n        lat2, lon2 = coord2\n        return math.sqrt((lat2 - lat1)**2 + (lon2 - lon1)**2)\n\n    def tsp_dp(mask: int, pos: int) -> Tuple[float, List[int]]:\n        if mask == (1 << n) - 1:\n            return calculate_distance(addresses[pos], addresses[0]), [pos, 0]\n        \n        if dp[mask][pos] is not None:\n            return dp[mask][pos]\n        \n        min_cost = float('inf')\n        min_path = []\n        \n        for next_pos in range(n):\n            if next_pos != pos and not (mask & (1 << next_pos)):\n                new_mask = mask | (1 << next_pos)\n                cost, path = tsp_dp(new_mask, next_pos)\n                cost += calculate_distance(addresses[pos], addresses[next_pos])\n                \n                if cost < min_cost:\n                    min_cost = cost\n                    min_path = [pos] + path\n        \n        dp[mask][pos] = (min_cost, min_path)\n        return min_cost, min_path\n\n    # Error handling for invalid inputs\n    if len(addresses) < 2:\n        raise ValueError(\"At least 2 addresses are required for route optimization.\")\n\n    n = len(addresses)\n    dp = [[None for _ in range(n)] for _ in range(1 << n)]\n    \n    _, optimal_path = tsp_dp(1, 0)\n    return [0] + optimal_path\n\n", "test": "def check(candidate):\n    assert candidate([(40.7128, -74.0060), (34.0522, -118.2437), (41.8781, -87.6298), (29.7604, -95.3698)]) == [0, 0, 2, 1, 3, 0]\n    assert candidate([(0, 0), (0.0001, 0.0001), (0.0002, 0.0002), (0.0003, 0.0003)]) == [0, 0, 1, 2, 3, 0]\n    assert candidate([(0, 0), (0, 1), (1, 0), (1, 1)]) == [0, 0, 1, 3, 2, 0]\n    assert candidate([(51.5074, -0.1278), (48.8566, 2.3522), (52.5200, 13.4050), (41.9028, 12.4964), (40.4168, -3.7038)]) == [0, 0, 1, 2, 3, 4, 0]\n    assert candidate([(35.6762, 139.6503), (22.3193, 114.1694), (1.3521, 103.8198), (13.7563, 100.5018)]) == [0, 0, 1, 3, 2, 0]\n    assert candidate([(0, 0), (1, 1), (2, 2), (3, 3), (4, 4)]) == [0, 0, 2, 3, 4, 1, 0]\n    assert candidate([(0, 0), (10, 0), (0, 10), (10, 10), (5, 5)]) == [0, 0, 1, 3, 2, 4, 0]\n    assert candidate([(40.7128, -74.0060), (40.7128, -74.0060), (40.7128, -74.0060), (41.8781, -87.6298)]) == [0, 0, 1, 2, 3, 0]\n    assert candidate([(37.7749, -122.4194), (37.3382, -121.8863), (37.8044, -122.2712), (37.4443, -122.1650)]) == [0, 0, 2, 1, 3, 0]\n    assert candidate([(90, 0), (-90, 0), (0, 180), (0, -180)]) == [0, 0, 2, 1, 3, 0]\n", "language": "python"}
{"task_id": "revision1a_problem223", "prompt": "from typing import List, Dict, Union\n\ndef analyze_sales(sales_data: List[Dict[str, Union[str, float]]]) -> Dict[str, Union[float, str]]:\n    \"\"\"\n    As a data analyst for a retail company, you need to process daily sales data\n    and generate a summary report. Each day's data is represented as a dictionary\n    containing the date, total sales, and number of transactions.\n    \n    Write a function that takes a list of these daily data dictionaries and returns\n    a summary dictionary with the following information:\n    - Average daily sales\n    - Total number of transactions\n    - Date with highest sales\n    - Date with lowest sales\n    \n    Use dictionary comprehension and the max() and min() functions with key parameter.\n    Handle potential errors like empty input list or invalid data format.\n    \n    Example:\n    Input: [\n        {\"date\": \"2023-05-01\", \"sales\": 1000.50, \"transactions\": 50},\n        {\"date\": \"2023-05-02\", \"sales\": 1500.75, \"transactions\": 75},\n        {\"date\": \"2023-05-03\", \"sales\": 800.25, \"transactions\": 40}\n    ]\n    Output: {\n        \"avg_daily_sales\": 1100.50,\n        \"total_transactions\": 165,\n        \"highest_sales_date\": \"2023-05-02\",\n        \"lowest_sales_date\": \"2023-05-03\"\n    }\n    \"\"\"\n", "entry_point": "analyze_sales", "solution": "    # Handle empty input list\n    if not sales_data:\n        return {\n            \"avg_daily_sales\": 0,\n            \"total_transactions\": 0,\n            \"highest_sales_date\": \"N/A\",\n            \"lowest_sales_date\": \"N/A\"\n        }\n\n    try:\n        # Calculate average daily sales\n        total_sales = sum(day[\"sales\"] for day in sales_data)\n        avg_daily_sales = total_sales / len(sales_data)\n\n        # Calculate total number of transactions\n        total_transactions = sum(day[\"transactions\"] for day in sales_data)\n\n        # Find date with highest sales\n        highest_sales_date = max(sales_data, key=lambda x: x[\"sales\"])[\"date\"]\n\n        # Find date with lowest sales\n        lowest_sales_date = min(sales_data, key=lambda x: x[\"sales\"])[\"date\"]\n\n        # Create and return the summary dictionary\n        return {\n            \"avg_daily_sales\": round(avg_daily_sales, 2),\n            \"total_transactions\": total_transactions,\n            \"highest_sales_date\": highest_sales_date,\n            \"lowest_sales_date\": lowest_sales_date\n        }\n    except (KeyError, TypeError, ValueError) as e:\n        # Handle invalid data format\n        return {\n            \"error\": f\"Invalid data format: {str(e)}\",\n            \"avg_daily_sales\": 0,\n            \"total_transactions\": 0,\n            \"highest_sales_date\": \"N/A\",\n            \"lowest_sales_date\": \"N/A\"\n        }\n", "test": "def check(candidate):\n    assert candidate([{\"date\": \"2023-05-01\", \"sales\": 999999.99, \"transactions\": 1}, {\"date\": \"2023-05-02\", \"sales\": 999999.99, \"transactions\": 1}]) == {'avg_daily_sales': 999999.99, 'total_transactions': 2, 'highest_sales_date': '2023-05-01', 'lowest_sales_date': '2023-05-01'}\n    assert candidate([{\"date\": \"2023-05-01\", \"sales\": 0.01, \"transactions\": 1}, {\"date\": \"2023-05-02\", \"sales\": 0.02, \"transactions\": 2}]) == {'avg_daily_sales': 0.01, 'total_transactions': 3, 'highest_sales_date': '2023-05-02', 'lowest_sales_date': '2023-05-01'}\n    assert candidate([{\"date\": \"2023-05-01\", \"sales\": 1000.50, \"transactions\": 50}, {\"date\": \"2023-05-02\", \"sales\": 1500.75, \"transactions\": 75}, {\"date\": \"2023-05-03\", \"sales\": 800.25, \"transactions\": 40}]) == {'avg_daily_sales': 1100.5, 'total_transactions': 165, 'highest_sales_date': '2023-05-02', 'lowest_sales_date': '2023-05-03'}\n    assert candidate([{\"date\": \"2023-05-01\", \"sales\": 1000.50, \"transactions\": 50}, {\"date\": \"2023-05-02\", \"sales\": 1500.75, \"transactions\": 75}, {\"date\": \"2023-05-03\", \"sales\": 800.25, \"transactions\": 40}, {\"date\": \"2023-05-04\", \"sales\": 2000.00, \"transactions\": 100}, {\"date\": \"2023-05-05\", \"sales\": 1200.00, \"transactions\": 60}]) == {'avg_daily_sales': 1300.3, 'total_transactions': 325, 'highest_sales_date': '2023-05-04', 'lowest_sales_date': '2023-05-03'}\n    assert candidate([{\"date\": \"2023-05-01\", \"sales\": 1000.00, \"transactions\": 100}]) == {'avg_daily_sales': 1000.0, 'total_transactions': 100, 'highest_sales_date': '2023-05-01', 'lowest_sales_date': '2023-05-01'}\n    assert candidate([{\"date\": \"2023-05-01\", \"sales\": 0, \"transactions\": 0}, {\"date\": \"2023-05-02\", \"sales\": 0, \"transactions\": 0}]) == {'avg_daily_sales': 0.0, 'total_transactions': 0, 'highest_sales_date': '2023-05-01', 'lowest_sales_date': '2023-05-01'}\n    assert candidate([]) == {'avg_daily_sales': 0, 'total_transactions': 0, 'highest_sales_date': 'N/A', 'lowest_sales_date': 'N/A'}\n    assert candidate([{\"date\": \"2023-05-01\", \"sales\": 1000.50, \"transactions\": 50}, {\"date\": \"2023-05-02\", \"sales\": 1000.50, \"transactions\": 50}]) == {'avg_daily_sales': 1000.5, 'total_transactions': 100, 'highest_sales_date': '2023-05-01', 'lowest_sales_date': '2023-05-01'}\n    assert candidate([{\"date\": \"2023-05-01\", \"sales\": 1000.50, \"transactions\": 50}, {\"date\": \"2023-05-01\", \"sales\": 1500.75, \"transactions\": 75}]) == {'avg_daily_sales': 1250.62, 'total_transactions': 125, 'highest_sales_date': '2023-05-01', 'lowest_sales_date': '2023-05-01'}\n    assert candidate([{\"date\": \"2023-05-01\", \"sales\": 1000.50, \"transactions\": 50}, {\"date\": \"2023-05-02\", \"sales\": 1500.75, \"transactions\": 75}, {\"date\": \"2023-05-03\", \"sales\": 800.25, \"transactions\": 40}, {\"date\": \"2023-05-04\", \"sales\": 1200.00, \"transactions\": 60}, {\"date\": \"2023-05-05\", \"sales\": 900.00, \"transactions\": 45}, {\"date\": \"2023-05-06\", \"sales\": 1800.00, \"transactions\": 90}, {\"date\": \"2023-05-07\", \"sales\": 1100.00, \"transactions\": 55}]) == {'avg_daily_sales': 1185.93, 'total_transactions': 415, 'highest_sales_date': '2023-05-06', 'lowest_sales_date': '2023-05-03'}\n", "language": "python"}
{"task_id": "revision1a_problem445", "prompt": "from typing import List, Dict\n\ndef decode_alien_message(message: str, codebook: Dict[str, str]) -> str:\n    \"\"\"\n    You are a cryptographer working for a secret government agency. \n    You've intercepted an alien message that needs to be decoded urgently.\n    The message is encoded using a substitution cipher, where each alien symbol is replaced by an Earth symbol.\n\n    You have been provided with a codebook that maps some (but not all) alien symbols to their Earth counterparts.\n    Your task is to decode as much of the message as possible, replacing unknown symbols with '?'.\n\n    Write a function that takes the encoded message and the codebook as input, and returns the partially decoded message.\n\n    Take input from the user for the encoded message and the codebook, and return the decoded message.\n\n    Example:\n    Input: \"XYZABCDEFG\", {\"X\": \"H\", \"Y\": \"E\", \"Z\": \"L\", \"A\": \"L\", \"C\": \"O\"}\n    Output: \"HELLO???FG\"\n    Input: \"ABCDEFGHIJKLMNOP\", {\"A\": \"T\", \"C\": \"H\", \"E\": \"I\", \"G\": \"S\", \"K\": \"M\", \"N\": \"G\"}\n    Output: \"T?HI?S?IS?M?G???\"\n    \"\"\"\n", "entry_point": "decode_alien_message", "solution": "    decoded_message = \"\"\n    \n    for char in message:\n        if char in codebook:\n            decoded_message += codebook[char]\n        else:\n            decoded_message += \"?\"\n    \n    return decoded_message\n", "test": "def check(candidate):\n    assert candidate(\"ABC\", {\"A\": \"X\", \"B\": \"Y\", \"C\": \"Z\"}) == 'XYZ'\n    assert candidate(\"HELLO\", {\"H\": \"G\", \"E\": \"O\", \"L\": \"A\", \"O\": \"D\"}) == 'GOAAD'\n    assert candidate(\"12345\", {\"1\": \"A\", \"2\": \"B\", \"3\": \"C\", \"4\": \"D\", \"5\": \"E\"}) == 'ABCDE'\n    assert candidate(\"QWERTYUIOP\", {\"Q\": \"A\", \"W\": \"S\", \"E\": \"D\", \"R\": \"F\", \"T\": \"G\"}) == 'ASDFG?????'\n    assert candidate(\"ASDFGHJKL\", {}) == '?????????'\n    assert candidate(\"\", {\"A\": \"B\"}) == ''\n    assert candidate(\"ABCDEFGHIJKLMNOP\", {\"A\": \"T\", \"C\": \"H\", \"E\": \"I\", \"G\": \"S\", \"K\": \"M\", \"N\": \"G\"}) == 'T?H?I?S???M??G??'\n    assert candidate(\"ZXCVBNM\", {\"Z\": \"M\", \"X\": \"N\", \"C\": \"B\", \"V\": \"V\", \"B\": \"C\", \"N\": \"X\", \"M\": \"Z\"}) == 'MNBVCXZ'\n    assert candidate(\"XYZABCDEFG\", {\"X\": \"H\", \"Y\": \"E\", \"Z\": \"L\", \"A\": \"L\", \"C\": \"O\"}) == 'HELL?O????'\n    assert candidate(\"AABBCCDDEE\", {\"A\": \"1\", \"B\": \"2\", \"C\": \"3\", \"D\": \"4\", \"E\": \"5\"}) == '1122334455'\n", "language": "python"}
{"task_id": "revision1a_problem585", "prompt": "import re\nfrom typing import List, Dict\n\ndef analyze_email_domains(email_list: List[str]) -> Dict[str, int]:\n    \"\"\"\n    Develop a program that analyzes a list of email addresses to identify the most common email domains.\n    The function should take a list of email addresses as input and return a dictionary with domain names as keys\n    and their frequency as values, sorted in descending order of frequency.\n    \n    Use regular expressions to extract domain names from email addresses.\n    Ignore any invalid email formats in the input list.\n    \n    Example:\n    Input: ['user1@gmail.com', 'user2@yahoo.com', 'user3@gmail.com', 'user4@outlook.com', 'invalid_email', 'user5@gmail.com']\n    Output: {'gmail.com': 3, 'yahoo.com': 1, 'outlook.com': 1}\n    \n    This function can be useful for marketing teams to understand the distribution of email providers among their customers.\n    \"\"\"\n", "entry_point": "analyze_email_domains", "solution": "    # Regular expression pattern to match valid email addresses and extract domains\n    email_pattern = r'^[\\w\\.-]+@([\\w\\.-]+\\.\\w+)$'\n    \n    # Dictionary to store domain frequencies\n    domain_freq = {}\n    \n    # Iterate through the email list\n    for email in email_list:\n        # Try to match the email pattern\n        match = re.match(email_pattern, email)\n        if match:\n            # Extract the domain from the matched group\n            domain = match.group(1)\n            # Increment the domain frequency in the dictionary\n            domain_freq[domain] = domain_freq.get(domain, 0) + 1\n    \n    # Sort the dictionary by frequency in descending order\n    sorted_domains = sorted(domain_freq.items(), key=lambda x: x[1], reverse=True)\n    \n    # Create a new dictionary with sorted domains\n    result = dict(sorted_domains)\n    \n    return result\n", "test": "def check(candidate):\n    assert candidate(['user@example.com']) == {'example.com': 1}\n    assert candidate(['user1@gmail.com', 'user2@yahoo.com', 'user3@gmail.com', 'user4@outlook.com', 'invalid_email', 'user5@gmail.com']) == {'gmail.com': 3, 'yahoo.com': 1, 'outlook.com': 1}\n    assert candidate(['user1@gmail.com', 'user2@gmail.com', 'user3@gmail.com']) == {'gmail.com': 3}\n    assert candidate(['user@subdomain.example.com', 'user@example.co.uk']) == {'subdomain.example.com': 1, 'example.co.uk': 1}\n    assert candidate(['USER@GMAIL.COM', 'user@gmail.com']) == {'GMAIL.COM': 1, 'gmail.com': 1}\n    assert candidate([]) == {}\n    assert candidate(['user1@hotmail.com', 'user2@yahoo.com', 'user3@gmail.com', 'user4@outlook.com']) == {'hotmail.com': 1, 'yahoo.com': 1, 'gmail.com': 1, 'outlook.com': 1}\n    assert candidate(['user@.com', '@domain.com', 'user@domain.', 'user@domain']) == {}\n    assert candidate(['user1@gmail.com', 'user2@Gmail.com', 'user3@GMAIL.COM']) == {'gmail.com': 1, 'Gmail.com': 1, 'GMAIL.COM': 1}\n", "language": "python"}
{"task_id": "revision1a_problem278", "prompt": "from typing import List, Dict\nimport heapq\n\ndef schedule_tasks(tasks: List[Dict[str, int]], processors: int) -> int:\n    \"\"\"\n    Schedule tasks on multiple processors to minimize completion time.\n\n    You are given a list of tasks, where each task is represented by a dictionary containing\n    'id' (task identifier), 'duration' (time to complete the task), and 'dependencies' (list of task IDs\n    that must be completed before this task can start). You have a fixed number of processors available.\n\n    Your goal is to schedule these tasks on the available processors to minimize the total completion time.\n    Tasks can be executed in parallel on different processors, but a task cannot start until all its\n    dependencies have been completed.\n\n    Take input from the user for the list of tasks and the number of available processors.\n    Return the minimum time required to complete all tasks.\n\n    Example:\n    Input: \n    [\n        {'id': 1, 'duration': 3, 'dependencies': []},\n        {'id': 2, 'duration': 2, 'dependencies': [1]},\n        {'id': 3, 'duration': 1, 'dependencies': [1]},\n        {'id': 4, 'duration': 4, 'dependencies': [2, 3]}\n    ], 2\n    Output: 7\n\n    Input:\n    [\n        {'id': 1, 'duration': 2, 'dependencies': []},\n        {'id': 2, 'duration': 3, 'dependencies': []},\n        {'id': 3, 'duration': 4, 'dependencies': [1, 2]},\n        {'id': 4, 'duration': 1, 'dependencies': [3]},\n        {'id': 5, 'duration': 2, 'dependencies': [3]}\n    ], 3\n    Output: 7\n    \"\"\"\n", "entry_point": "schedule_tasks", "solution": "    # Create a graph representation of tasks and their dependencies\n    graph = {task['id']: set(task['dependencies']) for task in tasks}\n    in_degree = {task['id']: len(task['dependencies']) for task in tasks}\n    duration = {task['id']: task['duration'] for task in tasks}\n\n    # Initialize the ready queue with tasks that have no dependencies\n    ready_queue = [(0, task['id']) for task in tasks if not task['dependencies']]\n    heapq.heapify(ready_queue)\n\n    # Initialize processor end times\n    processor_end_times = [0] * processors\n\n    # Process tasks\n    completion_time = 0\n    while ready_queue:\n        start_time, task_id = heapq.heappop(ready_queue)\n        # Find the earliest available processor\n        processor = min(range(processors), key=lambda i: processor_end_times[i])\n        # Update the processor end time and overall completion time\n        processor_end_times[processor] = max(processor_end_times[processor], start_time) + duration[task_id]\n        completion_time = max(completion_time, processor_end_times[processor])\n\n        # Update dependencies and add newly available tasks to the ready queue\n        for dependent in [t for t in graph if task_id in graph[t]]:\n            in_degree[dependent] -= 1\n            if in_degree[dependent] == 0:\n                heapq.heappush(ready_queue, (processor_end_times[processor], dependent))\n\n    return completion_time\n", "test": "def check(candidate):\n    assert candidate([{'id': 1, 'duration': 5, 'dependencies': []}, {'id': 2, 'duration': 5, 'dependencies': []}], 2) == 5\n    assert candidate([{'id': 1, 'duration': 3, 'dependencies': []}, {'id': 2, 'duration': 3, 'dependencies': []}, {'id': 3, 'duration': 3, 'dependencies': []}, {'id': 4, 'duration': 3, 'dependencies': [1, 2, 3]}], 3) == 6\n    assert candidate([{'id': 1, 'duration': 1, 'dependencies': []}], 1) == 1\n    assert candidate([{'id': 1, 'duration': 2, 'dependencies': []}, {'id': 2, 'duration': 3, 'dependencies': []}, {'id': 3, 'duration': 4, 'dependencies': [1, 2]}, {'id': 4, 'duration': 1, 'dependencies': [3]}, {'id': 5, 'duration': 2, 'dependencies': [3]}], 3) == 9\n    assert candidate([{'id': 1, 'duration': 3, 'dependencies': []}, {'id': 2, 'duration': 2, 'dependencies': [1]}, {'id': 3, 'duration': 1, 'dependencies': [1]}, {'id': 4, 'duration': 4, 'dependencies': [2, 3]}], 2) == 8\n    assert candidate([{'id': 1, 'duration': 1, 'dependencies': []}, {'id': 2, 'duration': 1, 'dependencies': [1]}, {'id': 3, 'duration': 1, 'dependencies': [2]}, {'id': 4, 'duration': 1, 'dependencies': [3]}, {'id': 5, 'duration': 1, 'dependencies': [4]}], 5) == 5\n    assert candidate([{'id': 1, 'duration': 5, 'dependencies': []}, {'id': 2, 'duration': 3, 'dependencies': [1]}, {'id': 3, 'duration': 4, 'dependencies': [1]}, {'id': 4, 'duration': 2, 'dependencies': [2, 3]}], 1) == 14\n    assert candidate([{'id': 1, 'duration': 2, 'dependencies': []}, {'id': 2, 'duration': 2, 'dependencies': []}, {'id': 3, 'duration': 2, 'dependencies': [1, 2]}, {'id': 4, 'duration': 2, 'dependencies': [3]}, {'id': 5, 'duration': 2, 'dependencies': [3]}], 2) == 6\n    assert candidate([{'id': 1, 'duration': 10, 'dependencies': []}, {'id': 2, 'duration': 5, 'dependencies': [1]}, {'id': 3, 'duration': 7, 'dependencies': [1]}], 3) == 17\n", "language": "python"}
{"task_id": "revision1a_problem371", "prompt": "def longest_palindromic_subsequence(s: str) -> str:\n    \"\"\"\n    Given a string s, find the longest subsequence that is a palindrome.\n    A subsequence is a sequence that can be derived from another sequence by deleting some or no elements\n    without changing the order of the remaining elements.\n\n    Implement a function that takes a string as input and returns the longest palindromic subsequence.\n    If there are multiple longest palindromic subsequences, return any one of them.\n\n    Use dynamic programming to solve this problem efficiently.\n    Implement a custom memoization decorator to optimize the recursive solution.\n\n    Example:\n    Input: \"bbbab\"\n    Output: \"bbbb\"\n    Input: \"cbbd\"\n    Output: \"bb\"\n    Input: \"aabaa\"\n    Output: \"aabaa\"\n    \"\"\"\n", "entry_point": "longest_palindromic_subsequence", "solution": "    def memoize(func):\n        memo = {}\n        def wrapper(*args):\n            if args not in memo:\n                memo[args] = func(*args)\n            return memo[args]\n        return wrapper\n\n    @memoize\n    def lps(i, j):\n        if i > j:\n            return \"\"\n        if i == j:\n            return s[i]\n        \n        if s[i] == s[j]:\n            return s[i] + lps(i+1, j-1) + s[j]\n        else:\n            left = lps(i+1, j)\n            right = lps(i, j-1)\n            return left if len(left) > len(right) else right\n\n    return lps(0, len(s) - 1)\n", "test": "def check(candidate):\n    assert candidate(\"abcdefg\") == 'a'\n    assert candidate(\"cbbd\") == 'bb'\n    assert candidate(\"racecar\") == 'racecar'\n    assert candidate(\"ab\") == 'a'\n    assert candidate(\"a\") == 'a'\n    assert candidate(\"\") == ''\n    assert candidate(\"bbbab\") == 'bbbb'\n    assert candidate(\"abc\") == 'a'\n    assert candidate(\"abcba\") == 'abcba'\n    assert candidate(\"aabaa\") == 'aabaa'\n", "language": "python"}
{"task_id": "revision1a_problem528", "prompt": "from typing import List, Dict, Tuple\nfrom collections import defaultdict\n\ndef analyze_social_network(connections: List[Tuple[str, str]], interests: Dict[str, List[str]]) -> Dict[str, List[str]]:\n    \"\"\"\n    A social media platform wants to suggest new connections to its users based on shared interests and mutual friends.\n    Your task is to analyze the social network and provide recommendations for each user.\n\n    Given a list of existing connections between users and a dictionary of user interests, determine the top 3 recommended\n    connections for each user. The recommendations should be based on the following criteria:\n    1. Number of mutual friends\n    2. Number of shared interests\n    3. If there's a tie, sort alphabetically by username\n\n    Parameters:\n    connections (List[Tuple[str, str]]): List of tuples representing connections between users\n    interests (Dict[str, List[str]]): Dictionary mapping usernames to lists of their interests\n\n    Returns:\n    Dict[str, List[str]]: A dictionary where keys are usernames and values are lists of top 3 recommended connections\n\n    Example:\n    Input:\n    connections = [(\"Alice\", \"Bob\"), (\"Bob\", \"Charlie\"), (\"Charlie\", \"David\"), (\"David\", \"Alice\"), (\"Eve\", \"Alice\")]\n    interests = {\n        \"Alice\": [\"reading\", \"music\", \"art\"],\n        \"Bob\": [\"music\", \"sports\", \"cooking\"],\n        \"Charlie\": [\"art\", \"sports\", \"travel\"],\n        \"David\": [\"reading\", \"cooking\", \"travel\"],\n        \"Eve\": [\"music\", \"art\", \"cooking\"]\n    }\n    Output:\n    {\n        \"Alice\": [\"Charlie\", \"Eve\", \"David\"],\n        \"Bob\": [\"David\", \"Eve\", \"Charlie\"],\n        \"Charlie\": [\"Alice\", \"Eve\", \"Bob\"],\n        \"David\": [\"Bob\", \"Charlie\", \"Eve\"],\n        \"Eve\": [\"Bob\", \"Charlie\", \"David\"]\n    }\n\n    Note: Implement an efficient algorithm to compute mutual friends and shared interests.\n    Consider using appropriate data structures like graphs or sets to optimize the solution.\n    \"\"\"\n", "entry_point": "analyze_social_network", "solution": "    # Create a graph of connections\n    graph = defaultdict(set)\n    for u, v in connections:\n        graph[u].add(v)\n        graph[v].add(u)\n    \n    # Convert interests to sets for faster intersection\n    interest_sets = {user: set(interest_list) for user, interest_list in interests.items()}\n    \n    # Function to calculate score for a potential connection\n    def calculate_score(user, potential_connection):\n        mutual_friends = len(graph[user] & graph[potential_connection])\n        shared_interests = len(interest_sets[user] & interest_sets[potential_connection])\n        return (mutual_friends, shared_interests, potential_connection)\n    \n    recommendations = {}\n    \n    for user in interests:\n        # Get all users except the current user\n        potential_connections = set(interests.keys()) - {user} - graph[user]\n        \n        # Calculate scores for all potential connections\n        scores = [calculate_score(user, pc) for pc in potential_connections]\n        \n        # Sort scores based on mutual friends (desc), shared interests (desc), and username (asc)\n        sorted_scores = sorted(scores, key=lambda x: (-x[0], -x[1], x[2]))\n        \n        # Get top 3 recommendations\n        recommendations[user] = [score[2] for score in sorted_scores[:3]]\n    \n    return recommendations\n", "test": "def check(candidate):\n    assert candidate([(\"User1\", \"User2\")], {\"User1\": [\"interest1\"], \"User2\": [\"interest1\"], \"User3\": [\"interest1\"]}) == {'User1': ['User3'], 'User2': ['User3'], 'User3': ['User1', 'User2']}\n    assert candidate([(\"X\", \"Y\")], {\"X\": [\"a\", \"b\", \"c\"], \"Y\": [\"a\", \"b\", \"c\"], \"Z\": [\"a\", \"b\", \"c\"]}) == {'X': ['Z'], 'Y': ['Z'], 'Z': ['X', 'Y']}\n    assert candidate([(\"A\", \"B\"), (\"B\", \"C\"), (\"C\", \"D\"), (\"D\", \"A\")], {\"A\": [\"x\", \"y\"], \"B\": [\"y\", \"z\"], \"C\": [\"z\", \"w\"], \"D\": [\"w\", \"x\"]}) == {'A': ['C'], 'B': ['D'], 'C': ['A'], 'D': ['B']}\n    assert candidate([(\"Alice\", \"Bob\"), (\"Bob\", \"Charlie\"), (\"Charlie\", \"Alice\")], {\"Alice\": [\"reading\"], \"Bob\": [\"music\"], \"Charlie\": [\"sports\"]}) == {'Alice': [], 'Bob': [], 'Charlie': []}\n    assert candidate([(\"User1\", \"User2\"), (\"User2\", \"User3\"), (\"User3\", \"User4\")], {\"User1\": [], \"User2\": [], \"User3\": [], \"User4\": []}) == {'User1': ['User3', 'User4'], 'User2': ['User4'], 'User3': ['User1'], 'User4': ['User2', 'User1']}\n    assert candidate([(\"Alice\", \"Bob\"), (\"Bob\", \"Charlie\"), (\"Charlie\", \"David\"), (\"David\", \"Alice\"), (\"Eve\", \"Alice\")], {\"Alice\": [\"reading\", \"music\", \"art\"], \"Bob\": [\"music\", \"sports\", \"cooking\"], \"Charlie\": [\"art\", \"sports\", \"travel\"], \"David\": [\"reading\", \"cooking\", \"travel\"], \"Eve\": [\"music\", \"art\", \"cooking\"]}) == {'Alice': ['Charlie'], 'Bob': ['David', 'Eve'], 'Charlie': ['Alice', 'Eve'], 'David': ['Bob', 'Eve'], 'Eve': ['Bob', 'David', 'Charlie']}\n    assert candidate([(\"X\", \"Y\"), (\"Y\", \"Z\")], {\"X\": [\"a\", \"b\"], \"Y\": [\"b\", \"c\"], \"Z\": [\"c\", \"d\"]}) == {'X': ['Z'], 'Y': [], 'Z': ['X']}\n    assert candidate([], {}) == {}\n    assert candidate([(\"A\", \"B\"), (\"B\", \"C\"), (\"C\", \"D\"), (\"D\", \"E\"), (\"E\", \"A\")], {\"A\": [\"1\", \"2\"], \"B\": [\"2\", \"3\"], \"C\": [\"3\", \"4\"], \"D\": [\"4\", \"5\"], \"E\": [\"5\", \"1\"]}) == {'A': ['C', 'D'], 'B': ['D', 'E'], 'C': ['A', 'E'], 'D': ['A', 'B'], 'E': ['B', 'C']}\n    assert candidate([(\"A\", \"B\")], {\"A\": [\"x\"], \"B\": [\"x\"]}) == {'A': [], 'B': []}\n", "language": "python"}
{"task_id": "revision1a_problem570", "prompt": "import math\nfrom typing import List, Tuple\n\ndef optimize_delivery_route(packages: List[Tuple[int, int]]) -> List[int]:\n    \"\"\"\n    Optimize a delivery route for a courier service.\n\n    A courier needs to deliver packages to various locations in a city. Each location\n    is represented by its (x, y) coordinates. The courier starts at (0, 0) and wants\n    to find the most efficient route to deliver all packages.\n\n    Take a list of tuples representing package destinations as input, where each tuple\n    contains the (x, y) coordinates of a delivery location. Return a list of indices\n    representing the optimal order to visit these locations.\n\n    Use the nearest neighbor algorithm: always move to the closest unvisited location.\n\n    Example:\n    Input: [(1, 1), (4, 4), (2, 3), (5, 2)]\n    Output: [0, 2, 1, 3]\n    Input: [(3, 3), (-2, -2), (5, 1), (1, 4), (-3, 5)]\n    Output: [1, 0, 3, 2, 4]\n    \"\"\"\n", "entry_point": "optimize_delivery_route", "solution": "    def distance(p1: Tuple[int, int], p2: Tuple[int, int]) -> float:\n        return math.sqrt((p1[0] - p2[0])**2 + (p1[1] - p2[1])**2)\n\n    n = len(packages)\n    unvisited = set(range(n))\n    route = []\n    current_pos = (0, 0)  # Starting position\n\n    while unvisited:\n        nearest = min(unvisited, key=lambda i: distance(current_pos, packages[i]))\n        route.append(nearest)\n        current_pos = packages[nearest]\n        unvisited.remove(nearest)\n\n    return route\n", "test": "def check(candidate):\n    assert candidate([]) == []\n    assert candidate([(1, 1), (4, 4), (2, 3), (5, 2)]) == [0, 2, 1, 3]\n    assert candidate([(1, 1), (2, 2), (3, 3), (4, 4), (5, 5)]) == [0, 1, 2, 3, 4]\n    assert candidate([(0, 1), (0, 2), (0, 3), (0, 4), (0, 5)]) == [0, 1, 2, 3, 4]\n    assert candidate([(1, 0), (0, 1), (-1, 0), (0, -1)]) == [0, 1, 2, 3]\n    assert candidate([(0, 0)]) == [0]\n    assert candidate([(3, 3), (-2, -2), (5, 1), (1, 4), (-3, 5)]) == [1, 3, 0, 2, 4]\n    assert candidate([(10, 10), (-10, -10), (10, -10), (-10, 10)]) == [0, 2, 1, 3]\n    assert candidate([(1, 1), (1, 2), (1, 3), (1, 4), (1, 5)]) == [0, 1, 2, 3, 4]\n    assert candidate([(1, 1), (1, 1), (2, 2), (2, 2), (3, 3)]) == [0, 1, 2, 3, 4]\n", "language": "python"}
{"task_id": "revision1a_problem209", "prompt": "from typing import List, Tuple, Dict\n\ndef investment_portfolio(name: str, stocks: Dict[str, int], bonds: Dict[str, int], real_estate: Dict[str, int]) -> Dict[str, float]:\n    \"\"\"\n    Create a class named Portfolio with the following methods:\n    1. StockReturn: calculate the return on stocks i.e., 7% of the total stock value\n    2. BondReturn: calculate the return on bonds i.e., 3% of the total bond value\n    3. RealEstateReturn: calculate the return on real estate i.e., 5% of the total real estate value\n    \n    Take input from the user for stock values, bond values, and real estate values as dictionaries.\n    Calculate and return the expected annual return for each investment type.\n    Also, take the name of the investor and include it in the output dictionary.\n    \n    Example:\n    Input: \"Sarah\", {\"AAPL\": 10000, \"GOOGL\": 15000}, {\"T-Bill\": 20000, \"Municipal\": 30000}, {\"Apartment\": 200000, \"Office\": 300000}\n    Output: {\"name\": \"Sarah\", \"stock_return\": 1750.0, \"bond_return\": 1500.0, \"real_estate_return\": 25000.0}\n    \"\"\"\n", "entry_point": "investment_portfolio", "solution": "    class Portfolio:\n        def __init__(self, stocks, bonds, real_estate):\n            self.stocks = stocks\n            self.bonds = bonds\n            self.real_estate = real_estate\n\n        def StockReturn(self):\n            total_stock_value = sum(self.stocks.values())\n            return 0.07 * total_stock_value\n\n        def BondReturn(self):\n            total_bond_value = sum(self.bonds.values())\n            return 0.03 * total_bond_value\n\n        def RealEstateReturn(self):\n            total_real_estate_value = sum(self.real_estate.values())\n            return 0.05 * total_real_estate_value\n\n    portfolio = Portfolio(stocks, bonds, real_estate)\n\n    result = {\n        \"name\": name,\n        \"stock_return\": portfolio.StockReturn(),\n        \"bond_return\": portfolio.BondReturn(),\n        \"real_estate_return\": portfolio.RealEstateReturn()\n    }\n\n    return result\n", "test": "def check(candidate):\n    assert candidate(\"Sarah Connor\", {\"AAPL\": 1, \"GOOGL\": 1, \"MSFT\": 1}, {\"T-Bill\": 1, \"Municipal\": 1}, {\"Apartment\": 1}) == {'name': 'Sarah Connor', 'stock_return': 0.21000000000000002, 'bond_return': 0.06, 'real_estate_return': 0.05}\n    assert candidate(\"Mike Johnson\", {}, {\"Government\": 50000}, {\"Land\": 100000}) == {'name': 'Mike Johnson', 'stock_return': 0.0, 'bond_return': 1500.0, 'real_estate_return': 5000.0}\n    assert candidate(\"Tony Stark\", {\"STARK\": 1000000}, {\"Arc Reactor\": 5000000}, {\"Stark Tower\": 1000000000}) == {'name': 'Tony Stark', 'stock_return': 70000.0, 'bond_return': 150000.0, 'real_estate_return': 50000000.0}\n    assert candidate(\"Bruce Wayne\", {\"WAYNE\": 500000}, {\"Gotham Bonds\": 1000000}, {\"Wayne Manor\": 50000000, \"Batcave\": 100000000}) == {'name': 'Bruce Wayne', 'stock_return': 35000.0, 'bond_return': 30000.0, 'real_estate_return': 7500000.0}\n    assert candidate(\"Clark Kent\", {}, {\"Smallville Bank\": 5000}, {\"Kent Farm\": 200000}) == {'name': 'Clark Kent', 'stock_return': 0.0, 'bond_return': 150.0, 'real_estate_return': 10000.0}\n    assert candidate(\"John Doe\", {\"AAPL\": 10000, \"GOOGL\": 15000}, {\"T-Bill\": 20000, \"Municipal\": 30000}, {\"Apartment\": 200000, \"Office\": 300000}) == {'name': 'John Doe', 'stock_return': 1750.0000000000002, 'bond_return': 1500.0, 'real_estate_return': 25000.0}\n    assert candidate(\"Emily Brown\", {\"MSFT\": 12000}, {}, {\"Retail Space\": 180000}) == {'name': 'Emily Brown', 'stock_return': 840.0000000000001, 'bond_return': 0.0, 'real_estate_return': 9000.0}\n    assert candidate(\"Peter Parker\", {\"Daily Bugle\": 100}, {}, {}) == {'name': 'Peter Parker', 'stock_return': 7.000000000000001, 'bond_return': 0.0, 'real_estate_return': 0.0}\n    assert candidate(\"David Lee\", {\"FB\": 7500, \"NFLX\": 6500}, {\"Municipal\": 25000, \"Corporate\": 20000}, {}) == {'name': 'David Lee', 'stock_return': 980.0000000000001, 'bond_return': 1350.0, 'real_estate_return': 0.0}\n    assert candidate(\"Jane Smith\", {\"TSLA\": 5000, \"AMZN\": 8000}, {\"Corporate\": 15000}, {\"House\": 250000}) == {'name': 'Jane Smith', 'stock_return': 910.0000000000001, 'bond_return': 450.0, 'real_estate_return': 12500.0}\n", "language": "python"}
{"task_id": "revision1a_problem617", "prompt": "from typing import List, Tuple\n\ndef optimize_delivery_route(packages: List[Tuple[int, int, int]]) -> int:\n    \"\"\"\n    You're a delivery driver for an e-commerce company. You need to deliver packages to various addresses in a city.\n    The city is represented as a grid, and each package has coordinates (x, y) and a weight.\n    Your task is to find the minimum distance you need to travel to deliver all packages, given these constraints:\n    1. You start at (0, 0) and must return there after all deliveries.\n    2. You can carry a maximum weight of 10 units at a time.\n    3. You must return to (0, 0) to pick up more packages if you can't carry all remaining ones.\n    4. Distance is calculated as Manhattan distance (|x1 - x2| + |y1 - y2|).\n\n    Take the list of packages (each represented as a tuple (x, y, weight)) as input and return the minimum total distance traveled.\n\n    Example:\n    Input: [(1, 1, 5), (2, 2, 7), (3, 3, 3)]\n    Output: 20\n    Input: [(1, 1, 1), (2, 2, 2), (3, 3, 3), (4, 4, 4)]\n    Output: 28\n    \"\"\"\n", "entry_point": "optimize_delivery_route", "solution": "    def manhattan_distance(x1, y1, x2, y2):\n        return abs(x1 - x2) + abs(y1 - y2)\n\n    def dfs(current_x, current_y, remaining_packages, current_weight, distance):\n        if not remaining_packages:\n            return distance + manhattan_distance(current_x, current_y, 0, 0)\n\n        min_distance = float('inf')\n        for i, (x, y, weight) in enumerate(remaining_packages):\n            if current_weight + weight <= 10:\n                new_distance = distance + manhattan_distance(current_x, current_y, x, y)\n                new_remaining = remaining_packages[:i] + remaining_packages[i+1:]\n                min_distance = min(min_distance, dfs(x, y, new_remaining, current_weight + weight, new_distance))\n\n        if min_distance == float('inf'):\n            return_distance = distance + manhattan_distance(current_x, current_y, 0, 0)\n            min_distance = dfs(0, 0, remaining_packages, 0, return_distance)\n\n        return min_distance\n\n    return dfs(0, 0, packages, 0, 0)\n", "test": "def check(candidate):\n    assert candidate([(0, 5, 2), (5, 0, 2), (5, 5, 2), (0, 0, 2)]) == 20\n    assert candidate([(0, 0, 10)]) == 0\n    assert candidate([(1, 1, 5), (2, 2, 7), (3, 3, 3)]) == 16\n    assert candidate([(1, 0, 5), (0, 1, 5), (-1, 0, 5), (0, -1, 5)]) == 8\n    assert candidate([(10, 10, 1), (20, 20, 1), (30, 30, 1)]) == 120\n    assert candidate([(1, 1, 1), (2, 2, 2), (3, 3, 3), (4, 4, 4)]) == 16\n    assert candidate([]) == 0\n    assert candidate([(1, 1, 3), (2, 2, 3), (3, 3, 3), (4, 4, 3)]) == 20\n    assert candidate([(5, 5, 10), (5, 5, 10), (5, 5, 10)]) == 60\n    assert candidate([(1, 1, 10), (2, 2, 10), (3, 3, 10)]) == 24\n", "language": "python"}
{"task_id": "revision1a_problem396", "prompt": "import heapq\nfrom typing import List\n\ndef design_rollercoaster(heights: List[int], k: int) -> List[List[int]]:\n    \"\"\"\n    You're an engineer designing a new rollercoaster for an amusement park. \n    Given a list of integers representing the heights of people in the queue and an integer k representing\n    the number of seats in each car, your task is to organize people into cars to maximize thrill.\n    The thrill of a car is defined as the difference between the tallest and shortest person in the car.\n    Use a sliding window technique with a priority queue to solve this problem efficiently.\n    Take the list of heights and k as input, and return a list of lists, where each sublist represents a car\n    with the indices of people in that car, organized to maximize overall thrill.\n\n    Example:\n    Input: heights = [1, 5, 3, 2, 4], k = 3\n    Output: [[1, 4, 5], [0, 2, 3]]\n\n    Input: heights = [7, 4, 1, 3, 6, 2, 5], k = 2\n    Output: [[0, 2], [3, 5], [1, 4], [6]]\n    \"\"\"\n", "entry_point": "design_rollercoaster", "solution": "    n = len(heights)\n    result = []\n    \n    # Create a list of tuples (height, index)\n    height_index = [(h, i) for i, h in enumerate(heights)]\n    \n    # Sort the list based on heights in descending order\n    height_index.sort(reverse=True)\n    \n    # Initialize a min heap to store the shortest person in each car\n    min_heap = []\n    \n    for height, index in height_index:\n        if len(min_heap) < (n + k - 1) // k:\n            # If we haven't formed enough cars yet, add a new car\n            heapq.heappush(min_heap, (float('inf'), []))\n        \n        # Get the car with the shortest person\n        shortest, car = heapq.heappop(min_heap)\n        \n        # Add the current person to the car\n        car.append(index)\n        \n        # Update the shortest person in the car\n        new_shortest = min(shortest, height)\n        \n        # If the car is full, add it to the result\n        if len(car) == k:\n            result.append(sorted(car))\n        else:\n            # Otherwise, push it back to the heap\n            heapq.heappush(min_heap, (new_shortest, car))\n    \n    # Add any remaining cars to the result\n    while min_heap:\n        _, car = heapq.heappop(min_heap)\n        if car:\n            result.append(sorted(car))\n    \n    return result\n", "test": "def check(candidate):\n    assert candidate([100, 1, 99, 2, 98, 3], 3) == [[0, 2, 4], [1, 3, 5]]\n    assert candidate([1, 2, 3, 4, 5, 6, 7, 8, 9, 10], 4) == [[6, 7, 8, 9], [2, 3, 4, 5], [0, 1]]\n    assert candidate([1, 2], 2) == [[0, 1]]\n    assert candidate([1, 1, 1, 1, 1, 1, 1, 1, 1, 1], 5) == [[5, 6, 7, 8, 9], [0, 1, 2, 3, 4]]\n    assert candidate([5, 5, 5, 5, 5], 2) == [[3, 4], [1, 2], [0]]\n    assert candidate([7, 4, 1, 3, 6, 2, 5], 2) == [[0, 4], [1, 6], [3, 5], [2]]\n    assert candidate([10, 20, 30, 40, 50], 5) == [[0, 1, 2, 3, 4]]\n    assert candidate([1, 5, 3, 2, 4], 3) == [[1, 2, 4], [0, 3]]\n    assert candidate([1], 1) == [[0]]\n    assert candidate([10, 9, 8, 7, 6, 5, 4, 3, 2, 1], 3) == [[0, 1, 2], [3, 4, 5], [6, 7, 8], [9]]\n", "language": "python"}
{"task_id": "revision1a_problem208", "prompt": "from typing import List\n\ndef longest_common_subsequence(str1: str, str2: str) -> str:\n    \"\"\"\n    Imagine you're a geneticist comparing DNA sequences from two different species.\n    You need to find the longest common subsequence (LCS) between these two sequences.\n    The LCS is the longest sequence of characters that appear in the same order in both strings,\n    but they don't need to be consecutive.\n\n    Write a function that takes two strings as input and returns their longest common subsequence.\n    If there are multiple LCS of the same length, return any one of them.\n\n    Example:\n    Input: \"ABCDGH\", \"AEDFHR\"\n    Output: \"ADH\"\n    Input: \"AGGTAB\", \"GXTXAYB\"\n    Output: \"GTAB\"\n    \"\"\"\n", "entry_point": "longest_common_subsequence", "solution": "    m, n = len(str1), len(str2)\n    \n    # Create a 2D table to store the lengths of LCS\n    dp = [[0] * (n + 1) for _ in range(m + 1)]\n    \n    # Fill the dp table\n    for i in range(1, m + 1):\n        for j in range(1, n + 1):\n            if str1[i-1] == str2[j-1]:\n                dp[i][j] = dp[i-1][j-1] + 1\n            else:\n                dp[i][j] = max(dp[i-1][j], dp[i][j-1])\n    \n    # Reconstruct the LCS\n    lcs = []\n    i, j = m, n\n    while i > 0 and j > 0:\n        if str1[i-1] == str2[j-1]:\n            lcs.append(str1[i-1])\n            i -= 1\n            j -= 1\n        elif dp[i-1][j] > dp[i][j-1]:\n            i -= 1\n        else:\n            j -= 1\n    \n    # Return the LCS as a string\n    return ''.join(reversed(lcs))\n", "test": "def check(candidate):\n    assert candidate(\"ABC\", \"ABC\") == 'ABC'\n    assert candidate(\"A\", \"A\") == 'A'\n    assert candidate(\"ABABAB\", \"ABAB\") == 'ABAB'\n    assert candidate(\"A\", \"\") == ''\n    assert candidate(\"ABC\", \"CBA\") == 'C'\n    assert candidate(\"\", \"B\") == ''\n    assert candidate(\"ABCDEFG\", \"ABCDEFG\") == 'ABCDEFG'\n    assert candidate(\"ABCDGH\", \"AEDFHR\") == 'ADH'\n    assert candidate(\"\", \"\") == ''\n    assert candidate(\"AGGTAB\", \"GXTXAYB\") == 'GTAB'\n", "language": "python"}
{"task_id": "revision1a_problem693", "prompt": "from typing import List\nimport math\n\ndef network_latency(n: int, connections: List[List[int]], queries: List[List[int]]) -> List[int]:\n    \"\"\"\n    In a computer network, I have n nodes numbered from 0 to n-1. The connections between nodes\n    are given as a list of triples [u, v, w], where u and v are the connected nodes, and w is the\n    latency between them. I need to process q queries, where each query is a pair [a, b] asking for\n    the minimum latency between nodes a and b.\n\n    Implement a function that takes the number of nodes, the list of connections, and the list of\n    queries as input, and returns a list of minimum latencies for each query. If there's no path\n    between two nodes, the latency should be considered as -1.\n\n    Use dynamic programming or graph algorithms to solve this problem efficiently.\n\n    Example:\n    Input: 4, [[0,1,10],[1,2,5],[2,3,9],[0,3,30]], [[0,3],[1,2],[0,2]]\n    Output: [24, 5, 15]\n\n    Explanation:\n    - Minimum latency from 0 to 3 is 24 (0 -> 1 -> 2 -> 3)\n    - Minimum latency from 1 to 2 is 5 (direct connection)\n    - Minimum latency from 0 to 2 is 15 (0 -> 1 -> 2)\n    \"\"\"\n", "entry_point": "network_latency", "solution": "    # Initialize the distance matrix with infinity\n    dist = [[math.inf] * n for _ in range(n)]\n    \n    # Set diagonal elements to 0 (distance from a node to itself)\n    for i in range(n):\n        dist[i][i] = 0\n    \n    # Fill in the known distances from the connections\n    for u, v, w in connections:\n        dist[u][v] = min(dist[u][v], w)  # In case of multiple connections between same nodes\n        dist[v][u] = min(dist[v][u], w)  # Assuming bidirectional connections\n    \n    # Floyd-Warshall algorithm\n    for k in range(n):\n        for i in range(n):\n            for j in range(n):\n                dist[i][j] = min(dist[i][j], dist[i][k] + dist[k][j])\n    \n    # Process queries\n    result = []\n    for a, b in queries:\n        latency = dist[a][b]\n        result.append(latency if latency != math.inf else -1)\n    \n    return result\n", "test": "def check(candidate):\n    assert candidate(6, [[0,1,1],[1,2,1],[2,3,1],[3,4,1],[4,5,1]], [[0,5],[2,4],[1,5]]) == [5, 2, 4]\n    assert candidate(2, [[0,1,100]], [[0,1],[1,0]]) == [100, 100]\n    assert candidate(3, [[0,1,1],[1,2,1],[0,2,3]], [[0,2],[1,2],[0,1]]) == [2, 1, 1]\n    assert candidate(3, [[0,1,5],[1,2,5]], [[0,2],[1,2],[0,1]]) == [10, 5, 5]\n    assert candidate(5, [[0,1,1],[1,2,2],[2,3,3],[3,4,4]], [[0,4],[1,3],[0,2]]) == [10, 5, 3]\n    assert candidate(10, [[i,i+1,1] for i in range(9)], [[0,9],[5,7],[2,8]]) == [9, 2, 6]\n    assert candidate(4, [[0,1,1],[1,2,1],[2,3,1],[3,0,1]], [[0,2],[1,3],[0,3]]) == [2, 2, 1]\n    assert candidate(1, [], [[0,0]]) == [0]\n    assert candidate(5, [[0,1,10],[1,2,20],[2,3,30],[3,4,40]], [[0,4],[1,3],[0,2]]) == [100, 50, 30]\n    assert candidate(4, [[0,1,10],[1,2,5],[2,3,9],[0,3,30]], [[0,3],[1,2],[0,2]]) == [24, 5, 15]\n", "language": "python"}
{"task_id": "revision1a_problem556", "prompt": "from typing import List, Tuple\nimport heapq\n\ndef network_latency(nodes: int, connections: List[Tuple[int, int, int]], start: int) -> List[int]:\n    \"\"\"\n    I'm a network engineer tasked with analyzing the latency in a computer network. The network consists \n    of nodes (computers) connected by links with varying latencies. I want to find the minimum latency from \n    a starting node to all other nodes in the network.\n\n    Take input from the user in the form of:\n    - The number of nodes in the network\n    - A list of tuples representing connections, where each tuple contains (source_node, target_node, latency)\n    - The starting node\n\n    Return a list of integers representing the minimum latency from the start node to each other node. \n    If a node is unreachable, its latency should be represented as -1.\n\n    Use Dijkstra's algorithm with a priority queue to solve this problem efficiently.\n\n    Example:\n    Input: \n    nodes = 4\n    connections = [(0, 1, 10), (0, 2, 5), (1, 2, 2), (1, 3, 1), (2, 3, 4)]\n    start = 0\n\n    Output: [0, 7, 5, 8]\n    \"\"\"\n", "entry_point": "network_latency", "solution": "    # Create an adjacency list to represent the network\n    graph = [[] for _ in range(nodes)]\n    for source, target, latency in connections:\n        graph[source].append((target, latency))\n        graph[target].append((source, latency))  # Assuming bidirectional connections\n\n    # Initialize distances array with infinity for all nodes except the start node\n    distances = [float('inf')] * nodes\n    distances[start] = 0\n\n    # Priority queue to store nodes to visit (latency, node)\n    pq = [(0, start)]\n\n    while pq:\n        current_latency, current_node = heapq.heappop(pq)\n\n        # If we've found a longer path, skip this node\n        if current_latency > distances[current_node]:\n            continue\n\n        # Check all neighbors of the current node\n        for neighbor, latency in graph[current_node]:\n            new_latency = current_latency + latency\n\n            # If we've found a shorter path to the neighbor\n            if new_latency < distances[neighbor]:\n                distances[neighbor] = new_latency\n                heapq.heappush(pq, (new_latency, neighbor))\n\n    # Replace infinity with -1 for unreachable nodes\n    return [d if d != float('inf') else -1 for d in distances]\n", "test": "def check(candidate):\n    assert candidate(5, [(0, 1, 5), (1, 2, 5), (2, 3, 5), (3, 4, 5), (0, 4, 1)], 0) == [0, 5, 10, 6, 1]\n    assert candidate(6, [(0, 1, 2), (1, 2, 3), (2, 3, 4), (3, 4, 5), (4, 5, 6)], 3) == [9, 7, 4, 0, 5, 11]\n    assert candidate(4, [(0, 1, 1), (1, 2, 1), (2, 3, 1)], 3) == [3, 2, 1, 0]\n    assert candidate(3, [], 0) == [0, -1, -1]\n    assert candidate(2, [(0, 1, 100)], 0) == [0, 100]\n    assert candidate(4, [(0, 1, 1), (1, 2, 1), (2, 3, 1), (0, 3, 10)], 0) == [0, 1, 2, 3]\n    assert candidate(5, [(0, 1, 1), (1, 2, 2), (2, 3, 3), (3, 4, 4)], 0) == [0, 1, 3, 6, 10]\n    assert candidate(4, [(0, 1, 10), (0, 2, 5), (1, 2, 2), (1, 3, 1), (2, 3, 4)], 0) == [0, 7, 5, 8]\n    assert candidate(3, [(0, 1, 1), (1, 2, 1), (0, 2, 3)], 1) == [1, 0, 1]\n    assert candidate(3, [(0, 1, 5), (1, 2, 5)], 0) == [0, 5, 10]\n", "language": "python"}
{"task_id": "revision1a_problem583", "prompt": "from typing import Dict\nfrom collections import Counter\nimport re\n\ndef analyze_text(text: str) -> Dict[str, int]:\n    \"\"\"\n    I'm working on a natural language processing project and need to analyze text documents.\n    I want a function that takes a text as input and returns various statistics about it.\n    The function should return a dictionary with the following keys and values:\n    - 'word_count': total number of words\n    - 'sentence_count': total number of sentences\n    - 'avg_word_length': average word length (rounded to 2 decimal places)\n    - 'unique_words': number of unique words (case-insensitive)\n    - 'most_common_word': the most frequently occurring word (excluding common stop words)\n    If the input text is empty or contains only whitespace, raise a ValueError.\n    Use regular expressions to split the text into words and sentences.\n    Example:\n    Input: \"Hello world! This is a sample text. Hello again.\"\n    Output: {\n        'word_count': 8,\n        'sentence_count': 3,\n        'avg_word_length': 4.25,\n        'unique_words': 7,\n        'most_common_word': 'hello'\n    }\n    Input: \"\"\n    Output: \"ValueError: Input text cannot be empty\"\n    \"\"\"\n", "entry_point": "analyze_text", "solution": "    # Check if the input text is empty or contains only whitespace\n    if not text.strip():\n        raise ValueError(\"Input text cannot be empty\")\n\n    # Define stop words\n    stop_words = set(['a', 'an', 'and', 'are', 'as', 'at', 'be', 'by', 'for', 'from', 'has', 'he', \n                      'in', 'is', 'it', 'its', 'of', 'on', 'that', 'the', 'to', 'was', 'were', 'will', 'with'])\n\n    # Split text into sentences\n    sentences = re.split(r'[.!?]+', text)\n    sentences = [s.strip() for s in sentences if s.strip()]\n\n    # Split text into words\n    words = re.findall(r'\\b\\w+\\b', text.lower())\n\n    # Calculate word count\n    word_count = len(words)\n\n    # Calculate sentence count\n    sentence_count = len(sentences)\n\n    # Calculate average word length\n    avg_word_length = round(sum(len(word) for word in words) / word_count, 2)\n\n    # Calculate unique words\n    unique_words = len(set(words))\n\n    # Find most common word (excluding stop words)\n    word_freq = Counter(word for word in words if word not in stop_words)\n    most_common_word = word_freq.most_common(1)[0][0] if word_freq else None\n\n    # Create and return the result dictionary\n    result = {\n        'word_count': word_count,\n        'sentence_count': sentence_count,\n        'avg_word_length': avg_word_length,\n        'unique_words': unique_words,\n        'most_common_word': most_common_word\n    }\n\n    return result\n", "test": "def check(candidate):\n    assert candidate(\"the quick brown fox jumps over the lazy dog.\") == {'word_count': 9, 'sentence_count': 1, 'avg_word_length': 3.89, 'unique_words': 8, 'most_common_word': 'quick'}\n    assert candidate(\"1234 5678 90\") == {'word_count': 3, 'sentence_count': 1, 'avg_word_length': 3.33, 'unique_words': 3, 'most_common_word': '1234'}\n    assert candidate(\"a b c d e f g h i j k l m n o p\") == {'word_count': 16, 'sentence_count': 1, 'avg_word_length': 1.0, 'unique_words': 16, 'most_common_word': 'b'}\n    assert candidate(\"THE QUICK BROWN FOX JUMPS OVER THE LAZY DOG.\") == {'word_count': 9, 'sentence_count': 1, 'avg_word_length': 3.89, 'unique_words': 8, 'most_common_word': 'quick'}\n    assert candidate(\"Short. Sentences. Are. Used. Here.\") == {'word_count': 5, 'sentence_count': 5, 'avg_word_length': 5.0, 'unique_words': 5, 'most_common_word': 'short'}\n    assert candidate(\"Hello world! This is a sample text. Hello again.\") == {'word_count': 9, 'sentence_count': 3, 'avg_word_length': 4.11, 'unique_words': 8, 'most_common_word': 'hello'}\n    assert candidate(\"The quick brown fox jumps over the lazy dog.\") == {'word_count': 9, 'sentence_count': 1, 'avg_word_length': 3.89, 'unique_words': 8, 'most_common_word': 'quick'}\n    assert candidate(\"Lorem ipsum dolor sit amet, consectetur adipiscing elit. Nullam auctor, nunc id aliquam tincidunt, nisl nunc tincidunt nunc, vitae aliquam nunc nunc vitae nunc.\") == {'word_count': 24, 'sentence_count': 2, 'avg_word_length': 5.46, 'unique_words': 16, 'most_common_word': 'nunc'}\n    assert candidate(\"A\") == {'word_count': 1, 'sentence_count': 1, 'avg_word_length': 1.0, 'unique_words': 1, 'most_common_word': None}\n    assert candidate(\"This sentence has exactly seven words.\") == {'word_count': 6, 'sentence_count': 1, 'avg_word_length': 5.33, 'unique_words': 6, 'most_common_word': 'this'}\n", "language": "python"}
{"task_id": "revision1a_problem230", "prompt": "import random\nfrom typing import List, Tuple\n\ndef simulate_stock_market(initial_capital: float, num_days: int, stocks: List[str]) -> Tuple[float, List[str]]:\n    \"\"\"\n    Simulate a simple stock market trading scenario to help understand basic financial concepts and decision-making.\n\n    Your task is to create a program that simulates daily stock price changes and allows the user to make buy/sell decisions.\n    The program should take the initial capital, number of simulation days, and a list of stock names as input.\n    For each day, randomly generate price changes for each stock and allow the user to buy, sell, or hold their position.\n    At the end of the simulation, calculate the final portfolio value and return it along with a list of daily actions taken.\n\n    Use the random module to generate price changes and the round() function to limit decimal places in calculations.\n\n    Example:\n    Input: 10000.0, 5, [\"AAPL\", \"GOOGL\", \"MSFT\"]\n    Output: (10523.75, ['Day 1: Bought 2 AAPL', 'Day 2: Sold 1 GOOGL', 'Day 3: Held', 'Day 4: Bought 3 MSFT', 'Day 5: Sold 1 AAPL'])\n    \"\"\"\n", "entry_point": "simulate_stock_market", "solution": "    portfolio = {stock: 0 for stock in stocks}\n    stock_prices = {stock: round(random.uniform(50, 200), 2) for stock in stocks}\n    cash = initial_capital\n    actions = []\n\n    for day in range(1, num_days + 1):\n        print(f\"\\nDay {day}:\")\n        print(f\"Cash: ${cash:.2f}\")\n        print(\"Current stock prices:\")\n        for stock, price in stock_prices.items():\n            print(f\"{stock}: ${price:.2f}\")\n        print(\"Your portfolio:\")\n        for stock, quantity in portfolio.items():\n            print(f\"{stock}: {quantity}\")\n\n        action = input(\"Enter your action (buy/sell/hold): \").lower()\n        if action == \"buy\":\n            stock = input(\"Enter the stock to buy: \").upper()\n            if stock in stocks:\n                quantity = int(input(\"Enter the quantity to buy: \"))\n                cost = stock_prices[stock] * quantity\n                if cost <= cash:\n                    cash -= cost\n                    portfolio[stock] += quantity\n                    actions.append(f\"Day {day}: Bought {quantity} {stock}\")\n                else:\n                    print(\"Insufficient funds.\")\n            else:\n                print(\"Invalid stock.\")\n        elif action == \"sell\":\n            stock = input(\"Enter the stock to sell: \").upper()\n            if stock in stocks and portfolio[stock] > 0:\n                quantity = int(input(\"Enter the quantity to sell: \"))\n                if quantity <= portfolio[stock]:\n                    cash += stock_prices[stock] * quantity\n                    portfolio[stock] -= quantity\n                    actions.append(f\"Day {day}: Sold {quantity} {stock}\")\n                else:\n                    print(\"Insufficient stocks to sell.\")\n            else:\n                print(\"Invalid stock or no stocks to sell.\")\n        else:\n            actions.append(f\"Day {day}: Held\")\n\n        # Update stock prices for the next day\n        for stock in stocks:\n            price_change = random.uniform(-0.05, 0.05)  # -5% to +5% change\n            stock_prices[stock] = round(stock_prices[stock] * (1 + price_change), 2)\n\n    # Calculate final portfolio value\n    final_value = cash + sum(portfolio[stock] * stock_prices[stock] for stock in stocks)\n    final_value = round(final_value, 2)\n\n    return final_value, actions\n", "test": "def check(candidate):\n    assert candidate(10000.0, 0, [\"AAPL\", \"GOOGL\"]) == (10000.0, [])\n", "language": "python"}
{"task_id": "revision1a_problem85", "prompt": "from typing import List\n\ndef optimize_warehouse_layout(items: List[int], shelf_capacity: int) -> int:\n    \"\"\"\n    A warehouse manager needs to organize items of various weights on shelves.\n    Each shelf has a maximum weight capacity. The goal is to minimize the number\n    of shelves used while ensuring no shelf exceeds its weight limit.\n\n    This function takes a list of item weights and the weight capacity of each shelf,\n    and returns the minimum number of shelves required to store all items.\n\n    Example:\n    Input: items = [10, 20, 30, 40, 50, 60, 70], shelf_capacity = 100\n    Output: 3\n\n    Explanation: \n    Shelf 1: [70, 30]\n    Shelf 2: [60, 40]\n    Shelf 3: [50, 20, 10]\n\n    Args:\n    items (List[int]): A list of integers representing the weights of items to be stored.\n    shelf_capacity (int): An integer representing the maximum weight capacity of each shelf.\n\n    Returns:\n    int: The minimum number of shelves required to store all items.\n    \"\"\"\n", "entry_point": "optimize_warehouse_layout", "solution": "    # Sort items in descending order\n    items.sort(reverse=True)\n    \n    # Initialize the number of shelves and the current shelf\n    shelves = 0\n    current_shelf = 0\n    \n    # Iterate through the sorted items\n    for item in items:\n        # If the item doesn't fit on the current shelf, start a new shelf\n        if current_shelf + item > shelf_capacity:\n            shelves += 1\n            current_shelf = item\n        else:\n            # Add the item to the current shelf\n            current_shelf += item\n    \n    # Add the last shelf if it contains items\n    if current_shelf > 0:\n        shelves += 1\n    \n    return shelves\n", "test": "def check(candidate):\n    assert candidate([1, 2, 3, 4, 5, 6, 7, 8, 9, 10], 15) == 5\n    assert candidate([30, 30, 30, 30, 30], 90) == 2\n    assert candidate([100, 100, 100, 100], 100) == 4\n    assert candidate([50, 50, 50, 50], 100) == 2\n    assert candidate([10], 10) == 1\n    assert candidate([10, 20, 30, 40, 50, 60, 70], 100) == 4\n    assert candidate([], 100) == 0\n    assert candidate([1, 1, 1, 1, 1], 5) == 1\n    assert candidate([1, 2, 3, 4, 5], 10) == 2\n    assert candidate([99, 99, 99], 100) == 3\n", "language": "python"}
{"task_id": "revision1a_problem211", "prompt": "from typing import List\n\ndef optimize_inventory(sales_data: List[int], days: int) -> List[int]:\n    \"\"\"\n    As the inventory manager of a popular electronics store, you're tasked with optimizing the stock levels \n    of a particular smartphone model. You have sales data for the past N days and want to find the optimal \n    restocking strategy for the next M days.\n\n    Given a list of daily sales for the past N days and the number of future days M to plan for, \n    return a list of M integers representing the optimal number of phones to stock each day. \n\n    The optimization should minimize both overstocking and stockouts. Assume that:\n    1. Any unsold phones from one day carry over to the next.\n    2. You can only restock at the beginning of each day.\n    3. The cost of overstocking is equal to the cost of a stockout.\n\n    Implement this using dynamic programming for efficiency.\n\n    Example:\n    Input: sales_data = [3, 5, 2, 7, 8, 2], days = 3\n    Output: [7, 8, 8]\n\n    Explanation: Based on the sales trend, the optimal stocking for the next 3 days would be 7, 8, and 8 phones.\n    \"\"\"\n", "entry_point": "optimize_inventory", "solution": "    n = len(sales_data)\n    window_size = min(n, 7)  # Use a sliding window of up to 7 days for prediction\n    \n    # Helper function to calculate the average sales for a given window\n    def get_average_sales(start, end):\n        return sum(sales_data[start:end]) // (end - start)\n    \n    # Initialize the optimal inventory list\n    optimal_inventory = []\n    \n    for i in range(days):\n        if i < n:\n            # If we have historical data for this day, use it\n            optimal_inventory.append(sales_data[i])\n        else:\n            # Calculate the average sales for the last window_size days\n            start = max(0, i - window_size)\n            end = i\n            avg_sales = get_average_sales(start, end)\n            \n            # Adjust the prediction based on recent trends\n            if len(optimal_inventory) >= 2:\n                trend = optimal_inventory[-1] - optimal_inventory[-2]\n                predicted_sales = avg_sales + trend\n            else:\n                predicted_sales = avg_sales\n            \n            # Ensure the predicted sales is non-negative\n            predicted_sales = max(0, predicted_sales)\n            \n            optimal_inventory.append(predicted_sales)\n    \n    return optimal_inventory\n\n", "test": "def check(candidate):\n    assert candidate([1, 10, 1, 10, 1], 4) == [1, 10, 1, 10]\n    assert candidate([7, 7, 7, 7, 7, 7, 7], 7) == [7, 7, 7, 7, 7, 7, 7]\n    assert candidate([100, 50, 25, 12, 6], 3) == [100, 50, 25]\n    assert candidate([1, 2, 4, 8, 16, 32], 5) == [1, 2, 4, 8, 16]\n    assert candidate([5, 4, 3, 2, 1], 6) == [5, 4, 3, 2, 1, 2]\n    assert candidate([1, 2, 3, 4, 5], 5) == [1, 2, 3, 4, 5]\n    assert candidate([10, 10, 10, 10, 10], 3) == [10, 10, 10]\n    assert candidate([0, 0, 0, 0, 0], 4) == [0, 0, 0, 0]\n    assert candidate([1, 1, 1, 1, 1], 1) == [1]\n    assert candidate([3, 5, 2, 7, 8, 2], 3) == [3, 5, 2]\n", "language": "python"}
{"task_id": "revision1a_problem506", "prompt": "from typing import List, Tuple\nimport math\n\ndef optimize_delivery_route(locations: List[Tuple[float, float]]) -> List[int]:\n    \"\"\"\n    You are a delivery driver for an e-commerce company. You need to deliver packages to multiple locations in a city.\n    Your task is to find the optimal route that minimizes the total distance traveled.\n\n    Given a list of (x, y) coordinates representing delivery locations, implement the nearest neighbor algorithm\n    to determine an efficient delivery route. Start from the first location (index 0) and always move to the nearest\n    unvisited location until all locations are visited.\n\n    Use list comprehensions and the sorted() function with a key parameter to implement this algorithm efficiently.\n\n    Example:\n    Input: [(0, 0), (1, 2), (3, 1), (2, 4)]\n    Output: [0, 2, 1, 3]\n\n    This output means the optimal route is: (0, 0) -> (3, 1) -> (1, 2) -> (2, 4)\n\n    Parameters:\n    locations (List[Tuple[float, float]]): A list of (x, y) coordinates representing delivery locations\n\n    Returns:\n    List[int]: A list of indices representing the optimal order to visit the locations\n    \"\"\"\n", "entry_point": "optimize_delivery_route", "solution": "    def distance(p1: Tuple[float, float], p2: Tuple[float, float]) -> float:\n        return ((p1[0] - p2[0]) ** 2 + (p1[1] - p2[1]) ** 2) ** 0.5\n\n    n = len(locations)\n    unvisited = set(range(1, n))  # Exclude the starting point (index 0)\n    route = [0]  # Start from the first location\n    current = 0\n\n    while unvisited:\n        current_location = locations[current]\n        next_location = min(unvisited, key=lambda x: distance(current_location, locations[x]))\n        route.append(next_location)\n        unvisited.remove(next_location)\n        current = next_location\n\n    return route\n", "test": "def check(candidate):\n    assert candidate([(0, 0), (1, 1), (2, 2), (3, 3), (4, 4)]) == [0, 1, 2, 3, 4]\n    assert candidate([(0, 0), (1, 2), (3, 1), (2, 4)]) == [0, 1, 2, 3]\n    assert candidate([(0, 0), (10, 10), (20, 20), (30, 30)]) == [0, 1, 2, 3]\n    assert candidate([(-1, -1), (1, 1), (2, -2), (-3, 3)]) == [0, 1, 2, 3]\n    assert candidate([(0, i) for i in range(5)]) == [0, 1, 2, 3, 4]\n    assert candidate([(0, 0)]) == [0]\n    assert candidate([(i, i) for i in range(10)]) == [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]\n    assert candidate([(1.5, 2.7), (3.2, 4.1), (0.8, 1.9), (5.6, 7.3)]) == [0, 2, 1, 3]\n    assert candidate([(1, 1), (1, 2), (1, 3), (1, 4), (1, 5)]) == [0, 1, 2, 3, 4]\n    assert candidate([(0, 0), (0, 1), (1, 0), (1, 1)]) == [0, 1, 3, 2]\n", "language": "python"}
{"task_id": "revision1a_problem423", "prompt": "from typing import List, Dict\nimport re\n\ndef analyze_text_sentiment(text: str) -> Dict[str, float]:\n    \"\"\"\n    As a data scientist working for a social media company, I need to analyze the sentiment of user posts.\n    Given a text input, calculate the sentiment scores for different emotions (joy, anger, sadness, fear, surprise).\n\n    Use regular expressions to identify emotion-related words and phrases, and implement a basic sentiment analysis\n    algorithm to calculate scores for each emotion category.\n\n    Take a string input from the user and return a dictionary with emotion categories as keys and sentiment scores as values.\n\n    Example:\n    Input: \"I'm so excited about my new job! It's a bit scary, but I can't wait to start.\"\n    Output: {\n        'joy': 0.6,\n        'anger': 0.0,\n        'sadness': 0.0,\n        'fear': 0.2,\n        'surprise': 0.4\n    }\n\n    Scores should be between 0 and 1, representing the intensity of each emotion in the text.\n    \"\"\"\n", "entry_point": "analyze_text_sentiment", "solution": "    \n    # Define emotion-related words and phrases for each category\n    emotion_words = {\n        'joy': ['happy', 'excited', 'glad', 'delighted', 'joyful', 'thrilled', \"can't wait\"],\n        'anger': ['angry', 'mad', 'furious', 'irritated', 'annoyed', 'frustrated'],\n        'sadness': ['sad', 'unhappy', 'depressed', 'miserable', 'gloomy', 'heartbroken'],\n        'fear': ['scared', 'afraid', 'frightened', 'terrified', 'anxious', 'worried'],\n        'surprise': ['surprised', 'shocked', 'amazed', 'astonished', 'unexpected']\n    }\n\n    # Initialize sentiment scores\n    sentiment_scores = {emotion: 0.0 for emotion in emotion_words.keys()}\n\n    # Function to calculate the score for each emotion\n    def calculate_emotion_score(emotion: str) -> float:\n        score = 0\n        for word in emotion_words[emotion]:\n            pattern = r'\\b' + re.escape(word) + r'\\b'\n            matches = re.findall(pattern, text.lower())\n            score += len(matches)\n        return min(score / 3, 1.0)  # Normalize score between 0 and 1\n\n    # Calculate scores for each emotion\n    for emotion in sentiment_scores.keys():\n        sentiment_scores[emotion] = calculate_emotion_score(emotion)\n\n    return sentiment_scores\n", "test": "def check(candidate):\n    assert candidate(\"I\\'m so excited about my new job! It\\'s a bit scary, but I can\\'t wait to start.\") == {'joy': 0.6666666666666666, 'anger': 0.0, 'sadness': 0.0, 'fear': 0.0, 'surprise': 0.0}\n    assert candidate(\"I\\'m feeling really sad and lonely today. Nothing seems to go right.\") == {'joy': 0.0, 'anger': 0.0, 'sadness': 0.3333333333333333, 'fear': 0.0, 'surprise': 0.0}\n    assert candidate(\"The sunset was breathtakingly beautiful. It filled me with awe and peace.\") == {'joy': 0.0, 'anger': 0.0, 'sadness': 0.0, 'fear': 0.0, 'surprise': 0.0}\n    assert candidate(\"I hate this weather. It\\'s making me so angry and frustrated!\") == {'joy': 0.0, 'anger': 0.6666666666666666, 'sadness': 0.0, 'fear': 0.0, 'surprise': 0.0}\n    assert candidate(\"Wow! I can\\'t believe I won the lottery! This is unbelievable!\") == {'joy': 0.0, 'anger': 0.0, 'sadness': 0.0, 'fear': 0.0, 'surprise': 0.0}\n    assert candidate(\"The news about the accident left me shocked and devastated.\") == {'joy': 0.0, 'anger': 0.0, 'sadness': 0.0, 'fear': 0.0, 'surprise': 0.3333333333333333}\n    assert candidate(\"I\\'m furious about the way they treated me. It\\'s completely unacceptable!\") == {'joy': 0.0, 'anger': 0.3333333333333333, 'sadness': 0.0, 'fear': 0.0, 'surprise': 0.0}\n    assert candidate(\"I\\'m so happy and grateful for my family and friends. They bring me so much joy.\") == {'joy': 0.3333333333333333, 'anger': 0.0, 'sadness': 0.0, 'fear': 0.0, 'surprise': 0.0}\n    assert candidate(\"The constant stress at work is making me anxious and fearful about my future.\") == {'joy': 0.0, 'anger': 0.0, 'sadness': 0.0, 'fear': 0.3333333333333333, 'surprise': 0.0}\n    assert candidate(\"The movie was surprisingly good. I enjoyed every moment of it.\") == {'joy': 0.0, 'anger': 0.0, 'sadness': 0.0, 'fear': 0.0, 'surprise': 0.0}\n", "language": "python"}
{"task_id": "revision1a_problem265", "prompt": "import heapq\nfrom typing import List, Tuple\n\ndef optimize_delivery_route(n: int, roads: List[Tuple[int, int, int]], start: int, end: int) -> Tuple[int, List[int]]:\n    \"\"\"\n    You are a logistics manager for a delivery company. You need to optimize the delivery route \n    between two cities in a network of n cities, numbered from 0 to n-1.\n\n    You are given:\n    - The number of cities (n)\n    - A list of roads, where each road is represented by a tuple (city1, city2, distance)\n    - The starting city number\n    - The destination city number\n\n    Your task is to find the shortest possible route from the start to the destination, \n    and return both the total distance and the sequence of cities to visit.\n\n    If there's no possible route, return (-1, []).\n\n    Use Dijkstra's algorithm to solve this problem efficiently.\n\n    Take input for the number of cities, list of roads, start city, and end city from the user,\n    and return the optimal route and distance.\n\n    Example:\n    Input: \n    5, [(0,1,10), (0,2,15), (1,2,2), (1,3,5), (2,3,3), (2,4,10), (3,4,6)], 0, 4\n\n    Output: \n    (21, [0, 1, 2, 4])\n    \"\"\"\n", "entry_point": "optimize_delivery_route", "solution": "    # Create an adjacency list to represent the graph\n    graph = {i: [] for i in range(n)}\n    for city1, city2, distance in roads:\n        graph[city1].append((city2, distance))\n        graph[city2].append((city1, distance))\n\n    # Initialize distances and previous nodes\n    distances = {i: float('inf') for i in range(n)}\n    distances[start] = 0\n    previous = {i: None for i in range(n)}\n\n    # Priority queue to store nodes to visit\n    pq = [(0, start)]\n\n    while pq:\n        current_distance, current_city = heapq.heappop(pq)\n\n        if current_city == end:\n            break\n\n        if current_distance > distances[current_city]:\n            continue\n\n        for neighbor, weight in graph[current_city]:\n            distance = current_distance + weight\n            if distance < distances[neighbor]:\n                distances[neighbor] = distance\n                previous[neighbor] = current_city\n                heapq.heappush(pq, (distance, neighbor))\n\n    # If there's no path to the end city\n    if distances[end] == float('inf'):\n        return (-1, [])\n\n    # Reconstruct the path\n    path = []\n    current = end\n    while current is not None:\n        path.append(current)\n        current = previous[current]\n    path.reverse()\n\n    return (distances[end], path)\n", "test": "def check(candidate):\n    assert candidate(6, [(0,1,5), (1,2,5), (2,3,5), (3,4,5), (4,5,5)], 0, 5) == (25, [0, 1, 2, 3, 4, 5])\n    assert candidate(4, [(0,1,1), (1,2,1), (2,3,1)], 0, 3) == (3, [0, 1, 2, 3])\n    assert candidate(4, [(0,1,1), (1,2,2), (2,3,3)], 3, 0) == (6, [3, 2, 1, 0])\n    assert candidate(5, [(0,1,10), (0,2,15), (1,2,2), (1,3,5), (2,3,3), (2,4,10), (3,4,6)], 0, 4) == (21, [0, 1, 3, 4])\n    assert candidate(2, [(0,1,100)], 0, 1) == (100, [0, 1])\n    assert candidate(5, [(0,1,1), (1,2,1), (2,3,1), (3,4,1), (0,4,10)], 0, 4) == (4, [0, 1, 2, 3, 4])\n    assert candidate(4, [(0,1,1), (1,2,1), (2,3,1), (0,3,5)], 0, 3) == (3, [0, 1, 2, 3])\n    assert candidate(3, [(0,1,10), (1,2,10)], 0, 2) == (20, [0, 1, 2])\n    assert candidate(3, [(0,1,1), (1,2,1), (0,2,3)], 0, 2) == (2, [0, 1, 2])\n    assert candidate(3, [(0,1,5), (1,2,3)], 0, 2) == (8, [0, 1, 2])\n", "language": "python"}
{"task_id": "revision1a_problem179", "prompt": "def encrypt_message(message: str, shift: int) -> str:\n    \"\"\"\n    Implement a Caesar cipher encryption algorithm.\n    The Caesar cipher is a simple encryption technique where each letter in the plaintext\n    is shifted a certain number of places down the alphabet.\n\n    Rules:\n    1. The function takes two inputs: the message to encrypt and the shift value.\n    2. Shift all alphabetic characters (both uppercase and lowercase) by the specified amount.\n    3. Non-alphabetic characters should remain unchanged.\n    4. The alphabet should wrap around (e.g., 'Z' shifted by 1 becomes 'A').\n    5. The shift value can be positive (shift right) or negative (shift left).\n\n    Take the message and shift value as input from the user and return the encrypted message.\n\n    Example 1:\n    Input: message = \"Hello, World!\", shift = 3\n    Output: \"Khoor, Zruog!\"\n\n    Example 2:\n    Input: message = \"Caesar Cipher\", shift = -1\n    Output: \"Bzdrzq Bhogdq\"\n    \"\"\"\n", "entry_point": "encrypt_message", "solution": "    encrypted_message = \"\"\n    for char in message:\n        if char.isalpha():\n            ascii_offset = ord('A') if char.isupper() else ord('a')\n            shifted_char = chr((ord(char) - ascii_offset + shift) % 26 + ascii_offset)\n            encrypted_message += shifted_char\n        else:\n            encrypted_message += char\n    return encrypted_message\n", "test": "def check(candidate):\n    assert candidate(\"Caesar Cipher\", -1) == 'Bzdrzq Bhogdq'\n    assert candidate(\"\", 5) == ''\n    assert candidate(\"Mixed 123 Characters ?!\", 5) == 'Rncji 123 Hmfwfhyjwx ?!'\n    assert candidate(\"Python is awesome!\", 13) == 'Clguba vf njrfbzr!'\n    assert candidate(\"ZzAa\", 26) == 'ZzAa'\n    assert candidate(\"abcdefghijklmnopqrstuvwxyz\", -1) == 'zabcdefghijklmnopqrstuvwxy'\n    assert candidate(\"ABCDEFGHIJKLMNOPQRSTUVWXYZ\", 1) == 'BCDEFGHIJKLMNOPQRSTUVWXYZA'\n    assert candidate(\"!@#$%^&*()\", 7) == '!@#$%^&*()'\n    assert candidate(\"12345\", 2) == '12345'\n    assert candidate(\"Hello, World!\", 3) == 'Khoor, Zruog!'\n", "language": "python"}
{"task_id": "revision1a_problem255", "prompt": "import itertools\nfrom typing import List\n\ndef optimize_delivery_route(locations: int, distances: List[List[int]]) -> List[int]:\n    \"\"\"\n    A delivery company needs to optimize its route for delivering packages in a city.\n    The city has multiple locations, including the company's warehouse and customer addresses.\n    The goal is to find the shortest path that visits all locations exactly once and returns to the starting point.\n\n    Points to be noted:\n    1. The first location (index 0) is always the warehouse.\n    2. There may be one-way streets, so the distance from A to B might not be the same as B to A.\n    3. If there's no direct route between two locations, the distance is represented as float('inf').\n\n    Take input from the user in the form of a matrix, where each row represents the distances from one location to all others.\n    Return the optimal route as a list of location indices, starting and ending with 0 (the warehouse).\n\n    Use the concept of the Traveling Salesman Problem and implement a solution using dynamic programming.\n\n    Example:\n    Input: 4, [\n        [0, 10, 15, 20],\n        [10, 0, 35, 25],\n        [15, 35, 0, 30],\n        [20, 25, 30, 0]\n    ]\n    Output: [0, 1, 3, 2, 0]\n    \"\"\"\n", "entry_point": "optimize_delivery_route", "solution": "    def tsp_dp(mask, pos):\n        if mask == all_visited:\n            return distances[pos][0], [0]\n        \n        if (mask, pos) in memo:\n            return memo[(mask, pos)]\n        \n        min_cost = float('inf')\n        best_path = []\n        \n        for next_pos in range(1, locations):\n            if (mask & (1 << next_pos)) == 0:\n                new_mask = mask | (1 << next_pos)\n                cost, path = tsp_dp(new_mask, next_pos)\n                total_cost = distances[pos][next_pos] + cost\n                \n                if total_cost < min_cost:\n                    min_cost = total_cost\n                    best_path = [next_pos] + path\n        \n        memo[(mask, pos)] = (min_cost, best_path)\n        return min_cost, best_path\n\n    all_visited = (1 << locations) - 1\n    memo = {}\n    \n    _, optimal_path = tsp_dp(1, 0)\n    return [0] + optimal_path\n\n", "test": "def check(candidate):\n    assert candidate(5, [[0, 10, 20, 30, 40], [40, 0, 10, 20, 30], [30, 40, 0, 10, 20], [20, 30, 40, 0, 10], [10, 20, 30, 40, 0]]) == [0, 1, 2, 3, 4, 0]\n    assert candidate(4, [[0, float('inf'), float('inf'), float('inf')], [float('inf'), 0, 1, 1], [float('inf'), 1, 0, 1], [float('inf'), 1, 1, 0]]) == [0]\n    assert candidate(2, [[0, 1], [1, 0]]) == [0, 1, 0]\n    assert candidate(6, [[0, 10, 15, 20, 25, 30], [10, 0, 35, 25, 30, 35], [15, 35, 0, 30, 35, 40], [20, 25, 30, 0, 35, 40], [25, 30, 35, 35, 0, 45], [30, 35, 40, 40, 45, 0]]) == [0, 1, 3, 4, 5, 2, 0]\n    assert candidate(3, [[0, 1, 2], [2, 0, 1], [1, 2, 0]]) == [0, 1, 2, 0]\n    assert candidate(5, [[0, 1, 2, 3, 4], [1, 0, 5, 6, 7], [2, 5, 0, 8, 9], [3, 6, 8, 0, 10], [4, 7, 9, 10, 0]]) == [0, 2, 1, 3, 4, 0]\n    assert candidate(4, [[0, 10, 15, 20], [10, 0, 35, 25], [15, 35, 0, 30], [20, 25, 30, 0]]) == [0, 1, 3, 2, 0]\n    assert candidate(3, [[0, 5, 10], [5, 0, 15], [10, 15, 0]]) == [0, 1, 2, 0]\n    assert candidate(3, [[0, float('inf'), 5], [float('inf'), 0, 10], [5, 10, 0]]) == [0]\n", "language": "python"}
{"task_id": "revision1a_problem725", "prompt": "from typing import List, Tuple\n\ndef design_network(nodes: int, connections: List[Tuple[int, int, int]]) -> List[Tuple[int, int, int]]:\n    \"\"\"\n    As a network engineer, I need to design a computer network that connects all nodes with minimum cost. \n    Given a number of nodes and a list of possible connections with their costs, I need to find the minimum spanning tree of the network.\n    \n    Take input from the user for the number of nodes and the list of possible connections (each connection is a tuple of two node IDs and the cost).\n    Return the list of connections that form the minimum spanning tree.\n    Use Kruskal's algorithm with a disjoint set data structure to solve this problem.\n\n    Example:\n    Input: 4, [(0,1,10), (0,2,6), (0,3,5), (1,3,15), (2,3,4)]\n    Output: [(2,3,4), (0,3,5), (0,1,10)]\n    \"\"\"\n", "entry_point": "design_network", "solution": "    \n    # Disjoint Set data structure\n    class DisjointSet:\n        def __init__(self, n):\n            self.parent = list(range(n))\n            self.rank = [0] * n\n        \n        def find(self, item):\n            if self.parent[item] != item:\n                self.parent[item] = self.find(self.parent[item])\n            return self.parent[item]\n        \n        def union(self, x, y):\n            xroot = self.find(x)\n            yroot = self.find(y)\n            if self.rank[xroot] < self.rank[yroot]:\n                self.parent[xroot] = yroot\n            elif self.rank[xroot] > self.rank[yroot]:\n                self.parent[yroot] = xroot\n            else:\n                self.parent[yroot] = xroot\n                self.rank[xroot] += 1\n\n    # Sort connections by cost\n    connections.sort(key=lambda x: x[2])\n    \n    # Initialize disjoint set\n    ds = DisjointSet(nodes)\n    \n    # Initialize result list\n    mst = []\n    \n    # Kruskal's algorithm\n    for connection in connections:\n        node1, node2, cost = connection\n        if ds.find(node1) != ds.find(node2):\n            ds.union(node1, node2)\n            mst.append(connection)\n        \n        # Stop when we have n-1 edges in the MST\n        if len(mst) == nodes - 1:\n            break\n    \n    return mst\n", "test": "def check(candidate):\n    assert candidate(5, [(0,1,10), (0,2,20), (0,3,30), (0,4,40), (1,2,50), (1,3,60), (1,4,70), (2,3,80), (2,4,90), (3,4,100)]) == [(0, 1, 10), (0, 2, 20), (0, 3, 30), (0, 4, 40)]\n    assert candidate(2, [(0,1,100)]) == [(0, 1, 100)]\n    assert candidate(7, [(0,1,7), (0,3,5), (1,2,8), (1,3,9), (1,4,7), (2,4,5), (3,4,15), (3,5,6), (4,5,8), (4,6,9), (5,6,11)]) == [(0, 3, 5), (2, 4, 5), (3, 5, 6), (0, 1, 7), (1, 4, 7), (4, 6, 9)]\n    assert candidate(6, [(i,j,abs(i-j)) for i in range(6) for j in range(i+1,6)]) == [(0, 1, 1), (1, 2, 1), (2, 3, 1), (3, 4, 1), (4, 5, 1)]\n    assert candidate(5, [(0,1,2), (0,3,6), (1,2,3), (1,3,8), (1,4,5), (2,4,7), (3,4,9)]) == [(0, 1, 2), (1, 2, 3), (1, 4, 5), (0, 3, 6)]\n    assert candidate(3, [(0,1,1), (1,2,1), (0,2,2)]) == [(0, 1, 1), (1, 2, 1)]\n    assert candidate(3, [(0,1,1), (1,2,2), (0,2,3)]) == [(0, 1, 1), (1, 2, 2)]\n    assert candidate(4, [(0,1,1), (0,2,1), (0,3,1), (1,2,1), (1,3,1), (2,3,1)]) == [(0, 1, 1), (0, 2, 1), (0, 3, 1)]\n    assert candidate(4, [(0,1,10), (0,2,6), (0,3,5), (1,3,15), (2,3,4)]) == [(2, 3, 4), (0, 3, 5), (0, 1, 10)]\n    assert candidate(6, [(0,1,1), (0,2,2), (1,2,3), (1,3,4), (2,3,5), (2,4,6), (3,4,7), (3,5,8), (4,5,9)]) == [(0, 1, 1), (0, 2, 2), (1, 3, 4), (2, 4, 6), (3, 5, 8)]\n", "language": "python"}
{"task_id": "revision1a_problem251", "prompt": "from typing import List, Tuple\nimport math\n\ndef optimize_delivery_route(locations: List[Tuple[float, float]]) -> List[int]:\n    \"\"\"\n    As a logistics manager for a food delivery company, I need to optimize our delivery routes to minimize travel time and fuel costs.\n    Given a list of customer locations as (latitude, longitude) tuples, determine the most efficient order to visit all locations.\n\n    Use the traveling salesman problem (TSP) algorithm to find the optimal route. Implement a nearest neighbor heuristic\n    for a quick approximation of the solution.\n\n    Take input from the user for the list of location coordinates and return the optimized route as a list of indices.\n\n    Example:\n    Input: [(40.7128, -74.0060), (34.0522, -118.2437), (41.8781, -87.6298), (29.7604, -95.3698)]\n    Output: [0, 2, 1, 3]\n\n    This output indicates the order in which to visit the locations: New York, Chicago, Los Angeles, Houston.\n    \"\"\"\n", "entry_point": "optimize_delivery_route", "solution": "    def calculate_distance(loc1: Tuple[float, float], loc2: Tuple[float, float]) -> float:\n        \"\"\"Calculate the Euclidean distance between two locations.\"\"\"\n        return math.sqrt((loc1[0] - loc2[0])**2 + (loc1[1] - loc2[1])**2)\n\n    n = len(locations)\n    unvisited = set(range(n))\n    route = []\n    current = 0  # Start with the first location\n\n    while unvisited:\n        route.append(current)\n        unvisited.remove(current)\n        \n        if not unvisited:\n            break\n\n        # Find the nearest unvisited location\n        nearest = min(unvisited, key=lambda x: calculate_distance(locations[current], locations[x]))\n        current = nearest\n\n    return route\n", "test": "def check(candidate):\n    assert candidate([]) == []\n    assert candidate([(0, 0), (1, 1), (2, 2), (3, 3), (4, 4)]) == [0, 1, 2, 3, 4]\n    assert candidate([(x, x) for x in range(10)]) == [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]\n    assert candidate([(40.7128, -74.0060), (34.0522, -118.2437), (41.8781, -87.6298), (29.7604, -95.3698)]) == [0, 2, 3, 1]\n    assert candidate([(0, 0)] * 5) == [0, 1, 2, 3, 4]\n    assert candidate([(40.7128, -74.0060)]) == [0]\n    assert candidate([(51.5074, -0.1278), (48.8566, 2.3522), (52.5200, 13.4050), (41.9028, 12.4964)]) == [0, 1, 2, 3]\n    assert candidate([(math.cos(x), math.sin(x)) for x in range(0, 360, 36)]) == [0, 4, 8, 1, 5, 9, 2, 6, 3, 7]\n    assert candidate([(90, 0), (-90, 0), (0, 180), (0, -180)]) == [0, 1, 2, 3]\n    assert candidate([(0, 0), (0, 1), (1, 0), (1, 1)]) == [0, 1, 3, 2]\n", "language": "python"}
{"task_id": "revision1a_problem324", "prompt": "from typing import List, Dict, Any\n\ndef stock_portfolio(transactions: List[Dict[str, Any]]) -> float:\n    \"\"\"\n    As a financial advisor, I need to help my client manage their stock portfolio.\n    Create a function that processes a list of stock transactions and calculates the current value of the portfolio.\n    Each transaction is a dictionary containing the following keys:\n    1. 'type': either 'buy' or 'sell'\n    2. 'stock': the stock symbol (e.g., 'AAPL' for Apple)\n    3. 'quantity': number of shares\n    4. 'price': price per share at the time of transaction\n\n    The function should:\n    1. Keep track of the stocks owned and their quantities\n    2. Calculate the total value of the portfolio based on the most recent price for each stock\n    3. Handle edge cases like selling more stocks than owned (ignore such transactions)\n\n    Return the total value of the portfolio rounded to 2 decimal places.\n\n    Example:\n    Input: [\n        {'type': 'buy', 'stock': 'AAPL', 'quantity': 10, 'price': 150.0},\n        {'type': 'buy', 'stock': 'GOOGL', 'quantity': 5, 'price': 2000.0},\n        {'type': 'sell', 'stock': 'AAPL', 'quantity': 5, 'price': 160.0},\n        {'type': 'buy', 'stock': 'AAPL', 'quantity': 2, 'price': 165.0}\n    ]\n    Output: 11575.00\n    \"\"\"\n", "entry_point": "stock_portfolio", "solution": "    portfolio = {}\n    latest_prices = {}\n\n    for transaction in transactions:\n        stock = transaction['stock']\n        quantity = transaction['quantity']\n        price = transaction['price']\n        \n        # Update the latest price for the stock\n        latest_prices[stock] = price\n        \n        if transaction['type'] == 'buy':\n            if stock in portfolio:\n                portfolio[stock] += quantity\n            else:\n                portfolio[stock] = quantity\n        elif transaction['type'] == 'sell':\n            if stock in portfolio and portfolio[stock] >= quantity:\n                portfolio[stock] -= quantity\n            else:\n                # Ignore the transaction if trying to sell more stocks than owned\n                continue\n    \n    # Calculate the total value of the portfolio\n    total_value = sum(portfolio[stock] * latest_prices[stock] for stock in portfolio)\n    \n    # Round the total value to 2 decimal places\n    return round(total_value, 2)\n", "test": "def check(candidate):\n    assert candidate([{'type': 'buy', 'stock': 'MSFT', 'quantity': 20, 'price': 300.0}, {'type': 'sell', 'stock': 'MSFT', 'quantity': 25, 'price': 310.0}]) == 6200.0\n    assert candidate([{'type': 'buy', 'stock': 'NFLX', 'quantity': 40, 'price': 400.0}, {'type': 'sell', 'stock': 'NFLX', 'quantity': 40, 'price': 450.0}, {'type': 'buy', 'stock': 'NFLX', 'quantity': 20, 'price': 500.0}]) == 10000.0\n    assert candidate([{'type': 'sell', 'stock': 'TSLA', 'quantity': 10, 'price': 700.0}]) == 0\n    assert candidate([{'type': 'buy', 'stock': 'AAPL', 'quantity': 10, 'price': 150.0}, {'type': 'buy', 'stock': 'GOOGL', 'quantity': 5, 'price': 2000.0}, {'type': 'sell', 'stock': 'AAPL', 'quantity': 5, 'price': 160.0}, {'type': 'buy', 'stock': 'AAPL', 'quantity': 2, 'price': 165.0}]) == 11155.0\n    assert candidate([{'type': 'buy', 'stock': 'GOOGL', 'quantity': 1, 'price': 2000.0}]) == 2000.0\n    assert candidate([]) == 0\n    assert candidate([{'type': 'buy', 'stock': 'FB', 'quantity': 30, 'price': 250.0}, {'type': 'sell', 'stock': 'FB', 'quantity': 15, 'price': 280.0}, {'type': 'buy', 'stock': 'FB', 'quantity': 10, 'price': 300.0}]) == 7500.0\n    assert candidate([{'type': 'buy', 'stock': 'AAPL', 'quantity': 10, 'price': 150.0}, {'type': 'buy', 'stock': 'AAPL', 'quantity': 5, 'price': 160.0}, {'type': 'sell', 'stock': 'AAPL', 'quantity': 15, 'price': 170.0}]) == 0.0\n    assert candidate([{'type': 'buy', 'stock': 'AMZN', 'quantity': 50, 'price': 100.0}, {'type': 'sell', 'stock': 'AMZN', 'quantity': 50, 'price': 120.0}]) == 0.0\n", "language": "python"}
{"task_id": "revision1a_problem207", "prompt": "import random\nfrom typing import List, Tuple\n\ndef network_resilience(nodes: int, connections: List[Tuple[int, int, int]], attacks: int) -> float:\n    \"\"\"\n    You are a network engineer tasked with analyzing the resilience of a computer network against cyber attacks.\n    The network consists of nodes (computers) connected by links with varying levels of security.\n\n    Write a function that takes three parameters:\n    1. An integer representing the number of nodes in the network\n    2. A list of tuples representing the connections between nodes, where each tuple contains:\n       (node1, node2, security_level)\n    3. An integer representing the number of simulated attacks to perform\n\n    The function should return a float representing the network's resilience score, calculated as follows:\n    - For each simulated attack, randomly \"disable\" the weakest available connection\n    - After each attack, calculate the percentage of nodes that can still communicate with each other\n    - The resilience score is the average of these percentages across all simulated attacks\n\n    Example:\n    Input:\n    nodes = 5\n    connections = [(0, 1, 3), (1, 2, 2), (2, 3, 1), (3, 4, 4), (4, 0, 5), (1, 3, 3)]\n    attacks = 3\n    Output: 0.8667\n\n    Explanation: After 3 attacks, on average 86.67% of the network remains connected.\n    \"\"\"\n", "entry_point": "network_resilience", "solution": "    def find_connected_nodes(graph, start, visited=None):\n        if visited is None:\n            visited = set()\n        visited.add(start)\n        for neighbor in graph[start]:\n            if neighbor not in visited:\n                find_connected_nodes(graph, neighbor, visited)\n        return visited\n\n    def calculate_connectivity(graph, total_nodes):\n        connected = len(find_connected_nodes(graph, 0))\n        return connected / total_nodes\n\n    # Create an adjacency list representation of the network\n    network = {i: set() for i in range(nodes)}\n    for node1, node2, _ in connections:\n        network[node1].add(node2)\n        network[node2].add(node1)\n\n    # Sort connections by security level (weakest first)\n    sorted_connections = sorted(connections, key=lambda x: x[2])\n\n    resilience_scores = []\n    for _ in range(attacks):\n        if not sorted_connections:\n            break\n\n        # Remove the weakest connection\n        node1, node2, _ = sorted_connections.pop(0)\n        network[node1].remove(node2)\n        network[node2].remove(node1)\n\n        # Calculate and store the connectivity percentage\n        resilience_scores.append(calculate_connectivity(network, nodes))\n\n    # Calculate and return the average resilience score\n    return sum(resilience_scores) / len(resilience_scores) if resilience_scores else 1.0\n", "test": "def check(candidate):\n    assert candidate(5, [(0, 1, 1), (1, 2, 1), (2, 3, 1), (3, 4, 1), (4, 0, 1)], 4) == 0.7\n    assert candidate(10, [(i, j, random.randint(1, 10)) for i in range(10) for j in range(i+1, 10)], 15) == 1.0\n    assert candidate(5, [(0, 1, 3), (1, 2, 2), (2, 3, 1), (3, 4, 4), (4, 0, 5), (1, 3, 3)], 3) == 0.8666666666666667\n    assert candidate(4, [(0, 1, 1), (1, 2, 2), (2, 3, 3), (3, 0, 4)], 2) == 0.875\n    assert candidate(3, [(0, 1, 1), (1, 2, 1)], 1) == 0.3333333333333333\n    assert candidate(3, [(0, 1, 100), (1, 2, 100), (2, 0, 100)], 2) == 0.8333333333333333\n    assert candidate(2, [(0, 1, 10)], 1) == 0.5\n    assert candidate(6, [(0, 1, 5), (1, 2, 4), (2, 3, 3), (3, 4, 2), (4, 5, 1), (5, 0, 6)], 4) == 0.75\n    assert candidate(7, [(i, (i+1)%7, i+1) for i in range(7)], 5) == 0.7142857142857143\n    assert candidate(8, [(i, (i+1)%8, 1) for i in range(8)] + [(i, (i+2)%8, 2) for i in range(8)], 10) == 0.85\n", "language": "python"}
{"task_id": "revision1a_problem33", "prompt": "from typing import List, Tuple\n\ndef celebrity_problem(n: int, knows: List[List[bool]]) -> int:\n    \"\"\"\n    In a party of N people, find the 'Celebrity'.\n    A celebrity is a person who:\n    1. Knows nobody\n    2. Everybody knows him/her\n\n    You are given a helper function 'knows(a, b)' which returns True if 'a' knows 'b', else returns False.\n    Your task is to find the celebrity in the party in O(N) time complexity.\n    If there is no celebrity, return -1.\n\n    Take the number of people and a 2D boolean array representing the 'knows' relationship as input from the user.\n    Return the index of the celebrity (0-indexed) or -1 if there's no celebrity.\n\n    This problem simulates finding an influencer in a social network where everyone follows the influencer, \n    but the influencer follows no one.\n\n    Example:\n    Input: 4, [[False, False, True, False], [False, False, True, False], [False, False, False, False], [False, False, True, False]]\n    Output: 2 (Person 2 is the celebrity)\n    Input: 3, [[False, True, False], [False, False, False], [True, True, False]]\n    Output: -1 (No celebrity exists)\n    \"\"\"\n", "entry_point": "celebrity_problem", "solution": "    def knows(a: int, b: int) -> bool:\n        return knows[a][b]\n\n    # Find a potential celebrity\n    potential_celebrity = 0\n    for i in range(1, n):\n        if knows(potential_celebrity, i):\n            potential_celebrity = i\n\n    # Verify if the potential celebrity is actually a celebrity\n    for i in range(n):\n        if i != potential_celebrity:\n            if knows(potential_celebrity, i) or not knows(i, potential_celebrity):\n                return -1\n\n    return potential_celebrity\n", "test": "def check(candidate):\n    assert candidate(1, [[False]]) == 0\n    assert candidate(1, [[True]]) == 0\n", "language": "python"}
{"task_id": "revision1a_problem460", "prompt": "from typing import List, Dict\n\ndef optimize_delivery_route(addresses: List[str], distances: Dict[str, Dict[str, int]]) -> List[str]:\n    \"\"\"\n    A delivery company wants to optimize their route to minimize fuel consumption.\n    Given a list of delivery addresses and a dictionary of distances between each pair of addresses,\n    determine the most efficient route that visits all addresses exactly once and returns to the starting point.\n\n    This is a variation of the Traveling Salesman Problem (TSP) and requires implementing a heuristic algorithm.\n\n    Parameters:\n    addresses (List[str]): List of delivery addresses\n    distances (Dict[str, Dict[str, int]]): Nested dictionary where distances[a][b] gives the distance from address a to b\n\n    Returns:\n    List[str]: The optimized route as a list of addresses\n\n    Example:\n    Input:\n    addresses = [\"A\", \"B\", \"C\", \"D\"]\n    distances = {\n        \"A\": {\"B\": 10, \"C\": 15, \"D\": 20},\n        \"B\": {\"A\": 10, \"C\": 35, \"D\": 25},\n        \"C\": {\"A\": 15, \"B\": 35, \"D\": 30},\n        \"D\": {\"A\": 20, \"B\": 25, \"C\": 30}\n    }\n    Output: [\"A\", \"B\", \"D\", \"C\", \"A\"]\n    \"\"\"\n", "entry_point": "optimize_delivery_route", "solution": "    def nearest_neighbor(current: str, unvisited: List[str]) -> str:\n        return min(unvisited, key=lambda x: distances[current][x])\n\n    route = [addresses[0]]  # Start with the first address\n    unvisited = addresses[1:]\n\n    while unvisited:\n        current = route[-1]\n        next_address = nearest_neighbor(current, unvisited)\n        route.append(next_address)\n        unvisited.remove(next_address)\n\n    route.append(addresses[0])  # Return to the starting point\n    return route\n", "test": "def check(candidate):\n    assert candidate([\"A\", \"B\", \"C\", \"D\", \"E\"], {\"A\": {\"B\": 1, \"C\": 2, \"D\": 3, \"E\": 4}, \"B\": {\"A\": 1, \"C\": 5, \"D\": 6, \"E\": 7}, \"C\": {\"A\": 2, \"B\": 5, \"D\": 8, \"E\": 9}, \"D\": {\"A\": 3, \"B\": 6, \"C\": 8, \"E\": 10}, \"E\": {\"A\": 4, \"B\": 7, \"C\": 9, \"D\": 10}}) == ['A', 'B', 'C', 'D', 'E', 'A']\n    assert candidate([\"P\", \"Q\", \"R\", \"S\", \"T\"], {\"P\": {\"Q\": 10, \"R\": 15, \"S\": 20, \"T\": 25}, \"Q\": {\"P\": 10, \"R\": 30, \"S\": 35, \"T\": 40}, \"R\": {\"P\": 15, \"Q\": 30, \"S\": 45, \"T\": 50}, \"S\": {\"P\": 20, \"Q\": 35, \"R\": 45, \"T\": 55}, \"T\": {\"P\": 25, \"Q\": 40, \"R\": 50, \"S\": 55}}) == ['P', 'Q', 'R', 'S', 'T', 'P']\n    assert candidate([\"A\"], {\"A\": {}}) == ['A', 'A']\n    assert candidate([\"A\", \"B\", \"C\"], {\"A\": {\"B\": 10, \"C\": 15}, \"B\": {\"A\": 10, \"C\": 20}, \"C\": {\"A\": 15, \"B\": 20}}) == ['A', 'B', 'C', 'A']\n    assert candidate([\"A\", \"B\", \"C\", \"D\", \"E\", \"F\"], {\"A\": {\"B\": 10, \"C\": 15, \"D\": 20, \"E\": 25, \"F\": 30}, \"B\": {\"A\": 10, \"C\": 35, \"D\": 40, \"E\": 45, \"F\": 50}, \"C\": {\"A\": 15, \"B\": 35, \"D\": 55, \"E\": 60, \"F\": 65}, \"D\": {\"A\": 20, \"B\": 40, \"C\": 55, \"E\": 70, \"F\": 75}, \"E\": {\"A\": 25, \"B\": 45, \"C\": 60, \"D\": 70, \"F\": 80}, \"F\": {\"A\": 30, \"B\": 50, \"C\": 65, \"D\": 75, \"E\": 80}}) == ['A', 'B', 'C', 'D', 'E', 'F', 'A']\n    assert candidate([\"X\", \"Y\", \"Z\"], {\"X\": {\"Y\": 1, \"Z\": 1}, \"Y\": {\"X\": 1, \"Z\": 1}, \"Z\": {\"X\": 1, \"Y\": 1}}) == ['X', 'Y', 'Z', 'X']\n    assert candidate([\"A\", \"B\", \"C\", \"D\"], {\"A\": {\"B\": 10, \"C\": 15, \"D\": 20}, \"B\": {\"A\": 10, \"C\": 35, \"D\": 25}, \"C\": {\"A\": 15, \"B\": 35, \"D\": 30}, \"D\": {\"A\": 20, \"B\": 25, \"C\": 30}}) == ['A', 'B', 'D', 'C', 'A']\n    assert candidate([\"1\", \"2\", \"3\", \"4\"], {\"1\": {\"2\": 100, \"3\": 200, \"4\": 300}, \"2\": {\"1\": 100, \"3\": 400, \"4\": 500}, \"3\": {\"1\": 200, \"2\": 400, \"4\": 600}, \"4\": {\"1\": 300, \"2\": 500, \"3\": 600}}) == ['1', '2', '3', '4', '1']\n    assert candidate([\"X\", \"Y\"], {\"X\": {\"Y\": 5}, \"Y\": {\"X\": 5}}) == ['X', 'Y', 'X']\n", "language": "python"}
{"task_id": "revision1a_problem345", "prompt": "from typing import List\n\ndef encrypt_message(message: str, key: List[int]) -> str:\n    \"\"\"\n    In a secret spy organization, agents need to encrypt their messages before sending them.\n    The encryption method uses a key (a list of integers) to shift each character in the message.\n    Each character is shifted by the corresponding number in the key, cycling through the key if necessary.\n    Spaces and punctuation should remain unchanged.\n    If a shift moves a letter beyond 'z', it wraps around to 'a'.\n    Take a message and a key as input, and return the encrypted message.\n    \n    Example 1:\n    Input: \"hello world\", [3, 1, 4]\n    Output: \"khpor zruog\"\n    \n    Example 2:\n    Input: \"top secret\", [5, 2, 7, 1]\n    Output: \"yvu xlhxly\"\n    \"\"\"\n", "entry_point": "encrypt_message", "solution": "    def shift_char(char: str, shift: int) -> str:\n        if not char.isalpha():\n            return char\n        \n        base = ord('a')\n        return chr((ord(char) - base + shift) % 26 + base)\n\n    encrypted = []\n    key_length = len(key)\n    key_index = 0\n\n    for char in message:\n        if char.isalpha():\n            encrypted_char = shift_char(char.lower(), key[key_index])\n            key_index = (key_index + 1) % key_length\n        else:\n            encrypted_char = char\n        encrypted.append(encrypted_char)\n\n    return ''.join(encrypted)\n", "test": "def check(candidate):\n    assert candidate(\"z\", [1]) == 'a'\n    assert candidate(\"UPPERCASE\", [1, 2, 3]) == 'vrsftfbuh'\n    assert candidate(\"!@#$%^&*()\", [1, 2, 3]) == '!@#$%^&*()'\n    assert candidate(\"\", [1, 2, 3]) == ''\n    assert candidate(\"mixed CASE\", [4, 2]) == 'qkbgh eeui'\n    assert candidate(\"1234567890\", [5, 5, 5]) == '1234567890'\n    assert candidate(\"hello world\", [3, 1, 4]) == 'kfpop arspg'\n    assert candidate(\"top secret\", [5, 2, 7, 1]) == 'yqw tjeyfy'\n    assert candidate(\"a\", [1]) == 'b'\n    assert candidate(\"abcdefghijklmnopqrstuvwxyz\", [1]) == 'bcdefghijklmnopqrstuvwxyza'\n", "language": "python"}
{"task_id": "revision1a_problem293", "prompt": "from typing import List, Tuple\n\ndef optimalDeliveryRoute(locations: List[Tuple[int, int]], fuel: int) -> int:\n    \"\"\"\n    You're a delivery driver for an eco-friendly courier service. Your task is to determine the maximum \n    number of packages you can deliver given your current fuel level.\n\n    You start at the origin (0, 0) and need to return there after all deliveries.\n    Each location is represented by a tuple of (x, y) coordinates.\n    Moving one unit (horizontally or vertically) consumes one unit of fuel.\n    You must visit the locations in the order they appear in the list.\n\n    Take a list of delivery locations and the amount of available fuel as input.\n    Return the maximum number of deliveries you can make before running out of fuel.\n\n    Example:\n    Input: [(1, 1), (-1, -1), (2, 2), (3, 3)], 15\n    Output: 3\n\n    Explanation:\n    Route: (0,0) -> (1,1) -> (0,0) -> (-1,-1) -> (0,0) -> (2,2) -> (0,0)\n    Total distance: 2 + 2 + 2 + 2 + 4 + 4 = 16\n    You can make 3 deliveries before running out of fuel.\n    \"\"\"\n", "entry_point": "optimalDeliveryRoute", "solution": "    def manhattan_distance(x1, y1, x2, y2):\n        return abs(x1 - x2) + abs(y1 - y2)\n\n    current_x, current_y = 0, 0\n    deliveries = 0\n    fuel_used = 0\n\n    for x, y in locations:\n        # Calculate fuel needed for round trip\n        fuel_needed = manhattan_distance(current_x, current_y, x, y) * 2\n\n        # If we have enough fuel, make the delivery\n        if fuel_used + fuel_needed <= fuel:\n            fuel_used += fuel_needed\n            deliveries += 1\n            current_x, current_y = x, y\n        else:\n            break\n\n    return deliveries\n", "test": "def check(candidate):\n    assert candidate([(5, 5), (-5, -5)], 40) == 1\n    assert candidate([(0, 1), (0, 2), (0, 3)], 5) == 2\n    assert candidate([(1, 1), (-1, -1), (2, 2), (3, 3)], 15) == 2\n    assert candidate([(0, 1), (0, 2), (0, 3), (0, 4)], 10) == 4\n    assert candidate([(0, 0), (1, 1), (2, 2), (3, 3)], 20) == 4\n    assert candidate([(10, 10)], 30) == 0\n    assert candidate([(1, 0), (2, 0), (3, 0), (4, 0)], 12) == 4\n    assert candidate([(1, 1), (-1, 1), (1, -1), (-1, -1)], 16) == 3\n    assert candidate([], 100) == 0\n    assert candidate([(1, 1), (1, 1), (1, 1), (1, 1)], 8) == 4\n", "language": "python"}
{"task_id": "revision1a_problem370", "prompt": "from typing import List, Tuple, Dict, Any\nfrom collections import defaultdict\n\ndef social_network_analysis(connections: List[Tuple[str, str]]) -> Dict[str, Any]:\n    \"\"\"\n    Analyze a social network based on a list of connections between individuals.\n\n    The function should:\n    1. Take a list of tuples representing connections between people\n    2. Create a graph representation of the social network\n    3. Calculate and return the following metrics:\n       - Total number of people in the network\n       - Average number of connections per person\n       - Most connected person(s) and their number of connections\n       - Number of distinct communities (groups of connected individuals)\n       - Largest community size\n\n    Example:\n    Input: [(\"Alice\", \"Bob\"), (\"Bob\", \"Charlie\"), (\"David\", \"Eve\"), (\"Eve\", \"Frank\"), (\"George\", \"Harry\")]\n    Output: {\n        'total_people': 8,\n        'avg_connections': 1.25,\n        'most_connected': [('Bob', 2)],\n        'num_communities': 3,\n        'largest_community_size': 3\n    }\n\n    Note: Assume that connections are undirected (if A is connected to B, B is also connected to A).\n    \"\"\"\n", "entry_point": "social_network_analysis", "solution": "    # Create a graph representation using defaultdict\n    graph = defaultdict(set)\n    for person1, person2 in connections:\n        graph[person1].add(person2)\n        graph[person2].add(person1)\n\n    # Calculate total number of people\n    total_people = len(graph)\n\n    # Calculate average number of connections\n    total_connections = sum(len(connections) for connections in graph.values())\n    avg_connections = total_connections / total_people if total_people > 0 else 0\n\n    # Find most connected person(s)\n    max_connections = max(len(connections) for connections in graph.values())\n    most_connected = [(person, len(connections)) for person, connections in graph.items() if len(connections) == max_connections]\n\n    # Find number of communities and largest community size\n    def dfs(person, visited):\n        visited.add(person)\n        community_size = 1\n        for neighbor in graph[person]:\n            if neighbor not in visited:\n                community_size += dfs(neighbor, visited)\n        return community_size\n\n    visited = set()\n    num_communities = 0\n    largest_community_size = 0\n\n    for person in graph:\n        if person not in visited:\n            num_communities += 1\n            community_size = dfs(person, visited)\n            largest_community_size = max(largest_community_size, community_size)\n\n    # Prepare and return the result\n    return {\n        'total_people': total_people,\n        'avg_connections': round(avg_connections, 2),\n        'most_connected': most_connected,\n        'num_communities': num_communities,\n        'largest_community_size': largest_community_size\n    }\n", "test": "def check(candidate):\n    assert candidate([(\"A\", \"B\")]) == {'total_people': 2, 'avg_connections': 1.0, 'most_connected': [('A', 1), ('B', 1)], 'num_communities': 1, 'largest_community_size': 2}\n    assert candidate([(\"A\", \"B\"), (\"B\", \"C\"), (\"C\", \"D\"), (\"D\", \"E\"), (\"E\", \"A\")]) == {'total_people': 5, 'avg_connections': 2.0, 'most_connected': [('A', 2), ('B', 2), ('C', 2), ('D', 2), ('E', 2)], 'num_communities': 1, 'largest_community_size': 5}\n    assert candidate([(\"A\", \"B\"), (\"C\", \"D\"), (\"E\", \"F\"), (\"G\", \"H\"), (\"I\", \"J\")]) == {'total_people': 10, 'avg_connections': 1.0, 'most_connected': [('A', 1), ('B', 1), ('C', 1), ('D', 1), ('E', 1), ('F', 1), ('G', 1), ('H', 1), ('I', 1), ('J', 1)], 'num_communities': 5, 'largest_community_size': 2}\n    assert candidate([(\"X\", \"Y\"), (\"Y\", \"Z\"), (\"Z\", \"X\"), (\"A\", \"B\"), (\"B\", \"C\"), (\"C\", \"A\")]) == {'total_people': 6, 'avg_connections': 2.0, 'most_connected': [('X', 2), ('Y', 2), ('Z', 2), ('A', 2), ('B', 2), ('C', 2)], 'num_communities': 2, 'largest_community_size': 3}\n    assert candidate([(\"A\", \"B\"), (\"B\", \"C\"), (\"C\", \"D\"), (\"D\", \"E\"), (\"E\", \"F\"), (\"F\", \"G\"), (\"G\", \"H\"), (\"H\", \"I\"), (\"I\", \"J\"), (\"J\", \"A\")]) == {'total_people': 10, 'avg_connections': 2.0, 'most_connected': [('A', 2), ('B', 2), ('C', 2), ('D', 2), ('E', 2), ('F', 2), ('G', 2), ('H', 2), ('I', 2), ('J', 2)], 'num_communities': 1, 'largest_community_size': 10}\n    assert candidate([(\"Alice\", \"Bob\"), (\"Bob\", \"Charlie\"), (\"David\", \"Eve\"), (\"Eve\", \"Frank\"), (\"George\", \"Harry\")]) == {'total_people': 8, 'avg_connections': 1.25, 'most_connected': [('Bob', 2), ('Eve', 2)], 'num_communities': 3, 'largest_community_size': 3}\n    assert candidate([(\"1\", \"2\"), (\"2\", \"3\"), (\"3\", \"4\"), (\"4\", \"5\"), (\"5\", \"1\"), (\"1\", \"3\"), (\"3\", \"5\")]) == {'total_people': 5, 'avg_connections': 2.8, 'most_connected': [('3', 4)], 'num_communities': 1, 'largest_community_size': 5}\n    assert candidate([(\"John\", \"Jane\"), (\"Jane\", \"Jack\"), (\"Jack\", \"Jill\"), (\"Jill\", \"John\"), (\"John\", \"Jack\")]) == {'total_people': 4, 'avg_connections': 2.5, 'most_connected': [('John', 3), ('Jack', 3)], 'num_communities': 1, 'largest_community_size': 4}\n    assert candidate([(\"X\", \"X\")]) == {'total_people': 1, 'avg_connections': 1.0, 'most_connected': [('X', 1)], 'num_communities': 1, 'largest_community_size': 1}\n    assert candidate([(\"Alice\", \"Bob\"), (\"Bob\", \"Charlie\"), (\"Charlie\", \"David\"), (\"David\", \"Alice\"), (\"Eve\", \"Frank\")]) == {'total_people': 6, 'avg_connections': 1.67, 'most_connected': [('Alice', 2), ('Bob', 2), ('Charlie', 2), ('David', 2)], 'num_communities': 2, 'largest_community_size': 4}\n", "language": "python"}
{"task_id": "revision1a_problem745", "prompt": "from typing import List\n\ndef decode_alien_message(encoded_message: str, dictionary: List[str]) -> List[str]:\n    \"\"\"\n    As a cryptographer working for SETI, I've intercepted an encoded message from an alien civilization.\n    The message is a string of lowercase letters without any spaces. We have a dictionary of alien words that we've previously decoded.\n    Your task is to determine if it's possible to segment the encoded message into a space-separated sequence of dictionary words.\n    If it's possible, return all valid decodings of the message. If it's not possible, return an empty list.\n    Take input from the user for the encoded message and the dictionary of known alien words.\n    Implement this using a combination of dynamic programming and backtracking for efficiency.\n    Example:\n    Input: \"ilikecoffee\", [\"i\", \"like\", \"coffee\", \"tea\", \"ice\"]\n    Output: [\"i like coffee\"]\n    Input: \"bewareofthedog\", [\"be\", \"aware\", \"of\", \"the\", \"dog\", \"bear\"]\n    Output: [\"beware of the dog\", \"be aware of the dog\"]\n    \"\"\"\n", "entry_point": "decode_alien_message", "solution": "    def backtrack(start: int, path: List[str]) -> None:\n        if start == len(encoded_message):\n            result.append(\" \".join(path))\n            return\n        \n        for end in range(start + 1, len(encoded_message) + 1):\n            word = encoded_message[start:end]\n            if word in dictionary and dp[end]:\n                path.append(word)\n                backtrack(end, path)\n                path.pop()\n\n    n = len(encoded_message)\n    dp = [False] * (n + 1)\n    dp[0] = True\n\n    for i in range(1, n + 1):\n        for j in range(i):\n            if dp[j] and encoded_message[j:i] in dictionary:\n                dp[i] = True\n                break\n\n    result = []\n    if dp[n]:\n        backtrack(0, [])\n\n    return result\n", "test": "def check(candidate):\n    assert candidate(\"bewareofthedog\", [\"be\", \"aware\", \"of\", \"the\", \"dog\", \"bear\"]) == []\n    assert candidate(\"abcdef\", [\"ab\", \"cd\", \"ef\", \"abc\", \"def\"]) == ['ab cd ef', 'abc def']\n    assert candidate(\"\", []) == ['']\n    assert candidate(\"ilikecoffee\", [\"i\", \"like\", \"coffee\", \"tea\", \"ice\"]) == ['i like coffee']\n    assert candidate(\"thequickbrownfox\", [\"the\", \"quick\", \"brown\", \"fox\", \"jumps\", \"over\"]) == ['the quick brown fox']\n    assert candidate(\"icecreamandcake\", [\"ice\", \"cream\", \"and\", \"cake\", \"icecream\"]) == ['ice cream and cake', 'icecream and cake']\n    assert candidate(\"aaaaa\", [\"a\", \"aa\", \"aaa\", \"aaaa\", \"aaaaa\"]) == ['a a a a a', 'a a a aa', 'a a aa a', 'a a aaa', 'a aa a a', 'a aa aa', 'a aaa a', 'a aaaa', 'aa a a a', 'aa a aa', 'aa aa a', 'aa aaa', 'aaa a a', 'aaa aa', 'aaaa a', 'aaaaa']\n    assert candidate(\"xyz\", [\"x\", \"y\", \"z\"]) == ['x y z']\n    assert candidate(\"helloworld\", [\"hello\", \"world\", \"hell\", \"o\", \"w\", \"or\", \"ld\"]) == ['hell o w or ld', 'hell o world', 'hello w or ld', 'hello world']\n    assert candidate(\"a\", [\"a\"]) == ['a']\n", "language": "python"}
{"task_id": "revision1a_problem124", "prompt": "def fibonacci_sum(n: int) -> int:\n    \"\"\"\n    Take n as input from the user, where n is the number of Fibonacci numbers to consider.\n    Calculate the sum of even-valued Fibonacci numbers up to the nth term.\n    Write Python code using a while loop and list comprehension.\n    \n    Example:\n    Input: 10\n    Output: 44 (sum of 2 + 8 + 34)\n    Input: 15\n    Output: 188 (sum of 2 + 8 + 34 + 144)\n    \"\"\"\n", "entry_point": "fibonacci_sum", "solution": "    a, b = 0, 1\n    fib_numbers = []\n    count = 0\n\n    while count < n:\n        fib_numbers.append(a)\n        a, b = b, a + b\n        count += 1\n\n    even_fibs = [num for num in fib_numbers if num % 2 == 0]\n    return sum(even_fibs)\n", "test": "def check(candidate):\n    assert candidate(50) == 6293134512\n    assert candidate(2) == 0\n    assert candidate(10) == 44\n    assert candidate(3) == 0\n    assert candidate(1) == 0\n    assert candidate(5) == 2\n    assert candidate(20) == 3382\n    assert candidate(4) == 2\n    assert candidate(30) == 257114\n    assert candidate(15) == 188\n", "language": "python"}
