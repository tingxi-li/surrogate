{"task_id": "dd48eece-8c15-4008-977a-fd13bb285e30-1516375488868785997", "prompt": "I am a programming helper designed to assist with coding tasks. My job is to implement functions that work correctly when executed. I'll complete functions as provided without adding external code. Any helper functions or classes will be defined within the main function. I'll only use libraries specified in the original problem.\n\n```python\ndef compress_string(s: str) -> str:\n    \"\"\"\n    Compresses a string by replacing consecutive repeated characters with the character\n    followed by the count of repetitions.\n\n    This function takes a string input and compresses it by replacing any sequence of\n    identical characters with that character followed by the number of times it appears\n    consecutively. If the compressed string is not shorter than the original string,\n    it returns the original string.\n\n    Args:\n        s (str): The input string to be compressed.\n\n    Returns:\n        str: The compressed string, or the original string if compression doesn't\n             result in a shorter string.\n\n\n    [EXAMPLES]\n    \n    assert candidate(\"aaabbb\") == 'a3b3'\n    assert candidate(\"aaaa\") == 'a4'\n\n    [/EXAMPLES]\n    \"\"\"\n```\n", "entry_point": "compress_string", "solution": "def compress_string(s: str) -> str:\n    \"\"\"\n    Compresses a string by replacing consecutive repeated characters with the character\n    followed by the count of repetitions.\n\n    This function takes a string input and compresses it by replacing any sequence of\n    identical characters with that character followed by the number of times it appears\n    consecutively. If the compressed string is not shorter than the original string,\n    it returns the original string.\n\n    Args:\n        s (str): The input string to be compressed.\n\n    Returns:\n        str: The compressed string, or the original string if compression doesn't\n             result in a shorter string.\n\n\n    [EXAMPLES]\n    \n    assert candidate(\"aaabbb\") == 'a3b3'\n    assert candidate(\"aaaa\") == 'a4'\n\n    [/EXAMPLES]\n    \"\"\"\n    if not s:\n        return s\n\n    compressed = []\n    count = 1\n    current_char = s[0]\n\n    for char in s[1:]:\n        if char == current_char:\n            count += 1\n        else:\n            compressed.append(current_char + str(count))\n            current_char = char\n            count = 1\n\n    compressed.append(current_char + str(count))\n\n    compressed_string = ''.join(compressed)\n    return compressed_string if len(compressed_string) < len(s) else s\n\n", "test": "def check(candidate):\n    assert candidate(\"a\" * 100) == 'a100'\n    assert candidate(\"aaabbb\") == 'a3b3'\n    assert candidate(\"aabb\") == 'aabb'\n    assert candidate(\"aA\" * 10) == 'aAaAaAaAaAaAaAaAaAaA'\n    assert candidate(\"aaaaaaaaaaa\") == 'a11'\n    assert candidate(\"abc\" * 10) == 'abcabcabcabcabcabcabcabcabcabc'\n    assert candidate(\"aaaa\") == 'a4'\n    assert candidate(\"zzzzzzzzzz\") == 'z10'\n    assert candidate(\"a\") == 'a'\n    assert candidate(\"abcabcabc\") == 'abcabcabc'\n", "language": "python"}
{"task_id": "789d7267-dcf0-4039-8e9c-83edd89212bb-3119088792819119339", "prompt": "Your solution should be a complete, executable function contained in a single code block. Any additional functions or classes should be defined within the main function. Only use libraries that are specified in the imports. Provide only the function code and nothing else.\n\n```python\ndef encrypt_alien_message(message: str, key: int) -> str:\n    \"\"\"\n    Encrypts a message using a unique alien encryption method.\n\n    This function employs concepts of string manipulation and modular arithmetic\n    to encrypt a message. The alien encryption method shifts each character in the\n    message by a value determined by the key and the character's position.\n\n    Args:\n        message (str): The message to be encrypted.\n        key (int): The encryption key.\n\n    Returns:\n        str: The encrypted message.\n\n\n    [EXAMPLES]\n    \n    assert candidate(\"Mixed Case 123\", 8) == 'Urhpp Qpiv 123'\n    assert candidate(\"LongMessageWithNoSpaces\", 100) == 'HllfMfuvelkDqcrYaFdpsvk'\n\n    [/EXAMPLES]\n    \"\"\"\n```\n", "entry_point": "encrypt_alien_message", "solution": "def encrypt_alien_message(message: str, key: int) -> str:\n    \"\"\"\n    Encrypts a message using a unique alien encryption method.\n\n    This function employs concepts of string manipulation and modular arithmetic\n    to encrypt a message. The alien encryption method shifts each character in the\n    message by a value determined by the key and the character's position.\n\n    Args:\n        message (str): The message to be encrypted.\n        key (int): The encryption key.\n\n    Returns:\n        str: The encrypted message.\n\n\n    [EXAMPLES]\n    \n    assert candidate(\"Mixed Case 123\", 8) == 'Urhpp Qpiv 123'\n    assert candidate(\"LongMessageWithNoSpaces\", 100) == 'HllfMfuvelkDqcrYaFdpsvk'\n\n    [/EXAMPLES]\n    \"\"\"\n    def shift_char(char: str, shift: int) -> str:\n        if not char.isalpha():\n            return char\n        \n        # Determine the ASCII offset based on case\n        offset = 65 if char.isupper() else 97\n        \n        # Apply the shift and wrap around the alphabet\n        return chr((ord(char) - offset + shift) % 26 + offset)\n\n    encrypted_message = \"\"\n    for i, char in enumerate(message):\n        # Calculate the shift based on the key and character position\n        shift = (key + i) % 26\n        encrypted_message += shift_char(char, shift)\n\n    return encrypted_message\n\n", "test": "def check(candidate):\n    assert candidate(\"Tab\\tCharacter\", 6) == 'Zhj\\tMsmeorjvj'\n    assert candidate(\"ABCDEFGHIJKLMNOPQRSTUVWXYZ\", 26) == 'ACEGIKMOQSUWYACEGIKMOQSUWY'\n    assert candidate(\"HELLO WORLD\", -1) == 'GEMNR BUYTM'\n    assert candidate(\"\", 5) == ''\n    assert candidate(\"NewLine\\nCharacter\", 4) == 'RjcSqwo\\nOuogqtlxl'\n    assert candidate(\"LongMessageWithNoSpaces\", 100) == 'HllfMfuvelkDqcrYaFdpsvk'\n    assert candidate(\"Mixed Case 123\", 8) == 'Urhpp Qpiv 123'\n    assert candidate(\"JUMPED OVER THE LAZY DOG\", 15) == 'YKDHXX KSCQ UJH QGGG NZS'\n    assert candidate(\"1234567890\", 3) == '1234567890'\n    assert candidate(\"Z\", 1000001) == 'O'\n", "language": "python"}
{"task_id": "2dce5ada-5902-41c6-a1ab-0c2109302a54-570341407869176322", "prompt": "Please implement the provided function fully, ensuring it's runnable within a single code block. Don't add code outside the function scope. Only use libraries that are already imported in the problem statement. Any helper functions or classes should be defined within the main function.\n\n```python\ndef calculate_word_score(word: str) -> int:\n    \"\"\"In a peculiar scrabble-like game, each letter is assigned a score based on its position in the alphabet.\n    'A' is worth 1 point, 'B' is worth 2 points, and so on, with 'Z' being worth 26 points.\n    Calculate the total score for a given word.\n\n\n    [EXAMPLES]\n    \n    assert candidate(\"PROGRAMMING\") == 131\n    assert candidate(\"ZZZZZ\") == 130\n\n    [/EXAMPLES]\n    \"\"\"\n```\n", "entry_point": "calculate_word_score", "solution": "def calculate_word_score(word: str) -> int:\n    \"\"\"In a peculiar scrabble-like game, each letter is assigned a score based on its position in the alphabet.\n    'A' is worth 1 point, 'B' is worth 2 points, and so on, with 'Z' being worth 26 points.\n    Calculate the total score for a given word.\n\n\n    [EXAMPLES]\n    \n    assert candidate(\"PROGRAMMING\") == 131\n    assert candidate(\"ZZZZZ\") == 130\n\n    [/EXAMPLES]\n    \"\"\"\n    def letter_score(char: str) -> int:\n        return ord(char.upper()) - ord('A') + 1\n\n    return sum(letter_score(char) for char in word)\n\n", "test": "def check(candidate):\n    assert candidate(\"ZZZ\") == 78\n    assert candidate(\"AEIOU\") == 51\n    assert candidate(\"\") == 0\n    assert candidate(\"AAA\") == 3\n    assert candidate(\"PROGRAMMING\") == 131\n    assert candidate(\"ABCDEFGHIJKLMNOPQRSTUVWXYZ\") == 351\n    assert candidate(\"ZZZZZ\") == 130\n    assert candidate(\"SUPERCALIFRAGILISTICEXPIALIDOCIOUS\") == 379\n    assert candidate(\"PNEUMONOULTRAMICROSCOPICSILICOVOLCANOCONIOSIS\") == 560\n    assert candidate(\"a\") == 1\n", "language": "python"}
{"task_id": "67a65bc2-e99c-4a03-8427-b03e48777fcf3890555888367880600", "prompt": "I need you to complete a function that's ready for execution. The implementation should be contained entirely within a single code block, with no code outside the function boundaries. Only use libraries that are already imported in the problem statement, and define any helper functions or classes within the main function itself. I'll deliver just one executable code block.\n\n```python\nimport math\n\ndef calculate_rocket_trajectory(initial_velocity: float, launch_angle: float, gravity: float = 9.8) -> tuple:\n    \"\"\"\n    Calculate the trajectory of a rocket launched from the ground.\n\n    This function uses projectile motion equations to determine the maximum height\n    and horizontal distance traveled by a rocket before it lands. It assumes no air\n    resistance and a flat Earth surface.\n\n    Args:\n    initial_velocity (float): The initial velocity of the rocket in m/s.\n    launch_angle (float): The angle of launch in degrees.\n    gravity (float): The acceleration due to gravity in m/s^2. Defaults to 9.8 m/s^2.\n\n    Returns:\n    tuple: A tuple containing the maximum height (in meters) and the horizontal\n           distance traveled (in meters).\n\n\n    [EXAMPLES]\n    \n    assert candidate(50, 45, 24.79) == (25.21177894312222, 100.84711577248889)\n    assert candidate(0.1, 45) == (0.0002551020408163265, 0.0010204081632653062)\n\n    [/EXAMPLES]\n    \"\"\"\n```\n", "entry_point": "calculate_rocket_trajectory", "solution": "import math\n\ndef calculate_rocket_trajectory(initial_velocity: float, launch_angle: float, gravity: float = 9.8) -> tuple:\n    \"\"\"\n    Calculate the trajectory of a rocket launched from the ground.\n\n    This function uses projectile motion equations to determine the maximum height\n    and horizontal distance traveled by a rocket before it lands. It assumes no air\n    resistance and a flat Earth surface.\n\n    Args:\n    initial_velocity (float): The initial velocity of the rocket in m/s.\n    launch_angle (float): The angle of launch in degrees.\n    gravity (float): The acceleration due to gravity in m/s^2. Defaults to 9.8 m/s^2.\n\n    Returns:\n    tuple: A tuple containing the maximum height (in meters) and the horizontal\n           distance traveled (in meters).\n\n\n    [EXAMPLES]\n    \n    assert candidate(50, 45, 24.79) == (25.21177894312222, 100.84711577248889)\n    assert candidate(0.1, 45) == (0.0002551020408163265, 0.0010204081632653062)\n\n    [/EXAMPLES]\n    \"\"\"\n    # Convert launch angle from degrees to radians\n    angle_rad = math.radians(launch_angle)\n\n    # Calculate the vertical and horizontal components of the initial velocity\n    v0y = initial_velocity * math.sin(angle_rad)\n    v0x = initial_velocity * math.cos(angle_rad)\n\n    # Calculate the time to reach maximum height\n    time_to_peak = v0y / gravity\n\n    # Calculate the maximum height\n    max_height = (v0y ** 2) / (2 * gravity)\n\n    # Calculate the total time of flight\n    total_time = 2 * time_to_peak\n\n    # Calculate the horizontal distance traveled\n    horizontal_distance = v0x * total_time\n\n    return (max_height, horizontal_distance)\n\n", "test": "def check(candidate):\n    assert candidate(50, 60, 1.62) == (578.7037037037037, 1336.4589564574671)\n    assert candidate(0.1, 45) == (0.0002551020408163265, 0.0010204081632653062)\n    assert candidate(200, 75) == (1904.10755488208, 2040.8163265306118)\n    assert candidate(1, 89) == (0.05100486803620142, 0.00356117313290828)\n    assert candidate(75, 60) == (215.24234693877548, 497.0809077844355)\n    assert candidate(50, 15) == (8.544298228033249, 127.55102040816323)\n    assert candidate(1000, 1) == (15.540127063884434, 3561.173132908262)\n    assert candidate(50, 45, 24.79) == (25.21177894312222, 100.84711577248889)\n    assert candidate(300, 45, 9.81) == (2293.5779816513755, 9174.311926605504)\n    assert candidate(1000, 90) == (51020.4081632653, 1.2496395909666868e-11)\n", "language": "python"}
{"task_id": "3f110a94-7377-4716-8983-29b06b56ad5a6899638149904160224", "prompt": "I'll implement the rest of the function based on the docstring provided. The function name and arguments will remain unchanged, and I'll deliver the complete code in one block.\n\n```python\nfrom typing import List\n\ndef optimize_study_schedule(subjects: List[str], study_times: List[int], available_time: int) -> List[str]:\n    \"\"\"\n    A student is preparing for final exams and wants to maximize the number of subjects they can \n    study within their available time. Help them create an optimal study schedule.\n\n    This function takes three parameters:\n    - subjects: A list of subject names\n    - study_times: A list of integers representing the time required to study each subject (in hours)\n    - available_time: The total time available for studying (in hours)\n\n    It returns a list of subjects that can be studied within the available time, maximizing the \n    number of subjects covered.\n\n\n    [EXAMPLES]\n    \n    assert candidate([], [], 10) == []\n    assert candidate(['A', 'B', 'C'], [1, 2, 3], 1) == ['A']\n\n    [/EXAMPLES]\n    \"\"\"\n```\n", "entry_point": "optimize_study_schedule", "solution": "from typing import List\n\ndef optimize_study_schedule(subjects: List[str], study_times: List[int], available_time: int) -> List[str]:\n    \"\"\"\n    A student is preparing for final exams and wants to maximize the number of subjects they can \n    study within their available time. Help them create an optimal study schedule.\n\n    This function takes three parameters:\n    - subjects: A list of subject names\n    - study_times: A list of integers representing the time required to study each subject (in hours)\n    - available_time: The total time available for studying (in hours)\n\n    It returns a list of subjects that can be studied within the available time, maximizing the \n    number of subjects covered.\n\n\n    [EXAMPLES]\n    \n    assert candidate([], [], 10) == []\n    assert candidate(['A', 'B', 'C'], [1, 2, 3], 1) == ['A']\n\n    [/EXAMPLES]\n    \"\"\"\n    # Create a list of tuples containing subject and study time\n    subject_time_pairs = list(zip(subjects, study_times))\n    \n    # Sort the pairs based on study time in ascending order\n    subject_time_pairs.sort(key=lambda x: x[1])\n    \n    optimal_schedule = []\n    remaining_time = available_time\n    \n    # Iterate through the sorted pairs\n    for subject, time in subject_time_pairs:\n        if time <= remaining_time:\n            optimal_schedule.append(subject)\n            remaining_time -= time\n        else:\n            break\n    \n    return optimal_schedule\n\n", "test": "def check(candidate):\n    assert candidate(['A', 'B', 'C'], [1, 2, 3], 1) == ['A']\n    assert candidate([], [], 10) == []\n    assert candidate(['Subject'] * 10, [1] * 10, 5) == ['Subject', 'Subject', 'Subject', 'Subject', 'Subject']\n    assert candidate(['Math', 'Science'], [3, 4], 0) == []\n    assert candidate(['S1', 'S2', 'S3', 'S4', 'S5'], [2, 2, 2, 2, 2], 9) == ['S1', 'S2', 'S3', 'S4']\n    assert candidate(['X', 'Y'], [50, 50], 100) == ['X', 'Y']\n    assert candidate(['A', 'B', 'C', 'D', 'E'], [5, 4, 3, 2, 1], 7) == ['E', 'D', 'C']\n    assert candidate(['Short', 'Medium', 'Long'], [1, 5, 10], 11) == ['Short', 'Medium']\n    assert candidate(['Long', 'Short'], [1000, 1], 999) == ['Short']\n    assert candidate(['A', 'B', 'C', 'D', 'E'], [1, 1, 1, 1, 1], 3) == ['A', 'B', 'C']\n", "language": "python"}
{"task_id": "6924d305-4b6b-4faf-988e-8c8bdd11d6052096701135448781696", "prompt": "I need you to finish the provided function in one complete, executable code block. Don't add any code outside the function definition. Stick to using only the libraries that are already imported in the problem. If you need helper functions or classes, define them inside the main function.\n\n```python\nfrom typing import List\n\ndef ancient_cipher(message: str, key: List[int]) -> str:\n    \"\"\"\n    In an ancient civilization, a secret society used a unique cipher to encode messages.\n    The cipher involves shifting each character in the message by a corresponding value in a repeating key.\n    Your task is to implement this cipher.\n\n    The function takes two parameters:\n    - message: A string containing the message to be encoded\n    - key: A list of integers representing the shifting values\n\n    The function should return the encoded message as a string.\n\n    The cipher works as follows:\n    1. Each character in the message is shifted by the corresponding value in the key.\n    2. The key repeats if it's shorter than the message.\n    3. Only alphabetic characters (A-Z, a-z) should be shifted. Other characters remain unchanged.\n    4. Shifting wraps around the alphabet (e.g., 'z' shifted by 1 becomes 'a').\n\n\n    [EXAMPLES]\n    \n    assert candidate(\"ABCDEFGHIJKLMNOPQRSTUVWXYZ\", [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]) == 'BDFHJLNPRTLNPRTVXZBDVXZBDF'\n    assert candidate(\"12345!@#$%^&*()_+\", [1, 2, 3, 4, 5]) == '12345!@#$%^&*()_+'\n\n    [/EXAMPLES]\n    \"\"\"\n```\n", "entry_point": "ancient_cipher", "solution": "from typing import List\n\ndef ancient_cipher(message: str, key: List[int]) -> str:\n    \"\"\"\n    In an ancient civilization, a secret society used a unique cipher to encode messages.\n    The cipher involves shifting each character in the message by a corresponding value in a repeating key.\n    Your task is to implement this cipher.\n\n    The function takes two parameters:\n    - message: A string containing the message to be encoded\n    - key: A list of integers representing the shifting values\n\n    The function should return the encoded message as a string.\n\n    The cipher works as follows:\n    1. Each character in the message is shifted by the corresponding value in the key.\n    2. The key repeats if it's shorter than the message.\n    3. Only alphabetic characters (A-Z, a-z) should be shifted. Other characters remain unchanged.\n    4. Shifting wraps around the alphabet (e.g., 'z' shifted by 1 becomes 'a').\n\n\n    [EXAMPLES]\n    \n    assert candidate(\"ABCDEFGHIJKLMNOPQRSTUVWXYZ\", [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]) == 'BDFHJLNPRTLNPRTVXZBDVXZBDF'\n    assert candidate(\"12345!@#$%^&*()_+\", [1, 2, 3, 4, 5]) == '12345!@#$%^&*()_+'\n\n    [/EXAMPLES]\n    \"\"\"\n    def shift_char(char: str, shift: int) -> str:\n        if not char.isalpha():\n            return char\n        \n        ascii_offset = ord('A') if char.isupper() else ord('a')\n        shifted = (ord(char) - ascii_offset + shift) % 26 + ascii_offset\n        return chr(shifted)\n\n    encoded = []\n    key_length = len(key)\n    \n    for i, char in enumerate(message):\n        shift = key[i % key_length]\n        encoded.append(shift_char(char, shift))\n    \n    return ''.join(encoded)\n\n", "test": "def check(candidate):\n    assert candidate(\"ABCDEFGHIJKLMNOPQRSTUVWXYZ\", [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]) == 'BDFHJLNPRTLNPRTVXZBDVXZBDF'\n    assert candidate(\"\", [1, 2, 3]) == ''\n    assert candidate(\"ZEUS\", [26, 26, 26, 26]) == 'ZEUS'\n    assert candidate(\"THE QUICK BROWN FOX JUMPS OVER THE LAZY DOG\", [3, 7, 2, 5]) == 'WOG TBKHN DWRDP IVZ MBOUV QAHY YKL QDGA GVI'\n    assert candidate(\"ABCDEFGHIJKLMNOPQRSTUVWXYZ\", [1]) == 'BCDEFGHIJKLMNOPQRSTUVWXYZA'\n    assert candidate(\"12345!@#$%^&*()_+\", [1, 2, 3, 4, 5]) == '12345!@#$%^&*()_+'\n    assert candidate(\"abcdefghijklmnopqrstuvwxyz\", [26]) == 'abcdefghijklmnopqrstuvwxyz'\n    assert candidate(\"secret message\", [5, 2, 8, 1]) == 'xgksjv njuablg'\n    assert candidate(\"aaaaaaaaaa\", [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]) == 'bcdefghijk'\n    assert candidate(\"The end.\", [100, 200, 300]) == 'Pzs wbz.'\n", "language": "python"}
{"task_id": "16706cb7-e992-4d78-9f56-a0b00c7831bf4423359570667796055", "prompt": "I'm your coding assistant. My job is to complete functions so they're immediately executable in code blocks. I'll stick to the libraries you've imported and won't add any external code. Any helper functions or classes I create will be nested inside your main function.\n\n```python\nfrom typing import List\n\ndef find_longest_arithmetic_subsequence(numbers: List[int]) -> int:\n    \"\"\"\n    A mathematician is studying arithmetic progressions in number sequences.\n    This function takes a list of integers and returns the length of the longest\n    arithmetic subsequence present in the list.\n\n    An arithmetic subsequence is a sequence where the difference between each\n    consecutive pair of elements is constant.\n\n\n    [EXAMPLES]\n    \n    assert candidate([1, 3, 5, 7, 9]) == 5\n    assert candidate([1, 3, 5, 2, 4, 6]) == 3\n\n    [/EXAMPLES]\n    \"\"\"\n```\n", "entry_point": "find_longest_arithmetic_subsequence", "solution": "from typing import List\n\ndef find_longest_arithmetic_subsequence(numbers: List[int]) -> int:\n    \"\"\"\n    A mathematician is studying arithmetic progressions in number sequences.\n    This function takes a list of integers and returns the length of the longest\n    arithmetic subsequence present in the list.\n\n    An arithmetic subsequence is a sequence where the difference between each\n    consecutive pair of elements is constant.\n\n\n    [EXAMPLES]\n    \n    assert candidate([1, 3, 5, 7, 9]) == 5\n    assert candidate([1, 3, 5, 2, 4, 6]) == 3\n\n    [/EXAMPLES]\n    \"\"\"\n    if len(numbers) <= 2:\n        return len(numbers)\n\n    n = len(numbers)\n    dp = [{} for _ in range(n)]\n    max_length = 2\n\n    for i in range(1, n):\n        for j in range(i):\n            diff = numbers[i] - numbers[j]\n            if diff in dp[j]:\n                dp[i][diff] = dp[j][diff] + 1\n            else:\n                dp[i][diff] = 2\n            max_length = max(max_length, dp[i][diff])\n\n    return max_length\n\n", "test": "def check(candidate):\n    assert candidate([1, 3, 5, 2, 4, 6]) == 3\n    assert candidate([3, 6, 9, 12, 15, 18, 21]) == 7\n    assert candidate([1, 3, 5, 7, 9]) == 5\n    assert candidate([1, 2, 3, 1, 2, 3, 1, 2, 3]) == 3\n", "language": "python"}
{"task_id": "af8f5e75-cca1-44bf-8010-aa87fc646442-470692414890889846", "prompt": "Let me complete the function code according to the docstring requirements. I'll provide the entire function in a single code block while keeping the original function name and parameters unchanged.\n\n```python\nfrom typing import List\n\ndef optimal_study_plan(subjects: List[int], time_limit: int) -> int:\n    \"\"\"\n    As a student preparing for exams, you want to maximize your study efficiency. You have a list of subjects, each requiring a certain amount of time to master, and a limited total study time available.\n\n    This function uses dynamic programming to determine the maximum number of subjects you can fully master within the given time limit.\n\n    Args:\n    subjects (List[int]): A list of integers representing the time required to master each subject.\n    time_limit (int): The total amount of study time available.\n\n    Returns:\n    int: The maximum number of subjects that can be fully mastered within the time limit.\n\n\n    [EXAMPLES]\n    \n    assert candidate([3, 3, 3, 3, 3], 14) == 4\n    assert candidate([100, 200, 300, 400, 500], 1000) == 4\n\n    [/EXAMPLES]\n    \"\"\"\n```\n", "entry_point": "optimal_study_plan", "solution": "from typing import List\n\ndef optimal_study_plan(subjects: List[int], time_limit: int) -> int:\n    \"\"\"\n    As a student preparing for exams, you want to maximize your study efficiency. You have a list of subjects, each requiring a certain amount of time to master, and a limited total study time available.\n\n    This function uses dynamic programming to determine the maximum number of subjects you can fully master within the given time limit.\n\n    Args:\n    subjects (List[int]): A list of integers representing the time required to master each subject.\n    time_limit (int): The total amount of study time available.\n\n    Returns:\n    int: The maximum number of subjects that can be fully mastered within the time limit.\n\n\n    [EXAMPLES]\n    \n    assert candidate([3, 3, 3, 3, 3], 14) == 4\n    assert candidate([100, 200, 300, 400, 500], 1000) == 4\n\n    [/EXAMPLES]\n    \"\"\"\n    n = len(subjects)\n    \n    # Create a 2D DP table\n    dp = [[0] * (time_limit + 1) for _ in range(n + 1)]\n    \n    # Fill the DP table\n    for i in range(1, n + 1):\n        for j in range(1, time_limit + 1):\n            if subjects[i-1] <= j:\n                # If the current subject can fit in the time limit,\n                # choose the maximum between including it or not\n                dp[i][j] = max(dp[i-1][j], dp[i-1][j-subjects[i-1]] + 1)\n            else:\n                # If the current subject doesn't fit, carry over the previous value\n                dp[i][j] = dp[i-1][j]\n    \n    # Return the maximum number of subjects that can be mastered\n    return dp[n][time_limit]\n\n", "test": "def check(candidate):\n    assert candidate([5, 5, 5, 5, 5], 20) == 4\n    assert candidate([100], 99) == 0\n    assert candidate([], 0) == 0\n    assert candidate([3, 3, 3, 3, 3], 14) == 4\n    assert candidate([i for i in range(1, 21)], 100) == 13\n    assert candidate([2, 4, 6, 8, 10], 9) == 2\n    assert candidate([5, 4, 3, 2, 1], 10) == 4\n    assert candidate([1, 10, 100, 1000], 1000) == 3\n    assert candidate([100, 200, 300, 400, 500], 1000) == 4\n    assert candidate([1, 1, 1], 2) == 2\n", "language": "python"}
{"task_id": "61480a84-7263-4a42-8cdf-82e6c798b223-5789330063496632423", "prompt": "Following the instructions in the docstring, I'll implement the complete function. The code will be contained in one block, and I'll make sure to address any edge cases.\n\n```python\nfrom typing import List\n\ndef calculate_water_trapped(heights: List[int]) -> int:\n    \"\"\"\n    In a post-apocalyptic world, survivors have built a settlement with irregular wall heights.\n    During the rainy season, water gets trapped between these walls.\n    Given an array of integers representing the wall heights,\n    calculate the total amount of water that can be trapped after a heavy rainfall.\n\n    Args:\n    heights (List[int]): A list of integers representing the heights of walls.\n\n    Returns:\n    int: The total amount of water trapped.\n\n\n    [EXAMPLES]\n    \n    assert candidate([1, 2, 3, 4, 5]) == 0\n    assert candidate([]) == 0\n\n    [/EXAMPLES]\n    \"\"\"\n```\n", "entry_point": "calculate_water_trapped", "solution": "from typing import List\n\ndef calculate_water_trapped(heights: List[int]) -> int:\n    \"\"\"\n    In a post-apocalyptic world, survivors have built a settlement with irregular wall heights.\n    During the rainy season, water gets trapped between these walls.\n    Given an array of integers representing the wall heights,\n    calculate the total amount of water that can be trapped after a heavy rainfall.\n\n    Args:\n    heights (List[int]): A list of integers representing the heights of walls.\n\n    Returns:\n    int: The total amount of water trapped.\n\n\n    [EXAMPLES]\n    \n    assert candidate([1, 2, 3, 4, 5]) == 0\n    assert candidate([]) == 0\n\n    [/EXAMPLES]\n    \"\"\"\n    if not heights:\n        return 0\n\n    n = len(heights)\n    left_max = [0] * n\n    right_max = [0] * n\n    water_trapped = 0\n\n    # Calculate the maximum height to the left of each element\n    left_max[0] = heights[0]\n    for i in range(1, n):\n        left_max[i] = max(left_max[i-1], heights[i])\n\n    # Calculate the maximum height to the right of each element\n    right_max[n-1] = heights[n-1]\n    for i in range(n-2, -1, -1):\n        right_max[i] = max(right_max[i+1], heights[i])\n\n    # Calculate the water trapped at each position\n    for i in range(n):\n        water_level = min(left_max[i], right_max[i])\n        water_trapped += max(0, water_level - heights[i])\n\n    return water_trapped\n\n", "test": "def check(candidate):\n    assert candidate([1]) == 0\n    assert candidate([]) == 0\n    assert candidate([1, 2, 3, 4, 5, 4, 3, 2, 1]) == 0\n    assert candidate([1, 1, 1, 1]) == 0\n    assert candidate([100, 0, 0, 0, 0, 100]) == 400\n    assert candidate([1, 2, 3, 4, 5]) == 0\n    assert candidate([5, 4, 3, 2, 1, 2, 3, 4, 5]) == 16\n    assert candidate([1, 8, 6, 2, 5, 4, 8, 3, 7]) == 19\n    assert candidate([0, 1, 0, 2, 1, 0, 1, 3, 2, 1, 2, 1]) == 6\n    assert candidate([4, 2, 0, 3, 2, 5]) == 9\n", "language": "python"}
{"task_id": "83cc62de-cd3d-4478-b0b2-407ab3754cd5-2069275220698300061", "prompt": "You are a coding assistant tasked with completing functions that can be run as-is in code blocks. Your responses should contain only the function implementation without any additional code outside of it. Use only the libraries that have been imported in the problem statement. Any helper functions or classes needed should be defined within the given function.\n\n```python\nfrom typing import List\n\ndef optimize_garden(plants: List[int], max_water: int) -> int:\n    \"\"\"\n    A gardener wants to optimize the arrangement of plants in a row to maximize water efficiency.\n    Each plant requires a specific amount of water, and there's a maximum amount of water available.\n    The function should return the maximum number of consecutive plants that can be watered\n    given the water requirements and the maximum water available.\n\n    Args:\n    plants (List[int]): A list of integers representing the water requirements for each plant.\n    max_water (int): The maximum amount of water available.\n\n    Returns:\n    int: The maximum number of consecutive plants that can be watered.\n\n\n    [EXAMPLES]\n    \n    assert candidate([10, 9, 8, 7, 6], 15) == 2\n    assert candidate([1, 2, 3, 4, 5, 6, 7, 8, 9, 10], 20) == 5\n\n    [/EXAMPLES]\n    \"\"\"\n```\n", "entry_point": "optimize_garden", "solution": "from typing import List\n\ndef optimize_garden(plants: List[int], max_water: int) -> int:\n    \"\"\"\n    A gardener wants to optimize the arrangement of plants in a row to maximize water efficiency.\n    Each plant requires a specific amount of water, and there's a maximum amount of water available.\n    The function should return the maximum number of consecutive plants that can be watered\n    given the water requirements and the maximum water available.\n\n    Args:\n    plants (List[int]): A list of integers representing the water requirements for each plant.\n    max_water (int): The maximum amount of water available.\n\n    Returns:\n    int: The maximum number of consecutive plants that can be watered.\n\n\n    [EXAMPLES]\n    \n    assert candidate([10, 9, 8, 7, 6], 15) == 2\n    assert candidate([1, 2, 3, 4, 5, 6, 7, 8, 9, 10], 20) == 5\n\n    [/EXAMPLES]\n    \"\"\"\n    if not plants or max_water <= 0:\n        return 0\n\n    n = len(plants)\n    start = 0\n    current_sum = 0\n    max_consecutive = 0\n\n    for end in range(n):\n        current_sum += plants[end]\n        \n        while current_sum > max_water:\n            current_sum -= plants[start]\n            start += 1\n        \n        max_consecutive = max(max_consecutive, end - start + 1)\n\n    return max_consecutive\n\n", "test": "def check(candidate):\n    assert candidate([1, 1, 1, 1, 1], 5) == 5\n    assert candidate([1, 2, 3, 4, 5], 15) == 5\n    assert candidate([1, 1, 1, 1, 1, 1, 1, 1, 1, 1], 5) == 5\n    assert candidate([], 100) == 0\n    assert candidate([2, 2, 2, 2, 2], 6) == 3\n    assert candidate([5, 5, 5, 5, 5], 25) == 5\n    assert candidate([3, 3, 3, 3, 3], 9) == 3\n    assert candidate([1, 2, 3, 4, 5], 6) == 3\n    assert candidate([10, 9, 8, 7, 6], 15) == 2\n    assert candidate([1, 2, 3, 4, 5, 6, 7, 8, 9, 10], 20) == 5\n", "language": "python"}
{"task_id": "23c0ea05-c531-49c4-bd79-a74b9da262de-3554712451287289017", "prompt": "Let me complete that code in a single block for you.\n\n```python\ndef calculate_population_growth(initial: int, growth_rate: float, years: int) -> int:\n    \"\"\"\n    Calculate the projected population after a given number of years based on initial population and growth rate.\n\n    This function uses a compound growth model to estimate the future population of a species or community.\n    It takes into account the initial population, annual growth rate, and the number of years to project.\n    The result is rounded down to the nearest integer.\n\n    Parameters:\n    initial (int): The initial population size.\n    growth_rate (float): The annual growth rate as a decimal (e.g., 0.05 for 5% growth).\n    years (int): The number of years to project the population growth.\n\n    Returns:\n    int: The projected population after the specified number of years, rounded down.\n\n\n    [EXAMPLES]\n    \n    assert candidate(100, 0.1, 20) == 672\n    assert candidate(1000000, -0.05, 30) == 214638\n\n    [/EXAMPLES]\n    \"\"\"\n```\n", "entry_point": "calculate_population_growth", "solution": "def calculate_population_growth(initial: int, growth_rate: float, years: int) -> int:\n    \"\"\"\n    Calculate the projected population after a given number of years based on initial population and growth rate.\n\n    This function uses a compound growth model to estimate the future population of a species or community.\n    It takes into account the initial population, annual growth rate, and the number of years to project.\n    The result is rounded down to the nearest integer.\n\n    Parameters:\n    initial (int): The initial population size.\n    growth_rate (float): The annual growth rate as a decimal (e.g., 0.05 for 5% growth).\n    years (int): The number of years to project the population growth.\n\n    Returns:\n    int: The projected population after the specified number of years, rounded down.\n\n\n    [EXAMPLES]\n    \n    assert candidate(100, 0.1, 20) == 672\n    assert candidate(1000000, -0.05, 30) == 214638\n\n    [/EXAMPLES]\n    \"\"\"\n    # Calculate the projected population using the compound growth formula\n    projected_population = initial * (1 + growth_rate) ** years\n    \n    # Round down to the nearest integer\n    return int(projected_population)\n\n", "test": "def check(candidate):\n    assert candidate(500, -0.02, 5) == 451\n    assert candidate(100000, 0.001, 100) == 110511\n    assert candidate(1, -0.99, 10) == 0\n    assert candidate(123456, 0.0789, 45) == 3764141\n    assert candidate(1000000, -0.05, 30) == 214638\n    assert candidate(500000, -0.0001, 1000) == 452416\n    assert candidate(1, 2.0, 15) == 14348907\n    assert candidate(100, 0.1, 20) == 672\n    assert candidate(50, 0.5, 8) == 1281\n    assert candidate(10000, 0.01, 50) == 16446\n", "language": "python"}
{"task_id": "ca260438-53f7-40ff-983e-73945da2104d1245748523693378809", "prompt": "I'll write the complete implementation of the function according to the documentation string. Here's the full code block:\n\n```python\nfrom typing import List, Tuple\nimport heapq\n\ndef optimize_network_latency(nodes: int, connections: List[Tuple[int, int, int]], start: int) -> List[int]:\n    \"\"\"\n    As a network engineer, I need to optimize the latency in a complex computer network.\n    \n    Given the number of nodes, a list of connections (source, destination, latency),\n    and a starting node, calculate the minimum latency from the start node to every other node.\n    \n    Use Dijkstra's algorithm with a priority queue (heapq) to find the shortest paths.\n    If a node is unreachable, its latency should be represented as float('inf').\n    \n    Return a list where the index represents the node number and the value represents\n    the minimum latency from the start node to that node.\n    \n\n    [EXAMPLES]\n    \n    assert candidate(5, [(0,1,1), (1,2,2), (2,3,3), (3,4,4), (0,4,10)], 0) == [0, 1, 3, 6, 10]\n    assert candidate(6, [(0,1,1), (1,2,2), (2,3,3), (3,4,4), (4,5,5)], 0) == [0, 1, 3, 6, 10, 15]\n\n    [/EXAMPLES]\n    \"\"\"\n```\n", "entry_point": "optimize_network_latency", "solution": "from typing import List, Tuple\nimport heapq\n\ndef optimize_network_latency(nodes: int, connections: List[Tuple[int, int, int]], start: int) -> List[int]:\n    \"\"\"\n    As a network engineer, I need to optimize the latency in a complex computer network.\n    \n    Given the number of nodes, a list of connections (source, destination, latency),\n    and a starting node, calculate the minimum latency from the start node to every other node.\n    \n    Use Dijkstra's algorithm with a priority queue (heapq) to find the shortest paths.\n    If a node is unreachable, its latency should be represented as float('inf').\n    \n    Return a list where the index represents the node number and the value represents\n    the minimum latency from the start node to that node.\n    \n\n    [EXAMPLES]\n    \n    assert candidate(5, [(0,1,1), (1,2,2), (2,3,3), (3,4,4), (0,4,10)], 0) == [0, 1, 3, 6, 10]\n    assert candidate(6, [(0,1,1), (1,2,2), (2,3,3), (3,4,4), (4,5,5)], 0) == [0, 1, 3, 6, 10, 15]\n\n    [/EXAMPLES]\n    \"\"\"\n    # Create an adjacency list to represent the graph\n    graph = [[] for _ in range(nodes)]\n    for source, dest, latency in connections:\n        graph[source].append((dest, latency))\n    \n    # Initialize distances with infinity for all nodes except the start node\n    distances = [float('inf')] * nodes\n    distances[start] = 0\n    \n    # Priority queue to store nodes to visit (latency, node)\n    pq = [(0, start)]\n    \n    while pq:\n        current_latency, current_node = heapq.heappop(pq)\n        \n        # If we've found a longer path, skip this node\n        if current_latency > distances[current_node]:\n            continue\n        \n        # Check all neighbors of the current node\n        for neighbor, latency in graph[current_node]:\n            new_latency = current_latency + latency\n            \n            # If we've found a shorter path, update the distance\n            if new_latency < distances[neighbor]:\n                distances[neighbor] = new_latency\n                heapq.heappush(pq, (new_latency, neighbor))\n    \n    return distances\n\n", "test": "def check(candidate):\n    assert candidate(5, [(0,1,1), (1,2,2), (2,3,3), (3,4,4), (0,4,10)], 0) == [0, 1, 3, 6, 10]\n    assert candidate(5, [(0,1,10), (0,2,3), (1,3,2), (2,1,4), (2,3,8), (2,4,2), (3,4,5)], 0) == [0, 7, 3, 9, 5]\n    assert candidate(6, [(0,1,10), (1,2,20), (2,3,30), (3,4,40), (4,5,50), (5,0,60)], 0) == [0, 10, 30, 60, 100, 150]\n    assert candidate(5, [(0,1,1), (1,2,2), (2,3,3), (3,4,4), (0,4,1)], 0) == [0, 1, 3, 6, 1]\n    assert candidate(6, [(0,1,1), (1,2,2), (2,3,3), (3,4,4), (4,5,5)], 0) == [0, 1, 3, 6, 10, 15]\n    assert candidate(4, [(0,1,1), (1,2,2), (2,3,3), (3,0,4)], 2) == [7, 8, 0, 3]\n    assert candidate(4, [(0,1,1), (0,2,2), (0,3,3), (1,2,4), (1,3,5), (2,3,6)], 0) == [0, 1, 2, 3]\n    assert candidate(6, [(0,1,5), (1,2,5), (2,3,5), (3,4,5), (4,5,5), (5,0,5)], 0) == [0, 5, 10, 15, 20, 25]\n    assert candidate(3, [(0,1,1), (1,0,1), (1,2,2), (2,1,2)], 1) == [1, 0, 2]\n    assert candidate(3, [(0,1,1000000), (1,2,1000000)], 0) == [0, 1000000, 2000000]\n", "language": "python"}
{"task_id": "77407aa1-b468-45b9-a316-d6182c83e26b-400870360445269727", "prompt": "Your goal is to write a complete, executable function in a single code block. The function should only use libraries that are imported in the problem statement. Any additional helper functions or classes must be defined inside the main function. I'll deliver just one code block containing the complete implementation.\n\n```python\nfrom typing import List\n\ndef calculate_optimal_path(grid: List[List[int]]) -> int:\n    \"\"\"\n    In a robot navigation system, we need to find the optimal path through a grid-like environment.\n    The grid is represented as a 2D array where each cell contains a cost value.\n    The robot can only move right or down, and we want to minimize the total cost of the path.\n\n    This function calculates the minimum cost path from the top-left corner to the bottom-right corner of the grid.\n\n\n    [EXAMPLES]\n    \n    assert candidate([[1, 2], [3, 4]]) == 7\n    assert candidate([[1, 1, 1, 1], [1, 1, 1, 1], [1, 1, 1, 1], [1, 1, 1, 1]]) == 7\n\n    [/EXAMPLES]\n    \"\"\"\n```\n", "entry_point": "calculate_optimal_path", "solution": "from typing import List\n\ndef calculate_optimal_path(grid: List[List[int]]) -> int:\n    \"\"\"\n    In a robot navigation system, we need to find the optimal path through a grid-like environment.\n    The grid is represented as a 2D array where each cell contains a cost value.\n    The robot can only move right or down, and we want to minimize the total cost of the path.\n\n    This function calculates the minimum cost path from the top-left corner to the bottom-right corner of the grid.\n\n\n    [EXAMPLES]\n    \n    assert candidate([[1, 2], [3, 4]]) == 7\n    assert candidate([[1, 1, 1, 1], [1, 1, 1, 1], [1, 1, 1, 1], [1, 1, 1, 1]]) == 7\n\n    [/EXAMPLES]\n    \"\"\"\n    if not grid or not grid[0]:\n        return 0\n\n    rows, cols = len(grid), len(grid[0])\n    \n    # Create a dp table to store minimum costs\n    dp = [[0] * cols for _ in range(rows)]\n    \n    # Initialize the first cell\n    dp[0][0] = grid[0][0]\n    \n    # Initialize the first row\n    for j in range(1, cols):\n        dp[0][j] = dp[0][j-1] + grid[0][j]\n    \n    # Initialize the first column\n    for i in range(1, rows):\n        dp[i][0] = dp[i-1][0] + grid[i][0]\n    \n    # Fill the dp table\n    for i in range(1, rows):\n        for j in range(1, cols):\n            dp[i][j] = min(dp[i-1][j], dp[i][j-1]) + grid[i][j]\n    \n    # Return the minimum cost to reach the bottom-right corner\n    return dp[rows-1][cols-1]\n\n", "test": "def check(candidate):\n    assert candidate([[1, 2], [3, 4], [5, 6], [7, 8]]) == 21\n    assert candidate([[1, 1, 1], [1, 1, 1], [1, 1, 1]]) == 5\n    assert candidate([[1, 2, 3, 4, 5]]) == 15\n    assert candidate([[i+j for j in range(10)] for i in range(0, 100, 10)]) == 576\n    assert candidate([[100, 1, 1, 1], [1, 100, 1, 1], [1, 1, 100, 1], [1, 1, 1, 1]]) == 106\n    assert candidate([[1, 2], [3, 4]]) == 7\n    assert candidate([[1, 3, 1], [1, 5, 1], [4, 2, 1]]) == 7\n    assert candidate([[0, 0], [0, 0]]) == 0\n    assert candidate([[1], [2], [3], [4], [5]]) == 15\n    assert candidate([[1, 1, 1, 1], [1, 1, 1, 1], [1, 1, 1, 1], [1, 1, 1, 1]]) == 7\n", "language": "python"}
{"task_id": "73d98a5b-6aee-40d5-915a-aaf11e286302-4671715962125332647", "prompt": "I need you to implement the requested function within a single code block. The implementation should be fully executable and stick only to the libraries specified in the problem. Any helper functions or classes needed should be defined inside the main function. I'll provide just one code block containing the complete solution.\n\n```python\nfrom collections import deque\nfrom typing import List, Tuple\n\ndef analyze_stock_prices(prices: List[float], time_window: int) -> List[Tuple[float, float]]:\n    \"\"\"\n    A financial analyst needs to analyze stock prices over time. They want to identify the maximum and minimum prices within a sliding time window.\n\n    This function takes a list of stock prices and a time window size. It returns a list of tuples, where each tuple contains the maximum and minimum prices within the specified time window as it slides over the price data.\n\n    Parameters:\n    prices (List[float]): A list of stock prices in chronological order.\n    time_window (int): The size of the sliding time window.\n\n    Returns:\n    List[Tuple[float, float]]: A list of tuples, each containing the maximum and minimum prices within the sliding time window.\n\n\n    [EXAMPLES]\n    \n    assert candidate([1.5, 2.5, 1.5, 2.5, 1.5], 3) == [(2.5, 1.5), (2.5, 1.5), (2.5, 1.5)]\n    assert candidate([100.0, 99.5, 101.0, 98.0, 97.5, 102.0, 103.5], 2) == [(100.0, 99.5), (101.0, 99.5), (101.0, 98.0), (98.0, 97.5), (102.0, 97.5), (103.5, 102.0)]\n\n    [/EXAMPLES]\n    \"\"\"\n```\n", "entry_point": "analyze_stock_prices", "solution": "from collections import deque\nfrom typing import List, Tuple\n\ndef analyze_stock_prices(prices: List[float], time_window: int) -> List[Tuple[float, float]]:\n    \"\"\"\n    A financial analyst needs to analyze stock prices over time. They want to identify the maximum and minimum prices within a sliding time window.\n\n    This function takes a list of stock prices and a time window size. It returns a list of tuples, where each tuple contains the maximum and minimum prices within the specified time window as it slides over the price data.\n\n    Parameters:\n    prices (List[float]): A list of stock prices in chronological order.\n    time_window (int): The size of the sliding time window.\n\n    Returns:\n    List[Tuple[float, float]]: A list of tuples, each containing the maximum and minimum prices within the sliding time window.\n\n\n    [EXAMPLES]\n    \n    assert candidate([1.5, 2.5, 1.5, 2.5, 1.5], 3) == [(2.5, 1.5), (2.5, 1.5), (2.5, 1.5)]\n    assert candidate([100.0, 99.5, 101.0, 98.0, 97.5, 102.0, 103.5], 2) == [(100.0, 99.5), (101.0, 99.5), (101.0, 98.0), (98.0, 97.5), (102.0, 97.5), (103.5, 102.0)]\n\n    [/EXAMPLES]\n    \"\"\"\n    if not prices or time_window <= 0 or time_window > len(prices):\n        return []\n\n    result = []\n    max_deque = deque()\n    min_deque = deque()\n\n    for i in range(len(prices)):\n        # Remove elements outside the current window from the deques\n        if max_deque and max_deque[0] <= i - time_window:\n            max_deque.popleft()\n        if min_deque and min_deque[0] <= i - time_window:\n            min_deque.popleft()\n\n        # Remove smaller elements from the end of max_deque\n        while max_deque and prices[max_deque[-1]] <= prices[i]:\n            max_deque.pop()\n        max_deque.append(i)\n\n        # Remove larger elements from the end of min_deque\n        while min_deque and prices[min_deque[-1]] >= prices[i]:\n            min_deque.pop()\n        min_deque.append(i)\n\n        # Add the max and min for the current window to the result\n        if i >= time_window - 1:\n            result.append((prices[max_deque[0]], prices[min_deque[0]]))\n\n    return result\n\n", "test": "def check(candidate):\n    assert candidate([1000.0, 999.9, 999.8, 999.7, 999.6], 2) == [(1000.0, 999.9), (999.9, 999.8), (999.8, 999.7), (999.7, 999.6)]\n    assert candidate([100.0], 1) == [(100.0, 100.0)]\n    assert candidate([10.0, 10.0, 10.0, 10.0], 2) == [(10.0, 10.0), (10.0, 10.0), (10.0, 10.0)]\n    assert candidate([1.5, 2.5, 1.5, 2.5, 1.5], 3) == [(2.5, 1.5), (2.5, 1.5), (2.5, 1.5)]\n    assert candidate([10.0, 12.5, 11.0, 13.5, 14.0, 13.0, 12.0, 11.5], 3) == [(12.5, 10.0), (13.5, 11.0), (14.0, 11.0), (14.0, 13.0), (14.0, 12.0), (13.0, 11.5)]\n    assert candidate([100.0, 90.0, 80.0, 70.0, 60.0], 3) == [(100.0, 80.0), (90.0, 70.0), (80.0, 60.0)]\n    assert candidate([1.1, 2.2, 3.3, 4.4, 5.5, 6.6, 7.7, 8.8, 9.9], 5) == [(5.5, 1.1), (6.6, 2.2), (7.7, 3.3), (8.8, 4.4), (9.9, 5.5)]\n    assert candidate([10.0, 20.0, 30.0, 40.0, 50.0, 60.0, 70.0, 80.0, 90.0, 100.0], 6) == [(60.0, 10.0), (70.0, 20.0), (80.0, 30.0), (90.0, 40.0), (100.0, 50.0)]\n    assert candidate([100.0, 200.0, 300.0, 400.0, 500.0], 2) == [(200.0, 100.0), (300.0, 200.0), (400.0, 300.0), (500.0, 400.0)]\n    assert candidate([100.0, 99.5, 101.0, 98.0, 97.5, 102.0, 103.5], 2) == [(100.0, 99.5), (101.0, 99.5), (101.0, 98.0), (98.0, 97.5), (102.0, 97.5), (103.5, 102.0)]\n", "language": "python"}
{"task_id": "b7dc07a9-715a-4c54-a5ba-9be31f2d082d-5878934240513549476", "prompt": "My purpose is to help you with code completion. I'll provide a solution for the function you share, making sure it's ready to run in a code block. I'll only use libraries mentioned in the problem and keep any additional code elements inside the given function.\n\n```python\nfrom typing import List\n\ndef predict_algae_bloom(nutrient_levels: List[float], water_temp: float, sunlight_hours: float) -> bool:\n    \"\"\"\n    Predict the likelihood of an algae bloom in a lake based on environmental factors.\n\n    This function uses a combination of nutrient levels in the water, water temperature,\n    and daily sunlight hours to determine if conditions are favorable for an algae bloom.\n\n    Args:\n    nutrient_levels (List[float]): A list of float values representing levels of different nutrients in the water.\n    water_temp (float): The current water temperature in Celsius.\n    sunlight_hours (float): The average number of sunlight hours per day.\n\n    Returns:\n    bool: True if an algae bloom is likely, False otherwise.\n\n\n    [EXAMPLES]\n    \n    assert candidate([0.01, 0.01, 0.01], 15.0, 6.0) == False\n    assert candidate([0.9, 0.7, 0.5], 31.0, 14.5) == True\n\n    [/EXAMPLES]\n    \"\"\"\n```\n", "entry_point": "predict_algae_bloom", "solution": "from typing import List\n\ndef predict_algae_bloom(nutrient_levels: List[float], water_temp: float, sunlight_hours: float) -> bool:\n    \"\"\"\n    Predict the likelihood of an algae bloom in a lake based on environmental factors.\n\n    This function uses a combination of nutrient levels in the water, water temperature,\n    and daily sunlight hours to determine if conditions are favorable for an algae bloom.\n\n    Args:\n    nutrient_levels (List[float]): A list of float values representing levels of different nutrients in the water.\n    water_temp (float): The current water temperature in Celsius.\n    sunlight_hours (float): The average number of sunlight hours per day.\n\n    Returns:\n    bool: True if an algae bloom is likely, False otherwise.\n\n\n    [EXAMPLES]\n    \n    assert candidate([0.01, 0.01, 0.01], 15.0, 6.0) == False\n    assert candidate([0.9, 0.7, 0.5], 31.0, 14.5) == True\n\n    [/EXAMPLES]\n    \"\"\"\n    def calculate_nutrient_score(levels):\n        weights = [0.5, 0.3, 0.2]  # Weights for different nutrients\n        return sum(level * weight for level, weight in zip(levels, weights))\n\n    # Thresholds for each factor\n    NUTRIENT_THRESHOLD = 0.15\n    TEMP_THRESHOLD = 20.0\n    SUNLIGHT_THRESHOLD = 10.0\n\n    # Calculate scores\n    nutrient_score = calculate_nutrient_score(nutrient_levels)\n\n    # Check if all conditions are met for an algae bloom\n    if (nutrient_score >= NUTRIENT_THRESHOLD and\n        water_temp >= TEMP_THRESHOLD and\n        sunlight_hours >= SUNLIGHT_THRESHOLD):\n        return True\n    else:\n        return False\n\n", "test": "def check(candidate):\n    assert candidate([0.9, 0.7, 0.5], 31.0, 14.5) == True\n    assert candidate([1.5, 1.0, 0.8], 33.0, 15.0) == True\n    assert candidate([0.5, 0.2, 0.1], 30.0, 14.0) == True\n    assert candidate([0.02, 0.015, 0.01], 17.0, 7.5) == False\n    assert candidate([0.4, 0.3, 0.2], 26.0, 11.5) == True\n    assert candidate([0.2, 0.15, 0.1], 22.5, 10.0) == True\n    assert candidate([0.25, 0.2, 0.15], 24.0, 11.0) == True\n    assert candidate([0.01, 0.01, 0.01], 15.0, 6.0) == False\n    assert candidate([0.7, 0.5, 0.3], 29.0, 13.0) == True\n    assert candidate([0.3, 0.1, 0.05], 25.5, 12.0) == True\n", "language": "python"}
{"task_id": "88e68f1e-f024-4997-82bb-541910055db63450623633640768196", "prompt": "Implement the function based on the docstring specification. Keep the function name and parameters unchanged. Here's the complete function in a single code block:\n\n```python\nfrom typing import List\n\ndef encrypt_message(message: str, key: List[int]) -> str:\n    \"\"\"\n    Encrypt a message using a custom cyclic substitution cipher.\n\n    This function takes a message and a key (list of integers) as input. It then\n    applies a cyclic substitution cipher to encrypt the message. Each character\n    in the message is shifted by the corresponding value in the key. If the key\n    is shorter than the message, it is repeated cyclically.\n\n    The function utilizes list comprehension and the modulo operator to perform\n    the character shifting and ensure the result stays within the ASCII printable\n    character range.\n\n    Args:\n    message (str): The message to be encrypted.\n    key (List[int]): A list of integers representing the encryption key.\n\n    Returns:\n    str: The encrypted message.\n\n\n    [EXAMPLES]\n    \n    assert candidate(\"Mixed 123 !@#\", [1, 2, 3, 4]) == 'Nk{ie\"464\"$D$'\n    assert candidate(\"ASCII boundaries\", [31, 95, -31, -95]) == '`S$Ih Co5nEa2iFs'\n\n    [/EXAMPLES]\n    \"\"\"\n```\n", "entry_point": "encrypt_message", "solution": "from typing import List\n\ndef encrypt_message(message: str, key: List[int]) -> str:\n    \"\"\"\n    Encrypt a message using a custom cyclic substitution cipher.\n\n    This function takes a message and a key (list of integers) as input. It then\n    applies a cyclic substitution cipher to encrypt the message. Each character\n    in the message is shifted by the corresponding value in the key. If the key\n    is shorter than the message, it is repeated cyclically.\n\n    The function utilizes list comprehension and the modulo operator to perform\n    the character shifting and ensure the result stays within the ASCII printable\n    character range.\n\n    Args:\n    message (str): The message to be encrypted.\n    key (List[int]): A list of integers representing the encryption key.\n\n    Returns:\n    str: The encrypted message.\n\n\n    [EXAMPLES]\n    \n    assert candidate(\"Mixed 123 !@#\", [1, 2, 3, 4]) == 'Nk{ie\"464\"$D$'\n    assert candidate(\"ASCII boundaries\", [31, 95, -31, -95]) == '`S$Ih Co5nEa2iFs'\n\n    [/EXAMPLES]\n    \"\"\"\n    def shift_char(char: str, shift: int) -> str:\n        if not char.isascii() or not char.isprintable():\n            return char\n        ascii_offset = 32  # Start of printable ASCII characters\n        ascii_range = 95   # Number of printable ASCII characters\n        char_code = ord(char) - ascii_offset\n        shifted_code = (char_code + shift) % ascii_range\n        return chr(shifted_code + ascii_offset)\n\n    key_length = len(key)\n    encrypted_chars = [shift_char(char, key[i % key_length]) for i, char in enumerate(message)]\n    return ''.join(encrypted_chars)\n\n", "test": "def check(candidate):\n    assert candidate(\"Short\", [100, 200, 300, 400, 500]) == \"Xr~'.\"\n    assert candidate(\"Test\", [-1, 0, 1]) == 'Sets'\n    assert candidate(\"Long message with spaces\", [0]) == 'Long message with spaces'\n    assert candidate(\"ABCDEFGHIJKLMNOPQRSTUVWXYZ\", [-1]) == '@ABCDEFGHIJKLMNOPQRSTUVWXY'\n    assert candidate(\"Hello\", [1]) == 'Ifmmp'\n    assert candidate(\"Multiple\\nLines\\nTest\", [5]) == 'Rzqynuqj\\nQnsjx\\nYjxy'\n    assert candidate(\"ASCII boundaries\", [31, 95, -31, -95]) == '`S$Ih Co5nEa2iFs'\n    assert candidate(\"Emoji test \ud83d\ude00\ud83d\ude03\ud83d\ude04\", [1, 2, 3]) == 'Forkk#ugvu\"\ud83d\ude00\ud83d\ude03\ud83d\ude04'\n    assert candidate(\"Mixed 123 !@#\", [1, 2, 3, 4]) == 'Nk{ie\"464\"$D$'\n    assert candidate(\"A\", [0]) == 'A'\n", "language": "python"}
{"task_id": "c46a7384-551e-4819-b952-75872d99ac9b-8088266918243152909", "prompt": "Based on the function's documentation, I'll develop the complete implementation in a single code block, with proper handling of edge cases.\n\n```python\nfrom typing import List, Tuple\n\ndef optimize_stock_trades(prices: List[int], max_trades: int) -> Tuple[int, List[Tuple[int, int]]]:\n    \"\"\"\n    Determine the optimal trading strategy to maximize profit given a list of stock prices and a maximum number of trades.\n\n    You are given a list of stock prices, where prices[i] is the price of the stock on the i-th day.\n    You can make at most max_trades transactions, and you must sell the stock before you buy again\n    (i.e., you cannot have multiple open positions at the same time).\n\n    Return a tuple containing the maximum profit achievable and a list of tuples representing the buy and sell days for each trade.\n\n    :param prices: A list of integers representing daily stock prices\n    :param max_trades: The maximum number of trades allowed\n    :return: A tuple containing the maximum profit (int) and a list of tuples representing buy and sell days for each trade\n\n\n    [EXAMPLES]\n    \n    assert candidate([1, 2, 3, 4, 5], 0) == (0, [])\n    assert candidate([10, 9, 8, 7, 6], 3) == (0, [])\n\n    [/EXAMPLES]\n    \"\"\"\n```\n", "entry_point": "optimize_stock_trades", "solution": "from typing import List, Tuple\n\ndef optimize_stock_trades(prices: List[int], max_trades: int) -> Tuple[int, List[Tuple[int, int]]]:\n    \"\"\"\n    Determine the optimal trading strategy to maximize profit given a list of stock prices and a maximum number of trades.\n\n    You are given a list of stock prices, where prices[i] is the price of the stock on the i-th day.\n    You can make at most max_trades transactions, and you must sell the stock before you buy again\n    (i.e., you cannot have multiple open positions at the same time).\n\n    Return a tuple containing the maximum profit achievable and a list of tuples representing the buy and sell days for each trade.\n\n    :param prices: A list of integers representing daily stock prices\n    :param max_trades: The maximum number of trades allowed\n    :return: A tuple containing the maximum profit (int) and a list of tuples representing buy and sell days for each trade\n\n\n    [EXAMPLES]\n    \n    assert candidate([1, 2, 3, 4, 5], 0) == (0, [])\n    assert candidate([10, 9, 8, 7, 6], 3) == (0, [])\n\n    [/EXAMPLES]\n    \"\"\"\n    if not prices or max_trades == 0:\n        return 0, []\n\n    n = len(prices)\n    \n    # Initialize the dp table\n    dp = [[0] * n for _ in range(max_trades + 1)]\n    \n    # Initialize the trades table to keep track of buy and sell days\n    trades = [[[]] * n for _ in range(max_trades + 1)]\n\n    for k in range(1, max_trades + 1):\n        max_diff = -prices[0]\n        for i in range(1, n):\n            dp[k][i] = max(dp[k][i-1], prices[i] + max_diff)\n            \n            if prices[i] + max_diff > dp[k][i-1]:\n                for j in range(i):\n                    if max_diff == dp[k-1][j] - prices[j]:\n                        trades[k][i] = trades[k-1][j] + [(j, i)]\n                        break\n            else:\n                trades[k][i] = trades[k][i-1]\n            \n            max_diff = max(max_diff, dp[k-1][i] - prices[i])\n\n    max_profit = dp[max_trades][n-1]\n    optimal_trades = trades[max_trades][n-1]\n\n    return max_profit, optimal_trades\n\n\n", "test": "def check(candidate):\n    assert candidate([5, 4, 3, 2, 1], 2) == (0, [])\n    assert candidate([1], 1) == (0, [])\n    assert candidate([1, 2, 3, 2, 1, 2, 3, 2, 1], 4) == (4, [(0, 2), (4, 6)])\n    assert candidate([3, 2, 6, 5, 0, 3, 1, 4], 2) == (8, [(1, 2), (4, 7)])\n    assert candidate([10, 9, 8, 7, 6], 3) == (0, [])\n    assert candidate([7, 1, 5, 3, 6, 4], 2) == (7, [(1, 2), (3, 4)])\n    assert candidate([1, 2, 3, 4, 5, 6, 7, 8, 9, 10], 5) == (9, [(0, 9)])\n    assert candidate([10, 9, 8, 7, 6, 5, 4, 3, 2, 1], 5) == (0, [])\n    assert candidate([3, 3, 5, 0, 0, 3, 1, 4], 2) == (6, [(0, 2), (3, 7)])\n    assert candidate([1, 2, 3, 4, 5], 0) == (0, [])\n", "language": "python"}
{"task_id": "8f3df380-63e2-43f8-8bbe-22f1e3942296-7153414567615626695", "prompt": "As your coding assistant, I'll complete the function you provide in an executable code block. I'll restrict myself to using only the libraries imported in the problem description and will nest any additional functions or classes inside the main function.\n\n```python\nfrom typing import List, Tuple, Dict\nfrom typing import List, Tuple\n\ndef analyze_plant_growth(measurements: List[Tuple[int, float]]) -> Dict[str, float]:\n    \"\"\"\n    Analyze the growth pattern of a rare orchid species in a botanical garden.\n\n    This function takes a list of tuples containing day number and plant height measurements,\n    and returns a dictionary with various growth statistics.\n\n    The function utilizes list comprehension and dictionary comprehension to process the data.\n\n    Parameters:\n    measurements (List[Tuple[int, float]]): A list of tuples where each tuple contains\n                                            (day_number, plant_height_in_cm)\n\n    Returns:\n    Dict[str, float]: A dictionary containing the following keys:\n                      - 'average_growth_rate': Average daily growth rate in cm\n                      - 'max_growth_spurt': Maximum growth between two consecutive measurements in cm\n                      - 'total_growth': Total growth from first to last measurement in cm\n\n\n    [EXAMPLES]\n    \n    assert candidate([(1, 1.0), (2, 3.0), (3, 2.0), (4, 4.0), (5, 3.0)]) == {'average_growth_rate': 0.5, 'max_growth_spurt': 2.0, 'total_growth': 2.0}\n    assert candidate([(1, 10.0), (10, 11.0), (100, 12.0), (1000, 13.0)]) == {'average_growth_rate': 0.003, 'max_growth_spurt': 1.0, 'total_growth': 3.0}\n\n    [/EXAMPLES]\n    \"\"\"\n```\n", "entry_point": "analyze_plant_growth", "solution": "from typing import List, Tuple, Dict\nfrom typing import List, Tuple\n\ndef analyze_plant_growth(measurements: List[Tuple[int, float]]) -> Dict[str, float]:\n    \"\"\"\n    Analyze the growth pattern of a rare orchid species in a botanical garden.\n\n    This function takes a list of tuples containing day number and plant height measurements,\n    and returns a dictionary with various growth statistics.\n\n    The function utilizes list comprehension and dictionary comprehension to process the data.\n\n    Parameters:\n    measurements (List[Tuple[int, float]]): A list of tuples where each tuple contains\n                                            (day_number, plant_height_in_cm)\n\n    Returns:\n    Dict[str, float]: A dictionary containing the following keys:\n                      - 'average_growth_rate': Average daily growth rate in cm\n                      - 'max_growth_spurt': Maximum growth between two consecutive measurements in cm\n                      - 'total_growth': Total growth from first to last measurement in cm\n\n\n    [EXAMPLES]\n    \n    assert candidate([(1, 1.0), (2, 3.0), (3, 2.0), (4, 4.0), (5, 3.0)]) == {'average_growth_rate': 0.5, 'max_growth_spurt': 2.0, 'total_growth': 2.0}\n    assert candidate([(1, 10.0), (10, 11.0), (100, 12.0), (1000, 13.0)]) == {'average_growth_rate': 0.003, 'max_growth_spurt': 1.0, 'total_growth': 3.0}\n\n    [/EXAMPLES]\n    \"\"\"\n    # Sort measurements by day number to ensure correct order\n    sorted_measurements = sorted(measurements, key=lambda x: x[0])\n    \n    # Calculate total growth\n    total_growth = sorted_measurements[-1][1] - sorted_measurements[0][1]\n    \n    # Calculate total days\n    total_days = sorted_measurements[-1][0] - sorted_measurements[0][0]\n    \n    # Calculate average growth rate\n    average_growth_rate = total_growth / total_days if total_days > 0 else 0\n    \n    # Calculate growth spurts between consecutive measurements\n    growth_spurts = [sorted_measurements[i+1][1] - sorted_measurements[i][1] \n                     for i in range(len(sorted_measurements) - 1)]\n    \n    # Find maximum growth spurt\n    max_growth_spurt = max(growth_spurts) if growth_spurts else 0\n    \n    # Create and return the result dictionary\n    return {\n        'average_growth_rate': round(average_growth_rate, 3),\n        'max_growth_spurt': round(max_growth_spurt, 1),\n        'total_growth': round(total_growth, 1)\n    }\n\n", "test": "def check(candidate):\n    assert candidate([(1, 1.0), (2, 3.0), (3, 2.0), (4, 4.0), (5, 3.0)]) == {'average_growth_rate': 0.5, 'max_growth_spurt': 2.0, 'total_growth': 2.0}\n    assert candidate([(1, 5.0), (2, 7.0), (3, 6.0), (4, 8.0), (5, 7.5)]) == {'average_growth_rate': 0.625, 'max_growth_spurt': 2.0, 'total_growth': 2.5}\n    assert candidate([(1, 20.0), (2, 19.8), (3, 19.9), (4, 20.1), (5, 20.3)]) == {'average_growth_rate': 0.075, 'max_growth_spurt': 0.2, 'total_growth': 0.3}\n    assert candidate([(1, 5.0), (2, 5.1), (3, 5.3), (4, 5.6), (5, 6.0)]) == {'average_growth_rate': 0.25, 'max_growth_spurt': 0.4, 'total_growth': 1.0}\n    assert candidate([(1, 0.5), (10, 1.0), (20, 1.5), (30, 2.0), (40, 2.5)]) == {'average_growth_rate': 0.051, 'max_growth_spurt': 0.5, 'total_growth': 2.0}\n    assert candidate([(1, 100.0), (2, 99.0), (3, 98.0), (4, 97.0), (5, 96.0)]) == {'average_growth_rate': -1.0, 'max_growth_spurt': -1.0, 'total_growth': -4.0}\n    assert candidate([(1, 10.0), (10, 11.0), (100, 12.0), (1000, 13.0)]) == {'average_growth_rate': 0.003, 'max_growth_spurt': 1.0, 'total_growth': 3.0}\n    assert candidate([(1, 1.0), (2, 1.1), (3, 1.2), (4, 1.3), (5, 1.4)]) == {'average_growth_rate': 0.1, 'max_growth_spurt': 0.1, 'total_growth': 0.4}\n    assert candidate([(1, 1.0), (2, 2.0), (3, 4.0), (4, 8.0), (5, 16.0)]) == {'average_growth_rate': 3.75, 'max_growth_spurt': 8.0, 'total_growth': 15.0}\n    assert candidate([(1, 0.0), (2, 0.1), (3, 0.3), (4, 0.6), (5, 1.0)]) == {'average_growth_rate': 0.25, 'max_growth_spurt': 0.4, 'total_growth': 1.0}\n", "language": "python"}
{"task_id": "eeb6d7b3-bdb9-4247-8169-be20cb77d6405665635261102438166", "prompt": "I'll implement the function described in the docstring, ensuring all edge cases are considered. The complete implementation will be provided in one code block.\n\n```python\nfrom typing import List\nimport heapq\n\ndef network_latency(connections: List[tuple], nodes: int, start: int, end: int) -> float:\n    \"\"\"In a computer network, calculate the minimum latency between two nodes.\n    Each connection has a source node, destination node, and latency in milliseconds.\n    Connections are bidirectional.\n\n    Parameters:\n    connections (List[tuple]): List of (source, destination, latency) for each connection\n    nodes (int): Total number of nodes in the network\n    start (int): Starting node\n    end (int): Destination node\n\n    Returns:\n    float: Minimum latency between start and end nodes in milliseconds, or -1 if no path exists\n\n\n    [EXAMPLES]\n    \n    assert candidate([(0, 1, 1), (1, 2, 1)], 3, 0, 2) == 2.0\n    assert candidate([(0, 1, 100), (1, 2, 100), (2, 3, 100), (0, 3, 250)], 4, 0, 3) == 250.0\n\n    [/EXAMPLES]\n    \"\"\"\n```\n", "entry_point": "network_latency", "solution": "from typing import List\nimport heapq\n\ndef network_latency(connections: List[tuple], nodes: int, start: int, end: int) -> float:\n    \"\"\"In a computer network, calculate the minimum latency between two nodes.\n    Each connection has a source node, destination node, and latency in milliseconds.\n    Connections are bidirectional.\n\n    Parameters:\n    connections (List[tuple]): List of (source, destination, latency) for each connection\n    nodes (int): Total number of nodes in the network\n    start (int): Starting node\n    end (int): Destination node\n\n    Returns:\n    float: Minimum latency between start and end nodes in milliseconds, or -1 if no path exists\n\n\n    [EXAMPLES]\n    \n    assert candidate([(0, 1, 1), (1, 2, 1)], 3, 0, 2) == 2.0\n    assert candidate([(0, 1, 100), (1, 2, 100), (2, 3, 100), (0, 3, 250)], 4, 0, 3) == 250.0\n\n    [/EXAMPLES]\n    \"\"\"\n    # Create an adjacency list to represent the network\n    graph = {i: [] for i in range(nodes)}\n    for source, dest, latency in connections:\n        graph[source].append((dest, latency))\n        graph[dest].append((source, latency))  # Bidirectional connection\n\n    # Initialize distances and priority queue\n    distances = [float('inf')] * nodes\n    distances[start] = 0\n    pq = [(0, start)]\n\n    while pq:\n        current_latency, current_node = heapq.heappop(pq)\n\n        if current_node == end:\n            return float(current_latency)\n\n        if current_latency > distances[current_node]:\n            continue\n\n        for neighbor, latency in graph[current_node]:\n            new_latency = current_latency + latency\n            if new_latency < distances[neighbor]:\n                distances[neighbor] = new_latency\n                heapq.heappush(pq, (new_latency, neighbor))\n\n    return -1.0  # No path found\n\n", "test": "def check(candidate):\n    assert candidate([(0, 1, 100), (1, 2, 100), (2, 3, 100), (0, 3, 250)], 4, 0, 3) == 250.0\n    assert candidate([(0, 1, 5), (1, 2, 5), (0, 2, 11)], 3, 0, 2) == 10.0\n    assert candidate([(0, 1, 1), (1, 2, 1), (2, 3, 1)], 4, 0, 3) == 3.0\n    assert candidate([(0, 1, 10), (0, 2, 5), (1, 2, 2), (1, 3, 1), (2, 3, 6)], 4, 0, 3) == 8.0\n    assert candidate([(0, 1, 1), (1, 2, 1), (2, 3, 1), (3, 0, 1)], 4, 0, 2) == 2.0\n    assert candidate([(0, 1, 1), (1, 2, 1)], 3, 0, 2) == 2.0\n    assert candidate([(0, 1, 1)], 2, 1, 0) == 1.0\n    assert candidate([(0, 1, 1.5), (1, 2, 2.5), (2, 3, 3.5)], 4, 0, 3) == 7.5\n    assert candidate([(0, 1, 1000000), (1, 2, 1000000)], 3, 0, 2) == 2000000.0\n    assert candidate([], 1, 0, 0) == 0.0\n", "language": "python"}
{"task_id": "04720bec-e9d2-49a8-ae72-17618779203c4212816794498729751", "prompt": "Please complete the requested function so that it can be executed directly. Include all necessary helper functions or classes within the main function definition. The solution should be contained in a single code block and only use libraries that are imported in the problem statement. Do not add any code outside the function definition.\n\n```python\nfrom typing import List, Dict\n\ndef decode_alien_message(sequence: List[int], codebook: Dict[int, str]) -> str:\n    \"\"\"You are a cryptographer working for a space agency. You've intercepted a sequence of numbers\n    believed to be a message from an alien civilization. Your task is to decode this message using\n    a provided codebook that maps numbers to letters or symbols.\n\n    The sequence may contain repeating patterns, and some numbers might not have a corresponding\n    entry in the codebook. Your function should decode the message, ignoring any numbers not in\n    the codebook, and return the decoded string.\n\n\n    [EXAMPLES]\n    \n    assert candidate([1, 2, 3, 4, 5], {1: ' ', 2: 'H', 3: 'i', 4: '!', 5: ' '}) == ' Hi! '\n    assert candidate([1, 1, 2, 3, 5, 8, 13], {1: 'F', 2: 'I', 3: 'B', 5: 'O', 8: 'N', 13: 'A'}) == 'FFIBONA'\n\n    [/EXAMPLES]\n    \"\"\"\n```\n", "entry_point": "decode_alien_message", "solution": "from typing import List, Dict\n\ndef decode_alien_message(sequence: List[int], codebook: Dict[int, str]) -> str:\n    \"\"\"You are a cryptographer working for a space agency. You've intercepted a sequence of numbers\n    believed to be a message from an alien civilization. Your task is to decode this message using\n    a provided codebook that maps numbers to letters or symbols.\n\n    The sequence may contain repeating patterns, and some numbers might not have a corresponding\n    entry in the codebook. Your function should decode the message, ignoring any numbers not in\n    the codebook, and return the decoded string.\n\n\n    [EXAMPLES]\n    \n    assert candidate([1, 2, 3, 4, 5], {1: ' ', 2: 'H', 3: 'i', 4: '!', 5: ' '}) == ' Hi! '\n    assert candidate([1, 1, 2, 3, 5, 8, 13], {1: 'F', 2: 'I', 3: 'B', 5: 'O', 8: 'N', 13: 'A'}) == 'FFIBONA'\n\n    [/EXAMPLES]\n    \"\"\"\n    decoded_message = []\n    \n    for number in sequence:\n        if number in codebook:\n            decoded_message.append(codebook[number])\n    \n    return ''.join(decoded_message)\n\n", "test": "def check(candidate):\n    assert candidate([42, 13, 7, 42, 13, 7, 99, 42, 13, 7], {7: 'S', 13: 'O', 42: 'S'}) == 'SOSSOSSOS'\n    assert candidate([3, 1, 4, 1, 5, 9, 2, 6, 5, 3, 5], {1: 'A', 3: 'E', 4: 'I', 5: 'O', 9: 'U'}) == 'EAIAOUOEO'\n    assert candidate([1, 2, 3, 4, 5], {1: ' ', 2: 'H', 3: 'i', 4: '!', 5: ' '}) == ' Hi! '\n    assert candidate([], {1: 'A', 2: 'B', 3: 'C'}) == ''\n    assert candidate([999, 888, 777, 666, 555], {999: 'S', 777: 'O', 555: 'S'}) == 'SOS'\n    assert candidate([1, 2, 3, 2, 1], {1: 'A', 2: 'B', 3: 'C'}) == 'ABCBA'\n    assert candidate([100, 200, 300, 400, 500], {100: 'V', 200: 'W', 300: 'X', 400: 'Y', 500: 'Z'}) == 'VWXYZ'\n    assert candidate([10, 20, 30, 40, 50], {10: 'Q', 30: 'W', 50: 'E'}) == 'QWE'\n    assert candidate([1, 2, 3, 4, 5, 6, 7, 8, 9, 10], {2: 'A', 4: 'B', 6: 'C', 8: 'D', 10: 'E'}) == 'ABCDE'\n    assert candidate([1, 1, 2, 3, 5, 8, 13], {1: 'F', 2: 'I', 3: 'B', 5: 'O', 8: 'N', 13: 'A'}) == 'FFIBONA'\n", "language": "python"}
{"task_id": "38f2efc3-eced-46c5-87b5-e497107a967a7248035768598435082", "prompt": "Given a function definition, I'll provide a complete implementation that can run by itself. I'll stay strictly within the function scope and only use the already imported libraries. Any additional functions or classes needed will be defined within the main function.\n\n```python\ndef roman_numeral_converter(num: int) -> str:\n    \"\"\"\n    In the context of ancient Roman mathematics, this function converts a given\n    integer to its Roman numeral representation.\n\n    The function takes an integer as input and returns a string representing\n    the Roman numeral equivalent. The input number should be between 1 and 3999.\n\n\n    [EXAMPLES]\n    \n    assert candidate(2023) == 'MMXXIII'\n    assert candidate(99) == 'XCIX'\n\n    [/EXAMPLES]\n    \"\"\"\n```\n", "entry_point": "roman_numeral_converter", "solution": "def roman_numeral_converter(num: int) -> str:\n    \"\"\"\n    In the context of ancient Roman mathematics, this function converts a given\n    integer to its Roman numeral representation.\n\n    The function takes an integer as input and returns a string representing\n    the Roman numeral equivalent. The input number should be between 1 and 3999.\n\n\n    [EXAMPLES]\n    \n    assert candidate(2023) == 'MMXXIII'\n    assert candidate(99) == 'XCIX'\n\n    [/EXAMPLES]\n    \"\"\"\n    if not 1 <= num <= 3999:\n        raise ValueError(\"Input number must be between 1 and 3999\")\n\n    roman_values = [\n        (1000, \"M\"),\n        (900, \"CM\"),\n        (500, \"D\"),\n        (400, \"CD\"),\n        (100, \"C\"),\n        (90, \"XC\"),\n        (50, \"L\"),\n        (40, \"XL\"),\n        (10, \"X\"),\n        (9, \"IX\"),\n        (5, \"V\"),\n        (4, \"IV\"),\n        (1, \"I\")\n    ]\n\n    result = \"\"\n    for value, symbol in roman_values:\n        while num >= value:\n            result += symbol\n            num -= value\n\n    return result\n\n", "test": "def check(candidate):\n    assert candidate(888) == 'DCCCLXXXVIII'\n    assert candidate(99) == 'XCIX'\n    assert candidate(1000) == 'M'\n    assert candidate(3999) == 'MMMCMXCIX'\n    assert candidate(2023) == 'MMXXIII'\n    assert candidate(9) == 'IX'\n    assert candidate(777) == 'DCCLXXVII'\n    assert candidate(444) == 'CDXLIV'\n    assert candidate(999) == 'CMXCIX'\n    assert candidate(500) == 'D'\n", "language": "python"}
{"task_id": "5344dffa-e650-46f1-ad10-99d90b127d218760752380815027499", "prompt": "Complete the function as per the docstring, addressing all edge cases. Provide a single cohesive code block for the implementation.\n\n```python\ndef calculate_time_dilation(velocity: float, time: float) -> float:\n    \"\"\"\n    An astrophysicist is studying the effects of time dilation in space travel. Given a spacecraft's\n    velocity as a fraction of the speed of light and the time elapsed from the spacecraft's perspective,\n    this function calculates the time that has passed on Earth.\n\n    :param velocity: A float between 0 and 1 representing the spacecraft's velocity as a fraction of\n                     the speed of light.\n    :param time: A float representing the time elapsed from the spacecraft's perspective in years.\n    :return: The time elapsed on Earth in years, rounded to two decimal places.\n\n\n    [EXAMPLES]\n    \n    assert candidate(0.9, 1) == 2.29\n    assert candidate(0.5, 1000) == 1154.7\n\n    [/EXAMPLES]\n    \"\"\"\n```\n", "entry_point": "calculate_time_dilation", "solution": "def calculate_time_dilation(velocity: float, time: float) -> float:\n    \"\"\"\n    An astrophysicist is studying the effects of time dilation in space travel. Given a spacecraft's\n    velocity as a fraction of the speed of light and the time elapsed from the spacecraft's perspective,\n    this function calculates the time that has passed on Earth.\n\n    :param velocity: A float between 0 and 1 representing the spacecraft's velocity as a fraction of\n                     the speed of light.\n    :param time: A float representing the time elapsed from the spacecraft's perspective in years.\n    :return: The time elapsed on Earth in years, rounded to two decimal places.\n\n\n    [EXAMPLES]\n    \n    assert candidate(0.9, 1) == 2.29\n    assert candidate(0.5, 1000) == 1154.7\n\n    [/EXAMPLES]\n    \"\"\"\n    import math\n\n    # Check if velocity is within the valid range\n    if not 0 <= velocity < 1:\n        raise ValueError(\"Velocity must be between 0 and 1 (exclusive)\")\n\n    # Calculate the Lorentz factor\n    lorentz_factor = 1 / math.sqrt(1 - velocity**2)\n\n    # Calculate the time elapsed on Earth\n    earth_time = time * lorentz_factor\n\n    # Round the result to two decimal places\n    return round(earth_time, 2)\n\n", "test": "def check(candidate):\n    assert candidate(0.5, 100) == 115.47\n    assert candidate(0.5, 1000) == 1154.7\n    assert candidate(0.9, 1) == 2.29\n    assert candidate(0.5, 0.1) == 0.12\n    assert candidate(0.95, 2.5) == 8.01\n    assert candidate(1e-10, 1) == 1.0\n    assert candidate(0.99, 1) == 7.09\n    assert candidate(0.75, 5) == 7.56\n    assert candidate(0.1, 1) == 1.01\n    assert candidate(0.8, 15) == 25.0\n", "language": "python"}
{"task_id": "f0633437-a579-4617-a49d-58088bad69ec-7320240027490570663", "prompt": "You need to implement a function that works as-is within a single code block. Don't add any code outside the function. Stick to the libraries that are already imported in the problem statement. If you need helper functions or classes, define them inside the main function.\n\n```python\ndef morse_encoder(message: str) -> str:\n    \"\"\"\n    In a post-apocalyptic world, a group of survivors needs to communicate using Morse code to avoid detection.\n    This function takes a string message and converts it to Morse code.\n\n    The function should handle letters (a-z, case-insensitive) and digits (0-9). \n    Use a dot (.) for a dit and a dash (-) for a dah. Use a single space to separate letters and \n    three spaces to separate words.\n\n\n    [EXAMPLES]\n    \n    assert candidate(\"MORSE CODE\") == '-- --- .-. ... .   -.-. --- -.. .'\n    assert candidate(\"THE QUICK BROWN FOX JUMPS OVER THE LAZY DOG\") == '- .... .   --.- ..- .. -.-. -.-   -... .-. --- .-- -.   ..-. --- -..-   .--- ..- -- .--. ...   --- ...- . .-.   - .... .   .-.. .- --.. -.--   -.. --- --.'\n\n    [/EXAMPLES]\n    \"\"\"\n```\n", "entry_point": "morse_encoder", "solution": "def morse_encoder(message: str) -> str:\n    \"\"\"\n    In a post-apocalyptic world, a group of survivors needs to communicate using Morse code to avoid detection.\n    This function takes a string message and converts it to Morse code.\n\n    The function should handle letters (a-z, case-insensitive) and digits (0-9). \n    Use a dot (.) for a dit and a dash (-) for a dah. Use a single space to separate letters and \n    three spaces to separate words.\n\n\n    [EXAMPLES]\n    \n    assert candidate(\"MORSE CODE\") == '-- --- .-. ... .   -.-. --- -.. .'\n    assert candidate(\"THE QUICK BROWN FOX JUMPS OVER THE LAZY DOG\") == '- .... .   --.- ..- .. -.-. -.-   -... .-. --- .-- -.   ..-. --- -..-   .--- ..- -- .--. ...   --- ...- . .-.   - .... .   .-.. .- --.. -.--   -.. --- --.'\n\n    [/EXAMPLES]\n    \"\"\"\n    morse_code_dict = {\n        'A': '.-', 'B': '-...', 'C': '-.-.', 'D': '-..', 'E': '.', 'F': '..-.',\n        'G': '--.', 'H': '....', 'I': '..', 'J': '.---', 'K': '-.-', 'L': '.-..',\n        'M': '--', 'N': '-.', 'O': '---', 'P': '.--.', 'Q': '--.-', 'R': '.-.',\n        'S': '...', 'T': '-', 'U': '..-', 'V': '...-', 'W': '.--', 'X': '-..-',\n        'Y': '-.--', 'Z': '--..', '0': '-----', '1': '.----', '2': '..---',\n        '3': '...--', '4': '....-', '5': '.....', '6': '-....', '7': '--...',\n        '8': '---..', '9': '----.'\n    }\n    \n    # Convert the message to uppercase\n    message = message.upper()\n    \n    # Split the message into words\n    words = message.split()\n    \n    # Convert each word to Morse code\n    morse_words = []\n    for word in words:\n        morse_letters = []\n        for char in word:\n            if char in morse_code_dict:\n                morse_letters.append(morse_code_dict[char])\n        morse_words.append(' '.join(morse_letters))\n    \n    # Join the Morse code words with three spaces\n    return '   '.join(morse_words)\n\n", "test": "def check(candidate):\n    assert candidate(\"HELLO WORLD\") == '.... . .-.. .-.. ---   .-- --- .-. .-.. -..'\n    assert candidate(\"THE FIVE BOXING WIZARDS JUMP QUICKLY\") == '- .... .   ..-. .. ...- .   -... --- -..- .. -. --.   .-- .. --.. .- .-. -.. ...   .--- ..- -- .--.   --.- ..- .. -.-. -.- .-.. -.--'\n    assert candidate(\"Hello, World!\") == '.... . .-.. .-.. ---   .-- --- .-. .-.. -..'\n    assert candidate(\"MORSE CODE\") == '-- --- .-. ... .   -.-. --- -.. .'\n    assert candidate(\"Z\") == '--..'\n    assert candidate(\"CQ CQ CQ DE KA1ABC\") == '-.-. --.-   -.-. --.-   -.-. --.-   -.. .   -.- .- .---- .- -... -.-.'\n    assert candidate(\"9\") == '----.'\n    assert candidate(\"this is a test message\") == '- .... .. ...   .. ...   .-   - . ... -   -- . ... ... .- --. .'\n    assert candidate(\"THE QUICK BROWN FOX JUMPS OVER THE LAZY DOG\") == '- .... .   --.- ..- .. -.-. -.-   -... .-. --- .-- -.   ..-. --- -..-   .--- ..- -- .--. ...   --- ...- . .-.   - .... .   .-.. .- --.. -.--   -.. --- --.'\n    assert candidate(\"1234567890\") == '.---- ..--- ...-- ....- ..... -.... --... ---.. ----. -----'\n", "language": "python"}
{"task_id": "41d1bed9-8529-4539-acd5-82f420cc2541-32650414852716623", "prompt": "Your role is to assist with coding by completing functions that are ready to execute in code blocks. You must contain all code within the specified function and use only the libraries that have been imported. Define any supplementary functions or classes inside the main function.\n\n```python\nfrom typing import List\n\ndef decode_alien_message(encrypted: str, codebook: List[str]) -> str:\n    \"\"\"\n    An alien civilization has sent an encrypted message to Earth. Scientists have partially\n    decrypted the alien language and compiled a codebook, but the message's structure is still unclear.\n\n    This function attempts to decode the alien message using the provided codebook. The decoding\n    process works as follows:\n    1. The function tries to match the longest possible sequence from the codebook to the start of the encrypted message.\n    2. If a match is found, it's added to the decoded message and removed from the encrypted string.\n    3. This process repeats until the entire message is decoded or no more matches can be found.\n\n    Parameters:\n    encrypted: The encrypted alien message as a string\n    codebook: A list of known alien words or phrases\n\n    Returns:\n    The decoded message as a string, or \"Unable to fully decode\" if the message couldn't be completely decrypted.\n\n\n    [EXAMPLES]\n    \n    assert candidate(\"abcabcabc\", [\"abc\"]) == 'abc abc abc'\n    assert candidate(\"thisisatest\", [\"this\", \"is\", \"a\", \"test\"]) == 'this is a test'\n\n    [/EXAMPLES]\n    \"\"\"\n```\n", "entry_point": "decode_alien_message", "solution": "from typing import List\n\ndef decode_alien_message(encrypted: str, codebook: List[str]) -> str:\n    \"\"\"\n    An alien civilization has sent an encrypted message to Earth. Scientists have partially\n    decrypted the alien language and compiled a codebook, but the message's structure is still unclear.\n\n    This function attempts to decode the alien message using the provided codebook. The decoding\n    process works as follows:\n    1. The function tries to match the longest possible sequence from the codebook to the start of the encrypted message.\n    2. If a match is found, it's added to the decoded message and removed from the encrypted string.\n    3. This process repeats until the entire message is decoded or no more matches can be found.\n\n    Parameters:\n    encrypted: The encrypted alien message as a string\n    codebook: A list of known alien words or phrases\n\n    Returns:\n    The decoded message as a string, or \"Unable to fully decode\" if the message couldn't be completely decrypted.\n\n\n    [EXAMPLES]\n    \n    assert candidate(\"abcabcabc\", [\"abc\"]) == 'abc abc abc'\n    assert candidate(\"thisisatest\", [\"this\", \"is\", \"a\", \"test\"]) == 'this is a test'\n\n    [/EXAMPLES]\n    \"\"\"\n    def find_longest_match(text, words):\n        longest_match = \"\"\n        for word in words:\n            if text.startswith(word) and len(word) > len(longest_match):\n                longest_match = word\n        return longest_match\n\n    decoded = []\n    while encrypted:\n        match = find_longest_match(encrypted, codebook)\n        if not match:\n            return \"Unable to fully decode\"\n        decoded.append(match)\n        encrypted = encrypted[len(match):]\n\n    return \" \".join(decoded)\n\n", "test": "def check(candidate):\n    assert candidate(\"abcdefg\", [\"a\", \"b\", \"c\", \"d\", \"e\", \"f\", \"g\"]) == 'a b c d e f g'\n    assert candidate(\"qwertyuiop\", [\"qwe\", \"rty\", \"uio\"]) == 'Unable to fully decode'\n    assert candidate(\"hello\", [\"hello\"]) == 'hello'\n    assert candidate(\"onlyfirsthalf\", [\"only\", \"first\"]) == 'Unable to fully decode'\n    assert candidate(\"a\"*1000, [\"a\"]) == 'a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a'\n    assert candidate(\"abcabcabc\", [\"abc\"]) == 'abc abc abc'\n    assert candidate(\"verylongstringverylongstringverylongstring\", [\"very\", \"long\", \"string\"]) == 'very long string very long string very long string'\n    assert candidate(\"specialcharacters!@#\", [\"special\", \"characters\", \"!@#\"]) == 'special characters !@#'\n    assert candidate(\"thisisatest\", [\"this\", \"is\", \"a\", \"test\"]) == 'this is a test'\n    assert candidate(\"emptystringsincodebook\", [\"\", \"empty\", \"strings\"]) == 'Unable to fully decode'\n", "language": "python"}
{"task_id": "4753e329-a065-4afc-941b-2f96a6d78751-5934286247600662086", "prompt": "Your task is to complete the function given as is in a single code block. Don't add any code outside the function boundaries. Stick to using only the libraries that are already imported in the problem. If you need additional functions or classes, define them inside the main function.\n\n```python\nfrom typing import List\n\ndef longest_happy_prefix(s: str) -> str:\n    \"\"\"\n    In a secret communication system, a \"happy prefix\" is defined as a non-empty prefix\n    which is also a suffix of the string. Find the longest happy prefix in a given string.\n\n    This function utilizes string manipulation and pattern matching techniques.\n\n\n    [EXAMPLES]\n    \n    assert candidate(\"ababab\") == 'abab'\n    assert candidate(\"pythonpython\") == 'python'\n\n    [/EXAMPLES]\n    \"\"\"\n```\n", "entry_point": "longest_happy_prefix", "solution": "from typing import List\n\ndef longest_happy_prefix(s: str) -> str:\n    \"\"\"\n    In a secret communication system, a \"happy prefix\" is defined as a non-empty prefix\n    which is also a suffix of the string. Find the longest happy prefix in a given string.\n\n    This function utilizes string manipulation and pattern matching techniques.\n\n\n    [EXAMPLES]\n    \n    assert candidate(\"ababab\") == 'abab'\n    assert candidate(\"pythonpython\") == 'python'\n\n    [/EXAMPLES]\n    \"\"\"\n    def compute_lps(pattern: str) -> List[int]:\n        lps = [0] * len(pattern)\n        length = 0\n        i = 1\n\n        while i < len(pattern):\n            if pattern[i] == pattern[length]:\n                length += 1\n                lps[i] = length\n                i += 1\n            else:\n                if length != 0:\n                    length = lps[length - 1]\n                else:\n                    lps[i] = 0\n                    i += 1\n\n        return lps\n\n    lps = compute_lps(s)\n    prefix_length = lps[-1]\n    \n    return s[:prefix_length]\n\n", "test": "def check(candidate):\n    assert candidate(\"aaabaaa\") == 'aaa'\n    assert candidate(\"aa\") == 'a'\n    assert candidate(\"racecar\") == 'r'\n    assert candidate(\"abcdefghijklmnopqrstuvwxyz\") == ''\n    assert candidate(\"levellevellevel\") == 'levellevel'\n    assert candidate(\"pythonpython\") == 'python'\n    assert candidate(\"abcdefabcdef\") == 'abcdef'\n    assert candidate(\"ababab\") == 'abab'\n    assert candidate(\"a\") == ''\n    assert candidate(\"aaaaaaaaaaaaaaaaaaaa\") == 'aaaaaaaaaaaaaaaaaaa'\n", "language": "python"}
{"task_id": "af39449f-4285-4309-a3cb-7e162f13fb0b8931433285858792604", "prompt": "I'll implement the remaining part of this function based on its docstring, maintaining the original function signature.\n\n```python\nfrom typing import List, Tuple\n\ndef optimize_study_schedule(subjects: List[str], durations: List[int], available_time: int) -> Tuple[List[str], int]:\n    \"\"\"\n    Determines the optimal combination of subjects to study within a given time constraint.\n    This function uses a greedy algorithm approach to maximize the number of subjects covered.\n\n    Args:\n    subjects (List[str]): A list of subject names.\n    durations (List[int]): A list of study durations for each subject in minutes.\n    available_time (int): The total available study time in minutes.\n\n    Returns:\n    Tuple[List[str], int]: A tuple containing the list of subjects to study and the total study time.\n\n\n    [EXAMPLES]\n    \n    assert candidate(['Subject1', 'Subject2'], [50, 70], 100) == (['Subject1'], 50)\n    assert candidate(['X', 'Y'], [2**30, 2**30], 2**31 - 1) == (['X'], 1073741824)\n\n    [/EXAMPLES]\n    \"\"\"\n```\n", "entry_point": "optimize_study_schedule", "solution": "from typing import List, Tuple\n\ndef optimize_study_schedule(subjects: List[str], durations: List[int], available_time: int) -> Tuple[List[str], int]:\n    \"\"\"\n    Determines the optimal combination of subjects to study within a given time constraint.\n    This function uses a greedy algorithm approach to maximize the number of subjects covered.\n\n    Args:\n    subjects (List[str]): A list of subject names.\n    durations (List[int]): A list of study durations for each subject in minutes.\n    available_time (int): The total available study time in minutes.\n\n    Returns:\n    Tuple[List[str], int]: A tuple containing the list of subjects to study and the total study time.\n\n\n    [EXAMPLES]\n    \n    assert candidate(['Subject1', 'Subject2'], [50, 70], 100) == (['Subject1'], 50)\n    assert candidate(['X', 'Y'], [2**30, 2**30], 2**31 - 1) == (['X'], 1073741824)\n\n    [/EXAMPLES]\n    \"\"\"\n    # Create a list of tuples containing (subject, duration)\n    subject_duration_pairs = list(zip(subjects, durations))\n    \n    # Sort the pairs based on duration in ascending order\n    subject_duration_pairs.sort(key=lambda x: x[1])\n    \n    optimal_subjects = []\n    total_study_time = 0\n    \n    for subject, duration in subject_duration_pairs:\n        if total_study_time + duration <= available_time:\n            optimal_subjects.append(subject)\n            total_study_time += duration\n        else:\n            break\n    \n    return (optimal_subjects, total_study_time)\n\n", "test": "def check(candidate):\n    assert candidate(['Programming', 'Algorithms', 'DataStructures'], [120, 90, 60], 180) == (['DataStructures', 'Algorithms'], 150)\n    assert candidate(['X', 'Y'], [2**30, 2**30], 2**31 - 1) == (['X'], 1073741824)\n    assert candidate(['Test1'], [30], 60) == (['Test1'], 30)\n    assert candidate(['S1', 'S2', 'S3', 'S4', 'S5'], [15, 25, 35, 45, 55], 150) == (['S1', 'S2', 'S3', 'S4'], 120)\n    assert candidate(['Math', 'Physics', 'Chemistry', 'Biology'], [60, 40, 30, 50], 120) == (['Chemistry', 'Physics', 'Biology'], 120)\n    assert candidate(['Subject' + str(i) for i in range(1, 6)], [30, 30, 30, 30, 30], 90) == (['Subject1', 'Subject2', 'Subject3'], 90)\n    assert candidate(['Subject1', 'Subject2'], [50, 70], 100) == (['Subject1'], 50)\n    assert candidate(['A', 'B', 'C'], [10, 10, 10], 25) == (['A', 'B'], 20)\n    assert candidate(['Short', 'Medium', 'Long'], [5, 15, 25], 30) == (['Short', 'Medium'], 20)\n    assert candidate(['Subject'], [100], 99) == ([], 0)\n", "language": "python"}
{"task_id": "0f195a96-b15d-4810-b955-02339659d5543745137787130002296", "prompt": "Based on the documentation string, write the complete function implementation. Preserve the function name and parameters as given. Put the entire solution in one code block.\n\n```python\nfrom collections import defaultdict\nfrom typing import List, Tuple, Dict\nfrom typing import List, Tuple\n\ndef organize_library(books: List[Tuple[str, str, int]]) -> Dict[str, List[Tuple[str, int]]]:\n    \"\"\"\n    A librarian needs to organize a collection of books by genre for easier browsing.\n\n    This function takes a list of books, where each book is represented by a tuple\n    containing the title, genre, and publication year. It then organizes the books\n    into a dictionary where the keys are genres and the values are lists of tuples\n    containing the title and publication year of books in that genre.\n\n    Args:\n    books (List[Tuple[str, str, int]]): A list of books, each represented as (title, genre, year)\n\n    Returns:\n    Dict[str, List[Tuple[str, int]]]: A dictionary organizing books by genre\n\n\n    [EXAMPLES]\n    \n    assert candidate([(\"The Hitchhiker's Guide to the Galaxy\", \"Science Fiction Comedy\", 1979), (\"Good Omens\", \"Fantasy Comedy\", 1990), (\"Catch-22\", \"Satirical\", 1961)]) == {'Science Fiction Comedy': [(\"The Hitchhiker's Guide to the Galaxy\", 1979)], 'Fantasy Comedy': [('Good Omens', 1990)], 'Satirical': [('Catch-22', 1961)]}\n    assert candidate([(\"To Kill a Mockingbird\", \"Classic\", 1960), (\"The Catcher in the Rye\", \"Classic\", 1951), (\"The Great Gatsby\", \"Classic\", 1925)]) == {'Classic': [('To Kill a Mockingbird', 1960), ('The Catcher in the Rye', 1951), ('The Great Gatsby', 1925)]}\n\n    [/EXAMPLES]\n    \"\"\"\n```\n", "entry_point": "organize_library", "solution": "from collections import defaultdict\nfrom typing import List, Tuple, Dict\nfrom typing import List, Tuple\n\ndef organize_library(books: List[Tuple[str, str, int]]) -> Dict[str, List[Tuple[str, int]]]:\n    \"\"\"\n    A librarian needs to organize a collection of books by genre for easier browsing.\n\n    This function takes a list of books, where each book is represented by a tuple\n    containing the title, genre, and publication year. It then organizes the books\n    into a dictionary where the keys are genres and the values are lists of tuples\n    containing the title and publication year of books in that genre.\n\n    Args:\n    books (List[Tuple[str, str, int]]): A list of books, each represented as (title, genre, year)\n\n    Returns:\n    Dict[str, List[Tuple[str, int]]]: A dictionary organizing books by genre\n\n\n    [EXAMPLES]\n    \n    assert candidate([(\"The Hitchhiker's Guide to the Galaxy\", \"Science Fiction Comedy\", 1979), (\"Good Omens\", \"Fantasy Comedy\", 1990), (\"Catch-22\", \"Satirical\", 1961)]) == {'Science Fiction Comedy': [(\"The Hitchhiker's Guide to the Galaxy\", 1979)], 'Fantasy Comedy': [('Good Omens', 1990)], 'Satirical': [('Catch-22', 1961)]}\n    assert candidate([(\"To Kill a Mockingbird\", \"Classic\", 1960), (\"The Catcher in the Rye\", \"Classic\", 1951), (\"The Great Gatsby\", \"Classic\", 1925)]) == {'Classic': [('To Kill a Mockingbird', 1960), ('The Catcher in the Rye', 1951), ('The Great Gatsby', 1925)]}\n\n    [/EXAMPLES]\n    \"\"\"\n    organized_books = defaultdict(list)\n    \n    for title, genre, year in books:\n        organized_books[genre].append((title, year))\n    \n    return dict(organized_books)\n\n", "test": "def check(candidate):\n    assert candidate([(\"To Kill a Mockingbird\", \"Classic\", 1960), (\"The Catcher in the Rye\", \"Classic\", 1951), (\"The Great Gatsby\", \"Classic\", 1925)]) == {'Classic': [('To Kill a Mockingbird', 1960), ('The Catcher in the Rye', 1951), ('The Great Gatsby', 1925)]}\n    assert candidate([(\"The Kite Runner\", \"Historical Fiction\", 2003), (\"A Thousand Splendid Suns\", \"Historical Fiction\", 2007), (\"And the Mountains Echoed\", \"Family Saga\", 2013)]) == {'Historical Fiction': [('The Kite Runner', 2003), ('A Thousand Splendid Suns', 2007)], 'Family Saga': [('And the Mountains Echoed', 2013)]}\n    assert candidate([(\"The Help\", \"Historical Fiction\", 2009), (\"All the Light We Cannot See\", \"Historical Fiction\", 2014), (\"The Book Thief\", \"Historical Fiction\", 2005)]) == {'Historical Fiction': [('The Help', 2009), ('All the Light We Cannot See', 2014), ('The Book Thief', 2005)]}\n    assert candidate([(\"The Girl on the Train\", \"Thriller\", 2015), (\"The Silent Patient\", \"Psychological Thriller\", 2019), (\"Before I Go to Sleep\", \"Psychological Thriller\", 2011)]) == {'Thriller': [('The Girl on the Train', 2015)], 'Psychological Thriller': [('The Silent Patient', 2019), ('Before I Go to Sleep', 2011)]}\n    assert candidate([(\"The Pillars of the Earth\", \"Historical Fiction\", 1989), (\"World Without End\", \"Historical Fiction\", 2007), (\"A Column of Fire\", \"Historical Fiction\", 2017)]) == {'Historical Fiction': [('The Pillars of the Earth', 1989), ('World Without End', 2007), ('A Column of Fire', 2017)]}\n    assert candidate([(\"The Old Man and the Sea\", \"Novella\", 1952), (\"Animal Farm\", \"Novella\", 1945), (\"Of Mice and Men\", \"Novella\", 1937)]) == {'Novella': [('The Old Man and the Sea', 1952), ('Animal Farm', 1945), ('Of Mice and Men', 1937)]}\n    assert candidate([(\"The Silence of the Lambs\", \"Thriller\", 1988), (\"Misery\", \"Psychological Horror\", 1987), (\"American Psycho\", \"Psychological Horror\", 1991)]) == {'Thriller': [('The Silence of the Lambs', 1988)], 'Psychological Horror': [('Misery', 1987), ('American Psycho', 1991)]}\n    assert candidate([(\"The Hitchhiker's Guide to the Galaxy\", \"Science Fiction Comedy\", 1979), (\"Good Omens\", \"Fantasy Comedy\", 1990), (\"Catch-22\", \"Satirical\", 1961)]) == {'Science Fiction Comedy': [(\"The Hitchhiker's Guide to the Galaxy\", 1979)], 'Fantasy Comedy': [('Good Omens', 1990)], 'Satirical': [('Catch-22', 1961)]}\n", "language": "python"}
{"task_id": "cb395512-2920-4392-9a0c-6199ef9eb391-7413304916677398871", "prompt": "Acting as your coding assistant, I'll ensure the function you provide is properly completed and ready to execute. I'll only use the imported libraries and keep all additional code contained within the function you specify.\n\n```python\nfrom collections import defaultdict\nfrom typing import List, Dict\nfrom typing import List, Dict, Union\n\ndef categorize_expenses(transactions: List[Dict[str, Union[str, float]]]) -> Dict[str, float]:\n    \"\"\"\n    Categorize and summarize personal expenses for a budgeting application.\n\n    This function takes a list of financial transactions, where each transaction is represented\n    as a dictionary containing the category and amount. It then calculates the total spent in\n    each category and returns a summary of expenses by category.\n\n    The function uses dictionary manipulation and list comprehension to efficiently process\n    and categorize the transactions.\n\n    Args:\n    transactions (List[Dict[str, Union[str, float]]]): A list of dictionaries, where each dictionary\n                                                       represents a transaction with 'category' and 'amount' keys.\n\n    Returns:\n    Dict[str, float]: A dictionary with expense categories as keys and total amounts as values.\n\n\n    [EXAMPLES]\n    \n    assert candidate([{'category': 'Grocery', 'amount': 50.25}, {'category': 'Gas', 'amount': 40.00}, {'category': 'Grocery', 'amount': 30.75}, {'category': 'Entertainment', 'amount': 100.00}, {'category': 'Gas', 'amount': 35.50}]) == {'Grocery': 81.0, 'Gas': 75.5, 'Entertainment': 100.0}\n    assert candidate([{'category': 'Housing', 'amount': 1000.00}, {'category': 'Food', 'amount': 200.00}, {'category': 'Transport', 'amount': 50.00}]) == {'Housing': 1000.0, 'Food': 200.0, 'Transport': 50.0}\n\n    [/EXAMPLES]\n    \"\"\"\n```\n", "entry_point": "categorize_expenses", "solution": "from collections import defaultdict\nfrom typing import List, Dict\nfrom typing import List, Dict, Union\n\ndef categorize_expenses(transactions: List[Dict[str, Union[str, float]]]) -> Dict[str, float]:\n    \"\"\"\n    Categorize and summarize personal expenses for a budgeting application.\n\n    This function takes a list of financial transactions, where each transaction is represented\n    as a dictionary containing the category and amount. It then calculates the total spent in\n    each category and returns a summary of expenses by category.\n\n    The function uses dictionary manipulation and list comprehension to efficiently process\n    and categorize the transactions.\n\n    Args:\n    transactions (List[Dict[str, Union[str, float]]]): A list of dictionaries, where each dictionary\n                                                       represents a transaction with 'category' and 'amount' keys.\n\n    Returns:\n    Dict[str, float]: A dictionary with expense categories as keys and total amounts as values.\n\n\n    [EXAMPLES]\n    \n    assert candidate([{'category': 'Grocery', 'amount': 50.25}, {'category': 'Gas', 'amount': 40.00}, {'category': 'Grocery', 'amount': 30.75}, {'category': 'Entertainment', 'amount': 100.00}, {'category': 'Gas', 'amount': 35.50}]) == {'Grocery': 81.0, 'Gas': 75.5, 'Entertainment': 100.0}\n    assert candidate([{'category': 'Housing', 'amount': 1000.00}, {'category': 'Food', 'amount': 200.00}, {'category': 'Transport', 'amount': 50.00}]) == {'Housing': 1000.0, 'Food': 200.0, 'Transport': 50.0}\n\n    [/EXAMPLES]\n    \"\"\"\n    # Use defaultdict to automatically handle new categories\n    expenses = defaultdict(float)\n    \n    # Iterate through transactions and sum up amounts for each category\n    for transaction in transactions:\n        category = transaction['category']\n        amount = transaction['amount']\n        expenses[category] += amount\n    \n    # Convert defaultdict to regular dict before returning\n    return dict(expenses)\n\n", "test": "def check(candidate):\n    assert candidate([{'category': 'Food', 'amount': 100.00}]) == {'Food': 100.0}\n    assert candidate([{'category': 'Round', 'amount': 1.00}, {'category': 'Round', 'amount': 2.00}, {'category': 'Not Round', 'amount': 1.50}]) == {'Round': 3.0, 'Not Round': 1.5}\n    assert candidate([{'category': 'Housing', 'amount': 1000.00}, {'category': 'Food', 'amount': 200.00}, {'category': 'Transport', 'amount': 50.00}]) == {'Housing': 1000.0, 'Food': 200.0, 'Transport': 50.0}\n    assert candidate([{'category': 'Grocery', 'amount': 50.25}, {'category': 'Gas', 'amount': 40.00}, {'category': 'Grocery', 'amount': 30.75}, {'category': 'Entertainment', 'amount': 100.00}, {'category': 'Gas', 'amount': 35.50}]) == {'Grocery': 81.0, 'Gas': 75.5, 'Entertainment': 100.0}\n    assert candidate([{'category': 'A', 'amount': 1.11}, {'category': 'B', 'amount': 2.22}, {'category': 'C', 'amount': 3.33}, {'category': 'A', 'amount': 4.44}, {'category': 'B', 'amount': 5.55}, {'category': 'C', 'amount': 6.66}]) == {'A': 5.550000000000001, 'B': 7.77, 'C': 9.99}\n    assert candidate([{'category': 'Test', 'amount': 0.001}, {'category': 'Test', 'amount': 0.002}, {'category': 'Test', 'amount': 0.003}]) == {'Test': 0.006}\n    assert candidate([{'category': 'Food', 'amount': 10.50}, {'category': 'Food', 'amount': 20.75}, {'category': 'Food', 'amount': 15.25}]) == {'Food': 46.5}\n    assert candidate([{'category': 'Same', 'amount': 1.00}, {'category': 'Same', 'amount': 1.00}, {'category': 'Different', 'amount': 1.00}]) == {'Same': 2.0, 'Different': 1.0}\n    assert candidate([{'category': 'Category1', 'amount': 0.1}, {'category': 'Category2', 'amount': 0.2}, {'category': 'Category3', 'amount': 0.3}]) == {'Category1': 0.1, 'Category2': 0.2, 'Category3': 0.3}\n    assert candidate([{'category': 'Large Purchase', 'amount': 9999999.99}]) == {'Large Purchase': 9999999.99}\n", "language": "python"}
{"task_id": "3e31a48f-c0d7-4e02-9e77-2ad29ca2718c1939292960071881631", "prompt": "I need you to implement a function provided in the instructions. I'll focus solely on completing that function, ensuring it's executable as is in a single code block. I'll keep all logic within the given function and will only use libraries that are already imported. Any helper functions or classes I create will be defined inside the main function. My response will consist of just one code block containing the completed function.\n\n```python\nfrom typing import List\n\ndef knapsack_problem(weights: List[int], values: List[int], capacity: int) -> int:\n    \"\"\"\n    You're a treasure hunter trying to maximize the value of items you can carry in your backpack.\n    Given a list of item weights, their corresponding values, and the maximum weight capacity of your backpack,\n    determine the maximum value of items you can carry.\n\n    Implement this using dynamic programming to solve the 0/1 knapsack problem.\n\n\n    [EXAMPLES]\n    \n    assert candidate([1, 3, 4, 5], [1, 4, 5, 7], 7) == 9\n    assert candidate([1, 2, 3, 4, 5], [5, 10, 15, 20, 25], 6) == 30\n\n    [/EXAMPLES]\n    \"\"\"\n```\n", "entry_point": "knapsack_problem", "solution": "from typing import List\n\ndef knapsack_problem(weights: List[int], values: List[int], capacity: int) -> int:\n    \"\"\"\n    You're a treasure hunter trying to maximize the value of items you can carry in your backpack.\n    Given a list of item weights, their corresponding values, and the maximum weight capacity of your backpack,\n    determine the maximum value of items you can carry.\n\n    Implement this using dynamic programming to solve the 0/1 knapsack problem.\n\n\n    [EXAMPLES]\n    \n    assert candidate([1, 3, 4, 5], [1, 4, 5, 7], 7) == 9\n    assert candidate([1, 2, 3, 4, 5], [5, 10, 15, 20, 25], 6) == 30\n\n    [/EXAMPLES]\n    \"\"\"\n    n = len(weights)\n    \n    # Create a 2D table to store the maximum values\n    # The rows represent the items (0 to n)\n    # The columns represent the capacities (0 to capacity)\n    dp = [[0 for _ in range(capacity + 1)] for _ in range(n + 1)]\n    \n    # Fill the dp table\n    for i in range(1, n + 1):\n        for w in range(capacity + 1):\n            if weights[i-1] <= w:\n                # If the current item can fit, we have two choices:\n                # 1. Include the item\n                # 2. Exclude the item\n                # We take the maximum of these two\n                dp[i][w] = max(values[i-1] + dp[i-1][w-weights[i-1]], dp[i-1][w])\n            else:\n                # If the current item doesn't fit, we exclude it\n                dp[i][w] = dp[i-1][w]\n    \n    # The maximum value will be in the bottom-right cell of the dp table\n    return dp[n][capacity]\n\n", "test": "def check(candidate):\n    assert candidate([1, 2, 3], [10, 20, 30], 0) == 0\n    assert candidate([1, 1, 1, 1, 1, 1, 1, 1, 1, 1], [10, 9, 8, 7, 6, 5, 4, 3, 2, 1], 5) == 40\n    assert candidate([2, 2, 2, 2, 2], [1, 2, 3, 4, 5], 8) == 14\n    assert candidate([3, 1, 4, 1, 5, 9], [15, 5, 20, 5, 25, 45], 11) == 55\n    assert candidate([1, 3, 4, 5], [1, 4, 5, 7], 7) == 9\n    assert candidate([5, 10, 15, 22, 25], [30, 40, 45, 77, 90], 60) == 207\n    assert candidate([1, 2, 3, 4, 5], [5, 4, 3, 2, 1], 15) == 15\n    assert candidate([1, 2, 3, 4, 5], [5, 4, 3, 2, 1], 10) == 14\n    assert candidate([100, 200, 300, 400, 500], [1, 2, 3, 4, 5], 1000) == 10\n    assert candidate([1, 2, 3, 4, 5], [5, 10, 15, 20, 25], 6) == 30\n", "language": "python"}
{"task_id": "6b54c6c9-0ec2-40ef-a535-06b644e3faef4673882698629233329", "prompt": "Your coding assistant here. I'll complete the given function so it's immediately executable. I'll only work with libraries that are imported in the problem statement. When necessary, I'll define additional functions or classes within the main function itself. My response will consist solely of the completed function code.\n\n```python\ndef predict_stock_profit(prices: list[int]) -> int:\n    \"\"\"\n    You are a time traveler with knowledge of future stock prices. You want to maximize your profit by choosing a single day to buy one stock and choosing a different day in the future to sell that stock.\n\n    Given an array 'prices' where prices[i] is the price of a given stock on the i-th day, return the maximum profit you can achieve.\n\n    If you cannot achieve any profit, return 0.\n\n\n    [EXAMPLES]\n    \n    assert candidate([5, 4, 3, 2, 1]) == 0\n    assert candidate([1, 2]) == 1\n\n    [/EXAMPLES]\n    \"\"\"\n```\n", "entry_point": "predict_stock_profit", "solution": "def predict_stock_profit(prices: list[int]) -> int:\n    \"\"\"\n    You are a time traveler with knowledge of future stock prices. You want to maximize your profit by choosing a single day to buy one stock and choosing a different day in the future to sell that stock.\n\n    Given an array 'prices' where prices[i] is the price of a given stock on the i-th day, return the maximum profit you can achieve.\n\n    If you cannot achieve any profit, return 0.\n\n\n    [EXAMPLES]\n    \n    assert candidate([5, 4, 3, 2, 1]) == 0\n    assert candidate([1, 2]) == 1\n\n    [/EXAMPLES]\n    \"\"\"\n    if not prices:\n        return 0\n\n    max_profit = 0\n    min_price = float('inf')\n\n    for price in prices:\n        if price < min_price:\n            min_price = price\n        else:\n            max_profit = max(max_profit, price - min_price)\n\n    return max_profit\n\n", "test": "def check(candidate):\n    assert candidate([5, 4, 3, 2, 1]) == 0\n    assert candidate([7, 6, 4, 3, 1]) == 0\n    assert candidate([1, 2]) == 1\n    assert candidate([3, 3, 5, 0, 0, 3, 1, 4]) == 4\n    assert candidate([100]) == 0\n    assert candidate([2, 1]) == 0\n    assert candidate([]) == 0\n    assert candidate([3, 2, 6, 5, 0, 3]) == 4\n    assert candidate([1, 2, 4, 2, 5, 7, 2, 4, 9, 0]) == 8\n    assert candidate([1000, 999, 998, 997, 996]) == 0\n", "language": "python"}
{"task_id": "2dce5ada-5902-41c6-a1ab-0c2109302a542312055867415994657", "prompt": "I'm a coding assistant ready to complete functions that you can execute immediately. I'll keep my code confined to the function body, only use libraries that are imported in the problem, and place any additional functions or classes within the main function.\n\n```python\nfrom typing import List\n\ndef stock_profit_calculator(prices: List[int]) -> int:\n    \"\"\"\n    In stock market analysis, we want to find the maximum profit that can be made\n    by buying and selling a stock once, given its price over a series of days.\n    This function takes a list of stock prices and returns the maximum profit possible.\n\n    Parameters:\n    prices (List[int]): A list of stock prices, where prices[i] is the price on the i-th day.\n\n    Returns:\n    int: The maximum profit that can be achieved.\n\n\n    [EXAMPLES]\n    \n    assert candidate([1, 1, 1, 1, 1]) == 0\n    assert candidate([2, 1]) == 0\n\n    [/EXAMPLES]\n    \"\"\"\n```\n", "entry_point": "stock_profit_calculator", "solution": "from typing import List\n\ndef stock_profit_calculator(prices: List[int]) -> int:\n    \"\"\"\n    In stock market analysis, we want to find the maximum profit that can be made\n    by buying and selling a stock once, given its price over a series of days.\n    This function takes a list of stock prices and returns the maximum profit possible.\n\n    Parameters:\n    prices (List[int]): A list of stock prices, where prices[i] is the price on the i-th day.\n\n    Returns:\n    int: The maximum profit that can be achieved.\n\n\n    [EXAMPLES]\n    \n    assert candidate([1, 1, 1, 1, 1]) == 0\n    assert candidate([2, 1]) == 0\n\n    [/EXAMPLES]\n    \"\"\"\n    if not prices or len(prices) < 2:\n        return 0\n\n    min_price = float('inf')\n    max_profit = 0\n\n    for price in prices:\n        if price < min_price:\n            min_price = price\n        else:\n            current_profit = price - min_price\n            max_profit = max(max_profit, current_profit)\n\n    return max_profit\n\n", "test": "def check(candidate):\n    assert candidate([1, 2, 3, 4, 5, 4, 3, 2, 1]) == 4\n    assert candidate([]) == 0\n    assert candidate([10, 9, 8, 7, 6, 5, 4, 3, 2, 1]) == 0\n    assert candidate([1000, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10]) == 9\n    assert candidate([10, 7, 5, 8, 11, 9]) == 6\n    assert candidate([1, 2]) == 1\n    assert candidate([1000, 999, 998, 997, 996]) == 0\n    assert candidate([1, 1, 1, 1, 1]) == 0\n    assert candidate([2, 1]) == 0\n    assert candidate([0, 1, 0, 1, 0]) == 1\n", "language": "python"}
{"task_id": "bf574237-da41-4cf6-b462-3970a559552f-5696346716913887109", "prompt": "Implement the remaining portion of the function to match the docstring specifications. Present the entire function in a single code block.\n\n```python\ndef decode_alien_transmission(message: str) -> int:\n    \"\"\"\n    A team of cryptographers has intercepted an alien transmission consisting of a string of digits.\n    They believe the message contains valuable information about the alien civilization's technology.\n    The team needs to decode the message by finding the number of valid decodings possible.\n    \n    A valid decoding maps digits to letters as follows: 'A' -> 1, 'B' -> 2, ..., 'Z' -> 26.\n    The decoding should be done in a way that the entire message is used, and no digit is left unused.\n    \n    Calculate the number of possible ways to decode the intercepted alien transmission.\n    \n\n    [EXAMPLES]\n    \n    assert candidate(\"26262626\") == 16\n    assert candidate(\"27\") == 1\n\n    [/EXAMPLES]\n    \"\"\"\n```\n", "entry_point": "decode_alien_transmission", "solution": "def decode_alien_transmission(message: str) -> int:\n    \"\"\"\n    A team of cryptographers has intercepted an alien transmission consisting of a string of digits.\n    They believe the message contains valuable information about the alien civilization's technology.\n    The team needs to decode the message by finding the number of valid decodings possible.\n    \n    A valid decoding maps digits to letters as follows: 'A' -> 1, 'B' -> 2, ..., 'Z' -> 26.\n    The decoding should be done in a way that the entire message is used, and no digit is left unused.\n    \n    Calculate the number of possible ways to decode the intercepted alien transmission.\n    \n\n    [EXAMPLES]\n    \n    assert candidate(\"26262626\") == 16\n    assert candidate(\"27\") == 1\n\n    [/EXAMPLES]\n    \"\"\"\n    if not message:\n        return 0\n    \n    n = len(message)\n    dp = [0] * (n + 1)\n    \n    # Base cases\n    dp[0] = 1\n    dp[1] = 1 if message[0] != '0' else 0\n    \n    for i in range(2, n + 1):\n        # Check if the current digit can be decoded (not '0')\n        if message[i-1] != '0':\n            dp[i] += dp[i-1]\n        \n        # Check if the last two digits form a valid letter (10-26)\n        two_digit = int(message[i-2:i])\n        if 10 <= two_digit <= 26:\n            dp[i] += dp[i-2]\n    \n    return dp[n]\n\n", "test": "def check(candidate):\n    assert candidate(\"12345\") == 3\n    assert candidate(\"27\") == 1\n    assert candidate(\"\") == 0\n    assert candidate(\"26\") == 2\n    assert candidate(\"9999999999\") == 1\n    assert candidate(\"111\") == 3\n    assert candidate(\"10\") == 1\n    assert candidate(\"1234\") == 3\n    assert candidate(\"26262626\") == 16\n    assert candidate(\"11111\") == 8\n", "language": "python"}
{"task_id": "de575bf3-45af-411d-be17-e0ab60431232-295233954507882743", "prompt": "Here's the completed code in a single block. All auxiliary functions and classes will be defined inside the given function.\n\n```python\nfrom typing import List\n\ndef election_winner(votes: List[str]) -> str:\n    \"\"\"\n    You are an election official tasked with determining the winner of a local election.\n    The election uses a first-past-the-post system, where the candidate with the most votes wins.\n    Your task is to count the votes and declare the winner.\n\n    The function takes one parameter:\n    - votes: A list of strings, where each string is the name of the candidate that received that vote\n\n    The function should return a string representing the name of the winning candidate.\n\n    This function utilizes the concept of dictionaries.\n\n\n    [EXAMPLES]\n    \n    assert candidate([\"A\"] * 100 + [\"B\"] * 99) == 'A'\n    assert candidate([\"First\", \"Second\", \"Third\", \"First\", \"Third\", \"First\"]) == 'First'\n\n    [/EXAMPLES]\n    \"\"\"\n```\n", "entry_point": "election_winner", "solution": "from typing import List\n\ndef election_winner(votes: List[str]) -> str:\n    \"\"\"\n    You are an election official tasked with determining the winner of a local election.\n    The election uses a first-past-the-post system, where the candidate with the most votes wins.\n    Your task is to count the votes and declare the winner.\n\n    The function takes one parameter:\n    - votes: A list of strings, where each string is the name of the candidate that received that vote\n\n    The function should return a string representing the name of the winning candidate.\n\n    This function utilizes the concept of dictionaries.\n\n\n    [EXAMPLES]\n    \n    assert candidate([\"A\"] * 100 + [\"B\"] * 99) == 'A'\n    assert candidate([\"First\", \"Second\", \"Third\", \"First\", \"Third\", \"First\"]) == 'First'\n\n    [/EXAMPLES]\n    \"\"\"\n    # Create a dictionary to store the vote count for each candidate\n    vote_count = {}\n\n    # Count the votes for each candidate\n    for vote in votes:\n        if vote in vote_count:\n            vote_count[vote] += 1\n        else:\n            vote_count[vote] = 1\n\n    # Find the candidate with the most votes\n    winner = max(vote_count, key=vote_count.get)\n\n    return winner\n\n", "test": "def check(candidate):\n    assert candidate([chr(65 + i) for i in range(26)] * 10 + [\"A\"]) == 'A'\n    assert candidate([\"A\", \"B\", \"C\", \"A\", \"B\", \"C\", \"A\"]) == 'A'\n    assert candidate([\"Alice\", \"Bob\", \"Alice\", \"Charlie\", \"Alice\", \"Bob\"]) == 'Alice'\n    assert candidate([\"Candidate\" + str(i) for i in range(100)] + [\"Candidate0\"] * 10) == 'Candidate0'\n    assert candidate([\"A\", \"B\", \"C\", \"D\", \"E\"] * 20) == 'A'\n    assert candidate([\"John\", \"Jane\", \"John\", \"Jane\", \"John\"]) == 'John'\n    assert candidate([\"Long Name 1\", \"Long Name 2\", \"Long Name 1\", \"Long Name 3\", \"Long Name 2\", \"Long Name 1\"]) == 'Long Name 1'\n    assert candidate([\"A\"] * 100 + [\"B\"] * 99) == 'A'\n    assert candidate([\"Candidate\"] * 50) == 'Candidate'\n    assert candidate([\"First\", \"Second\", \"Third\", \"First\", \"Third\", \"First\"]) == 'First'\n", "language": "python"}
{"task_id": "39ebd418-661d-47d5-9674-c3a2e289600c6558285022635950263", "prompt": "Let me complete the given code block for you. I'll ensure any supplementary functions or classes are defined within the scope of the specified function.\n\n```python\ndef analyze_social_network(connections: list) -> dict:\n    \"\"\"\n    Analyze a social network to identify influential users and communities.\n\n    A social media company wants to understand the structure of their user\n    network. They need to identify the most connected users and detect\n    distinct communities within the network.\n\n    Args:\n    connections (list): A list of tuples, each representing a connection between two users\n\n    Returns:\n    dict: A dictionary containing 'influencers' (list of top 3 users with most connections)\n          and 'communities' (list of lists, each representing a community)\n\n\n    [EXAMPLES]\n    \n    assert candidate([(1, 2), (2, 3), (3, 4), (4, 5), (5, 6)]) == {'influencers': [2, 3, 4], 'communities': [[1, 2, 3, 4, 5, 6]]}\n    assert candidate([(1, 2), (2, 3), (3, 4), (4, 5), (5, 6), (6, 1)]) == {'influencers': [1, 2, 3], 'communities': [[1, 2, 3, 4, 5, 6]]}\n\n    [/EXAMPLES]\n    \"\"\"\n```\n", "entry_point": "analyze_social_network", "solution": "def analyze_social_network(connections: list) -> dict:\n    \"\"\"\n    Analyze a social network to identify influential users and communities.\n\n    A social media company wants to understand the structure of their user\n    network. They need to identify the most connected users and detect\n    distinct communities within the network.\n\n    Args:\n    connections (list): A list of tuples, each representing a connection between two users\n\n    Returns:\n    dict: A dictionary containing 'influencers' (list of top 3 users with most connections)\n          and 'communities' (list of lists, each representing a community)\n\n\n    [EXAMPLES]\n    \n    assert candidate([(1, 2), (2, 3), (3, 4), (4, 5), (5, 6)]) == {'influencers': [2, 3, 4], 'communities': [[1, 2, 3, 4, 5, 6]]}\n    assert candidate([(1, 2), (2, 3), (3, 4), (4, 5), (5, 6), (6, 1)]) == {'influencers': [1, 2, 3], 'communities': [[1, 2, 3, 4, 5, 6]]}\n\n    [/EXAMPLES]\n    \"\"\"\n    from collections import defaultdict\n\n    def find_community(user, graph, visited):\n        community = []\n        stack = [user]\n        while stack:\n            current = stack.pop()\n            if current not in visited:\n                visited.add(current)\n                community.append(current)\n                stack.extend(graph[current] - visited)\n        return community\n\n    # Build the graph\n    graph = defaultdict(set)\n    for u, v in connections:\n        graph[u].add(v)\n        graph[v].add(u)\n\n    # Find influencers\n    influencers = sorted(graph.keys(), key=lambda x: len(graph[x]), reverse=True)[:3]\n\n    # Find communities\n    communities = []\n    visited = set()\n    for user in graph:\n        if user not in visited:\n            community = find_community(user, graph, visited)\n            communities.append(sorted(community))\n\n    return {\n        'influencers': influencers,\n        'communities': communities\n    }\n\n", "test": "def check(candidate):\n    assert candidate([(1, 2), (2, 3), (3, 4), (4, 5), (5, 6)]) == {'influencers': [2, 3, 4], 'communities': [[1, 2, 3, 4, 5, 6]]}\n    assert candidate([(1, 2), (2, 3), (3, 4), (4, 5), (5, 6), (6, 7), (7, 8), (8, 9), (9, 10), (10, 1)]) == {'influencers': [1, 2, 3], 'communities': [[1, 2, 3, 4, 5, 6, 7, 8, 9, 10]]}\n    assert candidate([(1, 2), (2, 3), (3, 4), (4, 1), (5, 6), (6, 7), (7, 8), (8, 5)]) == {'influencers': [1, 2, 3], 'communities': [[1, 2, 3, 4], [5, 6, 7, 8]]}\n    assert candidate([(1, 2), (2, 3), (3, 4), (4, 5), (5, 6), (6, 1), (7, 8), (8, 9), (9, 10), (10, 7)]) == {'influencers': [1, 2, 3], 'communities': [[1, 2, 3, 4, 5, 6], [7, 8, 9, 10]]}\n    assert candidate([(1, 2), (2, 3), (3, 4), (4, 5), (5, 6), (6, 7), (7, 8), (8, 9), (9, 10), (10, 1), (1, 5), (5, 10)]) == {'influencers': [5, 1, 10], 'communities': [[1, 2, 3, 4, 5, 6, 7, 8, 9, 10]]}\n    assert candidate([]) == {'influencers': [], 'communities': []}\n    assert candidate([(1, 2), (2, 3), (3, 4), (4, 1), (5, 6), (6, 7), (7, 5), (1, 5), (2, 6), (3, 7), (4, 5)]) == {'influencers': [5, 1, 2], 'communities': [[1, 2, 3, 4, 5, 6, 7]]}\n    assert candidate([(1, 2), (2, 3), (3, 4), (4, 5), (5, 6), (6, 1)]) == {'influencers': [1, 2, 3], 'communities': [[1, 2, 3, 4, 5, 6]]}\n    assert candidate([(1, 2), (2, 3), (3, 4), (4, 5), (5, 6), (6, 7), (7, 1)]) == {'influencers': [1, 2, 3], 'communities': [[1, 2, 3, 4, 5, 6, 7]]}\n    assert candidate([(1, 1)]) == {'influencers': [1], 'communities': [[1]]}\n", "language": "python"}
{"task_id": "1c37cb3b-0392-4c18-b3af-4588df768b38-3252024288474022965", "prompt": "I'll complete the given function within a single code block. Using only the libraries already imported, I'll ensure any additional functions or classes are defined inside the main function. Here's the completed function without any external code.\n\n```python\ndef calculate_ecological_footprint(consumption: dict) -> float:\n    \"\"\"\n    As an environmental scientist, you're developing a tool to calculate an individual's ecological footprint.\n    The ecological footprint is measured in global hectares (gha) and represents the amount of biologically \n    productive land and sea area needed to support a person's lifestyle.\n    \n    Given a dictionary of annual consumption data, calculate and return the total ecological footprint.\n    The consumption data includes:\n    - 'energy': kWh of electricity (1 kWh = 0.0005 gha)\n    - 'water': cubic meters of water (1 m\u00b3 = 0.0001 gha)\n    - 'waste': kg of waste produced (1 kg = 0.0002 gha)\n    - 'food': kg of food consumed (1 kg = 0.0003 gha)\n    - 'transport': km traveled by car (1 km = 0.00015 gha)\n\n\n    [EXAMPLES]\n    \n    assert candidate({'energy': 0, 'water': 0, 'waste': 0, 'food': 0, 'transport': 0}) == 0.0\n    assert candidate({'energy': 8888, 'water': 7777, 'waste': 6666, 'food': 5555, 'transport': 4444}) == 8.888\n\n    [/EXAMPLES]\n    \"\"\"\n```\n", "entry_point": "calculate_ecological_footprint", "solution": "def calculate_ecological_footprint(consumption: dict) -> float:\n    \"\"\"\n    As an environmental scientist, you're developing a tool to calculate an individual's ecological footprint.\n    The ecological footprint is measured in global hectares (gha) and represents the amount of biologically \n    productive land and sea area needed to support a person's lifestyle.\n    \n    Given a dictionary of annual consumption data, calculate and return the total ecological footprint.\n    The consumption data includes:\n    - 'energy': kWh of electricity (1 kWh = 0.0005 gha)\n    - 'water': cubic meters of water (1 m\u00b3 = 0.0001 gha)\n    - 'waste': kg of waste produced (1 kg = 0.0002 gha)\n    - 'food': kg of food consumed (1 kg = 0.0003 gha)\n    - 'transport': km traveled by car (1 km = 0.00015 gha)\n\n\n    [EXAMPLES]\n    \n    assert candidate({'energy': 0, 'water': 0, 'waste': 0, 'food': 0, 'transport': 0}) == 0.0\n    assert candidate({'energy': 8888, 'water': 7777, 'waste': 6666, 'food': 5555, 'transport': 4444}) == 8.888\n\n    [/EXAMPLES]\n    \"\"\"\n    # Define conversion factors\n    conversion_factors = {\n        'energy': 0.0005,    # kWh to gha\n        'water': 0.0001,     # m\u00b3 to gha\n        'waste': 0.0002,     # kg to gha\n        'food': 0.0003,      # kg to gha\n        'transport': 0.00015 # km to gha\n    }\n    \n    # Calculate the ecological footprint\n    total_footprint = sum(\n        consumption.get(category, 0) * factor\n        for category, factor in conversion_factors.items()\n    )\n    \n    # Round to 3 decimal places\n    return round(total_footprint, 3)\n\n", "test": "def check(candidate):\n    assert candidate({'energy': 3000, 'water': 100, 'waste': 400, 'food': 600, 'transport': 5000}) == 2.52\n    assert candidate({'energy': 9876, 'water': 5432, 'waste': 1098, 'food': 7654, 'transport': 3210}) == 8.478\n    assert candidate({'energy': 2000, 'water': 75, 'waste': 300, 'food': 400, 'transport': 7500}) == 2.312\n    assert candidate({'energy': 7500, 'water': 200, 'waste': 800, 'food': 1000, 'transport': 15000}) == 6.48\n    assert candidate({'energy': 8888, 'water': 7777, 'waste': 6666, 'food': 5555, 'transport': 4444}) == 8.888\n    assert candidate({'energy': 25000, 'water': 2500, 'waste': 5000, 'food': 7500, 'transport': 75000}) == 27.25\n    assert candidate({'energy': 1111, 'water': 2222, 'waste': 3333, 'food': 4444, 'transport': 5555}) == 3.611\n    assert candidate({'energy': 500, 'water': 50, 'waste': 100, 'food': 200, 'transport': 2000}) == 0.635\n    assert candidate({'energy': 0, 'water': 0, 'waste': 0, 'food': 0, 'transport': 0}) == 0.0\n    assert candidate({'energy': 50000, 'water': 5000, 'waste': 10000, 'food': 15000, 'transport': 100000}) == 47.0\n", "language": "python"}
{"task_id": "e6bc75d7-bf07-4905-b852-5d888ad57518-8873898215987337307", "prompt": "Your job is to write the complete implementation of a given function, making sure it executes properly as a standalone code block. Don't add any code outside the function's scope. Use only the libraries that are already imported in the problem. Create any necessary helper functions or classes inside the main function. Provide exactly one code block with your implementation.\n\n```python\nfrom typing import List\n\ndef alien_language_translator(message: str, dictionary: List[List[str]]) -> str:\n    \"\"\"\n    An alien civilization has made contact and provided a dictionary to translate\n    their language to English. Each word in their language can have multiple English\n    translations. Your task is to translate a message from their language to English.\n\n    If a word has multiple translations, use the first one in the dictionary.\n    If a word is not in the dictionary, leave it unchanged.\n\n    Args:\n    message (str): The alien message to be translated.\n    dictionary (List[List[str]]): A list of translation pairs [alien_word, english_word].\n\n    Returns:\n    str: The translated message in English.\n\n\n    [EXAMPLES]\n    \n    assert candidate(\"untranslatable\", [[\"other\", \"words\"]]) == 'untranslatable'\n    assert candidate(\"a b c d e\", [[\"a\", \"1\"], [\"b\", \"2\"], [\"c\", \"3\"], [\"d\", \"4\"], [\"e\", \"5\"]]) == '1 2 3 4 5'\n\n    [/EXAMPLES]\n    \"\"\"\n```\n", "entry_point": "alien_language_translator", "solution": "from typing import List\n\ndef alien_language_translator(message: str, dictionary: List[List[str]]) -> str:\n    \"\"\"\n    An alien civilization has made contact and provided a dictionary to translate\n    their language to English. Each word in their language can have multiple English\n    translations. Your task is to translate a message from their language to English.\n\n    If a word has multiple translations, use the first one in the dictionary.\n    If a word is not in the dictionary, leave it unchanged.\n\n    Args:\n    message (str): The alien message to be translated.\n    dictionary (List[List[str]]): A list of translation pairs [alien_word, english_word].\n\n    Returns:\n    str: The translated message in English.\n\n\n    [EXAMPLES]\n    \n    assert candidate(\"untranslatable\", [[\"other\", \"words\"]]) == 'untranslatable'\n    assert candidate(\"a b c d e\", [[\"a\", \"1\"], [\"b\", \"2\"], [\"c\", \"3\"], [\"d\", \"4\"], [\"e\", \"5\"]]) == '1 2 3 4 5'\n\n    [/EXAMPLES]\n    \"\"\"\n    # Create a dictionary for quick lookup\n    translation_dict = {}\n    for alien_word, english_word in dictionary:\n        if alien_word not in translation_dict:\n            translation_dict[alien_word] = english_word\n\n    # Split the message into words\n    alien_words = message.split()\n\n    # Translate each word\n    translated_words = []\n    for word in alien_words:\n        translated_words.append(translation_dict.get(word, word))\n\n    # Join the translated words back into a sentence\n    return \" \".join(translated_words)\n\n", "test": "def check(candidate):\n    assert candidate(\"untranslatable\", [[\"other\", \"words\"]]) == 'untranslatable'\n    assert candidate(\"foo bar baz\", [[\"foo\", \"hello\"], [\"bar\", \"world\"], [\"baz\", \"!\"]]) == 'hello world !'\n    assert candidate(\"special!@#characters\", [[\"special\", \"normal\"], [\"characters\", \"letters\"]]) == 'special!@#characters'\n    assert candidate(\"a b c d e\", [[\"a\", \"1\"], [\"b\", \"2\"], [\"c\", \"3\"], [\"d\", \"4\"], [\"e\", \"5\"]]) == '1 2 3 4 5'\n    assert candidate(\"a\" * 1000, [[\"a\", \"z\"]]) == 'aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa'\n    assert candidate(\"numbers123\", [[\"numbers\", \"digits\"]]) == 'numbers123'\n    assert candidate(\"repeated repeated word\", [[\"repeated\", \"echo\"], [\"word\", \"sound\"]]) == 'echo echo sound'\n    assert candidate(\"mixed 123 content\", [[\"mixed\", \"pure\"], [\"content\", \"substance\"]]) == 'pure 123 substance'\n    assert candidate(\"zorg blorg\", [[\"zorg\", \"hello\"], [\"blorg\", \"world\"]]) == 'hello world'\n    assert candidate(\"a b c\", [[\"a\", \"1\"], [\"b\", \"2\"], [\"c\", \"3\"]]) == '1 2 3'\n", "language": "python"}
{"task_id": "6c4b2e61-57d1-426a-a0e1-b2863fa289456384385908942493116", "prompt": "Please finish implementing a function that can be executed standalone in one code block. Don't include any code outside the function boundaries. Restrict yourself to using only the libraries imported in the original problem. If you need auxiliary functions or classes, nest them inside the main function. Your response should consist of exactly one code block.\n\n```python\ndef restaurant_tip_calculator(bill_amount: float, service_quality: str, split: int) -> float:\n    \"\"\"\n    A group of diners at a restaurant wants to calculate the appropriate tip based on their bill,\n    the quality of service, and how many ways they want to split the bill.\n\n    This function takes the bill amount, a rating of service quality (excellent, good, fair, or poor),\n    and the number of people splitting the bill. It returns the tip amount per person.\n\n\n    [EXAMPLES]\n    \n    assert candidate(80.25, \"excellent\", 4) == 4.01\n    assert candidate(300.00, \"poor\", 6) == 2.5\n\n    [/EXAMPLES]\n    \"\"\"\n```\n", "entry_point": "restaurant_tip_calculator", "solution": "def restaurant_tip_calculator(bill_amount: float, service_quality: str, split: int) -> float:\n    \"\"\"\n    A group of diners at a restaurant wants to calculate the appropriate tip based on their bill,\n    the quality of service, and how many ways they want to split the bill.\n\n    This function takes the bill amount, a rating of service quality (excellent, good, fair, or poor),\n    and the number of people splitting the bill. It returns the tip amount per person.\n\n\n    [EXAMPLES]\n    \n    assert candidate(80.25, \"excellent\", 4) == 4.01\n    assert candidate(300.00, \"poor\", 6) == 2.5\n\n    [/EXAMPLES]\n    \"\"\"\n    # Define tip percentages based on service quality\n    tip_percentages = {\n        \"excellent\": 0.20,\n        \"good\": 0.15,\n        \"fair\": 0.10,\n        \"poor\": 0.05\n    }\n    \n    # Get the appropriate tip percentage based on service quality\n    tip_percentage = tip_percentages.get(service_quality.lower(), 0.15)  # Default to 15% if not found\n    \n    # Calculate the total tip\n    total_tip = bill_amount * tip_percentage\n    \n    # Calculate the tip per person\n    tip_per_person = total_tip / split\n    \n    # Round the result to 2 decimal places\n    return round(tip_per_person, 2)\n\n", "test": "def check(candidate):\n    assert candidate(80.25, \"excellent\", 4) == 4.01\n    assert candidate(300.00, \"poor\", 6) == 2.5\n    assert candidate(999.99, \"excellent\", 1) == 200.0\n    assert candidate(40.25, \"fair\", 4) == 1.01\n    assert candidate(10.00, \"poor\", 1) == 0.5\n    assert candidate(45.75, \"fair\", 3) == 1.53\n    assert candidate(125.50, \"good\", 5) == 3.76\n    assert candidate(90.00, \"excellent\", 3) == 6.0\n    assert candidate(25.50, \"good\", 1) == 3.82\n    assert candidate(150.75, \"good\", 3) == 7.54\n", "language": "python"}
{"task_id": "c8baa7cd-4580-44e7-81ca-3b830f1f23ac-6270469239761284605", "prompt": "Please complete the function based on its docstring. Include a single code block with the implementation, ensuring edge cases are handled properly.\n\n```python\nfrom typing import List\nimport heapq\n\ndef optimize_network_latency(nodes: int, connections: List[List[int]], data_centers: List[int]) -> int:\n    \"\"\"\n    A tech company wants to optimize its network infrastructure to minimize latency.\n    Given a network of nodes, connections between nodes with their latencies, and the locations of data centers,\n    calculate the minimum time required to send data from any node to the nearest data center.\n\n    :param nodes: Total number of nodes in the network\n    :param connections: List of [node1, node2, latency] representing connections and their latencies\n    :param data_centers: List of node IDs where data centers are located\n    :return: The maximum of all minimum latencies from any node to its nearest data center\n\n\n    [EXAMPLES]\n    \n    assert candidate(6, [[0, 1, 1], [1, 2, 2], [2, 3, 3], [3, 4, 4], [4, 5, 5], [0, 5, 10]], [0, 5]) == 6\n    assert candidate(3, [[0, 1, 1000000], [1, 2, 1000000]], [0, 2]) == 1000000\n\n    [/EXAMPLES]\n    \"\"\"\n```\n", "entry_point": "optimize_network_latency", "solution": "from typing import List\nimport heapq\n\ndef optimize_network_latency(nodes: int, connections: List[List[int]], data_centers: List[int]) -> int:\n    \"\"\"\n    A tech company wants to optimize its network infrastructure to minimize latency.\n    Given a network of nodes, connections between nodes with their latencies, and the locations of data centers,\n    calculate the minimum time required to send data from any node to the nearest data center.\n\n    :param nodes: Total number of nodes in the network\n    :param connections: List of [node1, node2, latency] representing connections and their latencies\n    :param data_centers: List of node IDs where data centers are located\n    :return: The maximum of all minimum latencies from any node to its nearest data center\n\n\n    [EXAMPLES]\n    \n    assert candidate(6, [[0, 1, 1], [1, 2, 2], [2, 3, 3], [3, 4, 4], [4, 5, 5], [0, 5, 10]], [0, 5]) == 6\n    assert candidate(3, [[0, 1, 1000000], [1, 2, 1000000]], [0, 2]) == 1000000\n\n    [/EXAMPLES]\n    \"\"\"\n    # Create an adjacency list to represent the graph\n    graph = [[] for _ in range(nodes)]\n    for node1, node2, latency in connections:\n        graph[node1].append((node2, latency))\n        graph[node2].append((node1, latency))\n    \n    # Initialize distances and priority queue\n    distances = [float('inf')] * nodes\n    pq = []\n    \n    # Start from all data centers\n    for dc in data_centers:\n        distances[dc] = 0\n        heapq.heappush(pq, (0, dc))\n    \n    # Dijkstra's algorithm\n    while pq:\n        dist, node = heapq.heappop(pq)\n        \n        if dist > distances[node]:\n            continue\n        \n        for neighbor, latency in graph[node]:\n            new_dist = dist + latency\n            if new_dist < distances[neighbor]:\n                distances[neighbor] = new_dist\n                heapq.heappush(pq, (new_dist, neighbor))\n    \n    # Find the maximum of all minimum latencies\n    max_latency = max(distances)\n    \n    return max_latency if max_latency != float('inf') else -1\n\n", "test": "def check(candidate):\n    assert candidate(4, [[0, 1, 1], [0, 2, 2], [0, 3, 3], [1, 2, 4], [1, 3, 5], [2, 3, 6]], [3]) == 5\n    assert candidate(5, [[0, 1, 1], [1, 2, 2], [2, 3, 3], [3, 4, 4], [0, 4, 5]], []) == -1\n    assert candidate(7, [[0, 1, 2], [1, 2, 3], [2, 3, 4], [3, 4, 5], [4, 5, 6], [5, 6, 7]], [0, 3, 6]) == 7\n    assert candidate(5, [[0, 1, 10], [1, 2, 5], [2, 3, 7], [3, 4, 8], [0, 4, 15]], [0, 3]) == 10\n    assert candidate(6, [[0, 1, 1], [1, 2, 2], [2, 3, 3], [3, 4, 4], [4, 5, 5], [0, 5, 10]], [0, 5]) == 6\n    assert candidate(4, [[0, 1, 1], [1, 2, 1], [2, 3, 1], [0, 3, 10]], [1, 2]) == 1\n    assert candidate(6, [[i, j, 1] for i in range(6) for j in range(i+1, 6)], [0]) == 1\n    assert candidate(5, [[0, 1, 1], [1, 2, 1], [2, 3, 1], [3, 4, 1], [0, 4, 1]], [2]) == 2\n    assert candidate(2, [[0, 1, 100]], [0, 1]) == 0\n    assert candidate(3, [[0, 1, 1000000], [1, 2, 1000000]], [0, 2]) == 1000000\n", "language": "python"}
{"task_id": "04969393-4ef8-4844-a295-aa3d744c98a93579062881948505548", "prompt": "Please complete the following function based on the provided docstring. Here's the implementation in a single code block:\n\n```python\nimport re\nfrom typing import List\nfrom collections import Counter\n\ndef word_frequency(text: str) -> List[tuple]:\n    \"\"\"\n    A linguist is analyzing the frequency of words in a given text.\n    This function takes a string of text and returns a list of tuples containing each unique word and its frequency,\n    sorted in descending order of frequency.\n\n    Args:\n    text (str): The input text to analyze.\n\n    Returns:\n    List[tuple]: A list of tuples, each containing a word and its frequency, sorted by frequency in descending order.\n\n\n    [EXAMPLES]\n    \n    assert candidate(\"This is a test. This is only a test. If this had been an actual emergency, you would have been instructed where to tune in your area for news and official information.\") == [('this', 3), ('a', 2), ('been', 2), ('is', 2), ('test', 2), ('actual', 1), ('an', 1), ('and', 1), ('area', 1), ('emergency', 1), ('for', 1), ('had', 1), ('have', 1), ('if', 1), ('in', 1), ('information', 1), ('instructed', 1), ('news', 1), ('official', 1), ('only', 1), ('to', 1), ('tune', 1), ('where', 1), ('would', 1), ('you', 1), ('your', 1)]\n    assert candidate(\"the quick brown fox jumps over the lazy dog\") == [('the', 2), ('brown', 1), ('dog', 1), ('fox', 1), ('jumps', 1), ('lazy', 1), ('over', 1), ('quick', 1)]\n\n    [/EXAMPLES]\n    \"\"\"\n```\n", "entry_point": "word_frequency", "solution": "import re\nfrom typing import List\nfrom collections import Counter\n\ndef word_frequency(text: str) -> List[tuple]:\n    \"\"\"\n    A linguist is analyzing the frequency of words in a given text.\n    This function takes a string of text and returns a list of tuples containing each unique word and its frequency,\n    sorted in descending order of frequency.\n\n    Args:\n    text (str): The input text to analyze.\n\n    Returns:\n    List[tuple]: A list of tuples, each containing a word and its frequency, sorted by frequency in descending order.\n\n\n    [EXAMPLES]\n    \n    assert candidate(\"This is a test. This is only a test. If this had been an actual emergency, you would have been instructed where to tune in your area for news and official information.\") == [('this', 3), ('a', 2), ('been', 2), ('is', 2), ('test', 2), ('actual', 1), ('an', 1), ('and', 1), ('area', 1), ('emergency', 1), ('for', 1), ('had', 1), ('have', 1), ('if', 1), ('in', 1), ('information', 1), ('instructed', 1), ('news', 1), ('official', 1), ('only', 1), ('to', 1), ('tune', 1), ('where', 1), ('would', 1), ('you', 1), ('your', 1)]\n    assert candidate(\"the quick brown fox jumps over the lazy dog\") == [('the', 2), ('brown', 1), ('dog', 1), ('fox', 1), ('jumps', 1), ('lazy', 1), ('over', 1), ('quick', 1)]\n\n    [/EXAMPLES]\n    \"\"\"\n    # Remove punctuation and convert to lowercase\n    cleaned_text = re.sub(r'[^\\w\\s]', '', text.lower())\n    \n    # Split the text into words\n    words = cleaned_text.split()\n    \n    # Count the frequency of each word\n    word_counts = Counter(words)\n    \n    # Sort the word counts by frequency in descending order\n    sorted_word_counts = sorted(word_counts.items(), key=lambda x: (-x[1], x[0]))\n    \n    return sorted_word_counts\n\n", "test": "def check(candidate):\n    assert candidate(\"How much wood would a woodchuck chuck if a woodchuck could chuck wood?\") == [('a', 2), ('chuck', 2), ('wood', 2), ('woodchuck', 2), ('could', 1), ('how', 1), ('if', 1), ('much', 1), ('would', 1)]\n    assert candidate(\"a a a a a\") == [('a', 5)]\n    assert candidate(\"a\") == [('a', 1)]\n    assert candidate(\"Peter Piper picked a peck of pickled peppers\") == [('a', 1), ('of', 1), ('peck', 1), ('peppers', 1), ('peter', 1), ('picked', 1), ('pickled', 1), ('piper', 1)]\n    assert candidate(\"The quick brown fox jumps over the lazy dog. The quick brown fox jumps over the lazy dog.\") == [('the', 4), ('brown', 2), ('dog', 2), ('fox', 2), ('jumps', 2), ('lazy', 2), ('over', 2), ('quick', 2)]\n    assert candidate(\"a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q,r,s,t,u,v,w,x,y,z\") == [('abcdefghijklmnopqrstuvwxyz', 1)]\n    assert candidate(\"This is a test. This is only a test. If this had been an actual emergency, you would have been instructed where to tune in your area for news and official information.\") == [('this', 3), ('a', 2), ('been', 2), ('is', 2), ('test', 2), ('actual', 1), ('an', 1), ('and', 1), ('area', 1), ('emergency', 1), ('for', 1), ('had', 1), ('have', 1), ('if', 1), ('in', 1), ('information', 1), ('instructed', 1), ('news', 1), ('official', 1), ('only', 1), ('to', 1), ('tune', 1), ('where', 1), ('would', 1), ('you', 1), ('your', 1)]\n    assert candidate(\"   \") == []\n    assert candidate(\"the quick brown fox jumps over the lazy dog\") == [('the', 2), ('brown', 1), ('dog', 1), ('fox', 1), ('jumps', 1), ('lazy', 1), ('over', 1), ('quick', 1)]\n    assert candidate(\"Buffalo buffalo Buffalo buffalo buffalo buffalo Buffalo buffalo\") == [('buffalo', 8)]\n", "language": "python"}
{"task_id": "3dcc6f7c-dcad-4172-abb4-8ae8ceb61a6e-6754511683897494546", "prompt": "Please complete the function as described in the documentation. Write the entire implementation in a single code block, considering all edge cases.\n\n```python\ndef calculate_shipping_cost(weight: float, distance: float, fragile: bool) -> float:\n    \"\"\"\n    Calculate the shipping cost for a package based on its weight, shipping distance, and fragility.\n\n    The shipping cost is calculated as follows:\n    - Base cost: $5\n    - Weight cost: $0.5 per pound\n    - Distance cost: $0.1 per mile\n    - Fragile surcharge: $10 if the item is fragile\n\n    Parameters:\n    weight (float): Weight of the package in pounds\n    distance (float): Shipping distance in miles\n    fragile (bool): Whether the package contains fragile items\n\n    Returns:\n    float: Total shipping cost\n\n\n    [EXAMPLES]\n    \n    assert candidate(5, 50, True) == 22.5\n    assert candidate(9999.99, 9999.99, True) == 6014.99\n\n    [/EXAMPLES]\n    \"\"\"\n```\n", "entry_point": "calculate_shipping_cost", "solution": "def calculate_shipping_cost(weight: float, distance: float, fragile: bool) -> float:\n    \"\"\"\n    Calculate the shipping cost for a package based on its weight, shipping distance, and fragility.\n\n    The shipping cost is calculated as follows:\n    - Base cost: $5\n    - Weight cost: $0.5 per pound\n    - Distance cost: $0.1 per mile\n    - Fragile surcharge: $10 if the item is fragile\n\n    Parameters:\n    weight (float): Weight of the package in pounds\n    distance (float): Shipping distance in miles\n    fragile (bool): Whether the package contains fragile items\n\n    Returns:\n    float: Total shipping cost\n\n\n    [EXAMPLES]\n    \n    assert candidate(5, 50, True) == 22.5\n    assert candidate(9999.99, 9999.99, True) == 6014.99\n\n    [/EXAMPLES]\n    \"\"\"\n    # Base cost\n    total_cost = 5.0\n\n    # Weight cost\n    total_cost += weight * 0.5\n\n    # Distance cost\n    total_cost += distance * 0.1\n\n    # Fragile surcharge\n    if fragile:\n        total_cost += 10.0\n\n    # Round the total cost to 2 decimal places\n    return round(total_cost, 2)\n\n", "test": "def check(candidate):\n    assert candidate(5, 50, True) == 22.5\n    assert candidate(30, 150, True) == 45.0\n    assert candidate(10, 100, False) == 20.0\n    assert candidate(42, 42, False) == 30.2\n    assert candidate(0, 0, False) == 5.0\n    assert candidate(99.99, 999.99, False) == 154.99\n    assert candidate(9999.99, 9999.99, True) == 6014.99\n    assert candidate(1, 1, True) == 15.6\n    assert candidate(7.5, 175.5, True) == 36.3\n    assert candidate(0.1, 0.1, True) == 15.06\n", "language": "python"}
{"task_id": "e4c6992c-7751-4a8f-8446-620fccf346ec5593504897329661254", "prompt": "I'm a coding assistant focused on completing functions that work right out of the box. I'll only work within the function you provide, using just the libraries mentioned in your problem. Any additional code structures will be defined within your main function.\n\n```python\ndef optimize_solar_panel_placement(roof_dimensions: tuple, panel_dimensions: tuple) -> int:\n    \"\"\"\n    In an effort to maximize renewable energy production, a homeowner wants to determine\n    the optimal number of solar panels that can fit on their roof. The roof and solar panels\n    are rectangular, and the panels must be placed with their edges parallel to the roof's edges.\n\n    This function takes the dimensions of the roof (length, width) and the dimensions of a single\n    solar panel (length, width) as input. It returns the maximum number of panels that can be\n    placed on the roof without overlapping or extending beyond the roof's edges.\n\n\n    [EXAMPLES]\n    \n    assert candidate((60, 45), (12, 9)) == 25\n    assert candidate((25, 18), (4.5, 3)) == 32\n\n    [/EXAMPLES]\n    \"\"\"\n```\n", "entry_point": "optimize_solar_panel_placement", "solution": "def optimize_solar_panel_placement(roof_dimensions: tuple, panel_dimensions: tuple) -> int:\n    \"\"\"\n    In an effort to maximize renewable energy production, a homeowner wants to determine\n    the optimal number of solar panels that can fit on their roof. The roof and solar panels\n    are rectangular, and the panels must be placed with their edges parallel to the roof's edges.\n\n    This function takes the dimensions of the roof (length, width) and the dimensions of a single\n    solar panel (length, width) as input. It returns the maximum number of panels that can be\n    placed on the roof without overlapping or extending beyond the roof's edges.\n\n\n    [EXAMPLES]\n    \n    assert candidate((60, 45), (12, 9)) == 25\n    assert candidate((25, 18), (4.5, 3)) == 32\n\n    [/EXAMPLES]\n    \"\"\"\n    def calculate_panels(roof_side, panel_side):\n        return int(roof_side // panel_side)\n\n    roof_length, roof_width = roof_dimensions\n    panel_length, panel_width = panel_dimensions\n\n    # Calculate panels in normal orientation\n    panels_normal = calculate_panels(roof_length, panel_length) * calculate_panels(roof_width, panel_width)\n\n    # Calculate panels in rotated orientation\n    panels_rotated = calculate_panels(roof_length, panel_width) * calculate_panels(roof_width, panel_length)\n\n    # Return the maximum of the two orientations\n    return max(panels_normal, panels_rotated)\n\n", "test": "def check(candidate):\n    assert candidate((5.5, 3.2), (1.2, 0.8)) == 16\n    assert candidate((10, 8), (2, 1)) == 40\n    assert candidate((40, 30), (8, 6)) == 25\n    assert candidate((6, 4), (1, 1)) == 24\n    assert candidate((25, 18), (4.5, 3)) == 32\n    assert candidate((12.5, 8.75), (2.5, 1.75)) == 25\n    assert candidate((13.7, 10.3), (2.7, 2.1)) == 20\n    assert candidate((100, 100), (10, 10)) == 100\n    assert candidate((60, 45), (12, 9)) == 25\n    assert candidate((10.5, 7.5), (2.1, 1.5)) == 21\n", "language": "python"}
{"task_id": "acd53682-5049-4a9a-859b-cb20e15c30501140187711626305746", "prompt": "Code the function based on the instructions in the docstring. Keep all additional code structures contained within the function definition.\n\n```python\ndef grade_calculator(scores: dict) -> dict:\n    \"\"\"\n    A teacher wants to calculate letter grades based on numerical scores for different subjects.\n    This function takes a dictionary of subject-score pairs and returns a new dictionary\n    with subject-grade pairs. Grading scale: A (90-100), B (80-89), C (70-79), D (60-69), F (0-59).\n\n\n    [EXAMPLES]\n    \n    assert candidate({'Math': 100}) == {'Math': 'A'}\n    assert candidate({}) == {}\n\n    [/EXAMPLES]\n    \"\"\"\n```\n", "entry_point": "grade_calculator", "solution": "def grade_calculator(scores: dict) -> dict:\n    \"\"\"\n    A teacher wants to calculate letter grades based on numerical scores for different subjects.\n    This function takes a dictionary of subject-score pairs and returns a new dictionary\n    with subject-grade pairs. Grading scale: A (90-100), B (80-89), C (70-79), D (60-69), F (0-59).\n\n\n    [EXAMPLES]\n    \n    assert candidate({'Math': 100}) == {'Math': 'A'}\n    assert candidate({}) == {}\n\n    [/EXAMPLES]\n    \"\"\"\n    def get_letter_grade(score):\n        if score >= 90:\n            return 'A'\n        elif score >= 80:\n            return 'B'\n        elif score >= 70:\n            return 'C'\n        elif score >= 60:\n            return 'D'\n        else:\n            return 'F'\n\n    grades = {}\n    for subject, score in scores.items():\n        grades[subject] = get_letter_grade(score)\n    \n    return grades\n\n", "test": "def check(candidate):\n    assert candidate({'History': 80}) == {'History': 'B'}\n    assert candidate({'Math': 100}) == {'Math': 'A'}\n    assert candidate({'Math': 0, 'English': 100}) == {'Math': 'F', 'English': 'A'}\n    assert candidate({'Math': 90, 'English': 80, 'Science': 70, 'History': 60, 'Art': 50}) == {'Math': 'A', 'English': 'B', 'Science': 'C', 'History': 'D', 'Art': 'F'}\n    assert candidate({'Math': 75, 'English': 85, 'Science': 95}) == {'Math': 'C', 'English': 'B', 'Science': 'A'}\n    assert candidate({'Math': 59.9, 'English': 60.1}) == {'Math': 'F', 'English': 'D'}\n    assert candidate({'Chemistry': 69}) == {'Chemistry': 'D'}\n    assert candidate({'Biology': 60}) == {'Biology': 'D'}\n    assert candidate({}) == {}\n    assert candidate({'History': 65, 'Art': 88, 'Physics': 55, 'Chemistry': 72}) == {'History': 'D', 'Art': 'B', 'Physics': 'F', 'Chemistry': 'C'}\n", "language": "python"}
{"task_id": "24b18d7a-2946-4c05-b179-cef2abcf4ea6-4232992312896418006", "prompt": "I'll complete the requested function so it's ready to execute. My implementation will be contained entirely within one code block, using only the permitted libraries. If needed, I'll define any helper functions or classes inside the main function to ensure the solution is self-contained.\n\n```python\nfrom typing import List\n\ndef decode_alien_message(transmission: str, codebook: List[str]) -> str:\n    \"\"\"\n    An interstellar linguist is trying to decode a message received from an alien civilization.\n    The message is a string of symbols, and the linguist has a codebook of known alien words.\n    This function attempts to decode the message by matching the longest possible words from\n    the codebook, working from left to right.\n\n    Args:\n    transmission (str): The received alien message as a string of symbols.\n    codebook (List[str]): A list of known alien words, sorted by length in descending order.\n\n    Returns:\n    str: The decoded message, with unmatched symbols left as is.\n\n\n    [EXAMPLES]\n    \n    assert candidate(\"ABCDEFG\", [\"ABC\", \"DEF\", \"G\"]) == 'ABC DEF G'\n    assert candidate(\"ZXCVBNM\", [\"ZXC\", \"VBN\", \"M\"]) == 'ZXC VBN M'\n\n    [/EXAMPLES]\n    \"\"\"\n```\n", "entry_point": "decode_alien_message", "solution": "from typing import List\n\ndef decode_alien_message(transmission: str, codebook: List[str]) -> str:\n    \"\"\"\n    An interstellar linguist is trying to decode a message received from an alien civilization.\n    The message is a string of symbols, and the linguist has a codebook of known alien words.\n    This function attempts to decode the message by matching the longest possible words from\n    the codebook, working from left to right.\n\n    Args:\n    transmission (str): The received alien message as a string of symbols.\n    codebook (List[str]): A list of known alien words, sorted by length in descending order.\n\n    Returns:\n    str: The decoded message, with unmatched symbols left as is.\n\n\n    [EXAMPLES]\n    \n    assert candidate(\"ABCDEFG\", [\"ABC\", \"DEF\", \"G\"]) == 'ABC DEF G'\n    assert candidate(\"ZXCVBNM\", [\"ZXC\", \"VBN\", \"M\"]) == 'ZXC VBN M'\n\n    [/EXAMPLES]\n    \"\"\"\n    decoded_message = []\n    i = 0\n    \n    while i < len(transmission):\n        matched = False\n        for word in codebook:\n            if transmission.startswith(word, i):\n                decoded_message.append(word)\n                i += len(word)\n                matched = True\n                break\n        \n        if not matched:\n            decoded_message.append(transmission[i])\n            i += 1\n    \n    return ' '.join(decoded_message)\n\n", "test": "def check(candidate):\n    assert candidate(\"LKJHGFDSA\", [\"LKJ\", \"HGF\", \"DSA\"]) == 'LKJ HGF DSA'\n    assert candidate(\"ABCDEFG\", [\"ABC\", \"DEF\", \"G\"]) == 'ABC DEF G'\n    assert candidate(\"ZXCVBNM\", [\"ZXC\", \"VBN\", \"M\"]) == 'ZXC VBN M'\n    assert candidate(\"AABBCCDDEE\", [\"AA\", \"BB\", \"CC\", \"DD\", \"EE\"]) == 'AA BB CC DD EE'\n    assert candidate(\"\", [\"ABC\", \"DEF\"]) == ''\n    assert candidate(\"ABCDEFGHIJKLMNOPQRSTUVWXYZ\", [\"ABCDEFGHIJKLMNOPQRSTUVWXYZ\"]) == 'ABCDEFGHIJKLMNOPQRSTUVWXYZ'\n    assert candidate(\"THEQUICKBROWNFOXJUMPSOVERTHELAZYDOG\", [\"THE\", \"QUICK\", \"BROWN\", \"FOX\", \"JUMPS\", \"OVER\", \"LAZY\", \"DOG\"]) == 'THE QUICK BROWN FOX JUMPS OVER THE LAZY DOG'\n    assert candidate(\"A\", [\"B\", \"C\"]) == 'A'\n    assert candidate(\"ABCABC\", [\"ABC\", \"AB\", \"C\"]) == 'ABC ABC'\n    assert candidate(\"XYZXYZXYZ\", [\"XYZ\"]) == 'XYZ XYZ XYZ'\n", "language": "python"}
{"task_id": "200cb801-334b-4727-887a-ff56bdf2e529-8261313489850335180", "prompt": "Based on the docstring instructions, I'll write the full implementation of the function in a single code block.\n\n```python\ndef cipher_decode(message: str, shift: int) -> str:\n    \"\"\"\n    Decode a message encrypted using a Caesar cipher with a given shift value.\n    \n    This function uses recursion to decode each character in the message. It preserves\n    the case of letters and leaves non-alphabetic characters unchanged.\n    \n    Args:\n    message (str): The encrypted message to be decoded.\n    shift (int): The number of positions each letter was shifted during encryption.\n    \n    Returns:\n    str: The decoded message.\n    \n\n    [EXAMPLES]\n    \n    assert candidate(\"!@#$%^&*()\", 15) == '!@#$%^&*()'\n    assert candidate(\"Hello, World!\", 0) == 'Hello, World!'\n\n    [/EXAMPLES]\n    \"\"\"\n```\n", "entry_point": "cipher_decode", "solution": "def cipher_decode(message: str, shift: int) -> str:\n    \"\"\"\n    Decode a message encrypted using a Caesar cipher with a given shift value.\n    \n    This function uses recursion to decode each character in the message. It preserves\n    the case of letters and leaves non-alphabetic characters unchanged.\n    \n    Args:\n    message (str): The encrypted message to be decoded.\n    shift (int): The number of positions each letter was shifted during encryption.\n    \n    Returns:\n    str: The decoded message.\n    \n\n    [EXAMPLES]\n    \n    assert candidate(\"!@#$%^&*()\", 15) == '!@#$%^&*()'\n    assert candidate(\"Hello, World!\", 0) == 'Hello, World!'\n\n    [/EXAMPLES]\n    \"\"\"\n    def decode_char(char: str) -> str:\n        if not char.isalpha():\n            return char\n        \n        ascii_offset = ord('A') if char.isupper() else ord('a')\n        decoded_ascii = (ord(char) - ascii_offset - shift) % 26 + ascii_offset\n        return chr(decoded_ascii)\n    \n    if not message:\n        return \"\"\n    \n    return decode_char(message[0]) + cipher_decode(message[1:], shift)\n\n\n", "test": "def check(candidate):\n    assert candidate(\"Zab\", 1) == 'Yza'\n    assert candidate(\"Hello, World!\", 0) == 'Hello, World!'\n    assert candidate(\"Qzuipo Qsphsbnnjoh\", 1) == 'Python Programming'\n    assert candidate(\"AbCdEfG\", 52) == 'AbCdEfG'\n    assert candidate(\"\", 0) == ''\n    assert candidate(\"A\", 26) == 'A'\n    assert candidate(\"!@#$%^&*()\", 15) == '!@#$%^&*()'\n    assert candidate(\"lowercase\", 10) == 'bemuhsqiu'\n    assert candidate(\"aAaA\", 1000000) == 'mMmM'\n    assert candidate(\"Python Programming\", -1) == 'Qzuipo Qsphsbnnjoh'\n", "language": "python"}
{"task_id": "0ea3dcce-c87d-4a77-8a2c-d57535c9574c3557286706825171253", "prompt": "Let me complete this code snippet for you, keeping all additional functions and classes contained within the main function as specified.\n\n```python\nfrom typing import List\nimport math\n\ndef calculate_orbital_period(semi_major_axis: float, celestial_bodies: List[float]) -> List[float]:\n    \"\"\"\n    In the field of astrophysics, calculating orbital periods is crucial for understanding\n    planetary systems. This function calculates the orbital period of a body around multiple\n    central masses using Kepler's Third Law.\n    \n    The function takes the semi-major axis of the orbit (in astronomical units) and a list\n    of masses of celestial bodies (in solar masses), then returns a list of orbital periods\n    (in Earth years) for each central mass.\n    \n\n    [EXAMPLES]\n    \n    assert candidate(1.0, [0.1, 1.0, 10.0]) == [3.1622776601683795, 1.0, 0.31622776601683794]\n    assert candidate(9.5, [1.0]) == [29.280966514102637]\n\n    [/EXAMPLES]\n    \"\"\"\n```\n", "entry_point": "calculate_orbital_period", "solution": "from typing import List\nimport math\n\ndef calculate_orbital_period(semi_major_axis: float, celestial_bodies: List[float]) -> List[float]:\n    \"\"\"\n    In the field of astrophysics, calculating orbital periods is crucial for understanding\n    planetary systems. This function calculates the orbital period of a body around multiple\n    central masses using Kepler's Third Law.\n    \n    The function takes the semi-major axis of the orbit (in astronomical units) and a list\n    of masses of celestial bodies (in solar masses), then returns a list of orbital periods\n    (in Earth years) for each central mass.\n    \n\n    [EXAMPLES]\n    \n    assert candidate(1.0, [0.1, 1.0, 10.0]) == [3.1622776601683795, 1.0, 0.31622776601683794]\n    assert candidate(9.5, [1.0]) == [29.280966514102637]\n\n    [/EXAMPLES]\n    \"\"\"\n    def kepler_third_law(a: float, m: float) -> float:\n        \"\"\"\n        Calculate the orbital period using Kepler's Third Law.\n        a: semi-major axis in AU\n        m: mass of the central body in solar masses\n        Returns the orbital period in Earth years\n        \"\"\"\n        return math.sqrt((a ** 3) / m)\n    \n    orbital_periods = []\n    for mass in celestial_bodies:\n        period = kepler_third_law(semi_major_axis, mass)\n        orbital_periods.append(period)\n    \n    return orbital_periods\n\n", "test": "def check(candidate):\n    assert candidate(3.14159, [3.14159]) == [3.14159]\n    assert candidate(0.387, [1.0]) == [0.24075008411213486]\n    assert candidate(9.5, [0.5, 1.5, 2.5]) == [41.4095399636364, 23.90780904502404, 18.518909255137032]\n    assert candidate(1.0, [0.1, 1.0, 10.0]) == [3.1622776601683795, 1.0, 0.31622776601683794]\n    assert candidate(1.52, [1.0]) == [1.873981856902569]\n    assert candidate(100.0, [0.001, 0.01, 0.1, 1.0, 10.0, 100.0]) == [31622.776601683792, 10000.0, 3162.2776601683795, 1000.0, 316.22776601683796, 100.0]\n    assert candidate(10.0, [0.1, 1.0, 10.0, 100.0]) == [100.0, 31.622776601683793, 10.0, 3.1622776601683795]\n    assert candidate(0.01, [100.0]) == [0.0001]\n    assert candidate(2.0, [0.5]) == [4.0]\n    assert candidate(9.5, [1.0]) == [29.280966514102637]\n", "language": "python"}
{"task_id": "6dd1443a-a0b3-4400-ba3c-92c842e56cf6-1797687293260424275", "prompt": "I'll complete the provided function with an implementation that can be executed as-is. My solution will be contained entirely within the function body, with any helper functions or classes defined inside the main function. I'll restrict myself to using only the libraries that are imported in the problem statement.\n\n```python\nfrom typing import List, Tuple\nimport math\n\ndef optimize_solar_panel_placement(roof_dimensions: Tuple[float, float], panel_dimensions: Tuple[float, float]) -> List[Tuple[float, float]]:\n    \"\"\"\n    Determine the optimal placement of solar panels on a rectangular roof to maximize energy production.\n\n    This function calculates the best arrangement of solar panels on a given roof, considering the dimensions\n    of both the roof and the panels. It uses list comprehension to generate the placement coordinates and\n    the math module for precise calculations.\n\n    Args:\n    roof_dimensions (Tuple[float, float]): The length and width of the roof in meters.\n    panel_dimensions (Tuple[float, float]): The length and width of a single solar panel in meters.\n\n    Returns:\n    List[Tuple[float, float]]: A list of (x, y) coordinates for the top-left corner of each panel placement.\n\n\n    [EXAMPLES]\n    \n    assert candidate((22.5, 16.875), (4.5, 3.375)) == [(0.0, 0.0), (0.0, 3.375), (0.0, 6.75), (0.0, 10.125), (0.0, 13.5), (4.5, 0.0), (4.5, 3.375), (4.5, 6.75), (4.5, 10.125), (4.5, 13.5), (9.0, 0.0), (9.0, 3.375), (9.0, 6.75), (9.0, 10.125), (9.0, 13.5), (13.5, 0.0), (13.5, 3.375), (13.5, 6.75), (13.5, 10.125), (13.5, 13.5), (18.0, 0.0), (18.0, 3.375), (18.0, 6.75), (18.0, 10.125), (18.0, 13.5)]\n    assert candidate((10.0, 8.0), (1.5, 1.0)) == [(0.0, 0.0), (0.0, 1.0), (0.0, 2.0), (0.0, 3.0), (0.0, 4.0), (0.0, 5.0), (0.0, 6.0), (0.0, 7.0), (1.5, 0.0), (1.5, 1.0), (1.5, 2.0), (1.5, 3.0), (1.5, 4.0), (1.5, 5.0), (1.5, 6.0), (1.5, 7.0), (3.0, 0.0), (3.0, 1.0), (3.0, 2.0), (3.0, 3.0), (3.0, 4.0), (3.0, 5.0), (3.0, 6.0), (3.0, 7.0), (4.5, 0.0), (4.5, 1.0), (4.5, 2.0), (4.5, 3.0), (4.5, 4.0), (4.5, 5.0), (4.5, 6.0), (4.5, 7.0), (6.0, 0.0), (6.0, 1.0), (6.0, 2.0), (6.0, 3.0), (6.0, 4.0), (6.0, 5.0), (6.0, 6.0), (6.0, 7.0), (7.5, 0.0), (7.5, 1.0), (7.5, 2.0), (7.5, 3.0), (7.5, 4.0), (7.5, 5.0), (7.5, 6.0), (7.5, 7.0)]\n\n    [/EXAMPLES]\n    \"\"\"\n```\n", "entry_point": "optimize_solar_panel_placement", "solution": "from typing import List, Tuple\nimport math\n\ndef optimize_solar_panel_placement(roof_dimensions: Tuple[float, float], panel_dimensions: Tuple[float, float]) -> List[Tuple[float, float]]:\n    \"\"\"\n    Determine the optimal placement of solar panels on a rectangular roof to maximize energy production.\n\n    This function calculates the best arrangement of solar panels on a given roof, considering the dimensions\n    of both the roof and the panels. It uses list comprehension to generate the placement coordinates and\n    the math module for precise calculations.\n\n    Args:\n    roof_dimensions (Tuple[float, float]): The length and width of the roof in meters.\n    panel_dimensions (Tuple[float, float]): The length and width of a single solar panel in meters.\n\n    Returns:\n    List[Tuple[float, float]]: A list of (x, y) coordinates for the top-left corner of each panel placement.\n\n\n    [EXAMPLES]\n    \n    assert candidate((22.5, 16.875), (4.5, 3.375)) == [(0.0, 0.0), (0.0, 3.375), (0.0, 6.75), (0.0, 10.125), (0.0, 13.5), (4.5, 0.0), (4.5, 3.375), (4.5, 6.75), (4.5, 10.125), (4.5, 13.5), (9.0, 0.0), (9.0, 3.375), (9.0, 6.75), (9.0, 10.125), (9.0, 13.5), (13.5, 0.0), (13.5, 3.375), (13.5, 6.75), (13.5, 10.125), (13.5, 13.5), (18.0, 0.0), (18.0, 3.375), (18.0, 6.75), (18.0, 10.125), (18.0, 13.5)]\n    assert candidate((10.0, 8.0), (1.5, 1.0)) == [(0.0, 0.0), (0.0, 1.0), (0.0, 2.0), (0.0, 3.0), (0.0, 4.0), (0.0, 5.0), (0.0, 6.0), (0.0, 7.0), (1.5, 0.0), (1.5, 1.0), (1.5, 2.0), (1.5, 3.0), (1.5, 4.0), (1.5, 5.0), (1.5, 6.0), (1.5, 7.0), (3.0, 0.0), (3.0, 1.0), (3.0, 2.0), (3.0, 3.0), (3.0, 4.0), (3.0, 5.0), (3.0, 6.0), (3.0, 7.0), (4.5, 0.0), (4.5, 1.0), (4.5, 2.0), (4.5, 3.0), (4.5, 4.0), (4.5, 5.0), (4.5, 6.0), (4.5, 7.0), (6.0, 0.0), (6.0, 1.0), (6.0, 2.0), (6.0, 3.0), (6.0, 4.0), (6.0, 5.0), (6.0, 6.0), (6.0, 7.0), (7.5, 0.0), (7.5, 1.0), (7.5, 2.0), (7.5, 3.0), (7.5, 4.0), (7.5, 5.0), (7.5, 6.0), (7.5, 7.0)]\n\n    [/EXAMPLES]\n    \"\"\"\n    roof_length, roof_width = roof_dimensions\n    panel_length, panel_width = panel_dimensions\n\n    # Calculate the number of panels that can fit in each dimension\n    panels_x = math.floor(roof_length / panel_length)\n    panels_y = math.floor(roof_width / panel_width)\n\n    # Generate the coordinates for each panel placement\n    coordinates = [\n        (x * panel_length, y * panel_width)\n        for x in range(panels_x)\n        for y in range(panels_y)\n    ]\n\n    return coordinates\n\n", "test": "def check(candidate):\n    assert candidate((30.0, 22.5), (6.0, 4.5)) == [(0.0, 0.0), (0.0, 4.5), (0.0, 9.0), (0.0, 13.5), (0.0, 18.0), (6.0, 0.0), (6.0, 4.5), (6.0, 9.0), (6.0, 13.5), (6.0, 18.0), (12.0, 0.0), (12.0, 4.5), (12.0, 9.0), (12.0, 13.5), (12.0, 18.0), (18.0, 0.0), (18.0, 4.5), (18.0, 9.0), (18.0, 13.5), (18.0, 18.0), (24.0, 0.0), (24.0, 4.5), (24.0, 9.0), (24.0, 13.5), (24.0, 18.0)]\n    assert candidate((22.5, 16.875), (4.5, 3.375)) == [(0.0, 0.0), (0.0, 3.375), (0.0, 6.75), (0.0, 10.125), (0.0, 13.5), (4.5, 0.0), (4.5, 3.375), (4.5, 6.75), (4.5, 10.125), (4.5, 13.5), (9.0, 0.0), (9.0, 3.375), (9.0, 6.75), (9.0, 10.125), (9.0, 13.5), (13.5, 0.0), (13.5, 3.375), (13.5, 6.75), (13.5, 10.125), (13.5, 13.5), (18.0, 0.0), (18.0, 3.375), (18.0, 6.75), (18.0, 10.125), (18.0, 13.5)]\n    assert candidate((15.5, 11.25), (3.1, 2.25)) == [(0.0, 0.0), (0.0, 2.25), (0.0, 4.5), (0.0, 6.75), (0.0, 9.0), (3.1, 0.0), (3.1, 2.25), (3.1, 4.5), (3.1, 6.75), (3.1, 9.0), (6.2, 0.0), (6.2, 2.25), (6.2, 4.5), (6.2, 6.75), (6.2, 9.0), (9.3, 0.0), (9.3, 2.25), (9.3, 4.5), (9.3, 6.75), (9.3, 9.0), (12.4, 0.0), (12.4, 2.25), (12.4, 4.5), (12.4, 6.75), (12.4, 9.0)]\n    assert candidate((10.0, 8.0), (1.5, 1.0)) == [(0.0, 0.0), (0.0, 1.0), (0.0, 2.0), (0.0, 3.0), (0.0, 4.0), (0.0, 5.0), (0.0, 6.0), (0.0, 7.0), (1.5, 0.0), (1.5, 1.0), (1.5, 2.0), (1.5, 3.0), (1.5, 4.0), (1.5, 5.0), (1.5, 6.0), (1.5, 7.0), (3.0, 0.0), (3.0, 1.0), (3.0, 2.0), (3.0, 3.0), (3.0, 4.0), (3.0, 5.0), (3.0, 6.0), (3.0, 7.0), (4.5, 0.0), (4.5, 1.0), (4.5, 2.0), (4.5, 3.0), (4.5, 4.0), (4.5, 5.0), (4.5, 6.0), (4.5, 7.0), (6.0, 0.0), (6.0, 1.0), (6.0, 2.0), (6.0, 3.0), (6.0, 4.0), (6.0, 5.0), (6.0, 6.0), (6.0, 7.0), (7.5, 0.0), (7.5, 1.0), (7.5, 2.0), (7.5, 3.0), (7.5, 4.0), (7.5, 5.0), (7.5, 6.0), (7.5, 7.0)]\n    assert candidate((6.0, 4.5), (2.0, 1.5)) == [(0.0, 0.0), (0.0, 1.5), (0.0, 3.0), (2.0, 0.0), (2.0, 1.5), (2.0, 3.0), (4.0, 0.0), (4.0, 1.5), (4.0, 3.0)]\n    assert candidate((11.1, 8.325), (2.22, 1.665)) == [(0.0, 0.0), (0.0, 1.665), (0.0, 3.33), (0.0, 4.995), (2.22, 0.0), (2.22, 1.665), (2.22, 3.33), (2.22, 4.995), (4.44, 0.0), (4.44, 1.665), (4.44, 3.33), (4.44, 4.995), (6.66, 0.0), (6.66, 1.665), (6.66, 3.33), (6.66, 4.995)]\n    assert candidate((5.0, 4.0), (2.0, 1.5)) == [(0.0, 0.0), (0.0, 1.5), (2.0, 0.0), (2.0, 1.5)]\n    assert candidate((8.5, 6.5), (1.7, 1.2)) == [(0.0, 0.0), (0.0, 1.2), (0.0, 2.4), (0.0, 3.5999999999999996), (0.0, 4.8), (1.7, 0.0), (1.7, 1.2), (1.7, 2.4), (1.7, 3.5999999999999996), (1.7, 4.8), (3.4, 0.0), (3.4, 1.2), (3.4, 2.4), (3.4, 3.5999999999999996), (3.4, 4.8), (5.1, 0.0), (5.1, 1.2), (5.1, 2.4), (5.1, 3.5999999999999996), (5.1, 4.8), (6.8, 0.0), (6.8, 1.2), (6.8, 2.4), (6.8, 3.5999999999999996), (6.8, 4.8)]\n    assert candidate((20.0, 15.0), (2.5, 2.0)) == [(0.0, 0.0), (0.0, 2.0), (0.0, 4.0), (0.0, 6.0), (0.0, 8.0), (0.0, 10.0), (0.0, 12.0), (2.5, 0.0), (2.5, 2.0), (2.5, 4.0), (2.5, 6.0), (2.5, 8.0), (2.5, 10.0), (2.5, 12.0), (5.0, 0.0), (5.0, 2.0), (5.0, 4.0), (5.0, 6.0), (5.0, 8.0), (5.0, 10.0), (5.0, 12.0), (7.5, 0.0), (7.5, 2.0), (7.5, 4.0), (7.5, 6.0), (7.5, 8.0), (7.5, 10.0), (7.5, 12.0), (10.0, 0.0), (10.0, 2.0), (10.0, 4.0), (10.0, 6.0), (10.0, 8.0), (10.0, 10.0), (10.0, 12.0), (12.5, 0.0), (12.5, 2.0), (12.5, 4.0), (12.5, 6.0), (12.5, 8.0), (12.5, 10.0), (12.5, 12.0), (15.0, 0.0), (15.0, 2.0), (15.0, 4.0), (15.0, 6.0), (15.0, 8.0), (15.0, 10.0), (15.0, 12.0), (17.5, 0.0), (17.5, 2.0), (17.5, 4.0), (17.5, 6.0), (17.5, 8.0), (17.5, 10.0), (17.5, 12.0)]\n    assert candidate((9.8, 7.35), (1.96, 1.47)) == [(0.0, 0.0), (0.0, 1.47), (0.0, 2.94), (0.0, 4.41), (0.0, 5.88), (1.96, 0.0), (1.96, 1.47), (1.96, 2.94), (1.96, 4.41), (1.96, 5.88), (3.92, 0.0), (3.92, 1.47), (3.92, 2.94), (3.92, 4.41), (3.92, 5.88), (5.88, 0.0), (5.88, 1.47), (5.88, 2.94), (5.88, 4.41), (5.88, 5.88), (7.84, 0.0), (7.84, 1.47), (7.84, 2.94), (7.84, 4.41), (7.84, 5.88)]\n", "language": "python"}
{"task_id": "ca08139e-b677-41b1-9e32-bedddc64ccd82695812777744543259", "prompt": "I'm a coding assistant here to help you complete functions that are ready to execute in code blocks. I'll only work within the function provided, using only the libraries mentioned in the problem. Any additional functions or classes I create will be defined inside the main function.\n\n```python\nfrom typing import List\n\ndef encode_dna_sequence(sequence: str, mutations: List[List[int]]) -> str:\n    \"\"\"\n    In a genetics lab, scientists are working on encoding DNA sequences with mutations.\n    Given a DNA sequence (string of 'A', 'T', 'C', 'G') and a list of mutations,\n    apply the mutations to the sequence and return the encoded result.\n    Each mutation is represented by [position, shift], where position is the\n    0-indexed position in the sequence, and shift is the number of positions\n    to rotate the nucleotide forward in the sequence 'ATCG'.\n\n    The function should be case-insensitive and wrap around the sequence 'ATCG'.\n    Return the encoded sequence in uppercase.\n\n\n    [EXAMPLES]\n    \n    assert candidate(\"\", []) == ''\n    assert candidate(\"ATCGATCG\", [[0, 0], [2, 0], [4, 0], [6, 0]]) == 'ATCGATCG'\n\n    [/EXAMPLES]\n    \"\"\"\n```\n", "entry_point": "encode_dna_sequence", "solution": "from typing import List\n\ndef encode_dna_sequence(sequence: str, mutations: List[List[int]]) -> str:\n    \"\"\"\n    In a genetics lab, scientists are working on encoding DNA sequences with mutations.\n    Given a DNA sequence (string of 'A', 'T', 'C', 'G') and a list of mutations,\n    apply the mutations to the sequence and return the encoded result.\n    Each mutation is represented by [position, shift], where position is the\n    0-indexed position in the sequence, and shift is the number of positions\n    to rotate the nucleotide forward in the sequence 'ATCG'.\n\n    The function should be case-insensitive and wrap around the sequence 'ATCG'.\n    Return the encoded sequence in uppercase.\n\n\n    [EXAMPLES]\n    \n    assert candidate(\"\", []) == ''\n    assert candidate(\"ATCGATCG\", [[0, 0], [2, 0], [4, 0], [6, 0]]) == 'ATCGATCG'\n\n    [/EXAMPLES]\n    \"\"\"\n    def rotate_nucleotide(nucleotide: str, shift: int) -> str:\n        nucleotides = 'ATCG'\n        index = nucleotides.index(nucleotide.upper())\n        new_index = (index + shift) % 4\n        return nucleotides[new_index]\n\n    # Convert sequence to uppercase and create a list of characters\n    sequence = list(sequence.upper())\n\n    # Apply mutations\n    for position, shift in mutations:\n        if 0 <= position < len(sequence):\n            sequence[position] = rotate_nucleotide(sequence[position], shift)\n\n    # Convert the list of characters back to a string\n    return ''.join(sequence)\n\n", "test": "def check(candidate):\n    assert candidate(\"TTTT\", [[0, 1], [1, 2], [2, 3], [3, 4]]) == 'CGAT'\n    assert candidate(\"A\", [[0, 1000000]]) == 'A'\n    assert candidate(\"ATCG\", []) == 'ATCG'\n    assert candidate(\"AAAA\", [[0, 0], [1, 1], [2, 2], [3, 3]]) == 'ATCG'\n    assert candidate(\"AATTCCGG\", [[0, 1], [4, 2], [7, 3]]) == 'TATTACGC'\n    assert candidate(\"ATCGATCG\", [[1, 1], [3, 1], [5, 1], [7, 1]]) == 'ACCAACCA'\n    assert candidate(\"ATCGATCG\", [[0, 0], [2, 0], [4, 0], [6, 0]]) == 'ATCGATCG'\n    assert candidate(\"\", []) == ''\n    assert candidate(\"ATCGatcg\", [[0, 1], [4, 1]]) == 'TTCGTTCG'\n    assert candidate(\"G\" * 1000, [[i, 3] for i in range(1000)]) == 'CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC'\n", "language": "python"}
{"task_id": "2beaa28e-256f-400d-8560-834ff817971f2647348243185381427", "prompt": "Please implement the specified function as a standalone, executable piece of code. Any additional functions or classes should be nested within the main function. Restrict yourself to using only the libraries imported in the problem statement. Present your solution as a single code block.\n\n```python\nimport itertools\nfrom itertools import combinations\nfrom typing import List, Tuple\n\ndef find_closest_sum(numbers: List[int], target: int) -> Tuple[int, int, int]:\n    \"\"\"\n    In a chemistry experiment, you need to find three elements whose atomic weights\n    sum up closest to a target weight. Given a list of atomic weights (integers) and\n    a target weight, find three numbers in the list that sum to a value closest to\n    the target.\n\n    Args:\n    numbers (List[int]): A list of integers representing atomic weights.\n    target (int): The target weight to aim for.\n\n    Returns:\n    Tuple[int, int, int]: A tuple of three numbers from the list that sum closest to the target.\n\n\n    [EXAMPLES]\n    \n    assert candidate([-10, -5, 0, 5, 10], 15) == (0, 5, 10)\n    assert candidate([-100, -50, 0, 50, 100], 75) == (-100, 50, 100)\n\n    [/EXAMPLES]\n    \"\"\"\n```\n", "entry_point": "find_closest_sum", "solution": "import itertools\nfrom itertools import combinations\nfrom typing import List, Tuple\n\ndef find_closest_sum(numbers: List[int], target: int) -> Tuple[int, int, int]:\n    \"\"\"\n    In a chemistry experiment, you need to find three elements whose atomic weights\n    sum up closest to a target weight. Given a list of atomic weights (integers) and\n    a target weight, find three numbers in the list that sum to a value closest to\n    the target.\n\n    Args:\n    numbers (List[int]): A list of integers representing atomic weights.\n    target (int): The target weight to aim for.\n\n    Returns:\n    Tuple[int, int, int]: A tuple of three numbers from the list that sum closest to the target.\n\n\n    [EXAMPLES]\n    \n    assert candidate([-10, -5, 0, 5, 10], 15) == (0, 5, 10)\n    assert candidate([-100, -50, 0, 50, 100], 75) == (-100, 50, 100)\n\n    [/EXAMPLES]\n    \"\"\"\n    closest_sum = float('inf')\n    closest_combination = None\n\n    # Generate all possible combinations of three numbers\n    for combination in itertools.combinations(numbers, 3):\n        current_sum = sum(combination)\n        \n        # Check if this combination is closer to the target\n        if abs(current_sum - target) < abs(closest_sum - target):\n            closest_sum = current_sum\n            closest_combination = combination\n\n    return closest_combination\n\n", "test": "def check(candidate):\n    assert candidate([-10, -9, -8, -7, -6, -5, -4, -3, -2, -1], -30) == (-10, -9, -8)\n    assert candidate([7, 14, 21, 28, 35], 50) == (7, 14, 28)\n    assert candidate([-10, -5, 0, 5, 10], 15) == (0, 5, 10)\n    assert candidate([1, 2, 3, 4, 5, 6, 7, 8, 9, 10], 25) == (6, 9, 10)\n    assert candidate([1, 3, 5, 7, 9, 11, 13, 15], 30) == (1, 13, 15)\n    assert candidate([2, 4, 6, 8, 10], 15) == (2, 4, 8)\n    assert candidate([-100, -50, 0, 50, 100], 75) == (-100, 50, 100)\n    assert candidate([-5, -4, -3, -2, -1], -6) == (-3, -2, -1)\n    assert candidate([1, 2, 3, 4, 5, 6, 7, 8, 9, 10], 100) == (8, 9, 10)\n    assert candidate([-1000, -500, 0, 500, 1000], 1500) == (0, 500, 1000)\n", "language": "python"}
{"task_id": "8dfd8bb3-6f3d-4879-984a-405244a73d9f8078198861143025115", "prompt": "Let me implement the rest of the function based on its documentation string. I'll present the complete code in one block while preserving the given function signature.\n\n```python\nfrom typing import List, Dict\n\ndef analyze_stock_trends(price_data: Dict[str, List[float]]) -> List[Dict[str, float]]:\n    \"\"\"\n    Analyze stock price trends for multiple companies over a period of time.\n\n    This function takes a dictionary of stock price data for different companies\n    and returns a list of dictionaries containing trend analysis for each time period.\n\n    The analysis utilizes map functions and dictionary comprehensions to process the data.\n\n\n    [EXAMPLES]\n    \n    assert candidate({'A': [1.0, 2.0, 3.0], 'B': [4.0, 5.0, 6.0]}) == [{'A': 1.0, 'B': 4.0}, {'A': 2.0, 'B': 5.0}, {'A': 3.0, 'B': 6.0}]\n    assert candidate({'A': [1.0, 2.0, 3.0], 'B': [4.0, 5.0, 6.0], 'C': [7.0, 8.0, 9.0], 'D': [10.0, 11.0, 12.0]}) == [{'A': 1.0, 'B': 4.0, 'C': 7.0, 'D': 10.0}, {'A': 2.0, 'B': 5.0, 'C': 8.0, 'D': 11.0}, {'A': 3.0, 'B': 6.0, 'C': 9.0, 'D': 12.0}]\n\n    [/EXAMPLES]\n    \"\"\"\n```\n", "entry_point": "analyze_stock_trends", "solution": "from typing import List, Dict\n\ndef analyze_stock_trends(price_data: Dict[str, List[float]]) -> List[Dict[str, float]]:\n    \"\"\"\n    Analyze stock price trends for multiple companies over a period of time.\n\n    This function takes a dictionary of stock price data for different companies\n    and returns a list of dictionaries containing trend analysis for each time period.\n\n    The analysis utilizes map functions and dictionary comprehensions to process the data.\n\n\n    [EXAMPLES]\n    \n    assert candidate({'A': [1.0, 2.0, 3.0], 'B': [4.0, 5.0, 6.0]}) == [{'A': 1.0, 'B': 4.0}, {'A': 2.0, 'B': 5.0}, {'A': 3.0, 'B': 6.0}]\n    assert candidate({'A': [1.0, 2.0, 3.0], 'B': [4.0, 5.0, 6.0], 'C': [7.0, 8.0, 9.0], 'D': [10.0, 11.0, 12.0]}) == [{'A': 1.0, 'B': 4.0, 'C': 7.0, 'D': 10.0}, {'A': 2.0, 'B': 5.0, 'C': 8.0, 'D': 11.0}, {'A': 3.0, 'B': 6.0, 'C': 9.0, 'D': 12.0}]\n\n    [/EXAMPLES]\n    \"\"\"\n    # Get the number of time periods (assuming all companies have the same number of data points)\n    num_periods = len(next(iter(price_data.values())))\n    \n    # Use a map function to create a list of dictionaries for each time period\n    result = list(map(\n        lambda i: {company: prices[i] for company, prices in price_data.items()},\n        range(num_periods)\n    ))\n    \n    return result\n\n", "test": "def check(candidate):\n    assert candidate({'STOCK1': [1.00, 1.01, 1.02], 'STOCK2': [2.00, 2.01, 2.02], 'STOCK3': [3.00, 3.01, 3.02], 'STOCK4': [4.00, 4.01, 4.02], 'STOCK5': [5.00, 5.01, 5.02]}) == [{'STOCK1': 1.0, 'STOCK2': 2.0, 'STOCK3': 3.0, 'STOCK4': 4.0, 'STOCK5': 5.0}, {'STOCK1': 1.01, 'STOCK2': 2.01, 'STOCK3': 3.01, 'STOCK4': 4.01, 'STOCK5': 5.01}, {'STOCK1': 1.02, 'STOCK2': 2.02, 'STOCK3': 3.02, 'STOCK4': 4.02, 'STOCK5': 5.02}]\n    assert candidate({'AAPL': [150.25, 152.30, 151.75, 153.50, 155.20], 'GOOGL': [2750.10, 2780.50, 2795.25, 2810.75, 2830.00], 'MSFT': [305.50, 308.25, 310.75, 312.50, 315.00]}) == [{'AAPL': 150.25, 'GOOGL': 2750.1, 'MSFT': 305.5}, {'AAPL': 152.3, 'GOOGL': 2780.5, 'MSFT': 308.25}, {'AAPL': 151.75, 'GOOGL': 2795.25, 'MSFT': 310.75}, {'AAPL': 153.5, 'GOOGL': 2810.75, 'MSFT': 312.5}, {'AAPL': 155.2, 'GOOGL': 2830.0, 'MSFT': 315.0}]\n    assert candidate({'SINGLE': [1.0, 2.0, 3.0, 4.0, 5.0]}) == [{'SINGLE': 1.0}, {'SINGLE': 2.0}, {'SINGLE': 3.0}, {'SINGLE': 4.0}, {'SINGLE': 5.0}]\n    assert candidate({'CRYPTO': [0.00000001, 0.00000002, 0.00000003]}) == [{'CRYPTO': 1e-08}, {'CRYPTO': 2e-08}, {'CRYPTO': 3e-08}]\n    assert candidate({'AAPL': [-100.00, -99.00, -98.00], 'GOOGL': [-2000.00, -1990.00, -1980.00]}) == [{'AAPL': -100.0, 'GOOGL': -2000.0}, {'AAPL': -99.0, 'GOOGL': -1990.0}, {'AAPL': -98.0, 'GOOGL': -1980.0}]\n    assert candidate({'PENNY_STOCK': [0.01, 0.02, 0.03, 0.04, 0.05]}) == [{'PENNY_STOCK': 0.01}, {'PENNY_STOCK': 0.02}, {'PENNY_STOCK': 0.03}, {'PENNY_STOCK': 0.04}, {'PENNY_STOCK': 0.05}]\n    assert candidate({'A': [1.0, 2.0, 3.0], 'B': [4.0, 5.0, 6.0], 'C': [7.0, 8.0, 9.0], 'D': [10.0, 11.0, 12.0]}) == [{'A': 1.0, 'B': 4.0, 'C': 7.0, 'D': 10.0}, {'A': 2.0, 'B': 5.0, 'C': 8.0, 'D': 11.0}, {'A': 3.0, 'B': 6.0, 'C': 9.0, 'D': 12.0}]\n    assert candidate({'PENNY': [0.01, 0.02, 0.03], 'EXPENSIVE': [1000.0, 2000.0, 3000.0]}) == [{'PENNY': 0.01, 'EXPENSIVE': 1000.0}, {'PENNY': 0.02, 'EXPENSIVE': 2000.0}, {'PENNY': 0.03, 'EXPENSIVE': 3000.0}]\n    assert candidate({'A': [1.23456789, 2.34567890, 3.45678901]}) == [{'A': 1.23456789}, {'A': 2.3456789}, {'A': 3.45678901}]\n    assert candidate({'A': [1.0, 2.0, 3.0], 'B': [4.0, 5.0, 6.0]}) == [{'A': 1.0, 'B': 4.0}, {'A': 2.0, 'B': 5.0}, {'A': 3.0, 'B': 6.0}]\n", "language": "python"}
{"task_id": "b6412108-ddfb-4fdb-a64f-52887727def92698448341246864618", "prompt": "Please provide me with a function to complete. I'll write the implementation using only the specified imported libraries, keeping any helper functions or classes inside the main function. I'll deliver my solution as a single executable code block.\n\n```python\nfrom typing import List\n\ndef calculate_fuel_efficiency(distances: List[float], fuel_consumed: List[float]) -> float:\n    \"\"\"\n    A space agency wants to calculate the fuel efficiency of their new spacecraft during its test flights.\n    This function takes two lists as input: one containing the distances traveled in light-years for each\n    test flight, and another containing the amount of fuel consumed in tons for each corresponding flight.\n    It returns the average fuel efficiency in light-years per ton of fuel.\n\n\n    [EXAMPLES]\n    \n    assert candidate([999999, 999999], [99999, 99999]) == 10.000090000900009\n    assert candidate([0.5], [0.1]) == 5.0\n\n    [/EXAMPLES]\n    \"\"\"\n```\n", "entry_point": "calculate_fuel_efficiency", "solution": "from typing import List\n\ndef calculate_fuel_efficiency(distances: List[float], fuel_consumed: List[float]) -> float:\n    \"\"\"\n    A space agency wants to calculate the fuel efficiency of their new spacecraft during its test flights.\n    This function takes two lists as input: one containing the distances traveled in light-years for each\n    test flight, and another containing the amount of fuel consumed in tons for each corresponding flight.\n    It returns the average fuel efficiency in light-years per ton of fuel.\n\n\n    [EXAMPLES]\n    \n    assert candidate([999999, 999999], [99999, 99999]) == 10.000090000900009\n    assert candidate([0.5], [0.1]) == 5.0\n\n    [/EXAMPLES]\n    \"\"\"\n    if len(distances) != len(fuel_consumed):\n        raise ValueError(\"The number of distances must match the number of fuel consumption values.\")\n\n    if len(distances) == 0:\n        raise ValueError(\"Input lists cannot be empty.\")\n\n    total_distance = sum(distances)\n    total_fuel = sum(fuel_consumed)\n\n    if total_fuel == 0:\n        raise ValueError(\"Total fuel consumed cannot be zero.\")\n\n    fuel_efficiency = total_distance / total_fuel\n    return fuel_efficiency\n\n", "test": "def check(candidate):\n    assert candidate([1.5, 2.5, 3.5, 4.5, 5.5], [0.5, 1.0, 1.5, 2.0, 2.5]) == 2.3333333333333335\n    assert candidate([5e-5, 5e-4, 5e-3], [1e-5, 1e-4, 1e-3]) == 5.0\n    assert candidate([0.0001, 0.001, 0.01, 0.1, 1, 10, 100], [0.00001, 0.0001, 0.001, 0.01, 0.1, 1, 10]) == 10.0\n    assert candidate([999999, 999999], [99999, 99999]) == 10.000090000900009\n    assert candidate([0.5], [0.1]) == 5.0\n    assert candidate([1e10, 2e10], [1e9, 2e9]) == 10.0\n    assert candidate([0.1, 0.2, 0.3, 0.4, 0.5], [0.02, 0.04, 0.06, 0.08, 0.10]) == 4.999999999999999\n    assert candidate([1.111, 2.222, 3.333, 4.444], [0.111, 0.222, 0.333, 0.444]) == 10.009009009009008\n    assert candidate([1e6, 2e6, 3e6], [1e5, 2e5, 3e5]) == 10.0\n    assert candidate([100, 200, 300], [10, 20, 30]) == 10.0\n", "language": "python"}
{"task_id": "b7dc07a9-715a-4c54-a5ba-9be31f2d082d-8061324724769205200", "prompt": "Following the specifications in the docstring, here's the complete function implementation in one code block. All edge cases have been considered.\n\n```python\nfrom typing import List\n\ndef simulate_ecosystem(initial_population: List[int], food_chain: List[List[int]], time_steps: int) -> List[List[int]]:\n    \"\"\"\n    Simulate the evolution of a simple ecosystem over time based on predator-prey relationships.\n\n    Given an initial population of different species and their food chain relationships,\n    calculate how the population of each species changes over a specified number of time steps.\n\n    Args:\n    initial_population (List[int]): A list of integers representing the initial population of each species.\n    food_chain (List[List[int]]): A 2D list where food_chain[i][j] represents how many of species j a single individual of species i eats per time step.\n    time_steps (int): The number of time steps to simulate.\n\n    Returns:\n    List[List[int]]: A list of lists, where each inner list represents the population of each species at a given time step.\n\n\n    [EXAMPLES]\n    \n    assert candidate([100, 20, 5], [[0, 0, 0], [2, 0, 0], [0, 1, 0]], 3) == [[100, 20, 5], [60, 35, 7], [0, 58, 10]]\n    assert candidate([1000, 1, 1], [[0, 0, 0], [10, 0, 0], [0, 10, 0]], 3) == [[1000, 1, 1], [990, 5, 1], [940, 25, 3]]\n\n    [/EXAMPLES]\n    \"\"\"\n```\n", "entry_point": "simulate_ecosystem", "solution": "from typing import List\n\ndef simulate_ecosystem(initial_population: List[int], food_chain: List[List[int]], time_steps: int) -> List[List[int]]:\n    \"\"\"\n    Simulate the evolution of a simple ecosystem over time based on predator-prey relationships.\n\n    Given an initial population of different species and their food chain relationships,\n    calculate how the population of each species changes over a specified number of time steps.\n\n    Args:\n    initial_population (List[int]): A list of integers representing the initial population of each species.\n    food_chain (List[List[int]]): A 2D list where food_chain[i][j] represents how many of species j a single individual of species i eats per time step.\n    time_steps (int): The number of time steps to simulate.\n\n    Returns:\n    List[List[int]]: A list of lists, where each inner list represents the population of each species at a given time step.\n\n\n    [EXAMPLES]\n    \n    assert candidate([100, 20, 5], [[0, 0, 0], [2, 0, 0], [0, 1, 0]], 3) == [[100, 20, 5], [60, 35, 7], [0, 58, 10]]\n    assert candidate([1000, 1, 1], [[0, 0, 0], [10, 0, 0], [0, 10, 0]], 3) == [[1000, 1, 1], [990, 5, 1], [940, 25, 3]]\n\n    [/EXAMPLES]\n    \"\"\"\n    def calculate_next_population(current_population):\n        next_population = current_population.copy()\n        num_species = len(current_population)\n        \n        for predator in range(num_species):\n            for prey in range(num_species):\n                if food_chain[predator][prey] > 0:\n                    prey_consumed = min(current_population[prey], \n                                        current_population[predator] * food_chain[predator][prey])\n                    next_population[prey] -= prey_consumed\n                    next_population[predator] += prey_consumed // 2  # Assume 50% efficiency in converting prey to predator\n        \n        return [max(0, pop) for pop in next_population]  # Ensure populations don't go negative\n\n    result = [initial_population]\n    current_population = initial_population\n\n    for _ in range(time_steps - 1):  # -1 because initial_population counts as the first time step\n        current_population = calculate_next_population(current_population)\n        result.append(current_population)\n\n    return result\n\n", "test": "def check(candidate):\n    assert candidate([1, 1000, 1], [[0, 0, 0], [0, 0, 1], [1, 0, 0]], 5) == [[1, 1000, 1], [0, 1000, 0], [0, 1000, 0], [0, 1000, 0], [0, 1000, 0]]\n    assert candidate([100, 100], [[0, 1], [1, 0]], 7) == [[100, 100], [50, 50], [25, 25], [12, 12], [6, 6], [3, 3], [1, 1]]\n    assert candidate([100, 50, 25, 10], [[0, 0, 0, 0], [1, 0, 0, 0], [0, 1, 0, 0], [0, 0, 1, 0]], 5) == [[100, 50, 25, 10], [50, 50, 27, 15], [0, 48, 25, 22], [0, 23, 15, 33], [0, 8, 7, 40]]\n    assert candidate([1000, 1, 1], [[0, 0, 0], [10, 0, 0], [0, 10, 0]], 3) == [[1000, 1, 1], [990, 5, 1], [940, 25, 3]]\n    assert candidate([10, 10, 10, 10, 10], [[0, 0, 0, 0, 0], [1, 0, 0, 0, 0], [0, 1, 0, 0, 0], [0, 0, 1, 0, 0], [0, 0, 0, 1, 0]], 5) == [[10, 10, 10, 10, 10], [0, 5, 5, 5, 15], [0, 0, 2, 2, 17], [0, 0, 0, 1, 18], [0, 0, 0, 0, 18]]\n    assert candidate([100, 20, 5], [[0, 0, 0], [2, 0, 0], [0, 1, 0]], 3) == [[100, 20, 5], [60, 35, 7], [0, 58, 10]]\n    assert candidate([100, 50, 25], [[0, 0, 0], [2, 0, 0], [0, 2, 0]], 4) == [[100, 50, 25], [0, 50, 50], [0, 0, 75], [0, 0, 75]]\n    assert candidate([50, 10, 2], [[0, 0, 0], [1, 0, 0], [0, 2, 0]], 2) == [[50, 10, 2], [40, 11, 4]]\n    assert candidate([10, 5, 2, 1], [[0, 0, 0, 0], [1, 0, 0, 0], [0, 1, 0, 0], [0, 0, 1, 0]], 4) == [[10, 5, 2, 1], [5, 5, 2, 1], [0, 5, 2, 1], [0, 3, 2, 1]]\n    assert candidate([1000, 100, 10], [[0, 0, 0], [5, 0, 0], [0, 5, 0]], 3) == [[1000, 100, 10], [500, 300, 35], [0, 375, 122]]\n", "language": "python"}
{"task_id": "3f040bd5-9fb6-4abf-b10c-2344cfb61fd81859231764090071331", "prompt": "I'll complete the code within one code block. I'll only define any necessary functions or classes inside the given function. Please provide the code that needs to be completed.\n\n```python\nfrom typing import Dict\nimport re\n\ndef parse_log_file(log_content: str) -> Dict[str, Dict[str, int]]:\n    \"\"\"\n    A system administrator needs to analyze server logs to identify potential security\n    threats. This function parses a log file and returns a summary of activities\n    grouped by IP address.\n\n    The log file format is assumed to be:\n    [TIMESTAMP] IP_ADDRESS ACTION RESOURCE\n\n    Parameters:\n    log_content (str): The entire content of the log file\n\n    Returns:\n    Dict[str, Dict[str, int]]: A nested dictionary where the outer key is the IP address,\n    and the inner dictionary contains action counts for that IP.\n\n\n    [EXAMPLES]\n    \n    assert candidate(\"[2023-05-01 10:00:00] 127.0.0.1 GET /localhost\") == {'127.0.0.1': {'GET': 1}}\n    assert candidate(\"[2023-05-01 10:00:00] 192.168.1.1 GET /index.html\\n[2023-05-01 10:00:01] 192.168.1.2 POST /login\\n[2023-05-01 10:00:02] 192.168.1.3 PUT /update\") == {'192.168.1.1': {'GET': 1}, '192.168.1.2': {'POST': 1}, '192.168.1.3': {'PUT': 1}}\n\n    [/EXAMPLES]\n    \"\"\"\n```\n", "entry_point": "parse_log_file", "solution": "from typing import Dict\nimport re\n\ndef parse_log_file(log_content: str) -> Dict[str, Dict[str, int]]:\n    \"\"\"\n    A system administrator needs to analyze server logs to identify potential security\n    threats. This function parses a log file and returns a summary of activities\n    grouped by IP address.\n\n    The log file format is assumed to be:\n    [TIMESTAMP] IP_ADDRESS ACTION RESOURCE\n\n    Parameters:\n    log_content (str): The entire content of the log file\n\n    Returns:\n    Dict[str, Dict[str, int]]: A nested dictionary where the outer key is the IP address,\n    and the inner dictionary contains action counts for that IP.\n\n\n    [EXAMPLES]\n    \n    assert candidate(\"[2023-05-01 10:00:00] 127.0.0.1 GET /localhost\") == {'127.0.0.1': {'GET': 1}}\n    assert candidate(\"[2023-05-01 10:00:00] 192.168.1.1 GET /index.html\\n[2023-05-01 10:00:01] 192.168.1.2 POST /login\\n[2023-05-01 10:00:02] 192.168.1.3 PUT /update\") == {'192.168.1.1': {'GET': 1}, '192.168.1.2': {'POST': 1}, '192.168.1.3': {'PUT': 1}}\n\n    [/EXAMPLES]\n    \"\"\"\n    # Regular expression to match log entries\n    log_pattern = r'\\[.*?\\] (\\d+\\.\\d+\\.\\d+\\.\\d+) (\\w+) .*'\n    \n    # Dictionary to store the summary\n    summary = {}\n    \n    # Iterate through each line in the log content\n    for line in log_content.strip().split('\\n'):\n        # Skip empty lines\n        if not line.strip():\n            continue\n        \n        # Match the line against the log pattern\n        match = re.match(log_pattern, line)\n        \n        if match:\n            ip_address, action = match.groups()\n            \n            # If the IP address is not in the summary, add it\n            if ip_address not in summary:\n                summary[ip_address] = {}\n            \n            # Increment the count for the action\n            summary[ip_address][action] = summary[ip_address].get(action, 0) + 1\n    \n    return summary\n\n", "test": "def check(candidate):\n    assert candidate(\"[2023-05-01 10:00:00] 192.168.1.1 INVALID /index.html\") == {'192.168.1.1': {'INVALID': 1}}\n    assert candidate(\"[2023-05-01 10:00:00] 192.168.1.1 GET /index.html\\n[2023-05-01 10:00:01] 192.168.1.1 GET /about\\n[2023-05-01 10:00:02] 192.168.1.1 GET /contact\\n[2023-05-01 10:00:03] 192.168.1.1 POST /login\\n[2023-05-01 10:00:04] 192.168.1.1 PUT /update\\n[2023-05-01 10:00:05] 192.168.1.1 DELETE /file\\n[2023-05-01 10:00:06] 192.168.1.1 PATCH /modify\") == {'192.168.1.1': {'GET': 3, 'POST': 1, 'PUT': 1, 'DELETE': 1, 'PATCH': 1}}\n    assert candidate(\"[2023-05-01 10:00:00] 192.168.1.1 GET /index.html\\n[2023-05-01 10:00:01] 192.168.1.2 POST /login\\n[2023-05-01 10:00:02] 192.168.1.1 GET /about\\n[2023-05-01 10:00:03] 192.168.1.2 GET /dashboard\\n[2023-05-01 10:00:04] 192.168.1.1 GET /contact\\n[2023-05-01 10:00:05] 192.168.1.3 PUT /update\\n[2023-05-01 10:00:06] 192.168.1.4 DELETE /file\\n[2023-05-01 10:00:07] 192.168.1.5 PATCH /modify\\n[2023-05-01 10:00:08] 192.168.1.1 POST /comment\\n[2023-05-01 10:00:09] 192.168.1.2 PUT /profile\") == {'192.168.1.1': {'GET': 3, 'POST': 1}, '192.168.1.2': {'POST': 1, 'GET': 1, 'PUT': 1}, '192.168.1.3': {'PUT': 1}, '192.168.1.4': {'DELETE': 1}, '192.168.1.5': {'PATCH': 1}}\n    assert candidate(\"[2023-05-01 10:00:00] 127.0.0.1 GET /localhost\") == {'127.0.0.1': {'GET': 1}}\n    assert candidate(\"[2023-05-01 10:00:00] 192.168.1.1 GET /index.html\\n[2023-05-01 10:00:01] 192.168.1.1 GET /about\\n[2023-05-01 10:00:02] 192.168.1.1 GET /contact\") == {'192.168.1.1': {'GET': 3}}\n    assert candidate(\"[2023-05-01 10:00:00] 192.168.1.1 GET /index.html\\r\\n[2023-05-01 10:00:01] 192.168.1.2 POST /login\") == {'192.168.1.1': {'GET': 1}, '192.168.1.2': {'POST': 1}}\n    assert candidate(\"[2023-05-01 10:00:00] 192.168.1.1 GET /index.html\\n[2023-05-01 10:00:01] 192.168.1.2 POST /login\") == {'192.168.1.1': {'GET': 1}, '192.168.1.2': {'POST': 1}}\n    assert candidate(\"[2023-05-01 10:00:00] 192.168.1.1 GET /index.html\\n[2023-05-01 10:00:01] 192.168.1.2 POST /login\\n[2023-05-01 10:00:02] 192.168.1.3 PUT /update\\n[2023-05-01 10:00:03] 192.168.1.4 DELETE /file\\n[2023-05-01 10:00:04] 192.168.1.5 PATCH /modify\") == {'192.168.1.1': {'GET': 1}, '192.168.1.2': {'POST': 1}, '192.168.1.3': {'PUT': 1}, '192.168.1.4': {'DELETE': 1}, '192.168.1.5': {'PATCH': 1}}\n    assert candidate(\"[2023-05-01 10:00:00] 192.168.1.1 GET /index.html\") == {'192.168.1.1': {'GET': 1}}\n    assert candidate(\"[2023-05-01 10:00:00] 192.168.1.1 GET /index.html\\n[2023-05-01 10:00:01] 192.168.1.2 POST /login\\n[2023-05-01 10:00:02] 192.168.1.3 PUT /update\") == {'192.168.1.1': {'GET': 1}, '192.168.1.2': {'POST': 1}, '192.168.1.3': {'PUT': 1}}\n", "language": "python"}
{"task_id": "cd04f687-5d27-4c85-ba95-1f51c7d8cc1a-6956195628034196110", "prompt": "I'll implement the function as specified in the doc string. The complete solution will be in a single code block with edge cases properly handled.\n\n```python\nfrom typing import List\n\ndef pirate_treasure(map_grid: List[List[int]]) -> int:\n    \"\"\"\n    A pirate has a treasure map represented as a grid. Each cell contains a number\n    indicating the amount of gold coins. The pirate can only move right or down.\n    Calculate the maximum amount of treasure the pirate can collect.\n\n    Args:\n    map_grid (List[List[int]]): A 2D grid representing the treasure map.\n\n    Returns:\n    int: The maximum amount of treasure that can be collected.\n\n\n    [EXAMPLES]\n    \n    assert candidate([[1, 2, 3, 4, 5], [6, 7, 8, 9, 10], [11, 12, 13, 14, 15]]) == 72\n    assert candidate([[1, 2], [3, 4], [5, 6], [7, 8]]) == 24\n\n    [/EXAMPLES]\n    \"\"\"\n```\n", "entry_point": "pirate_treasure", "solution": "from typing import List\n\ndef pirate_treasure(map_grid: List[List[int]]) -> int:\n    \"\"\"\n    A pirate has a treasure map represented as a grid. Each cell contains a number\n    indicating the amount of gold coins. The pirate can only move right or down.\n    Calculate the maximum amount of treasure the pirate can collect.\n\n    Args:\n    map_grid (List[List[int]]): A 2D grid representing the treasure map.\n\n    Returns:\n    int: The maximum amount of treasure that can be collected.\n\n\n    [EXAMPLES]\n    \n    assert candidate([[1, 2, 3, 4, 5], [6, 7, 8, 9, 10], [11, 12, 13, 14, 15]]) == 72\n    assert candidate([[1, 2], [3, 4], [5, 6], [7, 8]]) == 24\n\n    [/EXAMPLES]\n    \"\"\"\n    if not map_grid or not map_grid[0]:\n        return 0\n\n    rows, cols = len(map_grid), len(map_grid[0])\n    \n    # Initialize the DP table with the same dimensions as the input grid\n    dp = [[0 for _ in range(cols)] for _ in range(rows)]\n    \n    # Fill the first cell\n    dp[0][0] = map_grid[0][0]\n    \n    # Fill the first row\n    for j in range(1, cols):\n        dp[0][j] = dp[0][j-1] + map_grid[0][j]\n    \n    # Fill the first column\n    for i in range(1, rows):\n        dp[i][0] = dp[i-1][0] + map_grid[i][0]\n    \n    # Fill the rest of the DP table\n    for i in range(1, rows):\n        for j in range(1, cols):\n            dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + map_grid[i][j]\n    \n    # Return the maximum treasure collected\n    return dp[rows-1][cols-1]\n\n", "test": "def check(candidate):\n    assert candidate([[9, 8, 7], [6, 5, 4], [3, 2, 1]]) == 29\n    assert candidate([[1, 1], [1, 1]]) == 3\n    assert candidate([[10, 20, 30, 40], [50, 60, 70, 80], [90, 100, 110, 120]]) == 480\n    assert candidate([[0, 0, 0], [0, 1, 0], [0, 0, 0]]) == 1\n    assert candidate([[5, 4, 3, 2, 1]]) == 15\n    assert candidate([[1], [2], [3], [4], [5]]) == 15\n    assert candidate([[99, 99], [99, 99], [99, 99]]) == 396\n    assert candidate([[1, 2], [3, 4], [5, 6], [7, 8]]) == 24\n    assert candidate([[1, 0, 0], [0, 1, 0], [0, 0, 1]]) == 3\n    assert candidate([[1, 2, 3, 4, 5], [6, 7, 8, 9, 10], [11, 12, 13, 14, 15]]) == 72\n", "language": "python"}
{"task_id": "0f51a2a3-30ea-4f17-b903-33b80bc2ab674504155908711250334", "prompt": "Write the complete implementation of the function as specified in the documentation. Deliver your solution in a single code block with robust handling of edge cases.\n\n```python\nfrom typing import List\n\ndef analyze_stock_trends(prices: List[int], k: int) -> List[int]:\n    \"\"\"\n    A financial analyst wants to study stock price trends. Given a list of daily closing prices for a stock\n    and a window size k, determine for each day whether the stock price is in an uptrend, downtrend, or\n    neither.\n\n    A price is considered in an uptrend if it's higher than all k previous prices, in a downtrend if it's\n    lower than all k previous prices, and neither otherwise.\n\n    Write a function that takes a list of stock prices and the window size k as input, and returns a list\n    of integers where:\n    1 represents an uptrend\n    -1 represents a downtrend\n    0 represents neither\n\n    The first k elements in the output should always be 0 since there aren't enough previous prices to\n    determine a trend.\n\n\n    [EXAMPLES]\n    \n    assert candidate([10, 12, 8, 11, 13, 9, 14], 3) == [0, 0, 0, 0, 1, 0, 1]\n    assert candidate([1, 2, 3, 4, 5, 6, 7, 8, 9, 10], 10) == [0, 0, 0, 0, 0, 0, 0, 0, 0, 0]\n\n    [/EXAMPLES]\n    \"\"\"\n```\n", "entry_point": "analyze_stock_trends", "solution": "from typing import List\n\ndef analyze_stock_trends(prices: List[int], k: int) -> List[int]:\n    \"\"\"\n    A financial analyst wants to study stock price trends. Given a list of daily closing prices for a stock\n    and a window size k, determine for each day whether the stock price is in an uptrend, downtrend, or\n    neither.\n\n    A price is considered in an uptrend if it's higher than all k previous prices, in a downtrend if it's\n    lower than all k previous prices, and neither otherwise.\n\n    Write a function that takes a list of stock prices and the window size k as input, and returns a list\n    of integers where:\n    1 represents an uptrend\n    -1 represents a downtrend\n    0 represents neither\n\n    The first k elements in the output should always be 0 since there aren't enough previous prices to\n    determine a trend.\n\n\n    [EXAMPLES]\n    \n    assert candidate([10, 12, 8, 11, 13, 9, 14], 3) == [0, 0, 0, 0, 1, 0, 1]\n    assert candidate([1, 2, 3, 4, 5, 6, 7, 8, 9, 10], 10) == [0, 0, 0, 0, 0, 0, 0, 0, 0, 0]\n\n    [/EXAMPLES]\n    \"\"\"\n    n = len(prices)\n    result = [0] * n\n\n    for i in range(k, n):\n        window = prices[i-k:i]\n        current_price = prices[i]\n\n        if current_price > max(window):\n            result[i] = 1\n        elif current_price < min(window):\n            result[i] = -1\n        else:\n            result[i] = 0\n\n    return result\n\n", "test": "def check(candidate):\n    assert candidate([15, 13, 11, 9, 7, 5, 3, 1], 3) == [0, 0, 0, -1, -1, -1, -1, -1]\n    assert candidate([10, 12, 8, 11, 13, 9, 14], 3) == [0, 0, 0, 0, 1, 0, 1]\n    assert candidate([5, 5, 5, 5, 6, 6, 6, 6, 5, 5, 5, 5], 4) == [0, 0, 0, 0, 1, 0, 0, 0, -1, 0, 0, 0]\n    assert candidate([1, 2, 3, 2, 1, 2, 3, 2, 1], 2) == [0, 0, 1, 0, -1, 0, 1, 0, -1]\n    assert candidate([1, 2], 2) == [0, 0]\n    assert candidate([1, 2, 3, 4, 5, 6, 7, 8, 9, 10], 10) == [0, 0, 0, 0, 0, 0, 0, 0, 0, 0]\n    assert candidate([10, 9, 8, 7, 6, 5, 4, 3, 2, 1], 5) == [0, 0, 0, 0, 0, -1, -1, -1, -1, -1]\n    assert candidate([1, 2, 3, 4, 5], 1) == [0, 1, 1, 1, 1]\n    assert candidate([1, 10, 2, 9, 3, 8, 4, 7, 5, 6], 2) == [0, 0, 0, 0, 0, 0, 0, 0, 0, 0]\n    assert candidate([-1, -2, -3, -4, -5, -4, -3, -2, -1], 3) == [0, 0, 0, -1, -1, 0, 1, 1, 1]\n", "language": "python"}
{"task_id": "dcf0fa74-b461-4f0e-baea-815d17082f65-9077388585564694458", "prompt": "I'll complete the provided function in a single code block, making sure it's executable as-is. I'll only use libraries that are imported in the problem and will keep any additional functions or classes within the main function. My response will contain exactly one code block.\n\n```python\nfrom typing import List\n\ndef optimize_solar_panel_placement(rooftop_areas: List[int], panel_size: int) -> int:\n    \"\"\"\n    A sustainable energy company is planning to install solar panels on residential rooftops.\n    Given a list of available rooftop areas and the size of each solar panel, determine the\n    maximum number of solar panels that can be installed.\n\n    The function takes two parameters:\n    - rooftop_areas: A list of integers representing the areas of available rooftops in square meters.\n    - panel_size: An integer representing the area required for each solar panel in square meters.\n\n    Returns the maximum number of solar panels that can be installed.\n\n\n    [EXAMPLES]\n    \n    assert candidate([25, 25, 25, 25], 25) == 4\n    assert candidate([1000, 2000, 3000, 4000, 5000], 1000) == 15\n\n    [/EXAMPLES]\n    \"\"\"\n```\n", "entry_point": "optimize_solar_panel_placement", "solution": "from typing import List\n\ndef optimize_solar_panel_placement(rooftop_areas: List[int], panel_size: int) -> int:\n    \"\"\"\n    A sustainable energy company is planning to install solar panels on residential rooftops.\n    Given a list of available rooftop areas and the size of each solar panel, determine the\n    maximum number of solar panels that can be installed.\n\n    The function takes two parameters:\n    - rooftop_areas: A list of integers representing the areas of available rooftops in square meters.\n    - panel_size: An integer representing the area required for each solar panel in square meters.\n\n    Returns the maximum number of solar panels that can be installed.\n\n\n    [EXAMPLES]\n    \n    assert candidate([25, 25, 25, 25], 25) == 4\n    assert candidate([1000, 2000, 3000, 4000, 5000], 1000) == 15\n\n    [/EXAMPLES]\n    \"\"\"\n    def panels_per_roof(roof_area: int) -> int:\n        \"\"\"Calculate the number of panels that can fit on a single roof.\"\"\"\n        return roof_area // panel_size\n\n    total_panels = sum(panels_per_roof(roof) for roof in rooftop_areas)\n    return total_panels\n\n", "test": "def check(candidate):\n    assert candidate([100, 200, 300], 50) == 12\n    assert candidate([1000, 2000, 3000, 4000, 5000], 1000) == 15\n    assert candidate([99, 99, 99, 99], 33) == 12\n    assert candidate([0, 10, 20, 30], 5) == 12\n    assert candidate([7, 14, 21, 28, 35], 7) == 15\n    assert candidate([1, 10, 100, 1000], 1) == 1111\n    assert candidate([25, 25, 25, 25], 25) == 4\n    assert candidate([], 10) == 0\n    assert candidate([5, 5, 5, 5, 5], 1) == 25\n    assert candidate([9, 18, 27, 36, 45], 9) == 15\n", "language": "python"}
{"task_id": "b4827d80-7dd7-43f8-abed-e014d479b73257606520459052367", "prompt": "I'll implement the remaining code for this function following the docstring specifications. The solution will be in a single code block with edge cases addressed.\n\n```python\nfrom typing import List, Tuple\n\ndef decode_alien_message(transmissions: List[str], dictionary: List[Tuple[str, str]]) -> str:\n    \"\"\"\n    An alien civilization has sent a series of encoded transmissions to Earth. Scientists have\n    partially decrypted their language and compiled a dictionary of known alien words and their\n    English translations. Your task is to decode the alien messages using the provided dictionary.\n\n    This function employs string manipulation and pattern matching techniques to decipher the\n    alien language.\n\n\n    [EXAMPLES]\n    \n    assert candidate([\"message\"], [(\"not_in_transmission\", \"test\")]) == 'message'\n    assert candidate([\"symbol\"], [(\"symbol\", \"!@#$%^&*()\")]) == '!@#$%^&*()'\n\n    [/EXAMPLES]\n    \"\"\"\n```\n", "entry_point": "decode_alien_message", "solution": "from typing import List, Tuple\n\ndef decode_alien_message(transmissions: List[str], dictionary: List[Tuple[str, str]]) -> str:\n    \"\"\"\n    An alien civilization has sent a series of encoded transmissions to Earth. Scientists have\n    partially decrypted their language and compiled a dictionary of known alien words and their\n    English translations. Your task is to decode the alien messages using the provided dictionary.\n\n    This function employs string manipulation and pattern matching techniques to decipher the\n    alien language.\n\n\n    [EXAMPLES]\n    \n    assert candidate([\"message\"], [(\"not_in_transmission\", \"test\")]) == 'message'\n    assert candidate([\"symbol\"], [(\"symbol\", \"!@#$%^&*()\")]) == '!@#$%^&*()'\n\n    [/EXAMPLES]\n    \"\"\"\n    # Create a dictionary for faster lookup\n    translation_dict = dict(dictionary)\n    \n    # Translate each word in the transmission\n    decoded_words = []\n    for word in transmissions:\n        if word in translation_dict:\n            decoded_words.append(translation_dict[word])\n        else:\n            # If the word is not in the dictionary, keep it as is\n            decoded_words.append(word)\n    \n    # Join the translated words into a single string\n    decoded_message = \" \".join(decoded_words)\n    \n    return decoded_message\n\n", "test": "def check(candidate):\n    assert candidate([\"long\", \"word\"], [(\"long\", \"this is a\"), (\"word\", \"long translation\")]) == 'this is a long translation'\n    assert candidate([\"a\", \"b\", \"c\"], [(\"a\", \"apple\"), (\"b\", \"banana\"), (\"c\", \"cherry\"), (\"d\", \"date\")]) == 'apple banana cherry'\n    assert candidate([\"x\", \"y\", \"z\", \"x\", \"y\", \"z\"], [(\"x\", \"start\"), (\"y\", \"middle\"), (\"z\", \"end\")]) == 'start middle end start middle end'\n    assert candidate([\"very\", \"long\", \"alien\", \"transmission\"], [(\"very\", \"this\"), (\"long\", \"is\"), (\"alien\", \"a\"), (\"transmission\", \"test\")]) == 'this is a test'\n    assert candidate([\"x\", \"y\", \"z\"], [(\"a\", \"1\"), (\"b\", \"2\"), (\"c\", \"3\")]) == 'x y z'\n    assert candidate([\"a\", \"b\", \"c\"], [(\"a\", \"1\"), (\"b\", \"2\"), (\"c\", \"3\")]) == '1 2 3'\n    assert candidate([\"message\"], [(\"not_in_transmission\", \"test\")]) == 'message'\n    assert candidate([\"symbol\"], [(\"symbol\", \"!@#$%^&*()\")]) == '!@#$%^&*()'\n    assert candidate([\"hello\"], [(\"hello\", \"world\")]) == 'world'\n    assert candidate([\"gloop\", \"bleep\", \"gloop\"], [(\"gloop\", \"greetings\"), (\"bleep\", \"earthling\")]) == 'greetings earthling greetings'\n", "language": "python"}
{"task_id": "27f7bde3-7931-4e0a-b87e-4ece344a00997349676411863346220", "prompt": "I will implement the specified function so it's immediately executable. My implementation will be confined to the function body, using only libraries that are already imported. Any supplementary functions or classes will be defined within the scope of the main function.\n\n```python\ndef dna_strand_complement(sequence: str) -> str:\n    \"\"\"\n    A biologist needs to find the complementary DNA strand for a given DNA sequence.\n    This function takes a DNA sequence as input and returns its complement.\n\n    In DNA, A pairs with T, and C pairs with G. The complement of a strand is formed by\n    replacing each nucleotide with its pair.\n\n    The function should handle both uppercase and lowercase input, and maintain the case\n    in the output.\n\n\n    [EXAMPLES]\n    \n    assert candidate(\"\") == ''\n    assert candidate(\"GGGG\") == 'CCCC'\n\n    [/EXAMPLES]\n    \"\"\"\n```\n", "entry_point": "dna_strand_complement", "solution": "def dna_strand_complement(sequence: str) -> str:\n    \"\"\"\n    A biologist needs to find the complementary DNA strand for a given DNA sequence.\n    This function takes a DNA sequence as input and returns its complement.\n\n    In DNA, A pairs with T, and C pairs with G. The complement of a strand is formed by\n    replacing each nucleotide with its pair.\n\n    The function should handle both uppercase and lowercase input, and maintain the case\n    in the output.\n\n\n    [EXAMPLES]\n    \n    assert candidate(\"\") == ''\n    assert candidate(\"GGGG\") == 'CCCC'\n\n    [/EXAMPLES]\n    \"\"\"\n    complement_dict = {\n        'A': 'T', 'T': 'A', 'C': 'G', 'G': 'C',\n        'a': 't', 't': 'a', 'c': 'g', 'g': 'c'\n    }\n    \n    complementary_strand = ''\n    for nucleotide in sequence:\n        complementary_strand += complement_dict.get(nucleotide, nucleotide)\n    \n    return complementary_strand\n\n", "test": "def check(candidate):\n    assert candidate(\"TTTT\") == 'AAAA'\n    assert candidate(\"A\") == 'T'\n    assert candidate(\"GGGG\") == 'CCCC'\n    assert candidate(\"\") == ''\n    assert candidate(\"T\") == 'A'\n    assert candidate(\"GCTAgctaGCTAgcta\") == 'CGATcgatCGATcgat'\n    assert candidate(\"ATCGatcg\") == 'TAGCtagc'\n    assert candidate(\"CCCC\") == 'GGGG'\n    assert candidate(\"g\") == 'c'\n    assert candidate(\"tTaAgGcC\") == 'aAtTcCgG'\n", "language": "python"}
{"task_id": "43768b8b-c297-466d-bc4e-93175b7d2971-2065664831354791641", "prompt": "Finish the function implementation according to the docstring requirements. Include the entire function in a single code block and ensure robust handling of edge cases.\n\n```python\nfrom typing import List\n\ndef create_staircase(bricks: int) -> List[int]:\n    \"\"\"\n    An architect is designing a unique staircase using special bricks. Each step of the staircase\n    needs one more brick than the step below it. Given a number of bricks, determine the number of\n    complete steps that can be built and the number of bricks that will be left over.\n\n    Return a list where the first element is the number of complete steps and the second element\n    is the number of bricks left over.\n\n\n    [EXAMPLES]\n    \n    assert candidate(15) == [5, 0]\n    assert candidate(21) == [6, 0]\n\n    [/EXAMPLES]\n    \"\"\"\n```\n", "entry_point": "create_staircase", "solution": "from typing import List\n\ndef create_staircase(bricks: int) -> List[int]:\n    \"\"\"\n    An architect is designing a unique staircase using special bricks. Each step of the staircase\n    needs one more brick than the step below it. Given a number of bricks, determine the number of\n    complete steps that can be built and the number of bricks that will be left over.\n\n    Return a list where the first element is the number of complete steps and the second element\n    is the number of bricks left over.\n\n\n    [EXAMPLES]\n    \n    assert candidate(15) == [5, 0]\n    assert candidate(21) == [6, 0]\n\n    [/EXAMPLES]\n    \"\"\"\n    steps = 0\n    bricks_used = 0\n    \n    while bricks_used + steps + 1 <= bricks:\n        steps += 1\n        bricks_used += steps\n    \n    bricks_left = bricks - bricks_used\n    \n    return [steps, bricks_left]\n\n", "test": "def check(candidate):\n    assert candidate(21) == [6, 0]\n    assert candidate(17) == [5, 2]\n    assert candidate(15) == [5, 0]\n    assert candidate(1) == [1, 0]\n    assert candidate(10) == [4, 0]\n    assert candidate(6) == [3, 0]\n    assert candidate(3) == [2, 0]\n    assert candidate(55) == [10, 0]\n", "language": "python"}
{"task_id": "02e1587b-d6a1-4a85-abb5-8e7b3e552b50-7585029422689648430", "prompt": "My response will contain exactly one code block with the completed function implementation. I'll only use the libraries specified in the problem and keep all additional code within the function itself.\n\n```python\nfrom typing import List\n\ndef quantum_entanglement_network(connections: List[tuple]) -> int:\n    \"\"\"In a quantum network, particles are entangled in pairs. Given a list of entangled\n    particle pairs, determine the size of the largest connected group of entangled particles.\n\n    This function uses recursion and set operations to solve the problem.\n\n\n    [EXAMPLES]\n    \n    assert candidate([(1, 2), (2, 3), (3, 4), (4, 5), (5, 6), (6, 7), (7, 8), (8, 1)]) == 8\n    assert candidate([(i, i+1) for i in range(1, 1000, 2)]) == 2\n\n    [/EXAMPLES]\n    \"\"\"\n```\n", "entry_point": "quantum_entanglement_network", "solution": "from typing import List\n\ndef quantum_entanglement_network(connections: List[tuple]) -> int:\n    \"\"\"In a quantum network, particles are entangled in pairs. Given a list of entangled\n    particle pairs, determine the size of the largest connected group of entangled particles.\n\n    This function uses recursion and set operations to solve the problem.\n\n\n    [EXAMPLES]\n    \n    assert candidate([(1, 2), (2, 3), (3, 4), (4, 5), (5, 6), (6, 7), (7, 8), (8, 1)]) == 8\n    assert candidate([(i, i+1) for i in range(1, 1000, 2)]) == 2\n\n    [/EXAMPLES]\n    \"\"\"\n    def find_connected_group(particle, visited):\n        if particle in visited:\n            return set()\n        \n        visited.add(particle)\n        group = {particle}\n        \n        for connection in connections:\n            if particle in connection:\n                other_particle = connection[0] if connection[1] == particle else connection[1]\n                group.update(find_connected_group(other_particle, visited))\n        \n        return group\n\n    all_particles = set()\n    for connection in connections:\n        all_particles.update(connection)\n\n    visited = set()\n    largest_group_size = 0\n\n    for particle in all_particles:\n        if particle not in visited:\n            group = find_connected_group(particle, visited)\n            largest_group_size = max(largest_group_size, len(group))\n\n    return largest_group_size\n\n", "test": "def check(candidate):\n    assert candidate([(1, 2), (2, 3), (3, 4), (4, 5), (5, 6), (6, 7), (7, 8), (8, 1)]) == 8\n    assert candidate([(1, 2), (2, 3)]) == 3\n    assert candidate([(i, i+1) for i in range(1, 1000, 2)]) == 2\n    assert candidate([(1, 2), (3, 4), (5, 6), (7, 8), (9, 10), (11, 12), (13, 14), (15, 16), (17, 18), (19, 20)]) == 2\n    assert candidate([(1, 2), (3, 4), (5, 6), (7, 8), (9, 10), (2, 4), (6, 8), (10, 1)]) == 6\n    assert candidate([(1, 2), (2, 3), (3, 4), (4, 5), (5, 6), (6, 1)]) == 6\n    assert candidate([(1, 2), (2, 3), (3, 1), (4, 5), (5, 6), (6, 4), (7, 8), (8, 9), (9, 7)]) == 3\n    assert candidate([(1, 2), (3, 4)]) == 2\n    assert candidate([(1, 2), (2, 3), (4, 5), (5, 6)]) == 3\n    assert candidate([(i, i+1) for i in range(1, 100, 2)]) == 2\n", "language": "python"}
{"task_id": "bb167bea-f65f-4a5c-9b2f-9834eca80969-7496065825762012422", "prompt": "Based on the doc string, I'll write the complete function implementation. The entire code will be in one block.\n\n```python\nfrom typing import List\n\ndef analyze_stock_patterns(prices: List[int]) -> List[int]:\n    \"\"\"\n    A financial analyst is studying stock market patterns. They've noticed that certain price sequences\n    form a \"mountain\" pattern, where prices rise to a peak and then fall. Your task is to identify all\n    the \"peaks\" in the given price sequence.\n\n    A peak is defined as a price that is strictly greater than its neighboring prices. The first and last\n    prices cannot be peaks.\n\n    Args:\n    prices (List[int]): A list of daily stock prices.\n\n    Returns:\n    List[int]: The indices of all the peaks in the price sequence.\n\n\n    [EXAMPLES]\n    \n    assert candidate([1, 3, 2, 4, 1, 5, 3, 2]) == [1, 3, 5]\n    assert candidate([1, 10, 100, 1000, 100, 10, 1]) == [3]\n\n    [/EXAMPLES]\n    \"\"\"\n```\n", "entry_point": "analyze_stock_patterns", "solution": "from typing import List\n\ndef analyze_stock_patterns(prices: List[int]) -> List[int]:\n    \"\"\"\n    A financial analyst is studying stock market patterns. They've noticed that certain price sequences\n    form a \"mountain\" pattern, where prices rise to a peak and then fall. Your task is to identify all\n    the \"peaks\" in the given price sequence.\n\n    A peak is defined as a price that is strictly greater than its neighboring prices. The first and last\n    prices cannot be peaks.\n\n    Args:\n    prices (List[int]): A list of daily stock prices.\n\n    Returns:\n    List[int]: The indices of all the peaks in the price sequence.\n\n\n    [EXAMPLES]\n    \n    assert candidate([1, 3, 2, 4, 1, 5, 3, 2]) == [1, 3, 5]\n    assert candidate([1, 10, 100, 1000, 100, 10, 1]) == [3]\n\n    [/EXAMPLES]\n    \"\"\"\n    peaks = []\n    \n    # We start from index 1 and end at the second-to-last index\n    # because the first and last prices cannot be peaks\n    for i in range(1, len(prices) - 1):\n        # Check if the current price is strictly greater than both its neighbors\n        if prices[i] > prices[i-1] and prices[i] > prices[i+1]:\n            peaks.append(i)\n    \n    return peaks\n\n", "test": "def check(candidate):\n    assert candidate([3, 3, 4, 4, 5, 5, 4, 4, 3, 3]) == []\n    assert candidate([5, 4, 3, 2, 1, 2, 3, 4, 5, 4, 3, 2, 1]) == [8]\n    assert candidate([1, 2, 3, 3, 2, 1]) == []\n    assert candidate([1, 2]) == []\n    assert candidate([5, 5, 5, 4, 5, 5, 5]) == []\n    assert candidate([7, 6, 5, 4, 3, 2, 1, 2, 3, 4, 5, 6, 7]) == []\n    assert candidate([2, 1, 3, 1, 4, 1, 5]) == [2, 4]\n    assert candidate([1, 10, 100, 1000, 100, 10, 1]) == [3]\n    assert candidate([1, 3, 2, 4, 1, 5, 3, 2]) == [1, 3, 5]\n    assert candidate([1]) == []\n", "language": "python"}
{"task_id": "615ecdde-a7e2-4515-b6cb-15607504d6a2-3261004672670316123", "prompt": "I need to see the function signature and docstring first to properly implement the function. Please provide the initial code so I can complete it according to the specifications without modifying the function name or parameters.\n\n```python\nfrom typing import List, Dict\n\ndef analyze_text_sentiment(text: str, sentiment_dict: Dict[str, float]) -> float:\n    \"\"\"\n    Analyze the sentiment of a given text using a pre-defined sentiment dictionary.\n\n    This function takes a text string and a dictionary of words with their associated\n    sentiment scores, then calculates an overall sentiment score for the text.\n    The function utilizes string methods and dictionary comprehension.\n\n    Args:\n    text (str): The input text to analyze.\n    sentiment_dict (Dict[str, float]): A dictionary mapping words to sentiment scores.\n\n    Returns:\n    float: The overall sentiment score of the text.\n\n\n    [EXAMPLES]\n    \n    assert candidate(\"Extremely positive and extremely negative.\", {\"extremely\": 0.8, \"positive\": 0.9, \"and\": 0.0, \"negative\": -0.9}) == 0.5666666666666668\n    assert candidate(\"All negative words.\", {\"all\": -0.3, \"negative\": -0.8, \"words\": -0.5}) == -0.55\n\n    [/EXAMPLES]\n    \"\"\"\n```\n", "entry_point": "analyze_text_sentiment", "solution": "from typing import List, Dict\n\ndef analyze_text_sentiment(text: str, sentiment_dict: Dict[str, float]) -> float:\n    \"\"\"\n    Analyze the sentiment of a given text using a pre-defined sentiment dictionary.\n\n    This function takes a text string and a dictionary of words with their associated\n    sentiment scores, then calculates an overall sentiment score for the text.\n    The function utilizes string methods and dictionary comprehension.\n\n    Args:\n    text (str): The input text to analyze.\n    sentiment_dict (Dict[str, float]): A dictionary mapping words to sentiment scores.\n\n    Returns:\n    float: The overall sentiment score of the text.\n\n\n    [EXAMPLES]\n    \n    assert candidate(\"Extremely positive and extremely negative.\", {\"extremely\": 0.8, \"positive\": 0.9, \"and\": 0.0, \"negative\": -0.9}) == 0.5666666666666668\n    assert candidate(\"All negative words.\", {\"all\": -0.3, \"negative\": -0.8, \"words\": -0.5}) == -0.55\n\n    [/EXAMPLES]\n    \"\"\"\n    # Convert text to lowercase and split into words\n    words = text.lower().split()\n\n    # Create a dictionary of sentiment scores for words present in both the text and sentiment_dict\n    word_scores = {word: sentiment_dict[word] for word in words if word in sentiment_dict}\n\n    # Calculate the overall sentiment score\n    if word_scores:\n        return sum(word_scores.values()) / len(word_scores)\n    else:\n        return 0.0  # Return neutral sentiment if no matching words are found\n\n\n", "test": "def check(candidate):\n    assert candidate(\"All negative words.\", {\"all\": -0.3, \"negative\": -0.8, \"words\": -0.5}) == -0.55\n    assert candidate(\"Word with multiple meanings bank.\", {\"bank\": 0.2, \"with\": 0.0, \"multiple\": 0.3, \"meanings\": 0.4}) == 0.2333333333333333\n    assert candidate(\"Amazing experience, highly recommend!\", {\"amazing\": 0.9, \"experience\": 0.6, \"highly\": 0.7, \"recommend\": 0.8}) == 0.8\n    assert candidate(\"All positive words!\", {\"all\": 0.7, \"positive\": 0.9, \"words\": 0.6}) == 0.8\n    assert candidate(\"Extremely positive and extremely negative.\", {\"extremely\": 0.8, \"positive\": 0.9, \"and\": 0.0, \"negative\": -0.9}) == 0.5666666666666668\n    assert candidate(\"This is a neutral sentence.\", {\"neutral\": 0.0, \"positive\": 1.0, \"negative\": -1.0}) == 0.0\n    assert candidate(\"Mixed Case WoRdS\", {\"mixed\": 0.3, \"case\": 0.2, \"words\": 0.4}) == 0.3\n    assert candidate(\"Numbers 123 and symbols @#$ matter\", {\"numbers\": 0.2, \"symbols\": 0.1, \"matter\": 0.6}) == 0.3\n    assert candidate(\"I love this product!\", {\"love\": 0.8, \"hate\": -0.8, \"like\": 0.5}) == 0.8\n    assert candidate(\"I really hate this awful product!\", {\"really\": 0.5, \"hate\": -0.9, \"awful\": -0.7, \"product\": 0.1}) == -0.3666666666666667\n", "language": "python"}
{"task_id": "6d828dde-ffbd-4982-8363-151bd60f7c3a-6980410248793712893", "prompt": "Finish coding the function as specified in the doc string. Present the entire implementation in one code block.\n\n```python\nfrom typing import List\n\ndef encrypt_message(message: str, key: List[int]) -> str:\n    \"\"\"\n    As a cryptography enthusiast, you've developed a simple encryption algorithm \n    for secure communication. The algorithm shifts each character in the message \n    by a corresponding value in the key list, wrapping around the alphabet if necessary.\n\n    This function takes a message (string of lowercase letters and spaces) and a key \n    (list of integers) as input. It returns the encrypted message as a string.\n\n    The function combines string manipulation with modular arithmetic to achieve \n    the encryption.\n\n\n    [EXAMPLES]\n    \n    assert candidate(\"xyz\", [3, 2, 1]) == 'aaa'\n    assert candidate(\"test\", [26, 52, 78, 104]) == 'test'\n\n    [/EXAMPLES]\n    \"\"\"\n```\n", "entry_point": "encrypt_message", "solution": "from typing import List\n\ndef encrypt_message(message: str, key: List[int]) -> str:\n    \"\"\"\n    As a cryptography enthusiast, you've developed a simple encryption algorithm \n    for secure communication. The algorithm shifts each character in the message \n    by a corresponding value in the key list, wrapping around the alphabet if necessary.\n\n    This function takes a message (string of lowercase letters and spaces) and a key \n    (list of integers) as input. It returns the encrypted message as a string.\n\n    The function combines string manipulation with modular arithmetic to achieve \n    the encryption.\n\n\n    [EXAMPLES]\n    \n    assert candidate(\"xyz\", [3, 2, 1]) == 'aaa'\n    assert candidate(\"test\", [26, 52, 78, 104]) == 'test'\n\n    [/EXAMPLES]\n    \"\"\"\n    def shift_char(char: str, shift: int) -> str:\n        if char == ' ':\n            return ' '\n        return chr((ord(char) - ord('a') + shift) % 26 + ord('a'))\n\n    encrypted = []\n    key_length = len(key)\n    \n    for i, char in enumerate(message):\n        shift = key[i % key_length]\n        encrypted.append(shift_char(char, shift))\n    \n    return ''.join(encrypted)\n\n", "test": "def check(candidate):\n    assert candidate(\"short key\", [1]) == 'tipsu lfz'\n    assert candidate(\"alternating az\", [1, 25]*50) == 'bkudsmbsjmh by'\n    assert candidate(\"z\"*100, [25]*100) == 'yyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyy'\n    assert candidate(\"test\", [26, 52, 78, 104]) == 'test'\n    assert candidate(\"aaaaaa\", [25, 24, 23, 22, 21, 20]) == 'zyxwvu'\n    assert candidate(\"\", []) == ''\n    assert candidate(\"xyz\", [3, 2, 1]) == 'aaa'\n    assert candidate(\"punctuation test\", [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17]) == 'qwqgyahbryy gshj'\n", "language": "python"}
{"task_id": "67a65bc2-e99c-4a03-8427-b03e48777fcf-3423094602413482", "prompt": "Please complete the given function in a single code block. Ensure it's executable as is, with no code outside the function. Only use libraries that are imported in the problem. If you need to define additional functions or classes, place them inside the main function. I'll provide just one code block in my response.\n\n```python\ndef decrypt_caesar_cipher(ciphertext: str, shift: int) -> str:\n    \"\"\"\n    Decrypt a message encoded with the Caesar cipher.\n\n    This function takes a ciphertext encrypted using the Caesar cipher and the\n    shift value used for encryption. It then decrypts the message and returns\n    the original plaintext. The function handles uppercase and lowercase letters,\n    preserving their case, and leaves non-alphabetic characters unchanged.\n\n    Args:\n    ciphertext (str): The encrypted message to be decrypted.\n    shift (int): The number of positions each letter was shifted during encryption.\n\n    Returns:\n    str: The decrypted plaintext message.\n\n\n    [EXAMPLES]\n    \n    assert candidate(\"Qrstuvwxyzabcdefghijklmnop\", 16) == 'Abcdefghijklmnopqrstuvwxyz'\n    assert candidate(\"Hello, World!\", 0) == 'Hello, World!'\n\n    [/EXAMPLES]\n    \"\"\"\n```\n", "entry_point": "decrypt_caesar_cipher", "solution": "def decrypt_caesar_cipher(ciphertext: str, shift: int) -> str:\n    \"\"\"\n    Decrypt a message encoded with the Caesar cipher.\n\n    This function takes a ciphertext encrypted using the Caesar cipher and the\n    shift value used for encryption. It then decrypts the message and returns\n    the original plaintext. The function handles uppercase and lowercase letters,\n    preserving their case, and leaves non-alphabetic characters unchanged.\n\n    Args:\n    ciphertext (str): The encrypted message to be decrypted.\n    shift (int): The number of positions each letter was shifted during encryption.\n\n    Returns:\n    str: The decrypted plaintext message.\n\n\n    [EXAMPLES]\n    \n    assert candidate(\"Qrstuvwxyzabcdefghijklmnop\", 16) == 'Abcdefghijklmnopqrstuvwxyz'\n    assert candidate(\"Hello, World!\", 0) == 'Hello, World!'\n\n    [/EXAMPLES]\n    \"\"\"\n    def shift_char(char: str, shift: int) -> str:\n        if char.isalpha():\n            ascii_offset = 65 if char.isupper() else 97\n            return chr((ord(char) - ascii_offset - shift) % 26 + ascii_offset)\n        return char\n\n    return ''.join(shift_char(char, shift) for char in ciphertext)\n\n", "test": "def check(candidate):\n    assert candidate(\"Hello, World!\", 0) == 'Hello, World!'\n    assert candidate(\"XyZ\", 27) == 'WxY'\n    assert candidate(\"Ifmmp, Xpsme!\", 1) == 'Hello, World!'\n    assert candidate(\"Qrstuvwxyzabcdefghijklmnop\", 16) == 'Abcdefghijklmnopqrstuvwxyz'\n    assert candidate(\"Khoor, Zruog!\", 3) == 'Hello, World!'\n    assert candidate(\"The Quick Brown Fox Jumps Over The Lazy Dog\", 100) == 'Xli Uymgo Fvsar Jsb Nyqtw Sziv Xli Pedc Hsk'\n    assert candidate(\"z\", 1) == 'y'\n    assert candidate(\"Gdkkn, Vnqkc!\", 25) == 'Hello, World!'\n    assert candidate(\"\", 0) == ''\n    assert candidate(\"AbCdEfG\", 26) == 'AbCdEfG'\n", "language": "python"}
{"task_id": "7ce0872d-4b0e-4af0-af3b-5f3dc6dbbd47-5296281109568037392", "prompt": "The completed function will be delivered in one executable code block. I'll only use the libraries specified in the imports, and any additional functions or classes will be nested within the main function. My response will consist of just the one required code block.\n\n```python\nfrom typing import List, Tuple\n\ndef archaeological_dig(site_map: List[List[int]], tools: List[int]) -> Tuple[int, List[Tuple[int, int]]]:\n    \"\"\"\n    An archaeological team is excavating an ancient site. The site is represented as a grid where each cell contains\n    an integer representing the depth of artifacts at that location. The team has a set of digging tools, each capable\n    of digging to a certain depth. The goal is to find the maximum number of artifacts that can be excavated and their\n    locations given the available tools.\n\n    Args:\n    site_map (List[List[int]]): A 2D grid representing the depths of artifacts at each location.\n    tools (List[int]): A list of integers representing the digging capabilities of available tools.\n\n    Returns:\n    Tuple[int, List[Tuple[int, int]]]: A tuple containing the maximum number of artifacts that can be excavated\n    and a list of (row, column) coordinates where artifacts can be found.\n\n\n    [EXAMPLES]\n    \n    assert candidate([[100]], [99]) == (0, [])\n    assert candidate([[1, 2], [3, 4], [5, 6], [7, 8]], [4, 6]) == (6, [(0, 0), (0, 1), (1, 0), (1, 1), (2, 0), (2, 1)])\n\n    [/EXAMPLES]\n    \"\"\"\n```\n", "entry_point": "archaeological_dig", "solution": "from typing import List, Tuple\n\ndef archaeological_dig(site_map: List[List[int]], tools: List[int]) -> Tuple[int, List[Tuple[int, int]]]:\n    \"\"\"\n    An archaeological team is excavating an ancient site. The site is represented as a grid where each cell contains\n    an integer representing the depth of artifacts at that location. The team has a set of digging tools, each capable\n    of digging to a certain depth. The goal is to find the maximum number of artifacts that can be excavated and their\n    locations given the available tools.\n\n    Args:\n    site_map (List[List[int]]): A 2D grid representing the depths of artifacts at each location.\n    tools (List[int]): A list of integers representing the digging capabilities of available tools.\n\n    Returns:\n    Tuple[int, List[Tuple[int, int]]]: A tuple containing the maximum number of artifacts that can be excavated\n    and a list of (row, column) coordinates where artifacts can be found.\n\n\n    [EXAMPLES]\n    \n    assert candidate([[100]], [99]) == (0, [])\n    assert candidate([[1, 2], [3, 4], [5, 6], [7, 8]], [4, 6]) == (6, [(0, 0), (0, 1), (1, 0), (1, 1), (2, 0), (2, 1)])\n\n    [/EXAMPLES]\n    \"\"\"\n    def can_dig(depth: int) -> bool:\n        return any(tool >= depth for tool in tools)\n\n    rows = len(site_map)\n    cols = len(site_map[0])\n    artifacts = 0\n    locations = []\n\n    for row in range(rows):\n        for col in range(cols):\n            depth = site_map[row][col]\n            if can_dig(depth):\n                artifacts += 1\n                locations.append((row, col))\n\n    return artifacts, locations\n\n", "test": "def check(candidate):\n    assert candidate([[1]], [1]) == (1, [(0, 0)])\n    assert candidate([[1, 2, 3, 4], [5, 6, 7, 8], [9, 10, 11, 12], [13, 14, 15, 16]], [8, 12]) == (12, [(0, 0), (0, 1), (0, 2), (0, 3), (1, 0), (1, 1), (1, 2), (1, 3), (2, 0), (2, 1), (2, 2), (2, 3)])\n    assert candidate([[100]], [99]) == (0, [])\n    assert candidate([[]], [1]) == (0, [])\n    assert candidate([[1, 2], [3, 4], [5, 6], [7, 8]], [4, 6]) == (6, [(0, 0), (0, 1), (1, 0), (1, 1), (2, 0), (2, 1)])\n    assert candidate([[10, 20], [30, 40]], [15, 35]) == (3, [(0, 0), (0, 1), (1, 0)])\n    assert candidate([[0, 0, 0], [0, 0, 0], [0, 0, 0]], [1]) == (9, [(0, 0), (0, 1), (0, 2), (1, 0), (1, 1), (1, 2), (2, 0), (2, 1), (2, 2)])\n    assert candidate([[1, 1], [1, 1], [1, 1], [1, 1], [1, 1]], [1]) == (10, [(0, 0), (0, 1), (1, 0), (1, 1), (2, 0), (2, 1), (3, 0), (3, 1), (4, 0), (4, 1)])\n    assert candidate([[1, 2, 3], [4, 5, 6], [7, 8, 9]], [10]) == (9, [(0, 0), (0, 1), (0, 2), (1, 0), (1, 1), (1, 2), (2, 0), (2, 1), (2, 2)])\n    assert candidate([[10, 20, 30, 40, 50]], [25, 45]) == (4, [(0, 0), (0, 1), (0, 2), (0, 3)])\n", "language": "python"}
{"task_id": "476b85c1-f1df-4dd0-b4ab-e29c32cbc9f93665413473947403485", "prompt": "Following the specifications in the doc string, complete the function implementation. Deliver the entire function in a single code block and ensure all edge cases are properly handled.\n\n```python\nfrom typing import List\n\ndef analyze_sensor_data(readings: List[float], threshold: float) -> int:\n    \"\"\"\n    A meteorologist is studying temperature anomalies in a specific region.\n    This function analyzes a series of temperature readings and determines\n    the number of times the temperature difference between consecutive days\n    exceeds a given threshold.\n\n    Args:\n    readings (List[float]): A list of daily temperature readings.\n    threshold (float): The temperature difference threshold to consider.\n\n    Returns:\n    int: The count of times the temperature difference exceeds the threshold.\n\n\n    [EXAMPLES]\n    \n    assert candidate([100.0, 50.0, 25.0, 12.5, 6.25], 10.0) == 3\n    assert candidate([10.0, 9.0, 8.0, 7.0, 6.0], 0.9) == 4\n\n    [/EXAMPLES]\n    \"\"\"\n```\n", "entry_point": "analyze_sensor_data", "solution": "from typing import List\n\ndef analyze_sensor_data(readings: List[float], threshold: float) -> int:\n    \"\"\"\n    A meteorologist is studying temperature anomalies in a specific region.\n    This function analyzes a series of temperature readings and determines\n    the number of times the temperature difference between consecutive days\n    exceeds a given threshold.\n\n    Args:\n    readings (List[float]): A list of daily temperature readings.\n    threshold (float): The temperature difference threshold to consider.\n\n    Returns:\n    int: The count of times the temperature difference exceeds the threshold.\n\n\n    [EXAMPLES]\n    \n    assert candidate([100.0, 50.0, 25.0, 12.5, 6.25], 10.0) == 3\n    assert candidate([10.0, 9.0, 8.0, 7.0, 6.0], 0.9) == 4\n\n    [/EXAMPLES]\n    \"\"\"\n    count = 0\n    for i in range(1, len(readings)):\n        difference = abs(readings[i] - readings[i-1])\n        if difference > threshold:\n            count += 1\n    return count\n\n", "test": "def check(candidate):\n    assert candidate([37.0, 36.5, 37.5, 36.0, 38.0], 0.7) == 3\n    assert candidate([100.0, 50.0, 25.0, 12.5, 6.25], 10.0) == 3\n    assert candidate([30.0, 25.0, 35.0, 20.0, 40.0], 5.0) == 3\n    assert candidate([20.0, 22.0, 21.0, 23.0, 22.0], 1.5) == 2\n    assert candidate([-5.0, 5.0, -5.0, 5.0, -5.0], 9.9) == 4\n    assert candidate([-10.0, -8.5, -9.0, -7.5, -8.0], 1.0) == 2\n    assert candidate([10.0, 9.0, 8.0, 7.0, 6.0], 0.9) == 4\n    assert candidate([0.0001, 0.0002, 0.0003, 0.0004, 0.0005], 0.00005) == 4\n    assert candidate([0.1, 0.2, 0.3, 0.4, 0.5], 0.05) == 4\n    assert candidate([1.0, 1.1, 1.2, 1.3, 1.4], 0.15) == 0\n", "language": "python"}
{"task_id": "af8f5e75-cca1-44bf-8010-aa87fc6464427354040172229625833", "prompt": "I'm a coding assistant. My role is to complete the provided function so it's ready for execution. I'll only write code within the function's boundaries, using only the libraries that are already imported. Any helper functions or classes I add will be defined inside the main function.\n\n```python\nfrom typing import List, Tuple\n\ndef optimize_study_schedule(subjects: List[str], time_required: List[int], available_time: int) -> Tuple[List[str], int]:\n    \"\"\"\n    A student is preparing for exams and wants to optimize their study schedule. They have\n    a list of subjects to study, the time required for each subject, and a limited amount\n    of available study time.\n\n    This function takes three parameters:\n    1. A list of subject names\n    2. A list of time required (in hours) for each subject, corresponding to the subject list\n    3. The total available study time (in hours)\n\n    The function should return a tuple containing:\n    1. A list of subjects that can be studied within the available time, maximizing the\n       number of subjects covered\n    2. The total time utilized for studying\n\n    If multiple combinations of subjects are possible, return the one that utilizes the\n    most time.\n\n\n    [EXAMPLES]\n    \n    assert candidate(['S'*50 for _ in range(10)], [1]*10, 5) == (['SSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSS', 'SSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSS', 'SSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSS', 'SSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSS', 'SSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSS'], 5)\n    assert candidate(['History', 'Literature', 'Art'], [3, 2, 1], 4) == (['History', 'Art'], 4)\n\n    [/EXAMPLES]\n    \"\"\"\n```\n", "entry_point": "optimize_study_schedule", "solution": "from typing import List, Tuple\n\ndef optimize_study_schedule(subjects: List[str], time_required: List[int], available_time: int) -> Tuple[List[str], int]:\n    \"\"\"\n    A student is preparing for exams and wants to optimize their study schedule. They have\n    a list of subjects to study, the time required for each subject, and a limited amount\n    of available study time.\n\n    This function takes three parameters:\n    1. A list of subject names\n    2. A list of time required (in hours) for each subject, corresponding to the subject list\n    3. The total available study time (in hours)\n\n    The function should return a tuple containing:\n    1. A list of subjects that can be studied within the available time, maximizing the\n       number of subjects covered\n    2. The total time utilized for studying\n\n    If multiple combinations of subjects are possible, return the one that utilizes the\n    most time.\n\n\n    [EXAMPLES]\n    \n    assert candidate(['S'*50 for _ in range(10)], [1]*10, 5) == (['SSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSS', 'SSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSS', 'SSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSS', 'SSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSS', 'SSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSS'], 5)\n    assert candidate(['History', 'Literature', 'Art'], [3, 2, 1], 4) == (['History', 'Art'], 4)\n\n    [/EXAMPLES]\n    \"\"\"\n    def knapsack(n, W, weights, values):\n        K = [[0 for _ in range(W + 1)] for _ in range(n + 1)]\n        \n        for i in range(n + 1):\n            for w in range(W + 1):\n                if i == 0 or w == 0:\n                    K[i][w] = 0\n                elif weights[i-1] <= w:\n                    K[i][w] = max(values[i-1] + K[i-1][w-weights[i-1]], K[i-1][w])\n                else:\n                    K[i][w] = K[i-1][w]\n        \n        return K\n\n    n = len(subjects)\n    K = knapsack(n, available_time, time_required, time_required)\n    \n    selected_subjects = []\n    total_time = 0\n    w = available_time\n    \n    for i in range(n, 0, -1):\n        if K[i][w] != K[i-1][w]:\n            selected_subjects.append(subjects[i-1])\n            total_time += time_required[i-1]\n            w -= time_required[i-1]\n    \n    selected_subjects.reverse()\n    return (selected_subjects, total_time)\n\n", "test": "def check(candidate):\n    assert candidate(['A', 'B', 'C', 'D', 'E'], [1, 2, 3, 4, 5], 10) == (['A', 'B', 'C', 'D'], 10)\n    assert candidate(['A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J'], [1]*10, 5) == (['A', 'B', 'C', 'D', 'E'], 5)\n    assert candidate(['S'*50 for _ in range(10)], [1]*10, 5) == (['SSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSS', 'SSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSS', 'SSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSS', 'SSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSS', 'SSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSS'], 5)\n    assert candidate(['Subject1', 'Subject2'], [1, 1], 1) == (['Subject1'], 1)\n    assert candidate(['A', 'B', 'C', 'D', 'E'], [5, 4, 3, 2, 1], 10) == (['A', 'C', 'D'], 10)\n    assert candidate(['History', 'Literature', 'Art'], [3, 2, 1], 4) == (['History', 'Art'], 4)\n    assert candidate(['A'*100, 'B'*100, 'C'*100], [1, 2, 3], 6) == (['AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA', 'BBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBB', 'CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC'], 6)\n    assert candidate(['Subject1', 'Subject2', 'Subject3'], [2, 2, 2], 5) == (['Subject1', 'Subject2'], 4)\n    assert candidate(['S1', 'S2', 'S3', 'S4', 'S5'], [3, 1, 4, 1, 5], 9) == (['S1', 'S2', 'S3', 'S4'], 9)\n    assert candidate(['X', 'Y', 'Z'], [5, 5, 5], 15) == (['X', 'Y', 'Z'], 15)\n", "language": "python"}
{"task_id": "a548a4ea-458f-465a-b996-ace9c8081ef34515581203216945571", "prompt": "Please implement the specified function according to the requirements. The function should be complete and runnable as-is in a single code block. Do not add any external code. Only utilize libraries that are already imported in the problem statement. If you need additional functions or classes, define them inside the main function.\n\n```python\nimport itertools\nfrom typing import List\n\ndef decode_alien_message(message: str, dictionary: List[str]) -> int:\n    \"\"\"\n    An alien civilization has sent a coded message. The message is a string of lowercase letters,\n    and you have a dictionary of valid alien words. Your task is to find the number of ways to\n    decode the entire message using only words from the dictionary.\n\n    The function takes two parameters:\n    - message: A string representing the coded alien message\n    - dictionary: A list of valid alien words\n\n    Return the number of ways to decode the entire message. If it's impossible to decode the\n    entire message using the given dictionary, return 0.\n\n\n    [EXAMPLES]\n    \n    assert candidate(\"thequickbrownfox\", [\"the\", \"quick\", \"brown\", \"fox\", \"quickbrown\"]) == 2\n    assert candidate(\"zzzzzz\", [\"z\", \"zz\", \"zzz\"]) == 24\n\n    [/EXAMPLES]\n    \"\"\"\n```\n", "entry_point": "decode_alien_message", "solution": "import itertools\nfrom typing import List\n\ndef decode_alien_message(message: str, dictionary: List[str]) -> int:\n    \"\"\"\n    An alien civilization has sent a coded message. The message is a string of lowercase letters,\n    and you have a dictionary of valid alien words. Your task is to find the number of ways to\n    decode the entire message using only words from the dictionary.\n\n    The function takes two parameters:\n    - message: A string representing the coded alien message\n    - dictionary: A list of valid alien words\n\n    Return the number of ways to decode the entire message. If it's impossible to decode the\n    entire message using the given dictionary, return 0.\n\n\n    [EXAMPLES]\n    \n    assert candidate(\"thequickbrownfox\", [\"the\", \"quick\", \"brown\", \"fox\", \"quickbrown\"]) == 2\n    assert candidate(\"zzzzzz\", [\"z\", \"zz\", \"zzz\"]) == 24\n\n    [/EXAMPLES]\n    \"\"\"\n    def can_decode(start: int, memo: dict) -> int:\n        if start == len(message):\n            return 1\n        \n        if start in memo:\n            return memo[start]\n        \n        ways = 0\n        for word in dictionary:\n            if message.startswith(word, start):\n                ways += can_decode(start + len(word), memo)\n        \n        memo[start] = ways\n        return ways\n    \n    memo = {}\n    return can_decode(0, memo)\n\n", "test": "def check(candidate):\n    assert candidate(\"aaab\", [\"a\", \"aa\", \"aaa\", \"b\"]) == 4\n    assert candidate(\"abcabcabc\", [\"a\", \"ab\", \"abc\", \"abca\", \"abcabc\"]) == 3\n    assert candidate(\"zzzzzz\", [\"z\", \"zz\", \"zzz\"]) == 24\n    assert candidate(\"abc\", [\"a\", \"b\", \"c\"]) == 1\n    assert candidate(\"\", []) == 1\n    assert candidate(\"a\", [\"a\"]) == 1\n    assert candidate(\"abcdef\", [\"ab\", \"abc\", \"cd\", \"def\", \"abcd\"]) == 1\n    assert candidate(\"helloworld\", [\"hello\", \"world\", \"hell\", \"o\", \"w\", \"or\", \"ld\"]) == 4\n    assert candidate(\"thequickbrownfox\", [\"the\", \"quick\", \"brown\", \"fox\", \"quickbrown\"]) == 2\n    assert candidate(\"aaaaaa\", [\"a\", \"aa\", \"aaa\"]) == 24\n", "language": "python"}
{"task_id": "77484f3f-5114-4e1d-a1dd-4ea0374033c3-3144837819073735251", "prompt": "Please complete the function implementation based on the provided docstring. Ensure you capture all edge cases in a single code block.\n\n```python\nfrom typing import List\n\ndef fibonacci_sequence_generator(n: int) -> List[int]:\n    \"\"\"\n    Generate a Fibonacci sequence with a twist. In this version, each number in the sequence\n    is the sum of the three preceding ones, starting from 0, 1, 1. Your task is to implement\n    this modified Fibonacci sequence generator.\n\n    Given an integer n, return a list containing the first n numbers in this sequence.\n\n\n    [EXAMPLES]\n    \n    assert candidate(100) == [0, 1, 1, 2, 4, 7, 13, 24, 44, 81, 149, 274, 504, 927, 1705, 3136, 5768, 10609, 19513, 35890, 66012, 121415, 223317, 410744, 755476, 1389537, 2555757, 4700770, 8646064, 15902591, 29249425, 53798080, 98950096, 181997601, 334745777, 615693474, 1132436852, 2082876103, 3831006429, 7046319384, 12960201916, 23837527729, 43844049029, 80641778674, 148323355432, 272809183135, 501774317241, 922906855808, 1697490356184, 3122171529233, 5742568741225, 10562230626642, 19426970897100, 35731770264967, 65720971788709, 120879712950776, 222332455004452, 408933139743937, 752145307699165, 1383410902447554, 2544489349890656, 4680045560037375, 8607945812375585, 15832480722303616, 29120472094716576, 53560898629395777, 98513851446415969, 181195222170528322, 333269972246340068, 612979045863284359, 1127444240280152749, 2073693258389777176, 3814116544533214284, 7015254043203144209, 12903063846126135669, 23732434433862494162, 43650752323191774040, 80286250603180403871, 147669437360234672073, 271606440286606849984, 499562128250021925928, 918838005896863447985, 1690006574433492223897, 3108406708580377597810, 5717251288910733269692, 10515664571924603091399, 19341322569415713958901, 35574238430251050319992, 65431225571591367370292, 120346786571258131649185, 221352250573100549339469, 407130262715950048358946, 748829299860308729347600, 1377311813149359327046015, 2533271375725618104752561, 4659412488735286161146176, 8569995677610263592944752, 15762679542071167858843489, 28992087708416717612934417, 53324762928098149064722658]\n    assert candidate(5) == [0, 1, 1, 2, 4]\n\n    [/EXAMPLES]\n    \"\"\"\n```\n", "entry_point": "fibonacci_sequence_generator", "solution": "from typing import List\n\ndef fibonacci_sequence_generator(n: int) -> List[int]:\n    \"\"\"\n    Generate a Fibonacci sequence with a twist. In this version, each number in the sequence\n    is the sum of the three preceding ones, starting from 0, 1, 1. Your task is to implement\n    this modified Fibonacci sequence generator.\n\n    Given an integer n, return a list containing the first n numbers in this sequence.\n\n\n    [EXAMPLES]\n    \n    assert candidate(100) == [0, 1, 1, 2, 4, 7, 13, 24, 44, 81, 149, 274, 504, 927, 1705, 3136, 5768, 10609, 19513, 35890, 66012, 121415, 223317, 410744, 755476, 1389537, 2555757, 4700770, 8646064, 15902591, 29249425, 53798080, 98950096, 181997601, 334745777, 615693474, 1132436852, 2082876103, 3831006429, 7046319384, 12960201916, 23837527729, 43844049029, 80641778674, 148323355432, 272809183135, 501774317241, 922906855808, 1697490356184, 3122171529233, 5742568741225, 10562230626642, 19426970897100, 35731770264967, 65720971788709, 120879712950776, 222332455004452, 408933139743937, 752145307699165, 1383410902447554, 2544489349890656, 4680045560037375, 8607945812375585, 15832480722303616, 29120472094716576, 53560898629395777, 98513851446415969, 181195222170528322, 333269972246340068, 612979045863284359, 1127444240280152749, 2073693258389777176, 3814116544533214284, 7015254043203144209, 12903063846126135669, 23732434433862494162, 43650752323191774040, 80286250603180403871, 147669437360234672073, 271606440286606849984, 499562128250021925928, 918838005896863447985, 1690006574433492223897, 3108406708580377597810, 5717251288910733269692, 10515664571924603091399, 19341322569415713958901, 35574238430251050319992, 65431225571591367370292, 120346786571258131649185, 221352250573100549339469, 407130262715950048358946, 748829299860308729347600, 1377311813149359327046015, 2533271375725618104752561, 4659412488735286161146176, 8569995677610263592944752, 15762679542071167858843489, 28992087708416717612934417, 53324762928098149064722658]\n    assert candidate(5) == [0, 1, 1, 2, 4]\n\n    [/EXAMPLES]\n    \"\"\"\n    if n <= 0:\n        return []\n    elif n == 1:\n        return [0]\n    elif n == 2:\n        return [0, 1]\n    elif n == 3:\n        return [0, 1, 1]\n\n    sequence = [0, 1, 1]\n    while len(sequence) < n:\n        next_num = sum(sequence[-3:])\n        sequence.append(next_num)\n\n    return sequence\n\n", "test": "def check(candidate):\n    assert candidate(6) == [0, 1, 1, 2, 4, 7]\n    assert candidate(50) == [0, 1, 1, 2, 4, 7, 13, 24, 44, 81, 149, 274, 504, 927, 1705, 3136, 5768, 10609, 19513, 35890, 66012, 121415, 223317, 410744, 755476, 1389537, 2555757, 4700770, 8646064, 15902591, 29249425, 53798080, 98950096, 181997601, 334745777, 615693474, 1132436852, 2082876103, 3831006429, 7046319384, 12960201916, 23837527729, 43844049029, 80641778674, 148323355432, 272809183135, 501774317241, 922906855808, 1697490356184, 3122171529233]\n    assert candidate(100) == [0, 1, 1, 2, 4, 7, 13, 24, 44, 81, 149, 274, 504, 927, 1705, 3136, 5768, 10609, 19513, 35890, 66012, 121415, 223317, 410744, 755476, 1389537, 2555757, 4700770, 8646064, 15902591, 29249425, 53798080, 98950096, 181997601, 334745777, 615693474, 1132436852, 2082876103, 3831006429, 7046319384, 12960201916, 23837527729, 43844049029, 80641778674, 148323355432, 272809183135, 501774317241, 922906855808, 1697490356184, 3122171529233, 5742568741225, 10562230626642, 19426970897100, 35731770264967, 65720971788709, 120879712950776, 222332455004452, 408933139743937, 752145307699165, 1383410902447554, 2544489349890656, 4680045560037375, 8607945812375585, 15832480722303616, 29120472094716576, 53560898629395777, 98513851446415969, 181195222170528322, 333269972246340068, 612979045863284359, 1127444240280152749, 2073693258389777176, 3814116544533214284, 7015254043203144209, 12903063846126135669, 23732434433862494162, 43650752323191774040, 80286250603180403871, 147669437360234672073, 271606440286606849984, 499562128250021925928, 918838005896863447985, 1690006574433492223897, 3108406708580377597810, 5717251288910733269692, 10515664571924603091399, 19341322569415713958901, 35574238430251050319992, 65431225571591367370292, 120346786571258131649185, 221352250573100549339469, 407130262715950048358946, 748829299860308729347600, 1377311813149359327046015, 2533271375725618104752561, 4659412488735286161146176, 8569995677610263592944752, 15762679542071167858843489, 28992087708416717612934417, 53324762928098149064722658]\n    assert candidate(30) == [0, 1, 1, 2, 4, 7, 13, 24, 44, 81, 149, 274, 504, 927, 1705, 3136, 5768, 10609, 19513, 35890, 66012, 121415, 223317, 410744, 755476, 1389537, 2555757, 4700770, 8646064, 15902591]\n    assert candidate(3) == [0, 1, 1]\n    assert candidate(25) == [0, 1, 1, 2, 4, 7, 13, 24, 44, 81, 149, 274, 504, 927, 1705, 3136, 5768, 10609, 19513, 35890, 66012, 121415, 223317, 410744, 755476]\n    assert candidate(5) == [0, 1, 1, 2, 4]\n    assert candidate(4) == [0, 1, 1, 2]\n    assert candidate(20) == [0, 1, 1, 2, 4, 7, 13, 24, 44, 81, 149, 274, 504, 927, 1705, 3136, 5768, 10609, 19513, 35890]\n    assert candidate(35) == [0, 1, 1, 2, 4, 7, 13, 24, 44, 81, 149, 274, 504, 927, 1705, 3136, 5768, 10609, 19513, 35890, 66012, 121415, 223317, 410744, 755476, 1389537, 2555757, 4700770, 8646064, 15902591, 29249425, 53798080, 98950096, 181997601, 334745777]\n", "language": "python"}
{"task_id": "aa08fb5f-a5e3-4325-a9c7-861b00568305-2514116461945933938", "prompt": "The function implementation will be provided in one code block, ready to execute. I'll only use libraries imported in the problem, and will define any additional functions or classes inside the main function. My response will contain just the complete code block.\n\n```python\nfrom collections import Counter\nfrom heapq import heapify, heappush, heappop\nfrom typing import List\n\ndef schedule_tasks(tasks: List[str], cooldown: int) -> int:\n    \"\"\"\n    A computer scientist is designing a task scheduler for a new operating system. The scheduler needs to execute a series of tasks, but identical tasks require a cooldown period between executions. The goal is to determine the minimum number of units of time required to complete all tasks.\n\n    Parameters:\n    tasks (List[str]): A list of task identifiers, where each task is represented by a single uppercase letter.\n    cooldown (int): The required number of time units between two identical tasks.\n\n    Returns:\n    int: The minimum number of time units needed to complete all tasks.\n\n\n    [EXAMPLES]\n    \n    assert candidate(['A', 'A', 'B', 'B', 'C', 'C'], 1) == 6\n    assert candidate(['A', 'B', 'C', 'A', 'D', 'E'], 3) == 6\n\n    [/EXAMPLES]\n    \"\"\"\n```\n", "entry_point": "schedule_tasks", "solution": "from collections import Counter\nfrom heapq import heapify, heappush, heappop\nfrom typing import List\n\ndef schedule_tasks(tasks: List[str], cooldown: int) -> int:\n    \"\"\"\n    A computer scientist is designing a task scheduler for a new operating system. The scheduler needs to execute a series of tasks, but identical tasks require a cooldown period between executions. The goal is to determine the minimum number of units of time required to complete all tasks.\n\n    Parameters:\n    tasks (List[str]): A list of task identifiers, where each task is represented by a single uppercase letter.\n    cooldown (int): The required number of time units between two identical tasks.\n\n    Returns:\n    int: The minimum number of time units needed to complete all tasks.\n\n\n    [EXAMPLES]\n    \n    assert candidate(['A', 'A', 'B', 'B', 'C', 'C'], 1) == 6\n    assert candidate(['A', 'B', 'C', 'A', 'D', 'E'], 3) == 6\n\n    [/EXAMPLES]\n    \"\"\"\n    # Count the frequency of each task\n    task_counts = Counter(tasks)\n    \n    # Find the task with the maximum frequency\n    max_freq = max(task_counts.values())\n    \n    # Count how many tasks have the maximum frequency\n    max_freq_tasks = sum(1 for count in task_counts.values() if count == max_freq)\n    \n    # Calculate the minimum time required\n    min_time = (max_freq - 1) * (cooldown + 1) + max_freq_tasks\n    \n    # Return the maximum of the calculated minimum time and the total number of tasks\n    return max(min_time, len(tasks))\n\n", "test": "def check(candidate):\n    assert candidate(['A', 'B', 'C', 'D', 'E', 'A', 'B', 'C', 'D', 'E'], 4) == 10\n    assert candidate(['A', 'B', 'C', 'A', 'D', 'E'], 3) == 6\n    assert candidate(['A', 'A', 'B', 'B', 'C', 'C', 'D', 'D', 'E', 'E'], 2) == 10\n    assert candidate(['A', 'A', 'A', 'B', 'B', 'B', 'C', 'C', 'C'], 3) == 11\n    assert candidate(['A', 'A', 'B', 'B', 'C', 'C'], 1) == 6\n    assert candidate(['A', 'B', 'A', 'B', 'A', 'B'], 2) == 8\n    assert candidate(['A', 'B', 'C', 'D', 'A', 'B', 'C', 'D'], 3) == 8\n    assert candidate(['A', 'A', 'A', 'A', 'A', 'A'], 1) == 11\n    assert candidate(['A', 'B', 'C'], 0) == 3\n    assert candidate(['A'], 0) == 1\n", "language": "python"}
{"task_id": "593b6fa0-fbdc-4eea-a85b-ebf68c2f541d-7552554327721658751", "prompt": "My job is to implement a function that works right out of the box when executed. The function must be self-contained and use only the libraries that have been imported. If I need additional helper functions or classes, I'll nest them inside the primary function.\n\n```python\nfrom itertools import combinations\nimport itertools\nfrom math import gcd\nfrom typing import List\n\ndef calculate_orbital_resonance(planet_periods: List[float]) -> float:\n    \"\"\"\n    Calculate the strength of orbital resonance in a planetary system.\n\n    In celestial mechanics, orbital resonance occurs when two orbiting bodies exert regular, periodic gravitational influences on each other.\n    This function takes a list of orbital periods (in Earth years) for planets in a system and calculates a resonance strength factor.\n\n    The resonance strength is determined by:\n    1. Finding all possible pairs of planets\n    2. Calculating the ratio of their orbital periods (larger / smaller)\n    3. Determining how close this ratio is to a simple fraction (e.g., 2/1, 3/2, 4/3)\n    4. Summing a weighted value based on the closeness to these simple fractions\n\n    A higher output value indicates stronger resonance in the system.\n\n\n    [EXAMPLES]\n    \n    assert candidate([0.5, 1.0, 1.5, 2.0, 2.5]) == 0.625\n    assert candidate([1.0, 1.0, 1.0]) == 0.64\n\n    [/EXAMPLES]\n    \"\"\"\n```\n", "entry_point": "calculate_orbital_resonance", "solution": "from itertools import combinations\nimport itertools\nfrom math import gcd\nfrom typing import List\n\ndef calculate_orbital_resonance(planet_periods: List[float]) -> float:\n    \"\"\"\n    Calculate the strength of orbital resonance in a planetary system.\n\n    In celestial mechanics, orbital resonance occurs when two orbiting bodies exert regular, periodic gravitational influences on each other.\n    This function takes a list of orbital periods (in Earth years) for planets in a system and calculates a resonance strength factor.\n\n    The resonance strength is determined by:\n    1. Finding all possible pairs of planets\n    2. Calculating the ratio of their orbital periods (larger / smaller)\n    3. Determining how close this ratio is to a simple fraction (e.g., 2/1, 3/2, 4/3)\n    4. Summing a weighted value based on the closeness to these simple fractions\n\n    A higher output value indicates stronger resonance in the system.\n\n\n    [EXAMPLES]\n    \n    assert candidate([0.5, 1.0, 1.5, 2.0, 2.5]) == 0.625\n    assert candidate([1.0, 1.0, 1.0]) == 0.64\n\n    [/EXAMPLES]\n    \"\"\"\n    def ratio_closeness(ratio: float) -> float:\n        \"\"\"Calculate how close a ratio is to simple fractions.\"\"\"\n        simple_fractions = [2/1, 3/2, 4/3, 5/3, 5/4, 6/5]\n        closeness = min(abs(ratio - frac) for frac in simple_fractions)\n        return max(0, 1 - closeness)\n\n    def weighted_resonance(period1: float, period2: float) -> float:\n        \"\"\"Calculate weighted resonance between two planets.\"\"\"\n        ratio = max(period1, period2) / min(period1, period2)\n        closeness = ratio_closeness(ratio)\n        return closeness ** 2  # Square for more pronounced effect\n\n    # Generate all possible pairs of planets\n    planet_pairs = list(itertools.combinations(planet_periods, 2))\n\n    # Calculate the sum of weighted resonances\n    total_resonance = sum(weighted_resonance(p1, p2) for p1, p2 in planet_pairs)\n\n    # Normalize by the number of pairs\n    normalized_resonance = total_resonance / len(planet_pairs) if planet_pairs else 0\n\n    return round(normalized_resonance, 4)\n\n", "test": "def check(candidate):\n    assert candidate([0.01, 0.05, 0.25, 1.25, 6.25]) == 0.0\n    assert candidate([0.01, 0.1, 1.0, 10.0, 100.0]) == 0\n    assert candidate([0.1, 0.2, 0.4, 0.8, 1.6, 3.2, 6.4]) == 0.2857\n    assert candidate([0.33, 0.66, 0.99, 1.32, 1.65]) == 0.625\n    assert candidate([0.01, 0.1, 1.0, 10.0, 100.0]) == 0.0\n    assert candidate([1.0, 2.0, 4.0, 8.0]) == 0.5\n    assert candidate([0.5, 1.0, 1.5, 2.0, 2.5]) == 0.625\n    assert candidate([1.0, 1.0, 1.0]) == 0.64\n    assert candidate([0.01, 0.05, 0.25, 1.25, 6.25]) == 0\n    assert candidate([1.0, 1.5, 2.25, 3.375, 5.0625]) == 0.5687\n", "language": "python"}
{"task_id": "5cdd056f-8268-495c-b80c-c20dae9b7dbf7870955665421994305", "prompt": "I'll implement the requested function as a complete, executable solution in one code block. The implementation will only use libraries that are imported in the problem statement. Any additional functions or classes will be defined within the main function scope. No code will be placed outside the function definition.\n\n```python\ndef calculate_delivery_time(distance: float, traffic_level: str) -> str:\n    \"\"\"\n    A food delivery company wants to estimate delivery times based on distance and traffic conditions.\n    The company uses three traffic levels: \"light\", \"moderate\", and \"heavy\".\n    The base speed is 30 km/h, which is adjusted based on traffic:\n    - Light traffic: No change\n    - Moderate traffic: Speed reduced by 20%\n    - Heavy traffic: Speed reduced by 40%\n\n    This function calculates the estimated delivery time given the distance and traffic level.\n\n    Parameters:\n    distance (float): The distance to the delivery location in kilometers\n    traffic_level (str): The current traffic level (\"light\", \"moderate\", or \"heavy\")\n\n    Returns:\n    str: A string representation of the estimated delivery time in hours and minutes\n\n\n    [EXAMPLES]\n    \n    assert candidate(40, \"heavy\") == '2 hours and 13 minutes'\n    assert candidate(999.999, \"heavy\") == '55 hours and 33 minutes'\n\n    [/EXAMPLES]\n    \"\"\"\n```\n", "entry_point": "calculate_delivery_time", "solution": "def calculate_delivery_time(distance: float, traffic_level: str) -> str:\n    \"\"\"\n    A food delivery company wants to estimate delivery times based on distance and traffic conditions.\n    The company uses three traffic levels: \"light\", \"moderate\", and \"heavy\".\n    The base speed is 30 km/h, which is adjusted based on traffic:\n    - Light traffic: No change\n    - Moderate traffic: Speed reduced by 20%\n    - Heavy traffic: Speed reduced by 40%\n\n    This function calculates the estimated delivery time given the distance and traffic level.\n\n    Parameters:\n    distance (float): The distance to the delivery location in kilometers\n    traffic_level (str): The current traffic level (\"light\", \"moderate\", or \"heavy\")\n\n    Returns:\n    str: A string representation of the estimated delivery time in hours and minutes\n\n\n    [EXAMPLES]\n    \n    assert candidate(40, \"heavy\") == '2 hours and 13 minutes'\n    assert candidate(999.999, \"heavy\") == '55 hours and 33 minutes'\n\n    [/EXAMPLES]\n    \"\"\"\n    base_speed = 30  # km/h\n\n    # Adjust speed based on traffic level\n    if traffic_level == \"light\":\n        speed = base_speed\n    elif traffic_level == \"moderate\":\n        speed = base_speed * 0.8  # 20% reduction\n    elif traffic_level == \"heavy\":\n        speed = base_speed * 0.6  # 40% reduction\n    else:\n        raise ValueError(\"Invalid traffic level. Use 'light', 'moderate', or 'heavy'.\")\n\n    # Calculate time in hours\n    time_hours = distance / speed\n\n    # Convert to hours and minutes\n    hours = int(time_hours)\n    minutes = round((time_hours - hours) * 60)\n\n    # Handle case where minutes round up to 60\n    if minutes == 60:\n        hours += 1\n        minutes = 0\n\n    # Format the result string\n    if hours == 1:\n        hour_str = \"1 hour\"\n    else:\n        hour_str = f\"{hours} hours\"\n\n    if minutes == 1:\n        minute_str = \"1 minute\"\n    else:\n        minute_str = f\"{minutes} minutes\"\n\n    return f\"{hour_str} and {minute_str}\"\n\n", "test": "def check(candidate):\n    assert candidate(30, \"light\") == '1 hour and 0 minutes'\n    assert candidate(42.42, \"heavy\") == '2 hours and 21 minutes'\n    assert candidate(75, \"moderate\") == '3 hours and 8 minutes'\n    assert candidate(40, \"heavy\") == '2 hours and 13 minutes'\n    assert candidate(60, \"heavy\") == '3 hours and 20 minutes'\n    assert candidate(0.1, \"heavy\") == '0 hours and 0 minutes'\n    assert candidate(2, \"heavy\") == '0 hours and 7 minutes'\n    assert candidate(0.001, \"light\") == '0 hours and 0 minutes'\n    assert candidate(999.999, \"heavy\") == '55 hours and 33 minutes'\n    assert candidate(1.5, \"moderate\") == '0 hours and 4 minutes'\n", "language": "python"}
{"task_id": "73aaec6f-035f-4786-90fb-43122c87c61a1311589039652362290", "prompt": "Based on the docstring provided, I'll write the complete function implementation. I'll preserve the function name and parameters while delivering the entire solution as a single code block.\n\n```python\nfrom typing import List\n\ndef edit_distance(str1: str, str2: str) -> int:\n    \"\"\"\n    Calculate the minimum number of operations required to transform one string into another.\n    The allowed operations are:\n    1. Insert a character\n    2. Delete a character\n    3. Replace a character\n\n    Take two strings as input from the user and return the minimum number of operations needed to transform str1 into str2.\n\n\n    [EXAMPLES]\n    \n    assert candidate(\"a\", \"b\") == 1\n    assert candidate(\"kitten\", \"sitting\") == 3\n\n    [/EXAMPLES]\n    \"\"\"\n```\n", "entry_point": "edit_distance", "solution": "from typing import List\n\ndef edit_distance(str1: str, str2: str) -> int:\n    \"\"\"\n    Calculate the minimum number of operations required to transform one string into another.\n    The allowed operations are:\n    1. Insert a character\n    2. Delete a character\n    3. Replace a character\n\n    Take two strings as input from the user and return the minimum number of operations needed to transform str1 into str2.\n\n\n    [EXAMPLES]\n    \n    assert candidate(\"a\", \"b\") == 1\n    assert candidate(\"kitten\", \"sitting\") == 3\n\n    [/EXAMPLES]\n    \"\"\"\n    m, n = len(str1), len(str2)\n    \n    # Create a matrix to store the edit distances\n    dp = [[0] * (n + 1) for _ in range(m + 1)]\n    \n    # Initialize the first row and column\n    for i in range(m + 1):\n        dp[i][0] = i\n    for j in range(n + 1):\n        dp[0][j] = j\n    \n    # Fill the dp matrix\n    for i in range(1, m + 1):\n        for j in range(1, n + 1):\n            if str1[i - 1] == str2[j - 1]:\n                dp[i][j] = dp[i - 1][j - 1]\n            else:\n                dp[i][j] = 1 + min(dp[i - 1][j],      # Delete\n                                   dp[i][j - 1],      # Insert\n                                   dp[i - 1][j - 1])  # Replace\n    \n    # Return the minimum number of operations\n    return dp[m][n]\n\n", "test": "def check(candidate):\n    assert candidate(\"a\", \"b\") == 1\n    assert candidate(\"\", \"\") == 0\n    assert candidate(\"abcde\", \"edcba\") == 4\n    assert candidate(\"programming\", \"coding\") == 7\n    assert candidate(\"distance\", \"instance\") == 2\n    assert candidate(\"\", \"test\") == 4\n    assert candidate(\"test\", \"\") == 4\n    assert candidate(\"kitten\", \"sitting\") == 3\n    assert candidate(\"hello\", \"world\") == 4\n    assert candidate(\"algorithm\", \"logarithm\") == 3\n", "language": "python"}
{"task_id": "c951ae91-aa07-4e95-abfb-20e6b61b44ee-8047625189567760682", "prompt": "Using the docstring as your guide, complete the function implementation. Provide the entire solution in one code block and make sure you've considered all edge cases.\n\n```python\ndef decode_alien_message(message: str) -> str:\n    \"\"\"\n    An astronomer has intercepted a message from an alien civilization, but it's encoded.\n    The message consists of lowercase letters and digits. The aliens use a simple encoding:\n    each letter is replaced by the letter that comes after it in the alphabet (wrapping from 'z' to 'a'),\n    and each digit is replaced by the next digit (wrapping from 9 to 0).\n\n    This function decodes the alien message and returns the original text.\n\n    :param message: The encoded alien message as a string\n    :return: The decoded message as a string\n\n\n    [EXAMPLES]\n    \n    assert candidate(\"ifmmp xpsme\") == 'hello world'\n    assert candidate(\"nopqrstuvwxyzabcdefghijklm\") == 'mnopqrstuvwxyzabcdefghijkl'\n\n    [/EXAMPLES]\n    \"\"\"\n```\n", "entry_point": "decode_alien_message", "solution": "def decode_alien_message(message: str) -> str:\n    \"\"\"\n    An astronomer has intercepted a message from an alien civilization, but it's encoded.\n    The message consists of lowercase letters and digits. The aliens use a simple encoding:\n    each letter is replaced by the letter that comes after it in the alphabet (wrapping from 'z' to 'a'),\n    and each digit is replaced by the next digit (wrapping from 9 to 0).\n\n    This function decodes the alien message and returns the original text.\n\n    :param message: The encoded alien message as a string\n    :return: The decoded message as a string\n\n\n    [EXAMPLES]\n    \n    assert candidate(\"ifmmp xpsme\") == 'hello world'\n    assert candidate(\"nopqrstuvwxyzabcdefghijklm\") == 'mnopqrstuvwxyzabcdefghijkl'\n\n    [/EXAMPLES]\n    \"\"\"\n    def decode_char(char):\n        if char.isalpha():\n            return chr((ord(char) - 97 - 1) % 26 + 97)\n        elif char.isdigit():\n            return str((int(char) - 1) % 10)\n        else:\n            return char\n\n    return ''.join(decode_char(c) for c in message)\n\n", "test": "def check(candidate):\n    assert candidate(\"abcdefghijklmnopqrstuvwxyz\") == 'zabcdefghijklmnopqrstuvwxy'\n    assert candidate(\"ifmmp xpsme\") == 'hello world'\n    assert candidate(\"z\") == 'y'\n    assert candidate(\"a\") == 'z'\n    assert candidate(\"ifmmp\") == 'hello'\n    assert candidate(\"zzzzzz\") == 'yyyyyy'\n    assert candidate(\"aaabbbccc111222333\") == 'zzzaaabbb000111222'\n    assert candidate(\"az09\") == 'zy98'\n    assert candidate(\"nopqrstuvwxyzabcdefghijklm\") == 'mnopqrstuvwxyzabcdefghijkl'\n    assert candidate(\"xpsme\") == 'world'\n", "language": "python"}
{"task_id": "90df0e0d-3858-45c3-bd8d-0a5f7ba68c45-1612781069425066218", "prompt": "I need you to complete a provided function that can run as-is in a single code block. Don't include any code outside the function definition. Only use libraries that are imported in the original problem. If you need helper functions or classes, define them within the main function. Your response should contain exactly one code block.\n\n```python\nfrom typing import List, Tuple\n\ndef analyze_stock_trends(prices: List[int], window_size: int) -> List[Tuple[str, int]]:\n    \"\"\"\n    A financial analyst is developing a tool to identify trends in stock prices. Given a list of daily closing prices\n    and a window size, the function should analyze the trend for each window and classify it as \"Bullish\" (prices\n    generally increasing), \"Bearish\" (prices generally decreasing), or \"Neutral\" (no clear trend).\n\n    This function takes a list of integer stock prices and a window size as input. It returns a list of tuples,\n    where each tuple contains the trend classification (\"Bullish\", \"Bearish\", or \"Neutral\") and the starting index\n    of the window.\n\n\n    [EXAMPLES]\n    \n    assert candidate([1, 2, 3, 4, 5, 6, 7, 8, 9, 10], 5) == [('Bullish', 0), ('Bullish', 1), ('Bullish', 2), ('Bullish', 3), ('Bullish', 4), ('Bullish', 5)]\n    assert candidate([1, 2, 3, 4, 5, 4, 3, 2, 1], 3) == [('Bullish', 0), ('Bullish', 1), ('Bullish', 2), ('Neutral', 3), ('Bearish', 4), ('Bearish', 5), ('Bearish', 6)]\n\n    [/EXAMPLES]\n    \"\"\"\n```\n", "entry_point": "analyze_stock_trends", "solution": "from typing import List, Tuple\n\ndef analyze_stock_trends(prices: List[int], window_size: int) -> List[Tuple[str, int]]:\n    \"\"\"\n    A financial analyst is developing a tool to identify trends in stock prices. Given a list of daily closing prices\n    and a window size, the function should analyze the trend for each window and classify it as \"Bullish\" (prices\n    generally increasing), \"Bearish\" (prices generally decreasing), or \"Neutral\" (no clear trend).\n\n    This function takes a list of integer stock prices and a window size as input. It returns a list of tuples,\n    where each tuple contains the trend classification (\"Bullish\", \"Bearish\", or \"Neutral\") and the starting index\n    of the window.\n\n\n    [EXAMPLES]\n    \n    assert candidate([1, 2, 3, 4, 5, 6, 7, 8, 9, 10], 5) == [('Bullish', 0), ('Bullish', 1), ('Bullish', 2), ('Bullish', 3), ('Bullish', 4), ('Bullish', 5)]\n    assert candidate([1, 2, 3, 4, 5, 4, 3, 2, 1], 3) == [('Bullish', 0), ('Bullish', 1), ('Bullish', 2), ('Neutral', 3), ('Bearish', 4), ('Bearish', 5), ('Bearish', 6)]\n\n    [/EXAMPLES]\n    \"\"\"\n    def classify_trend(window: List[int]) -> str:\n        increases = sum(1 for i in range(1, len(window)) if window[i] > window[i-1])\n        decreases = sum(1 for i in range(1, len(window)) if window[i] < window[i-1])\n        \n        if increases > decreases and increases > len(window) // 2:\n            return \"Bullish\"\n        elif decreases > increases and decreases > len(window) // 2:\n            return \"Bearish\"\n        else:\n            return \"Neutral\"\n\n    result = []\n    for i in range(len(prices) - window_size + 1):\n        window = prices[i:i+window_size]\n        trend = classify_trend(window)\n        result.append((trend, i))\n\n    return result\n\n", "test": "def check(candidate):\n    assert candidate([10, 20, 30, 40, 50], 2) == [('Neutral', 0), ('Neutral', 1), ('Neutral', 2), ('Neutral', 3)]\n    assert candidate([5, 5, 5, 5, 5, 5, 5, 5, 5, 5], 3) == [('Neutral', 0), ('Neutral', 1), ('Neutral', 2), ('Neutral', 3), ('Neutral', 4), ('Neutral', 5), ('Neutral', 6), ('Neutral', 7)]\n    assert candidate([1, 10, 1, 10, 1, 10, 1, 10], 2) == [('Neutral', 0), ('Neutral', 1), ('Neutral', 2), ('Neutral', 3), ('Neutral', 4), ('Neutral', 5), ('Neutral', 6)]\n    assert candidate([1, 2, 3, 4, 5, 6, 7, 8, 9, 10], 5) == [('Bullish', 0), ('Bullish', 1), ('Bullish', 2), ('Bullish', 3), ('Bullish', 4), ('Bullish', 5)]\n    assert candidate([50, 40, 30, 20, 10], 2) == [('Neutral', 0), ('Neutral', 1), ('Neutral', 2), ('Neutral', 3)]\n    assert candidate([1, 2, 3, 4, 5, 4, 3, 2, 1], 3) == [('Bullish', 0), ('Bullish', 1), ('Bullish', 2), ('Neutral', 3), ('Bearish', 4), ('Bearish', 5), ('Bearish', 6)]\n    assert candidate([100, 102, 105, 103, 101, 98, 100, 105], 3) == [('Bullish', 0), ('Neutral', 1), ('Bearish', 2), ('Bearish', 3), ('Neutral', 4), ('Bullish', 5)]\n    assert candidate([100, 90, 80, 90, 100], 3) == [('Bearish', 0), ('Neutral', 1), ('Bullish', 2)]\n    assert candidate([1, 1, 1, 1, 1], 3) == [('Neutral', 0), ('Neutral', 1), ('Neutral', 2)]\n    assert candidate([50, 55, 60, 55, 50, 45, 40], 4) == [('Neutral', 0), ('Neutral', 1), ('Bearish', 2), ('Bearish', 3)]\n", "language": "python"}
{"task_id": "88e68f1e-f024-4997-82bb-541910055db66480844248613307155", "prompt": "Provide a complete implementation of the function described in the problem. Your solution should be contained entirely within a single code block that can be executed as is. Any helper functions or classes must be defined inside the main function. Only use libraries that are already imported in the problem statement. Present just the function code without additional explanations.\n\n```python\nfrom typing import List\n\ndef maximize_profit(prices: List[int], k: int) -> int:\n    \"\"\"\n    An art collector wants to maximize their profit by buying and selling paintings.\n    They can make at most k transactions (a transaction is a buy followed by a sell).\n    Given a list of daily prices for a painting, determine the maximum profit that can be achieved.\n\n\n    [EXAMPLES]\n    \n    assert candidate([3,3,5,0,0,3,1,4], 3) == 8\n    assert candidate([10,20,30,40,50], 2) == 40\n\n    [/EXAMPLES]\n    \"\"\"\n```\n", "entry_point": "maximize_profit", "solution": "from typing import List\n\ndef maximize_profit(prices: List[int], k: int) -> int:\n    \"\"\"\n    An art collector wants to maximize their profit by buying and selling paintings.\n    They can make at most k transactions (a transaction is a buy followed by a sell).\n    Given a list of daily prices for a painting, determine the maximum profit that can be achieved.\n\n\n    [EXAMPLES]\n    \n    assert candidate([3,3,5,0,0,3,1,4], 3) == 8\n    assert candidate([10,20,30,40,50], 2) == 40\n\n    [/EXAMPLES]\n    \"\"\"\n    if not prices or k == 0:\n        return 0\n\n    n = len(prices)\n    \n    # If k is larger than n/2, we can make as many transactions as we want\n    if k >= n // 2:\n        return sum(max(0, prices[i] - prices[i-1]) for i in range(1, n))\n\n    # Initialize the dp table\n    dp = [[0 for _ in range(n)] for _ in range(k+1)]\n\n    for i in range(1, k+1):\n        max_diff = -prices[0]\n        for j in range(1, n):\n            dp[i][j] = max(dp[i][j-1], prices[j] + max_diff)\n            max_diff = max(max_diff, dp[i-1][j] - prices[j])\n\n    return dp[k][n-1]\n\n", "test": "def check(candidate):\n    assert candidate([3,3,5,0,0,3,1,4], 1) == 4\n    assert candidate([100,1,100,1,100], 2) == 198\n    assert candidate([1,1,1,1,1], 3) == 0\n    assert candidate([10,9,8,7,6,5,4,3,2,1], 5) == 0\n    assert candidate([1], 1) == 0\n    assert candidate([1,2,3,4,5,4,3,2,1], 4) == 4\n    assert candidate([1,2,3,2,3,4,3,4,5,4], 3) == 6\n    assert candidate([3,3,5,0,0,3,1,4], 3) == 8\n    assert candidate([1,2,1,2,1,2], 3) == 3\n    assert candidate([10,20,30,40,50], 2) == 40\n", "language": "python"}
{"task_id": "0fcb1e8c-6d03-4a7e-8d3a-aa25538ff29c8628934913459913309", "prompt": "My role is to assist with coding by completing functions that are ready to execute in code blocks. I'll strictly adhere to using only the libraries imported in the problem and will contain all code including any helper functions or classes within the given function scope. No external code will be provided.\n\n```python\nfrom collections import Counter\nfrom typing import List\n\ndef analyze_genetic_sequence(sequence: str, k: int) -> List[str]:\n    \"\"\"\n    Analyze a genetic sequence to find the most frequent k-mers (substrings of length k).\n\n    This function takes a DNA sequence and a length k, then returns the most common k-mers\n    in the sequence. It utilizes both string manipulation and dictionary data structures.\n\n    Args:\n    sequence (str): A string representing a DNA sequence (containing only A, C, G, T).\n    k (int): The length of k-mers to analyze.\n\n    Returns:\n    List[str]: A list of the most frequent k-mers in the sequence.\n\n\n    [EXAMPLES]\n    \n    assert candidate(\"ACTGACTGACTG\", 3) == ['ACT', 'CTG']\n    assert candidate(\"AAAAACCCCCAAAAACCCCCC\", 5) == ['CCCCC']\n\n    [/EXAMPLES]\n    \"\"\"\n```\n", "entry_point": "analyze_genetic_sequence", "solution": "from collections import Counter\nfrom typing import List\n\ndef analyze_genetic_sequence(sequence: str, k: int) -> List[str]:\n    \"\"\"\n    Analyze a genetic sequence to find the most frequent k-mers (substrings of length k).\n\n    This function takes a DNA sequence and a length k, then returns the most common k-mers\n    in the sequence. It utilizes both string manipulation and dictionary data structures.\n\n    Args:\n    sequence (str): A string representing a DNA sequence (containing only A, C, G, T).\n    k (int): The length of k-mers to analyze.\n\n    Returns:\n    List[str]: A list of the most frequent k-mers in the sequence.\n\n\n    [EXAMPLES]\n    \n    assert candidate(\"ACTGACTGACTG\", 3) == ['ACT', 'CTG']\n    assert candidate(\"AAAAACCCCCAAAAACCCCCC\", 5) == ['CCCCC']\n\n    [/EXAMPLES]\n    \"\"\"\n    # Check if the sequence length is less than k\n    if len(sequence) < k:\n        return []\n\n    # Generate all k-mers from the sequence\n    kmers = [sequence[i:i+k] for i in range(len(sequence) - k + 1)]\n\n    # Count the occurrences of each k-mer\n    kmer_counts = Counter(kmers)\n\n    # Find the maximum count\n    max_count = max(kmer_counts.values())\n\n    # Return all k-mers with the maximum count\n    most_frequent_kmers = [kmer for kmer, count in kmer_counts.items() if count == max_count]\n\n    return sorted(most_frequent_kmers)\n\n", "test": "def check(candidate):\n    assert candidate(\"GGGGGGGGGGGG\", 2) == ['GG']\n    assert candidate(\"ATCG\", 1) == ['A', 'C', 'G', 'T']\n    assert candidate(\"ACGTACGTACGT\", 4) == ['ACGT']\n    assert candidate(\"ATATATATATAT\", 6) == ['ATATAT']\n    assert candidate(\"AAAAAAAAAAAA\", 1) == ['A']\n    assert candidate(\"ATCGATCGATCG\", 6) == ['ATCGAT', 'CGATCG', 'TCGATC']\n    assert candidate(\"AAATTTCCCGGG\", 3) == ['AAA', 'AAT', 'ATT', 'CCC', 'CCG', 'CGG', 'GGG', 'TCC', 'TTC', 'TTT']\n    assert candidate(\"AAAAACCCCCAAAAACCCCCC\", 5) == ['CCCCC']\n    assert candidate(\"ACTGACTGACTG\", 3) == ['ACT', 'CTG']\n    assert candidate(\"ATGCATGCATGC\", 3) == ['ATG', 'TGC']\n", "language": "python"}
{"task_id": "5e3e9306-93b0-4be0-a795-a63daffa9cf4-1688872604199624750", "prompt": "Completing the following code as requested, all in one code block.\n\n```python\ndef time_dilation_calculator(velocity: float, time_elapsed: float) -> float:\n    \"\"\"\n    In the year 2150, interstellar travel has become a reality. However, the effects of time dilation\n    due to traveling at extremely high velocities have become a significant concern for space travelers.\n\n    This function calculates the time experienced by a traveler moving at high velocity relative to a\n    stationary observer, taking into account the effects of special relativity.\n\n    Parameters:\n    velocity (float): The velocity of the traveler as a fraction of the speed of light (0 < velocity < 1)\n    time_elapsed (float): The time elapsed for a stationary observer in years\n\n    Returns:\n    float: The time experienced by the traveler in years, rounded to 2 decimal places\n\n\n    [EXAMPLES]\n    \n    assert candidate(0.9, 20) == 8.72\n    assert candidate(0.5, 10) == 8.66\n\n    [/EXAMPLES]\n    \"\"\"\n```\n", "entry_point": "time_dilation_calculator", "solution": "def time_dilation_calculator(velocity: float, time_elapsed: float) -> float:\n    \"\"\"\n    In the year 2150, interstellar travel has become a reality. However, the effects of time dilation\n    due to traveling at extremely high velocities have become a significant concern for space travelers.\n\n    This function calculates the time experienced by a traveler moving at high velocity relative to a\n    stationary observer, taking into account the effects of special relativity.\n\n    Parameters:\n    velocity (float): The velocity of the traveler as a fraction of the speed of light (0 < velocity < 1)\n    time_elapsed (float): The time elapsed for a stationary observer in years\n\n    Returns:\n    float: The time experienced by the traveler in years, rounded to 2 decimal places\n\n\n    [EXAMPLES]\n    \n    assert candidate(0.9, 20) == 8.72\n    assert candidate(0.5, 10) == 8.66\n\n    [/EXAMPLES]\n    \"\"\"\n    import math\n\n    # Check if velocity is within the valid range\n    if velocity <= 0 or velocity >= 1:\n        raise ValueError(\"Velocity must be between 0 and 1 (exclusive)\")\n\n    # Calculate the Lorentz factor\n    lorentz_factor = 1 / math.sqrt(1 - velocity**2)\n\n    # Calculate the time experienced by the traveler\n    time_traveler = time_elapsed / lorentz_factor\n\n    # Round the result to 2 decimal places\n    return round(time_traveler, 2)\n\n", "test": "def check(candidate):\n    assert candidate(0.1, 5) == 4.97\n    assert candidate(0.75, 50) == 33.07\n    assert candidate(0.6, 30) == 24.0\n    assert candidate(0.85, 60) == 31.61\n    assert candidate(0.98, 500) == 99.5\n    assert candidate(0.95, 200) == 62.45\n    assert candidate(0.5, 10) == 8.66\n    assert candidate(0.9, 20) == 8.72\n    assert candidate(0.99, 100) == 14.11\n    assert candidate(0.01, 1) == 1.0\n", "language": "python"}
{"task_id": "08e2fb37-2fcb-4232-8d25-b076db592da6-6774359104858237277", "prompt": "Following the docstring description, complete the function implementation. Do not modify the function name or parameters.\n\n```python\nfrom typing import List, Tuple\nfrom itertools import permutations\nimport itertools\n\ndef optimize_factory_layout(machines: List[int], connections: List[Tuple[int, int]]) -> int:\n    \"\"\"You are tasked with optimizing the layout of a factory floor to minimize the total distance between connected machines.\n\n    The factory has N machines, numbered from 0 to N-1, which need to be arranged in a line. Some machines are connected and need to be as close as possible to each other. Your goal is to find the optimal arrangement that minimizes the sum of distances between all connected pairs of machines.\n\n    Parameters:\n    machines (List[int]): A list of machine IDs, where the index represents the current position of the machine.\n    connections (List[Tuple[int, int]]): A list of tuples, where each tuple (a, b) represents a connection between machine a and machine b.\n\n    Returns:\n    int: The minimum total distance between all connected pairs of machines.\n\n\n    [EXAMPLES]\n    \n    assert candidate([0, 1, 2, 3, 4, 5], [(0, 1), (2, 3), (4, 5)]) == 3\n    assert candidate([0, 1], [(0, 1)]) == 1\n\n    [/EXAMPLES]\n    \"\"\"\n```\n", "entry_point": "optimize_factory_layout", "solution": "from typing import List, Tuple\nfrom itertools import permutations\nimport itertools\n\ndef optimize_factory_layout(machines: List[int], connections: List[Tuple[int, int]]) -> int:\n    \"\"\"You are tasked with optimizing the layout of a factory floor to minimize the total distance between connected machines.\n\n    The factory has N machines, numbered from 0 to N-1, which need to be arranged in a line. Some machines are connected and need to be as close as possible to each other. Your goal is to find the optimal arrangement that minimizes the sum of distances between all connected pairs of machines.\n\n    Parameters:\n    machines (List[int]): A list of machine IDs, where the index represents the current position of the machine.\n    connections (List[Tuple[int, int]]): A list of tuples, where each tuple (a, b) represents a connection between machine a and machine b.\n\n    Returns:\n    int: The minimum total distance between all connected pairs of machines.\n\n\n    [EXAMPLES]\n    \n    assert candidate([0, 1, 2, 3, 4, 5], [(0, 1), (2, 3), (4, 5)]) == 3\n    assert candidate([0, 1], [(0, 1)]) == 1\n\n    [/EXAMPLES]\n    \"\"\"\n    \n    def calculate_total_distance(arrangement):\n        # Create a dictionary to store the position of each machine\n        positions = {machine: idx for idx, machine in enumerate(arrangement)}\n        \n        # Calculate the total distance\n        total_distance = 0\n        for a, b in connections:\n            total_distance += abs(positions[a] - positions[b])\n        \n        return total_distance\n\n    # Generate all possible permutations of machine arrangements\n    all_arrangements = itertools.permutations(machines)\n    \n    # Find the arrangement with the minimum total distance\n    min_distance = float('inf')\n    for arrangement in all_arrangements:\n        distance = calculate_total_distance(arrangement)\n        min_distance = min(min_distance, distance)\n    \n    return min_distance\n\n", "test": "def check(candidate):\n    assert candidate([0, 1, 2, 3], [(0, 2), (1, 3)]) == 2\n    assert candidate([0, 1], [(0, 1)]) == 1\n    assert candidate([0, 1, 2, 3, 4, 5, 6, 7], [(0, 7), (1, 6), (2, 5), (3, 4)]) == 4\n    assert candidate([0, 1, 2, 3, 4, 5], [(0, 1), (2, 3), (4, 5)]) == 3\n    assert candidate([0, 1, 2, 3, 4], [(0, 1), (0, 2), (0, 3), (0, 4)]) == 6\n    assert candidate([0, 1, 2], [(0, 1), (1, 2)]) == 2\n    assert candidate([0, 1, 2, 3, 4, 5], [(0, 5), (1, 4), (2, 3), (0, 2), (1, 3), (4, 5)]) == 10\n    assert candidate([0, 1, 2, 3, 4, 5], [(0, 1), (1, 2), (2, 3), (3, 4), (4, 5), (0, 5)]) == 10\n    assert candidate([0, 1, 2, 3, 4, 5, 6], [(0, 6), (1, 5), (2, 4), (3, 3)]) == 3\n    assert candidate([0, 1, 2, 3], [(0, 1), (1, 2), (2, 3)]) == 3\n", "language": "python"}
{"task_id": "998468d2-a595-4271-aea5-429be6158ce6-3400134046325416402", "prompt": "I'll write the complete function implementation according to the docstring specifications. The solution will be in a single code block with the function name and arguments kept unchanged.\n\n```python\nfrom typing import List\n\ndef optimize_solar_panels(roof: List[List[int]]) -> int:\n    \"\"\"\n    A solar energy company is planning to install solar panels on a uniquely shaped roof. \n    The roof is represented as a grid where each cell can either be empty (0) or have an obstacle (1).\n\n    Solar panels can only be installed on empty cells, and for maximum efficiency, \n    they should be installed in rectangular shapes. The goal is to find the area of the largest \n    rectangular region of empty cells where solar panels can be installed.\n\n    Args:\n    roof (List[List[int]]): A 2D grid representing the roof, where 0 is an empty cell and 1 is an obstacle.\n\n    Returns:\n    int: The area of the largest rectangular region of empty cells.\n\n\n    [EXAMPLES]\n    \n    assert candidate([[0,1],[1,0]]) == 1\n    assert candidate([[1,0,1,0,1],[0,1,0,1,0],[1,0,1,0,1],[0,1,0,1,0],[1,0,1,0,1]]) == 1\n\n    [/EXAMPLES]\n    \"\"\"\n```\n", "entry_point": "optimize_solar_panels", "solution": "from typing import List\n\ndef optimize_solar_panels(roof: List[List[int]]) -> int:\n    \"\"\"\n    A solar energy company is planning to install solar panels on a uniquely shaped roof. \n    The roof is represented as a grid where each cell can either be empty (0) or have an obstacle (1).\n\n    Solar panels can only be installed on empty cells, and for maximum efficiency, \n    they should be installed in rectangular shapes. The goal is to find the area of the largest \n    rectangular region of empty cells where solar panels can be installed.\n\n    Args:\n    roof (List[List[int]]): A 2D grid representing the roof, where 0 is an empty cell and 1 is an obstacle.\n\n    Returns:\n    int: The area of the largest rectangular region of empty cells.\n\n\n    [EXAMPLES]\n    \n    assert candidate([[0,1],[1,0]]) == 1\n    assert candidate([[1,0,1,0,1],[0,1,0,1,0],[1,0,1,0,1],[0,1,0,1,0],[1,0,1,0,1]]) == 1\n\n    [/EXAMPLES]\n    \"\"\"\n    if not roof or not roof[0]:\n        return 0\n\n    rows, cols = len(roof), len(roof[0])\n    heights = [0] * cols\n    max_area = 0\n\n    for row in range(rows):\n        # Update heights\n        for col in range(cols):\n            if roof[row][col] == 0:\n                heights[col] += 1\n            else:\n                heights[col] = 0\n\n        # Calculate max area for current row\n        stack = []\n        for i, h in enumerate(heights + [0]):\n            start = i\n            while stack and stack[-1][1] > h:\n                index, height = stack.pop()\n                max_area = max(max_area, height * (i - index))\n                start = index\n            stack.append((start, h))\n\n    return max_area\n\n", "test": "def check(candidate):\n    assert candidate([[1,1,1,1,1,1],[1,0,0,0,0,1],[1,0,0,0,0,1],[1,0,0,0,0,1],[1,1,1,1,1,1]]) == 12\n    assert candidate([[0,0,0,0,0,0],[0,1,1,1,1,0],[0,1,0,0,1,0],[0,1,0,0,1,0],[0,1,1,1,1,0],[0,0,0,0,0,0]]) == 6\n    assert candidate([[1,0,1,0,1],[0,1,0,1,0],[1,0,1,0,1],[0,1,0,1,0],[1,0,1,0,1],[0,1,0,1,0]]) == 1\n    assert candidate([[0,0,0,0,0],[0,0,0,0,0],[0,0,0,0,0],[0,0,0,0,0],[0,0,0,0,0]]) == 25\n    assert candidate([[1,0,1,0,1],[0,1,0,1,0],[1,0,1,0,1],[0,1,0,1,0],[1,0,1,0,1]]) == 1\n    assert candidate([[1,1,1],[1,1,1],[1,1,1]]) == 0\n    assert candidate([[0,0,0,0,0],[0,1,1,1,0],[0,1,0,1,0],[0,1,1,1,0],[0,0,0,0,0]]) == 5\n    assert candidate([[1,1],[1,1]]) == 0\n    assert candidate([[1]]) == 0\n    assert candidate([[0,1],[1,0]]) == 1\n", "language": "python"}
{"task_id": "9d1b19a6-b404-466e-8dc3-d00d5c788150-75045241285457148", "prompt": "I need you to complete a function that is executable as-is in a single code block. Don't include any code outside of the function. Stick to using only libraries that are imported in the problem statement. If you need additional functions or classes, define them within the main function. Provide your solution in one code block only.\n\n```python\ndef edit_distance(word1: str, word2: str) -> int:\n    \"\"\"\n    In DNA sequence analysis, scientists often need to determine how similar two sequences are.\n    One way to measure this is by calculating the minimum number of operations required to transform one sequence into another.\n\n    Given two strings word1 and word2, return the minimum number of operations required to convert word1 to word2.\n    The allowed operations are: insert a character, delete a character, or replace a character.\n\n    This function uses dynamic programming to calculate the edit distance between two strings.\n\n\n    [EXAMPLES]\n    \n    assert candidate(\"GGACTGA\", \"GATTACA\") == 4\n    assert candidate(\"horse\", \"ros\") == 3\n\n    [/EXAMPLES]\n    \"\"\"\n```\n", "entry_point": "edit_distance", "solution": "def edit_distance(word1: str, word2: str) -> int:\n    \"\"\"\n    In DNA sequence analysis, scientists often need to determine how similar two sequences are.\n    One way to measure this is by calculating the minimum number of operations required to transform one sequence into another.\n\n    Given two strings word1 and word2, return the minimum number of operations required to convert word1 to word2.\n    The allowed operations are: insert a character, delete a character, or replace a character.\n\n    This function uses dynamic programming to calculate the edit distance between two strings.\n\n\n    [EXAMPLES]\n    \n    assert candidate(\"GGACTGA\", \"GATTACA\") == 4\n    assert candidate(\"horse\", \"ros\") == 3\n\n    [/EXAMPLES]\n    \"\"\"\n    m, n = len(word1), len(word2)\n    \n    # Create a matrix to store the edit distances\n    dp = [[0] * (n + 1) for _ in range(m + 1)]\n    \n    # Initialize the first row and column\n    for i in range(m + 1):\n        dp[i][0] = i\n    for j in range(n + 1):\n        dp[0][j] = j\n    \n    # Fill the matrix\n    for i in range(1, m + 1):\n        for j in range(1, n + 1):\n            if word1[i-1] == word2[j-1]:\n                dp[i][j] = dp[i-1][j-1]\n            else:\n                dp[i][j] = min(dp[i-1][j],      # deletion\n                               dp[i][j-1],      # insertion\n                               dp[i-1][j-1]     # substitution\n                              ) + 1\n    \n    # Return the edit distance\n    return dp[m][n]\n\n", "test": "def check(candidate):\n    assert candidate(\"saturday\", \"sunday\") == 3\n    assert candidate(\"ThisIsALongStringWithNoSpaces\", \"ThisIsALongStringWithNoSpacz\") == 2\n    assert candidate(\"intention\", \"execution\") == 5\n    assert candidate(\"ATGCATGC\", \"ATGGATGC\") == 1\n    assert candidate(\"\", \"\") == 0\n    assert candidate(\"GGACTGA\", \"GATTACA\") == 4\n    assert candidate(\"hello\", \"world\") == 4\n    assert candidate(\"horse\", \"ros\") == 3\n    assert candidate(\"DNA\", \"RNA\") == 1\n    assert candidate(\"kitten\", \"sitting\") == 3\n", "language": "python"}
{"task_id": "03f769de-6f70-4647-b658-e78dbb8b9b0c4584781292546893417", "prompt": "Based on the provided docstring, implement the remaining function code. Place your entire solution in a single code block. Don't forget to account for any edge cases that might arise.\n\n```python\nfrom typing import List\n\ndef calculate_leap_years(start_year: int, end_year: int) -> List[int]:\n    \"\"\"\n    Calculate all leap years within a given range of years.\n\n    This function determines which years between the start and end years (inclusive)\n    are leap years. It's useful for calendar systems, date calculations, and\n    historical research.\n\n\n    [EXAMPLES]\n    \n    assert candidate(1999, 2001) == [2000]\n    assert candidate(1600, 1700) == [1600, 1604, 1608, 1612, 1616, 1620, 1624, 1628, 1632, 1636, 1640, 1644, 1648, 1652, 1656, 1660, 1664, 1668, 1672, 1676, 1680, 1684, 1688, 1692, 1696]\n\n    [/EXAMPLES]\n    \"\"\"\n```\n", "entry_point": "calculate_leap_years", "solution": "from typing import List\n\ndef calculate_leap_years(start_year: int, end_year: int) -> List[int]:\n    \"\"\"\n    Calculate all leap years within a given range of years.\n\n    This function determines which years between the start and end years (inclusive)\n    are leap years. It's useful for calendar systems, date calculations, and\n    historical research.\n\n\n    [EXAMPLES]\n    \n    assert candidate(1999, 2001) == [2000]\n    assert candidate(1600, 1700) == [1600, 1604, 1608, 1612, 1616, 1620, 1624, 1628, 1632, 1636, 1640, 1644, 1648, 1652, 1656, 1660, 1664, 1668, 1672, 1676, 1680, 1684, 1688, 1692, 1696]\n\n    [/EXAMPLES]\n    \"\"\"\n    def is_leap_year(year: int) -> bool:\n        \"\"\"\n        Determine if a given year is a leap year.\n        \"\"\"\n        return year % 4 == 0 and (year % 100 != 0 or year % 400 == 0)\n\n    leap_years = []\n    for year in range(start_year, end_year + 1):\n        if is_leap_year(year):\n            leap_years.append(year)\n    \n    return leap_years\n\n", "test": "def check(candidate):\n    assert candidate(9999, 10000) == [10000]\n    assert candidate(1600, 1700) == [1600, 1604, 1608, 1612, 1616, 1620, 1624, 1628, 1632, 1636, 1640, 1644, 1648, 1652, 1656, 1660, 1664, 1668, 1672, 1676, 1680, 1684, 1688, 1692, 1696]\n    assert candidate(1, 2023) == [4, 8, 12, 16, 20, 24, 28, 32, 36, 40, 44, 48, 52, 56, 60, 64, 68, 72, 76, 80, 84, 88, 92, 96, 104, 108, 112, 116, 120, 124, 128, 132, 136, 140, 144, 148, 152, 156, 160, 164, 168, 172, 176, 180, 184, 188, 192, 196, 204, 208, 212, 216, 220, 224, 228, 232, 236, 240, 244, 248, 252, 256, 260, 264, 268, 272, 276, 280, 284, 288, 292, 296, 304, 308, 312, 316, 320, 324, 328, 332, 336, 340, 344, 348, 352, 356, 360, 364, 368, 372, 376, 380, 384, 388, 392, 396, 400, 404, 408, 412, 416, 420, 424, 428, 432, 436, 440, 444, 448, 452, 456, 460, 464, 468, 472, 476, 480, 484, 488, 492, 496, 504, 508, 512, 516, 520, 524, 528, 532, 536, 540, 544, 548, 552, 556, 560, 564, 568, 572, 576, 580, 584, 588, 592, 596, 604, 608, 612, 616, 620, 624, 628, 632, 636, 640, 644, 648, 652, 656, 660, 664, 668, 672, 676, 680, 684, 688, 692, 696, 704, 708, 712, 716, 720, 724, 728, 732, 736, 740, 744, 748, 752, 756, 760, 764, 768, 772, 776, 780, 784, 788, 792, 796, 800, 804, 808, 812, 816, 820, 824, 828, 832, 836, 840, 844, 848, 852, 856, 860, 864, 868, 872, 876, 880, 884, 888, 892, 896, 904, 908, 912, 916, 920, 924, 928, 932, 936, 940, 944, 948, 952, 956, 960, 964, 968, 972, 976, 980, 984, 988, 992, 996, 1004, 1008, 1012, 1016, 1020, 1024, 1028, 1032, 1036, 1040, 1044, 1048, 1052, 1056, 1060, 1064, 1068, 1072, 1076, 1080, 1084, 1088, 1092, 1096, 1104, 1108, 1112, 1116, 1120, 1124, 1128, 1132, 1136, 1140, 1144, 1148, 1152, 1156, 1160, 1164, 1168, 1172, 1176, 1180, 1184, 1188, 1192, 1196, 1200, 1204, 1208, 1212, 1216, 1220, 1224, 1228, 1232, 1236, 1240, 1244, 1248, 1252, 1256, 1260, 1264, 1268, 1272, 1276, 1280, 1284, 1288, 1292, 1296, 1304, 1308, 1312, 1316, 1320, 1324, 1328, 1332, 1336, 1340, 1344, 1348, 1352, 1356, 1360, 1364, 1368, 1372, 1376, 1380, 1384, 1388, 1392, 1396, 1404, 1408, 1412, 1416, 1420, 1424, 1428, 1432, 1436, 1440, 1444, 1448, 1452, 1456, 1460, 1464, 1468, 1472, 1476, 1480, 1484, 1488, 1492, 1496, 1504, 1508, 1512, 1516, 1520, 1524, 1528, 1532, 1536, 1540, 1544, 1548, 1552, 1556, 1560, 1564, 1568, 1572, 1576, 1580, 1584, 1588, 1592, 1596, 1600, 1604, 1608, 1612, 1616, 1620, 1624, 1628, 1632, 1636, 1640, 1644, 1648, 1652, 1656, 1660, 1664, 1668, 1672, 1676, 1680, 1684, 1688, 1692, 1696, 1704, 1708, 1712, 1716, 1720, 1724, 1728, 1732, 1736, 1740, 1744, 1748, 1752, 1756, 1760, 1764, 1768, 1772, 1776, 1780, 1784, 1788, 1792, 1796, 1804, 1808, 1812, 1816, 1820, 1824, 1828, 1832, 1836, 1840, 1844, 1848, 1852, 1856, 1860, 1864, 1868, 1872, 1876, 1880, 1884, 1888, 1892, 1896, 1904, 1908, 1912, 1916, 1920, 1924, 1928, 1932, 1936, 1940, 1944, 1948, 1952, 1956, 1960, 1964, 1968, 1972, 1976, 1980, 1984, 1988, 1992, 1996, 2000, 2004, 2008, 2012, 2016, 2020]\n    assert candidate(1900, 2100) == [1904, 1908, 1912, 1916, 1920, 1924, 1928, 1932, 1936, 1940, 1944, 1948, 1952, 1956, 1960, 1964, 1968, 1972, 1976, 1980, 1984, 1988, 1992, 1996, 2000, 2004, 2008, 2012, 2016, 2020, 2024, 2028, 2032, 2036, 2040, 2044, 2048, 2052, 2056, 2060, 2064, 2068, 2072, 2076, 2080, 2084, 2088, 2092, 2096]\n    assert candidate(9996, 10000) == [9996, 10000]\n    assert candidate(2022, 2030) == [2024, 2028]\n    assert candidate(1500, 1600) == [1504, 1508, 1512, 1516, 1520, 1524, 1528, 1532, 1536, 1540, 1544, 1548, 1552, 1556, 1560, 1564, 1568, 1572, 1576, 1580, 1584, 1588, 1592, 1596, 1600]\n    assert candidate(1999, 2001) == [2000]\n    assert candidate(1896, 1904) == [1896, 1904]\n    assert candidate(1, 1) == []\n", "language": "python"}
{"task_id": "3c38bf85-2040-47f5-8aa2-89337774deb5-6358058260285469033", "prompt": "I'd be happy to complete the code for you. Please share what you have so far, and I'll fill in the missing parts.\n\n```python\nfrom typing import List\n\ndef find_magical_indices(spells: List[int]) -> List[int]:\n    \"\"\"\n    In a magical library, there's a shelf of spell books. Each book has a magical power level,\n    represented by an integer. A book is considered \"magical\" if its power level is equal to the\n    number of books to its right that have a lower or equal power level.\n\n    Given a list of integers representing the power levels of the books from left to right,\n    return a list of indices of all the magical books in ascending order.\n\n\n    [EXAMPLES]\n    \n    assert candidate([5, 4, 3, 2, 1, 0, 0, 0, 0, 0]) == [9]\n    assert candidate([1000000, 999999, 999998, 999997, 999996]) == []\n\n    [/EXAMPLES]\n    \"\"\"\n```\n", "entry_point": "find_magical_indices", "solution": "from typing import List\n\ndef find_magical_indices(spells: List[int]) -> List[int]:\n    \"\"\"\n    In a magical library, there's a shelf of spell books. Each book has a magical power level,\n    represented by an integer. A book is considered \"magical\" if its power level is equal to the\n    number of books to its right that have a lower or equal power level.\n\n    Given a list of integers representing the power levels of the books from left to right,\n    return a list of indices of all the magical books in ascending order.\n\n\n    [EXAMPLES]\n    \n    assert candidate([5, 4, 3, 2, 1, 0, 0, 0, 0, 0]) == [9]\n    assert candidate([1000000, 999999, 999998, 999997, 999996]) == []\n\n    [/EXAMPLES]\n    \"\"\"\n    n = len(spells)\n    magical_indices = []\n    \n    for i in range(n):\n        magical_count = 0\n        for j in range(i + 1, n):\n            if spells[j] <= spells[i]:\n                magical_count += 1\n        \n        if magical_count == spells[i]:\n            magical_indices.append(i)\n    \n    return magical_indices\n\n", "test": "def check(candidate):\n    assert candidate([10, 0, 0, 0]) == [3]\n    assert candidate([1, 10, 1, 10, 1]) == [2]\n    assert candidate([1, 2, 1, 2, 1]) == [2]\n    assert candidate([1, 2, 3, 4, 5, 4, 3, 2, 1]) == [0, 1, 2, 3]\n    assert candidate([1000000, 999999, 999998, 999997, 999996]) == []\n    assert candidate([3, 1, 2, 1]) == [0, 1]\n    assert candidate([0, 1, 0, 1, 0]) == [3, 4]\n    assert candidate([2, 2, 2, 2]) == [1]\n    assert candidate([5, 4, 3, 2, 1, 0, 0, 0, 0, 0]) == [9]\n    assert candidate([100, 99, 98, 97, 96]) == []\n", "language": "python"}
{"task_id": "bb5a8049-209d-4205-b75f-153664d78b4d8988160711844733034", "prompt": "As your coding helper, I'll complete the function you provide so it's ready for execution. I'll work within the boundaries of the given function, only use libraries that are already imported, and include any necessary helper functions or classes inside the main function.\n\n```python\nimport heapq\nfrom typing import List\n\ndef minimum_cost_rope(rope_lengths: List[int]) -> int:\n    \"\"\"\n    In a rope manufacturing facility, there's a need to join smaller ropes to form longer ones.\n    The cost of joining two ropes is equal to the sum of their lengths. This function calculates\n    the minimum cost of joining all the ropes into a single rope.\n    \n\n    [EXAMPLES]\n    \n    assert candidate([1, 1]) == 2\n    assert candidate([100, 1, 1]) == 104\n\n    [/EXAMPLES]\n    \"\"\"\n```\n", "entry_point": "minimum_cost_rope", "solution": "import heapq\nfrom typing import List\n\ndef minimum_cost_rope(rope_lengths: List[int]) -> int:\n    \"\"\"\n    In a rope manufacturing facility, there's a need to join smaller ropes to form longer ones.\n    The cost of joining two ropes is equal to the sum of their lengths. This function calculates\n    the minimum cost of joining all the ropes into a single rope.\n    \n\n    [EXAMPLES]\n    \n    assert candidate([1, 1]) == 2\n    assert candidate([100, 1, 1]) == 104\n\n    [/EXAMPLES]\n    \"\"\"\n    # Convert the input list into a min heap\n    heapq.heapify(rope_lengths)\n    \n    total_cost = 0\n    \n    # Continue until there's only one rope left\n    while len(rope_lengths) > 1:\n        # Extract the two shortest ropes\n        first = heapq.heappop(rope_lengths)\n        second = heapq.heappop(rope_lengths)\n        \n        # Calculate the cost of joining these two ropes\n        cost = first + second\n        \n        # Add the cost to the total\n        total_cost += cost\n        \n        # Add the new rope back to the heap\n        heapq.heappush(rope_lengths, cost)\n    \n    return total_cost\n\n", "test": "def check(candidate):\n    assert candidate([5, 4, 3, 2, 1]) == 33\n    assert candidate([4, 3, 2, 6]) == 29\n    assert candidate([2, 4, 6, 8, 10, 12, 14, 16, 18, 20]) == 346\n    assert candidate([7, 9, 11, 13, 15]) == 126\n    assert candidate([100, 200, 300, 400, 500]) == 3300\n    assert candidate([100, 1, 1]) == 104\n    assert candidate([1, 1]) == 2\n    assert candidate([10, 10, 10]) == 50\n    assert candidate([50, 40, 30, 20, 10]) == 330\n    assert candidate([1, 2, 3, 4, 5, 6, 7, 8, 9, 10]) == 173\n", "language": "python"}
{"task_id": "400fe2b3-dfb8-47a9-a4e2-6a68eca3dc025163346677541607422", "prompt": "Complete this function according to its documented specifications. Present your entire implementation in one code block.\n\n```python\nfrom typing import List\n\ndef calculate_spiral_sum(matrix: List[List[int]]) -> int:\n    \"\"\"\n    In a secret government facility, there's a square room with a peculiar floor tiling pattern represented as a matrix.\n    Each tile has a number etched on it. Your task is to calculate the sum of these numbers when traversed in a clockwise spiral pattern,\n    starting from the outer edge and moving inwards.\n\n    This function takes a square matrix as input and returns the sum of elements traversed in a spiral order.\n\n\n    [EXAMPLES]\n    \n    assert candidate([[99, 99], [99, 99]]) == 396\n    assert candidate([[10, 20], [30, 40]]) == 100\n\n    [/EXAMPLES]\n    \"\"\"\n```\n", "entry_point": "calculate_spiral_sum", "solution": "from typing import List\n\ndef calculate_spiral_sum(matrix: List[List[int]]) -> int:\n    \"\"\"\n    In a secret government facility, there's a square room with a peculiar floor tiling pattern represented as a matrix.\n    Each tile has a number etched on it. Your task is to calculate the sum of these numbers when traversed in a clockwise spiral pattern,\n    starting from the outer edge and moving inwards.\n\n    This function takes a square matrix as input and returns the sum of elements traversed in a spiral order.\n\n\n    [EXAMPLES]\n    \n    assert candidate([[99, 99], [99, 99]]) == 396\n    assert candidate([[10, 20], [30, 40]]) == 100\n\n    [/EXAMPLES]\n    \"\"\"\n    if not matrix or not matrix[0]:\n        return 0\n\n    n = len(matrix)\n    total_sum = 0\n    top, bottom, left, right = 0, n - 1, 0, n - 1\n\n    while top <= bottom and left <= right:\n        # Traverse top row\n        for i in range(left, right + 1):\n            total_sum += matrix[top][i]\n        top += 1\n\n        # Traverse right column\n        for i in range(top, bottom + 1):\n            total_sum += matrix[i][right]\n        right -= 1\n\n        if top <= bottom:\n            # Traverse bottom row\n            for i in range(right, left - 1, -1):\n                total_sum += matrix[bottom][i]\n            bottom -= 1\n\n        if left <= right:\n            # Traverse left column\n            for i in range(bottom, top - 1, -1):\n                total_sum += matrix[i][left]\n            left += 1\n\n    return total_sum\n\n", "test": "def check(candidate):\n    assert candidate([[100]]) == 100\n    assert candidate([[0, 1, 0], [1, 0, 1], [0, 1, 0]]) == 4\n    assert candidate([[1, 2, 3], [4, 5, 6], [7, 8, 9]]) == 45\n    assert candidate([[5, 5, 5], [5, 5, 5], [5, 5, 5]]) == 45\n    assert candidate([[1, 2], [3, 4]]) == 10\n    assert candidate([[1, 1, 1, 1], [1, 2, 2, 1], [1, 2, 2, 1], [1, 1, 1, 1]]) == 20\n    assert candidate([[1, 2, 3, 4], [12, 13, 14, 5], [11, 16, 15, 6], [10, 9, 8, 7]]) == 136\n    assert candidate([[10, 20], [30, 40]]) == 100\n    assert candidate([[99, 99], [99, 99]]) == 396\n    assert candidate([[0]]) == 0\n", "language": "python"}
{"task_id": "a585e093-76f0-47be-933d-b3c0b74b04f12823062318654591473", "prompt": "Create a function that is ready to execute as-is within a single code block. Do not include any code outside the function definition. Only use libraries that are already imported in the problem statement. Define any helper functions or classes inside the main function itself. Provide exactly one code block in your response.\n\n```python\nfrom collections import defaultdict, deque\nfrom typing import List\nfrom collections import deque\n\ndef optimize_network_flow(nodes: int, edges: List[List[int]], capacities: List[int]) -> int:\n    \"\"\"\n    A telecommunications company wants to optimize the flow of data through their network.\n    Given a network represented as a directed graph, calculate the maximum flow from the source\n    node (0) to the sink node (nodes - 1).\n\n    Args:\n    nodes (int): The number of nodes in the network.\n    edges (List[List[int]]): A list of edges, where each edge is represented as [from_node, to_node].\n    capacities (List[int]): A list of capacities corresponding to each edge.\n\n    Returns:\n    int: The maximum flow that can be achieved through the network.\n\n\n    [EXAMPLES]\n    \n    assert candidate(4, [[0,1], [0,2], [1,2], [1,3], [2,3]], [100, 100, 1, 100, 100]) == 200\n    assert candidate(3, [[0,1], [1,2]], [10, 5]) == 5\n\n    [/EXAMPLES]\n    \"\"\"\n```\n", "entry_point": "optimize_network_flow", "solution": "from collections import defaultdict, deque\nfrom typing import List\nfrom collections import deque\n\ndef optimize_network_flow(nodes: int, edges: List[List[int]], capacities: List[int]) -> int:\n    \"\"\"\n    A telecommunications company wants to optimize the flow of data through their network.\n    Given a network represented as a directed graph, calculate the maximum flow from the source\n    node (0) to the sink node (nodes - 1).\n\n    Args:\n    nodes (int): The number of nodes in the network.\n    edges (List[List[int]]): A list of edges, where each edge is represented as [from_node, to_node].\n    capacities (List[int]): A list of capacities corresponding to each edge.\n\n    Returns:\n    int: The maximum flow that can be achieved through the network.\n\n\n    [EXAMPLES]\n    \n    assert candidate(4, [[0,1], [0,2], [1,2], [1,3], [2,3]], [100, 100, 1, 100, 100]) == 200\n    assert candidate(3, [[0,1], [1,2]], [10, 5]) == 5\n\n    [/EXAMPLES]\n    \"\"\"\n    def bfs(graph, source, sink, parent):\n        visited = [False] * nodes\n        queue = deque([source])\n        visited[source] = True\n        \n        while queue:\n            u = queue.popleft()\n            for v, cap in enumerate(graph[u]):\n                if not visited[v] and cap > 0:\n                    queue.append(v)\n                    visited[v] = True\n                    parent[v] = u\n                    if v == sink:\n                        return True\n        return False\n\n    def ford_fulkerson(graph, source, sink):\n        parent = [-1] * nodes\n        max_flow = 0\n\n        while bfs(graph, source, sink, parent):\n            path_flow = float('inf')\n            s = sink\n            while s != source:\n                path_flow = min(path_flow, graph[parent[s]][s])\n                s = parent[s]\n\n            max_flow += path_flow\n\n            v = sink\n            while v != source:\n                u = parent[v]\n                graph[u][v] -= path_flow\n                graph[v][u] += path_flow\n                v = parent[v]\n\n        return max_flow\n\n    # Create residual graph\n    graph = [[0] * nodes for _ in range(nodes)]\n    for (u, v), cap in zip(edges, capacities):\n        graph[u][v] = cap\n\n    # Calculate maximum flow\n    return ford_fulkerson(graph, 0, nodes - 1)\n\n", "test": "def check(candidate):\n    assert candidate(6, [[0,1], [0,2], [1,3], [2,3], [3,4], [4,5]], [10, 10, 5, 5, 15, 20]) == 10\n    assert candidate(3, [[0,1], [1,2]], [10, 5]) == 5\n    assert candidate(5, [[0,1], [0,2], [1,3], [2,3], [3,4]], [100, 100, 1, 1, 100]) == 2\n    assert candidate(3, [[0,1], [0,2], [1,2]], [0, 0, 0]) == 0\n    assert candidate(6, [[0,1], [0,2], [1,3], [2,3], [3,4], [3,5], [4,5]], [10, 10, 10, 10, 5, 5, 5]) == 10\n    assert candidate(5, [[0,1], [0,2], [1,3], [2,3], [3,4]], [1, 2, 3, 4, 5]) == 3\n    assert candidate(3, [[0,1], [1,2]], [10, 10]) == 10\n    assert candidate(3, [[0,1], [0,2], [1,2]], [1, 1, 1]) == 2\n    assert candidate(2, [[0,1]], [5]) == 5\n    assert candidate(4, [[0,1], [0,2], [1,2], [1,3], [2,3]], [100, 100, 1, 100, 100]) == 200\n", "language": "python"}
{"task_id": "38f2efc3-eced-46c5-87b5-e497107a967a-3834580025906301485", "prompt": "Based on the doc string, I'll implement the function in a single code block. Please provide the function signature and the doc string so I can complete the implementation correctly.\n\n```python\ndef balanced_brackets(expression: str) -> bool:\n    \"\"\"\n    In the world of programming and mathematical expressions, this function checks\n    if a given string of brackets is balanced.\n\n    The function takes a string containing only brackets ('(', ')', '{', '}', '[', ']')\n    as input and returns True if the brackets are balanced, and False otherwise.\n\n    A string of brackets is considered balanced if:\n    - It is empty\n    - It consists of opening and closing brackets of the same type\n    - The brackets are properly nested\n\n\n    [EXAMPLES]\n    \n    assert candidate(\"([{}()])\") == True\n    assert candidate(\"()[]{}\") == True\n\n    [/EXAMPLES]\n    \"\"\"\n```\n", "entry_point": "balanced_brackets", "solution": "def balanced_brackets(expression: str) -> bool:\n    \"\"\"\n    In the world of programming and mathematical expressions, this function checks\n    if a given string of brackets is balanced.\n\n    The function takes a string containing only brackets ('(', ')', '{', '}', '[', ']')\n    as input and returns True if the brackets are balanced, and False otherwise.\n\n    A string of brackets is considered balanced if:\n    - It is empty\n    - It consists of opening and closing brackets of the same type\n    - The brackets are properly nested\n\n\n    [EXAMPLES]\n    \n    assert candidate(\"([{}()])\") == True\n    assert candidate(\"()[]{}\") == True\n\n    [/EXAMPLES]\n    \"\"\"\n    stack = []\n    bracket_pairs = {')': '(', '}': '{', ']': '['}\n    \n    for char in expression:\n        if char in '({[':\n            stack.append(char)\n        elif char in ')}]':\n            if not stack or stack.pop() != bracket_pairs[char]:\n                return False\n    \n    return len(stack) == 0\n\n", "test": "def check(candidate):\n    assert candidate(\"[(])\") == False\n    assert candidate(\"()[]{}\") == True\n    assert candidate(\"([{}()])\") == True\n    assert candidate(\"(()()()()){{}}[[]]\") == True\n    assert candidate(\"\") == True\n    assert candidate(\"({[]})\") == True\n    assert candidate(\"((())\") == False\n    assert candidate(\"((([[[{{{\") == False\n    assert candidate(\")\") == False\n    assert candidate(\"{[]()}\") == True\n", "language": "python"}
{"task_id": "2aa0d5a7-ea2b-489d-a2b2-a7697a2a2dbb8193277720366714810", "prompt": "Provide a complete function implementation that can be executed without modification. Keep all code within the function block. Use only the libraries specified in the problem. If additional functionality is needed, create helper functions or classes inside the main function.\n\n```python\nfrom typing import List, Tuple\n\ndef optimize_mining_route(mine_map: List[List[int]]) -> Tuple[int, List[Tuple[int, int]]]:\n    \"\"\"\n    In a futuristic mining operation on an alien planet, we need to find the most efficient route\n    through a rectangular mine field to extract the maximum amount of rare minerals. The mine is\n    represented as a 2D grid where each cell contains the amount of minerals that can be extracted\n    from that location. We can only move right or down from any given cell.\n\n    This function takes a 2D list representing the mine map and returns a tuple containing the\n    maximum amount of minerals that can be extracted and the optimal path through the mine.\n\n\n    [EXAMPLES]\n    \n    assert candidate([[1] * 10 for _ in range(10)]) == (19, [(0, 0), (1, 0), (2, 0), (3, 0), (4, 0), (5, 0), (6, 0), (7, 0), (8, 0), (9, 0), (9, 1), (9, 2), (9, 3), (9, 4), (9, 5), (9, 6), (9, 7), (9, 8), (9, 9)])\n    assert candidate([[0, 0, 0], [0, 0, 0], [0, 0, 0]]) == (0, [(0, 0), (1, 0), (2, 0), (2, 1), (2, 2)])\n\n    [/EXAMPLES]\n    \"\"\"\n```\n", "entry_point": "optimize_mining_route", "solution": "from typing import List, Tuple\n\ndef optimize_mining_route(mine_map: List[List[int]]) -> Tuple[int, List[Tuple[int, int]]]:\n    \"\"\"\n    In a futuristic mining operation on an alien planet, we need to find the most efficient route\n    through a rectangular mine field to extract the maximum amount of rare minerals. The mine is\n    represented as a 2D grid where each cell contains the amount of minerals that can be extracted\n    from that location. We can only move right or down from any given cell.\n\n    This function takes a 2D list representing the mine map and returns a tuple containing the\n    maximum amount of minerals that can be extracted and the optimal path through the mine.\n\n\n    [EXAMPLES]\n    \n    assert candidate([[1] * 10 for _ in range(10)]) == (19, [(0, 0), (1, 0), (2, 0), (3, 0), (4, 0), (5, 0), (6, 0), (7, 0), (8, 0), (9, 0), (9, 1), (9, 2), (9, 3), (9, 4), (9, 5), (9, 6), (9, 7), (9, 8), (9, 9)])\n    assert candidate([[0, 0, 0], [0, 0, 0], [0, 0, 0]]) == (0, [(0, 0), (1, 0), (2, 0), (2, 1), (2, 2)])\n\n    [/EXAMPLES]\n    \"\"\"\n    if not mine_map or not mine_map[0]:\n        return (0, [])\n\n    rows, cols = len(mine_map), len(mine_map[0])\n    \n    # Initialize the DP table and path tracker\n    dp = [[0] * cols for _ in range(rows)]\n    path = [[None] * cols for _ in range(rows)]\n    \n    # Fill the DP table and track the path\n    for i in range(rows):\n        for j in range(cols):\n            if i == 0 and j == 0:\n                dp[i][j] = mine_map[i][j]\n            elif i == 0:\n                dp[i][j] = dp[i][j-1] + mine_map[i][j]\n                path[i][j] = (i, j-1)\n            elif j == 0:\n                dp[i][j] = dp[i-1][j] + mine_map[i][j]\n                path[i][j] = (i-1, j)\n            else:\n                if dp[i-1][j] > dp[i][j-1]:\n                    dp[i][j] = dp[i-1][j] + mine_map[i][j]\n                    path[i][j] = (i-1, j)\n                else:\n                    dp[i][j] = dp[i][j-1] + mine_map[i][j]\n                    path[i][j] = (i, j-1)\n    \n    # Reconstruct the optimal path\n    optimal_path = []\n    i, j = rows - 1, cols - 1\n    while i >= 0 and j >= 0:\n        optimal_path.append((i, j))\n        if path[i][j] is None:\n            break\n        i, j = path[i][j]\n    \n    optimal_path.reverse()\n    \n    return (dp[rows-1][cols-1], optimal_path)\n\n", "test": "def check(candidate):\n    assert candidate([[1, 1, 1], [1, 1, 1], [1, 1, 1]]) == (5, [(0, 0), (1, 0), (2, 0), (2, 1), (2, 2)])\n    assert candidate([[1] * 10 for _ in range(10)]) == (19, [(0, 0), (1, 0), (2, 0), (3, 0), (4, 0), (5, 0), (6, 0), (7, 0), (8, 0), (9, 0), (9, 1), (9, 2), (9, 3), (9, 4), (9, 5), (9, 6), (9, 7), (9, 8), (9, 9)])\n    assert candidate([[0, 0, 0], [0, 0, 0], [0, 0, 0]]) == (0, [(0, 0), (1, 0), (2, 0), (2, 1), (2, 2)])\n    assert candidate([[1]]) == (1, [(0, 0)])\n    assert candidate([[1, 1], [1, 1]]) == (3, [(0, 0), (1, 0), (1, 1)])\n    assert candidate([[1, 2], [3, 4], [5, 6], [7, 8], [9, 10]]) == (35, [(0, 0), (1, 0), (2, 0), (3, 0), (4, 0), (4, 1)])\n    assert candidate([[1, 1, 1, 1], [1, 1, 1, 1], [1, 1, 1, 1], [1, 1, 1, 1]]) == (7, [(0, 0), (1, 0), (2, 0), (3, 0), (3, 1), (3, 2), (3, 3)])\n    assert candidate([[9, 8, 7], [6, 5, 4], [3, 2, 1]]) == (29, [(0, 0), (0, 1), (0, 2), (1, 2), (2, 2)])\n    assert candidate([[i + j for j in range(5)] for i in range(5)]) == (36, [(0, 0), (1, 0), (2, 0), (3, 0), (4, 0), (4, 1), (4, 2), (4, 3), (4, 4)])\n    assert candidate([[1, 2, 3], [4, 5, 6], [7, 8, 9]]) == (29, [(0, 0), (1, 0), (2, 0), (2, 1), (2, 2)])\n", "language": "python"}
{"task_id": "9a234a30-2244-4b45-a66b-a16734cd384d3951963245938956813", "prompt": "I serve as your coding assistant. My job is to implement the function you provide so it's directly executable. I'll confine my solution to the function body, without external code. I'll work exclusively with the libraries imported in your problem statement and will include any necessary helper functions or classes within the main function definition.\n\n```python\nfrom collections import defaultdict, deque\nfrom typing import List, Tuple\nfrom collections import defaultdict\n\ndef optimize_network_flow(nodes: List[str], edges: List[Tuple[str, str, int]], source: str, sink: str) -> int:\n    \"\"\"\n    You are a network engineer tasked with optimizing the flow of data in a complex computer network.\n    Your goal is to find the maximum flow of data that can be sent from a source node to a sink node\n    while respecting the capacity constraints of each edge in the network.\n\n    Parameters:\n    nodes (List[str]): A list of node names in the network.\n    edges (List[Tuple[str, str, int]]): A list of tuples representing edges, where each tuple contains\n                                        (start_node, end_node, capacity).\n    source (str): The name of the source node.\n    sink (str): The name of the sink node.\n\n    Returns:\n    int: The maximum flow that can be achieved from source to sink.\n\n\n    [EXAMPLES]\n    \n    assert candidate(['P', 'Q', 'R', 'S', 'T'], [('P', 'Q', 3), ('P', 'R', 2), ('Q', 'S', 1), ('R', 'S', 2), ('S', 'T', 4)], 'P', 'T') == 3\n    assert candidate(['A', 'B', 'C', 'D', 'E', 'F'], [('A', 'B', 10), ('A', 'C', 10), ('B', 'D', 5), ('C', 'E', 5), ('D', 'F', 10), ('E', 'F', 10)], 'A', 'F') == 10\n\n    [/EXAMPLES]\n    \"\"\"\n```\n", "entry_point": "optimize_network_flow", "solution": "from collections import defaultdict, deque\nfrom typing import List, Tuple\nfrom collections import defaultdict\n\ndef optimize_network_flow(nodes: List[str], edges: List[Tuple[str, str, int]], source: str, sink: str) -> int:\n    \"\"\"\n    You are a network engineer tasked with optimizing the flow of data in a complex computer network.\n    Your goal is to find the maximum flow of data that can be sent from a source node to a sink node\n    while respecting the capacity constraints of each edge in the network.\n\n    Parameters:\n    nodes (List[str]): A list of node names in the network.\n    edges (List[Tuple[str, str, int]]): A list of tuples representing edges, where each tuple contains\n                                        (start_node, end_node, capacity).\n    source (str): The name of the source node.\n    sink (str): The name of the sink node.\n\n    Returns:\n    int: The maximum flow that can be achieved from source to sink.\n\n\n    [EXAMPLES]\n    \n    assert candidate(['P', 'Q', 'R', 'S', 'T'], [('P', 'Q', 3), ('P', 'R', 2), ('Q', 'S', 1), ('R', 'S', 2), ('S', 'T', 4)], 'P', 'T') == 3\n    assert candidate(['A', 'B', 'C', 'D', 'E', 'F'], [('A', 'B', 10), ('A', 'C', 10), ('B', 'D', 5), ('C', 'E', 5), ('D', 'F', 10), ('E', 'F', 10)], 'A', 'F') == 10\n\n    [/EXAMPLES]\n    \"\"\"\n    def bfs(graph, source, sink, parent):\n        visited = set()\n        queue = [source]\n        visited.add(source)\n        \n        while queue:\n            u = queue.pop(0)\n            for v, capacity in graph[u].items():\n                if v not in visited and capacity > 0:\n                    queue.append(v)\n                    visited.add(v)\n                    parent[v] = u\n                    if v == sink:\n                        return True\n        return False\n\n    def ford_fulkerson(graph, source, sink):\n        parent = {}\n        max_flow = 0\n\n        while bfs(graph, source, sink, parent):\n            path_flow = float('inf')\n            s = sink\n            while s != source:\n                path_flow = min(path_flow, graph[parent[s]][s])\n                s = parent[s]\n\n            max_flow += path_flow\n\n            v = sink\n            while v != source:\n                u = parent[v]\n                graph[u][v] -= path_flow\n                graph[v][u] += path_flow\n                v = parent[v]\n\n        return max_flow\n\n    # Create a graph representation\n    graph = defaultdict(lambda: defaultdict(int))\n    for start, end, capacity in edges:\n        graph[start][end] += capacity\n\n    return ford_fulkerson(graph, source, sink)\n\n", "test": "def check(candidate):\n    assert candidate(['A', 'B', 'C', 'D'], [('A', 'B', 100), ('A', 'C', 100), ('B', 'D', 1), ('C', 'D', 1)], 'A', 'D') == 2\n    assert candidate(['X', 'Y'], [('X', 'Y', 0)], 'X', 'Y') == 0\n    assert candidate(['A', 'B', 'C', 'D', 'E', 'F'], [('A', 'B', 10), ('A', 'C', 10), ('B', 'D', 5), ('C', 'E', 5), ('D', 'F', 10), ('E', 'F', 10)], 'A', 'F') == 10\n    assert candidate(['A', 'B', 'C', 'D'], [('A', 'B', 1), ('A', 'C', 1), ('B', 'D', 1), ('C', 'D', 1)], 'A', 'D') == 2\n    assert candidate(['S', 'A', 'B', 'T'], [('S', 'A', 3), ('A', 'B', 3), ('B', 'T', 3)], 'S', 'T') == 3\n    assert candidate(['S', 'A', 'B', 'T'], [('S', 'A', 3), ('S', 'B', 2), ('A', 'T', 2), ('B', 'T', 3)], 'S', 'T') == 4\n    assert candidate(['S', 'A', 'B', 'C', 'D', 'E', 'T'], [('S', 'A', 8), ('S', 'B', 6), ('A', 'C', 4), ('A', 'D', 2), ('B', 'D', 4), ('C', 'E', 4), ('D', 'E', 5), ('D', 'T', 3), ('E', 'T', 8)], 'S', 'T') == 10\n    assert candidate(['P', 'Q', 'R', 'S', 'T'], [('P', 'Q', 3), ('P', 'R', 2), ('Q', 'S', 1), ('R', 'S', 2), ('S', 'T', 4)], 'P', 'T') == 3\n    assert candidate(['A', 'B'], [('A', 'B', 10)], 'A', 'B') == 10\n    assert candidate(['A', 'B', 'C', 'D'], [('A', 'B', 5), ('A', 'C', 3), ('B', 'C', 2), ('B', 'D', 4), ('C', 'D', 5)], 'A', 'D') == 8\n", "language": "python"}
{"task_id": "a3cd2c82-04cd-44e0-8c5c-a9eb132dfb3a8995907154501977746", "prompt": "Complete the function as specified in the docstring. The entire function should be contained in a single code block.\n\n```python\nimport re\nfrom typing import List\n\ndef parse_custom_format(log_entries: List[str]) -> List[dict]:\n    \"\"\"You are a data analyst working with log files from a custom-built system.\n    The log entries follow a specific format, and your task is to parse these entries\n    into structured data for further analysis.\n\n    The function takes one parameter:\n    1. log_entries: A list of strings, where each string represents a log entry.\n\n    Each log entry has the following format:\n    [TIMESTAMP] USER:username ACTION:action_name DURATION:duration_ms STATUS:status_code\n\n    Return a list of dictionaries, where each dictionary represents a parsed log entry\n    with the following keys: 'timestamp', 'username', 'action', 'duration', 'status'.\n\n    Notes:\n    - The timestamp is in the format YYYY-MM-DD HH:MM:SS\n    - The username may contain letters, numbers, and underscores\n    - The action_name may contain letters, numbers, and underscores\n    - The duration is an integer representing milliseconds\n    - The status_code is either 'SUCCESS' or 'FAILURE'\n\n    If a log entry is invalid or missing any component, exclude it from the output.\n\n\n    [EXAMPLES]\n    \n    assert candidate([\"[2023-03-29 19:30:41] USER:user ACTION:action DURATION:100 STATUS:SUCCESS\", \"[Invalid log entry]\"]) == [{'timestamp': '2023-03-29 19:30:41', 'username': 'user', 'action': 'action', 'duration': 100, 'status': 'SUCCESS'}]\n    assert candidate([\"[2023-03-20 10:20:30] USER: ACTION:action DURATION:100 STATUS:SUCCESS\"]) == []\n\n    [/EXAMPLES]\n    \"\"\"\n```\n", "entry_point": "parse_custom_format", "solution": "import re\nfrom typing import List\n\ndef parse_custom_format(log_entries: List[str]) -> List[dict]:\n    \"\"\"You are a data analyst working with log files from a custom-built system.\n    The log entries follow a specific format, and your task is to parse these entries\n    into structured data for further analysis.\n\n    The function takes one parameter:\n    1. log_entries: A list of strings, where each string represents a log entry.\n\n    Each log entry has the following format:\n    [TIMESTAMP] USER:username ACTION:action_name DURATION:duration_ms STATUS:status_code\n\n    Return a list of dictionaries, where each dictionary represents a parsed log entry\n    with the following keys: 'timestamp', 'username', 'action', 'duration', 'status'.\n\n    Notes:\n    - The timestamp is in the format YYYY-MM-DD HH:MM:SS\n    - The username may contain letters, numbers, and underscores\n    - The action_name may contain letters, numbers, and underscores\n    - The duration is an integer representing milliseconds\n    - The status_code is either 'SUCCESS' or 'FAILURE'\n\n    If a log entry is invalid or missing any component, exclude it from the output.\n\n\n    [EXAMPLES]\n    \n    assert candidate([\"[2023-03-29 19:30:41] USER:user ACTION:action DURATION:100 STATUS:SUCCESS\", \"[Invalid log entry]\"]) == [{'timestamp': '2023-03-29 19:30:41', 'username': 'user', 'action': 'action', 'duration': 100, 'status': 'SUCCESS'}]\n    assert candidate([\"[2023-03-20 10:20:30] USER: ACTION:action DURATION:100 STATUS:SUCCESS\"]) == []\n\n    [/EXAMPLES]\n    \"\"\"\n    parsed_entries = []\n    pattern = r'\\[(\\d{4}-\\d{2}-\\d{2} \\d{2}:\\d{2}:\\d{2})\\] USER:(\\w+) ACTION:(\\w+) DURATION:(\\d+) STATUS:(SUCCESS|FAILURE)'\n\n    for entry in log_entries:\n        match = re.match(pattern, entry)\n        if match:\n            timestamp, username, action, duration, status = match.groups()\n            parsed_entry = {\n                'timestamp': timestamp,\n                'username': username,\n                'action': action,\n                'duration': int(duration),\n                'status': status\n            }\n            parsed_entries.append(parsed_entry)\n\n    return parsed_entries\n\n", "test": "def check(candidate):\n    assert candidate([\"[2023-03-29 19:30:41] USER:user ACTION:action DURATION:100 STATUS:SUCCESS\", \"[Invalid log entry]\"]) == [{'timestamp': '2023-03-29 19:30:41', 'username': 'user', 'action': 'action', 'duration': 100, 'status': 'SUCCESS'}]\n    assert candidate([]) == []\n    assert candidate([\"[2023-03-17 23:59:59] USER:user2 ACTION:action2 DURATION:9999999 STATUS:FAILURE\"]) == [{'timestamp': '2023-03-17 23:59:59', 'username': 'user2', 'action': 'action2', 'duration': 9999999, 'status': 'FAILURE'}]\n    assert candidate([\"[2023-03-17 00:00:00] USER:user1 ACTION:action1 DURATION:0 STATUS:SUCCESS\"]) == [{'timestamp': '2023-03-17 00:00:00', 'username': 'user1', 'action': 'action1', 'duration': 0, 'status': 'SUCCESS'}]\n    assert candidate([\"[2023-03-28 18:29:40] USER:user ACTION:action/subaction DURATION:100 STATUS:SUCCESS\"]) == []\n    assert candidate([\"[2023-03-20 10:20:30] USER: ACTION:action DURATION:100 STATUS:SUCCESS\"]) == []\n    assert candidate([\"[2023-03-23 13:24:35] USER:user ACTION:action DURATION:100 STATUS:\"]) == []\n    assert candidate([\"[2023-03-25 15:26:37] USER:user ACTION:action DURATION:-100 STATUS:SUCCESS\"]) == []\n    assert candidate([\"[2023-03-30 20:31:42] USER:user1 ACTION:action1 DURATION:100 STATUS:SUCCESS\", \"[2023-03-30 20:31:43] USER:user2 ACTION:action2 DURATION:200 STATUS:FAILURE\", \"[2023-03-30 20:31:44] USER:user3 ACTION:action3 DURATION:300 STATUS:SUCCESS\"]) == [{'timestamp': '2023-03-30 20:31:42', 'username': 'user1', 'action': 'action1', 'duration': 100, 'status': 'SUCCESS'}, {'timestamp': '2023-03-30 20:31:43', 'username': 'user2', 'action': 'action2', 'duration': 200, 'status': 'FAILURE'}, {'timestamp': '2023-03-30 20:31:44', 'username': 'user3', 'action': 'action3', 'duration': 300, 'status': 'SUCCESS'}]\n    assert candidate([\"[2023-03-27 17:28:39] USER:user@email.com ACTION:action DURATION:100 STATUS:SUCCESS\"]) == []\n", "language": "python"}
{"task_id": "9bc2ba9f-88c0-48e0-8cb1-defeec7b586d-2861528323677032294", "prompt": "I'll finish implementing the function you've provided, ensuring it's completely self-contained in one code block. I'll only utilize libraries that are imported in the problem and will define any necessary helper functions or classes inside your main function.\n\n```python\nfrom typing import List, Tuple\n\ndef analyze_dna_sequences(sequences: List[str]) -> Tuple[str, float, List[str]]:\n    \"\"\"\n    A bioinformatics researcher is studying DNA sequences. This function takes a list of DNA sequences\n    and performs various analyses using string manipulation and list operations.\n\n    The function should:\n    1. Find the longest common substring among all sequences\n    2. Calculate the average GC-content (percentage of G and C bases) across all sequences\n    3. Identify sequences that are palindromes (read the same forwards and backwards)\n\n\n    [EXAMPLES]\n    \n    assert candidate([\"ATATATATATAT\", \"CGCGCGCGCGCG\", \"TATATATATAT\", \"GCGCGCGCGCG\"]) == ('', 50.0, ['TATATATATAT', 'GCGCGCGCGCG'])\n    assert candidate([\"ATATATATA\", \"GCGCGCGCG\", \"TATATATA\", \"CGCGCGCG\"]) == ('', 50.0, ['ATATATATA', 'GCGCGCGCG'])\n\n    [/EXAMPLES]\n    \"\"\"\n```\n", "entry_point": "analyze_dna_sequences", "solution": "from typing import List, Tuple\n\ndef analyze_dna_sequences(sequences: List[str]) -> Tuple[str, float, List[str]]:\n    \"\"\"\n    A bioinformatics researcher is studying DNA sequences. This function takes a list of DNA sequences\n    and performs various analyses using string manipulation and list operations.\n\n    The function should:\n    1. Find the longest common substring among all sequences\n    2. Calculate the average GC-content (percentage of G and C bases) across all sequences\n    3. Identify sequences that are palindromes (read the same forwards and backwards)\n\n\n    [EXAMPLES]\n    \n    assert candidate([\"ATATATATATAT\", \"CGCGCGCGCGCG\", \"TATATATATAT\", \"GCGCGCGCGCG\"]) == ('', 50.0, ['TATATATATAT', 'GCGCGCGCGCG'])\n    assert candidate([\"ATATATATA\", \"GCGCGCGCG\", \"TATATATA\", \"CGCGCGCG\"]) == ('', 50.0, ['ATATATATA', 'GCGCGCGCG'])\n\n    [/EXAMPLES]\n    \"\"\"\n    def find_longest_common_substring(seqs):\n        if not seqs:\n            return \"\"\n        shortest = min(seqs, key=len)\n        for length in range(len(shortest), 0, -1):\n            for start in range(len(shortest) - length + 1):\n                substring = shortest[start:start+length]\n                if all(substring in seq for seq in seqs):\n                    return substring\n        return \"\"\n\n    def calculate_gc_content(seq):\n        gc_count = sum(1 for base in seq if base in 'GC')\n        return (gc_count / len(seq)) * 100 if len(seq) > 0 else 0\n\n    def is_palindrome(seq):\n        return seq == seq[::-1]\n\n    # 1. Find the longest common substring\n    longest_common = find_longest_common_substring(sequences)\n\n    # 2. Calculate the average GC-content\n    avg_gc_content = sum(calculate_gc_content(seq) for seq in sequences) / len(sequences) if sequences else 0\n\n    # 3. Identify palindrome sequences\n    palindromes = [seq for seq in sequences if is_palindrome(seq)]\n\n    return (longest_common, avg_gc_content, palindromes)\n\n", "test": "def check(candidate):\n    assert candidate([\"ATCGATCG\", \"CGATATCG\", \"TCGATCGA\", \"GATCGATC\"]) == ('ATCG', 50.0, [])\n    assert candidate([\"ATAT\", \"TATA\", \"CGCG\", \"GCGC\"]) == ('', 50.0, [])\n    assert candidate([\"ATCGATCG\", \"TAGCTAGC\", \"GCTAGCTA\", \"CGAT\"]) == ('C', 50.0, [])\n    assert candidate([\"ATCG\" * 25, \"CGAT\" * 25, \"GATC\" * 25, \"TCGA\" * 25]) == ('ATCGATCGATCGATCGATCGATCGATCGATCGATCGATCGATCGATCGATCGATCGATCGATCGATCGATCGATCGATCGATCGATCGATCGATCGA', 50.0, [])\n    assert candidate([\"AAAAACCCCCGGGGGTTTTT\", \"TTTTTGGGGGCCCCCAAAAA\"]) == ('AAAAA', 50.0, [])\n    assert candidate([\"AAAAA\", \"TTTTT\", \"CCCCC\", \"GGGGG\"]) == ('', 50.0, ['AAAAA', 'TTTTT', 'CCCCC', 'GGGGG'])\n    assert candidate([\"ATATATATATAT\", \"CGCGCGCGCGCG\", \"TATATATATAT\", \"GCGCGCGCGCG\"]) == ('', 50.0, ['TATATATATAT', 'GCGCGCGCGCG'])\n    assert candidate([\"A\" * 100, \"T\" * 100, \"C\" * 100, \"G\" * 100]) == ('', 50.0, ['AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA', 'TTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTT', 'CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC', 'GGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGG'])\n    assert candidate([\"ATATATATA\", \"GCGCGCGCG\", \"TATATATA\", \"CGCGCGCG\"]) == ('', 50.0, ['ATATATATA', 'GCGCGCGCG'])\n    assert candidate([\"ATCGATCGATCG\", \"ATCGATCGATCG\", \"CGCGCGCGCGCG\"]) == ('CG', 66.66666666666667, [])\n", "language": "python"}
{"task_id": "b22e9f2a-63af-4846-8ee8-c5a170896146-7250459204374088829", "prompt": "Based on the doc string information, I'll complete this function implementation. I'll maintain the existing function signature and provide the full code in one block.\n\n```python\nfrom typing import List, Dict\n\ndef decode_alien_message(symbols: List[str]) -> str:\n    \"\"\"\n    An alien civilization has sent a message to Earth using a series of symbols.\n    Scientists have determined that each symbol represents a specific sound in\n    the alien language. Your task is to decode this message and translate it into\n    human-readable form.\n\n    You are given a list of symbols representing the alien message. Create a\n    decoder that translates each symbol to its corresponding sound and combines\n    them to form the complete message.\n\n    The decoder should use the following rules:\n    1. Each symbol is represented by a unique string.\n    2. The corresponding sounds are as follows:\n       - '\u25b3': 'zee'\n       - '\u25a1': 'boo'\n       - '\u25cb': 'gah'\n       - '\u25c7': 'meh'\n\n    Args:\n    symbols (List[str]): A list of strings representing the alien symbols.\n\n    Returns:\n    str: The decoded message as a string of sounds separated by spaces.\n\n\n    [EXAMPLES]\n    \n    assert candidate(['\u25a1']) == 'boo'\n    assert candidate(['\u25b3', '\u25c7', '\u25a1', '\u25cb', '\u25b3', '\u25c7']) == 'zee meh boo gah zee meh'\n\n    [/EXAMPLES]\n    \"\"\"\n```\n", "entry_point": "decode_alien_message", "solution": "from typing import List, Dict\n\ndef decode_alien_message(symbols: List[str]) -> str:\n    \"\"\"\n    An alien civilization has sent a message to Earth using a series of symbols.\n    Scientists have determined that each symbol represents a specific sound in\n    the alien language. Your task is to decode this message and translate it into\n    human-readable form.\n\n    You are given a list of symbols representing the alien message. Create a\n    decoder that translates each symbol to its corresponding sound and combines\n    them to form the complete message.\n\n    The decoder should use the following rules:\n    1. Each symbol is represented by a unique string.\n    2. The corresponding sounds are as follows:\n       - '\u25b3': 'zee'\n       - '\u25a1': 'boo'\n       - '\u25cb': 'gah'\n       - '\u25c7': 'meh'\n\n    Args:\n    symbols (List[str]): A list of strings representing the alien symbols.\n\n    Returns:\n    str: The decoded message as a string of sounds separated by spaces.\n\n\n    [EXAMPLES]\n    \n    assert candidate(['\u25a1']) == 'boo'\n    assert candidate(['\u25b3', '\u25c7', '\u25a1', '\u25cb', '\u25b3', '\u25c7']) == 'zee meh boo gah zee meh'\n\n    [/EXAMPLES]\n    \"\"\"\n    # Define the decoder dictionary\n    decoder = {\n        '\u25b3': 'zee',\n        '\u25a1': 'boo',\n        '\u25cb': 'gah',\n        '\u25c7': 'meh'\n    }\n\n    # Translate each symbol to its corresponding sound\n    decoded_sounds = [decoder[symbol] for symbol in symbols]\n\n    # Join the decoded sounds with spaces\n    decoded_message = ' '.join(decoded_sounds)\n\n    return decoded_message\n\n", "test": "def check(candidate):\n    assert candidate(['\u25c7', '\u25c7']) == 'meh meh'\n    assert candidate(['\u25a1', '\u25b3', '\u25a1', '\u25cb', '\u25c7', '\u25b3']) == 'boo zee boo gah meh zee'\n    assert candidate(['\u25b3'] * 10) == 'zee zee zee zee zee zee zee zee zee zee'\n    assert candidate([]) == ''\n    assert candidate(['\u25cb', '\u25c7']) == 'gah meh'\n    assert candidate(['\u25b3']) == 'zee'\n    assert candidate(['\u25b3', '\u25b3', '\u25b3']) == 'zee zee zee'\n    assert candidate(['\u25a1']) == 'boo'\n    assert candidate(['\u25b3', '\u25c7', '\u25a1', '\u25cb', '\u25b3', '\u25c7']) == 'zee meh boo gah zee meh'\n    assert candidate(['\u25b3', '\u25a1', '\u25cb', '\u25c7', '\u25b3', '\u25a1', '\u25cb', '\u25c7']) == 'zee boo gah meh zee boo gah meh'\n", "language": "python"}
{"task_id": "8294ebf0-26f7-4070-8ebe-4a18c702fd41-3354481026547563373", "prompt": "I'll provide the full function implementation according to the docstring requirements. The code will be in one block and will account for edge cases.\n\n```python\ndef decode_alien_message(encoded_text: str, decryption_key: dict) -> str:\n    \"\"\"\n    As a cryptographer working for SETI, you've intercepted an alien message. Your task is to decode it using a given decryption key.\n\n    The message is a string of alien symbols, and the decryption key is a dictionary mapping alien symbols to Earth letters.\n    Some alien symbols might not have a corresponding Earth letter - these should be left as is in the decoded message.\n\n    Return the decoded message as a string.\n\n\n    [EXAMPLES]\n    \n    assert candidate(\"abc\", {'a': 'x', 'b': 'y', 'c': 'z'}) == 'xyz'\n    assert candidate(\"\u221e\u222b\u2202\u00a2\u2206\u03c0\u0192\u2211\u220f\u2206\u2206\u2206\", {'\u221e': 'a', '\u222b': 's', '\u2202': 't', '\u00a2': 'r', '\u2206': 'o', '\u03c0': 'n', '\u0192': 'o', '\u2211': 'm', '\u220f': 'y'}) == 'astronomyooo'\n\n    [/EXAMPLES]\n    \"\"\"\n```\n", "entry_point": "decode_alien_message", "solution": "def decode_alien_message(encoded_text: str, decryption_key: dict) -> str:\n    \"\"\"\n    As a cryptographer working for SETI, you've intercepted an alien message. Your task is to decode it using a given decryption key.\n\n    The message is a string of alien symbols, and the decryption key is a dictionary mapping alien symbols to Earth letters.\n    Some alien symbols might not have a corresponding Earth letter - these should be left as is in the decoded message.\n\n    Return the decoded message as a string.\n\n\n    [EXAMPLES]\n    \n    assert candidate(\"abc\", {'a': 'x', 'b': 'y', 'c': 'z'}) == 'xyz'\n    assert candidate(\"\u221e\u222b\u2202\u00a2\u2206\u03c0\u0192\u2211\u220f\u2206\u2206\u2206\", {'\u221e': 'a', '\u222b': 's', '\u2202': 't', '\u00a2': 'r', '\u2206': 'o', '\u03c0': 'n', '\u0192': 'o', '\u2211': 'm', '\u220f': 'y'}) == 'astronomyooo'\n\n    [/EXAMPLES]\n    \"\"\"\n    decoded_message = []\n    for symbol in encoded_text:\n        if symbol in decryption_key:\n            decoded_message.append(decryption_key[symbol])\n        else:\n            decoded_message.append(symbol)\n    \n    return ''.join(decoded_message)\n\n", "test": "def check(candidate):\n    assert candidate(\"\u222b\u2206\u03c0 \u2211\u220f\u0192\u2202\", {'\u222b': 's', '\u2206': 'o', '\u03c0': 's', '\u2211': 'c', '\u220f': 'o', '\u0192': 'o', '\u2202': 'l'}) == 'sos cool'\n    assert candidate(\"\u00a9\u00a7\u00a5\u00ae\u00a7 \u221e\u00a7 \u00a2\u00a7\u2202\u00a9 \u222b\u2206\u03c0\", {'\u00a9': 'h', '\u00a7': 'e', '\u00a5': 'l', '\u00ae': 'o', '\u221e': 'a', '\u00a2': 'r', '\u2202': 't', '\u222b': 's', '\u2206': 'o', '\u03c0': 's'}) == 'heloe ae reth sos'\n    assert candidate(\"\u221e\u222b\u2202\u00a2\u2206\", {'\u221e': 'a', '\u222b': 's', '\u2202': 't', '\u00a2': 'r', '\u2206': 'o'}) == 'astro'\n    assert candidate(\"\u221e\u221e\u221e\", {'\u221e': 'a'}) == 'aaa'\n    assert candidate(\"\u221e\u222b\u2202\u00a2\u2206\u03c0\u0192\u2211\u220f\u2206\u2206\u2206\", {'\u221e': 'a', '\u222b': 's', '\u2202': 't', '\u00a2': 'r', '\u2206': 'o', '\u03c0': 'n', '\u0192': 'o', '\u2211': 'm', '\u220f': 'y'}) == 'astronomyooo'\n    assert candidate(\"!@#$%\", {'!': '1', '@': '2', '#': '3', '$': '4', '%': '5'}) == '12345'\n    assert candidate(\"\", {}) == ''\n    assert candidate(\"\u221e\u222b\u2202\u00a2\u2206\u03c0\u0192\u2211\u220f\", {'\u221e': 'A', '\u222b': 'S', '\u2202': 'T', '\u00a2': 'R', '\u2206': 'O', '\u03c0': 'N', '\u0192': 'O', '\u2211': 'M', '\u220f': 'Y'}) == 'ASTRONOMY'\n    assert candidate(\"abc\", {'a': 'x', 'b': 'y', 'c': 'z'}) == 'xyz'\n    assert candidate(\"\u00a9\u00a7\u00a5\u00a5\u2206 \u221e\u2206\u00a2\u00a5\u2202\", {'\u00a9': 'h', '\u00a7': 'e', '\u00a5': 'l', '\u2206': 'o', '\u221e': 'w', '\u00a2': 'r', '\u2202': 'd'}) == 'hello world'\n", "language": "python"}
{"task_id": "a423cdbc-648a-4aec-9844-a25abba862612149388545948983956", "prompt": "I'll code the rest of this function according to its docstring. The solution will be provided as one complete code block.\n\n```python\nfrom typing import List\n\ndef calculate_water_flow(terrain: List[int]) -> int:\n    \"\"\"\n    In a mountainous region, you're tasked with calculating the amount of water that can be trapped between peaks after a rainstorm.\n    The terrain is represented as a list of integers where each integer represents the height of the land at that position.\n    Water can be trapped between two peaks if there are lower elevations between them.\n    \n    Your function should return the total units of water that can be trapped in the terrain.\n    \n\n    [EXAMPLES]\n    \n    assert candidate([3,0,0,2,0,4]) == 10\n    assert candidate([1,1,1,1]) == 0\n\n    [/EXAMPLES]\n    \"\"\"\n```\n", "entry_point": "calculate_water_flow", "solution": "from typing import List\n\ndef calculate_water_flow(terrain: List[int]) -> int:\n    \"\"\"\n    In a mountainous region, you're tasked with calculating the amount of water that can be trapped between peaks after a rainstorm.\n    The terrain is represented as a list of integers where each integer represents the height of the land at that position.\n    Water can be trapped between two peaks if there are lower elevations between them.\n    \n    Your function should return the total units of water that can be trapped in the terrain.\n    \n\n    [EXAMPLES]\n    \n    assert candidate([3,0,0,2,0,4]) == 10\n    assert candidate([1,1,1,1]) == 0\n\n    [/EXAMPLES]\n    \"\"\"\n    if not terrain or len(terrain) < 3:\n        return 0\n\n    n = len(terrain)\n    left_max = [0] * n\n    right_max = [0] * n\n    water = 0\n\n    # Calculate the maximum height to the left of each position\n    left_max[0] = terrain[0]\n    for i in range(1, n):\n        left_max[i] = max(left_max[i-1], terrain[i])\n\n    # Calculate the maximum height to the right of each position\n    right_max[n-1] = terrain[n-1]\n    for i in range(n-2, -1, -1):\n        right_max[i] = max(right_max[i+1], terrain[i])\n\n    # Calculate the water trapped at each position\n    for i in range(n):\n        min_height = min(left_max[i], right_max[i])\n        if min_height > terrain[i]:\n            water += min_height - terrain[i]\n\n    return water\n\n", "test": "def check(candidate):\n    assert candidate([5,5,5,5]) == 0\n    assert candidate([9,8,7,6,5,4,3,2,1,0]) == 0\n    assert candidate([5,4,3,2,1]) == 0\n    assert candidate([3,0,0,2,0,4]) == 10\n    assert candidate([0,0,0,0,5]) == 0\n    assert candidate([]) == 0\n    assert candidate([1,1,1,1]) == 0\n    assert candidate([7,0,7,0,7]) == 14\n    assert candidate([1]) == 0\n    assert candidate([5,2,3,2,5]) == 8\n", "language": "python"}
{"task_id": "ce1de220-72d9-466b-9faa-77659125fa742305188522504065428", "prompt": "Please complete the function based on its docstring. Provide the implementation in a single code block.\n\n```python\nfrom typing import List\n\ndef count_submatrices(matrix: List[List[int]]) -> int:\n    \"\"\"\n    Count the number of submatrices with all ones.\n\n    In a digital image processing task, you're given a binary matrix where 1\n    represents a pixel and 0 represents an empty space. Your goal is to count\n    the total number of submatrices (of any size) that consist entirely of ones.\n\n\n    [EXAMPLES]\n    \n    assert candidate([[0,1,1,0],[1,1,1,1],[0,1,1,0]]) == 25\n    assert candidate([[1,0,0,1],[0,1,1,0],[0,1,1,0],[1,0,0,1]]) == 13\n\n    [/EXAMPLES]\n    \"\"\"\n```\n", "entry_point": "count_submatrices", "solution": "from typing import List\n\ndef count_submatrices(matrix: List[List[int]]) -> int:\n    \"\"\"\n    Count the number of submatrices with all ones.\n\n    In a digital image processing task, you're given a binary matrix where 1\n    represents a pixel and 0 represents an empty space. Your goal is to count\n    the total number of submatrices (of any size) that consist entirely of ones.\n\n\n    [EXAMPLES]\n    \n    assert candidate([[0,1,1,0],[1,1,1,1],[0,1,1,0]]) == 25\n    assert candidate([[1,0,0,1],[0,1,1,0],[0,1,1,0],[1,0,0,1]]) == 13\n\n    [/EXAMPLES]\n    \"\"\"\n    if not matrix or not matrix[0]:\n        return 0\n\n    m, n = len(matrix), len(matrix[0])\n    heights = [0] * n\n    result = 0\n\n    def count_rectangles(heights: List[int]) -> int:\n        stack = [-1]\n        count = 0\n        for i, h in enumerate(heights + [0]):\n            while stack[-1] != -1 and heights[stack[-1]] > h:\n                height = heights[stack.pop()]\n                width = i - stack[-1] - 1\n                count += height * width\n            stack.append(i)\n        return count\n\n    for row in matrix:\n        for i in range(n):\n            if row[i] == 1:\n                heights[i] += 1\n            else:\n                heights[i] = 0\n        result += count_rectangles(heights)\n\n    return result\n\n", "test": "def check(candidate):\n    assert candidate([[1,0,0,1],[0,1,1,0],[0,1,1,0],[1,0,0,1]]) == 13\n    assert candidate([[1,1,1,1,1],[1,0,0,0,1],[1,0,1,0,1],[1,0,0,0,1],[1,1,1,1,1]]) == 54\n    assert candidate([[1,1,1,1],[1,1,1,1],[1,1,1,1],[1,1,1,1]]) == 100\n    assert candidate([[1,0,1,0],[0,1,0,1],[1,0,1,0],[0,1,0,1]]) == 8\n    assert candidate([[0,1,1,0],[1,1,1,1],[0,1,1,0]]) == 25\n    assert candidate([[1,0,1,1],[0,1,1,1],[1,1,1,0]]) == 23\n    assert candidate([[0,0,0],[0,0,0],[0,0,0]]) == 0\n    assert candidate([[1,1,1],[1,1,1],[1,1,1]]) == 36\n    assert candidate([[1,1,0],[1,1,0],[0,0,1]]) == 10\n    assert candidate([[0,0],[0,0]]) == 0\n", "language": "python"}
{"task_id": "2f539e24-ad06-4108-9317-494f12dbc41b4256412303049750699", "prompt": "Write the function implementation based on the provided docstring. Ensure you handle all edge cases. Present the complete function in a single code block.\n\n```python\nfrom typing import List, Tuple\n\ndef calculate_tax(income: float, brackets: List[Tuple[float, float]]) -> float:\n    \"\"\"You are a tax accountant developing a function to calculate income tax based on a progressive tax system.\n\n    In this system, different tax rates apply to different portions of income. Each bracket is defined by an upper limit and a tax rate.\n\n    Take the total income and a list of tax brackets as input. Return the total tax to be paid.\n\n\n    [EXAMPLES]\n    \n    assert candidate(10000, [(10000, 0.1), (20000, 0.2)]) == 1000.0\n    assert candidate(0, [(10000, 0.1), (20000, 0.2)]) == 0\n\n    [/EXAMPLES]\n    \"\"\"\n```\n", "entry_point": "calculate_tax", "solution": "from typing import List, Tuple\n\ndef calculate_tax(income: float, brackets: List[Tuple[float, float]]) -> float:\n    \"\"\"You are a tax accountant developing a function to calculate income tax based on a progressive tax system.\n\n    In this system, different tax rates apply to different portions of income. Each bracket is defined by an upper limit and a tax rate.\n\n    Take the total income and a list of tax brackets as input. Return the total tax to be paid.\n\n\n    [EXAMPLES]\n    \n    assert candidate(10000, [(10000, 0.1), (20000, 0.2)]) == 1000.0\n    assert candidate(0, [(10000, 0.1), (20000, 0.2)]) == 0\n\n    [/EXAMPLES]\n    \"\"\"\n    total_tax = 0\n    remaining_income = income\n    previous_limit = 0\n\n    for limit, rate in brackets:\n        if remaining_income <= 0:\n            break\n\n        taxable_amount = min(remaining_income, limit - previous_limit)\n        tax = taxable_amount * rate\n        total_tax += tax\n\n        remaining_income -= taxable_amount\n        previous_limit = limit\n\n    return round(total_tax, 2)\n\n", "test": "def check(candidate):\n    assert candidate(25, [(50, 0.1), (75, 0.15), (100, 0.2)]) == 2.5\n    assert candidate(10000, [(10000, 0.1), (20000, 0.2)]) == 1000.0\n    assert candidate(10000.01, [(10000, 0.1), (20000, 0.2)]) == 1000.0\n    assert candidate(0, [(10000, 0.1), (20000, 0.2)]) == 0\n    assert candidate(1000, [(500, 0.05), (1000, 0.1)]) == 75.0\n    assert candidate(20000, [(10000, 0.1), (20000, 0.2)]) == 3000.0\n    assert candidate(50000, [(10000, 0.1), (30000, 0.15), (100000, 0.25)]) == 9000.0\n    assert candidate(120000, [(20000, 0.1), (50000, 0.2), (100000, 0.3), (float('inf'), 0.4)]) == 31000.0\n    assert candidate(9999.99, [(10000, 0.1)]) == 1000.0\n    assert candidate(30000, [(10000, 0.1), (20000, 0.2), (30000, 0.3)]) == 6000.0\n", "language": "python"}
{"task_id": "84e1fd03-ad9e-41c2-9eb1-c77013b49c826260053619887543848", "prompt": "Complete the function according to the documentation string. Provide the entire function in a single code block, ensuring edge cases are handled properly.\n\n```python\nimport re\n\ndef extract_product_info(product_code: str) -> dict:\n    \"\"\"\n    A retail store manager needs to parse product codes to extract information.\n    This function takes a product code string and extracts category, ID, and price.\n\n    The product code format is: CATXXX-IDYYY-$ZZZ.ZZ\n    Where:\n    CAT is a 3-letter category code\n    XXX is a 3-digit subcategory number\n    ID is a 2-letter ID code\n    YYY is a 3-digit product number\n    ZZZ.ZZ is the price with 2 decimal places\n\n\n    [EXAMPLES]\n    \n    assert candidate(\"FUN666-BC888-$135.79\") == {'category': 'FUN', 'subcategory': '666', 'id': 'BC', 'product_number': '888', 'price': 135.79}\n    assert candidate(\"PET222-WX333-$567.89\") == {'category': 'PET', 'subcategory': '222', 'id': 'WX', 'product_number': '333', 'price': 567.89}\n\n    [/EXAMPLES]\n    \"\"\"\n```\n", "entry_point": "extract_product_info", "solution": "import re\n\ndef extract_product_info(product_code: str) -> dict:\n    \"\"\"\n    A retail store manager needs to parse product codes to extract information.\n    This function takes a product code string and extracts category, ID, and price.\n\n    The product code format is: CATXXX-IDYYY-$ZZZ.ZZ\n    Where:\n    CAT is a 3-letter category code\n    XXX is a 3-digit subcategory number\n    ID is a 2-letter ID code\n    YYY is a 3-digit product number\n    ZZZ.ZZ is the price with 2 decimal places\n\n\n    [EXAMPLES]\n    \n    assert candidate(\"FUN666-BC888-$135.79\") == {'category': 'FUN', 'subcategory': '666', 'id': 'BC', 'product_number': '888', 'price': 135.79}\n    assert candidate(\"PET222-WX333-$567.89\") == {'category': 'PET', 'subcategory': '222', 'id': 'WX', 'product_number': '333', 'price': 567.89}\n\n    [/EXAMPLES]\n    \"\"\"\n    # Define the regex pattern to match the product code format\n    pattern = r'([A-Z]{3})(\\d{3})-([A-Z]{2})(\\d{3})-\\$(\\d+\\.\\d{2})'\n    \n    # Use re.match to find the pattern in the product code\n    match = re.match(pattern, product_code)\n    \n    if match:\n        # Extract the matched groups\n        category, subcategory, id_code, product_number, price = match.groups()\n        \n        # Create and return the dictionary with extracted information\n        return {\n            'category': category,\n            'subcategory': subcategory,\n            'id': id_code,\n            'product_number': product_number,\n            'price': float(price)\n        }\n    else:\n        # If the product code doesn't match the expected format, return None or raise an exception\n        raise ValueError(\"Invalid product code format\")\n\n", "test": "def check(candidate):\n    assert candidate(\"PET222-WX333-$567.89\") == {'category': 'PET', 'subcategory': '222', 'id': 'WX', 'product_number': '333', 'price': 567.89}\n    assert candidate(\"TEA333-LM444-$680.24\") == {'category': 'TEA', 'subcategory': '333', 'id': 'LM', 'product_number': '444', 'price': 680.24}\n    assert candidate(\"FUN666-BC888-$135.79\") == {'category': 'FUN', 'subcategory': '666', 'id': 'BC', 'product_number': '888', 'price': 135.79}\n    assert candidate(\"KID555-HI222-$468.02\") == {'category': 'KID', 'subcategory': '555', 'id': 'HI', 'product_number': '222', 'price': 468.02}\n    assert candidate(\"ELE123-AB456-$789.00\") == {'category': 'ELE', 'subcategory': '123', 'id': 'AB', 'product_number': '456', 'price': 789.0}\n    assert candidate(\"FOO999-XY001-$024.99\") == {'category': 'FOO', 'subcategory': '999', 'id': 'XY', 'product_number': '001', 'price': 24.99}\n    assert candidate(\"CAR789-UV012-$345.67\") == {'category': 'CAR', 'subcategory': '789', 'id': 'UV', 'product_number': '012', 'price': 345.67}\n    assert candidate(\"DOG111-AA222-$333.33\") == {'category': 'DOG', 'subcategory': '111', 'id': 'AA', 'product_number': '222', 'price': 333.33}\n    assert candidate(\"GYM444-RS666-$098.76\") == {'category': 'GYM', 'subcategory': '444', 'id': 'RS', 'product_number': '666', 'price': 98.76}\n    assert candidate(\"DIY333-YZ444-$678.90\") == {'category': 'DIY', 'subcategory': '333', 'id': 'YZ', 'product_number': '444', 'price': 678.9}\n", "language": "python"}
{"task_id": "ecdfd1ed-baa1-4c07-9124-3ab3aa21cd667308535894413141028", "prompt": "Complete the function implementation according to its documentation. Provide the entire function in a single code block and handle all edge cases.\n\n```python\nfrom typing import List\n\ndef optimize_factory_layout(rows: int, cols: int, machines: List[List[int]]) -> int:\n    \"\"\"\n    An industrial engineer is tasked with optimizing the layout of a factory floor.\n    The factory is represented as a grid of rows x cols, where each cell contains a machine with an efficiency rating.\n    The goal is to find the most efficient path from the top-left corner to the bottom-right corner of the factory floor.\n    The path can only move right or down, and the efficiency of the path is the sum of the efficiencies of the machines visited.\n\n    The function should return the maximum possible efficiency that can be achieved.\n\n\n    [EXAMPLES]\n    \n    assert candidate(2, 4, [[1, 10, 1, 1], [1, 1, 1, 10]]) == 23\n    assert candidate(5, 1, [[1], [2], [3], [4], [5]]) == 15\n\n    [/EXAMPLES]\n    \"\"\"\n```\n", "entry_point": "optimize_factory_layout", "solution": "from typing import List\n\ndef optimize_factory_layout(rows: int, cols: int, machines: List[List[int]]) -> int:\n    \"\"\"\n    An industrial engineer is tasked with optimizing the layout of a factory floor.\n    The factory is represented as a grid of rows x cols, where each cell contains a machine with an efficiency rating.\n    The goal is to find the most efficient path from the top-left corner to the bottom-right corner of the factory floor.\n    The path can only move right or down, and the efficiency of the path is the sum of the efficiencies of the machines visited.\n\n    The function should return the maximum possible efficiency that can be achieved.\n\n\n    [EXAMPLES]\n    \n    assert candidate(2, 4, [[1, 10, 1, 1], [1, 1, 1, 10]]) == 23\n    assert candidate(5, 1, [[1], [2], [3], [4], [5]]) == 15\n\n    [/EXAMPLES]\n    \"\"\"\n    # Create a 2D table to store the maximum efficiency at each cell\n    dp = [[0 for _ in range(cols)] for _ in range(rows)]\n    \n    # Initialize the first cell\n    dp[0][0] = machines[0][0]\n    \n    # Initialize the first row\n    for j in range(1, cols):\n        dp[0][j] = dp[0][j-1] + machines[0][j]\n    \n    # Initialize the first column\n    for i in range(1, rows):\n        dp[i][0] = dp[i-1][0] + machines[i][0]\n    \n    # Fill the rest of the table\n    for i in range(1, rows):\n        for j in range(1, cols):\n            # The maximum efficiency at each cell is the maximum of coming from above or from the left\n            dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + machines[i][j]\n    \n    # The bottom-right cell contains the maximum efficiency\n    return dp[rows-1][cols-1]\n\n", "test": "def check(candidate):\n    assert candidate(4, 4, [[1, 2, 3, 4], [5, 6, 7, 8], [9, 10, 11, 12], [13, 14, 15, 16]]) == 73\n    assert candidate(2, 4, [[1, 10, 1, 1], [1, 1, 1, 10]]) == 23\n    assert candidate(1, 1, [[5]]) == 5\n    assert candidate(3, 3, [[1000000, 1000000, 1000000], [1000000, 1000000, 1000000], [1000000, 1000000, 1000000]]) == 5000000\n    assert candidate(5, 5, [[1, 2, 3, 4, 5], [6, 7, 8, 9, 10], [11, 12, 13, 14, 15], [16, 17, 18, 19, 20], [21, 22, 23, 24, 25]]) == 149\n    assert candidate(4, 4, [[1, 1, 1, 1], [1, 2, 2, 1], [1, 2, 2, 1], [1, 1, 1, 1]]) == 10\n    assert candidate(5, 1, [[1], [2], [3], [4], [5]]) == 15\n    assert candidate(10, 1, [[i] for i in range(1, 11)]) == 55\n    assert candidate(2, 3, [[1, 2, 3], [4, 5, 6]]) == 16\n    assert candidate(4, 2, [[1, 1], [10, 1], [1, 1], [1, 10]]) == 23\n", "language": "python"}
{"task_id": "43689131-f48e-4abb-8e4b-12ba97f7343c-2195631337602464328", "prompt": "Let me complete the function for you. I'll ensure the code is fully executable, uses only the imported libraries, and contains any necessary helper functions within the main function. You'll receive just one code block with the implementation.\n\n```python\nfrom typing import List\n\ndef analyze_dna_sequence(sequence: str) -> dict:\n    \"\"\"\n    In a genomics research lab, scientists need to analyze DNA sequences.\n    This function takes a DNA sequence as input and returns various statistics about it.\n\n    The function calculates the following:\n    1. The length of the sequence\n    2. The count of each nucleotide (A, C, G, T)\n    3. The GC-content (percentage of G and C nucleotides)\n\n\n    [EXAMPLES]\n    \n    assert candidate(\"\") == {'length': 0, 'A': 0, 'T': 0, 'C': 0, 'G': 0, 'GC_content': 0}\n    assert candidate(\"ATCGATCGATCGATCGATCG\") == {'length': 20, 'A': 5, 'T': 5, 'C': 5, 'G': 5, 'GC_content': 50.0}\n\n    [/EXAMPLES]\n    \"\"\"\n```\n", "entry_point": "analyze_dna_sequence", "solution": "from typing import List\n\ndef analyze_dna_sequence(sequence: str) -> dict:\n    \"\"\"\n    In a genomics research lab, scientists need to analyze DNA sequences.\n    This function takes a DNA sequence as input and returns various statistics about it.\n\n    The function calculates the following:\n    1. The length of the sequence\n    2. The count of each nucleotide (A, C, G, T)\n    3. The GC-content (percentage of G and C nucleotides)\n\n\n    [EXAMPLES]\n    \n    assert candidate(\"\") == {'length': 0, 'A': 0, 'T': 0, 'C': 0, 'G': 0, 'GC_content': 0}\n    assert candidate(\"ATCGATCGATCGATCGATCG\") == {'length': 20, 'A': 5, 'T': 5, 'C': 5, 'G': 5, 'GC_content': 50.0}\n\n    [/EXAMPLES]\n    \"\"\"\n    # Initialize the result dictionary\n    result = {'length': len(sequence), 'A': 0, 'T': 0, 'C': 0, 'G': 0}\n    \n    # Count the occurrences of each nucleotide\n    for nucleotide in sequence:\n        if nucleotide in result:\n            result[nucleotide] += 1\n    \n    # Calculate GC-content\n    gc_count = result['C'] + result['G']\n    gc_content = (gc_count / result['length']) * 100 if result['length'] > 0 else 0\n    \n    # Add GC-content to the result dictionary, rounded to 2 decimal places\n    result['GC_content'] = round(gc_content, 2)\n    \n    return result\n\n", "test": "def check(candidate):\n    assert candidate(\"AT\") == {'length': 2, 'A': 1, 'T': 1, 'C': 0, 'G': 0, 'GC_content': 0.0}\n    assert candidate(\"T\") == {'length': 1, 'A': 0, 'T': 1, 'C': 0, 'G': 0, 'GC_content': 0.0}\n    assert candidate(\"ATATATATATAT\") == {'length': 12, 'A': 6, 'T': 6, 'C': 0, 'G': 0, 'GC_content': 0.0}\n    assert candidate(\"ATCGATCGATCGATCGATCGATCGATCGATCG\") == {'length': 32, 'A': 8, 'T': 8, 'C': 8, 'G': 8, 'GC_content': 50.0}\n    assert candidate(\"GGGG\") == {'length': 4, 'A': 0, 'T': 0, 'C': 0, 'G': 4, 'GC_content': 100.0}\n    assert candidate(\"ATCGATCGATCGATCGATCG\") == {'length': 20, 'A': 5, 'T': 5, 'C': 5, 'G': 5, 'GC_content': 50.0}\n    assert candidate(\"CCCC\") == {'length': 4, 'A': 0, 'T': 0, 'C': 4, 'G': 0, 'GC_content': 100.0}\n    assert candidate(\"ATCG\") == {'length': 4, 'A': 1, 'T': 1, 'C': 1, 'G': 1, 'GC_content': 50.0}\n    assert candidate(\"\") == {'length': 0, 'A': 0, 'T': 0, 'C': 0, 'G': 0, 'GC_content': 0}\n    assert candidate(\"AAAA\") == {'length': 4, 'A': 4, 'T': 0, 'C': 0, 'G': 0, 'GC_content': 0.0}\n", "language": "python"}
{"task_id": "516342b8-54b4-40d5-9180-304eed9064332086141166112530854", "prompt": "I'll complete the specified function so it's ready to execute. The implementation will be contained entirely within one code block, using only the libraries that are imported in the problem. Any helper functions or classes needed will be defined within the main function. The output will be exactly one code block.\n\n```python\nfrom typing import List, Tuple\n\ndef solar_panel_efficiency(panel_data: List[Tuple[float, float, float]]) -> float:\n    \"\"\"\n    Calculate the average efficiency of solar panels based on their performance data.\n\n    This function takes a list of tuples containing solar panel performance data and\n    returns the average efficiency across all panels. Each tuple in the input list\n    represents a single panel and contains three float values: power output (in watts),\n    panel area (in square meters), and solar irradiance (in watts per square meter).\n\n\n    [EXAMPLES]\n    \n    assert candidate([(60.0, 0.6, 500.0), (70.0, 0.7, 550.0), (80.0, 0.8, 600.0), (90.0, 0.9, 650.0), (100.0, 1.0, 700.0)]) == 0.16903762903762903\n    assert candidate([(50.0, 0.5, 400.0), (60.0, 0.6, 450.0), (70.0, 0.7, 500.0), (80.0, 0.8, 550.0), (90.0, 0.9, 600.0)]) == 0.20414141414141418\n\n    [/EXAMPLES]\n    \"\"\"\n```\n", "entry_point": "solar_panel_efficiency", "solution": "from typing import List, Tuple\n\ndef solar_panel_efficiency(panel_data: List[Tuple[float, float, float]]) -> float:\n    \"\"\"\n    Calculate the average efficiency of solar panels based on their performance data.\n\n    This function takes a list of tuples containing solar panel performance data and\n    returns the average efficiency across all panels. Each tuple in the input list\n    represents a single panel and contains three float values: power output (in watts),\n    panel area (in square meters), and solar irradiance (in watts per square meter).\n\n\n    [EXAMPLES]\n    \n    assert candidate([(60.0, 0.6, 500.0), (70.0, 0.7, 550.0), (80.0, 0.8, 600.0), (90.0, 0.9, 650.0), (100.0, 1.0, 700.0)]) == 0.16903762903762903\n    assert candidate([(50.0, 0.5, 400.0), (60.0, 0.6, 450.0), (70.0, 0.7, 500.0), (80.0, 0.8, 550.0), (90.0, 0.9, 600.0)]) == 0.20414141414141418\n\n    [/EXAMPLES]\n    \"\"\"\n    if not panel_data:\n        return 0.0\n\n    total_efficiency = 0.0\n    for power, area, irradiance in panel_data:\n        # Calculate efficiency for each panel\n        # Efficiency = Power Output / (Panel Area * Solar Irradiance)\n        efficiency = power / (area * irradiance)\n        total_efficiency += efficiency\n\n    # Calculate average efficiency\n    average_efficiency = total_efficiency / len(panel_data)\n    return average_efficiency\n\n", "test": "def check(candidate):\n    assert candidate([(150.0, 1.2, 850.0), (175.0, 1.3, 900.0), (200.0, 1.4, 950.0), (225.0, 1.5, 1000.0), (250.0, 1.6, 1050.0)]) == 0.14916338735224183\n    assert candidate([(100.0, 1.0, 600.0), (120.0, 1.1, 650.0), (140.0, 1.2, 700.0), (160.0, 1.3, 750.0), (180.0, 1.4, 800.0)]) == 0.16519647019647016\n    assert candidate([(120.0, 1.0, 700.0), (140.0, 1.1, 750.0), (160.0, 1.2, 800.0), (180.0, 1.3, 850.0), (200.0, 1.4, 900.0)]) == 0.1658836588248353\n    assert candidate([(50.0, 0.5, 400.0), (60.0, 0.6, 450.0), (70.0, 0.7, 500.0), (80.0, 0.8, 550.0), (90.0, 0.9, 600.0)]) == 0.20414141414141418\n    assert candidate([(150.0, 1.2, 800.0), (180.0, 1.3, 900.0), (200.0, 1.4, 950.0), (220.0, 1.5, 1000.0)]) == 0.15178469009061113\n    assert candidate([(50.0, 0.5, 400.0), (75.0, 0.6, 500.0), (100.0, 0.7, 600.0)]) == 0.24603174603174605\n    assert candidate([(300.0, 1.5, 1200.0), (250.0, 1.4, 1100.0), (280.0, 1.6, 1150.0)]) == 0.1603927473492691\n    assert candidate([(400.0, 2.0, 1500.0)]) == 0.13333333333333333\n    assert candidate([(400.0, 2.0, 1500.0), (350.0, 1.8, 1400.0), (450.0, 2.2, 1600.0)]) == 0.13335437710437711\n    assert candidate([(60.0, 0.6, 500.0), (70.0, 0.7, 550.0), (80.0, 0.8, 600.0), (90.0, 0.9, 650.0), (100.0, 1.0, 700.0)]) == 0.16903762903762903\n", "language": "python"}
{"task_id": "19b54a96-151e-464b-b557-9692dcecf3626584090014844827325", "prompt": "I need to write a complete, executable function as requested. The function should be self-contained in one code block with no external dependencies beyond those imported in the problem statement. Any additional helper functions or classes will be nested within the main function.\n\n```python\nfrom typing import List\n\ndef optimize_warehouse_layout(grid: List[List[int]]) -> int:\n    \"\"\"\n    You are tasked with optimizing the layout of a warehouse to maximize the storage efficiency.\n    The warehouse is represented as a grid where each cell can be either empty (0) or contain a shelf (1).\n    Your goal is to find the largest square submatrix of shelves within the warehouse.\n\n    Parameters:\n    grid (List[List[int]]): A 2D matrix representing the warehouse layout.\n                            0 represents an empty cell, 1 represents a shelf.\n\n    Returns:\n    int: The size of the largest square submatrix of shelves.\n\n    This problem requires dynamic programming to solve efficiently.\n\n\n    [EXAMPLES]\n    \n    assert candidate([[1,1,1],[1,0,1],[1,1,1]]) == 1\n    assert candidate([[0,0,0,0,0],[0,0,0,0,0],[0,0,0,0,0],[0,0,0,0,0],[0,0,0,0,0]]) == 0\n\n    [/EXAMPLES]\n    \"\"\"\n```\n", "entry_point": "optimize_warehouse_layout", "solution": "from typing import List\n\ndef optimize_warehouse_layout(grid: List[List[int]]) -> int:\n    \"\"\"\n    You are tasked with optimizing the layout of a warehouse to maximize the storage efficiency.\n    The warehouse is represented as a grid where each cell can be either empty (0) or contain a shelf (1).\n    Your goal is to find the largest square submatrix of shelves within the warehouse.\n\n    Parameters:\n    grid (List[List[int]]): A 2D matrix representing the warehouse layout.\n                            0 represents an empty cell, 1 represents a shelf.\n\n    Returns:\n    int: The size of the largest square submatrix of shelves.\n\n    This problem requires dynamic programming to solve efficiently.\n\n\n    [EXAMPLES]\n    \n    assert candidate([[1,1,1],[1,0,1],[1,1,1]]) == 1\n    assert candidate([[0,0,0,0,0],[0,0,0,0,0],[0,0,0,0,0],[0,0,0,0,0],[0,0,0,0,0]]) == 0\n\n    [/EXAMPLES]\n    \"\"\"\n    if not grid or not grid[0]:\n        return 0\n\n    rows, cols = len(grid), len(grid[0])\n    dp = [[0] * (cols + 1) for _ in range(rows + 1)]\n    max_size = 0\n\n    for i in range(1, rows + 1):\n        for j in range(1, cols + 1):\n            if grid[i-1][j-1] == 1:\n                dp[i][j] = min(dp[i-1][j], dp[i][j-1], dp[i-1][j-1]) + 1\n                max_size = max(max_size, dp[i][j])\n\n    return max_size\n\n", "test": "def check(candidate):\n    assert candidate([[0,1,1,0],[1,1,1,1],[1,1,1,1],[0,1,1,0]]) == 2\n    assert candidate([[0,0,0],[0,0,0],[0,0,0]]) == 0\n    assert candidate([[0,0,0,0,0],[0,0,0,0,0],[0,0,0,0,0],[0,0,0,0,0],[0,0,0,0,0]]) == 0\n    assert candidate([[1,1,1],[1,0,1],[1,1,1]]) == 1\n    assert candidate([[1,1,1],[1,1,1],[1,1,1]]) == 3\n    assert candidate([[1,1],[1,1]]) == 2\n    assert candidate([[1,0,1],[0,1,0],[1,0,1]]) == 1\n    assert candidate([[0,0],[0,0]]) == 0\n", "language": "python"}
{"task_id": "dd88af44-9e10-4a14-9fff-c80b14b6c1006331369976473691405", "prompt": "Finish implementing the function as described in its docstring. Preserve the function name and its parameters. Present your complete solution in one code block.\n\n```python\ndef calculate_compound_interest(principal: float, rate: float, time: int, compounds_per_year: int) -> float:\n    \"\"\"\n    Calculate the final amount after compound interest is applied.\n\n    This function determines the total amount of money after applying compound\n    interest to a principal amount over a specified time period. It takes into\n    account the interest rate, the number of years, and the number of times\n    interest is compounded per year.\n\n    Parameters:\n    principal (float): The initial amount of money.\n    rate (float): The annual interest rate as a decimal (e.g., 0.05 for 5%).\n    time (int): The number of years the interest is applied.\n    compounds_per_year (int): The number of times interest is compounded per year.\n\n    Returns:\n    float: The final amount after compound interest, rounded to two decimal places.\n\n\n    [EXAMPLES]\n    \n    assert candidate(0, 0.07, 10, 4) == 0.0\n    assert candidate(15000, 0.08, 15, 52) == 49755.85\n\n    [/EXAMPLES]\n    \"\"\"\n```\n", "entry_point": "calculate_compound_interest", "solution": "def calculate_compound_interest(principal: float, rate: float, time: int, compounds_per_year: int) -> float:\n    \"\"\"\n    Calculate the final amount after compound interest is applied.\n\n    This function determines the total amount of money after applying compound\n    interest to a principal amount over a specified time period. It takes into\n    account the interest rate, the number of years, and the number of times\n    interest is compounded per year.\n\n    Parameters:\n    principal (float): The initial amount of money.\n    rate (float): The annual interest rate as a decimal (e.g., 0.05 for 5%).\n    time (int): The number of years the interest is applied.\n    compounds_per_year (int): The number of times interest is compounded per year.\n\n    Returns:\n    float: The final amount after compound interest, rounded to two decimal places.\n\n\n    [EXAMPLES]\n    \n    assert candidate(0, 0.07, 10, 4) == 0.0\n    assert candidate(15000, 0.08, 15, 52) == 49755.85\n\n    [/EXAMPLES]\n    \"\"\"\n    # Calculate the final amount using the compound interest formula\n    final_amount = principal * (1 + rate / compounds_per_year) ** (compounds_per_year * time)\n    \n    # Round the result to two decimal places\n    return round(final_amount, 2)\n\n", "test": "def check(candidate):\n    assert candidate(3000, 0.055, 12, 24) == 5800.0\n    assert candidate(250, 0.15, 2, 365) == 337.44\n    assert candidate(50000, 0.02, 25, 4) == 82333.42\n    assert candidate(15000, 0.08, 15, 52) == 49755.85\n    assert candidate(1000, 0.05, 5, 12) == 1283.36\n    assert candidate(1000, 1.0, 1, 1) == 2000.0\n    assert candidate(0, 0.07, 10, 4) == 0.0\n    assert candidate(1, 0.01, 100, 1) == 2.7\n    assert candidate(100, 0.10, 1, 12) == 110.47\n    assert candidate(1000000, 0.001, 5, 12) == 1005012.31\n", "language": "python"}
{"task_id": "b2aabdaa-abc5-4e5b-b146-353b51bca8a85306891559518668155", "prompt": "I need to implement the requested function fully within a single code block. I'll ensure it's executable as-is, only using the imported libraries specified in the problem. Any auxiliary functions or classes will be defined inside the main function.\n\n```python\nfrom typing import List\n\ndef optimize_study_schedule(subjects: List[str], durations: List[int], available_time: int) -> List[str]:\n    \"\"\"You are a student preparing for exams and want to optimize your study schedule.\n    Given a list of subjects, their study durations in hours, and your available study time,\n    determine the combination of subjects that maximizes your study efficiency.\n\n    Your task is to implement an algorithm that finds the optimal combination of subjects\n    that fit within your available time, maximizing the total study duration. The algorithm\n    should use dynamic programming to solve this knapsack-like problem.\n\n    Take input from the user for the list of subjects, their corresponding study durations,\n    and the total available study time. Return a list of subjects that represent the optimal\n    study schedule.\n\n\n    [EXAMPLES]\n    \n    assert candidate([\"Alpha\", \"Beta\", \"Gamma\", \"Delta\"], [3, 4, 2, 5], 11) == ['Beta', 'Gamma', 'Delta']\n    assert candidate([\"A\", \"B\", \"C\", \"D\", \"E\"], [5, 4, 3, 2, 1], 7) == ['B', 'C']\n\n    [/EXAMPLES]\n    \"\"\"\n```\n", "entry_point": "optimize_study_schedule", "solution": "from typing import List\n\ndef optimize_study_schedule(subjects: List[str], durations: List[int], available_time: int) -> List[str]:\n    \"\"\"You are a student preparing for exams and want to optimize your study schedule.\n    Given a list of subjects, their study durations in hours, and your available study time,\n    determine the combination of subjects that maximizes your study efficiency.\n\n    Your task is to implement an algorithm that finds the optimal combination of subjects\n    that fit within your available time, maximizing the total study duration. The algorithm\n    should use dynamic programming to solve this knapsack-like problem.\n\n    Take input from the user for the list of subjects, their corresponding study durations,\n    and the total available study time. Return a list of subjects that represent the optimal\n    study schedule.\n\n\n    [EXAMPLES]\n    \n    assert candidate([\"Alpha\", \"Beta\", \"Gamma\", \"Delta\"], [3, 4, 2, 5], 11) == ['Beta', 'Gamma', 'Delta']\n    assert candidate([\"A\", \"B\", \"C\", \"D\", \"E\"], [5, 4, 3, 2, 1], 7) == ['B', 'C']\n\n    [/EXAMPLES]\n    \"\"\"\n    n = len(subjects)\n    \n    # Create a 2D table for dynamic programming\n    dp = [[0 for _ in range(available_time + 1)] for _ in range(n + 1)]\n    \n    # Fill the dp table\n    for i in range(1, n + 1):\n        for j in range(available_time + 1):\n            if durations[i-1] <= j:\n                dp[i][j] = max(dp[i-1][j], dp[i-1][j-durations[i-1]] + durations[i-1])\n            else:\n                dp[i][j] = dp[i-1][j]\n    \n    # Backtrack to find the selected subjects\n    selected_subjects = []\n    i, j = n, available_time\n    \n    while i > 0 and j > 0:\n        if dp[i][j] != dp[i-1][j]:\n            selected_subjects.append(subjects[i-1])\n            j -= durations[i-1]\n        i -= 1\n    \n    # Reverse the list to get the subjects in the original order\n    selected_subjects.reverse()\n    \n    return selected_subjects\n\n\n", "test": "def check(candidate):\n    assert candidate([\"X\", \"Y\", \"Z\"], [10, 20, 30], 50) == ['Y', 'Z']\n    assert candidate([\"A\", \"B\", \"C\", \"D\", \"E\"], [2, 2, 2, 2, 2], 9) == ['A', 'B', 'C', 'D']\n    assert candidate([\"Alpha\", \"Beta\", \"Gamma\", \"Delta\"], [3, 4, 2, 5], 11) == ['Beta', 'Gamma', 'Delta']\n    assert candidate([\"A\", \"B\", \"C\", \"D\", \"E\"], [5, 4, 3, 2, 1], 7) == ['B', 'C']\n    assert candidate([\"A\", \"B\", \"C\", \"D\", \"E\"], [1, 2, 3, 4, 5], 15) == ['A', 'B', 'C', 'D', 'E']\n    assert candidate([\"History\", \"Literature\", \"Geography\", \"Economics\", \"Art\"], [3, 4, 2, 5, 1], 8) == ['History', 'Economics']\n    assert candidate([\"A\", \"B\", \"C\", \"D\", \"E\", \"F\", \"G\", \"H\", \"I\", \"J\"], [1, 2, 3, 4, 5, 6, 7, 8, 9, 10], 30) == ['A', 'B', 'C', 'D', 'E', 'G', 'H']\n    assert candidate([\"Short\", \"Medium\", \"Long\"], [1, 5, 10], 11) == ['Short', 'Long']\n    assert candidate([\"Long1\", \"Long2\"], [100, 200], 150) == ['Long1']\n    assert candidate([\"Subject1\", \"Subject2\", \"Subject3\"], [3, 3, 3], 6) == ['Subject1', 'Subject2']\n", "language": "python"}
{"task_id": "4958cb2d-4036-4652-9e83-08c93aced056-6975509843846500104", "prompt": "Complete the function implementation according to the documentation string. Present the entire function in a single code block.\n\n```python\ndef validate_isbn(isbn: str) -> bool:\n    \"\"\"\n    In a library management system, we need to validate ISBN (International Standard\n    Book Number) codes. This function checks if a given ISBN-10 is valid.\n\n    The function takes a string representing an ISBN-10 and returns True if it's\n    valid, False otherwise. An ISBN-10 is valid if the sum of 10 times the first\n    digit, 9 times the second digit, 8 times the third digit, and so on up to 1\n    time the last digit is divisible by 11.\n\n    This function demonstrates string manipulation, mathematical operations, and\n    the use of control structures for validation.\n\n\n    [EXAMPLES]\n    \n    assert candidate(\"1234567890\") == False\n    assert candidate(\"2222222222\") == True\n\n    [/EXAMPLES]\n    \"\"\"\n```\n", "entry_point": "validate_isbn", "solution": "def validate_isbn(isbn: str) -> bool:\n    \"\"\"\n    In a library management system, we need to validate ISBN (International Standard\n    Book Number) codes. This function checks if a given ISBN-10 is valid.\n\n    The function takes a string representing an ISBN-10 and returns True if it's\n    valid, False otherwise. An ISBN-10 is valid if the sum of 10 times the first\n    digit, 9 times the second digit, 8 times the third digit, and so on up to 1\n    time the last digit is divisible by 11.\n\n    This function demonstrates string manipulation, mathematical operations, and\n    the use of control structures for validation.\n\n\n    [EXAMPLES]\n    \n    assert candidate(\"1234567890\") == False\n    assert candidate(\"2222222222\") == True\n\n    [/EXAMPLES]\n    \"\"\"\n    # Remove hyphens and spaces from the ISBN\n    isbn = isbn.replace('-', '').replace(' ', '')\n\n    # Check if the ISBN has exactly 10 characters\n    if len(isbn) != 10:\n        return False\n\n    # Initialize the sum\n    total = 0\n\n    # Iterate through the first 9 digits\n    for i in range(9):\n        # Check if the character is a digit\n        if not isbn[i].isdigit():\n            return False\n        # Add to the total: digit * (10 - position)\n        total += int(isbn[i]) * (10 - i)\n\n    # Check the last character (can be 'X' for 10)\n    if isbn[9] == 'X':\n        total += 10\n    elif isbn[9].isdigit():\n        total += int(isbn[9])\n    else:\n        return False\n\n    # Check if the total is divisible by 11\n    return total % 11 == 0\n\n", "test": "def check(candidate):\n    assert candidate(\"0306406151\") == False\n    assert candidate(\"1234567890\") == False\n    assert candidate(\"2222222222\") == True\n    assert candidate(\"123456789X\") == True\n    assert candidate(\"1111111111\") == True\n    assert candidate(\"03064 06152\") == True\n    assert candidate(\"9999999999\") == True\n    assert candidate(\"3598215089\") == False\n    assert candidate(\"3598215088\") == True\n    assert candidate(\"0-306-40615-2\") == True\n", "language": "python"}
{"task_id": "f7ca2193-2fbf-45a5-aa87-ab97f3a5b6d0-5134364921339964353", "prompt": "For this task, I'll complete the specified function in one self-contained code block. I won't add any code outside the function, and I'll only use libraries imported in the problem. Any additional functions or classes will be nested within the main function. My solution will be delivered as one executable code block.\n\n```python\ndef generate_maze_paths(n: int, m: int) -> int:\n    \"\"\"\n    In a rectangular maze of size n x m, a robot starts from the top-left corner and wants to reach the bottom-right corner.\n    The robot can only move either down or right at any point in time. Calculate the total number of unique paths the robot can take to reach its destination.\n\n    This function utilizes combinatorics and dynamic programming concepts to solve the problem efficiently.\n\n\n    [EXAMPLES]\n    \n    assert candidate(15, 3) == 120\n    assert candidate(8, 4) == 120\n\n    [/EXAMPLES]\n    \"\"\"\n```\n", "entry_point": "generate_maze_paths", "solution": "def generate_maze_paths(n: int, m: int) -> int:\n    \"\"\"\n    In a rectangular maze of size n x m, a robot starts from the top-left corner and wants to reach the bottom-right corner.\n    The robot can only move either down or right at any point in time. Calculate the total number of unique paths the robot can take to reach its destination.\n\n    This function utilizes combinatorics and dynamic programming concepts to solve the problem efficiently.\n\n\n    [EXAMPLES]\n    \n    assert candidate(15, 3) == 120\n    assert candidate(8, 4) == 120\n\n    [/EXAMPLES]\n    \"\"\"\n    def factorial(x: int) -> int:\n        if x == 0 or x == 1:\n            return 1\n        return x * factorial(x - 1)\n\n    # Total steps needed = (n-1) steps down + (m-1) steps right\n    total_steps = (n - 1) + (m - 1)\n    \n    # Number of ways to choose (n-1) down steps from total steps\n    # This is equivalent to choosing (m-1) right steps from total steps\n    # We use the combination formula: C(total_steps, n-1) or C(total_steps, m-1)\n    paths = factorial(total_steps) // (factorial(n - 1) * factorial(m - 1))\n    \n    return paths\n\n", "test": "def check(candidate):\n    assert candidate(2, 2) == 2\n    assert candidate(6, 9) == 1287\n    assert candidate(5, 2) == 5\n    assert candidate(10, 10) == 48620\n    assert candidate(100, 100) == 22750883079422934966181954039568885395604168260154104734000\n    assert candidate(15, 3) == 120\n    assert candidate(1, 1) == 1\n    assert candidate(7, 3) == 28\n    assert candidate(1, 10) == 1\n    assert candidate(8, 4) == 120\n", "language": "python"}
{"task_id": "b149fa02-bd07-4250-9525-347bd3aed144-1630986664989420859", "prompt": "I need to complete a specific function such that it's executable within a single code block. All code should be contained within this function. I'll only use libraries that are already imported. Any additional functions or classes required will be defined inside the main function, not outside.\n\n```python\nfrom typing import List\n\ndef decode_alien_message(transmission: str, key: List[int]) -> str:\n    \"\"\"\n    An alien civilization has sent a coded message to Earth. The message is a string of lowercase letters,\n    and the key to decode it is a list of integers. Each integer in the key represents the number of positions\n    each corresponding letter in the transmission should be shifted forward in the alphabet.\n\n    Write a function that takes the coded transmission and the decryption key as input, and returns the\n    decoded message. If a shift goes beyond 'z', it should wrap around to 'a'.\n\n\n    [EXAMPLES]\n    \n    assert candidate(\"abc\", [1, 1, 1]) == 'bcd'\n    assert candidate(\"xyz\", [3, 3, 3]) == 'abc'\n\n    [/EXAMPLES]\n    \"\"\"\n```\n", "entry_point": "decode_alien_message", "solution": "from typing import List\n\ndef decode_alien_message(transmission: str, key: List[int]) -> str:\n    \"\"\"\n    An alien civilization has sent a coded message to Earth. The message is a string of lowercase letters,\n    and the key to decode it is a list of integers. Each integer in the key represents the number of positions\n    each corresponding letter in the transmission should be shifted forward in the alphabet.\n\n    Write a function that takes the coded transmission and the decryption key as input, and returns the\n    decoded message. If a shift goes beyond 'z', it should wrap around to 'a'.\n\n\n    [EXAMPLES]\n    \n    assert candidate(\"abc\", [1, 1, 1]) == 'bcd'\n    assert candidate(\"xyz\", [3, 3, 3]) == 'abc'\n\n    [/EXAMPLES]\n    \"\"\"\n    def shift_letter(letter: str, shift: int) -> str:\n        \"\"\"Helper function to shift a single letter by a given amount.\"\"\"\n        ascii_offset = ord('a')\n        return chr((ord(letter) - ascii_offset + shift) % 26 + ascii_offset)\n\n    # Ensure the key is long enough by repeating it if necessary\n    key_length = len(key)\n    if key_length < len(transmission):\n        key = key * (len(transmission) // key_length + 1)\n\n    # Decode the message\n    decoded_message = \"\"\n    for i, char in enumerate(transmission):\n        decoded_message += shift_letter(char, key[i])\n\n    return decoded_message\n\n", "test": "def check(candidate):\n    assert candidate(\"test\", [0, 0, 0, 0]) == 'test'\n    assert candidate(\"edgecase\", [25, 24, 23, 22, 21, 20, 19, 18]) == 'dbdaxulw'\n    assert candidate(\"\", []) == ''\n    assert candidate(\"aa\", [0, 25]) == 'az'\n    assert candidate(\"shortkey\", [1]) == 'tipsulfz'\n    assert candidate(\"smallstring\", [1000000, 2000000]) == 'goonzuhtwpu'\n    assert candidate(\"repeatedkey\", [1, 2, 3]) == 'sgsfcwffnfa'\n    assert candidate(\"largeshift\", [100, 200, 300, 400]) == 'hsfqakvsbl'\n    assert candidate(\"abc\", [1, 1, 1]) == 'bcd'\n    assert candidate(\"xyz\", [3, 3, 3]) == 'abc'\n", "language": "python"}
{"task_id": "a423cdbc-648a-4aec-9844-a25abba862613464317623548581773", "prompt": "Let me complete that function for you based on the docstring. The entire implementation will be in a single code block.\n\n```python\nfrom typing import List, Tuple\n\ndef compress_genome(dna_sequence: str) -> List[Tuple[str, int]]:\n    \"\"\"\n    You're working on a genome compression algorithm for a biotech company.\n    Given a DNA sequence (a string containing only 'A', 'C', 'G', and 'T'),\n    compress it by grouping consecutive identical nucleotides.\n    \n    Return a list of tuples, where each tuple contains a nucleotide and its count.\n    The compressed representation should maintain the original order of nucleotides.\n    \n\n    [EXAMPLES]\n    \n    assert candidate(\"AATTCCGG\") == [('A', 2), ('T', 2), ('C', 2), ('G', 2)]\n    assert candidate(\"AAAAAAAATTTTTTTTCCCCCCCCGGGGGGGG\") == [('A', 8), ('T', 8), ('C', 8), ('G', 8)]\n\n    [/EXAMPLES]\n    \"\"\"\n```\n", "entry_point": "compress_genome", "solution": "from typing import List, Tuple\n\ndef compress_genome(dna_sequence: str) -> List[Tuple[str, int]]:\n    \"\"\"\n    You're working on a genome compression algorithm for a biotech company.\n    Given a DNA sequence (a string containing only 'A', 'C', 'G', and 'T'),\n    compress it by grouping consecutive identical nucleotides.\n    \n    Return a list of tuples, where each tuple contains a nucleotide and its count.\n    The compressed representation should maintain the original order of nucleotides.\n    \n\n    [EXAMPLES]\n    \n    assert candidate(\"AATTCCGG\") == [('A', 2), ('T', 2), ('C', 2), ('G', 2)]\n    assert candidate(\"AAAAAAAATTTTTTTTCCCCCCCCGGGGGGGG\") == [('A', 8), ('T', 8), ('C', 8), ('G', 8)]\n\n    [/EXAMPLES]\n    \"\"\"\n    if not dna_sequence:\n        return []\n\n    compressed = []\n    current_nucleotide = dna_sequence[0]\n    count = 1\n\n    for nucleotide in dna_sequence[1:]:\n        if nucleotide == current_nucleotide:\n            count += 1\n        else:\n            compressed.append((current_nucleotide, count))\n            current_nucleotide = nucleotide\n            count = 1\n\n    # Add the last group\n    compressed.append((current_nucleotide, count))\n\n    return compressed\n\n", "test": "def check(candidate):\n    assert candidate(\"TTTT\") == [('T', 4)]\n    assert candidate(\"GGGG\") == [('G', 4)]\n    assert candidate(\"TTTAAACCCGGG\") == [('T', 3), ('A', 3), ('C', 3), ('G', 3)]\n    assert candidate(\"\") == []\n    assert candidate(\"ATCGATCGATCG\") == [('A', 1), ('T', 1), ('C', 1), ('G', 1), ('A', 1), ('T', 1), ('C', 1), ('G', 1), ('A', 1), ('T', 1), ('C', 1), ('G', 1)]\n    assert candidate(\"AATTCCGG\") == [('A', 2), ('T', 2), ('C', 2), ('G', 2)]\n    assert candidate(\"T\") == [('T', 1)]\n    assert candidate(\"AAAAAAAATTTTTTTTCCCCCCCCGGGGGGGG\") == [('A', 8), ('T', 8), ('C', 8), ('G', 8)]\n", "language": "python"}
{"task_id": "ab61702c-ccbf-42be-8a4f-b8bc343dbc66-4517490468362677534", "prompt": "Complete the function based on the docstring provided. Here's the implementation in a single code block:\n\n```python\nimport re\nfrom typing import List\n\ndef parse_log_file(log_content: str) -> List[dict]:\n    \"\"\"\n    Parse a log file and extract relevant information into a structured format.\n\n    This function takes a string containing log file content and parses it to extract\n    information such as timestamp, log level, and message. It returns a list of\n    dictionaries, where each dictionary represents a log entry with structured information.\n\n\n    [EXAMPLES]\n    \n    assert candidate(\"2023-05-18 12:00:00 [INFO] Application update available: v2.0.1\") == [{'timestamp': '2023-05-18 12:00:00', 'level': 'INFO', 'message': 'Application update available: v2.0.1'}]\n    assert candidate(\"2023-05-10 07:30:00 [ERROR] Failed to connect to external API\\n2023-05-10 07:30:05 [INFO] Retrying connection\") == [{'timestamp': '2023-05-10 07:30:00', 'level': 'ERROR', 'message': 'Failed to connect to external API'}, {'timestamp': '2023-05-10 07:30:05', 'level': 'INFO', 'message': 'Retrying connection'}]\n\n    [/EXAMPLES]\n    \"\"\"\n```\n", "entry_point": "parse_log_file", "solution": "import re\nfrom typing import List\n\ndef parse_log_file(log_content: str) -> List[dict]:\n    \"\"\"\n    Parse a log file and extract relevant information into a structured format.\n\n    This function takes a string containing log file content and parses it to extract\n    information such as timestamp, log level, and message. It returns a list of\n    dictionaries, where each dictionary represents a log entry with structured information.\n\n\n    [EXAMPLES]\n    \n    assert candidate(\"2023-05-18 12:00:00 [INFO] Application update available: v2.0.1\") == [{'timestamp': '2023-05-18 12:00:00', 'level': 'INFO', 'message': 'Application update available: v2.0.1'}]\n    assert candidate(\"2023-05-10 07:30:00 [ERROR] Failed to connect to external API\\n2023-05-10 07:30:05 [INFO] Retrying connection\") == [{'timestamp': '2023-05-10 07:30:00', 'level': 'ERROR', 'message': 'Failed to connect to external API'}, {'timestamp': '2023-05-10 07:30:05', 'level': 'INFO', 'message': 'Retrying connection'}]\n\n    [/EXAMPLES]\n    \"\"\"\n    # Define the regular expression pattern to match log entries\n    pattern = r'(\\d{4}-\\d{2}-\\d{2} \\d{2}:\\d{2}:\\d{2}) \\[(\\w+)\\] (.+)'\n\n    # Split the log content into individual lines\n    log_lines = log_content.split('\\n')\n\n    # Initialize an empty list to store the parsed log entries\n    parsed_logs = []\n\n    # Iterate through each line in the log content\n    for line in log_lines:\n        # Skip empty lines\n        if not line.strip():\n            continue\n\n        # Use regex to match and extract information from the log line\n        match = re.match(pattern, line)\n\n        if match:\n            # Extract timestamp, level, and message from the matched groups\n            timestamp, level, message = match.groups()\n\n            # Create a dictionary with the extracted information\n            log_entry = {\n                'timestamp': timestamp,\n                'level': level,\n                'message': message\n            }\n\n            # Append the log entry to the list of parsed logs\n            parsed_logs.append(log_entry)\n\n    return parsed_logs\n\n", "test": "def check(candidate):\n    assert candidate(\"2023-05-03 14:45:00 [DEBUG] Debugging information\\n2023-05-03 14:46:30 [INFO] Process completed\") == [{'timestamp': '2023-05-03 14:45:00', 'level': 'DEBUG', 'message': 'Debugging information'}, {'timestamp': '2023-05-03 14:46:30', 'level': 'INFO', 'message': 'Process completed'}]\n    assert candidate(\"2023-05-17 04:20:15 [INFO] Scheduled task 'cleanup' started\\n2023-05-17 04:25:30 [INFO] Scheduled task 'cleanup' completed\") == [{'timestamp': '2023-05-17 04:20:15', 'level': 'INFO', 'message': \"Scheduled task 'cleanup' started\"}, {'timestamp': '2023-05-17 04:25:30', 'level': 'INFO', 'message': \"Scheduled task 'cleanup' completed\"}]\n    assert candidate(\"2023-05-11 19:45:30 [DEBUG] Cache hit rate: 95%\") == [{'timestamp': '2023-05-11 19:45:30', 'level': 'DEBUG', 'message': 'Cache hit rate: 95%'}]\n    assert candidate(\"2023-05-10 07:30:00 [ERROR] Failed to connect to external API\\n2023-05-10 07:30:05 [INFO] Retrying connection\") == [{'timestamp': '2023-05-10 07:30:00', 'level': 'ERROR', 'message': 'Failed to connect to external API'}, {'timestamp': '2023-05-10 07:30:05', 'level': 'INFO', 'message': 'Retrying connection'}]\n    assert candidate(\"2023-05-02 09:15:30 [WARNING] Disk space low\\n2023-05-02 09:16:45 [INFO] Backup started\") == [{'timestamp': '2023-05-02 09:15:30', 'level': 'WARNING', 'message': 'Disk space low'}, {'timestamp': '2023-05-02 09:16:45', 'level': 'INFO', 'message': 'Backup started'}]\n    assert candidate(\"\") == []\n    assert candidate(\"2023-05-18 12:00:00 [INFO] Application update available: v2.0.1\") == [{'timestamp': '2023-05-18 12:00:00', 'level': 'INFO', 'message': 'Application update available: v2.0.1'}]\n    assert candidate(\"2023-05-12 13:00:00 [INFO] Server maintenance started\\n2023-05-12 14:30:00 [INFO] Server maintenance completed\") == [{'timestamp': '2023-05-12 13:00:00', 'level': 'INFO', 'message': 'Server maintenance started'}, {'timestamp': '2023-05-12 14:30:00', 'level': 'INFO', 'message': 'Server maintenance completed'}]\n    assert candidate(\"2023-05-16 21:30:00 [CRITICAL] Database corruption detected\\n2023-05-16 21:30:05 [INFO] Starting database recovery\") == [{'timestamp': '2023-05-16 21:30:00', 'level': 'CRITICAL', 'message': 'Database corruption detected'}, {'timestamp': '2023-05-16 21:30:05', 'level': 'INFO', 'message': 'Starting database recovery'}]\n    assert candidate(\"2023-05-14 10:00:00 [INFO] New user registered: john_doe@example.com\") == [{'timestamp': '2023-05-14 10:00:00', 'level': 'INFO', 'message': 'New user registered: john_doe@example.com'}]\n", "language": "python"}
{"task_id": "ffe897bf-157b-4fe8-8433-731b808cbb50-6691539954434092908", "prompt": "Acting as a coding assistant, I'll complete the provided function to be executable in a code block. I'll utilize only the libraries imported in the problem statement and will nest any additional functions or classes within the given function.\n\n```python\nfrom typing import List\n\ndef decode_alien_message(signal: List[int], key: int) -> str:\n    \"\"\"\n    As a cryptographer working for SETI, you've intercepted an alien signal consisting of a list of integers.\n    Your task is to decode this message using a given key. The decoding process involves using bitwise operations\n    and string manipulation to convert the signal into readable text.\n\n    The function takes two parameters:\n    - signal: A list of integers representing the encoded alien message\n    - key: An integer used as the decryption key\n\n    The function should return the decoded message as a string.\n\n\n    [EXAMPLES]\n    \n    assert candidate([128, 129, 130], 128) == '\\x00\\x01\\x02'\n    assert candidate(list(range(32, 127)), 42) == '\\n\\x0b\\x08\\t\\x0e\\x0f\\x0c\\r\\x02\\x03\\x00\\x01\\x06\\x07\\x04\\x05\\x1a\\x1b\\x18\\x19\\x1e\\x1f\\x1c\\x1d\\x12\\x13\\x10\\x11\\x16\\x17\\x14\\x15jkhinolmbc`afgdez{xy~\\x7f|}rspqvwtuJKHINOLMBC@AFGDEZ[XY^_\\\\]RSPQVWT'\n\n    [/EXAMPLES]\n    \"\"\"\n```\n", "entry_point": "decode_alien_message", "solution": "from typing import List\n\ndef decode_alien_message(signal: List[int], key: int) -> str:\n    \"\"\"\n    As a cryptographer working for SETI, you've intercepted an alien signal consisting of a list of integers.\n    Your task is to decode this message using a given key. The decoding process involves using bitwise operations\n    and string manipulation to convert the signal into readable text.\n\n    The function takes two parameters:\n    - signal: A list of integers representing the encoded alien message\n    - key: An integer used as the decryption key\n\n    The function should return the decoded message as a string.\n\n\n    [EXAMPLES]\n    \n    assert candidate([128, 129, 130], 128) == '\\x00\\x01\\x02'\n    assert candidate(list(range(32, 127)), 42) == '\\n\\x0b\\x08\\t\\x0e\\x0f\\x0c\\r\\x02\\x03\\x00\\x01\\x06\\x07\\x04\\x05\\x1a\\x1b\\x18\\x19\\x1e\\x1f\\x1c\\x1d\\x12\\x13\\x10\\x11\\x16\\x17\\x14\\x15jkhinolmbc`afgdez{xy~\\x7f|}rspqvwtuJKHINOLMBC@AFGDEZ[XY^_\\\\]RSPQVWT'\n\n    [/EXAMPLES]\n    \"\"\"\n    def decode_char(encoded_char: int) -> str:\n        # XOR the encoded character with the key to get the ASCII value\n        ascii_value = encoded_char ^ key\n        # Convert ASCII value to character\n        return chr(ascii_value)\n\n    # Decode each integer in the signal and join the resulting characters\n    decoded_message = ''.join(decode_char(char) for char in signal)\n    return decoded_message\n\n", "test": "def check(candidate):\n    assert candidate([90, 89, 88, 87], 5) == '_\\\\]R'\n    assert candidate([87, 111, 114, 108, 100], 10) == ']exfn'\n    assert candidate(list(range(32, 127)), 42) == '\\n\\x0b\\x08\\t\\x0e\\x0f\\x0c\\r\\x02\\x03\\x00\\x01\\x06\\x07\\x04\\x05\\x1a\\x1b\\x18\\x19\\x1e\\x1f\\x1c\\x1d\\x12\\x13\\x10\\x11\\x16\\x17\\x14\\x15jkhinolmbc`afgdez{xy~\\x7f|}rspqvwtuJKHINOLMBC@AFGDEZ[XY^_\\\\]RSPQVWT'\n    assert candidate([32, 33, 34, 35, 36], 100) == 'DEFG@'\n    assert candidate([1, 2, 3, 4, 5], 1000000) == '\\U000f4241\\U000f4242\\U000f4243\\U000f4244\\U000f4245'\n    assert candidate([128, 129, 130], 128) == '\\x00\\x01\\x02'\n    assert candidate([65, 90, 97, 122], 26) == '[@{`'\n    assert candidate([0], 0) == '\\x00'\n    assert candidate([2**31 - 1], 2**31 - 1) == '\\x00'\n    assert candidate([33, 64, 35, 36, 37], 2) == \"#B!&'\"\n", "language": "python"}
{"task_id": "80066986-24b3-4de9-8ea2-93ccbc8e4e6b4437748629811927336", "prompt": "You are to act as a coding assistant who completes functions that can run without modification. Place all your code within the provided function block. Only use libraries that are already imported. If you need additional helper functions or class definitions, include them inside the main function.\n\n```python\ndef compress_dna_sequence(sequence: str) -> str:\n    \"\"\"\n    A bioinformatics researcher wants to compress DNA sequences to save storage space.\n    The compression algorithm works by replacing consecutive repeated nucleotides\n    with the number of repetitions followed by the nucleotide.\n\n    For example, 'AAAAACCCCCGGT' would be compressed to '5A5C2G1T'.\n    Single occurrences should be represented as '1X' where X is the nucleotide.\n\n    The function should only accept valid DNA sequences (containing only A, C, G, and T)\n    and should raise a ValueError for invalid inputs.\n\n\n    [EXAMPLES]\n    \n    assert candidate('T') == '1T'\n    assert candidate('ACGT') == '1A1C1G1T'\n\n    [/EXAMPLES]\n    \"\"\"\n```\n", "entry_point": "compress_dna_sequence", "solution": "def compress_dna_sequence(sequence: str) -> str:\n    \"\"\"\n    A bioinformatics researcher wants to compress DNA sequences to save storage space.\n    The compression algorithm works by replacing consecutive repeated nucleotides\n    with the number of repetitions followed by the nucleotide.\n\n    For example, 'AAAAACCCCCGGT' would be compressed to '5A5C2G1T'.\n    Single occurrences should be represented as '1X' where X is the nucleotide.\n\n    The function should only accept valid DNA sequences (containing only A, C, G, and T)\n    and should raise a ValueError for invalid inputs.\n\n\n    [EXAMPLES]\n    \n    assert candidate('T') == '1T'\n    assert candidate('ACGT') == '1A1C1G1T'\n\n    [/EXAMPLES]\n    \"\"\"\n    if not sequence:\n        return \"\"\n    \n    if not all(nucleotide in 'ACGT' for nucleotide in sequence):\n        raise ValueError(\"Invalid DNA sequence. Only A, C, G, and T are allowed.\")\n\n    compressed = []\n    count = 1\n    current_nucleotide = sequence[0]\n\n    for nucleotide in sequence[1:]:\n        if nucleotide == current_nucleotide:\n            count += 1\n        else:\n            compressed.append(f\"{count}{current_nucleotide}\")\n            current_nucleotide = nucleotide\n            count = 1\n\n    compressed.append(f\"{count}{current_nucleotide}\")\n\n    return ''.join(compressed)\n\n", "test": "def check(candidate):\n    assert candidate('A' * 100) == '100A'\n    assert candidate('GGGGGGGGGGGGGGGGGGGG') == '20G'\n    assert candidate('AAAAACCCCCGGT') == '5A5C2G1T'\n    assert candidate('ACGT') == '1A1C1G1T'\n    assert candidate('ACTGACTGACTGACTGACTG') == '1A1C1T1G1A1C1T1G1A1C1T1G1A1C1T1G1A1C1T1G'\n    assert candidate('T') == '1T'\n    assert candidate('ATGCATGC') == '1A1T1G1C1A1T1G1C'\n    assert candidate('AAAAAAAAAACCCCCCCCCCGGGGGGGGGGTTTTTTTTTT') == '10A10C10G10T'\n    assert candidate('') == ''\n    assert candidate('AGCT' * 10) == '1A1G1C1T1A1G1C1T1A1G1C1T1A1G1C1T1A1G1C1T1A1G1C1T1A1G1C1T1A1G1C1T1A1G1C1T1A1G1C1T'\n", "language": "python"}
{"task_id": "cbb5fc30-3e31-4ba8-9d63-b3c9946eefee-917730365972332482", "prompt": "Complete the function implementation following the requirements in the docstring. The function name and parameters should stay as given, with the full implementation presented in a single code block.\n\n```python\ndef morse_code_translator(text: str, to_morse: bool = True) -> str:\n    \"\"\"\n    Translate between English text and Morse code.\n    The function can convert from English to Morse code or vice versa.\n\n    Args:\n    text (str): The input text to be translated.\n    to_morse (bool): If True, translate from English to Morse code.\n                     If False, translate from Morse code to English.\n\n    Returns:\n    str: The translated text.\n\n\n    [EXAMPLES]\n    \n    assert candidate(\"  \") == '   '\n    assert candidate(\"HELLO WORLD\") == '.... . .-.. .-.. ---   .-- --- .-. .-.. -..'\n\n    [/EXAMPLES]\n    \"\"\"\n```\n", "entry_point": "morse_code_translator", "solution": "def morse_code_translator(text: str, to_morse: bool = True) -> str:\n    \"\"\"\n    Translate between English text and Morse code.\n    The function can convert from English to Morse code or vice versa.\n\n    Args:\n    text (str): The input text to be translated.\n    to_morse (bool): If True, translate from English to Morse code.\n                     If False, translate from Morse code to English.\n\n    Returns:\n    str: The translated text.\n\n\n    [EXAMPLES]\n    \n    assert candidate(\"  \") == '   '\n    assert candidate(\"HELLO WORLD\") == '.... . .-.. .-.. ---   .-- --- .-. .-.. -..'\n\n    [/EXAMPLES]\n    \"\"\"\n    morse_code_dict = {\n        'A': '.-', 'B': '-...', 'C': '-.-.', 'D': '-..', 'E': '.', 'F': '..-.',\n        'G': '--.', 'H': '....', 'I': '..', 'J': '.---', 'K': '-.-', 'L': '.-..',\n        'M': '--', 'N': '-.', 'O': '---', 'P': '.--.', 'Q': '--.-', 'R': '.-.',\n        'S': '...', 'T': '-', 'U': '..-', 'V': '...-', 'W': '.--', 'X': '-..-',\n        'Y': '-.--', 'Z': '--..', '0': '-----', '1': '.----', '2': '..---',\n        '3': '...--', '4': '....-', '5': '.....', '6': '-....', '7': '--...',\n        '8': '---..', '9': '----.', ' ': ' '\n    }\n    \n    reverse_morse_code_dict = {v: k for k, v in morse_code_dict.items()}\n    \n    if to_morse:\n        return ' '.join(morse_code_dict.get(char.upper(), '') for char in text)\n    else:\n        return ''.join(reverse_morse_code_dict.get(code, '') for code in text.split())\n\n\n", "test": "def check(candidate):\n    assert candidate(\"... --- ...\") == '            '\n    assert candidate(\".... . .-.. .-.. --- .-- --- .-. .-.. -..\", False) == 'HELLOWORLD'\n    assert candidate(\"HELLO WORLD\") == '.... . .-.. .-.. ---   .-- --- .-. .-.. -..'\n    assert candidate(\"SOS\") == '... --- ...'\n    assert candidate(\"  \") == '   '\n    assert candidate(\"a\") == '.-'\n    assert candidate(\".-.-.- .--.-. -.--. -.--.- ..--.-\", False) == ''\n    assert candidate(\"\", False) == ''\n    assert candidate(\"- .... . --.- ..- .. -.-. -.- -... .-. --- .-- -. ..-. --- -..- .--- ..- -- .--. ... --- ...- . .-. - .... . .-.. .- --.. -.-- -.. --- --.\", False) == 'THEQUICKBROWNFOXJUMPSOVERTHELAZYDOG'\n    assert candidate(\"The quick brown fox jumps over the lazy dog\") == '- .... .   --.- ..- .. -.-. -.-   -... .-. --- .-- -.   ..-. --- -..-   .--- ..- -- .--. ...   --- ...- . .-.   - .... .   .-.. .- --.. -.--   -.. --- --.'\n", "language": "python"}
{"task_id": "8728ec92-994d-40be-8d40-855e94799644-4186134555469423839", "prompt": "Complete the function provided in a single executable code block. Don't add any code outside the function scope. Stick to using only the libraries that are imported in the problem. If additional functions or classes are needed, define them inside the main function.\n\n```python\nfrom typing import List\nfrom typing import List, Tuple\n\ndef analyze_stock_prices(prices: List[int]) -> Tuple[int, int]:\n    \"\"\"\n    An investment analyst wants to find the best days to buy and sell a stock.\n    Given a list of stock prices for consecutive days, determine the pair of days\n    where buying on the first day and selling on the second day would yield the maximum profit.\n\n    This function uses list traversal and comparison operations.\n\n    Args:\n    prices (List[int]): A list of integers representing daily stock prices.\n\n    Returns:\n    Tuple[int, int]: A tuple containing the best day to buy and the best day to sell.\n\n\n    [EXAMPLES]\n    \n    assert candidate([100, 180, 260, 310, 40, 535, 695]) == (4, 6)\n    assert candidate([1, 1, 1, 1, 1]) == (0, 0)\n\n    [/EXAMPLES]\n    \"\"\"\n```\n", "entry_point": "analyze_stock_prices", "solution": "from typing import List\nfrom typing import List, Tuple\n\ndef analyze_stock_prices(prices: List[int]) -> Tuple[int, int]:\n    \"\"\"\n    An investment analyst wants to find the best days to buy and sell a stock.\n    Given a list of stock prices for consecutive days, determine the pair of days\n    where buying on the first day and selling on the second day would yield the maximum profit.\n\n    This function uses list traversal and comparison operations.\n\n    Args:\n    prices (List[int]): A list of integers representing daily stock prices.\n\n    Returns:\n    Tuple[int, int]: A tuple containing the best day to buy and the best day to sell.\n\n\n    [EXAMPLES]\n    \n    assert candidate([100, 180, 260, 310, 40, 535, 695]) == (4, 6)\n    assert candidate([1, 1, 1, 1, 1]) == (0, 0)\n\n    [/EXAMPLES]\n    \"\"\"\n    if len(prices) < 2:\n        return (0, 0)\n\n    min_price_day = 0\n    max_profit_buy_day = 0\n    max_profit_sell_day = 0\n    max_profit = 0\n\n    for current_day in range(1, len(prices)):\n        # Update the day with minimum price if we find a lower price\n        if prices[current_day] < prices[min_price_day]:\n            min_price_day = current_day\n        else:\n            # Calculate the profit if we sell on the current day\n            current_profit = prices[current_day] - prices[min_price_day]\n            # Update max profit and buy/sell days if we find a better profit\n            if current_profit > max_profit:\n                max_profit = current_profit\n                max_profit_buy_day = min_price_day\n                max_profit_sell_day = current_day\n\n    return (max_profit_buy_day, max_profit_sell_day)\n\n", "test": "def check(candidate):\n    assert candidate([3, 2, 6, 5, 0, 3]) == (1, 2)\n    assert candidate([1, 1, 1, 1, 1]) == (0, 0)\n    assert candidate([5, 0, 0, 0, 0]) == (0, 0)\n    assert candidate([2, 1, 2, 1, 0, 1, 2]) == (4, 6)\n    assert candidate([1, 2, 4, 2, 5, 7, 2, 4, 9, 0]) == (0, 8)\n    assert candidate([2, 1]) == (0, 0)\n    assert candidate([7, 6, 4, 3, 1]) == (0, 0)\n    assert candidate([3, 3, 5, 0, 0, 3, 1, 4]) == (3, 7)\n    assert candidate([100, 180, 260, 310, 40, 535, 695]) == (4, 6)\n    assert candidate([1, 1, 0]) == (0, 0)\n", "language": "python"}
{"task_id": "3f3533b0-5ba8-4159-9ac9-b648bc362d1f-8975680203237758286", "prompt": "I'll implement the rest of the function based on the provided docstring. The function will be delivered in one complete code block with the original function name and arguments preserved.\n\n```python\ndef encrypt_message(message: str, key: int) -> str:\n    \"\"\"\n    A secret agent needs to encrypt a message using a simple substitution cipher.\n    Each letter in the message is shifted forward in the alphabet by the number of positions specified by the key.\n    If the shift goes beyond 'Z', it wraps around to 'A'.\n    \n    The function should preserve spaces and punctuation, and maintain the case of the original letters.\n    It should only encrypt alphabetic characters.\n\n\n    [EXAMPLES]\n    \n    assert candidate(\"The quick brown fox jumps over the lazy dog.\", 7) == 'Aol xbpjr iyvdu mve qbtwz vcly aol shgf kvn.'\n    assert candidate(\"Wrap around test\", 26) == 'Wrap around test'\n\n    [/EXAMPLES]\n    \"\"\"\n```\n", "entry_point": "encrypt_message", "solution": "def encrypt_message(message: str, key: int) -> str:\n    \"\"\"\n    A secret agent needs to encrypt a message using a simple substitution cipher.\n    Each letter in the message is shifted forward in the alphabet by the number of positions specified by the key.\n    If the shift goes beyond 'Z', it wraps around to 'A'.\n    \n    The function should preserve spaces and punctuation, and maintain the case of the original letters.\n    It should only encrypt alphabetic characters.\n\n\n    [EXAMPLES]\n    \n    assert candidate(\"The quick brown fox jumps over the lazy dog.\", 7) == 'Aol xbpjr iyvdu mve qbtwz vcly aol shgf kvn.'\n    assert candidate(\"Wrap around test\", 26) == 'Wrap around test'\n\n    [/EXAMPLES]\n    \"\"\"\n    def shift_char(char: str, shift: int) -> str:\n        if not char.isalpha():\n            return char\n        \n        ascii_offset = 65 if char.isupper() else 97\n        shifted = (ord(char) - ascii_offset + shift) % 26\n        return chr(shifted + ascii_offset)\n\n    return ''.join(shift_char(char, key) for char in message)\n\n", "test": "def check(candidate):\n    assert candidate(\"The quick brown fox jumps over the lazy dog.\", 7) == 'Aol xbpjr iyvdu mve qbtwz vcly aol shgf kvn.'\n    assert candidate(\"abcdefghijklmnopqrstuvwxyz\", 1) == 'bcdefghijklmnopqrstuvwxyza'\n    assert candidate(\"This is a very long message that needs to be encrypted securely.\", 11) == 'Estd td l gpcj wzyr xpddlrp esle yppod ez mp pyncjaepo dpnfcpwj.'\n    assert candidate(\"ABCDEFGHIJKLMNOPQRSTUVWXYZ\", 25) == 'ZABCDEFGHIJKLMNOPQRSTUVWXY'\n    assert candidate(\"Hello\", 0) == 'Hello'\n    assert candidate(\"Secret Agent 007\", 15) == 'Htrgti Pvtci 007'\n    assert candidate(\"ZzYyXxWwVvUu\", 5) == 'EeDdCcBbAaZz'\n    assert candidate(\"!@#$%^&*()\", 8) == '!@#$%^&*()'\n    assert candidate(\"Wrap around test\", 26) == 'Wrap around test'\n    assert candidate(\"  Multiple   Spaces  \", 7) == '  Tbsapwsl   Zwhjlz  '\n", "language": "python"}
{"task_id": "e9dc674e-4560-47a4-97e8-c03ad30848458353534986435107507", "prompt": "Implement the function body according to the docstring instructions. Keep the function name and parameters unchanged, and present the complete solution in one unified code block.\n\n```python\ndef calculate_freight_cost(distance: float, weight: float) -> float:\n    \"\"\"\n    A logistics company needs to calculate shipping costs for various packages.\n    This function computes the freight cost based on the distance and weight of the package.\n    \n    The cost is calculated using a tiered system:\n    - Base rate: $10 for the first 100 miles\n    - $0.05 per mile for each additional mile\n    - Weight surcharge: $0.10 per pound for packages over 50 pounds\n    \n    Use the divmod function to separate the distance into base and additional miles.\n    \n\n    [EXAMPLES]\n    \n    assert candidate(150.5, 55.5) == 13.08\n    assert candidate(300, 40) == 30.0\n\n    [/EXAMPLES]\n    \"\"\"\n```\n", "entry_point": "calculate_freight_cost", "solution": "def calculate_freight_cost(distance: float, weight: float) -> float:\n    \"\"\"\n    A logistics company needs to calculate shipping costs for various packages.\n    This function computes the freight cost based on the distance and weight of the package.\n    \n    The cost is calculated using a tiered system:\n    - Base rate: $10 for the first 100 miles\n    - $0.05 per mile for each additional mile\n    - Weight surcharge: $0.10 per pound for packages over 50 pounds\n    \n    Use the divmod function to separate the distance into base and additional miles.\n    \n\n    [EXAMPLES]\n    \n    assert candidate(150.5, 55.5) == 13.08\n    assert candidate(300, 40) == 30.0\n\n    [/EXAMPLES]\n    \"\"\"\n    # Constants\n    BASE_RATE = 10\n    BASE_DISTANCE = 100\n    ADDITIONAL_MILE_RATE = 0.05\n    WEIGHT_THRESHOLD = 50\n    WEIGHT_SURCHARGE_RATE = 0.10\n\n    # Calculate distance cost\n    base_miles, additional_miles = divmod(distance, BASE_DISTANCE)\n    distance_cost = BASE_RATE * base_miles + ADDITIONAL_MILE_RATE * additional_miles\n\n    # Calculate weight surcharge\n    weight_surcharge = max(0, weight - WEIGHT_THRESHOLD) * WEIGHT_SURCHARGE_RATE\n\n    # Total cost\n    total_cost = distance_cost + weight_surcharge\n\n    return round(total_cost, 2)\n\n", "test": "def check(candidate):\n    assert candidate(250, 30) == 22.5\n    assert candidate(999.99, 99.99) == 100.0\n    assert candidate(3500, 51) == 350.1\n    assert candidate(10000, 1000) == 1095.0\n    assert candidate(300, 40) == 30.0\n    assert candidate(750, 80) == 75.5\n    assert candidate(50, 150) == 12.5\n    assert candidate(150.5, 55.5) == 13.08\n    assert candidate(100.1, 50.1) == 10.01\n    assert candidate(0, 0) == 0.0\n", "language": "python"}
{"task_id": "593b6fa0-fbdc-4eea-a85b-ebf68c2f541d-715484034373776449", "prompt": "I'll help you complete a function based on its documentation. Please provide your function in one code block, and I'll make sure to address edge cases in the implementation.\n\n```python\nfrom typing import List\n\ndef decode_genetic_sequence(sequence: str, mutations: List[str]) -> int:\n    \"\"\"\n    In a genetics lab, scientists are studying a newly discovered species. They have\n    obtained a genetic sequence and a list of known mutations. Each mutation is\n    represented by a string of nucleotides (A, C, G, T) that may appear multiple times\n    in the sequence.\n    \n    The task is to determine the total number of mutations present in the genetic sequence.\n    Mutations can overlap, and a single section of the sequence can contribute to multiple\n    mutations. The count should include all occurrences of each mutation.\n    \n\n    [EXAMPLES]\n    \n    assert candidate(\"ACACACACACAC\", [\"ACA\", \"CAC\"]) == 10\n    assert candidate(\"AGTCAGTCAGTC\", [\"AGT\", \"GTC\", \"TCA\"]) == 8\n\n    [/EXAMPLES]\n    \"\"\"\n```\n", "entry_point": "decode_genetic_sequence", "solution": "from typing import List\n\ndef decode_genetic_sequence(sequence: str, mutations: List[str]) -> int:\n    \"\"\"\n    In a genetics lab, scientists are studying a newly discovered species. They have\n    obtained a genetic sequence and a list of known mutations. Each mutation is\n    represented by a string of nucleotides (A, C, G, T) that may appear multiple times\n    in the sequence.\n    \n    The task is to determine the total number of mutations present in the genetic sequence.\n    Mutations can overlap, and a single section of the sequence can contribute to multiple\n    mutations. The count should include all occurrences of each mutation.\n    \n\n    [EXAMPLES]\n    \n    assert candidate(\"ACACACACACAC\", [\"ACA\", \"CAC\"]) == 10\n    assert candidate(\"AGTCAGTCAGTC\", [\"AGT\", \"GTC\", \"TCA\"]) == 8\n\n    [/EXAMPLES]\n    \"\"\"\n    def count_occurrences(text, pattern):\n        count = 0\n        start = 0\n        while True:\n            start = text.find(pattern, start)\n            if start == -1:\n                return count\n            count += 1\n            start += 1\n\n    total_mutations = 0\n    for mutation in mutations:\n        total_mutations += count_occurrences(sequence, mutation)\n    \n    return total_mutations\n\n", "test": "def check(candidate):\n    assert candidate(\"ACACACACACAC\", [\"ACA\", \"CAC\"]) == 10\n    assert candidate(\"ACGTACGTACGT\", [\"ACG\", \"CGT\", \"GTA\"]) == 8\n    assert candidate(\"AAAAGGGGCCCCTTTT\", [\"AA\", \"GG\", \"CC\", \"TT\"]) == 12\n    assert candidate(\"GATTACA\", [\"GAT\", \"ATT\", \"TTA\", \"TAC\"]) == 4\n    assert candidate(\"GCGCGCGCGCGC\", [\"GCG\", \"CGC\"]) == 10\n    assert candidate(\"ATCG\", [\"A\", \"T\", \"C\", \"G\"]) == 4\n    assert candidate(\"ATATATATATAT\", [\"AT\", \"TA\"]) == 11\n    assert candidate(\"GGGGGGGG\", [\"GG\", \"GGG\", \"GGGG\"]) == 18\n    assert candidate(\"AGTCAGTCAGTC\", [\"AGT\", \"GTC\", \"TCA\"]) == 8\n    assert candidate(\"AAAAA\", [\"AA\"]) == 4\n", "language": "python"}
{"task_id": "fe7c1663-0f2b-431e-a042-dde2a8b3c0457130346365284893730", "prompt": "Please finish the function implementation so it's ready to execute within one code block. Stick to using only the libraries mentioned in the problem. If you need to create helper functions or classes, nest them inside the main function. Don't add any code outside the function.\n\n```python\nfrom typing import List\n\ndef design_rollercoaster(heights: List[int], min_height: int, max_consecutive_rejections: int) -> int:\n    \"\"\"\n    An amusement park is designing a new rollercoaster and wants to maximize the number of riders while\n    adhering to safety guidelines. Given a list of visitor heights, the minimum height requirement for\n    the ride, and the maximum number of consecutive rejections allowed before the park must shut down\n    the ride for maintenance, determine the maximum number of riders that can be admitted.\n\n\n    [EXAMPLES]\n    \n    assert candidate([200, 190, 180, 170, 160], 175, 1) == 3\n    assert candidate([140, 145, 150, 155, 160, 165, 170], 145, 1) == 6\n\n    [/EXAMPLES]\n    \"\"\"\n```\n", "entry_point": "design_rollercoaster", "solution": "from typing import List\n\ndef design_rollercoaster(heights: List[int], min_height: int, max_consecutive_rejections: int) -> int:\n    \"\"\"\n    An amusement park is designing a new rollercoaster and wants to maximize the number of riders while\n    adhering to safety guidelines. Given a list of visitor heights, the minimum height requirement for\n    the ride, and the maximum number of consecutive rejections allowed before the park must shut down\n    the ride for maintenance, determine the maximum number of riders that can be admitted.\n\n\n    [EXAMPLES]\n    \n    assert candidate([200, 190, 180, 170, 160], 175, 1) == 3\n    assert candidate([140, 145, 150, 155, 160, 165, 170], 145, 1) == 6\n\n    [/EXAMPLES]\n    \"\"\"\n    riders = 0\n    consecutive_rejections = 0\n\n    for height in heights:\n        if height >= min_height:\n            riders += 1\n            consecutive_rejections = 0\n        else:\n            consecutive_rejections += 1\n            if consecutive_rejections > max_consecutive_rejections:\n                break\n\n    return riders\n\n", "test": "def check(candidate):\n    assert candidate([180, 175, 170, 165, 160, 155], 170, 2) == 3\n    assert candidate([150, 151, 149, 152, 148], 150, 1) == 3\n    assert candidate([145, 150, 155, 160, 165], 165, 4) == 1\n    assert candidate([155, 154, 153, 152, 151, 150], 152, 3) == 4\n    assert candidate([200, 190, 180, 170, 160], 175, 1) == 3\n    assert candidate([100, 101, 102, 103, 104, 105], 103, 1) == 0\n    assert candidate([140, 145, 150, 155, 160, 165, 170], 145, 1) == 6\n    assert candidate([100, 110, 120, 130, 140, 150], 120, 3) == 4\n", "language": "python"}
{"task_id": "d41335a6-5d7a-48ea-9b31-2695515246e9-457112264238051186", "prompt": "Finish the function according to the documentation provided. Deliver your implementation as one complete code block, with appropriate handling of any potential edge cases.\n\n```python\nfrom typing import List, Tuple\n\ndef maze_solver(maze: List[List[int]], start: Tuple[int, int], end: Tuple[int, int]) -> List[Tuple[int, int]]:\n    \"\"\"\n    Find a path through a maze using depth-first search.\n\n    This function takes a 2D grid representing a maze, where 0 indicates a passable cell\n    and 1 indicates a wall. It uses depth-first search to find a path from the start\n    position to the end position, if one exists.\n\n    Args:\n    maze (List[List[int]]): A 2D list representing the maze layout.\n    start (Tuple[int, int]): The starting position (row, column).\n    end (Tuple[int, int]): The ending position (row, column).\n\n    Returns:\n    List[Tuple[int, int]]: A list of tuples representing the path from start to end,\n                           or an empty list if no path is found.\n\n\n    [EXAMPLES]\n    \n    assert candidate([[0,0,0,0],[0,1,1,0],[0,1,0,0],[0,0,0,0]], (0,0), (3,3)) == [(0, 0), (0, 1), (0, 2), (0, 3), (1, 3), (2, 3), (3, 3)]\n    assert candidate([[0]], (0,0), (0,0)) == [(0, 0)]\n\n    [/EXAMPLES]\n    \"\"\"\n```\n", "entry_point": "maze_solver", "solution": "from typing import List, Tuple\n\ndef maze_solver(maze: List[List[int]], start: Tuple[int, int], end: Tuple[int, int]) -> List[Tuple[int, int]]:\n    \"\"\"\n    Find a path through a maze using depth-first search.\n\n    This function takes a 2D grid representing a maze, where 0 indicates a passable cell\n    and 1 indicates a wall. It uses depth-first search to find a path from the start\n    position to the end position, if one exists.\n\n    Args:\n    maze (List[List[int]]): A 2D list representing the maze layout.\n    start (Tuple[int, int]): The starting position (row, column).\n    end (Tuple[int, int]): The ending position (row, column).\n\n    Returns:\n    List[Tuple[int, int]]: A list of tuples representing the path from start to end,\n                           or an empty list if no path is found.\n\n\n    [EXAMPLES]\n    \n    assert candidate([[0,0,0,0],[0,1,1,0],[0,1,0,0],[0,0,0,0]], (0,0), (3,3)) == [(0, 0), (0, 1), (0, 2), (0, 3), (1, 3), (2, 3), (3, 3)]\n    assert candidate([[0]], (0,0), (0,0)) == [(0, 0)]\n\n    [/EXAMPLES]\n    \"\"\"\n    def dfs(current: Tuple[int, int], path: List[Tuple[int, int]]) -> List[Tuple[int, int]]:\n        row, col = current\n\n        # Check if we're out of bounds or hit a wall\n        if (row < 0 or row >= len(maze) or\n            col < 0 or col >= len(maze[0]) or\n            maze[row][col] == 1):\n            return []\n\n        # Check if we've reached the end\n        if current == end:\n            return path + [current]\n\n        # Mark the current cell as visited\n        maze[row][col] = 1\n\n        # Explore in all four directions\n        for dr, dc in [(0, 1), (1, 0), (0, -1), (-1, 0)]:\n            next_pos = (row + dr, col + dc)\n            result = dfs(next_pos, path + [current])\n            if result:\n                return result\n\n        # Unmark the current cell (backtrack)\n        maze[row][col] = 0\n\n        return []\n\n    # Start the depth-first search\n    return dfs(start, [])\n\n", "test": "def check(candidate):\n    assert candidate([[0,0,0,0],[0,1,1,0],[0,1,0,0],[0,0,0,0]], (3,3), (0,0)) == [(3, 3), (3, 2), (3, 1), (3, 0), (2, 0), (1, 0), (0, 0)]\n    assert candidate([[1]], (0,0), (0,0)) == []\n    assert candidate([[0,1,0],[0,1,0],[0,0,0]], (0,0), (2,2)) == [(0, 0), (1, 0), (2, 0), (2, 1), (2, 2)]\n    assert candidate([[0,0,0,0,0],[1,1,1,1,0],[0,0,0,0,0],[0,1,1,1,0],[0,0,0,0,0]], (4,4), (0,0)) == [(4, 4), (4, 3), (4, 2), (4, 1), (4, 0), (3, 0), (2, 0), (2, 1), (2, 2), (2, 3), (2, 4), (1, 4), (0, 4), (0, 3), (0, 2), (0, 1), (0, 0)]\n    assert candidate([[0,0,0,0,0],[0,1,1,1,0],[0,1,0,1,0],[0,1,0,0,0],[0,0,0,1,0]], (4,4), (0,0)) == [(4, 4), (3, 4), (3, 3), (3, 2), (4, 2), (4, 1), (4, 0), (3, 0), (2, 0), (1, 0), (0, 0)]\n    assert candidate([[0,1],[1,0]], (0,0), (1,1)) == []\n    assert candidate([[0,0,0],[1,1,0],[0,0,0]], (0,0), (2,2)) == [(0, 0), (0, 1), (0, 2), (1, 2), (2, 2)]\n    assert candidate([[0,0],[0,0]], (0,0), (1,1)) == [(0, 0), (0, 1), (1, 1)]\n    assert candidate([[0,0,0,0],[0,1,1,0],[0,1,0,0],[0,0,0,0]], (0,0), (3,3)) == [(0, 0), (0, 1), (0, 2), (0, 3), (1, 3), (2, 3), (3, 3)]\n    assert candidate([[0]], (0,0), (0,0)) == [(0, 0)]\n", "language": "python"}
{"task_id": "e84ec5ca-68e6-4e82-ac31-61534b6d30a52054250892612828854", "prompt": "Code the body of the function according to what's described in the doc string. Provide the complete function within one code block.\n\n```python\nfrom typing import List\n\ndef treasure_map(map_grid: List[List[int]]) -> int:\n    \"\"\"\n    A group of adventurers found an ancient treasure map. The map is represented as a grid\n    where each cell contains a number indicating the amount of gold in that location.\n    The adventurers can only move right or down and want to collect the maximum amount of gold.\n\n    This function takes a 2D list representing the treasure map and returns the maximum\n    amount of gold that can be collected.\n\n\n    [EXAMPLES]\n    \n    assert candidate([[10, 20, 30], [40, 50, 60], [70, 80, 90]]) == 290\n    assert candidate([[1, 3, 1], [2, 5, 1], [4, 2, 1]]) == 12\n\n    [/EXAMPLES]\n    \"\"\"\n```\n", "entry_point": "treasure_map", "solution": "from typing import List\n\ndef treasure_map(map_grid: List[List[int]]) -> int:\n    \"\"\"\n    A group of adventurers found an ancient treasure map. The map is represented as a grid\n    where each cell contains a number indicating the amount of gold in that location.\n    The adventurers can only move right or down and want to collect the maximum amount of gold.\n\n    This function takes a 2D list representing the treasure map and returns the maximum\n    amount of gold that can be collected.\n\n\n    [EXAMPLES]\n    \n    assert candidate([[10, 20, 30], [40, 50, 60], [70, 80, 90]]) == 290\n    assert candidate([[1, 3, 1], [2, 5, 1], [4, 2, 1]]) == 12\n\n    [/EXAMPLES]\n    \"\"\"\n    if not map_grid or not map_grid[0]:\n        return 0\n\n    rows = len(map_grid)\n    cols = len(map_grid[0])\n\n    # Create a dp table with the same dimensions as the map_grid\n    dp = [[0 for _ in range(cols)] for _ in range(rows)]\n\n    # Initialize the first cell\n    dp[0][0] = map_grid[0][0]\n\n    # Initialize the first row\n    for j in range(1, cols):\n        dp[0][j] = dp[0][j-1] + map_grid[0][j]\n\n    # Initialize the first column\n    for i in range(1, rows):\n        dp[i][0] = dp[i-1][0] + map_grid[i][0]\n\n    # Fill the dp table\n    for i in range(1, rows):\n        for j in range(1, cols):\n            dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + map_grid[i][j]\n\n    # Return the maximum gold collected (bottom-right cell)\n    return dp[rows-1][cols-1]\n\n", "test": "def check(candidate):\n    assert candidate([[1, 2, 3, 4, 5]]) == 15\n    assert candidate([[0, 1, 0], [1, 0, 1], [0, 1, 0]]) == 2\n    assert candidate([[10, 20], [30, 40], [50, 60]]) == 150\n    assert candidate([[1, 1], [1, 1]]) == 3\n    assert candidate([[1, 1, 1, 1], [1, 1, 1, 1]]) == 5\n    assert candidate([[1, 1, 1], [1, 1, 1], [1, 1, 1]]) == 5\n    assert candidate([[1, 3, 1], [2, 5, 1], [4, 2, 1]]) == 12\n    assert candidate([[10, 0, 10], [0, 10, 0], [10, 0, 10]]) == 30\n    assert candidate([[10, 20, 30], [40, 50, 60], [70, 80, 90]]) == 290\n    assert candidate([[0, 0], [0, 0]]) == 0\n", "language": "python"}
{"task_id": "e84a8e60-4140-43c1-ad28-8dfc31fb0a00-918977623235456114", "prompt": "Code the remainder of the function to fulfill the requirements in the docstring. Present the entire solution in one code block.\n\n```python\ndef encrypt_dna_sequence(sequence: str) -> str:\n    \"\"\"\n    Encrypts a DNA sequence using a simple substitution cipher and base64 encoding.\n    \n    In a genetics research lab, scientists need to securely transmit DNA sequences.\n    This function takes a DNA sequence (containing only A, T, C, G) and applies\n    a substitution cipher followed by base64 encoding for added security.\n    \n\n    [EXAMPLES]\n    \n    assert candidate(\"AAAA\") == 'VFRUVA=='\n    assert candidate(\"GGGGGGGGGGGG\") == 'Q0NDQ0NDQ0NDQ0ND'\n\n    [/EXAMPLES]\n    \"\"\"\n```\n", "entry_point": "encrypt_dna_sequence", "solution": "def encrypt_dna_sequence(sequence: str) -> str:\n    \"\"\"\n    Encrypts a DNA sequence using a simple substitution cipher and base64 encoding.\n    \n    In a genetics research lab, scientists need to securely transmit DNA sequences.\n    This function takes a DNA sequence (containing only A, T, C, G) and applies\n    a substitution cipher followed by base64 encoding for added security.\n    \n\n    [EXAMPLES]\n    \n    assert candidate(\"AAAA\") == 'VFRUVA=='\n    assert candidate(\"GGGGGGGGGGGG\") == 'Q0NDQ0NDQ0NDQ0ND'\n\n    [/EXAMPLES]\n    \"\"\"\n    import base64\n    \n    def substitute(char: str) -> str:\n        \"\"\"Simple substitution cipher for DNA bases.\"\"\"\n        substitution = {'A': 'T', 'T': 'A', 'C': 'G', 'G': 'C'}\n        return substitution.get(char, char)\n    \n    # Apply substitution cipher\n    substituted = ''.join(substitute(char) for char in sequence)\n    \n    # Convert to bytes\n    substituted_bytes = substituted.encode('ascii')\n    \n    # Apply base64 encoding\n    encoded = base64.b64encode(substituted_bytes)\n    \n    # Convert back to string\n    return encoded.decode('ascii')\n\n", "test": "def check(candidate):\n    assert candidate(\"GGGG\") == 'Q0NDQw=='\n    assert candidate(\"TTTTTTTTTTTT\") == 'QUFBQUFBQUFBQUFB'\n    assert candidate(\"GGGGGGGGGGGG\") == 'Q0NDQ0NDQ0NDQ0ND'\n    assert candidate(\"C\") == 'Rw=='\n    assert candidate(\"AAAA\") == 'VFRUVA=='\n    assert candidate(\"TTTT\") == 'QUFBQQ=='\n    assert candidate(\"CG\") == 'R0M='\n    assert candidate(\"GATTACA\") == 'Q1RBQVRHVA=='\n    assert candidate(\"GCGCGCGCGCGC\") == 'Q0dDR0NHQ0dDR0NH'\n    assert candidate(\"ATCG\") == 'VEFHQw=='\n", "language": "python"}
{"task_id": "43d84e7b-d0b5-4c39-a4c2-52ee64fdb1181316128798893421927", "prompt": "My role is to complete coding functions that are ready to execute. I'll only utilize libraries that are imported in the problem and will contain any additional functions or classes within the given function's scope.\n\n```python\nfrom typing import List, Tuple\n\ndef knapsack_planner(items: List[Tuple[str, int, int]], capacity: int) -> List[str]:\n    \"\"\"\n    Plan the optimal items to pack in a knapsack for a hiking trip. Each item has a name,\n    weight, and value. The goal is to maximize the total value of items while staying\n    within the weight capacity of the knapsack.\n\n    Args:\n    items (List[Tuple[str, int, int]]): A list of tuples, each containing\n                                        (item_name, weight, value)\n    capacity (int): The maximum weight capacity of the knapsack\n\n    Returns:\n    List[str]: A list of item names that should be packed in the knapsack\n\n\n    [EXAMPLES]\n    \n    assert candidate([(\"water_bottle\", 1, 10), (\"snack_bar\", 1, 5), (\"sunscreen\", 1, 8), (\"sunglasses\", 1, 12)], 3) == ['water_bottle', 'sunscreen', 'sunglasses']\n    assert candidate([(\"hammer\", 3, 30), (\"screwdriver\", 1, 15), (\"pliers\", 2, 20), (\"wrench\", 2, 25)], 6) == ['hammer', 'screwdriver', 'wrench']\n\n    [/EXAMPLES]\n    \"\"\"\n```\n", "entry_point": "knapsack_planner", "solution": "from typing import List, Tuple\n\ndef knapsack_planner(items: List[Tuple[str, int, int]], capacity: int) -> List[str]:\n    \"\"\"\n    Plan the optimal items to pack in a knapsack for a hiking trip. Each item has a name,\n    weight, and value. The goal is to maximize the total value of items while staying\n    within the weight capacity of the knapsack.\n\n    Args:\n    items (List[Tuple[str, int, int]]): A list of tuples, each containing\n                                        (item_name, weight, value)\n    capacity (int): The maximum weight capacity of the knapsack\n\n    Returns:\n    List[str]: A list of item names that should be packed in the knapsack\n\n\n    [EXAMPLES]\n    \n    assert candidate([(\"water_bottle\", 1, 10), (\"snack_bar\", 1, 5), (\"sunscreen\", 1, 8), (\"sunglasses\", 1, 12)], 3) == ['water_bottle', 'sunscreen', 'sunglasses']\n    assert candidate([(\"hammer\", 3, 30), (\"screwdriver\", 1, 15), (\"pliers\", 2, 20), (\"wrench\", 2, 25)], 6) == ['hammer', 'screwdriver', 'wrench']\n\n    [/EXAMPLES]\n    \"\"\"\n    n = len(items)\n    \n    # Create a 2D table for dynamic programming\n    dp = [[0 for _ in range(capacity + 1)] for _ in range(n + 1)]\n    \n    # Fill the dp table\n    for i in range(1, n + 1):\n        for w in range(1, capacity + 1):\n            if items[i-1][1] <= w:\n                dp[i][w] = max(items[i-1][2] + dp[i-1][w-items[i-1][1]], dp[i-1][w])\n            else:\n                dp[i][w] = dp[i-1][w]\n    \n    # Backtrack to find the items\n    w = capacity\n    selected_items = []\n    for i in range(n, 0, -1):\n        if dp[i][w] != dp[i-1][w]:\n            selected_items.append(items[i-1][0])\n            w -= items[i-1][1]\n    \n    # Reverse the list to get items in original order\n    return selected_items[::-1]\n\n", "test": "def check(candidate):\n    assert candidate([(\"book\", 1, 10), (\"notebook\", 1, 8), (\"pen\", 1, 3)], 2) == ['book', 'notebook']\n    assert candidate([(\"map\", 1, 5), (\"compass\", 1, 7), (\"flashlight\", 2, 10), (\"first-aid\", 3, 15)], 5) == ['map', 'compass', 'first-aid']\n    assert candidate([(\"binoculars\", 2, 40), (\"bird_guide\", 1, 15), (\"notepad\", 1, 10), (\"pencil\", 1, 5)], 4) == ['binoculars', 'bird_guide', 'notepad']\n    assert candidate([], 10) == []\n    assert candidate([(\"guitar\", 5, 100), (\"harmonica\", 1, 20), (\"flute\", 2, 40), (\"tambourine\", 1, 15)], 7) == ['guitar', 'flute']\n    assert candidate([(\"laptop\", 2, 500), (\"phone\", 1, 300), (\"camera\", 1, 200)], 3) == ['laptop', 'phone']\n    assert candidate([(\"skateboard\", 5, 80), (\"helmet\", 2, 40), (\"knee_pads\", 1, 20), (\"elbow_pads\", 1, 20)], 8) == ['skateboard', 'helmet', 'knee_pads']\n    assert candidate([(\"water\", 3, 10), (\"food\", 4, 15), (\"tent\", 5, 7), (\"clothes\", 2, 8)], 7) == ['water', 'food']\n    assert candidate([(\"hammer\", 3, 30), (\"screwdriver\", 1, 15), (\"pliers\", 2, 20), (\"wrench\", 2, 25)], 6) == ['hammer', 'screwdriver', 'wrench']\n    assert candidate([(\"water_bottle\", 1, 10), (\"snack_bar\", 1, 5), (\"sunscreen\", 1, 8), (\"sunglasses\", 1, 12)], 3) == ['water_bottle', 'sunscreen', 'sunglasses']\n", "language": "python"}
{"task_id": "358022d2-210e-4067-bd3b-2a0a53a6a8c2-8537646072227391609", "prompt": "Here's the complete implementation of the function that fulfills the requirements in the docstring. The entire code will be in one block.\n\n```python\nimport re\nfrom typing import List\n\ndef decode_alien_message(encoded_message: str, code_book: List[str]) -> str:\n    \"\"\"\n    As a cryptanalyst in a top-secret government facility, you've intercepted an encoded alien message.\n    The message is a string of symbols, and you have a code book containing known symbol-to-letter mappings.\n    Your mission is to decode the message using the provided code book.\n\n    Parameters:\n    - encoded_message: A string of symbols representing the encoded alien message\n    - code_book: A list of strings where each string is in the format \"symbol=letter\"\n\n    Return the decoded message as a string. If a symbol is not in the code book, leave it as is in the output.\n\n\n    [EXAMPLES]\n    \n    assert candidate(\"aabbccddee\", [\"a=1\", \"b=2\", \"c=3\", \"d=4\", \"e=5\"]) == '1122334455'\n    assert candidate(\"ABCDEFG\", [\"A=1\", \"B=2\", \"C=3\", \"D=4\", \"E=5\", \"F=6\", \"G=7\"]) == '1234567'\n\n    [/EXAMPLES]\n    \"\"\"\n```\n", "entry_point": "decode_alien_message", "solution": "import re\nfrom typing import List\n\ndef decode_alien_message(encoded_message: str, code_book: List[str]) -> str:\n    \"\"\"\n    As a cryptanalyst in a top-secret government facility, you've intercepted an encoded alien message.\n    The message is a string of symbols, and you have a code book containing known symbol-to-letter mappings.\n    Your mission is to decode the message using the provided code book.\n\n    Parameters:\n    - encoded_message: A string of symbols representing the encoded alien message\n    - code_book: A list of strings where each string is in the format \"symbol=letter\"\n\n    Return the decoded message as a string. If a symbol is not in the code book, leave it as is in the output.\n\n\n    [EXAMPLES]\n    \n    assert candidate(\"aabbccddee\", [\"a=1\", \"b=2\", \"c=3\", \"d=4\", \"e=5\"]) == '1122334455'\n    assert candidate(\"ABCDEFG\", [\"A=1\", \"B=2\", \"C=3\", \"D=4\", \"E=5\", \"F=6\", \"G=7\"]) == '1234567'\n\n    [/EXAMPLES]\n    \"\"\"\n    # Create a dictionary to store the symbol-to-letter mappings\n    symbol_map = {}\n    \n    # Parse the code book and populate the symbol_map\n    for entry in code_book:\n        symbol, letter = entry.split('=')\n        symbol_map[symbol] = letter\n    \n    # Function to replace symbols with letters if they exist in the symbol_map\n    def replace_symbol(match):\n        symbol = match.group(0)\n        return symbol_map.get(symbol, symbol)\n    \n    # Create a regular expression pattern to match all symbols in the encoded message\n    pattern = '|'.join(re.escape(symbol) for symbol in symbol_map.keys())\n    \n    # Use re.sub with the replace_symbol function to decode the message\n    decoded_message = re.sub(pattern, replace_symbol, encoded_message)\n    \n    return decoded_message\n\n", "test": "def check(candidate):\n    assert candidate(\"A1B2C3\", [\"A=X\", \"B=Y\", \"C=Z\", \"1=9\", \"2=8\", \"3=7\"]) == 'X9Y8Z7'\n    assert candidate(\"abcABC123\", [\"a=x\", \"b=y\", \"c=z\", \"A=X\", \"B=Y\", \"C=Z\", \"1=9\", \"2=8\", \"3=7\"]) == 'xyzXYZ987'\n    assert candidate(\"!@#$%^&*()_+\", []) == '!@#$%^&*()_+'\n    assert candidate(\"\", []) == ''\n    assert candidate(\"!@#$%^&*()\", [\"@=A\", \"#=B\", \"$=C\", \"%=D\", \"^=E\"]) == '!ABCDE&*()'\n    assert candidate(\"The quick brown fox\", [\"T=Z\", \"h=y\", \"e=x\", \"q=w\", \"u=v\", \"i=t\", \"c=s\", \"k=r\", \"b=o\", \"r=n\", \"o=m\", \"w=l\", \"n=k\", \"f=j\", \"x=h\"]) == 'Zyx wvtsr onmlk jmh'\n    assert candidate(\"12345\", [\"1=One\", \"2=Two\", \"3=Three\", \"4=Four\", \"5=Five\"]) == 'OneTwoThreeFourFive'\n    assert candidate(\"aabbccddee\", [\"a=1\", \"b=2\", \"c=3\", \"d=4\", \"e=5\"]) == '1122334455'\n    assert candidate(\"ABCDEFG\", [\"A=1\", \"B=2\", \"C=3\", \"D=4\", \"E=5\", \"F=6\", \"G=7\"]) == '1234567'\n    assert candidate(\"!@#$%\", [\"!=!\", \"@=@\", \"#=#\", \"$=$\", \"%=%\"]) == '!@#$%'\n", "language": "python"}
{"task_id": "86f15fd1-f57d-4737-b9b3-3e80943c23c3-3206229213627635159", "prompt": "I'll provide a single code block containing the completed function that's ready to execute. The solution will only use libraries that are already imported in the problem. Any helper functions or classes needed will be defined within the main function itself. My response will be just the one code block with the full implementation.\n\n```python\ndef morse_code_decoder(message: str) -> str:\n    \"\"\"\n    Decode a message written in Morse code to its English alphabet equivalent.\n\n    In a world of secret communications, you've intercepted a message in Morse code.\n    Your task is to decode it into readable text. The message consists of dots (.) and dashes (-),\n    with spaces between letters and forward slashes (/) between words.\n\n\n    [EXAMPLES]\n    \n    assert candidate(\"... --- ... / ... --- ...\") == 'SOS SOS'\n    assert candidate(\".-.. --- .-- . .-. -.-. .- ... . / .- -. -.. / ..- .--. .--. . .-. -.-. .- ... .\") == 'LOWERCASE AND UPPERCASE'\n\n    [/EXAMPLES]\n    \"\"\"\n```\n", "entry_point": "morse_code_decoder", "solution": "def morse_code_decoder(message: str) -> str:\n    \"\"\"\n    Decode a message written in Morse code to its English alphabet equivalent.\n\n    In a world of secret communications, you've intercepted a message in Morse code.\n    Your task is to decode it into readable text. The message consists of dots (.) and dashes (-),\n    with spaces between letters and forward slashes (/) between words.\n\n\n    [EXAMPLES]\n    \n    assert candidate(\"... --- ... / ... --- ...\") == 'SOS SOS'\n    assert candidate(\".-.. --- .-- . .-. -.-. .- ... . / .- -. -.. / ..- .--. .--. . .-. -.-. .- ... .\") == 'LOWERCASE AND UPPERCASE'\n\n    [/EXAMPLES]\n    \"\"\"\n    # Morse code dictionary\n    morse_code_dict = {\n        '.-': 'A', '-...': 'B', '-.-.': 'C', '-..': 'D', '.': 'E',\n        '..-.': 'F', '--.': 'G', '....': 'H', '..': 'I', '.---': 'J',\n        '-.-': 'K', '.-..': 'L', '--': 'M', '-.': 'N', '---': 'O',\n        '.--.': 'P', '--.-': 'Q', '.-.': 'R', '...': 'S', '-': 'T',\n        '..-': 'U', '...-': 'V', '.--': 'W', '-..-': 'X', '-.--': 'Y',\n        '--..': 'Z'\n    }\n\n    # Split the message into words\n    words = message.split('/')\n\n    decoded_message = []\n    for word in words:\n        # Split each word into letters\n        letters = word.strip().split()\n        # Decode each letter and join them\n        decoded_word = ''.join(morse_code_dict.get(letter, '') for letter in letters)\n        decoded_message.append(decoded_word)\n\n    # Join the decoded words with spaces\n    return ' '.join(decoded_message)\n\n", "test": "def check(candidate):\n    assert candidate(\"... .--. . -.-. .. .- .-.. / -.-. .... .- .-. .- -.-. - . .-. ... -.-.--\") == 'SPECIAL CHARACTERS'\n    assert candidate(\".- -... -.-. / -..- -.-- --.. / .---- ..--- ...-- / .-.-.- --..-- -.-.--\") == 'ABC XYZ  '\n    assert candidate(\"... --- ... / ... --- ...\") == 'SOS SOS'\n    assert candidate(\".-\") == 'A'\n    assert candidate(\".-.. --- .-- . .-. -.-. .- ... . / .- -. -.. / ..- .--. .--. . .-. -.-. .- ... .\") == 'LOWERCASE AND UPPERCASE'\n    assert candidate(\"-. ..- -- -... . .-. ... / .- -. -.. / .-.. . - - . .-. ... / .---- ..--- ...-- / .- -... -.-.\") == 'NUMBERS AND LETTERS  ABC'\n    assert candidate(\"-.-.--\") == ''\n    assert candidate(\".-.. --- -. --. / .-- --- .-. -.. / ... .... --- .-. - / .-- --- .-. -.. / .-.. --- -. --. / .-- --- .-. -..\") == 'LONG WORD SHORT WORD LONG WORD'\n    assert candidate(\"--. --- --- -.. / -- --- .-. -. .. -. --. / ...- .. . - -. .- --\") == 'GOOD MORNING VIETNAM'\n    assert candidate(\".--. ..- -. -.-. - ..- .- - .. --- -. / -- .- .-. -.- ... / .-.-.- --..-- ..--.. -.-.-- -....- -..-.\") == 'PUNCTUATION MARKS '\n", "language": "python"}
{"task_id": "ce1de220-72d9-466b-9faa-77659125fa74-3833180288469021486", "prompt": "Your job is to implement a function that works immediately when copied into a code editor. The function should be entirely self-contained in a single code block. Only use libraries that were imported in the original problem. Place any additional functions or classes you need to create inside the main function body.\n\n```python\ndef calculate_taxi_fare(distance: float, waiting_time: int) -> float:\n    \"\"\"\n    A taxi company in a bustling city wants to implement a new fare calculation \n    system. They need a function that computes the total fare based on the distance \n    traveled and waiting time.\n\n    This function calculates the taxi fare given the distance traveled in kilometers \n    and the waiting time in minutes. The fare is calculated as follows:\n    - Base fare: $5.00\n    - Per kilometer charge: $2.50\n    - Per minute of waiting time: $0.50\n    The final fare should be rounded to the nearest cent.\n\n    Parameters:\n    distance (float): The distance traveled in kilometers\n    waiting_time (int): The waiting time in minutes\n\n    Returns:\n    float: The total fare rounded to two decimal places\n\n\n    [EXAMPLES]\n    \n    assert candidate(100, 0) == 255.0\n    assert candidate(9.99, 59) == 59.48\n\n    [/EXAMPLES]\n    \"\"\"\n```\n", "entry_point": "calculate_taxi_fare", "solution": "def calculate_taxi_fare(distance: float, waiting_time: int) -> float:\n    \"\"\"\n    A taxi company in a bustling city wants to implement a new fare calculation \n    system. They need a function that computes the total fare based on the distance \n    traveled and waiting time.\n\n    This function calculates the taxi fare given the distance traveled in kilometers \n    and the waiting time in minutes. The fare is calculated as follows:\n    - Base fare: $5.00\n    - Per kilometer charge: $2.50\n    - Per minute of waiting time: $0.50\n    The final fare should be rounded to the nearest cent.\n\n    Parameters:\n    distance (float): The distance traveled in kilometers\n    waiting_time (int): The waiting time in minutes\n\n    Returns:\n    float: The total fare rounded to two decimal places\n\n\n    [EXAMPLES]\n    \n    assert candidate(100, 0) == 255.0\n    assert candidate(9.99, 59) == 59.48\n\n    [/EXAMPLES]\n    \"\"\"\n    base_fare = 5.00\n    per_km_charge = 2.50\n    per_minute_waiting_charge = 0.50\n\n    distance_fare = distance * per_km_charge\n    waiting_fare = waiting_time * per_minute_waiting_charge\n    total_fare = base_fare + distance_fare + waiting_fare\n\n    return round(total_fare, 2)\n\n", "test": "def check(candidate):\n    assert candidate(5.5, 15) == 26.25\n    assert candidate(1, 1) == 8.0\n    assert candidate(100, 0) == 255.0\n    assert candidate(20.7, 30) == 71.75\n    assert candidate(0.01, 1) == 5.53\n    assert candidate(0, 1) == 5.5\n    assert candidate(3.14, 7) == 16.35\n    assert candidate(0, 0) == 5.0\n    assert candidate(50, 120) == 190.0\n    assert candidate(9.99, 59) == 59.48\n", "language": "python"}
{"task_id": "cd8abd07-5422-4c9a-99e8-e42408aac54d8118918651530962365", "prompt": "I'm a coding assistant here to complete functions that can be executed as-is. I'll only write code inside the provided function, using exclusively the imported libraries from the problem. If additional functions or classes are needed, I'll define them within the given function.\n\n```python\nfrom typing import List\n\ndef alien_code_decryption(encrypted_message: str, alien_dictionary: List[str]) -> str:\n    \"\"\"\n    You've intercepted an encrypted message from an alien civilization. The message is a string\n    of symbols, and you have been provided with an alien dictionary that maps each symbol to a\n    unique Earth letter. Your task is to decrypt the message using the provided dictionary.\n\n    The function takes the encrypted message as a string and the alien dictionary as a list of\n    strings, where each string represents a symbol-letter pair (e.g., \"\u00a9=A\"). It should return\n    the decrypted message as a string.\n\n    This problem involves string manipulation and dictionary usage to create an efficient\n    decryption mechanism.\n\n\n    [EXAMPLES]\n    \n    assert candidate(\"\u2660\u2665\u2666\u2663\", [\"\u2660=A\", \"\u2665=K\", \"\u2666=Q\", \"\u2663=J\"]) == 'AKQJ'\n    assert candidate(\"11011011\", [\"0=O\", \"1=I\"]) == 'IIOIIOII'\n\n    [/EXAMPLES]\n    \"\"\"\n```\n", "entry_point": "alien_code_decryption", "solution": "from typing import List\n\ndef alien_code_decryption(encrypted_message: str, alien_dictionary: List[str]) -> str:\n    \"\"\"\n    You've intercepted an encrypted message from an alien civilization. The message is a string\n    of symbols, and you have been provided with an alien dictionary that maps each symbol to a\n    unique Earth letter. Your task is to decrypt the message using the provided dictionary.\n\n    The function takes the encrypted message as a string and the alien dictionary as a list of\n    strings, where each string represents a symbol-letter pair (e.g., \"\u00a9=A\"). It should return\n    the decrypted message as a string.\n\n    This problem involves string manipulation and dictionary usage to create an efficient\n    decryption mechanism.\n\n\n    [EXAMPLES]\n    \n    assert candidate(\"\u2660\u2665\u2666\u2663\", [\"\u2660=A\", \"\u2665=K\", \"\u2666=Q\", \"\u2663=J\"]) == 'AKQJ'\n    assert candidate(\"11011011\", [\"0=O\", \"1=I\"]) == 'IIOIIOII'\n\n    [/EXAMPLES]\n    \"\"\"\n    # Create a dictionary to map alien symbols to Earth letters\n    decryption_map = {}\n    for pair in alien_dictionary:\n        symbol, letter = pair.split('=')\n        decryption_map[symbol] = letter\n\n    # Decrypt the message\n    decrypted_message = []\n    for symbol in encrypted_message:\n        if symbol in decryption_map:\n            decrypted_message.append(decryption_map[symbol])\n        else:\n            # If a symbol is not in the dictionary, keep it as is\n            decrypted_message.append(symbol)\n\n    return ''.join(decrypted_message)\n\n", "test": "def check(candidate):\n    assert candidate(\"\u03b1\u03b1  \u03b2\u03b2  \u03b3\u03b3\", [\"\u03b1=S\", \"\u03b2=O\", \"\u03b3=S\", \" = \"]) == 'SS  OO  SS'\n    assert candidate(\"\u2660\u2665\u2666\u2663\", [\"\u2660=A\", \"\u2665=K\", \"\u2666=Q\", \"\u2663=J\"]) == 'AKQJ'\n    assert candidate(\".-.-...--.\", [\".=S\", \"-=O\", \"=S\"]) == 'SOSOSSSOOS'\n    assert candidate(\"\", []) == ''\n    assert candidate(\"AEIOU\", [\"A=1\", \"E=2\", \"I=3\", \"O=4\", \"U=5\"]) == '12345'\n    assert candidate(\"\u03b1\u03b2\u03b3\", [\"\u03b1=X\", \"\u03b2=Y\", \"\u03b3=Z\"]) == 'XYZ'\n    assert candidate(\"\u03b1\u03b2\u03b3\u03b4\u03b5\u03b6\u03b7\u03b8\u03b9\u03ba\u03bb\u03bc\u03bd\u03be\u03bf\u03c0\u03c1\u03c3\u03c4\u03c5\u03c6\u03c7\u03c8\u03c9\", [\"\u03b1=A\", \"\u03b2=B\", \"\u03b3=C\", \"\u03b4=D\", \"\u03b5=E\", \"\u03b6=F\", \"\u03b7=G\", \"\u03b8=H\", \"\u03b9=I\", \"\u03ba=J\", \"\u03bb=K\", \"\u03bc=L\", \"\u03bd=M\", \"\u03be=N\", \"\u03bf=O\", \"\u03c0=P\", \"\u03c1=Q\", \"\u03c3=R\", \"\u03c4=S\", \"\u03c5=T\", \"\u03c6=U\", \"\u03c7=V\", \"\u03c8=W\", \"\u03c9=X\"]) == 'ABCDEFGHIJKLMNOPQRSTUVWX'\n    assert candidate(\"abcdefghijklmnopqrstuvwxyz\", [\"a=Z\", \"b=Y\", \"c=X\", \"d=W\", \"e=V\", \"f=U\", \"g=T\", \"h=S\", \"i=R\", \"j=Q\", \"k=P\", \"l=O\", \"m=N\", \"n=M\", \"o=L\", \"p=K\", \"q=J\", \"r=I\", \"s=H\", \"t=G\", \"u=F\", \"v=E\", \"w=D\", \"x=C\", \"y=B\", \"z=A\"]) == 'ZYXWVUTSRQPONMLKJIHGFEDCBA'\n    assert candidate(\"11011011\", [\"0=O\", \"1=I\"]) == 'IIOIIOII'\n    assert candidate(\"12345!@#$%\", [\"1=A\", \"2=B\", \"3=C\", \"4=D\", \"5=E\", \"!=F\", \"@=G\", \"#=H\", \"$=I\", \"%=J\"]) == 'ABCDEFGHIJ'\n", "language": "python"}
{"task_id": "698d7d10-a6bc-4c47-a2d0-bf95c2423250-5757163937546318386", "prompt": "Your coding assistant here. I'll complete the provided function to make it ready for execution. All my code will remain within the function boundaries, and I'll only use libraries that are imported in the problem. Any helper functions or classes I create will be defined inside the main function.\n\n```python\nimport math\n\ndef calculate_delivery_time(distance: float, traffic_level: str, weather_condition: str) -> int:\n    \"\"\"\n    A food delivery app wants to estimate delivery times based on various factors. This function calculates the estimated delivery time in minutes based on the distance, traffic level, and weather condition.\n\n    The base delivery speed is 30 km/h. Adjustments are made as follows:\n    - Traffic levels: 'light' (no change), 'moderate' (-5 km/h), 'heavy' (-10 km/h)\n    - Weather conditions: 'clear' (no change), 'rainy' (-5 km/h), 'stormy' (-10 km/h)\n\n    The function should return the estimated delivery time rounded up to the nearest minute.\n\n\n    [EXAMPLES]\n    \n    assert candidate(18.9, \"moderate\", \"stormy\") == 76\n    assert candidate(20, \"moderate\", \"stormy\") == 80\n\n    [/EXAMPLES]\n    \"\"\"\n```\n", "entry_point": "calculate_delivery_time", "solution": "import math\n\ndef calculate_delivery_time(distance: float, traffic_level: str, weather_condition: str) -> int:\n    \"\"\"\n    A food delivery app wants to estimate delivery times based on various factors. This function calculates the estimated delivery time in minutes based on the distance, traffic level, and weather condition.\n\n    The base delivery speed is 30 km/h. Adjustments are made as follows:\n    - Traffic levels: 'light' (no change), 'moderate' (-5 km/h), 'heavy' (-10 km/h)\n    - Weather conditions: 'clear' (no change), 'rainy' (-5 km/h), 'stormy' (-10 km/h)\n\n    The function should return the estimated delivery time rounded up to the nearest minute.\n\n\n    [EXAMPLES]\n    \n    assert candidate(18.9, \"moderate\", \"stormy\") == 76\n    assert candidate(20, \"moderate\", \"stormy\") == 80\n\n    [/EXAMPLES]\n    \"\"\"\n    import math\n\n    # Base delivery speed\n    base_speed = 30\n\n    # Adjust speed based on traffic level\n    traffic_adjustments = {\"light\": 0, \"moderate\": -5, \"heavy\": -10}\n    speed = base_speed + traffic_adjustments.get(traffic_level.lower(), 0)\n\n    # Adjust speed based on weather condition\n    weather_adjustments = {\"clear\": 0, \"rainy\": -5, \"stormy\": -10}\n    speed += weather_adjustments.get(weather_condition.lower(), 0)\n\n    # Ensure the speed doesn't go below 1 km/h\n    speed = max(speed, 1)\n\n    # Calculate time in hours\n    time_hours = distance / speed\n\n    # Convert time to minutes and round up to the nearest minute\n    time_minutes = math.ceil(time_hours * 60)\n\n    return time_minutes\n\n", "test": "def check(candidate):\n    assert candidate(20, \"moderate\", \"stormy\") == 80\n    assert candidate(50, \"heavy\", \"rainy\") == 200\n    assert candidate(8.7, \"moderate\", \"moderate\") == 21\n    assert candidate(0.1, \"moderate\", \"clear\") == 1\n    assert candidate(15, \"moderate\", \"rainy\") == 45\n    assert candidate(18.9, \"moderate\", \"stormy\") == 76\n    assert candidate(7.8, \"heavy\", \"clear\") == 24\n    assert candidate(6.2, \"heavy\", \"clear\") == 19\n    assert candidate(10, \"light\", \"clear\") == 20\n    assert candidate(25.6, \"heavy\", \"rainy\") == 103\n", "language": "python"}
{"task_id": "2371725c-169f-4cb7-97c0-996c5fd6f7ae-6468952178613971102", "prompt": "Implement the given function to be fully operational when run. All code must remain within the function scope. Use only the libraries that are imported in the original problem. Any additional functions or class definitions should be created inside the main function.\n\n```python\ndef calculate_tax(income: float, tax_brackets: list) -> float:\n    \"\"\"\n    As an accountant, you need to calculate the total tax for a given income.\n    The tax system uses progressive tax brackets, where different rates apply to different portions of income.\n    Each bracket in tax_brackets is a tuple of (upper_limit, rate).\n    The last bracket has no upper limit (represented by float('inf')).\n\n    This function involves list manipulation and mathematical calculations.\n\n\n    [EXAMPLES]\n    \n    assert candidate(50000, [(10000, 0.1), (30000, 0.15), (float('inf'), 0.25)]) == 9000.0\n    assert candidate(1000000, [(10000, 0.1), (30000, 0.15), (float('inf'), 0.25)]) == 246500.0\n\n    [/EXAMPLES]\n    \"\"\"\n```\n", "entry_point": "calculate_tax", "solution": "def calculate_tax(income: float, tax_brackets: list) -> float:\n    \"\"\"\n    As an accountant, you need to calculate the total tax for a given income.\n    The tax system uses progressive tax brackets, where different rates apply to different portions of income.\n    Each bracket in tax_brackets is a tuple of (upper_limit, rate).\n    The last bracket has no upper limit (represented by float('inf')).\n\n    This function involves list manipulation and mathematical calculations.\n\n\n    [EXAMPLES]\n    \n    assert candidate(50000, [(10000, 0.1), (30000, 0.15), (float('inf'), 0.25)]) == 9000.0\n    assert candidate(1000000, [(10000, 0.1), (30000, 0.15), (float('inf'), 0.25)]) == 246500.0\n\n    [/EXAMPLES]\n    \"\"\"\n    total_tax = 0\n    remaining_income = income\n    previous_limit = 0\n\n    for upper_limit, rate in tax_brackets:\n        if remaining_income <= 0:\n            break\n\n        taxable_amount = min(remaining_income, upper_limit - previous_limit)\n        tax_for_bracket = taxable_amount * rate\n        total_tax += tax_for_bracket\n\n        remaining_income -= taxable_amount\n        previous_limit = upper_limit\n\n    return round(total_tax, 2)\n\n", "test": "def check(candidate):\n    assert candidate(49999.99, [(10000, 0.05), (25000, 0.1), (50000, 0.15), (float('inf'), 0.2)]) == 5750.0\n    assert candidate(50000.01, [(10000, 0.05), (25000, 0.1), (50000, 0.15), (float('inf'), 0.2)]) == 5750.0\n    assert candidate(500000, [(100000, 0.1), (250000, 0.2), (500000, 0.3), (float('inf'), 0.4)]) == 115000.0\n    assert candidate(0, [(10000, 0.1), (30000, 0.15), (float('inf'), 0.25)]) == 0\n    assert candidate(50000, [(10000, 0.1), (30000, 0.15), (float('inf'), 0.25)]) == 9000.0\n    assert candidate(1, [(1000, 0.01), (float('inf'), 0.02)]) == 0.01\n    assert candidate(1000000, [(10000, 0.1), (30000, 0.15), (float('inf'), 0.25)]) == 246500.0\n    assert candidate(10000, [(10000, 0.1), (30000, 0.15), (float('inf'), 0.25)]) == 1000.0\n    assert candidate(0.01, [(0.01, 0.1), (float('inf'), 0.2)]) == 0.0\n    assert candidate(30000, [(10000, 0.1), (30000, 0.15), (float('inf'), 0.25)]) == 4000.0\n", "language": "python"}
{"task_id": "1c38c250-5e66-4a6c-b04f-89f0d9b1ac7a-1243715626841911444", "prompt": "I'll provide the entire completed code in one block below.\n\n```python\ndef analyze_marine_life(depth: float, species_count: dict) -> str:\n    \"\"\"\n    As a marine biologist, you're studying the distribution of marine life at different ocean depths.\n    This function takes the depth of a particular ocean layer and a dictionary of species counts,\n    then determines the biodiversity category of that layer.\n\n    The function uses both floating-point arithmetic (for depth calculations) and dictionary operations\n    (for species analysis) to categorize the ocean layer.\n\n    Args:\n    depth (float): The depth of the ocean layer in meters\n    species_count (dict): A dictionary where keys are species names and values are their counts\n\n    Returns:\n    str: The biodiversity category of the ocean layer\n\n\n    [EXAMPLES]\n    \n    assert candidate(300.0, {\"parrotfish\": 25, \"surgeonfish\": 30, \"wrasses\": 35}) == 'Moderate Diversity'\n    assert candidate(500.75, {\"squid\": 10, \"octopus\": 5, \"cuttlefish\": 3}) == 'Moderate Diversity'\n\n    [/EXAMPLES]\n    \"\"\"\n```\n", "entry_point": "analyze_marine_life", "solution": "def analyze_marine_life(depth: float, species_count: dict) -> str:\n    \"\"\"\n    As a marine biologist, you're studying the distribution of marine life at different ocean depths.\n    This function takes the depth of a particular ocean layer and a dictionary of species counts,\n    then determines the biodiversity category of that layer.\n\n    The function uses both floating-point arithmetic (for depth calculations) and dictionary operations\n    (for species analysis) to categorize the ocean layer.\n\n    Args:\n    depth (float): The depth of the ocean layer in meters\n    species_count (dict): A dictionary where keys are species names and values are their counts\n\n    Returns:\n    str: The biodiversity category of the ocean layer\n\n\n    [EXAMPLES]\n    \n    assert candidate(300.0, {\"parrotfish\": 25, \"surgeonfish\": 30, \"wrasses\": 35}) == 'Moderate Diversity'\n    assert candidate(500.75, {\"squid\": 10, \"octopus\": 5, \"cuttlefish\": 3}) == 'Moderate Diversity'\n\n    [/EXAMPLES]\n    \"\"\"\n    def categorize_depth(depth):\n        if depth < 200:\n            return \"Epipelagic\"\n        elif 200 <= depth < 1000:\n            return \"Mesopelagic\"\n        elif 1000 <= depth < 4000:\n            return \"Bathypelagic\"\n        else:\n            return \"Abyssopelagic\"\n    \n    def calculate_diversity(species_count):\n        total_species = len(species_count)\n        total_individuals = sum(species_count.values())\n        \n        if total_species == 0:\n            return \"No Life\"\n        elif total_species < 3 or total_individuals < 10:\n            return \"Low Diversity\"\n        elif total_species < 5 or total_individuals < 50:\n            return \"Moderate Diversity\"\n        else:\n            return \"High Diversity\"\n    \n    depth_category = categorize_depth(depth)\n    diversity_category = calculate_diversity(species_count)\n    \n    if depth_category == \"Abyssopelagic\" and diversity_category != \"No Life\":\n        diversity_category = \"Rare Deep Sea Life\"\n    \n    return diversity_category\n\n", "test": "def check(candidate):\n    assert candidate(9999.99, {\"foraminifera\": 500}) == 'Rare Deep Sea Life'\n    assert candidate(1500.0, {\"gulper eel\": 1, \"fangtooth\": 2, \"dragonfish\": 3}) == 'Low Diversity'\n    assert candidate(50.25, {\"seahorses\": 20, \"pipefish\": 15, \"seadragons\": 5}) == 'Moderate Diversity'\n    assert candidate(300.0, {\"parrotfish\": 25, \"surgeonfish\": 30, \"wrasses\": 35}) == 'Moderate Diversity'\n    assert candidate(0.0, {\"plankton\": 1000000}) == 'Low Diversity'\n    assert candidate(1000.0, {\"anglerfish\": 5, \"viperfish\": 3}) == 'Low Diversity'\n    assert candidate(2000.5, {\"giant squid\": 1}) == 'Low Diversity'\n    assert candidate(500.75, {\"squid\": 10, \"octopus\": 5, \"cuttlefish\": 3}) == 'Moderate Diversity'\n", "language": "python"}
{"task_id": "d1fca404-05e9-4e29-bd32-92a427bf35eb2410898307041369441", "prompt": "Ready to complete your code within a single block. What's the starting code that needs completion?\n\n```python\ndef count_bit_strings(n: int, k: int) -> int:\n    \"\"\"\n    In the field of quantum computing, you're working on a problem involving\n    bit strings. You need to count the number of bit strings of length n that\n    contain exactly k ones.\n\n    This function takes two integers as input: n (the length of the bit string)\n    and k (the number of ones), and returns the count of such bit strings.\n    The result should be returned modulo 10^9 + 7 to handle large numbers.\n\n\n    [EXAMPLES]\n    \n    assert candidate(100000, 50000) == 149033233\n    assert candidate(50, 25) == 605552882\n\n    [/EXAMPLES]\n    \"\"\"\n```\n", "entry_point": "count_bit_strings", "solution": "def count_bit_strings(n: int, k: int) -> int:\n    \"\"\"\n    In the field of quantum computing, you're working on a problem involving\n    bit strings. You need to count the number of bit strings of length n that\n    contain exactly k ones.\n\n    This function takes two integers as input: n (the length of the bit string)\n    and k (the number of ones), and returns the count of such bit strings.\n    The result should be returned modulo 10^9 + 7 to handle large numbers.\n\n\n    [EXAMPLES]\n    \n    assert candidate(100000, 50000) == 149033233\n    assert candidate(50, 25) == 605552882\n\n    [/EXAMPLES]\n    \"\"\"\n    def factorial(num):\n        result = 1\n        for i in range(1, num + 1):\n            result = (result * i) % MOD\n        return result\n\n    def modular_inverse(a, m):\n        def extended_gcd(a, b):\n            if b == 0:\n                return a, 1, 0\n            else:\n                gcd, x, y = extended_gcd(b, a % b)\n                return gcd, y, x - (a // b) * y\n\n        gcd, x, _ = extended_gcd(a, m)\n        if gcd != 1:\n            raise ValueError(\"Modular inverse does not exist\")\n        else:\n            return x % m\n\n    MOD = 10**9 + 7\n\n    if k > n:\n        return 0\n\n    numerator = factorial(n)\n    denominator = (factorial(k) * factorial(n - k)) % MOD\n\n    result = (numerator * modular_inverse(denominator, MOD)) % MOD\n\n    return result\n\n", "test": "def check(candidate):\n    assert candidate(100000, 50000) == 149033233\n    assert candidate(10000, 1) == 10000\n    assert candidate(10, 5) == 252\n    assert candidate(100, 50) == 538992043\n    assert candidate(4, 1) == 4\n    assert candidate(50, 25) == 605552882\n    assert candidate(1000, 1000) == 1\n    assert candidate(1, 1) == 1\n    assert candidate(1000, 500) == 159835829\n    assert candidate(10, 10) == 1\n", "language": "python"}
{"task_id": "2eb2dfb8-b4f3-4b2b-b04e-f012b5800088-5907104689297598438", "prompt": "Let me finish that code for you in a complete code block:\n\n```python\nfrom typing import List\n\ndef alien_language_translator(dictionary: List[str], message: str) -> str:\n    \"\"\"\n    Xenolinguists have discovered an alien language and are trying to decipher it. They have a partial dictionary\n    of alien words and their English translations. Your task is to translate a given alien message using this\n    dictionary. If a word is not in the dictionary, it should remain unchanged in the translation.\n\n    This function takes a list of word pairs (alien word, English translation) and an alien message, then returns\n    the translated message in English.\n\n    Parameters:\n    dictionary (List[str]): A list of string pairs [\"alien_word:english_translation\", ...].\n    message (str): The alien message to be translated.\n\n    Returns:\n    str: The translated message in English.\n\n\n    [EXAMPLES]\n    \n    assert candidate([\"foo:bar\", \"baz:qux\"], \"foo bar baz\") == 'bar bar qux'\n    assert candidate([\"a:a\", \"b:b\", \"c:c\"], \"abc\") == 'abc'\n\n    [/EXAMPLES]\n    \"\"\"\n```\n", "entry_point": "alien_language_translator", "solution": "from typing import List\n\ndef alien_language_translator(dictionary: List[str], message: str) -> str:\n    \"\"\"\n    Xenolinguists have discovered an alien language and are trying to decipher it. They have a partial dictionary\n    of alien words and their English translations. Your task is to translate a given alien message using this\n    dictionary. If a word is not in the dictionary, it should remain unchanged in the translation.\n\n    This function takes a list of word pairs (alien word, English translation) and an alien message, then returns\n    the translated message in English.\n\n    Parameters:\n    dictionary (List[str]): A list of string pairs [\"alien_word:english_translation\", ...].\n    message (str): The alien message to be translated.\n\n    Returns:\n    str: The translated message in English.\n\n\n    [EXAMPLES]\n    \n    assert candidate([\"foo:bar\", \"baz:qux\"], \"foo bar baz\") == 'bar bar qux'\n    assert candidate([\"a:a\", \"b:b\", \"c:c\"], \"abc\") == 'abc'\n\n    [/EXAMPLES]\n    \"\"\"\n    # Create a dictionary to store alien-to-English translations\n    translation_dict = {}\n    \n    # Populate the translation dictionary\n    for pair in dictionary:\n        alien_word, english_word = pair.split(':')\n        translation_dict[alien_word] = english_word\n    \n    # Split the message into words\n    words = message.split()\n    \n    # Translate each word, or keep it unchanged if not in the dictionary\n    translated_words = [translation_dict.get(word, word) for word in words]\n    \n    # Join the translated words back into a string\n    translated_message = ' '.join(translated_words)\n    \n    return translated_message\n\n", "test": "def check(candidate):\n    assert candidate([\"\u00e1\u00e9\u00ed\u00f3\u00fa:aeiou\"], \"\u00e1\u00e9\u00ed\u00f3\u00fa\") == 'aeiou'\n    assert candidate([\"!:?\", \"?:!\"], \"! ? ! ?\") == '? ! ? !'\n    assert candidate([\"long_word:short\", \"short:long_word\"], \"long_word short\") == 'short long_word'\n    assert candidate([\"begin:end\", \"end:begin\"], \"begin middle end\") == 'end middle begin'\n    assert candidate([\"foo:bar\", \"baz:qux\"], \"foo bar baz\") == 'bar bar qux'\n    assert candidate([\"a:1\", \"b:2\", \"c:3\"], \"a b c d\") == '1 2 3 d'\n    assert candidate([\"punctuation:!\"], \"punctuation ! punctuation\") == '! ! !'\n    assert candidate([\"a:a\", \"b:b\", \"c:c\"], \"abc\") == 'abc'\n    assert candidate([\"word:sentence\"], \"word word word\") == 'sentence sentence sentence'\n    assert candidate([\"number:1234\"], \"number 1234 number\") == '1234 1234 1234'\n", "language": "python"}
{"task_id": "82c13117-c033-4a54-bba2-da7ad95957da-2290428107136986652", "prompt": "I'll develop the remainder of this function according to the specifications in the docstring, providing the complete function in one code block.\n\n```python\nfrom typing import List\n\ndef book_arrangement(shelf_width: int, book_widths: List[int]) -> int:\n    \"\"\"\n    Determine the minimum number of shelves needed to arrange all books in a library.\n    Each shelf has a fixed width, and books must be placed in the order given. A new\n    shelf is started when the next book doesn't fit on the current shelf.\n\n    Args:\n    shelf_width (int): Width of each shelf\n    book_widths (List[int]): List of book widths in the order they must be placed\n\n    Returns:\n    int: Minimum number of shelves needed\n\n\n    [EXAMPLES]\n    \n    assert candidate(100, [99, 2, 99, 2, 99, 2]) == 6\n    assert candidate(25, [24, 1, 24, 1, 24, 1]) == 3\n\n    [/EXAMPLES]\n    \"\"\"\n```\n", "entry_point": "book_arrangement", "solution": "from typing import List\n\ndef book_arrangement(shelf_width: int, book_widths: List[int]) -> int:\n    \"\"\"\n    Determine the minimum number of shelves needed to arrange all books in a library.\n    Each shelf has a fixed width, and books must be placed in the order given. A new\n    shelf is started when the next book doesn't fit on the current shelf.\n\n    Args:\n    shelf_width (int): Width of each shelf\n    book_widths (List[int]): List of book widths in the order they must be placed\n\n    Returns:\n    int: Minimum number of shelves needed\n\n\n    [EXAMPLES]\n    \n    assert candidate(100, [99, 2, 99, 2, 99, 2]) == 6\n    assert candidate(25, [24, 1, 24, 1, 24, 1]) == 3\n\n    [/EXAMPLES]\n    \"\"\"\n    shelves = 1  # Start with one shelf\n    current_width = 0  # Current width used on the current shelf\n\n    for book_width in book_widths:\n        # If the book doesn't fit on the current shelf\n        if current_width + book_width > shelf_width:\n            shelves += 1  # Start a new shelf\n            current_width = book_width  # Place the book on the new shelf\n        else:\n            current_width += book_width  # Add the book to the current shelf\n\n    return shelves\n\n", "test": "def check(candidate):\n    assert candidate(100, [99, 2, 99, 2, 99, 2]) == 6\n    assert candidate(25, [24, 1, 24, 1, 24, 1]) == 3\n    assert candidate(30, [10, 10, 10, 10, 10, 10]) == 2\n    assert candidate(1000, [1000] * 10) == 10\n    assert candidate(10, []) == 1\n    assert candidate(1, [1]) == 1\n    assert candidate(100, [33, 33, 33, 1]) == 1\n    assert candidate(10, [3, 3, 3, 3, 3]) == 2\n    assert candidate(10, [3, 2, 5, 7, 4, 1, 8]) == 4\n    assert candidate(1000, [999, 1, 999, 1]) == 2\n", "language": "python"}
{"task_id": "7a3dc24e-d6c3-4f40-9677-eeb408b68f0e-7248949894631342524", "prompt": "Continue the implementation of the function as per the doc string specifications. Maintain the existing function name and parameters while providing a full implementation.\n\n```python\nfrom typing import List\n\ndef spiral_matrix(n: int) -> List[List[int]]:\n    \"\"\"\n    Generate a square matrix of size n x n filled with numbers in a spiral pattern,\n    starting from 1 in the top-left corner and moving clockwise.\n\n    This function combines the concepts of 2D array manipulation and directional traversal.\n\n\n    [EXAMPLES]\n    \n    assert candidate(0) == []\n    assert candidate(4) == [[1, 2, 3, 4], [12, 13, 14, 5], [11, 16, 15, 6], [10, 9, 8, 7]]\n\n    [/EXAMPLES]\n    \"\"\"\n```\n", "entry_point": "spiral_matrix", "solution": "from typing import List\n\ndef spiral_matrix(n: int) -> List[List[int]]:\n    \"\"\"\n    Generate a square matrix of size n x n filled with numbers in a spiral pattern,\n    starting from 1 in the top-left corner and moving clockwise.\n\n    This function combines the concepts of 2D array manipulation and directional traversal.\n\n\n    [EXAMPLES]\n    \n    assert candidate(0) == []\n    assert candidate(4) == [[1, 2, 3, 4], [12, 13, 14, 5], [11, 16, 15, 6], [10, 9, 8, 7]]\n\n    [/EXAMPLES]\n    \"\"\"\n    # Initialize the matrix with zeros\n    matrix = [[0 for _ in range(n)] for _ in range(n)]\n    \n    # Define the directions: right, down, left, up\n    directions = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n    \n    # Initialize variables\n    row, col = 0, 0\n    dir_index = 0\n    current_num = 1\n    \n    # Fill the matrix in spiral order\n    while current_num <= n * n:\n        matrix[row][col] = current_num\n        current_num += 1\n        \n        # Calculate the next position\n        next_row = row + directions[dir_index][0]\n        next_col = col + directions[dir_index][1]\n        \n        # Check if we need to change direction\n        if (next_row < 0 or next_row >= n or next_col < 0 or next_col >= n or\n            matrix[next_row][next_col] != 0):\n            # Change direction\n            dir_index = (dir_index + 1) % 4\n            next_row = row + directions[dir_index][0]\n            next_col = col + directions[dir_index][1]\n        \n        # Move to the next position\n        row, col = next_row, next_col\n    \n    return matrix\n\n", "test": "def check(candidate):\n    assert candidate(30) == [[1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30], [116, 117, 118, 119, 120, 121, 122, 123, 124, 125, 126, 127, 128, 129, 130, 131, 132, 133, 134, 135, 136, 137, 138, 139, 140, 141, 142, 143, 144, 31], [115, 224, 225, 226, 227, 228, 229, 230, 231, 232, 233, 234, 235, 236, 237, 238, 239, 240, 241, 242, 243, 244, 245, 246, 247, 248, 249, 250, 145, 32], [114, 223, 324, 325, 326, 327, 328, 329, 330, 331, 332, 333, 334, 335, 336, 337, 338, 339, 340, 341, 342, 343, 344, 345, 346, 347, 348, 251, 146, 33], [113, 222, 323, 416, 417, 418, 419, 420, 421, 422, 423, 424, 425, 426, 427, 428, 429, 430, 431, 432, 433, 434, 435, 436, 437, 438, 349, 252, 147, 34], [112, 221, 322, 415, 500, 501, 502, 503, 504, 505, 506, 507, 508, 509, 510, 511, 512, 513, 514, 515, 516, 517, 518, 519, 520, 439, 350, 253, 148, 35], [111, 220, 321, 414, 499, 576, 577, 578, 579, 580, 581, 582, 583, 584, 585, 586, 587, 588, 589, 590, 591, 592, 593, 594, 521, 440, 351, 254, 149, 36], [110, 219, 320, 413, 498, 575, 644, 645, 646, 647, 648, 649, 650, 651, 652, 653, 654, 655, 656, 657, 658, 659, 660, 595, 522, 441, 352, 255, 150, 37], [109, 218, 319, 412, 497, 574, 643, 704, 705, 706, 707, 708, 709, 710, 711, 712, 713, 714, 715, 716, 717, 718, 661, 596, 523, 442, 353, 256, 151, 38], [108, 217, 318, 411, 496, 573, 642, 703, 756, 757, 758, 759, 760, 761, 762, 763, 764, 765, 766, 767, 768, 719, 662, 597, 524, 443, 354, 257, 152, 39], [107, 216, 317, 410, 495, 572, 641, 702, 755, 800, 801, 802, 803, 804, 805, 806, 807, 808, 809, 810, 769, 720, 663, 598, 525, 444, 355, 258, 153, 40], [106, 215, 316, 409, 494, 571, 640, 701, 754, 799, 836, 837, 838, 839, 840, 841, 842, 843, 844, 811, 770, 721, 664, 599, 526, 445, 356, 259, 154, 41], [105, 214, 315, 408, 493, 570, 639, 700, 753, 798, 835, 864, 865, 866, 867, 868, 869, 870, 845, 812, 771, 722, 665, 600, 527, 446, 357, 260, 155, 42], [104, 213, 314, 407, 492, 569, 638, 699, 752, 797, 834, 863, 884, 885, 886, 887, 888, 871, 846, 813, 772, 723, 666, 601, 528, 447, 358, 261, 156, 43], [103, 212, 313, 406, 491, 568, 637, 698, 751, 796, 833, 862, 883, 896, 897, 898, 889, 872, 847, 814, 773, 724, 667, 602, 529, 448, 359, 262, 157, 44], [102, 211, 312, 405, 490, 567, 636, 697, 750, 795, 832, 861, 882, 895, 900, 899, 890, 873, 848, 815, 774, 725, 668, 603, 530, 449, 360, 263, 158, 45], [101, 210, 311, 404, 489, 566, 635, 696, 749, 794, 831, 860, 881, 894, 893, 892, 891, 874, 849, 816, 775, 726, 669, 604, 531, 450, 361, 264, 159, 46], [100, 209, 310, 403, 488, 565, 634, 695, 748, 793, 830, 859, 880, 879, 878, 877, 876, 875, 850, 817, 776, 727, 670, 605, 532, 451, 362, 265, 160, 47], [99, 208, 309, 402, 487, 564, 633, 694, 747, 792, 829, 858, 857, 856, 855, 854, 853, 852, 851, 818, 777, 728, 671, 606, 533, 452, 363, 266, 161, 48], [98, 207, 308, 401, 486, 563, 632, 693, 746, 791, 828, 827, 826, 825, 824, 823, 822, 821, 820, 819, 778, 729, 672, 607, 534, 453, 364, 267, 162, 49], [97, 206, 307, 400, 485, 562, 631, 692, 745, 790, 789, 788, 787, 786, 785, 784, 783, 782, 781, 780, 779, 730, 673, 608, 535, 454, 365, 268, 163, 50], [96, 205, 306, 399, 484, 561, 630, 691, 744, 743, 742, 741, 740, 739, 738, 737, 736, 735, 734, 733, 732, 731, 674, 609, 536, 455, 366, 269, 164, 51], [95, 204, 305, 398, 483, 560, 629, 690, 689, 688, 687, 686, 685, 684, 683, 682, 681, 680, 679, 678, 677, 676, 675, 610, 537, 456, 367, 270, 165, 52], [94, 203, 304, 397, 482, 559, 628, 627, 626, 625, 624, 623, 622, 621, 620, 619, 618, 617, 616, 615, 614, 613, 612, 611, 538, 457, 368, 271, 166, 53], [93, 202, 303, 396, 481, 558, 557, 556, 555, 554, 553, 552, 551, 550, 549, 548, 547, 546, 545, 544, 543, 542, 541, 540, 539, 458, 369, 272, 167, 54], [92, 201, 302, 395, 480, 479, 478, 477, 476, 475, 474, 473, 472, 471, 470, 469, 468, 467, 466, 465, 464, 463, 462, 461, 460, 459, 370, 273, 168, 55], [91, 200, 301, 394, 393, 392, 391, 390, 389, 388, 387, 386, 385, 384, 383, 382, 381, 380, 379, 378, 377, 376, 375, 374, 373, 372, 371, 274, 169, 56], [90, 199, 300, 299, 298, 297, 296, 295, 294, 293, 292, 291, 290, 289, 288, 287, 286, 285, 284, 283, 282, 281, 280, 279, 278, 277, 276, 275, 170, 57], [89, 198, 197, 196, 195, 194, 193, 192, 191, 190, 189, 188, 187, 186, 185, 184, 183, 182, 181, 180, 179, 178, 177, 176, 175, 174, 173, 172, 171, 58], [88, 87, 86, 85, 84, 83, 82, 81, 80, 79, 78, 77, 76, 75, 74, 73, 72, 71, 70, 69, 68, 67, 66, 65, 64, 63, 62, 61, 60, 59]]\n    assert candidate(4) == [[1, 2, 3, 4], [12, 13, 14, 5], [11, 16, 15, 6], [10, 9, 8, 7]]\n    assert candidate(0) == []\n    assert candidate(1) == [[1]]\n    assert candidate(99) == [[1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99], [392, 393, 394, 395, 396, 397, 398, 399, 400, 401, 402, 403, 404, 405, 406, 407, 408, 409, 410, 411, 412, 413, 414, 415, 416, 417, 418, 419, 420, 421, 422, 423, 424, 425, 426, 427, 428, 429, 430, 431, 432, 433, 434, 435, 436, 437, 438, 439, 440, 441, 442, 443, 444, 445, 446, 447, 448, 449, 450, 451, 452, 453, 454, 455, 456, 457, 458, 459, 460, 461, 462, 463, 464, 465, 466, 467, 468, 469, 470, 471, 472, 473, 474, 475, 476, 477, 478, 479, 480, 481, 482, 483, 484, 485, 486, 487, 488, 489, 100], [391, 776, 777, 778, 779, 780, 781, 782, 783, 784, 785, 786, 787, 788, 789, 790, 791, 792, 793, 794, 795, 796, 797, 798, 799, 800, 801, 802, 803, 804, 805, 806, 807, 808, 809, 810, 811, 812, 813, 814, 815, 816, 817, 818, 819, 820, 821, 822, 823, 824, 825, 826, 827, 828, 829, 830, 831, 832, 833, 834, 835, 836, 837, 838, 839, 840, 841, 842, 843, 844, 845, 846, 847, 848, 849, 850, 851, 852, 853, 854, 855, 856, 857, 858, 859, 860, 861, 862, 863, 864, 865, 866, 867, 868, 869, 870, 871, 490, 101], [390, 775, 1152, 1153, 1154, 1155, 1156, 1157, 1158, 1159, 1160, 1161, 1162, 1163, 1164, 1165, 1166, 1167, 1168, 1169, 1170, 1171, 1172, 1173, 1174, 1175, 1176, 1177, 1178, 1179, 1180, 1181, 1182, 1183, 1184, 1185, 1186, 1187, 1188, 1189, 1190, 1191, 1192, 1193, 1194, 1195, 1196, 1197, 1198, 1199, 1200, 1201, 1202, 1203, 1204, 1205, 1206, 1207, 1208, 1209, 1210, 1211, 1212, 1213, 1214, 1215, 1216, 1217, 1218, 1219, 1220, 1221, 1222, 1223, 1224, 1225, 1226, 1227, 1228, 1229, 1230, 1231, 1232, 1233, 1234, 1235, 1236, 1237, 1238, 1239, 1240, 1241, 1242, 1243, 1244, 1245, 872, 491, 102], [389, 774, 1151, 1520, 1521, 1522, 1523, 1524, 1525, 1526, 1527, 1528, 1529, 1530, 1531, 1532, 1533, 1534, 1535, 1536, 1537, 1538, 1539, 1540, 1541, 1542, 1543, 1544, 1545, 1546, 1547, 1548, 1549, 1550, 1551, 1552, 1553, 1554, 1555, 1556, 1557, 1558, 1559, 1560, 1561, 1562, 1563, 1564, 1565, 1566, 1567, 1568, 1569, 1570, 1571, 1572, 1573, 1574, 1575, 1576, 1577, 1578, 1579, 1580, 1581, 1582, 1583, 1584, 1585, 1586, 1587, 1588, 1589, 1590, 1591, 1592, 1593, 1594, 1595, 1596, 1597, 1598, 1599, 1600, 1601, 1602, 1603, 1604, 1605, 1606, 1607, 1608, 1609, 1610, 1611, 1246, 873, 492, 103], [388, 773, 1150, 1519, 1880, 1881, 1882, 1883, 1884, 1885, 1886, 1887, 1888, 1889, 1890, 1891, 1892, 1893, 1894, 1895, 1896, 1897, 1898, 1899, 1900, 1901, 1902, 1903, 1904, 1905, 1906, 1907, 1908, 1909, 1910, 1911, 1912, 1913, 1914, 1915, 1916, 1917, 1918, 1919, 1920, 1921, 1922, 1923, 1924, 1925, 1926, 1927, 1928, 1929, 1930, 1931, 1932, 1933, 1934, 1935, 1936, 1937, 1938, 1939, 1940, 1941, 1942, 1943, 1944, 1945, 1946, 1947, 1948, 1949, 1950, 1951, 1952, 1953, 1954, 1955, 1956, 1957, 1958, 1959, 1960, 1961, 1962, 1963, 1964, 1965, 1966, 1967, 1968, 1969, 1612, 1247, 874, 493, 104], [387, 772, 1149, 1518, 1879, 2232, 2233, 2234, 2235, 2236, 2237, 2238, 2239, 2240, 2241, 2242, 2243, 2244, 2245, 2246, 2247, 2248, 2249, 2250, 2251, 2252, 2253, 2254, 2255, 2256, 2257, 2258, 2259, 2260, 2261, 2262, 2263, 2264, 2265, 2266, 2267, 2268, 2269, 2270, 2271, 2272, 2273, 2274, 2275, 2276, 2277, 2278, 2279, 2280, 2281, 2282, 2283, 2284, 2285, 2286, 2287, 2288, 2289, 2290, 2291, 2292, 2293, 2294, 2295, 2296, 2297, 2298, 2299, 2300, 2301, 2302, 2303, 2304, 2305, 2306, 2307, 2308, 2309, 2310, 2311, 2312, 2313, 2314, 2315, 2316, 2317, 2318, 2319, 1970, 1613, 1248, 875, 494, 105], [386, 771, 1148, 1517, 1878, 2231, 2576, 2577, 2578, 2579, 2580, 2581, 2582, 2583, 2584, 2585, 2586, 2587, 2588, 2589, 2590, 2591, 2592, 2593, 2594, 2595, 2596, 2597, 2598, 2599, 2600, 2601, 2602, 2603, 2604, 2605, 2606, 2607, 2608, 2609, 2610, 2611, 2612, 2613, 2614, 2615, 2616, 2617, 2618, 2619, 2620, 2621, 2622, 2623, 2624, 2625, 2626, 2627, 2628, 2629, 2630, 2631, 2632, 2633, 2634, 2635, 2636, 2637, 2638, 2639, 2640, 2641, 2642, 2643, 2644, 2645, 2646, 2647, 2648, 2649, 2650, 2651, 2652, 2653, 2654, 2655, 2656, 2657, 2658, 2659, 2660, 2661, 2320, 1971, 1614, 1249, 876, 495, 106], [385, 770, 1147, 1516, 1877, 2230, 2575, 2912, 2913, 2914, 2915, 2916, 2917, 2918, 2919, 2920, 2921, 2922, 2923, 2924, 2925, 2926, 2927, 2928, 2929, 2930, 2931, 2932, 2933, 2934, 2935, 2936, 2937, 2938, 2939, 2940, 2941, 2942, 2943, 2944, 2945, 2946, 2947, 2948, 2949, 2950, 2951, 2952, 2953, 2954, 2955, 2956, 2957, 2958, 2959, 2960, 2961, 2962, 2963, 2964, 2965, 2966, 2967, 2968, 2969, 2970, 2971, 2972, 2973, 2974, 2975, 2976, 2977, 2978, 2979, 2980, 2981, 2982, 2983, 2984, 2985, 2986, 2987, 2988, 2989, 2990, 2991, 2992, 2993, 2994, 2995, 2662, 2321, 1972, 1615, 1250, 877, 496, 107], [384, 769, 1146, 1515, 1876, 2229, 2574, 2911, 3240, 3241, 3242, 3243, 3244, 3245, 3246, 3247, 3248, 3249, 3250, 3251, 3252, 3253, 3254, 3255, 3256, 3257, 3258, 3259, 3260, 3261, 3262, 3263, 3264, 3265, 3266, 3267, 3268, 3269, 3270, 3271, 3272, 3273, 3274, 3275, 3276, 3277, 3278, 3279, 3280, 3281, 3282, 3283, 3284, 3285, 3286, 3287, 3288, 3289, 3290, 3291, 3292, 3293, 3294, 3295, 3296, 3297, 3298, 3299, 3300, 3301, 3302, 3303, 3304, 3305, 3306, 3307, 3308, 3309, 3310, 3311, 3312, 3313, 3314, 3315, 3316, 3317, 3318, 3319, 3320, 3321, 2996, 2663, 2322, 1973, 1616, 1251, 878, 497, 108], [383, 768, 1145, 1514, 1875, 2228, 2573, 2910, 3239, 3560, 3561, 3562, 3563, 3564, 3565, 3566, 3567, 3568, 3569, 3570, 3571, 3572, 3573, 3574, 3575, 3576, 3577, 3578, 3579, 3580, 3581, 3582, 3583, 3584, 3585, 3586, 3587, 3588, 3589, 3590, 3591, 3592, 3593, 3594, 3595, 3596, 3597, 3598, 3599, 3600, 3601, 3602, 3603, 3604, 3605, 3606, 3607, 3608, 3609, 3610, 3611, 3612, 3613, 3614, 3615, 3616, 3617, 3618, 3619, 3620, 3621, 3622, 3623, 3624, 3625, 3626, 3627, 3628, 3629, 3630, 3631, 3632, 3633, 3634, 3635, 3636, 3637, 3638, 3639, 3322, 2997, 2664, 2323, 1974, 1617, 1252, 879, 498, 109], [382, 767, 1144, 1513, 1874, 2227, 2572, 2909, 3238, 3559, 3872, 3873, 3874, 3875, 3876, 3877, 3878, 3879, 3880, 3881, 3882, 3883, 3884, 3885, 3886, 3887, 3888, 3889, 3890, 3891, 3892, 3893, 3894, 3895, 3896, 3897, 3898, 3899, 3900, 3901, 3902, 3903, 3904, 3905, 3906, 3907, 3908, 3909, 3910, 3911, 3912, 3913, 3914, 3915, 3916, 3917, 3918, 3919, 3920, 3921, 3922, 3923, 3924, 3925, 3926, 3927, 3928, 3929, 3930, 3931, 3932, 3933, 3934, 3935, 3936, 3937, 3938, 3939, 3940, 3941, 3942, 3943, 3944, 3945, 3946, 3947, 3948, 3949, 3640, 3323, 2998, 2665, 2324, 1975, 1618, 1253, 880, 499, 110], [381, 766, 1143, 1512, 1873, 2226, 2571, 2908, 3237, 3558, 3871, 4176, 4177, 4178, 4179, 4180, 4181, 4182, 4183, 4184, 4185, 4186, 4187, 4188, 4189, 4190, 4191, 4192, 4193, 4194, 4195, 4196, 4197, 4198, 4199, 4200, 4201, 4202, 4203, 4204, 4205, 4206, 4207, 4208, 4209, 4210, 4211, 4212, 4213, 4214, 4215, 4216, 4217, 4218, 4219, 4220, 4221, 4222, 4223, 4224, 4225, 4226, 4227, 4228, 4229, 4230, 4231, 4232, 4233, 4234, 4235, 4236, 4237, 4238, 4239, 4240, 4241, 4242, 4243, 4244, 4245, 4246, 4247, 4248, 4249, 4250, 4251, 3950, 3641, 3324, 2999, 2666, 2325, 1976, 1619, 1254, 881, 500, 111], [380, 765, 1142, 1511, 1872, 2225, 2570, 2907, 3236, 3557, 3870, 4175, 4472, 4473, 4474, 4475, 4476, 4477, 4478, 4479, 4480, 4481, 4482, 4483, 4484, 4485, 4486, 4487, 4488, 4489, 4490, 4491, 4492, 4493, 4494, 4495, 4496, 4497, 4498, 4499, 4500, 4501, 4502, 4503, 4504, 4505, 4506, 4507, 4508, 4509, 4510, 4511, 4512, 4513, 4514, 4515, 4516, 4517, 4518, 4519, 4520, 4521, 4522, 4523, 4524, 4525, 4526, 4527, 4528, 4529, 4530, 4531, 4532, 4533, 4534, 4535, 4536, 4537, 4538, 4539, 4540, 4541, 4542, 4543, 4544, 4545, 4252, 3951, 3642, 3325, 3000, 2667, 2326, 1977, 1620, 1255, 882, 501, 112], [379, 764, 1141, 1510, 1871, 2224, 2569, 2906, 3235, 3556, 3869, 4174, 4471, 4760, 4761, 4762, 4763, 4764, 4765, 4766, 4767, 4768, 4769, 4770, 4771, 4772, 4773, 4774, 4775, 4776, 4777, 4778, 4779, 4780, 4781, 4782, 4783, 4784, 4785, 4786, 4787, 4788, 4789, 4790, 4791, 4792, 4793, 4794, 4795, 4796, 4797, 4798, 4799, 4800, 4801, 4802, 4803, 4804, 4805, 4806, 4807, 4808, 4809, 4810, 4811, 4812, 4813, 4814, 4815, 4816, 4817, 4818, 4819, 4820, 4821, 4822, 4823, 4824, 4825, 4826, 4827, 4828, 4829, 4830, 4831, 4546, 4253, 3952, 3643, 3326, 3001, 2668, 2327, 1978, 1621, 1256, 883, 502, 113], [378, 763, 1140, 1509, 1870, 2223, 2568, 2905, 3234, 3555, 3868, 4173, 4470, 4759, 5040, 5041, 5042, 5043, 5044, 5045, 5046, 5047, 5048, 5049, 5050, 5051, 5052, 5053, 5054, 5055, 5056, 5057, 5058, 5059, 5060, 5061, 5062, 5063, 5064, 5065, 5066, 5067, 5068, 5069, 5070, 5071, 5072, 5073, 5074, 5075, 5076, 5077, 5078, 5079, 5080, 5081, 5082, 5083, 5084, 5085, 5086, 5087, 5088, 5089, 5090, 5091, 5092, 5093, 5094, 5095, 5096, 5097, 5098, 5099, 5100, 5101, 5102, 5103, 5104, 5105, 5106, 5107, 5108, 5109, 4832, 4547, 4254, 3953, 3644, 3327, 3002, 2669, 2328, 1979, 1622, 1257, 884, 503, 114], [377, 762, 1139, 1508, 1869, 2222, 2567, 2904, 3233, 3554, 3867, 4172, 4469, 4758, 5039, 5312, 5313, 5314, 5315, 5316, 5317, 5318, 5319, 5320, 5321, 5322, 5323, 5324, 5325, 5326, 5327, 5328, 5329, 5330, 5331, 5332, 5333, 5334, 5335, 5336, 5337, 5338, 5339, 5340, 5341, 5342, 5343, 5344, 5345, 5346, 5347, 5348, 5349, 5350, 5351, 5352, 5353, 5354, 5355, 5356, 5357, 5358, 5359, 5360, 5361, 5362, 5363, 5364, 5365, 5366, 5367, 5368, 5369, 5370, 5371, 5372, 5373, 5374, 5375, 5376, 5377, 5378, 5379, 5110, 4833, 4548, 4255, 3954, 3645, 3328, 3003, 2670, 2329, 1980, 1623, 1258, 885, 504, 115], [376, 761, 1138, 1507, 1868, 2221, 2566, 2903, 3232, 3553, 3866, 4171, 4468, 4757, 5038, 5311, 5576, 5577, 5578, 5579, 5580, 5581, 5582, 5583, 5584, 5585, 5586, 5587, 5588, 5589, 5590, 5591, 5592, 5593, 5594, 5595, 5596, 5597, 5598, 5599, 5600, 5601, 5602, 5603, 5604, 5605, 5606, 5607, 5608, 5609, 5610, 5611, 5612, 5613, 5614, 5615, 5616, 5617, 5618, 5619, 5620, 5621, 5622, 5623, 5624, 5625, 5626, 5627, 5628, 5629, 5630, 5631, 5632, 5633, 5634, 5635, 5636, 5637, 5638, 5639, 5640, 5641, 5380, 5111, 4834, 4549, 4256, 3955, 3646, 3329, 3004, 2671, 2330, 1981, 1624, 1259, 886, 505, 116], [375, 760, 1137, 1506, 1867, 2220, 2565, 2902, 3231, 3552, 3865, 4170, 4467, 4756, 5037, 5310, 5575, 5832, 5833, 5834, 5835, 5836, 5837, 5838, 5839, 5840, 5841, 5842, 5843, 5844, 5845, 5846, 5847, 5848, 5849, 5850, 5851, 5852, 5853, 5854, 5855, 5856, 5857, 5858, 5859, 5860, 5861, 5862, 5863, 5864, 5865, 5866, 5867, 5868, 5869, 5870, 5871, 5872, 5873, 5874, 5875, 5876, 5877, 5878, 5879, 5880, 5881, 5882, 5883, 5884, 5885, 5886, 5887, 5888, 5889, 5890, 5891, 5892, 5893, 5894, 5895, 5642, 5381, 5112, 4835, 4550, 4257, 3956, 3647, 3330, 3005, 2672, 2331, 1982, 1625, 1260, 887, 506, 117], [374, 759, 1136, 1505, 1866, 2219, 2564, 2901, 3230, 3551, 3864, 4169, 4466, 4755, 5036, 5309, 5574, 5831, 6080, 6081, 6082, 6083, 6084, 6085, 6086, 6087, 6088, 6089, 6090, 6091, 6092, 6093, 6094, 6095, 6096, 6097, 6098, 6099, 6100, 6101, 6102, 6103, 6104, 6105, 6106, 6107, 6108, 6109, 6110, 6111, 6112, 6113, 6114, 6115, 6116, 6117, 6118, 6119, 6120, 6121, 6122, 6123, 6124, 6125, 6126, 6127, 6128, 6129, 6130, 6131, 6132, 6133, 6134, 6135, 6136, 6137, 6138, 6139, 6140, 6141, 5896, 5643, 5382, 5113, 4836, 4551, 4258, 3957, 3648, 3331, 3006, 2673, 2332, 1983, 1626, 1261, 888, 507, 118], [373, 758, 1135, 1504, 1865, 2218, 2563, 2900, 3229, 3550, 3863, 4168, 4465, 4754, 5035, 5308, 5573, 5830, 6079, 6320, 6321, 6322, 6323, 6324, 6325, 6326, 6327, 6328, 6329, 6330, 6331, 6332, 6333, 6334, 6335, 6336, 6337, 6338, 6339, 6340, 6341, 6342, 6343, 6344, 6345, 6346, 6347, 6348, 6349, 6350, 6351, 6352, 6353, 6354, 6355, 6356, 6357, 6358, 6359, 6360, 6361, 6362, 6363, 6364, 6365, 6366, 6367, 6368, 6369, 6370, 6371, 6372, 6373, 6374, 6375, 6376, 6377, 6378, 6379, 6142, 5897, 5644, 5383, 5114, 4837, 4552, 4259, 3958, 3649, 3332, 3007, 2674, 2333, 1984, 1627, 1262, 889, 508, 119], [372, 757, 1134, 1503, 1864, 2217, 2562, 2899, 3228, 3549, 3862, 4167, 4464, 4753, 5034, 5307, 5572, 5829, 6078, 6319, 6552, 6553, 6554, 6555, 6556, 6557, 6558, 6559, 6560, 6561, 6562, 6563, 6564, 6565, 6566, 6567, 6568, 6569, 6570, 6571, 6572, 6573, 6574, 6575, 6576, 6577, 6578, 6579, 6580, 6581, 6582, 6583, 6584, 6585, 6586, 6587, 6588, 6589, 6590, 6591, 6592, 6593, 6594, 6595, 6596, 6597, 6598, 6599, 6600, 6601, 6602, 6603, 6604, 6605, 6606, 6607, 6608, 6609, 6380, 6143, 5898, 5645, 5384, 5115, 4838, 4553, 4260, 3959, 3650, 3333, 3008, 2675, 2334, 1985, 1628, 1263, 890, 509, 120], [371, 756, 1133, 1502, 1863, 2216, 2561, 2898, 3227, 3548, 3861, 4166, 4463, 4752, 5033, 5306, 5571, 5828, 6077, 6318, 6551, 6776, 6777, 6778, 6779, 6780, 6781, 6782, 6783, 6784, 6785, 6786, 6787, 6788, 6789, 6790, 6791, 6792, 6793, 6794, 6795, 6796, 6797, 6798, 6799, 6800, 6801, 6802, 6803, 6804, 6805, 6806, 6807, 6808, 6809, 6810, 6811, 6812, 6813, 6814, 6815, 6816, 6817, 6818, 6819, 6820, 6821, 6822, 6823, 6824, 6825, 6826, 6827, 6828, 6829, 6830, 6831, 6610, 6381, 6144, 5899, 5646, 5385, 5116, 4839, 4554, 4261, 3960, 3651, 3334, 3009, 2676, 2335, 1986, 1629, 1264, 891, 510, 121], [370, 755, 1132, 1501, 1862, 2215, 2560, 2897, 3226, 3547, 3860, 4165, 4462, 4751, 5032, 5305, 5570, 5827, 6076, 6317, 6550, 6775, 6992, 6993, 6994, 6995, 6996, 6997, 6998, 6999, 7000, 7001, 7002, 7003, 7004, 7005, 7006, 7007, 7008, 7009, 7010, 7011, 7012, 7013, 7014, 7015, 7016, 7017, 7018, 7019, 7020, 7021, 7022, 7023, 7024, 7025, 7026, 7027, 7028, 7029, 7030, 7031, 7032, 7033, 7034, 7035, 7036, 7037, 7038, 7039, 7040, 7041, 7042, 7043, 7044, 7045, 6832, 6611, 6382, 6145, 5900, 5647, 5386, 5117, 4840, 4555, 4262, 3961, 3652, 3335, 3010, 2677, 2336, 1987, 1630, 1265, 892, 511, 122], [369, 754, 1131, 1500, 1861, 2214, 2559, 2896, 3225, 3546, 3859, 4164, 4461, 4750, 5031, 5304, 5569, 5826, 6075, 6316, 6549, 6774, 6991, 7200, 7201, 7202, 7203, 7204, 7205, 7206, 7207, 7208, 7209, 7210, 7211, 7212, 7213, 7214, 7215, 7216, 7217, 7218, 7219, 7220, 7221, 7222, 7223, 7224, 7225, 7226, 7227, 7228, 7229, 7230, 7231, 7232, 7233, 7234, 7235, 7236, 7237, 7238, 7239, 7240, 7241, 7242, 7243, 7244, 7245, 7246, 7247, 7248, 7249, 7250, 7251, 7046, 6833, 6612, 6383, 6146, 5901, 5648, 5387, 5118, 4841, 4556, 4263, 3962, 3653, 3336, 3011, 2678, 2337, 1988, 1631, 1266, 893, 512, 123], [368, 753, 1130, 1499, 1860, 2213, 2558, 2895, 3224, 3545, 3858, 4163, 4460, 4749, 5030, 5303, 5568, 5825, 6074, 6315, 6548, 6773, 6990, 7199, 7400, 7401, 7402, 7403, 7404, 7405, 7406, 7407, 7408, 7409, 7410, 7411, 7412, 7413, 7414, 7415, 7416, 7417, 7418, 7419, 7420, 7421, 7422, 7423, 7424, 7425, 7426, 7427, 7428, 7429, 7430, 7431, 7432, 7433, 7434, 7435, 7436, 7437, 7438, 7439, 7440, 7441, 7442, 7443, 7444, 7445, 7446, 7447, 7448, 7449, 7252, 7047, 6834, 6613, 6384, 6147, 5902, 5649, 5388, 5119, 4842, 4557, 4264, 3963, 3654, 3337, 3012, 2679, 2338, 1989, 1632, 1267, 894, 513, 124], [367, 752, 1129, 1498, 1859, 2212, 2557, 2894, 3223, 3544, 3857, 4162, 4459, 4748, 5029, 5302, 5567, 5824, 6073, 6314, 6547, 6772, 6989, 7198, 7399, 7592, 7593, 7594, 7595, 7596, 7597, 7598, 7599, 7600, 7601, 7602, 7603, 7604, 7605, 7606, 7607, 7608, 7609, 7610, 7611, 7612, 7613, 7614, 7615, 7616, 7617, 7618, 7619, 7620, 7621, 7622, 7623, 7624, 7625, 7626, 7627, 7628, 7629, 7630, 7631, 7632, 7633, 7634, 7635, 7636, 7637, 7638, 7639, 7450, 7253, 7048, 6835, 6614, 6385, 6148, 5903, 5650, 5389, 5120, 4843, 4558, 4265, 3964, 3655, 3338, 3013, 2680, 2339, 1990, 1633, 1268, 895, 514, 125], [366, 751, 1128, 1497, 1858, 2211, 2556, 2893, 3222, 3543, 3856, 4161, 4458, 4747, 5028, 5301, 5566, 5823, 6072, 6313, 6546, 6771, 6988, 7197, 7398, 7591, 7776, 7777, 7778, 7779, 7780, 7781, 7782, 7783, 7784, 7785, 7786, 7787, 7788, 7789, 7790, 7791, 7792, 7793, 7794, 7795, 7796, 7797, 7798, 7799, 7800, 7801, 7802, 7803, 7804, 7805, 7806, 7807, 7808, 7809, 7810, 7811, 7812, 7813, 7814, 7815, 7816, 7817, 7818, 7819, 7820, 7821, 7640, 7451, 7254, 7049, 6836, 6615, 6386, 6149, 5904, 5651, 5390, 5121, 4844, 4559, 4266, 3965, 3656, 3339, 3014, 2681, 2340, 1991, 1634, 1269, 896, 515, 126], [365, 750, 1127, 1496, 1857, 2210, 2555, 2892, 3221, 3542, 3855, 4160, 4457, 4746, 5027, 5300, 5565, 5822, 6071, 6312, 6545, 6770, 6987, 7196, 7397, 7590, 7775, 7952, 7953, 7954, 7955, 7956, 7957, 7958, 7959, 7960, 7961, 7962, 7963, 7964, 7965, 7966, 7967, 7968, 7969, 7970, 7971, 7972, 7973, 7974, 7975, 7976, 7977, 7978, 7979, 7980, 7981, 7982, 7983, 7984, 7985, 7986, 7987, 7988, 7989, 7990, 7991, 7992, 7993, 7994, 7995, 7822, 7641, 7452, 7255, 7050, 6837, 6616, 6387, 6150, 5905, 5652, 5391, 5122, 4845, 4560, 4267, 3966, 3657, 3340, 3015, 2682, 2341, 1992, 1635, 1270, 897, 516, 127], [364, 749, 1126, 1495, 1856, 2209, 2554, 2891, 3220, 3541, 3854, 4159, 4456, 4745, 5026, 5299, 5564, 5821, 6070, 6311, 6544, 6769, 6986, 7195, 7396, 7589, 7774, 7951, 8120, 8121, 8122, 8123, 8124, 8125, 8126, 8127, 8128, 8129, 8130, 8131, 8132, 8133, 8134, 8135, 8136, 8137, 8138, 8139, 8140, 8141, 8142, 8143, 8144, 8145, 8146, 8147, 8148, 8149, 8150, 8151, 8152, 8153, 8154, 8155, 8156, 8157, 8158, 8159, 8160, 8161, 7996, 7823, 7642, 7453, 7256, 7051, 6838, 6617, 6388, 6151, 5906, 5653, 5392, 5123, 4846, 4561, 4268, 3967, 3658, 3341, 3016, 2683, 2342, 1993, 1636, 1271, 898, 517, 128], [363, 748, 1125, 1494, 1855, 2208, 2553, 2890, 3219, 3540, 3853, 4158, 4455, 4744, 5025, 5298, 5563, 5820, 6069, 6310, 6543, 6768, 6985, 7194, 7395, 7588, 7773, 7950, 8119, 8280, 8281, 8282, 8283, 8284, 8285, 8286, 8287, 8288, 8289, 8290, 8291, 8292, 8293, 8294, 8295, 8296, 8297, 8298, 8299, 8300, 8301, 8302, 8303, 8304, 8305, 8306, 8307, 8308, 8309, 8310, 8311, 8312, 8313, 8314, 8315, 8316, 8317, 8318, 8319, 8162, 7997, 7824, 7643, 7454, 7257, 7052, 6839, 6618, 6389, 6152, 5907, 5654, 5393, 5124, 4847, 4562, 4269, 3968, 3659, 3342, 3017, 2684, 2343, 1994, 1637, 1272, 899, 518, 129], [362, 747, 1124, 1493, 1854, 2207, 2552, 2889, 3218, 3539, 3852, 4157, 4454, 4743, 5024, 5297, 5562, 5819, 6068, 6309, 6542, 6767, 6984, 7193, 7394, 7587, 7772, 7949, 8118, 8279, 8432, 8433, 8434, 8435, 8436, 8437, 8438, 8439, 8440, 8441, 8442, 8443, 8444, 8445, 8446, 8447, 8448, 8449, 8450, 8451, 8452, 8453, 8454, 8455, 8456, 8457, 8458, 8459, 8460, 8461, 8462, 8463, 8464, 8465, 8466, 8467, 8468, 8469, 8320, 8163, 7998, 7825, 7644, 7455, 7258, 7053, 6840, 6619, 6390, 6153, 5908, 5655, 5394, 5125, 4848, 4563, 4270, 3969, 3660, 3343, 3018, 2685, 2344, 1995, 1638, 1273, 900, 519, 130], [361, 746, 1123, 1492, 1853, 2206, 2551, 2888, 3217, 3538, 3851, 4156, 4453, 4742, 5023, 5296, 5561, 5818, 6067, 6308, 6541, 6766, 6983, 7192, 7393, 7586, 7771, 7948, 8117, 8278, 8431, 8576, 8577, 8578, 8579, 8580, 8581, 8582, 8583, 8584, 8585, 8586, 8587, 8588, 8589, 8590, 8591, 8592, 8593, 8594, 8595, 8596, 8597, 8598, 8599, 8600, 8601, 8602, 8603, 8604, 8605, 8606, 8607, 8608, 8609, 8610, 8611, 8470, 8321, 8164, 7999, 7826, 7645, 7456, 7259, 7054, 6841, 6620, 6391, 6154, 5909, 5656, 5395, 5126, 4849, 4564, 4271, 3970, 3661, 3344, 3019, 2686, 2345, 1996, 1639, 1274, 901, 520, 131], [360, 745, 1122, 1491, 1852, 2205, 2550, 2887, 3216, 3537, 3850, 4155, 4452, 4741, 5022, 5295, 5560, 5817, 6066, 6307, 6540, 6765, 6982, 7191, 7392, 7585, 7770, 7947, 8116, 8277, 8430, 8575, 8712, 8713, 8714, 8715, 8716, 8717, 8718, 8719, 8720, 8721, 8722, 8723, 8724, 8725, 8726, 8727, 8728, 8729, 8730, 8731, 8732, 8733, 8734, 8735, 8736, 8737, 8738, 8739, 8740, 8741, 8742, 8743, 8744, 8745, 8612, 8471, 8322, 8165, 8000, 7827, 7646, 7457, 7260, 7055, 6842, 6621, 6392, 6155, 5910, 5657, 5396, 5127, 4850, 4565, 4272, 3971, 3662, 3345, 3020, 2687, 2346, 1997, 1640, 1275, 902, 521, 132], [359, 744, 1121, 1490, 1851, 2204, 2549, 2886, 3215, 3536, 3849, 4154, 4451, 4740, 5021, 5294, 5559, 5816, 6065, 6306, 6539, 6764, 6981, 7190, 7391, 7584, 7769, 7946, 8115, 8276, 8429, 8574, 8711, 8840, 8841, 8842, 8843, 8844, 8845, 8846, 8847, 8848, 8849, 8850, 8851, 8852, 8853, 8854, 8855, 8856, 8857, 8858, 8859, 8860, 8861, 8862, 8863, 8864, 8865, 8866, 8867, 8868, 8869, 8870, 8871, 8746, 8613, 8472, 8323, 8166, 8001, 7828, 7647, 7458, 7261, 7056, 6843, 6622, 6393, 6156, 5911, 5658, 5397, 5128, 4851, 4566, 4273, 3972, 3663, 3346, 3021, 2688, 2347, 1998, 1641, 1276, 903, 522, 133], [358, 743, 1120, 1489, 1850, 2203, 2548, 2885, 3214, 3535, 3848, 4153, 4450, 4739, 5020, 5293, 5558, 5815, 6064, 6305, 6538, 6763, 6980, 7189, 7390, 7583, 7768, 7945, 8114, 8275, 8428, 8573, 8710, 8839, 8960, 8961, 8962, 8963, 8964, 8965, 8966, 8967, 8968, 8969, 8970, 8971, 8972, 8973, 8974, 8975, 8976, 8977, 8978, 8979, 8980, 8981, 8982, 8983, 8984, 8985, 8986, 8987, 8988, 8989, 8872, 8747, 8614, 8473, 8324, 8167, 8002, 7829, 7648, 7459, 7262, 7057, 6844, 6623, 6394, 6157, 5912, 5659, 5398, 5129, 4852, 4567, 4274, 3973, 3664, 3347, 3022, 2689, 2348, 1999, 1642, 1277, 904, 523, 134], [357, 742, 1119, 1488, 1849, 2202, 2547, 2884, 3213, 3534, 3847, 4152, 4449, 4738, 5019, 5292, 5557, 5814, 6063, 6304, 6537, 6762, 6979, 7188, 7389, 7582, 7767, 7944, 8113, 8274, 8427, 8572, 8709, 8838, 8959, 9072, 9073, 9074, 9075, 9076, 9077, 9078, 9079, 9080, 9081, 9082, 9083, 9084, 9085, 9086, 9087, 9088, 9089, 9090, 9091, 9092, 9093, 9094, 9095, 9096, 9097, 9098, 9099, 8990, 8873, 8748, 8615, 8474, 8325, 8168, 8003, 7830, 7649, 7460, 7263, 7058, 6845, 6624, 6395, 6158, 5913, 5660, 5399, 5130, 4853, 4568, 4275, 3974, 3665, 3348, 3023, 2690, 2349, 2000, 1643, 1278, 905, 524, 135], [356, 741, 1118, 1487, 1848, 2201, 2546, 2883, 3212, 3533, 3846, 4151, 4448, 4737, 5018, 5291, 5556, 5813, 6062, 6303, 6536, 6761, 6978, 7187, 7388, 7581, 7766, 7943, 8112, 8273, 8426, 8571, 8708, 8837, 8958, 9071, 9176, 9177, 9178, 9179, 9180, 9181, 9182, 9183, 9184, 9185, 9186, 9187, 9188, 9189, 9190, 9191, 9192, 9193, 9194, 9195, 9196, 9197, 9198, 9199, 9200, 9201, 9100, 8991, 8874, 8749, 8616, 8475, 8326, 8169, 8004, 7831, 7650, 7461, 7264, 7059, 6846, 6625, 6396, 6159, 5914, 5661, 5400, 5131, 4854, 4569, 4276, 3975, 3666, 3349, 3024, 2691, 2350, 2001, 1644, 1279, 906, 525, 136], [355, 740, 1117, 1486, 1847, 2200, 2545, 2882, 3211, 3532, 3845, 4150, 4447, 4736, 5017, 5290, 5555, 5812, 6061, 6302, 6535, 6760, 6977, 7186, 7387, 7580, 7765, 7942, 8111, 8272, 8425, 8570, 8707, 8836, 8957, 9070, 9175, 9272, 9273, 9274, 9275, 9276, 9277, 9278, 9279, 9280, 9281, 9282, 9283, 9284, 9285, 9286, 9287, 9288, 9289, 9290, 9291, 9292, 9293, 9294, 9295, 9202, 9101, 8992, 8875, 8750, 8617, 8476, 8327, 8170, 8005, 7832, 7651, 7462, 7265, 7060, 6847, 6626, 6397, 6160, 5915, 5662, 5401, 5132, 4855, 4570, 4277, 3976, 3667, 3350, 3025, 2692, 2351, 2002, 1645, 1280, 907, 526, 137], [354, 739, 1116, 1485, 1846, 2199, 2544, 2881, 3210, 3531, 3844, 4149, 4446, 4735, 5016, 5289, 5554, 5811, 6060, 6301, 6534, 6759, 6976, 7185, 7386, 7579, 7764, 7941, 8110, 8271, 8424, 8569, 8706, 8835, 8956, 9069, 9174, 9271, 9360, 9361, 9362, 9363, 9364, 9365, 9366, 9367, 9368, 9369, 9370, 9371, 9372, 9373, 9374, 9375, 9376, 9377, 9378, 9379, 9380, 9381, 9296, 9203, 9102, 8993, 8876, 8751, 8618, 8477, 8328, 8171, 8006, 7833, 7652, 7463, 7266, 7061, 6848, 6627, 6398, 6161, 5916, 5663, 5402, 5133, 4856, 4571, 4278, 3977, 3668, 3351, 3026, 2693, 2352, 2003, 1646, 1281, 908, 527, 138], [353, 738, 1115, 1484, 1845, 2198, 2543, 2880, 3209, 3530, 3843, 4148, 4445, 4734, 5015, 5288, 5553, 5810, 6059, 6300, 6533, 6758, 6975, 7184, 7385, 7578, 7763, 7940, 8109, 8270, 8423, 8568, 8705, 8834, 8955, 9068, 9173, 9270, 9359, 9440, 9441, 9442, 9443, 9444, 9445, 9446, 9447, 9448, 9449, 9450, 9451, 9452, 9453, 9454, 9455, 9456, 9457, 9458, 9459, 9382, 9297, 9204, 9103, 8994, 8877, 8752, 8619, 8478, 8329, 8172, 8007, 7834, 7653, 7464, 7267, 7062, 6849, 6628, 6399, 6162, 5917, 5664, 5403, 5134, 4857, 4572, 4279, 3978, 3669, 3352, 3027, 2694, 2353, 2004, 1647, 1282, 909, 528, 139], [352, 737, 1114, 1483, 1844, 2197, 2542, 2879, 3208, 3529, 3842, 4147, 4444, 4733, 5014, 5287, 5552, 5809, 6058, 6299, 6532, 6757, 6974, 7183, 7384, 7577, 7762, 7939, 8108, 8269, 8422, 8567, 8704, 8833, 8954, 9067, 9172, 9269, 9358, 9439, 9512, 9513, 9514, 9515, 9516, 9517, 9518, 9519, 9520, 9521, 9522, 9523, 9524, 9525, 9526, 9527, 9528, 9529, 9460, 9383, 9298, 9205, 9104, 8995, 8878, 8753, 8620, 8479, 8330, 8173, 8008, 7835, 7654, 7465, 7268, 7063, 6850, 6629, 6400, 6163, 5918, 5665, 5404, 5135, 4858, 4573, 4280, 3979, 3670, 3353, 3028, 2695, 2354, 2005, 1648, 1283, 910, 529, 140], [351, 736, 1113, 1482, 1843, 2196, 2541, 2878, 3207, 3528, 3841, 4146, 4443, 4732, 5013, 5286, 5551, 5808, 6057, 6298, 6531, 6756, 6973, 7182, 7383, 7576, 7761, 7938, 8107, 8268, 8421, 8566, 8703, 8832, 8953, 9066, 9171, 9268, 9357, 9438, 9511, 9576, 9577, 9578, 9579, 9580, 9581, 9582, 9583, 9584, 9585, 9586, 9587, 9588, 9589, 9590, 9591, 9530, 9461, 9384, 9299, 9206, 9105, 8996, 8879, 8754, 8621, 8480, 8331, 8174, 8009, 7836, 7655, 7466, 7269, 7064, 6851, 6630, 6401, 6164, 5919, 5666, 5405, 5136, 4859, 4574, 4281, 3980, 3671, 3354, 3029, 2696, 2355, 2006, 1649, 1284, 911, 530, 141], [350, 735, 1112, 1481, 1842, 2195, 2540, 2877, 3206, 3527, 3840, 4145, 4442, 4731, 5012, 5285, 5550, 5807, 6056, 6297, 6530, 6755, 6972, 7181, 7382, 7575, 7760, 7937, 8106, 8267, 8420, 8565, 8702, 8831, 8952, 9065, 9170, 9267, 9356, 9437, 9510, 9575, 9632, 9633, 9634, 9635, 9636, 9637, 9638, 9639, 9640, 9641, 9642, 9643, 9644, 9645, 9592, 9531, 9462, 9385, 9300, 9207, 9106, 8997, 8880, 8755, 8622, 8481, 8332, 8175, 8010, 7837, 7656, 7467, 7270, 7065, 6852, 6631, 6402, 6165, 5920, 5667, 5406, 5137, 4860, 4575, 4282, 3981, 3672, 3355, 3030, 2697, 2356, 2007, 1650, 1285, 912, 531, 142], [349, 734, 1111, 1480, 1841, 2194, 2539, 2876, 3205, 3526, 3839, 4144, 4441, 4730, 5011, 5284, 5549, 5806, 6055, 6296, 6529, 6754, 6971, 7180, 7381, 7574, 7759, 7936, 8105, 8266, 8419, 8564, 8701, 8830, 8951, 9064, 9169, 9266, 9355, 9436, 9509, 9574, 9631, 9680, 9681, 9682, 9683, 9684, 9685, 9686, 9687, 9688, 9689, 9690, 9691, 9646, 9593, 9532, 9463, 9386, 9301, 9208, 9107, 8998, 8881, 8756, 8623, 8482, 8333, 8176, 8011, 7838, 7657, 7468, 7271, 7066, 6853, 6632, 6403, 6166, 5921, 5668, 5407, 5138, 4861, 4576, 4283, 3982, 3673, 3356, 3031, 2698, 2357, 2008, 1651, 1286, 913, 532, 143], [348, 733, 1110, 1479, 1840, 2193, 2538, 2875, 3204, 3525, 3838, 4143, 4440, 4729, 5010, 5283, 5548, 5805, 6054, 6295, 6528, 6753, 6970, 7179, 7380, 7573, 7758, 7935, 8104, 8265, 8418, 8563, 8700, 8829, 8950, 9063, 9168, 9265, 9354, 9435, 9508, 9573, 9630, 9679, 9720, 9721, 9722, 9723, 9724, 9725, 9726, 9727, 9728, 9729, 9692, 9647, 9594, 9533, 9464, 9387, 9302, 9209, 9108, 8999, 8882, 8757, 8624, 8483, 8334, 8177, 8012, 7839, 7658, 7469, 7272, 7067, 6854, 6633, 6404, 6167, 5922, 5669, 5408, 5139, 4862, 4577, 4284, 3983, 3674, 3357, 3032, 2699, 2358, 2009, 1652, 1287, 914, 533, 144], [347, 732, 1109, 1478, 1839, 2192, 2537, 2874, 3203, 3524, 3837, 4142, 4439, 4728, 5009, 5282, 5547, 5804, 6053, 6294, 6527, 6752, 6969, 7178, 7379, 7572, 7757, 7934, 8103, 8264, 8417, 8562, 8699, 8828, 8949, 9062, 9167, 9264, 9353, 9434, 9507, 9572, 9629, 9678, 9719, 9752, 9753, 9754, 9755, 9756, 9757, 9758, 9759, 9730, 9693, 9648, 9595, 9534, 9465, 9388, 9303, 9210, 9109, 9000, 8883, 8758, 8625, 8484, 8335, 8178, 8013, 7840, 7659, 7470, 7273, 7068, 6855, 6634, 6405, 6168, 5923, 5670, 5409, 5140, 4863, 4578, 4285, 3984, 3675, 3358, 3033, 2700, 2359, 2010, 1653, 1288, 915, 534, 145], [346, 731, 1108, 1477, 1838, 2191, 2536, 2873, 3202, 3523, 3836, 4141, 4438, 4727, 5008, 5281, 5546, 5803, 6052, 6293, 6526, 6751, 6968, 7177, 7378, 7571, 7756, 7933, 8102, 8263, 8416, 8561, 8698, 8827, 8948, 9061, 9166, 9263, 9352, 9433, 9506, 9571, 9628, 9677, 9718, 9751, 9776, 9777, 9778, 9779, 9780, 9781, 9760, 9731, 9694, 9649, 9596, 9535, 9466, 9389, 9304, 9211, 9110, 9001, 8884, 8759, 8626, 8485, 8336, 8179, 8014, 7841, 7660, 7471, 7274, 7069, 6856, 6635, 6406, 6169, 5924, 5671, 5410, 5141, 4864, 4579, 4286, 3985, 3676, 3359, 3034, 2701, 2360, 2011, 1654, 1289, 916, 535, 146], [345, 730, 1107, 1476, 1837, 2190, 2535, 2872, 3201, 3522, 3835, 4140, 4437, 4726, 5007, 5280, 5545, 5802, 6051, 6292, 6525, 6750, 6967, 7176, 7377, 7570, 7755, 7932, 8101, 8262, 8415, 8560, 8697, 8826, 8947, 9060, 9165, 9262, 9351, 9432, 9505, 9570, 9627, 9676, 9717, 9750, 9775, 9792, 9793, 9794, 9795, 9782, 9761, 9732, 9695, 9650, 9597, 9536, 9467, 9390, 9305, 9212, 9111, 9002, 8885, 8760, 8627, 8486, 8337, 8180, 8015, 7842, 7661, 7472, 7275, 7070, 6857, 6636, 6407, 6170, 5925, 5672, 5411, 5142, 4865, 4580, 4287, 3986, 3677, 3360, 3035, 2702, 2361, 2012, 1655, 1290, 917, 536, 147], [344, 729, 1106, 1475, 1836, 2189, 2534, 2871, 3200, 3521, 3834, 4139, 4436, 4725, 5006, 5279, 5544, 5801, 6050, 6291, 6524, 6749, 6966, 7175, 7376, 7569, 7754, 7931, 8100, 8261, 8414, 8559, 8696, 8825, 8946, 9059, 9164, 9261, 9350, 9431, 9504, 9569, 9626, 9675, 9716, 9749, 9774, 9791, 9800, 9801, 9796, 9783, 9762, 9733, 9696, 9651, 9598, 9537, 9468, 9391, 9306, 9213, 9112, 9003, 8886, 8761, 8628, 8487, 8338, 8181, 8016, 7843, 7662, 7473, 7276, 7071, 6858, 6637, 6408, 6171, 5926, 5673, 5412, 5143, 4866, 4581, 4288, 3987, 3678, 3361, 3036, 2703, 2362, 2013, 1656, 1291, 918, 537, 148], [343, 728, 1105, 1474, 1835, 2188, 2533, 2870, 3199, 3520, 3833, 4138, 4435, 4724, 5005, 5278, 5543, 5800, 6049, 6290, 6523, 6748, 6965, 7174, 7375, 7568, 7753, 7930, 8099, 8260, 8413, 8558, 8695, 8824, 8945, 9058, 9163, 9260, 9349, 9430, 9503, 9568, 9625, 9674, 9715, 9748, 9773, 9790, 9799, 9798, 9797, 9784, 9763, 9734, 9697, 9652, 9599, 9538, 9469, 9392, 9307, 9214, 9113, 9004, 8887, 8762, 8629, 8488, 8339, 8182, 8017, 7844, 7663, 7474, 7277, 7072, 6859, 6638, 6409, 6172, 5927, 5674, 5413, 5144, 4867, 4582, 4289, 3988, 3679, 3362, 3037, 2704, 2363, 2014, 1657, 1292, 919, 538, 149], [342, 727, 1104, 1473, 1834, 2187, 2532, 2869, 3198, 3519, 3832, 4137, 4434, 4723, 5004, 5277, 5542, 5799, 6048, 6289, 6522, 6747, 6964, 7173, 7374, 7567, 7752, 7929, 8098, 8259, 8412, 8557, 8694, 8823, 8944, 9057, 9162, 9259, 9348, 9429, 9502, 9567, 9624, 9673, 9714, 9747, 9772, 9789, 9788, 9787, 9786, 9785, 9764, 9735, 9698, 9653, 9600, 9539, 9470, 9393, 9308, 9215, 9114, 9005, 8888, 8763, 8630, 8489, 8340, 8183, 8018, 7845, 7664, 7475, 7278, 7073, 6860, 6639, 6410, 6173, 5928, 5675, 5414, 5145, 4868, 4583, 4290, 3989, 3680, 3363, 3038, 2705, 2364, 2015, 1658, 1293, 920, 539, 150], [341, 726, 1103, 1472, 1833, 2186, 2531, 2868, 3197, 3518, 3831, 4136, 4433, 4722, 5003, 5276, 5541, 5798, 6047, 6288, 6521, 6746, 6963, 7172, 7373, 7566, 7751, 7928, 8097, 8258, 8411, 8556, 8693, 8822, 8943, 9056, 9161, 9258, 9347, 9428, 9501, 9566, 9623, 9672, 9713, 9746, 9771, 9770, 9769, 9768, 9767, 9766, 9765, 9736, 9699, 9654, 9601, 9540, 9471, 9394, 9309, 9216, 9115, 9006, 8889, 8764, 8631, 8490, 8341, 8184, 8019, 7846, 7665, 7476, 7279, 7074, 6861, 6640, 6411, 6174, 5929, 5676, 5415, 5146, 4869, 4584, 4291, 3990, 3681, 3364, 3039, 2706, 2365, 2016, 1659, 1294, 921, 540, 151], [340, 725, 1102, 1471, 1832, 2185, 2530, 2867, 3196, 3517, 3830, 4135, 4432, 4721, 5002, 5275, 5540, 5797, 6046, 6287, 6520, 6745, 6962, 7171, 7372, 7565, 7750, 7927, 8096, 8257, 8410, 8555, 8692, 8821, 8942, 9055, 9160, 9257, 9346, 9427, 9500, 9565, 9622, 9671, 9712, 9745, 9744, 9743, 9742, 9741, 9740, 9739, 9738, 9737, 9700, 9655, 9602, 9541, 9472, 9395, 9310, 9217, 9116, 9007, 8890, 8765, 8632, 8491, 8342, 8185, 8020, 7847, 7666, 7477, 7280, 7075, 6862, 6641, 6412, 6175, 5930, 5677, 5416, 5147, 4870, 4585, 4292, 3991, 3682, 3365, 3040, 2707, 2366, 2017, 1660, 1295, 922, 541, 152], [339, 724, 1101, 1470, 1831, 2184, 2529, 2866, 3195, 3516, 3829, 4134, 4431, 4720, 5001, 5274, 5539, 5796, 6045, 6286, 6519, 6744, 6961, 7170, 7371, 7564, 7749, 7926, 8095, 8256, 8409, 8554, 8691, 8820, 8941, 9054, 9159, 9256, 9345, 9426, 9499, 9564, 9621, 9670, 9711, 9710, 9709, 9708, 9707, 9706, 9705, 9704, 9703, 9702, 9701, 9656, 9603, 9542, 9473, 9396, 9311, 9218, 9117, 9008, 8891, 8766, 8633, 8492, 8343, 8186, 8021, 7848, 7667, 7478, 7281, 7076, 6863, 6642, 6413, 6176, 5931, 5678, 5417, 5148, 4871, 4586, 4293, 3992, 3683, 3366, 3041, 2708, 2367, 2018, 1661, 1296, 923, 542, 153], [338, 723, 1100, 1469, 1830, 2183, 2528, 2865, 3194, 3515, 3828, 4133, 4430, 4719, 5000, 5273, 5538, 5795, 6044, 6285, 6518, 6743, 6960, 7169, 7370, 7563, 7748, 7925, 8094, 8255, 8408, 8553, 8690, 8819, 8940, 9053, 9158, 9255, 9344, 9425, 9498, 9563, 9620, 9669, 9668, 9667, 9666, 9665, 9664, 9663, 9662, 9661, 9660, 9659, 9658, 9657, 9604, 9543, 9474, 9397, 9312, 9219, 9118, 9009, 8892, 8767, 8634, 8493, 8344, 8187, 8022, 7849, 7668, 7479, 7282, 7077, 6864, 6643, 6414, 6177, 5932, 5679, 5418, 5149, 4872, 4587, 4294, 3993, 3684, 3367, 3042, 2709, 2368, 2019, 1662, 1297, 924, 543, 154], [337, 722, 1099, 1468, 1829, 2182, 2527, 2864, 3193, 3514, 3827, 4132, 4429, 4718, 4999, 5272, 5537, 5794, 6043, 6284, 6517, 6742, 6959, 7168, 7369, 7562, 7747, 7924, 8093, 8254, 8407, 8552, 8689, 8818, 8939, 9052, 9157, 9254, 9343, 9424, 9497, 9562, 9619, 9618, 9617, 9616, 9615, 9614, 9613, 9612, 9611, 9610, 9609, 9608, 9607, 9606, 9605, 9544, 9475, 9398, 9313, 9220, 9119, 9010, 8893, 8768, 8635, 8494, 8345, 8188, 8023, 7850, 7669, 7480, 7283, 7078, 6865, 6644, 6415, 6178, 5933, 5680, 5419, 5150, 4873, 4588, 4295, 3994, 3685, 3368, 3043, 2710, 2369, 2020, 1663, 1298, 925, 544, 155], [336, 721, 1098, 1467, 1828, 2181, 2526, 2863, 3192, 3513, 3826, 4131, 4428, 4717, 4998, 5271, 5536, 5793, 6042, 6283, 6516, 6741, 6958, 7167, 7368, 7561, 7746, 7923, 8092, 8253, 8406, 8551, 8688, 8817, 8938, 9051, 9156, 9253, 9342, 9423, 9496, 9561, 9560, 9559, 9558, 9557, 9556, 9555, 9554, 9553, 9552, 9551, 9550, 9549, 9548, 9547, 9546, 9545, 9476, 9399, 9314, 9221, 9120, 9011, 8894, 8769, 8636, 8495, 8346, 8189, 8024, 7851, 7670, 7481, 7284, 7079, 6866, 6645, 6416, 6179, 5934, 5681, 5420, 5151, 4874, 4589, 4296, 3995, 3686, 3369, 3044, 2711, 2370, 2021, 1664, 1299, 926, 545, 156], [335, 720, 1097, 1466, 1827, 2180, 2525, 2862, 3191, 3512, 3825, 4130, 4427, 4716, 4997, 5270, 5535, 5792, 6041, 6282, 6515, 6740, 6957, 7166, 7367, 7560, 7745, 7922, 8091, 8252, 8405, 8550, 8687, 8816, 8937, 9050, 9155, 9252, 9341, 9422, 9495, 9494, 9493, 9492, 9491, 9490, 9489, 9488, 9487, 9486, 9485, 9484, 9483, 9482, 9481, 9480, 9479, 9478, 9477, 9400, 9315, 9222, 9121, 9012, 8895, 8770, 8637, 8496, 8347, 8190, 8025, 7852, 7671, 7482, 7285, 7080, 6867, 6646, 6417, 6180, 5935, 5682, 5421, 5152, 4875, 4590, 4297, 3996, 3687, 3370, 3045, 2712, 2371, 2022, 1665, 1300, 927, 546, 157], [334, 719, 1096, 1465, 1826, 2179, 2524, 2861, 3190, 3511, 3824, 4129, 4426, 4715, 4996, 5269, 5534, 5791, 6040, 6281, 6514, 6739, 6956, 7165, 7366, 7559, 7744, 7921, 8090, 8251, 8404, 8549, 8686, 8815, 8936, 9049, 9154, 9251, 9340, 9421, 9420, 9419, 9418, 9417, 9416, 9415, 9414, 9413, 9412, 9411, 9410, 9409, 9408, 9407, 9406, 9405, 9404, 9403, 9402, 9401, 9316, 9223, 9122, 9013, 8896, 8771, 8638, 8497, 8348, 8191, 8026, 7853, 7672, 7483, 7286, 7081, 6868, 6647, 6418, 6181, 5936, 5683, 5422, 5153, 4876, 4591, 4298, 3997, 3688, 3371, 3046, 2713, 2372, 2023, 1666, 1301, 928, 547, 158], [333, 718, 1095, 1464, 1825, 2178, 2523, 2860, 3189, 3510, 3823, 4128, 4425, 4714, 4995, 5268, 5533, 5790, 6039, 6280, 6513, 6738, 6955, 7164, 7365, 7558, 7743, 7920, 8089, 8250, 8403, 8548, 8685, 8814, 8935, 9048, 9153, 9250, 9339, 9338, 9337, 9336, 9335, 9334, 9333, 9332, 9331, 9330, 9329, 9328, 9327, 9326, 9325, 9324, 9323, 9322, 9321, 9320, 9319, 9318, 9317, 9224, 9123, 9014, 8897, 8772, 8639, 8498, 8349, 8192, 8027, 7854, 7673, 7484, 7287, 7082, 6869, 6648, 6419, 6182, 5937, 5684, 5423, 5154, 4877, 4592, 4299, 3998, 3689, 3372, 3047, 2714, 2373, 2024, 1667, 1302, 929, 548, 159], [332, 717, 1094, 1463, 1824, 2177, 2522, 2859, 3188, 3509, 3822, 4127, 4424, 4713, 4994, 5267, 5532, 5789, 6038, 6279, 6512, 6737, 6954, 7163, 7364, 7557, 7742, 7919, 8088, 8249, 8402, 8547, 8684, 8813, 8934, 9047, 9152, 9249, 9248, 9247, 9246, 9245, 9244, 9243, 9242, 9241, 9240, 9239, 9238, 9237, 9236, 9235, 9234, 9233, 9232, 9231, 9230, 9229, 9228, 9227, 9226, 9225, 9124, 9015, 8898, 8773, 8640, 8499, 8350, 8193, 8028, 7855, 7674, 7485, 7288, 7083, 6870, 6649, 6420, 6183, 5938, 5685, 5424, 5155, 4878, 4593, 4300, 3999, 3690, 3373, 3048, 2715, 2374, 2025, 1668, 1303, 930, 549, 160], [331, 716, 1093, 1462, 1823, 2176, 2521, 2858, 3187, 3508, 3821, 4126, 4423, 4712, 4993, 5266, 5531, 5788, 6037, 6278, 6511, 6736, 6953, 7162, 7363, 7556, 7741, 7918, 8087, 8248, 8401, 8546, 8683, 8812, 8933, 9046, 9151, 9150, 9149, 9148, 9147, 9146, 9145, 9144, 9143, 9142, 9141, 9140, 9139, 9138, 9137, 9136, 9135, 9134, 9133, 9132, 9131, 9130, 9129, 9128, 9127, 9126, 9125, 9016, 8899, 8774, 8641, 8500, 8351, 8194, 8029, 7856, 7675, 7486, 7289, 7084, 6871, 6650, 6421, 6184, 5939, 5686, 5425, 5156, 4879, 4594, 4301, 4000, 3691, 3374, 3049, 2716, 2375, 2026, 1669, 1304, 931, 550, 161], [330, 715, 1092, 1461, 1822, 2175, 2520, 2857, 3186, 3507, 3820, 4125, 4422, 4711, 4992, 5265, 5530, 5787, 6036, 6277, 6510, 6735, 6952, 7161, 7362, 7555, 7740, 7917, 8086, 8247, 8400, 8545, 8682, 8811, 8932, 9045, 9044, 9043, 9042, 9041, 9040, 9039, 9038, 9037, 9036, 9035, 9034, 9033, 9032, 9031, 9030, 9029, 9028, 9027, 9026, 9025, 9024, 9023, 9022, 9021, 9020, 9019, 9018, 9017, 8900, 8775, 8642, 8501, 8352, 8195, 8030, 7857, 7676, 7487, 7290, 7085, 6872, 6651, 6422, 6185, 5940, 5687, 5426, 5157, 4880, 4595, 4302, 4001, 3692, 3375, 3050, 2717, 2376, 2027, 1670, 1305, 932, 551, 162], [329, 714, 1091, 1460, 1821, 2174, 2519, 2856, 3185, 3506, 3819, 4124, 4421, 4710, 4991, 5264, 5529, 5786, 6035, 6276, 6509, 6734, 6951, 7160, 7361, 7554, 7739, 7916, 8085, 8246, 8399, 8544, 8681, 8810, 8931, 8930, 8929, 8928, 8927, 8926, 8925, 8924, 8923, 8922, 8921, 8920, 8919, 8918, 8917, 8916, 8915, 8914, 8913, 8912, 8911, 8910, 8909, 8908, 8907, 8906, 8905, 8904, 8903, 8902, 8901, 8776, 8643, 8502, 8353, 8196, 8031, 7858, 7677, 7488, 7291, 7086, 6873, 6652, 6423, 6186, 5941, 5688, 5427, 5158, 4881, 4596, 4303, 4002, 3693, 3376, 3051, 2718, 2377, 2028, 1671, 1306, 933, 552, 163], [328, 713, 1090, 1459, 1820, 2173, 2518, 2855, 3184, 3505, 3818, 4123, 4420, 4709, 4990, 5263, 5528, 5785, 6034, 6275, 6508, 6733, 6950, 7159, 7360, 7553, 7738, 7915, 8084, 8245, 8398, 8543, 8680, 8809, 8808, 8807, 8806, 8805, 8804, 8803, 8802, 8801, 8800, 8799, 8798, 8797, 8796, 8795, 8794, 8793, 8792, 8791, 8790, 8789, 8788, 8787, 8786, 8785, 8784, 8783, 8782, 8781, 8780, 8779, 8778, 8777, 8644, 8503, 8354, 8197, 8032, 7859, 7678, 7489, 7292, 7087, 6874, 6653, 6424, 6187, 5942, 5689, 5428, 5159, 4882, 4597, 4304, 4003, 3694, 3377, 3052, 2719, 2378, 2029, 1672, 1307, 934, 553, 164], [327, 712, 1089, 1458, 1819, 2172, 2517, 2854, 3183, 3504, 3817, 4122, 4419, 4708, 4989, 5262, 5527, 5784, 6033, 6274, 6507, 6732, 6949, 7158, 7359, 7552, 7737, 7914, 8083, 8244, 8397, 8542, 8679, 8678, 8677, 8676, 8675, 8674, 8673, 8672, 8671, 8670, 8669, 8668, 8667, 8666, 8665, 8664, 8663, 8662, 8661, 8660, 8659, 8658, 8657, 8656, 8655, 8654, 8653, 8652, 8651, 8650, 8649, 8648, 8647, 8646, 8645, 8504, 8355, 8198, 8033, 7860, 7679, 7490, 7293, 7088, 6875, 6654, 6425, 6188, 5943, 5690, 5429, 5160, 4883, 4598, 4305, 4004, 3695, 3378, 3053, 2720, 2379, 2030, 1673, 1308, 935, 554, 165], [326, 711, 1088, 1457, 1818, 2171, 2516, 2853, 3182, 3503, 3816, 4121, 4418, 4707, 4988, 5261, 5526, 5783, 6032, 6273, 6506, 6731, 6948, 7157, 7358, 7551, 7736, 7913, 8082, 8243, 8396, 8541, 8540, 8539, 8538, 8537, 8536, 8535, 8534, 8533, 8532, 8531, 8530, 8529, 8528, 8527, 8526, 8525, 8524, 8523, 8522, 8521, 8520, 8519, 8518, 8517, 8516, 8515, 8514, 8513, 8512, 8511, 8510, 8509, 8508, 8507, 8506, 8505, 8356, 8199, 8034, 7861, 7680, 7491, 7294, 7089, 6876, 6655, 6426, 6189, 5944, 5691, 5430, 5161, 4884, 4599, 4306, 4005, 3696, 3379, 3054, 2721, 2380, 2031, 1674, 1309, 936, 555, 166], [325, 710, 1087, 1456, 1817, 2170, 2515, 2852, 3181, 3502, 3815, 4120, 4417, 4706, 4987, 5260, 5525, 5782, 6031, 6272, 6505, 6730, 6947, 7156, 7357, 7550, 7735, 7912, 8081, 8242, 8395, 8394, 8393, 8392, 8391, 8390, 8389, 8388, 8387, 8386, 8385, 8384, 8383, 8382, 8381, 8380, 8379, 8378, 8377, 8376, 8375, 8374, 8373, 8372, 8371, 8370, 8369, 8368, 8367, 8366, 8365, 8364, 8363, 8362, 8361, 8360, 8359, 8358, 8357, 8200, 8035, 7862, 7681, 7492, 7295, 7090, 6877, 6656, 6427, 6190, 5945, 5692, 5431, 5162, 4885, 4600, 4307, 4006, 3697, 3380, 3055, 2722, 2381, 2032, 1675, 1310, 937, 556, 167], [324, 709, 1086, 1455, 1816, 2169, 2514, 2851, 3180, 3501, 3814, 4119, 4416, 4705, 4986, 5259, 5524, 5781, 6030, 6271, 6504, 6729, 6946, 7155, 7356, 7549, 7734, 7911, 8080, 8241, 8240, 8239, 8238, 8237, 8236, 8235, 8234, 8233, 8232, 8231, 8230, 8229, 8228, 8227, 8226, 8225, 8224, 8223, 8222, 8221, 8220, 8219, 8218, 8217, 8216, 8215, 8214, 8213, 8212, 8211, 8210, 8209, 8208, 8207, 8206, 8205, 8204, 8203, 8202, 8201, 8036, 7863, 7682, 7493, 7296, 7091, 6878, 6657, 6428, 6191, 5946, 5693, 5432, 5163, 4886, 4601, 4308, 4007, 3698, 3381, 3056, 2723, 2382, 2033, 1676, 1311, 938, 557, 168], [323, 708, 1085, 1454, 1815, 2168, 2513, 2850, 3179, 3500, 3813, 4118, 4415, 4704, 4985, 5258, 5523, 5780, 6029, 6270, 6503, 6728, 6945, 7154, 7355, 7548, 7733, 7910, 8079, 8078, 8077, 8076, 8075, 8074, 8073, 8072, 8071, 8070, 8069, 8068, 8067, 8066, 8065, 8064, 8063, 8062, 8061, 8060, 8059, 8058, 8057, 8056, 8055, 8054, 8053, 8052, 8051, 8050, 8049, 8048, 8047, 8046, 8045, 8044, 8043, 8042, 8041, 8040, 8039, 8038, 8037, 7864, 7683, 7494, 7297, 7092, 6879, 6658, 6429, 6192, 5947, 5694, 5433, 5164, 4887, 4602, 4309, 4008, 3699, 3382, 3057, 2724, 2383, 2034, 1677, 1312, 939, 558, 169], [322, 707, 1084, 1453, 1814, 2167, 2512, 2849, 3178, 3499, 3812, 4117, 4414, 4703, 4984, 5257, 5522, 5779, 6028, 6269, 6502, 6727, 6944, 7153, 7354, 7547, 7732, 7909, 7908, 7907, 7906, 7905, 7904, 7903, 7902, 7901, 7900, 7899, 7898, 7897, 7896, 7895, 7894, 7893, 7892, 7891, 7890, 7889, 7888, 7887, 7886, 7885, 7884, 7883, 7882, 7881, 7880, 7879, 7878, 7877, 7876, 7875, 7874, 7873, 7872, 7871, 7870, 7869, 7868, 7867, 7866, 7865, 7684, 7495, 7298, 7093, 6880, 6659, 6430, 6193, 5948, 5695, 5434, 5165, 4888, 4603, 4310, 4009, 3700, 3383, 3058, 2725, 2384, 2035, 1678, 1313, 940, 559, 170], [321, 706, 1083, 1452, 1813, 2166, 2511, 2848, 3177, 3498, 3811, 4116, 4413, 4702, 4983, 5256, 5521, 5778, 6027, 6268, 6501, 6726, 6943, 7152, 7353, 7546, 7731, 7730, 7729, 7728, 7727, 7726, 7725, 7724, 7723, 7722, 7721, 7720, 7719, 7718, 7717, 7716, 7715, 7714, 7713, 7712, 7711, 7710, 7709, 7708, 7707, 7706, 7705, 7704, 7703, 7702, 7701, 7700, 7699, 7698, 7697, 7696, 7695, 7694, 7693, 7692, 7691, 7690, 7689, 7688, 7687, 7686, 7685, 7496, 7299, 7094, 6881, 6660, 6431, 6194, 5949, 5696, 5435, 5166, 4889, 4604, 4311, 4010, 3701, 3384, 3059, 2726, 2385, 2036, 1679, 1314, 941, 560, 171], [320, 705, 1082, 1451, 1812, 2165, 2510, 2847, 3176, 3497, 3810, 4115, 4412, 4701, 4982, 5255, 5520, 5777, 6026, 6267, 6500, 6725, 6942, 7151, 7352, 7545, 7544, 7543, 7542, 7541, 7540, 7539, 7538, 7537, 7536, 7535, 7534, 7533, 7532, 7531, 7530, 7529, 7528, 7527, 7526, 7525, 7524, 7523, 7522, 7521, 7520, 7519, 7518, 7517, 7516, 7515, 7514, 7513, 7512, 7511, 7510, 7509, 7508, 7507, 7506, 7505, 7504, 7503, 7502, 7501, 7500, 7499, 7498, 7497, 7300, 7095, 6882, 6661, 6432, 6195, 5950, 5697, 5436, 5167, 4890, 4605, 4312, 4011, 3702, 3385, 3060, 2727, 2386, 2037, 1680, 1315, 942, 561, 172], [319, 704, 1081, 1450, 1811, 2164, 2509, 2846, 3175, 3496, 3809, 4114, 4411, 4700, 4981, 5254, 5519, 5776, 6025, 6266, 6499, 6724, 6941, 7150, 7351, 7350, 7349, 7348, 7347, 7346, 7345, 7344, 7343, 7342, 7341, 7340, 7339, 7338, 7337, 7336, 7335, 7334, 7333, 7332, 7331, 7330, 7329, 7328, 7327, 7326, 7325, 7324, 7323, 7322, 7321, 7320, 7319, 7318, 7317, 7316, 7315, 7314, 7313, 7312, 7311, 7310, 7309, 7308, 7307, 7306, 7305, 7304, 7303, 7302, 7301, 7096, 6883, 6662, 6433, 6196, 5951, 5698, 5437, 5168, 4891, 4606, 4313, 4012, 3703, 3386, 3061, 2728, 2387, 2038, 1681, 1316, 943, 562, 173], [318, 703, 1080, 1449, 1810, 2163, 2508, 2845, 3174, 3495, 3808, 4113, 4410, 4699, 4980, 5253, 5518, 5775, 6024, 6265, 6498, 6723, 6940, 7149, 7148, 7147, 7146, 7145, 7144, 7143, 7142, 7141, 7140, 7139, 7138, 7137, 7136, 7135, 7134, 7133, 7132, 7131, 7130, 7129, 7128, 7127, 7126, 7125, 7124, 7123, 7122, 7121, 7120, 7119, 7118, 7117, 7116, 7115, 7114, 7113, 7112, 7111, 7110, 7109, 7108, 7107, 7106, 7105, 7104, 7103, 7102, 7101, 7100, 7099, 7098, 7097, 6884, 6663, 6434, 6197, 5952, 5699, 5438, 5169, 4892, 4607, 4314, 4013, 3704, 3387, 3062, 2729, 2388, 2039, 1682, 1317, 944, 563, 174], [317, 702, 1079, 1448, 1809, 2162, 2507, 2844, 3173, 3494, 3807, 4112, 4409, 4698, 4979, 5252, 5517, 5774, 6023, 6264, 6497, 6722, 6939, 6938, 6937, 6936, 6935, 6934, 6933, 6932, 6931, 6930, 6929, 6928, 6927, 6926, 6925, 6924, 6923, 6922, 6921, 6920, 6919, 6918, 6917, 6916, 6915, 6914, 6913, 6912, 6911, 6910, 6909, 6908, 6907, 6906, 6905, 6904, 6903, 6902, 6901, 6900, 6899, 6898, 6897, 6896, 6895, 6894, 6893, 6892, 6891, 6890, 6889, 6888, 6887, 6886, 6885, 6664, 6435, 6198, 5953, 5700, 5439, 5170, 4893, 4608, 4315, 4014, 3705, 3388, 3063, 2730, 2389, 2040, 1683, 1318, 945, 564, 175], [316, 701, 1078, 1447, 1808, 2161, 2506, 2843, 3172, 3493, 3806, 4111, 4408, 4697, 4978, 5251, 5516, 5773, 6022, 6263, 6496, 6721, 6720, 6719, 6718, 6717, 6716, 6715, 6714, 6713, 6712, 6711, 6710, 6709, 6708, 6707, 6706, 6705, 6704, 6703, 6702, 6701, 6700, 6699, 6698, 6697, 6696, 6695, 6694, 6693, 6692, 6691, 6690, 6689, 6688, 6687, 6686, 6685, 6684, 6683, 6682, 6681, 6680, 6679, 6678, 6677, 6676, 6675, 6674, 6673, 6672, 6671, 6670, 6669, 6668, 6667, 6666, 6665, 6436, 6199, 5954, 5701, 5440, 5171, 4894, 4609, 4316, 4015, 3706, 3389, 3064, 2731, 2390, 2041, 1684, 1319, 946, 565, 176], [315, 700, 1077, 1446, 1807, 2160, 2505, 2842, 3171, 3492, 3805, 4110, 4407, 4696, 4977, 5250, 5515, 5772, 6021, 6262, 6495, 6494, 6493, 6492, 6491, 6490, 6489, 6488, 6487, 6486, 6485, 6484, 6483, 6482, 6481, 6480, 6479, 6478, 6477, 6476, 6475, 6474, 6473, 6472, 6471, 6470, 6469, 6468, 6467, 6466, 6465, 6464, 6463, 6462, 6461, 6460, 6459, 6458, 6457, 6456, 6455, 6454, 6453, 6452, 6451, 6450, 6449, 6448, 6447, 6446, 6445, 6444, 6443, 6442, 6441, 6440, 6439, 6438, 6437, 6200, 5955, 5702, 5441, 5172, 4895, 4610, 4317, 4016, 3707, 3390, 3065, 2732, 2391, 2042, 1685, 1320, 947, 566, 177], [314, 699, 1076, 1445, 1806, 2159, 2504, 2841, 3170, 3491, 3804, 4109, 4406, 4695, 4976, 5249, 5514, 5771, 6020, 6261, 6260, 6259, 6258, 6257, 6256, 6255, 6254, 6253, 6252, 6251, 6250, 6249, 6248, 6247, 6246, 6245, 6244, 6243, 6242, 6241, 6240, 6239, 6238, 6237, 6236, 6235, 6234, 6233, 6232, 6231, 6230, 6229, 6228, 6227, 6226, 6225, 6224, 6223, 6222, 6221, 6220, 6219, 6218, 6217, 6216, 6215, 6214, 6213, 6212, 6211, 6210, 6209, 6208, 6207, 6206, 6205, 6204, 6203, 6202, 6201, 5956, 5703, 5442, 5173, 4896, 4611, 4318, 4017, 3708, 3391, 3066, 2733, 2392, 2043, 1686, 1321, 948, 567, 178], [313, 698, 1075, 1444, 1805, 2158, 2503, 2840, 3169, 3490, 3803, 4108, 4405, 4694, 4975, 5248, 5513, 5770, 6019, 6018, 6017, 6016, 6015, 6014, 6013, 6012, 6011, 6010, 6009, 6008, 6007, 6006, 6005, 6004, 6003, 6002, 6001, 6000, 5999, 5998, 5997, 5996, 5995, 5994, 5993, 5992, 5991, 5990, 5989, 5988, 5987, 5986, 5985, 5984, 5983, 5982, 5981, 5980, 5979, 5978, 5977, 5976, 5975, 5974, 5973, 5972, 5971, 5970, 5969, 5968, 5967, 5966, 5965, 5964, 5963, 5962, 5961, 5960, 5959, 5958, 5957, 5704, 5443, 5174, 4897, 4612, 4319, 4018, 3709, 3392, 3067, 2734, 2393, 2044, 1687, 1322, 949, 568, 179], [312, 697, 1074, 1443, 1804, 2157, 2502, 2839, 3168, 3489, 3802, 4107, 4404, 4693, 4974, 5247, 5512, 5769, 5768, 5767, 5766, 5765, 5764, 5763, 5762, 5761, 5760, 5759, 5758, 5757, 5756, 5755, 5754, 5753, 5752, 5751, 5750, 5749, 5748, 5747, 5746, 5745, 5744, 5743, 5742, 5741, 5740, 5739, 5738, 5737, 5736, 5735, 5734, 5733, 5732, 5731, 5730, 5729, 5728, 5727, 5726, 5725, 5724, 5723, 5722, 5721, 5720, 5719, 5718, 5717, 5716, 5715, 5714, 5713, 5712, 5711, 5710, 5709, 5708, 5707, 5706, 5705, 5444, 5175, 4898, 4613, 4320, 4019, 3710, 3393, 3068, 2735, 2394, 2045, 1688, 1323, 950, 569, 180], [311, 696, 1073, 1442, 1803, 2156, 2501, 2838, 3167, 3488, 3801, 4106, 4403, 4692, 4973, 5246, 5511, 5510, 5509, 5508, 5507, 5506, 5505, 5504, 5503, 5502, 5501, 5500, 5499, 5498, 5497, 5496, 5495, 5494, 5493, 5492, 5491, 5490, 5489, 5488, 5487, 5486, 5485, 5484, 5483, 5482, 5481, 5480, 5479, 5478, 5477, 5476, 5475, 5474, 5473, 5472, 5471, 5470, 5469, 5468, 5467, 5466, 5465, 5464, 5463, 5462, 5461, 5460, 5459, 5458, 5457, 5456, 5455, 5454, 5453, 5452, 5451, 5450, 5449, 5448, 5447, 5446, 5445, 5176, 4899, 4614, 4321, 4020, 3711, 3394, 3069, 2736, 2395, 2046, 1689, 1324, 951, 570, 181], [310, 695, 1072, 1441, 1802, 2155, 2500, 2837, 3166, 3487, 3800, 4105, 4402, 4691, 4972, 5245, 5244, 5243, 5242, 5241, 5240, 5239, 5238, 5237, 5236, 5235, 5234, 5233, 5232, 5231, 5230, 5229, 5228, 5227, 5226, 5225, 5224, 5223, 5222, 5221, 5220, 5219, 5218, 5217, 5216, 5215, 5214, 5213, 5212, 5211, 5210, 5209, 5208, 5207, 5206, 5205, 5204, 5203, 5202, 5201, 5200, 5199, 5198, 5197, 5196, 5195, 5194, 5193, 5192, 5191, 5190, 5189, 5188, 5187, 5186, 5185, 5184, 5183, 5182, 5181, 5180, 5179, 5178, 5177, 4900, 4615, 4322, 4021, 3712, 3395, 3070, 2737, 2396, 2047, 1690, 1325, 952, 571, 182], [309, 694, 1071, 1440, 1801, 2154, 2499, 2836, 3165, 3486, 3799, 4104, 4401, 4690, 4971, 4970, 4969, 4968, 4967, 4966, 4965, 4964, 4963, 4962, 4961, 4960, 4959, 4958, 4957, 4956, 4955, 4954, 4953, 4952, 4951, 4950, 4949, 4948, 4947, 4946, 4945, 4944, 4943, 4942, 4941, 4940, 4939, 4938, 4937, 4936, 4935, 4934, 4933, 4932, 4931, 4930, 4929, 4928, 4927, 4926, 4925, 4924, 4923, 4922, 4921, 4920, 4919, 4918, 4917, 4916, 4915, 4914, 4913, 4912, 4911, 4910, 4909, 4908, 4907, 4906, 4905, 4904, 4903, 4902, 4901, 4616, 4323, 4022, 3713, 3396, 3071, 2738, 2397, 2048, 1691, 1326, 953, 572, 183], [308, 693, 1070, 1439, 1800, 2153, 2498, 2835, 3164, 3485, 3798, 4103, 4400, 4689, 4688, 4687, 4686, 4685, 4684, 4683, 4682, 4681, 4680, 4679, 4678, 4677, 4676, 4675, 4674, 4673, 4672, 4671, 4670, 4669, 4668, 4667, 4666, 4665, 4664, 4663, 4662, 4661, 4660, 4659, 4658, 4657, 4656, 4655, 4654, 4653, 4652, 4651, 4650, 4649, 4648, 4647, 4646, 4645, 4644, 4643, 4642, 4641, 4640, 4639, 4638, 4637, 4636, 4635, 4634, 4633, 4632, 4631, 4630, 4629, 4628, 4627, 4626, 4625, 4624, 4623, 4622, 4621, 4620, 4619, 4618, 4617, 4324, 4023, 3714, 3397, 3072, 2739, 2398, 2049, 1692, 1327, 954, 573, 184], [307, 692, 1069, 1438, 1799, 2152, 2497, 2834, 3163, 3484, 3797, 4102, 4399, 4398, 4397, 4396, 4395, 4394, 4393, 4392, 4391, 4390, 4389, 4388, 4387, 4386, 4385, 4384, 4383, 4382, 4381, 4380, 4379, 4378, 4377, 4376, 4375, 4374, 4373, 4372, 4371, 4370, 4369, 4368, 4367, 4366, 4365, 4364, 4363, 4362, 4361, 4360, 4359, 4358, 4357, 4356, 4355, 4354, 4353, 4352, 4351, 4350, 4349, 4348, 4347, 4346, 4345, 4344, 4343, 4342, 4341, 4340, 4339, 4338, 4337, 4336, 4335, 4334, 4333, 4332, 4331, 4330, 4329, 4328, 4327, 4326, 4325, 4024, 3715, 3398, 3073, 2740, 2399, 2050, 1693, 1328, 955, 574, 185], [306, 691, 1068, 1437, 1798, 2151, 2496, 2833, 3162, 3483, 3796, 4101, 4100, 4099, 4098, 4097, 4096, 4095, 4094, 4093, 4092, 4091, 4090, 4089, 4088, 4087, 4086, 4085, 4084, 4083, 4082, 4081, 4080, 4079, 4078, 4077, 4076, 4075, 4074, 4073, 4072, 4071, 4070, 4069, 4068, 4067, 4066, 4065, 4064, 4063, 4062, 4061, 4060, 4059, 4058, 4057, 4056, 4055, 4054, 4053, 4052, 4051, 4050, 4049, 4048, 4047, 4046, 4045, 4044, 4043, 4042, 4041, 4040, 4039, 4038, 4037, 4036, 4035, 4034, 4033, 4032, 4031, 4030, 4029, 4028, 4027, 4026, 4025, 3716, 3399, 3074, 2741, 2400, 2051, 1694, 1329, 956, 575, 186], [305, 690, 1067, 1436, 1797, 2150, 2495, 2832, 3161, 3482, 3795, 3794, 3793, 3792, 3791, 3790, 3789, 3788, 3787, 3786, 3785, 3784, 3783, 3782, 3781, 3780, 3779, 3778, 3777, 3776, 3775, 3774, 3773, 3772, 3771, 3770, 3769, 3768, 3767, 3766, 3765, 3764, 3763, 3762, 3761, 3760, 3759, 3758, 3757, 3756, 3755, 3754, 3753, 3752, 3751, 3750, 3749, 3748, 3747, 3746, 3745, 3744, 3743, 3742, 3741, 3740, 3739, 3738, 3737, 3736, 3735, 3734, 3733, 3732, 3731, 3730, 3729, 3728, 3727, 3726, 3725, 3724, 3723, 3722, 3721, 3720, 3719, 3718, 3717, 3400, 3075, 2742, 2401, 2052, 1695, 1330, 957, 576, 187], [304, 689, 1066, 1435, 1796, 2149, 2494, 2831, 3160, 3481, 3480, 3479, 3478, 3477, 3476, 3475, 3474, 3473, 3472, 3471, 3470, 3469, 3468, 3467, 3466, 3465, 3464, 3463, 3462, 3461, 3460, 3459, 3458, 3457, 3456, 3455, 3454, 3453, 3452, 3451, 3450, 3449, 3448, 3447, 3446, 3445, 3444, 3443, 3442, 3441, 3440, 3439, 3438, 3437, 3436, 3435, 3434, 3433, 3432, 3431, 3430, 3429, 3428, 3427, 3426, 3425, 3424, 3423, 3422, 3421, 3420, 3419, 3418, 3417, 3416, 3415, 3414, 3413, 3412, 3411, 3410, 3409, 3408, 3407, 3406, 3405, 3404, 3403, 3402, 3401, 3076, 2743, 2402, 2053, 1696, 1331, 958, 577, 188], [303, 688, 1065, 1434, 1795, 2148, 2493, 2830, 3159, 3158, 3157, 3156, 3155, 3154, 3153, 3152, 3151, 3150, 3149, 3148, 3147, 3146, 3145, 3144, 3143, 3142, 3141, 3140, 3139, 3138, 3137, 3136, 3135, 3134, 3133, 3132, 3131, 3130, 3129, 3128, 3127, 3126, 3125, 3124, 3123, 3122, 3121, 3120, 3119, 3118, 3117, 3116, 3115, 3114, 3113, 3112, 3111, 3110, 3109, 3108, 3107, 3106, 3105, 3104, 3103, 3102, 3101, 3100, 3099, 3098, 3097, 3096, 3095, 3094, 3093, 3092, 3091, 3090, 3089, 3088, 3087, 3086, 3085, 3084, 3083, 3082, 3081, 3080, 3079, 3078, 3077, 2744, 2403, 2054, 1697, 1332, 959, 578, 189], [302, 687, 1064, 1433, 1794, 2147, 2492, 2829, 2828, 2827, 2826, 2825, 2824, 2823, 2822, 2821, 2820, 2819, 2818, 2817, 2816, 2815, 2814, 2813, 2812, 2811, 2810, 2809, 2808, 2807, 2806, 2805, 2804, 2803, 2802, 2801, 2800, 2799, 2798, 2797, 2796, 2795, 2794, 2793, 2792, 2791, 2790, 2789, 2788, 2787, 2786, 2785, 2784, 2783, 2782, 2781, 2780, 2779, 2778, 2777, 2776, 2775, 2774, 2773, 2772, 2771, 2770, 2769, 2768, 2767, 2766, 2765, 2764, 2763, 2762, 2761, 2760, 2759, 2758, 2757, 2756, 2755, 2754, 2753, 2752, 2751, 2750, 2749, 2748, 2747, 2746, 2745, 2404, 2055, 1698, 1333, 960, 579, 190], [301, 686, 1063, 1432, 1793, 2146, 2491, 2490, 2489, 2488, 2487, 2486, 2485, 2484, 2483, 2482, 2481, 2480, 2479, 2478, 2477, 2476, 2475, 2474, 2473, 2472, 2471, 2470, 2469, 2468, 2467, 2466, 2465, 2464, 2463, 2462, 2461, 2460, 2459, 2458, 2457, 2456, 2455, 2454, 2453, 2452, 2451, 2450, 2449, 2448, 2447, 2446, 2445, 2444, 2443, 2442, 2441, 2440, 2439, 2438, 2437, 2436, 2435, 2434, 2433, 2432, 2431, 2430, 2429, 2428, 2427, 2426, 2425, 2424, 2423, 2422, 2421, 2420, 2419, 2418, 2417, 2416, 2415, 2414, 2413, 2412, 2411, 2410, 2409, 2408, 2407, 2406, 2405, 2056, 1699, 1334, 961, 580, 191], [300, 685, 1062, 1431, 1792, 2145, 2144, 2143, 2142, 2141, 2140, 2139, 2138, 2137, 2136, 2135, 2134, 2133, 2132, 2131, 2130, 2129, 2128, 2127, 2126, 2125, 2124, 2123, 2122, 2121, 2120, 2119, 2118, 2117, 2116, 2115, 2114, 2113, 2112, 2111, 2110, 2109, 2108, 2107, 2106, 2105, 2104, 2103, 2102, 2101, 2100, 2099, 2098, 2097, 2096, 2095, 2094, 2093, 2092, 2091, 2090, 2089, 2088, 2087, 2086, 2085, 2084, 2083, 2082, 2081, 2080, 2079, 2078, 2077, 2076, 2075, 2074, 2073, 2072, 2071, 2070, 2069, 2068, 2067, 2066, 2065, 2064, 2063, 2062, 2061, 2060, 2059, 2058, 2057, 1700, 1335, 962, 581, 192], [299, 684, 1061, 1430, 1791, 1790, 1789, 1788, 1787, 1786, 1785, 1784, 1783, 1782, 1781, 1780, 1779, 1778, 1777, 1776, 1775, 1774, 1773, 1772, 1771, 1770, 1769, 1768, 1767, 1766, 1765, 1764, 1763, 1762, 1761, 1760, 1759, 1758, 1757, 1756, 1755, 1754, 1753, 1752, 1751, 1750, 1749, 1748, 1747, 1746, 1745, 1744, 1743, 1742, 1741, 1740, 1739, 1738, 1737, 1736, 1735, 1734, 1733, 1732, 1731, 1730, 1729, 1728, 1727, 1726, 1725, 1724, 1723, 1722, 1721, 1720, 1719, 1718, 1717, 1716, 1715, 1714, 1713, 1712, 1711, 1710, 1709, 1708, 1707, 1706, 1705, 1704, 1703, 1702, 1701, 1336, 963, 582, 193], [298, 683, 1060, 1429, 1428, 1427, 1426, 1425, 1424, 1423, 1422, 1421, 1420, 1419, 1418, 1417, 1416, 1415, 1414, 1413, 1412, 1411, 1410, 1409, 1408, 1407, 1406, 1405, 1404, 1403, 1402, 1401, 1400, 1399, 1398, 1397, 1396, 1395, 1394, 1393, 1392, 1391, 1390, 1389, 1388, 1387, 1386, 1385, 1384, 1383, 1382, 1381, 1380, 1379, 1378, 1377, 1376, 1375, 1374, 1373, 1372, 1371, 1370, 1369, 1368, 1367, 1366, 1365, 1364, 1363, 1362, 1361, 1360, 1359, 1358, 1357, 1356, 1355, 1354, 1353, 1352, 1351, 1350, 1349, 1348, 1347, 1346, 1345, 1344, 1343, 1342, 1341, 1340, 1339, 1338, 1337, 964, 583, 194], [297, 682, 1059, 1058, 1057, 1056, 1055, 1054, 1053, 1052, 1051, 1050, 1049, 1048, 1047, 1046, 1045, 1044, 1043, 1042, 1041, 1040, 1039, 1038, 1037, 1036, 1035, 1034, 1033, 1032, 1031, 1030, 1029, 1028, 1027, 1026, 1025, 1024, 1023, 1022, 1021, 1020, 1019, 1018, 1017, 1016, 1015, 1014, 1013, 1012, 1011, 1010, 1009, 1008, 1007, 1006, 1005, 1004, 1003, 1002, 1001, 1000, 999, 998, 997, 996, 995, 994, 993, 992, 991, 990, 989, 988, 987, 986, 985, 984, 983, 982, 981, 980, 979, 978, 977, 976, 975, 974, 973, 972, 971, 970, 969, 968, 967, 966, 965, 584, 195], [296, 681, 680, 679, 678, 677, 676, 675, 674, 673, 672, 671, 670, 669, 668, 667, 666, 665, 664, 663, 662, 661, 660, 659, 658, 657, 656, 655, 654, 653, 652, 651, 650, 649, 648, 647, 646, 645, 644, 643, 642, 641, 640, 639, 638, 637, 636, 635, 634, 633, 632, 631, 630, 629, 628, 627, 626, 625, 624, 623, 622, 621, 620, 619, 618, 617, 616, 615, 614, 613, 612, 611, 610, 609, 608, 607, 606, 605, 604, 603, 602, 601, 600, 599, 598, 597, 596, 595, 594, 593, 592, 591, 590, 589, 588, 587, 586, 585, 196], [295, 294, 293, 292, 291, 290, 289, 288, 287, 286, 285, 284, 283, 282, 281, 280, 279, 278, 277, 276, 275, 274, 273, 272, 271, 270, 269, 268, 267, 266, 265, 264, 263, 262, 261, 260, 259, 258, 257, 256, 255, 254, 253, 252, 251, 250, 249, 248, 247, 246, 245, 244, 243, 242, 241, 240, 239, 238, 237, 236, 235, 234, 233, 232, 231, 230, 229, 228, 227, 226, 225, 224, 223, 222, 221, 220, 219, 218, 217, 216, 215, 214, 213, 212, 211, 210, 209, 208, 207, 206, 205, 204, 203, 202, 201, 200, 199, 198, 197]]\n    assert candidate(15) == [[1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15], [56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 16], [55, 104, 105, 106, 107, 108, 109, 110, 111, 112, 113, 114, 115, 70, 17], [54, 103, 144, 145, 146, 147, 148, 149, 150, 151, 152, 153, 116, 71, 18], [53, 102, 143, 176, 177, 178, 179, 180, 181, 182, 183, 154, 117, 72, 19], [52, 101, 142, 175, 200, 201, 202, 203, 204, 205, 184, 155, 118, 73, 20], [51, 100, 141, 174, 199, 216, 217, 218, 219, 206, 185, 156, 119, 74, 21], [50, 99, 140, 173, 198, 215, 224, 225, 220, 207, 186, 157, 120, 75, 22], [49, 98, 139, 172, 197, 214, 223, 222, 221, 208, 187, 158, 121, 76, 23], [48, 97, 138, 171, 196, 213, 212, 211, 210, 209, 188, 159, 122, 77, 24], [47, 96, 137, 170, 195, 194, 193, 192, 191, 190, 189, 160, 123, 78, 25], [46, 95, 136, 169, 168, 167, 166, 165, 164, 163, 162, 161, 124, 79, 26], [45, 94, 135, 134, 133, 132, 131, 130, 129, 128, 127, 126, 125, 80, 27], [44, 93, 92, 91, 90, 89, 88, 87, 86, 85, 84, 83, 82, 81, 28], [43, 42, 41, 40, 39, 38, 37, 36, 35, 34, 33, 32, 31, 30, 29]]\n    assert candidate(60) == [[1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60], [236, 237, 238, 239, 240, 241, 242, 243, 244, 245, 246, 247, 248, 249, 250, 251, 252, 253, 254, 255, 256, 257, 258, 259, 260, 261, 262, 263, 264, 265, 266, 267, 268, 269, 270, 271, 272, 273, 274, 275, 276, 277, 278, 279, 280, 281, 282, 283, 284, 285, 286, 287, 288, 289, 290, 291, 292, 293, 294, 61], [235, 464, 465, 466, 467, 468, 469, 470, 471, 472, 473, 474, 475, 476, 477, 478, 479, 480, 481, 482, 483, 484, 485, 486, 487, 488, 489, 490, 491, 492, 493, 494, 495, 496, 497, 498, 499, 500, 501, 502, 503, 504, 505, 506, 507, 508, 509, 510, 511, 512, 513, 514, 515, 516, 517, 518, 519, 520, 295, 62], [234, 463, 684, 685, 686, 687, 688, 689, 690, 691, 692, 693, 694, 695, 696, 697, 698, 699, 700, 701, 702, 703, 704, 705, 706, 707, 708, 709, 710, 711, 712, 713, 714, 715, 716, 717, 718, 719, 720, 721, 722, 723, 724, 725, 726, 727, 728, 729, 730, 731, 732, 733, 734, 735, 736, 737, 738, 521, 296, 63], [233, 462, 683, 896, 897, 898, 899, 900, 901, 902, 903, 904, 905, 906, 907, 908, 909, 910, 911, 912, 913, 914, 915, 916, 917, 918, 919, 920, 921, 922, 923, 924, 925, 926, 927, 928, 929, 930, 931, 932, 933, 934, 935, 936, 937, 938, 939, 940, 941, 942, 943, 944, 945, 946, 947, 948, 739, 522, 297, 64], [232, 461, 682, 895, 1100, 1101, 1102, 1103, 1104, 1105, 1106, 1107, 1108, 1109, 1110, 1111, 1112, 1113, 1114, 1115, 1116, 1117, 1118, 1119, 1120, 1121, 1122, 1123, 1124, 1125, 1126, 1127, 1128, 1129, 1130, 1131, 1132, 1133, 1134, 1135, 1136, 1137, 1138, 1139, 1140, 1141, 1142, 1143, 1144, 1145, 1146, 1147, 1148, 1149, 1150, 949, 740, 523, 298, 65], [231, 460, 681, 894, 1099, 1296, 1297, 1298, 1299, 1300, 1301, 1302, 1303, 1304, 1305, 1306, 1307, 1308, 1309, 1310, 1311, 1312, 1313, 1314, 1315, 1316, 1317, 1318, 1319, 1320, 1321, 1322, 1323, 1324, 1325, 1326, 1327, 1328, 1329, 1330, 1331, 1332, 1333, 1334, 1335, 1336, 1337, 1338, 1339, 1340, 1341, 1342, 1343, 1344, 1151, 950, 741, 524, 299, 66], [230, 459, 680, 893, 1098, 1295, 1484, 1485, 1486, 1487, 1488, 1489, 1490, 1491, 1492, 1493, 1494, 1495, 1496, 1497, 1498, 1499, 1500, 1501, 1502, 1503, 1504, 1505, 1506, 1507, 1508, 1509, 1510, 1511, 1512, 1513, 1514, 1515, 1516, 1517, 1518, 1519, 1520, 1521, 1522, 1523, 1524, 1525, 1526, 1527, 1528, 1529, 1530, 1345, 1152, 951, 742, 525, 300, 67], [229, 458, 679, 892, 1097, 1294, 1483, 1664, 1665, 1666, 1667, 1668, 1669, 1670, 1671, 1672, 1673, 1674, 1675, 1676, 1677, 1678, 1679, 1680, 1681, 1682, 1683, 1684, 1685, 1686, 1687, 1688, 1689, 1690, 1691, 1692, 1693, 1694, 1695, 1696, 1697, 1698, 1699, 1700, 1701, 1702, 1703, 1704, 1705, 1706, 1707, 1708, 1531, 1346, 1153, 952, 743, 526, 301, 68], [228, 457, 678, 891, 1096, 1293, 1482, 1663, 1836, 1837, 1838, 1839, 1840, 1841, 1842, 1843, 1844, 1845, 1846, 1847, 1848, 1849, 1850, 1851, 1852, 1853, 1854, 1855, 1856, 1857, 1858, 1859, 1860, 1861, 1862, 1863, 1864, 1865, 1866, 1867, 1868, 1869, 1870, 1871, 1872, 1873, 1874, 1875, 1876, 1877, 1878, 1709, 1532, 1347, 1154, 953, 744, 527, 302, 69], [227, 456, 677, 890, 1095, 1292, 1481, 1662, 1835, 2000, 2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008, 2009, 2010, 2011, 2012, 2013, 2014, 2015, 2016, 2017, 2018, 2019, 2020, 2021, 2022, 2023, 2024, 2025, 2026, 2027, 2028, 2029, 2030, 2031, 2032, 2033, 2034, 2035, 2036, 2037, 2038, 2039, 2040, 1879, 1710, 1533, 1348, 1155, 954, 745, 528, 303, 70], [226, 455, 676, 889, 1094, 1291, 1480, 1661, 1834, 1999, 2156, 2157, 2158, 2159, 2160, 2161, 2162, 2163, 2164, 2165, 2166, 2167, 2168, 2169, 2170, 2171, 2172, 2173, 2174, 2175, 2176, 2177, 2178, 2179, 2180, 2181, 2182, 2183, 2184, 2185, 2186, 2187, 2188, 2189, 2190, 2191, 2192, 2193, 2194, 2041, 1880, 1711, 1534, 1349, 1156, 955, 746, 529, 304, 71], [225, 454, 675, 888, 1093, 1290, 1479, 1660, 1833, 1998, 2155, 2304, 2305, 2306, 2307, 2308, 2309, 2310, 2311, 2312, 2313, 2314, 2315, 2316, 2317, 2318, 2319, 2320, 2321, 2322, 2323, 2324, 2325, 2326, 2327, 2328, 2329, 2330, 2331, 2332, 2333, 2334, 2335, 2336, 2337, 2338, 2339, 2340, 2195, 2042, 1881, 1712, 1535, 1350, 1157, 956, 747, 530, 305, 72], [224, 453, 674, 887, 1092, 1289, 1478, 1659, 1832, 1997, 2154, 2303, 2444, 2445, 2446, 2447, 2448, 2449, 2450, 2451, 2452, 2453, 2454, 2455, 2456, 2457, 2458, 2459, 2460, 2461, 2462, 2463, 2464, 2465, 2466, 2467, 2468, 2469, 2470, 2471, 2472, 2473, 2474, 2475, 2476, 2477, 2478, 2341, 2196, 2043, 1882, 1713, 1536, 1351, 1158, 957, 748, 531, 306, 73], [223, 452, 673, 886, 1091, 1288, 1477, 1658, 1831, 1996, 2153, 2302, 2443, 2576, 2577, 2578, 2579, 2580, 2581, 2582, 2583, 2584, 2585, 2586, 2587, 2588, 2589, 2590, 2591, 2592, 2593, 2594, 2595, 2596, 2597, 2598, 2599, 2600, 2601, 2602, 2603, 2604, 2605, 2606, 2607, 2608, 2479, 2342, 2197, 2044, 1883, 1714, 1537, 1352, 1159, 958, 749, 532, 307, 74], [222, 451, 672, 885, 1090, 1287, 1476, 1657, 1830, 1995, 2152, 2301, 2442, 2575, 2700, 2701, 2702, 2703, 2704, 2705, 2706, 2707, 2708, 2709, 2710, 2711, 2712, 2713, 2714, 2715, 2716, 2717, 2718, 2719, 2720, 2721, 2722, 2723, 2724, 2725, 2726, 2727, 2728, 2729, 2730, 2609, 2480, 2343, 2198, 2045, 1884, 1715, 1538, 1353, 1160, 959, 750, 533, 308, 75], [221, 450, 671, 884, 1089, 1286, 1475, 1656, 1829, 1994, 2151, 2300, 2441, 2574, 2699, 2816, 2817, 2818, 2819, 2820, 2821, 2822, 2823, 2824, 2825, 2826, 2827, 2828, 2829, 2830, 2831, 2832, 2833, 2834, 2835, 2836, 2837, 2838, 2839, 2840, 2841, 2842, 2843, 2844, 2731, 2610, 2481, 2344, 2199, 2046, 1885, 1716, 1539, 1354, 1161, 960, 751, 534, 309, 76], [220, 449, 670, 883, 1088, 1285, 1474, 1655, 1828, 1993, 2150, 2299, 2440, 2573, 2698, 2815, 2924, 2925, 2926, 2927, 2928, 2929, 2930, 2931, 2932, 2933, 2934, 2935, 2936, 2937, 2938, 2939, 2940, 2941, 2942, 2943, 2944, 2945, 2946, 2947, 2948, 2949, 2950, 2845, 2732, 2611, 2482, 2345, 2200, 2047, 1886, 1717, 1540, 1355, 1162, 961, 752, 535, 310, 77], [219, 448, 669, 882, 1087, 1284, 1473, 1654, 1827, 1992, 2149, 2298, 2439, 2572, 2697, 2814, 2923, 3024, 3025, 3026, 3027, 3028, 3029, 3030, 3031, 3032, 3033, 3034, 3035, 3036, 3037, 3038, 3039, 3040, 3041, 3042, 3043, 3044, 3045, 3046, 3047, 3048, 2951, 2846, 2733, 2612, 2483, 2346, 2201, 2048, 1887, 1718, 1541, 1356, 1163, 962, 753, 536, 311, 78], [218, 447, 668, 881, 1086, 1283, 1472, 1653, 1826, 1991, 2148, 2297, 2438, 2571, 2696, 2813, 2922, 3023, 3116, 3117, 3118, 3119, 3120, 3121, 3122, 3123, 3124, 3125, 3126, 3127, 3128, 3129, 3130, 3131, 3132, 3133, 3134, 3135, 3136, 3137, 3138, 3049, 2952, 2847, 2734, 2613, 2484, 2347, 2202, 2049, 1888, 1719, 1542, 1357, 1164, 963, 754, 537, 312, 79], [217, 446, 667, 880, 1085, 1282, 1471, 1652, 1825, 1990, 2147, 2296, 2437, 2570, 2695, 2812, 2921, 3022, 3115, 3200, 3201, 3202, 3203, 3204, 3205, 3206, 3207, 3208, 3209, 3210, 3211, 3212, 3213, 3214, 3215, 3216, 3217, 3218, 3219, 3220, 3139, 3050, 2953, 2848, 2735, 2614, 2485, 2348, 2203, 2050, 1889, 1720, 1543, 1358, 1165, 964, 755, 538, 313, 80], [216, 445, 666, 879, 1084, 1281, 1470, 1651, 1824, 1989, 2146, 2295, 2436, 2569, 2694, 2811, 2920, 3021, 3114, 3199, 3276, 3277, 3278, 3279, 3280, 3281, 3282, 3283, 3284, 3285, 3286, 3287, 3288, 3289, 3290, 3291, 3292, 3293, 3294, 3221, 3140, 3051, 2954, 2849, 2736, 2615, 2486, 2349, 2204, 2051, 1890, 1721, 1544, 1359, 1166, 965, 756, 539, 314, 81], [215, 444, 665, 878, 1083, 1280, 1469, 1650, 1823, 1988, 2145, 2294, 2435, 2568, 2693, 2810, 2919, 3020, 3113, 3198, 3275, 3344, 3345, 3346, 3347, 3348, 3349, 3350, 3351, 3352, 3353, 3354, 3355, 3356, 3357, 3358, 3359, 3360, 3295, 3222, 3141, 3052, 2955, 2850, 2737, 2616, 2487, 2350, 2205, 2052, 1891, 1722, 1545, 1360, 1167, 966, 757, 540, 315, 82], [214, 443, 664, 877, 1082, 1279, 1468, 1649, 1822, 1987, 2144, 2293, 2434, 2567, 2692, 2809, 2918, 3019, 3112, 3197, 3274, 3343, 3404, 3405, 3406, 3407, 3408, 3409, 3410, 3411, 3412, 3413, 3414, 3415, 3416, 3417, 3418, 3361, 3296, 3223, 3142, 3053, 2956, 2851, 2738, 2617, 2488, 2351, 2206, 2053, 1892, 1723, 1546, 1361, 1168, 967, 758, 541, 316, 83], [213, 442, 663, 876, 1081, 1278, 1467, 1648, 1821, 1986, 2143, 2292, 2433, 2566, 2691, 2808, 2917, 3018, 3111, 3196, 3273, 3342, 3403, 3456, 3457, 3458, 3459, 3460, 3461, 3462, 3463, 3464, 3465, 3466, 3467, 3468, 3419, 3362, 3297, 3224, 3143, 3054, 2957, 2852, 2739, 2618, 2489, 2352, 2207, 2054, 1893, 1724, 1547, 1362, 1169, 968, 759, 542, 317, 84], [212, 441, 662, 875, 1080, 1277, 1466, 1647, 1820, 1985, 2142, 2291, 2432, 2565, 2690, 2807, 2916, 3017, 3110, 3195, 3272, 3341, 3402, 3455, 3500, 3501, 3502, 3503, 3504, 3505, 3506, 3507, 3508, 3509, 3510, 3469, 3420, 3363, 3298, 3225, 3144, 3055, 2958, 2853, 2740, 2619, 2490, 2353, 2208, 2055, 1894, 1725, 1548, 1363, 1170, 969, 760, 543, 318, 85], [211, 440, 661, 874, 1079, 1276, 1465, 1646, 1819, 1984, 2141, 2290, 2431, 2564, 2689, 2806, 2915, 3016, 3109, 3194, 3271, 3340, 3401, 3454, 3499, 3536, 3537, 3538, 3539, 3540, 3541, 3542, 3543, 3544, 3511, 3470, 3421, 3364, 3299, 3226, 3145, 3056, 2959, 2854, 2741, 2620, 2491, 2354, 2209, 2056, 1895, 1726, 1549, 1364, 1171, 970, 761, 544, 319, 86], [210, 439, 660, 873, 1078, 1275, 1464, 1645, 1818, 1983, 2140, 2289, 2430, 2563, 2688, 2805, 2914, 3015, 3108, 3193, 3270, 3339, 3400, 3453, 3498, 3535, 3564, 3565, 3566, 3567, 3568, 3569, 3570, 3545, 3512, 3471, 3422, 3365, 3300, 3227, 3146, 3057, 2960, 2855, 2742, 2621, 2492, 2355, 2210, 2057, 1896, 1727, 1550, 1365, 1172, 971, 762, 545, 320, 87], [209, 438, 659, 872, 1077, 1274, 1463, 1644, 1817, 1982, 2139, 2288, 2429, 2562, 2687, 2804, 2913, 3014, 3107, 3192, 3269, 3338, 3399, 3452, 3497, 3534, 3563, 3584, 3585, 3586, 3587, 3588, 3571, 3546, 3513, 3472, 3423, 3366, 3301, 3228, 3147, 3058, 2961, 2856, 2743, 2622, 2493, 2356, 2211, 2058, 1897, 1728, 1551, 1366, 1173, 972, 763, 546, 321, 88], [208, 437, 658, 871, 1076, 1273, 1462, 1643, 1816, 1981, 2138, 2287, 2428, 2561, 2686, 2803, 2912, 3013, 3106, 3191, 3268, 3337, 3398, 3451, 3496, 3533, 3562, 3583, 3596, 3597, 3598, 3589, 3572, 3547, 3514, 3473, 3424, 3367, 3302, 3229, 3148, 3059, 2962, 2857, 2744, 2623, 2494, 2357, 2212, 2059, 1898, 1729, 1552, 1367, 1174, 973, 764, 547, 322, 89], [207, 436, 657, 870, 1075, 1272, 1461, 1642, 1815, 1980, 2137, 2286, 2427, 2560, 2685, 2802, 2911, 3012, 3105, 3190, 3267, 3336, 3397, 3450, 3495, 3532, 3561, 3582, 3595, 3600, 3599, 3590, 3573, 3548, 3515, 3474, 3425, 3368, 3303, 3230, 3149, 3060, 2963, 2858, 2745, 2624, 2495, 2358, 2213, 2060, 1899, 1730, 1553, 1368, 1175, 974, 765, 548, 323, 90], [206, 435, 656, 869, 1074, 1271, 1460, 1641, 1814, 1979, 2136, 2285, 2426, 2559, 2684, 2801, 2910, 3011, 3104, 3189, 3266, 3335, 3396, 3449, 3494, 3531, 3560, 3581, 3594, 3593, 3592, 3591, 3574, 3549, 3516, 3475, 3426, 3369, 3304, 3231, 3150, 3061, 2964, 2859, 2746, 2625, 2496, 2359, 2214, 2061, 1900, 1731, 1554, 1369, 1176, 975, 766, 549, 324, 91], [205, 434, 655, 868, 1073, 1270, 1459, 1640, 1813, 1978, 2135, 2284, 2425, 2558, 2683, 2800, 2909, 3010, 3103, 3188, 3265, 3334, 3395, 3448, 3493, 3530, 3559, 3580, 3579, 3578, 3577, 3576, 3575, 3550, 3517, 3476, 3427, 3370, 3305, 3232, 3151, 3062, 2965, 2860, 2747, 2626, 2497, 2360, 2215, 2062, 1901, 1732, 1555, 1370, 1177, 976, 767, 550, 325, 92], [204, 433, 654, 867, 1072, 1269, 1458, 1639, 1812, 1977, 2134, 2283, 2424, 2557, 2682, 2799, 2908, 3009, 3102, 3187, 3264, 3333, 3394, 3447, 3492, 3529, 3558, 3557, 3556, 3555, 3554, 3553, 3552, 3551, 3518, 3477, 3428, 3371, 3306, 3233, 3152, 3063, 2966, 2861, 2748, 2627, 2498, 2361, 2216, 2063, 1902, 1733, 1556, 1371, 1178, 977, 768, 551, 326, 93], [203, 432, 653, 866, 1071, 1268, 1457, 1638, 1811, 1976, 2133, 2282, 2423, 2556, 2681, 2798, 2907, 3008, 3101, 3186, 3263, 3332, 3393, 3446, 3491, 3528, 3527, 3526, 3525, 3524, 3523, 3522, 3521, 3520, 3519, 3478, 3429, 3372, 3307, 3234, 3153, 3064, 2967, 2862, 2749, 2628, 2499, 2362, 2217, 2064, 1903, 1734, 1557, 1372, 1179, 978, 769, 552, 327, 94], [202, 431, 652, 865, 1070, 1267, 1456, 1637, 1810, 1975, 2132, 2281, 2422, 2555, 2680, 2797, 2906, 3007, 3100, 3185, 3262, 3331, 3392, 3445, 3490, 3489, 3488, 3487, 3486, 3485, 3484, 3483, 3482, 3481, 3480, 3479, 3430, 3373, 3308, 3235, 3154, 3065, 2968, 2863, 2750, 2629, 2500, 2363, 2218, 2065, 1904, 1735, 1558, 1373, 1180, 979, 770, 553, 328, 95], [201, 430, 651, 864, 1069, 1266, 1455, 1636, 1809, 1974, 2131, 2280, 2421, 2554, 2679, 2796, 2905, 3006, 3099, 3184, 3261, 3330, 3391, 3444, 3443, 3442, 3441, 3440, 3439, 3438, 3437, 3436, 3435, 3434, 3433, 3432, 3431, 3374, 3309, 3236, 3155, 3066, 2969, 2864, 2751, 2630, 2501, 2364, 2219, 2066, 1905, 1736, 1559, 1374, 1181, 980, 771, 554, 329, 96], [200, 429, 650, 863, 1068, 1265, 1454, 1635, 1808, 1973, 2130, 2279, 2420, 2553, 2678, 2795, 2904, 3005, 3098, 3183, 3260, 3329, 3390, 3389, 3388, 3387, 3386, 3385, 3384, 3383, 3382, 3381, 3380, 3379, 3378, 3377, 3376, 3375, 3310, 3237, 3156, 3067, 2970, 2865, 2752, 2631, 2502, 2365, 2220, 2067, 1906, 1737, 1560, 1375, 1182, 981, 772, 555, 330, 97], [199, 428, 649, 862, 1067, 1264, 1453, 1634, 1807, 1972, 2129, 2278, 2419, 2552, 2677, 2794, 2903, 3004, 3097, 3182, 3259, 3328, 3327, 3326, 3325, 3324, 3323, 3322, 3321, 3320, 3319, 3318, 3317, 3316, 3315, 3314, 3313, 3312, 3311, 3238, 3157, 3068, 2971, 2866, 2753, 2632, 2503, 2366, 2221, 2068, 1907, 1738, 1561, 1376, 1183, 982, 773, 556, 331, 98], [198, 427, 648, 861, 1066, 1263, 1452, 1633, 1806, 1971, 2128, 2277, 2418, 2551, 2676, 2793, 2902, 3003, 3096, 3181, 3258, 3257, 3256, 3255, 3254, 3253, 3252, 3251, 3250, 3249, 3248, 3247, 3246, 3245, 3244, 3243, 3242, 3241, 3240, 3239, 3158, 3069, 2972, 2867, 2754, 2633, 2504, 2367, 2222, 2069, 1908, 1739, 1562, 1377, 1184, 983, 774, 557, 332, 99], [197, 426, 647, 860, 1065, 1262, 1451, 1632, 1805, 1970, 2127, 2276, 2417, 2550, 2675, 2792, 2901, 3002, 3095, 3180, 3179, 3178, 3177, 3176, 3175, 3174, 3173, 3172, 3171, 3170, 3169, 3168, 3167, 3166, 3165, 3164, 3163, 3162, 3161, 3160, 3159, 3070, 2973, 2868, 2755, 2634, 2505, 2368, 2223, 2070, 1909, 1740, 1563, 1378, 1185, 984, 775, 558, 333, 100], [196, 425, 646, 859, 1064, 1261, 1450, 1631, 1804, 1969, 2126, 2275, 2416, 2549, 2674, 2791, 2900, 3001, 3094, 3093, 3092, 3091, 3090, 3089, 3088, 3087, 3086, 3085, 3084, 3083, 3082, 3081, 3080, 3079, 3078, 3077, 3076, 3075, 3074, 3073, 3072, 3071, 2974, 2869, 2756, 2635, 2506, 2369, 2224, 2071, 1910, 1741, 1564, 1379, 1186, 985, 776, 559, 334, 101], [195, 424, 645, 858, 1063, 1260, 1449, 1630, 1803, 1968, 2125, 2274, 2415, 2548, 2673, 2790, 2899, 3000, 2999, 2998, 2997, 2996, 2995, 2994, 2993, 2992, 2991, 2990, 2989, 2988, 2987, 2986, 2985, 2984, 2983, 2982, 2981, 2980, 2979, 2978, 2977, 2976, 2975, 2870, 2757, 2636, 2507, 2370, 2225, 2072, 1911, 1742, 1565, 1380, 1187, 986, 777, 560, 335, 102], [194, 423, 644, 857, 1062, 1259, 1448, 1629, 1802, 1967, 2124, 2273, 2414, 2547, 2672, 2789, 2898, 2897, 2896, 2895, 2894, 2893, 2892, 2891, 2890, 2889, 2888, 2887, 2886, 2885, 2884, 2883, 2882, 2881, 2880, 2879, 2878, 2877, 2876, 2875, 2874, 2873, 2872, 2871, 2758, 2637, 2508, 2371, 2226, 2073, 1912, 1743, 1566, 1381, 1188, 987, 778, 561, 336, 103], [193, 422, 643, 856, 1061, 1258, 1447, 1628, 1801, 1966, 2123, 2272, 2413, 2546, 2671, 2788, 2787, 2786, 2785, 2784, 2783, 2782, 2781, 2780, 2779, 2778, 2777, 2776, 2775, 2774, 2773, 2772, 2771, 2770, 2769, 2768, 2767, 2766, 2765, 2764, 2763, 2762, 2761, 2760, 2759, 2638, 2509, 2372, 2227, 2074, 1913, 1744, 1567, 1382, 1189, 988, 779, 562, 337, 104], [192, 421, 642, 855, 1060, 1257, 1446, 1627, 1800, 1965, 2122, 2271, 2412, 2545, 2670, 2669, 2668, 2667, 2666, 2665, 2664, 2663, 2662, 2661, 2660, 2659, 2658, 2657, 2656, 2655, 2654, 2653, 2652, 2651, 2650, 2649, 2648, 2647, 2646, 2645, 2644, 2643, 2642, 2641, 2640, 2639, 2510, 2373, 2228, 2075, 1914, 1745, 1568, 1383, 1190, 989, 780, 563, 338, 105], [191, 420, 641, 854, 1059, 1256, 1445, 1626, 1799, 1964, 2121, 2270, 2411, 2544, 2543, 2542, 2541, 2540, 2539, 2538, 2537, 2536, 2535, 2534, 2533, 2532, 2531, 2530, 2529, 2528, 2527, 2526, 2525, 2524, 2523, 2522, 2521, 2520, 2519, 2518, 2517, 2516, 2515, 2514, 2513, 2512, 2511, 2374, 2229, 2076, 1915, 1746, 1569, 1384, 1191, 990, 781, 564, 339, 106], [190, 419, 640, 853, 1058, 1255, 1444, 1625, 1798, 1963, 2120, 2269, 2410, 2409, 2408, 2407, 2406, 2405, 2404, 2403, 2402, 2401, 2400, 2399, 2398, 2397, 2396, 2395, 2394, 2393, 2392, 2391, 2390, 2389, 2388, 2387, 2386, 2385, 2384, 2383, 2382, 2381, 2380, 2379, 2378, 2377, 2376, 2375, 2230, 2077, 1916, 1747, 1570, 1385, 1192, 991, 782, 565, 340, 107], [189, 418, 639, 852, 1057, 1254, 1443, 1624, 1797, 1962, 2119, 2268, 2267, 2266, 2265, 2264, 2263, 2262, 2261, 2260, 2259, 2258, 2257, 2256, 2255, 2254, 2253, 2252, 2251, 2250, 2249, 2248, 2247, 2246, 2245, 2244, 2243, 2242, 2241, 2240, 2239, 2238, 2237, 2236, 2235, 2234, 2233, 2232, 2231, 2078, 1917, 1748, 1571, 1386, 1193, 992, 783, 566, 341, 108], [188, 417, 638, 851, 1056, 1253, 1442, 1623, 1796, 1961, 2118, 2117, 2116, 2115, 2114, 2113, 2112, 2111, 2110, 2109, 2108, 2107, 2106, 2105, 2104, 2103, 2102, 2101, 2100, 2099, 2098, 2097, 2096, 2095, 2094, 2093, 2092, 2091, 2090, 2089, 2088, 2087, 2086, 2085, 2084, 2083, 2082, 2081, 2080, 2079, 1918, 1749, 1572, 1387, 1194, 993, 784, 567, 342, 109], [187, 416, 637, 850, 1055, 1252, 1441, 1622, 1795, 1960, 1959, 1958, 1957, 1956, 1955, 1954, 1953, 1952, 1951, 1950, 1949, 1948, 1947, 1946, 1945, 1944, 1943, 1942, 1941, 1940, 1939, 1938, 1937, 1936, 1935, 1934, 1933, 1932, 1931, 1930, 1929, 1928, 1927, 1926, 1925, 1924, 1923, 1922, 1921, 1920, 1919, 1750, 1573, 1388, 1195, 994, 785, 568, 343, 110], [186, 415, 636, 849, 1054, 1251, 1440, 1621, 1794, 1793, 1792, 1791, 1790, 1789, 1788, 1787, 1786, 1785, 1784, 1783, 1782, 1781, 1780, 1779, 1778, 1777, 1776, 1775, 1774, 1773, 1772, 1771, 1770, 1769, 1768, 1767, 1766, 1765, 1764, 1763, 1762, 1761, 1760, 1759, 1758, 1757, 1756, 1755, 1754, 1753, 1752, 1751, 1574, 1389, 1196, 995, 786, 569, 344, 111], [185, 414, 635, 848, 1053, 1250, 1439, 1620, 1619, 1618, 1617, 1616, 1615, 1614, 1613, 1612, 1611, 1610, 1609, 1608, 1607, 1606, 1605, 1604, 1603, 1602, 1601, 1600, 1599, 1598, 1597, 1596, 1595, 1594, 1593, 1592, 1591, 1590, 1589, 1588, 1587, 1586, 1585, 1584, 1583, 1582, 1581, 1580, 1579, 1578, 1577, 1576, 1575, 1390, 1197, 996, 787, 570, 345, 112], [184, 413, 634, 847, 1052, 1249, 1438, 1437, 1436, 1435, 1434, 1433, 1432, 1431, 1430, 1429, 1428, 1427, 1426, 1425, 1424, 1423, 1422, 1421, 1420, 1419, 1418, 1417, 1416, 1415, 1414, 1413, 1412, 1411, 1410, 1409, 1408, 1407, 1406, 1405, 1404, 1403, 1402, 1401, 1400, 1399, 1398, 1397, 1396, 1395, 1394, 1393, 1392, 1391, 1198, 997, 788, 571, 346, 113], [183, 412, 633, 846, 1051, 1248, 1247, 1246, 1245, 1244, 1243, 1242, 1241, 1240, 1239, 1238, 1237, 1236, 1235, 1234, 1233, 1232, 1231, 1230, 1229, 1228, 1227, 1226, 1225, 1224, 1223, 1222, 1221, 1220, 1219, 1218, 1217, 1216, 1215, 1214, 1213, 1212, 1211, 1210, 1209, 1208, 1207, 1206, 1205, 1204, 1203, 1202, 1201, 1200, 1199, 998, 789, 572, 347, 114], [182, 411, 632, 845, 1050, 1049, 1048, 1047, 1046, 1045, 1044, 1043, 1042, 1041, 1040, 1039, 1038, 1037, 1036, 1035, 1034, 1033, 1032, 1031, 1030, 1029, 1028, 1027, 1026, 1025, 1024, 1023, 1022, 1021, 1020, 1019, 1018, 1017, 1016, 1015, 1014, 1013, 1012, 1011, 1010, 1009, 1008, 1007, 1006, 1005, 1004, 1003, 1002, 1001, 1000, 999, 790, 573, 348, 115], [181, 410, 631, 844, 843, 842, 841, 840, 839, 838, 837, 836, 835, 834, 833, 832, 831, 830, 829, 828, 827, 826, 825, 824, 823, 822, 821, 820, 819, 818, 817, 816, 815, 814, 813, 812, 811, 810, 809, 808, 807, 806, 805, 804, 803, 802, 801, 800, 799, 798, 797, 796, 795, 794, 793, 792, 791, 574, 349, 116], [180, 409, 630, 629, 628, 627, 626, 625, 624, 623, 622, 621, 620, 619, 618, 617, 616, 615, 614, 613, 612, 611, 610, 609, 608, 607, 606, 605, 604, 603, 602, 601, 600, 599, 598, 597, 596, 595, 594, 593, 592, 591, 590, 589, 588, 587, 586, 585, 584, 583, 582, 581, 580, 579, 578, 577, 576, 575, 350, 117], [179, 408, 407, 406, 405, 404, 403, 402, 401, 400, 399, 398, 397, 396, 395, 394, 393, 392, 391, 390, 389, 388, 387, 386, 385, 384, 383, 382, 381, 380, 379, 378, 377, 376, 375, 374, 373, 372, 371, 370, 369, 368, 367, 366, 365, 364, 363, 362, 361, 360, 359, 358, 357, 356, 355, 354, 353, 352, 351, 118], [178, 177, 176, 175, 174, 173, 172, 171, 170, 169, 168, 167, 166, 165, 164, 163, 162, 161, 160, 159, 158, 157, 156, 155, 154, 153, 152, 151, 150, 149, 148, 147, 146, 145, 144, 143, 142, 141, 140, 139, 138, 137, 136, 135, 134, 133, 132, 131, 130, 129, 128, 127, 126, 125, 124, 123, 122, 121, 120, 119]]\n    assert candidate(9) == [[1, 2, 3, 4, 5, 6, 7, 8, 9], [32, 33, 34, 35, 36, 37, 38, 39, 10], [31, 56, 57, 58, 59, 60, 61, 40, 11], [30, 55, 72, 73, 74, 75, 62, 41, 12], [29, 54, 71, 80, 81, 76, 63, 42, 13], [28, 53, 70, 79, 78, 77, 64, 43, 14], [27, 52, 69, 68, 67, 66, 65, 44, 15], [26, 51, 50, 49, 48, 47, 46, 45, 16], [25, 24, 23, 22, 21, 20, 19, 18, 17]]\n    assert candidate(40) == [[1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40], [156, 157, 158, 159, 160, 161, 162, 163, 164, 165, 166, 167, 168, 169, 170, 171, 172, 173, 174, 175, 176, 177, 178, 179, 180, 181, 182, 183, 184, 185, 186, 187, 188, 189, 190, 191, 192, 193, 194, 41], [155, 304, 305, 306, 307, 308, 309, 310, 311, 312, 313, 314, 315, 316, 317, 318, 319, 320, 321, 322, 323, 324, 325, 326, 327, 328, 329, 330, 331, 332, 333, 334, 335, 336, 337, 338, 339, 340, 195, 42], [154, 303, 444, 445, 446, 447, 448, 449, 450, 451, 452, 453, 454, 455, 456, 457, 458, 459, 460, 461, 462, 463, 464, 465, 466, 467, 468, 469, 470, 471, 472, 473, 474, 475, 476, 477, 478, 341, 196, 43], [153, 302, 443, 576, 577, 578, 579, 580, 581, 582, 583, 584, 585, 586, 587, 588, 589, 590, 591, 592, 593, 594, 595, 596, 597, 598, 599, 600, 601, 602, 603, 604, 605, 606, 607, 608, 479, 342, 197, 44], [152, 301, 442, 575, 700, 701, 702, 703, 704, 705, 706, 707, 708, 709, 710, 711, 712, 713, 714, 715, 716, 717, 718, 719, 720, 721, 722, 723, 724, 725, 726, 727, 728, 729, 730, 609, 480, 343, 198, 45], [151, 300, 441, 574, 699, 816, 817, 818, 819, 820, 821, 822, 823, 824, 825, 826, 827, 828, 829, 830, 831, 832, 833, 834, 835, 836, 837, 838, 839, 840, 841, 842, 843, 844, 731, 610, 481, 344, 199, 46], [150, 299, 440, 573, 698, 815, 924, 925, 926, 927, 928, 929, 930, 931, 932, 933, 934, 935, 936, 937, 938, 939, 940, 941, 942, 943, 944, 945, 946, 947, 948, 949, 950, 845, 732, 611, 482, 345, 200, 47], [149, 298, 439, 572, 697, 814, 923, 1024, 1025, 1026, 1027, 1028, 1029, 1030, 1031, 1032, 1033, 1034, 1035, 1036, 1037, 1038, 1039, 1040, 1041, 1042, 1043, 1044, 1045, 1046, 1047, 1048, 951, 846, 733, 612, 483, 346, 201, 48], [148, 297, 438, 571, 696, 813, 922, 1023, 1116, 1117, 1118, 1119, 1120, 1121, 1122, 1123, 1124, 1125, 1126, 1127, 1128, 1129, 1130, 1131, 1132, 1133, 1134, 1135, 1136, 1137, 1138, 1049, 952, 847, 734, 613, 484, 347, 202, 49], [147, 296, 437, 570, 695, 812, 921, 1022, 1115, 1200, 1201, 1202, 1203, 1204, 1205, 1206, 1207, 1208, 1209, 1210, 1211, 1212, 1213, 1214, 1215, 1216, 1217, 1218, 1219, 1220, 1139, 1050, 953, 848, 735, 614, 485, 348, 203, 50], [146, 295, 436, 569, 694, 811, 920, 1021, 1114, 1199, 1276, 1277, 1278, 1279, 1280, 1281, 1282, 1283, 1284, 1285, 1286, 1287, 1288, 1289, 1290, 1291, 1292, 1293, 1294, 1221, 1140, 1051, 954, 849, 736, 615, 486, 349, 204, 51], [145, 294, 435, 568, 693, 810, 919, 1020, 1113, 1198, 1275, 1344, 1345, 1346, 1347, 1348, 1349, 1350, 1351, 1352, 1353, 1354, 1355, 1356, 1357, 1358, 1359, 1360, 1295, 1222, 1141, 1052, 955, 850, 737, 616, 487, 350, 205, 52], [144, 293, 434, 567, 692, 809, 918, 1019, 1112, 1197, 1274, 1343, 1404, 1405, 1406, 1407, 1408, 1409, 1410, 1411, 1412, 1413, 1414, 1415, 1416, 1417, 1418, 1361, 1296, 1223, 1142, 1053, 956, 851, 738, 617, 488, 351, 206, 53], [143, 292, 433, 566, 691, 808, 917, 1018, 1111, 1196, 1273, 1342, 1403, 1456, 1457, 1458, 1459, 1460, 1461, 1462, 1463, 1464, 1465, 1466, 1467, 1468, 1419, 1362, 1297, 1224, 1143, 1054, 957, 852, 739, 618, 489, 352, 207, 54], [142, 291, 432, 565, 690, 807, 916, 1017, 1110, 1195, 1272, 1341, 1402, 1455, 1500, 1501, 1502, 1503, 1504, 1505, 1506, 1507, 1508, 1509, 1510, 1469, 1420, 1363, 1298, 1225, 1144, 1055, 958, 853, 740, 619, 490, 353, 208, 55], [141, 290, 431, 564, 689, 806, 915, 1016, 1109, 1194, 1271, 1340, 1401, 1454, 1499, 1536, 1537, 1538, 1539, 1540, 1541, 1542, 1543, 1544, 1511, 1470, 1421, 1364, 1299, 1226, 1145, 1056, 959, 854, 741, 620, 491, 354, 209, 56], [140, 289, 430, 563, 688, 805, 914, 1015, 1108, 1193, 1270, 1339, 1400, 1453, 1498, 1535, 1564, 1565, 1566, 1567, 1568, 1569, 1570, 1545, 1512, 1471, 1422, 1365, 1300, 1227, 1146, 1057, 960, 855, 742, 621, 492, 355, 210, 57], [139, 288, 429, 562, 687, 804, 913, 1014, 1107, 1192, 1269, 1338, 1399, 1452, 1497, 1534, 1563, 1584, 1585, 1586, 1587, 1588, 1571, 1546, 1513, 1472, 1423, 1366, 1301, 1228, 1147, 1058, 961, 856, 743, 622, 493, 356, 211, 58], [138, 287, 428, 561, 686, 803, 912, 1013, 1106, 1191, 1268, 1337, 1398, 1451, 1496, 1533, 1562, 1583, 1596, 1597, 1598, 1589, 1572, 1547, 1514, 1473, 1424, 1367, 1302, 1229, 1148, 1059, 962, 857, 744, 623, 494, 357, 212, 59], [137, 286, 427, 560, 685, 802, 911, 1012, 1105, 1190, 1267, 1336, 1397, 1450, 1495, 1532, 1561, 1582, 1595, 1600, 1599, 1590, 1573, 1548, 1515, 1474, 1425, 1368, 1303, 1230, 1149, 1060, 963, 858, 745, 624, 495, 358, 213, 60], [136, 285, 426, 559, 684, 801, 910, 1011, 1104, 1189, 1266, 1335, 1396, 1449, 1494, 1531, 1560, 1581, 1594, 1593, 1592, 1591, 1574, 1549, 1516, 1475, 1426, 1369, 1304, 1231, 1150, 1061, 964, 859, 746, 625, 496, 359, 214, 61], [135, 284, 425, 558, 683, 800, 909, 1010, 1103, 1188, 1265, 1334, 1395, 1448, 1493, 1530, 1559, 1580, 1579, 1578, 1577, 1576, 1575, 1550, 1517, 1476, 1427, 1370, 1305, 1232, 1151, 1062, 965, 860, 747, 626, 497, 360, 215, 62], [134, 283, 424, 557, 682, 799, 908, 1009, 1102, 1187, 1264, 1333, 1394, 1447, 1492, 1529, 1558, 1557, 1556, 1555, 1554, 1553, 1552, 1551, 1518, 1477, 1428, 1371, 1306, 1233, 1152, 1063, 966, 861, 748, 627, 498, 361, 216, 63], [133, 282, 423, 556, 681, 798, 907, 1008, 1101, 1186, 1263, 1332, 1393, 1446, 1491, 1528, 1527, 1526, 1525, 1524, 1523, 1522, 1521, 1520, 1519, 1478, 1429, 1372, 1307, 1234, 1153, 1064, 967, 862, 749, 628, 499, 362, 217, 64], [132, 281, 422, 555, 680, 797, 906, 1007, 1100, 1185, 1262, 1331, 1392, 1445, 1490, 1489, 1488, 1487, 1486, 1485, 1484, 1483, 1482, 1481, 1480, 1479, 1430, 1373, 1308, 1235, 1154, 1065, 968, 863, 750, 629, 500, 363, 218, 65], [131, 280, 421, 554, 679, 796, 905, 1006, 1099, 1184, 1261, 1330, 1391, 1444, 1443, 1442, 1441, 1440, 1439, 1438, 1437, 1436, 1435, 1434, 1433, 1432, 1431, 1374, 1309, 1236, 1155, 1066, 969, 864, 751, 630, 501, 364, 219, 66], [130, 279, 420, 553, 678, 795, 904, 1005, 1098, 1183, 1260, 1329, 1390, 1389, 1388, 1387, 1386, 1385, 1384, 1383, 1382, 1381, 1380, 1379, 1378, 1377, 1376, 1375, 1310, 1237, 1156, 1067, 970, 865, 752, 631, 502, 365, 220, 67], [129, 278, 419, 552, 677, 794, 903, 1004, 1097, 1182, 1259, 1328, 1327, 1326, 1325, 1324, 1323, 1322, 1321, 1320, 1319, 1318, 1317, 1316, 1315, 1314, 1313, 1312, 1311, 1238, 1157, 1068, 971, 866, 753, 632, 503, 366, 221, 68], [128, 277, 418, 551, 676, 793, 902, 1003, 1096, 1181, 1258, 1257, 1256, 1255, 1254, 1253, 1252, 1251, 1250, 1249, 1248, 1247, 1246, 1245, 1244, 1243, 1242, 1241, 1240, 1239, 1158, 1069, 972, 867, 754, 633, 504, 367, 222, 69], [127, 276, 417, 550, 675, 792, 901, 1002, 1095, 1180, 1179, 1178, 1177, 1176, 1175, 1174, 1173, 1172, 1171, 1170, 1169, 1168, 1167, 1166, 1165, 1164, 1163, 1162, 1161, 1160, 1159, 1070, 973, 868, 755, 634, 505, 368, 223, 70], [126, 275, 416, 549, 674, 791, 900, 1001, 1094, 1093, 1092, 1091, 1090, 1089, 1088, 1087, 1086, 1085, 1084, 1083, 1082, 1081, 1080, 1079, 1078, 1077, 1076, 1075, 1074, 1073, 1072, 1071, 974, 869, 756, 635, 506, 369, 224, 71], [125, 274, 415, 548, 673, 790, 899, 1000, 999, 998, 997, 996, 995, 994, 993, 992, 991, 990, 989, 988, 987, 986, 985, 984, 983, 982, 981, 980, 979, 978, 977, 976, 975, 870, 757, 636, 507, 370, 225, 72], [124, 273, 414, 547, 672, 789, 898, 897, 896, 895, 894, 893, 892, 891, 890, 889, 888, 887, 886, 885, 884, 883, 882, 881, 880, 879, 878, 877, 876, 875, 874, 873, 872, 871, 758, 637, 508, 371, 226, 73], [123, 272, 413, 546, 671, 788, 787, 786, 785, 784, 783, 782, 781, 780, 779, 778, 777, 776, 775, 774, 773, 772, 771, 770, 769, 768, 767, 766, 765, 764, 763, 762, 761, 760, 759, 638, 509, 372, 227, 74], [122, 271, 412, 545, 670, 669, 668, 667, 666, 665, 664, 663, 662, 661, 660, 659, 658, 657, 656, 655, 654, 653, 652, 651, 650, 649, 648, 647, 646, 645, 644, 643, 642, 641, 640, 639, 510, 373, 228, 75], [121, 270, 411, 544, 543, 542, 541, 540, 539, 538, 537, 536, 535, 534, 533, 532, 531, 530, 529, 528, 527, 526, 525, 524, 523, 522, 521, 520, 519, 518, 517, 516, 515, 514, 513, 512, 511, 374, 229, 76], [120, 269, 410, 409, 408, 407, 406, 405, 404, 403, 402, 401, 400, 399, 398, 397, 396, 395, 394, 393, 392, 391, 390, 389, 388, 387, 386, 385, 384, 383, 382, 381, 380, 379, 378, 377, 376, 375, 230, 77], [119, 268, 267, 266, 265, 264, 263, 262, 261, 260, 259, 258, 257, 256, 255, 254, 253, 252, 251, 250, 249, 248, 247, 246, 245, 244, 243, 242, 241, 240, 239, 238, 237, 236, 235, 234, 233, 232, 231, 78], [118, 117, 116, 115, 114, 113, 112, 111, 110, 109, 108, 107, 106, 105, 104, 103, 102, 101, 100, 99, 98, 97, 96, 95, 94, 93, 92, 91, 90, 89, 88, 87, 86, 85, 84, 83, 82, 81, 80, 79]]\n    assert candidate(10) == [[1, 2, 3, 4, 5, 6, 7, 8, 9, 10], [36, 37, 38, 39, 40, 41, 42, 43, 44, 11], [35, 64, 65, 66, 67, 68, 69, 70, 45, 12], [34, 63, 84, 85, 86, 87, 88, 71, 46, 13], [33, 62, 83, 96, 97, 98, 89, 72, 47, 14], [32, 61, 82, 95, 100, 99, 90, 73, 48, 15], [31, 60, 81, 94, 93, 92, 91, 74, 49, 16], [30, 59, 80, 79, 78, 77, 76, 75, 50, 17], [29, 58, 57, 56, 55, 54, 53, 52, 51, 18], [28, 27, 26, 25, 24, 23, 22, 21, 20, 19]]\n", "language": "python"}
{"task_id": "3e4608fd-d454-4131-90e7-78d86372774d-587797540951790721", "prompt": "You're a coding assistant. Your job is to fill in the given function so it works as-is in a code block. Don't add code outside the function. Stick to libraries already imported in the problem. Any helper functions or classes should be defined within the main function.\n\n```python\ndef word_pattern(pattern: str, s: str) -> bool:\n    \"\"\"\n    In a cryptography class, you're studying a peculiar form of encoding where a pattern string\n    is used to encode a message. Each character in the pattern corresponds to a word in the message,\n    and the same character should always map to the same word.\n\n    Given a pattern string and an encoded message string, your task is to determine if the message\n    follows the pattern. The message words are separated by a single space, and you can assume that\n    the pattern only contains lowercase letters and the message only contains lowercase letters and spaces.\n\n\n    [EXAMPLES]\n    \n    assert candidate(\"abcde\", \"dog cat fish bird elephant\") == True\n    assert candidate(\"aba\", \"cat dog cat\") == True\n\n    [/EXAMPLES]\n    \"\"\"\n```\n", "entry_point": "word_pattern", "solution": "def word_pattern(pattern: str, s: str) -> bool:\n    \"\"\"\n    In a cryptography class, you're studying a peculiar form of encoding where a pattern string\n    is used to encode a message. Each character in the pattern corresponds to a word in the message,\n    and the same character should always map to the same word.\n\n    Given a pattern string and an encoded message string, your task is to determine if the message\n    follows the pattern. The message words are separated by a single space, and you can assume that\n    the pattern only contains lowercase letters and the message only contains lowercase letters and spaces.\n\n\n    [EXAMPLES]\n    \n    assert candidate(\"abcde\", \"dog cat fish bird elephant\") == True\n    assert candidate(\"aba\", \"cat dog cat\") == True\n\n    [/EXAMPLES]\n    \"\"\"\n    words = s.split()\n    \n    if len(pattern) != len(words):\n        return False\n    \n    char_to_word = {}\n    word_to_char = {}\n    \n    for char, word in zip(pattern, words):\n        if char in char_to_word:\n            if char_to_word[char] != word:\n                return False\n        else:\n            if word in word_to_char:\n                return False\n            char_to_word[char] = word\n            word_to_char[word] = char\n    \n    return True\n\n", "test": "def check(candidate):\n    assert candidate(\"abc\", \"dog cat dog\") == False\n    assert candidate(\"aba\", \"cat dog cat\") == True\n    assert candidate(\"a\", \"dog\") == True\n    assert candidate(\"abcde\", \"dog cat fish bird elephant\") == True\n", "language": "python"}
{"task_id": "ae1118fb-c273-42d0-8bf8-a2c3636f2931-5747013646140237574", "prompt": "I'll assist you with coding by completing given functions in executable form. I'll confine my code to the function block and only use libraries that are imported in the problem statement. Any additional helper functions or classes will be defined within the given function.\n\n```python\nimport math\n\ndef calculate_rocket_fuel(mass: float, delta_v: float, isp: float) -> float:\n    \"\"\"\n    As a rocket scientist, I need to calculate the amount of fuel required for a spacecraft\n    to achieve a certain change in velocity (delta-v) given its mass and the specific impulse (Isp)\n    of its engines. This function uses the Tsiolkovsky rocket equation to determine the fuel mass\n    needed for the maneuver.\n\n\n    [EXAMPLES]\n    \n    assert candidate(1e-3, 1e3, 1e2) == 0.0017724078789397675\n    assert candidate(100.0, 1000.0, 200.0) == 66.50549176948391\n\n    [/EXAMPLES]\n    \"\"\"\n```\n", "entry_point": "calculate_rocket_fuel", "solution": "import math\n\ndef calculate_rocket_fuel(mass: float, delta_v: float, isp: float) -> float:\n    \"\"\"\n    As a rocket scientist, I need to calculate the amount of fuel required for a spacecraft\n    to achieve a certain change in velocity (delta-v) given its mass and the specific impulse (Isp)\n    of its engines. This function uses the Tsiolkovsky rocket equation to determine the fuel mass\n    needed for the maneuver.\n\n\n    [EXAMPLES]\n    \n    assert candidate(1e-3, 1e3, 1e2) == 0.0017724078789397675\n    assert candidate(100.0, 1000.0, 200.0) == 66.50549176948391\n\n    [/EXAMPLES]\n    \"\"\"\n    # Standard gravity acceleration (m/s^2)\n    g0 = 9.80665\n\n    # Calculate the mass ratio using the Tsiolkovsky rocket equation\n    mass_ratio = math.exp(delta_v / (isp * g0))\n\n    # Calculate the fuel mass\n    fuel_mass = mass * (mass_ratio - 1)\n\n    return fuel_mass\n\n", "test": "def check(candidate):\n    assert candidate(10000000.0, 50000.0, 500.0) == 268259465537.9363\n    assert candidate(1000000.0, 100000.0, 450.0) == 6938561326057186.0\n    assert candidate(1000.0, 5000.0, 300.0) == 4471.358945199606\n    assert candidate(1.0, 1.0, 100.0) == 0.001020236300320887\n    assert candidate(10000.0, 10000.0, 400.0) == 117980.20780482084\n    assert candidate(100.0, 1000.0, 200.0) == 66.50549176948391\n    assert candidate(300.0, 1500.0, 220.0) == 301.2696657296492\n    assert candidate(1e6, 1e5, 1e3) == 26825946553.79363\n    assert candidate(0.001, 10.0, 100.0) == 1.0249330359376919e-05\n    assert candidate(1e-3, 1e3, 1e2) == 0.0017724078789397675\n", "language": "python"}
{"task_id": "0289d325-4418-4043-96f1-42c66a5f6ded7034133407348581730", "prompt": "I'm here to complete your function with working code. I'll ensure my solution stays within the function block you provide, only utilizes libraries imported in the problem, and includes any necessary helper functions or classes within the main function structure.\n\n```python\ndef decode_alien_message(encrypted_text: str, key: int) -> str:\n    \"\"\"\n    An alien civilization has sent us an encrypted message. Our cryptography team believes it's a simple shift cipher.\n    We need to decode the message to establish first contact. The key represents the number of positions each letter\n    has been shifted in the alphabet.\n\n    This function takes the encrypted text and the decryption key as input, and returns the decrypted message.\n    The function should handle uppercase and lowercase letters, preserving their case. Non-alphabetic characters\n    should remain unchanged.\n\n\n    [EXAMPLES]\n    \n    assert candidate(\"ABC123xyz\", 1) == 'ZAB123wxy'\n    assert candidate(\"XYZ890abc\", 3) == 'UVW890xyz'\n\n    [/EXAMPLES]\n    \"\"\"\n```\n", "entry_point": "decode_alien_message", "solution": "def decode_alien_message(encrypted_text: str, key: int) -> str:\n    \"\"\"\n    An alien civilization has sent us an encrypted message. Our cryptography team believes it's a simple shift cipher.\n    We need to decode the message to establish first contact. The key represents the number of positions each letter\n    has been shifted in the alphabet.\n\n    This function takes the encrypted text and the decryption key as input, and returns the decrypted message.\n    The function should handle uppercase and lowercase letters, preserving their case. Non-alphabetic characters\n    should remain unchanged.\n\n\n    [EXAMPLES]\n    \n    assert candidate(\"ABC123xyz\", 1) == 'ZAB123wxy'\n    assert candidate(\"XYZ890abc\", 3) == 'UVW890xyz'\n\n    [/EXAMPLES]\n    \"\"\"\n    def shift_letter(char: str, shift: int) -> str:\n        if char.isalpha():\n            ascii_offset = ord('A') if char.isupper() else ord('a')\n            return chr((ord(char) - ascii_offset - shift) % 26 + ascii_offset)\n        return char\n\n    return ''.join(shift_letter(char, key) for char in encrypted_text)\n\n", "test": "def check(candidate):\n    assert candidate(\"Pmttw, Mibpv!\", 8) == 'Hello, Eathn!'\n    assert candidate(\"Aol Xbpjr Iyvdu Mve Qbtwz Vcly Aol Shgf Kvn\", 7) == 'The Quick Brown Fox Jumps Over The Lazy Dog'\n    assert candidate(\"Hello, World!\", 26) == 'Hello, World!'\n    assert candidate(\"The Quick Brown Fox Jumps Over The Lazy Dog\", 7) == 'Max Jnbvd Ukhpg Yhq Cnfil Hoxk Max Etsr Whz'\n    assert candidate(\"Khoor, Zruog!\", 3) == 'Hello, World!'\n    assert candidate(\"XYZ890abc\", 3) == 'UVW890xyz'\n    assert candidate(\"A1B2C3\", 13) == 'N1O2P3'\n    assert candidate(\"ABC123xyz\", 1) == 'ZAB123wxy'\n    assert candidate(\"AbCdEfG\", 2) == 'YzAbCdE'\n    assert candidate(\"\", 5) == ''\n", "language": "python"}
{"task_id": "73b1b7e5-90fd-4966-b3db-dea364eb75ef9118745710359965971", "prompt": "You are a coding assistant. I'll help you complete functions so they can be executed as is within code blocks. I'll only code within the function bounds, using only imported libraries, and will define any additional functions or classes inside the given function.\n\n```python\nfrom typing import List\n\ndef decode_alien_message(message: str, dictionary: List[str]) -> List[str]:\n    \"\"\"\n    Scientists have intercepted an alien message composed of a string of characters.\n    They believe it can be decoded into words from a given dictionary. \n    Return all possible decodings of the message using words from the dictionary.\n\n    This function involves string manipulation and recursive problem-solving.\n\n\n    [EXAMPLES]\n    \n    assert candidate(\"abcdefg\", [\"a\", \"b\", \"c\", \"d\", \"e\", \"f\", \"g\"]) == ['a b c d e f g']\n    assert candidate(\"123123123\", [\"1\", \"2\", \"3\", \"12\", \"23\", \"123\"]) == ['1 2 3 1 2 3 1 2 3', '1 2 3 1 2 3 1 23', '1 2 3 1 2 3 12 3', '1 2 3 1 2 3 123', '1 2 3 1 23 1 2 3', '1 2 3 1 23 1 23', '1 2 3 1 23 12 3', '1 2 3 1 23 123', '1 2 3 12 3 1 2 3', '1 2 3 12 3 1 23', '1 2 3 12 3 12 3', '1 2 3 12 3 123', '1 2 3 123 1 2 3', '1 2 3 123 1 23', '1 2 3 123 12 3', '1 2 3 123 123', '1 23 1 2 3 1 2 3', '1 23 1 2 3 1 23', '1 23 1 2 3 12 3', '1 23 1 2 3 123', '1 23 1 23 1 2 3', '1 23 1 23 1 23', '1 23 1 23 12 3', '1 23 1 23 123', '1 23 12 3 1 2 3', '1 23 12 3 1 23', '1 23 12 3 12 3', '1 23 12 3 123', '1 23 123 1 2 3', '1 23 123 1 23', '1 23 123 12 3', '1 23 123 123', '12 3 1 2 3 1 2 3', '12 3 1 2 3 1 23', '12 3 1 2 3 12 3', '12 3 1 2 3 123', '12 3 1 23 1 2 3', '12 3 1 23 1 23', '12 3 1 23 12 3', '12 3 1 23 123', '12 3 12 3 1 2 3', '12 3 12 3 1 23', '12 3 12 3 12 3', '12 3 12 3 123', '12 3 123 1 2 3', '12 3 123 1 23', '12 3 123 12 3', '12 3 123 123', '123 1 2 3 1 2 3', '123 1 2 3 1 23', '123 1 2 3 12 3', '123 1 2 3 123', '123 1 23 1 2 3', '123 1 23 1 23', '123 1 23 12 3', '123 1 23 123', '123 12 3 1 2 3', '123 12 3 1 23', '123 12 3 12 3', '123 12 3 123', '123 123 1 2 3', '123 123 1 23', '123 123 12 3', '123 123 123']\n\n    [/EXAMPLES]\n    \"\"\"\n```\n", "entry_point": "decode_alien_message", "solution": "from typing import List\n\ndef decode_alien_message(message: str, dictionary: List[str]) -> List[str]:\n    \"\"\"\n    Scientists have intercepted an alien message composed of a string of characters.\n    They believe it can be decoded into words from a given dictionary. \n    Return all possible decodings of the message using words from the dictionary.\n\n    This function involves string manipulation and recursive problem-solving.\n\n\n    [EXAMPLES]\n    \n    assert candidate(\"abcdefg\", [\"a\", \"b\", \"c\", \"d\", \"e\", \"f\", \"g\"]) == ['a b c d e f g']\n    assert candidate(\"123123123\", [\"1\", \"2\", \"3\", \"12\", \"23\", \"123\"]) == ['1 2 3 1 2 3 1 2 3', '1 2 3 1 2 3 1 23', '1 2 3 1 2 3 12 3', '1 2 3 1 2 3 123', '1 2 3 1 23 1 2 3', '1 2 3 1 23 1 23', '1 2 3 1 23 12 3', '1 2 3 1 23 123', '1 2 3 12 3 1 2 3', '1 2 3 12 3 1 23', '1 2 3 12 3 12 3', '1 2 3 12 3 123', '1 2 3 123 1 2 3', '1 2 3 123 1 23', '1 2 3 123 12 3', '1 2 3 123 123', '1 23 1 2 3 1 2 3', '1 23 1 2 3 1 23', '1 23 1 2 3 12 3', '1 23 1 2 3 123', '1 23 1 23 1 2 3', '1 23 1 23 1 23', '1 23 1 23 12 3', '1 23 1 23 123', '1 23 12 3 1 2 3', '1 23 12 3 1 23', '1 23 12 3 12 3', '1 23 12 3 123', '1 23 123 1 2 3', '1 23 123 1 23', '1 23 123 12 3', '1 23 123 123', '12 3 1 2 3 1 2 3', '12 3 1 2 3 1 23', '12 3 1 2 3 12 3', '12 3 1 2 3 123', '12 3 1 23 1 2 3', '12 3 1 23 1 23', '12 3 1 23 12 3', '12 3 1 23 123', '12 3 12 3 1 2 3', '12 3 12 3 1 23', '12 3 12 3 12 3', '12 3 12 3 123', '12 3 123 1 2 3', '12 3 123 1 23', '12 3 123 12 3', '12 3 123 123', '123 1 2 3 1 2 3', '123 1 2 3 1 23', '123 1 2 3 12 3', '123 1 2 3 123', '123 1 23 1 2 3', '123 1 23 1 23', '123 1 23 12 3', '123 1 23 123', '123 12 3 1 2 3', '123 12 3 1 23', '123 12 3 12 3', '123 12 3 123', '123 123 1 2 3', '123 123 1 23', '123 123 12 3', '123 123 123']\n\n    [/EXAMPLES]\n    \"\"\"\n    def backtrack(start: int, current_decoding: List[str]) -> None:\n        if start == len(message):\n            decodings.append(\" \".join(current_decoding))\n            return\n\n        for word in dictionary:\n            if message.startswith(word, start):\n                current_decoding.append(word)\n                backtrack(start + len(word), current_decoding)\n                current_decoding.pop()\n\n    decodings = []\n    backtrack(0, [])\n    return decodings\n\n", "test": "def check(candidate):\n    assert candidate(\"helloworld\", [\"hello\", \"world\", \"he\", \"ll\", \"o\", \"w\", \"or\", \"ld\"]) == ['hello world', 'hello w or ld', 'he ll o world', 'he ll o w or ld']\n    assert candidate(\"supercalifragilisticexpialidocious\", [\"super\", \"cali\", \"fragi\", \"listic\", \"expiali\", \"docious\"]) == ['super cali fragi listic expiali docious']\n    assert candidate(\"abcdefg\", [\"a\", \"b\", \"c\", \"d\", \"e\", \"f\", \"g\"]) == ['a b c d e f g']\n    assert candidate(\"thequickbrownfox\", [\"the\", \"quick\", \"brown\", \"fox\", \"the\", \"qui\", \"ck\"]) == ['the quick brown fox', 'the qui ck brown fox', 'the quick brown fox', 'the qui ck brown fox']\n    assert candidate(\"123123123\", [\"1\", \"2\", \"3\", \"12\", \"23\", \"123\"]) == ['1 2 3 1 2 3 1 2 3', '1 2 3 1 2 3 1 23', '1 2 3 1 2 3 12 3', '1 2 3 1 2 3 123', '1 2 3 1 23 1 2 3', '1 2 3 1 23 1 23', '1 2 3 1 23 12 3', '1 2 3 1 23 123', '1 2 3 12 3 1 2 3', '1 2 3 12 3 1 23', '1 2 3 12 3 12 3', '1 2 3 12 3 123', '1 2 3 123 1 2 3', '1 2 3 123 1 23', '1 2 3 123 12 3', '1 2 3 123 123', '1 23 1 2 3 1 2 3', '1 23 1 2 3 1 23', '1 23 1 2 3 12 3', '1 23 1 2 3 123', '1 23 1 23 1 2 3', '1 23 1 23 1 23', '1 23 1 23 12 3', '1 23 1 23 123', '1 23 12 3 1 2 3', '1 23 12 3 1 23', '1 23 12 3 12 3', '1 23 12 3 123', '1 23 123 1 2 3', '1 23 123 1 23', '1 23 123 12 3', '1 23 123 123', '12 3 1 2 3 1 2 3', '12 3 1 2 3 1 23', '12 3 1 2 3 12 3', '12 3 1 2 3 123', '12 3 1 23 1 2 3', '12 3 1 23 1 23', '12 3 1 23 12 3', '12 3 1 23 123', '12 3 12 3 1 2 3', '12 3 12 3 1 23', '12 3 12 3 12 3', '12 3 12 3 123', '12 3 123 1 2 3', '12 3 123 1 23', '12 3 123 12 3', '12 3 123 123', '123 1 2 3 1 2 3', '123 1 2 3 1 23', '123 1 2 3 12 3', '123 1 2 3 123', '123 1 23 1 2 3', '123 1 23 1 23', '123 1 23 12 3', '123 1 23 123', '123 12 3 1 2 3', '123 12 3 1 23', '123 12 3 12 3', '123 12 3 123', '123 123 1 2 3', '123 123 1 23', '123 123 12 3', '123 123 123']\n    assert candidate(\"owoztneoer\", [\"one\", \"two\", \"three\", \"zero\"]) == []\n    assert candidate(\"abc\", [\"a\", \"b\", \"c\", \"ab\", \"bc\", \"abc\"]) == ['a b c', 'a bc', 'ab c', 'abc']\n    assert candidate(\"xyzabc\", [\"xyz\", \"abc\", \"x\", \"y\", \"z\"]) == ['xyz abc', 'x y z abc']\n    assert candidate(\"\", []) == ['']\n    assert candidate(\"zzz\", [\"z\"]) == ['z z z']\n", "language": "python"}
{"task_id": "a23e1447-adb3-4cdd-aaa7-57d77af49240-8086054458116204566", "prompt": "Your goal is to implement the given function completely so it's ready to run. Keep all code within the function definition. Don't add imports - use only the libraries specified in the problem. Any auxiliary functions or classes should be defined within the main function.\n\n```python\nfrom typing import List\n\ndef optimize_meeting_schedule(durations: List[int], max_time: int) -> List[int]:\n    \"\"\"\n    An executive assistant is trying to schedule as many meetings as possible\n    within a given time frame. Each meeting has a fixed duration, and there\n    are no breaks between meetings.\n\n    This function takes a list of meeting durations in minutes and the maximum\n    available time, returning a list of indices representing the optimal\n    selection of meetings to maximize the number of meetings held.\n\n\n    [EXAMPLES]\n    \n    assert candidate([1, 2, 3, 4, 5, 6, 7, 8, 9, 10], 30) == [0, 1, 2, 3, 4, 5, 6]\n    assert candidate([30, 60, 45, 15, 45], 120) == [0, 2, 3]\n\n    [/EXAMPLES]\n    \"\"\"\n```\n", "entry_point": "optimize_meeting_schedule", "solution": "from typing import List\n\ndef optimize_meeting_schedule(durations: List[int], max_time: int) -> List[int]:\n    \"\"\"\n    An executive assistant is trying to schedule as many meetings as possible\n    within a given time frame. Each meeting has a fixed duration, and there\n    are no breaks between meetings.\n\n    This function takes a list of meeting durations in minutes and the maximum\n    available time, returning a list of indices representing the optimal\n    selection of meetings to maximize the number of meetings held.\n\n\n    [EXAMPLES]\n    \n    assert candidate([1, 2, 3, 4, 5, 6, 7, 8, 9, 10], 30) == [0, 1, 2, 3, 4, 5, 6]\n    assert candidate([30, 60, 45, 15, 45], 120) == [0, 2, 3]\n\n    [/EXAMPLES]\n    \"\"\"\n    # Create a list of tuples containing (duration, index)\n    meetings = list(enumerate(durations))\n    \n    # Sort meetings by duration (ascending order)\n    meetings.sort(key=lambda x: x[1])\n    \n    optimal_schedule = []\n    total_time = 0\n    \n    for index, duration in meetings:\n        if total_time + duration <= max_time:\n            optimal_schedule.append(index)\n            total_time += duration\n        else:\n            break\n    \n    # Sort the indices to return them in ascending order\n    return sorted(optimal_schedule)\n\n", "test": "def check(candidate):\n    assert candidate([45, 45, 45, 45], 180) == [0, 1, 2, 3]\n    assert candidate([30, 60, 45, 15, 45], 120) == [0, 2, 3]\n    assert candidate([10, 20, 30, 40, 50, 60], 100) == [0, 1, 2, 3]\n    assert candidate([1, 2, 3, 4, 5, 6, 7, 8, 9, 10], 30) == [0, 1, 2, 3, 4, 5, 6]\n    assert candidate([60, 60, 60, 60], 240) == [0, 1, 2, 3]\n    assert candidate([1], 1) == [0]\n    assert candidate([1, 1, 1, 1, 1, 1, 1, 1, 1, 1], 5) == [0, 1, 2, 3, 4]\n    assert candidate([5, 10, 15, 20, 25], 50) == [0, 1, 2, 3]\n    assert candidate([], 100) == []\n    assert candidate([1, 2, 3, 4, 5], 10) == [0, 1, 2, 3]\n", "language": "python"}
{"task_id": "2371725c-169f-4cb7-97c0-996c5fd6f7ae5638251578746429370", "prompt": "My role is to assist with coding by completing functions that are ready to execute. I'll ensure the code uses only the imported libraries and will define any supplementary functions or classes within the main function scope.\n\n```python\ndef solve_maze(maze: list) -> list:\n    \"\"\"\n    You are creating a maze-solving algorithm for a robot.\n    Given a 2D list representing a maze (0 for path, 1 for wall),\n    find a path from the top-left corner to the bottom-right corner.\n    The robot can only move right or down.\n    Return the path as a list of coordinates [(x, y), ...] or an empty list if no path exists.\n\n    This function involves 2D list manipulation and pathfinding concepts.\n\n\n    [EXAMPLES]\n    \n    assert candidate([[0, 0], [0, 0]]) == [(0, 0), (0, 1), (1, 1)]\n    assert candidate([[0, 0, 0, 0, 0], [0, 1, 1, 1, 0], [0, 1, 0, 1, 0], [0, 1, 1, 1, 0], [0, 0, 0, 0, 0]]) == [(0, 0), (0, 1), (0, 2), (0, 3), (0, 4), (1, 4), (2, 4), (3, 4), (4, 4)]\n\n    [/EXAMPLES]\n    \"\"\"\n```\n", "entry_point": "solve_maze", "solution": "def solve_maze(maze: list) -> list:\n    \"\"\"\n    You are creating a maze-solving algorithm for a robot.\n    Given a 2D list representing a maze (0 for path, 1 for wall),\n    find a path from the top-left corner to the bottom-right corner.\n    The robot can only move right or down.\n    Return the path as a list of coordinates [(x, y), ...] or an empty list if no path exists.\n\n    This function involves 2D list manipulation and pathfinding concepts.\n\n\n    [EXAMPLES]\n    \n    assert candidate([[0, 0], [0, 0]]) == [(0, 0), (0, 1), (1, 1)]\n    assert candidate([[0, 0, 0, 0, 0], [0, 1, 1, 1, 0], [0, 1, 0, 1, 0], [0, 1, 1, 1, 0], [0, 0, 0, 0, 0]]) == [(0, 0), (0, 1), (0, 2), (0, 3), (0, 4), (1, 4), (2, 4), (3, 4), (4, 4)]\n\n    [/EXAMPLES]\n    \"\"\"\n    def dfs(x, y, path):\n        # Check if we're out of bounds or hit a wall\n        if x >= len(maze) or y >= len(maze[0]) or maze[x][y] == 1:\n            return None\n        \n        # Check if we've reached the goal (bottom-right corner)\n        if x == len(maze) - 1 and y == len(maze[0]) - 1:\n            return path + [(x, y)]\n        \n        # Try moving right\n        right_path = dfs(x, y + 1, path + [(x, y)])\n        if right_path:\n            return right_path\n        \n        # Try moving down\n        down_path = dfs(x + 1, y, path + [(x, y)])\n        if down_path:\n            return down_path\n        \n        # If neither right nor down leads to a solution, return None\n        return None\n\n    # Start the search from the top-left corner\n    result = dfs(0, 0, [])\n    return result if result else []\n\n", "test": "def check(candidate):\n    assert candidate([[0, 0, 0, 0, 0], [1, 1, 1, 1, 0], [0, 0, 0, 0, 0]]) == [(0, 0), (0, 1), (0, 2), (0, 3), (0, 4), (1, 4), (2, 4)]\n    assert candidate([[0, 0], [1, 0]]) == [(0, 0), (0, 1), (1, 1)]\n    assert candidate([[0, 0, 0, 0], [0, 1, 1, 0], [0, 1, 0, 0], [0, 1, 1, 0]]) == [(0, 0), (0, 1), (0, 2), (0, 3), (1, 3), (2, 3), (3, 3)]\n    assert candidate([[0, 0, 0], [0, 0, 0], [0, 0, 0]]) == [(0, 0), (0, 1), (0, 2), (1, 2), (2, 2)]\n    assert candidate([[1, 0, 0, 0, 0], [0, 0, 1, 1, 0], [0, 1, 0, 1, 0], [0, 1, 1, 1, 0], [0, 0, 0, 1, 0]]) == []\n    assert candidate([[0, 0, 1, 1], [1, 0, 0, 1], [1, 1, 0, 0], [1, 1, 1, 0]]) == [(0, 0), (0, 1), (1, 1), (1, 2), (2, 2), (2, 3), (3, 3)]\n    assert candidate([[0, 0, 0, 0, 0], [0, 1, 1, 1, 0], [0, 1, 0, 1, 0], [0, 1, 1, 1, 0], [0, 0, 0, 0, 0]]) == [(0, 0), (0, 1), (0, 2), (0, 3), (0, 4), (1, 4), (2, 4), (3, 4), (4, 4)]\n    assert candidate([[0, 0], [0, 0]]) == [(0, 0), (0, 1), (1, 1)]\n    assert candidate([[0, 0, 0, 1], [1, 1, 0, 1], [0, 0, 0, 0]]) == [(0, 0), (0, 1), (0, 2), (1, 2), (2, 2), (2, 3)]\n    assert candidate([[0, 1], [1, 0]]) == []\n", "language": "python"}
{"task_id": "038d4e2a-960b-48b1-b338-3018c51de6a0-3626380856648504521", "prompt": "I'm a coding helper designed to implement functions that can be directly executed. I'll strictly code within the function you provide, using only the libraries already imported in the problem statement. Any additional functions or classes needed for the solution will be defined inside your main function.\n\n```python\ndef analyze_dna_sequence(sequence: str) -> dict:\n    \"\"\"\n    Analyzes a DNA sequence and provides various statistics about its composition.\n    \n    This function takes a DNA sequence as input and calculates the frequency of\n    each nucleotide (A, C, G, T), the GC content, and identifies any non-standard\n    nucleotides present in the sequence.\n    \n    Args:\n    sequence (str): The DNA sequence to analyze (uppercase letters only).\n    \n    Returns:\n    dict: A dictionary containing nucleotide frequencies, GC content, and non-standard nucleotides.\n    \n\n    [EXAMPLES]\n    \n    assert candidate(\"ATCGATXAGCTCTAGCG\") == {'A': 0.23529411764705882, 'C': 0.23529411764705882, 'G': 0.23529411764705882, 'T': 0.23529411764705882, 'GC_content': 0.47058823529411764, 'non_standard': ['X']}\n    assert candidate(\"NNNNNNNN\") == {'A': 0.0, 'C': 0.0, 'G': 0.0, 'T': 0.0, 'GC_content': 0.0, 'non_standard': ['N']}\n\n    [/EXAMPLES]\n    \"\"\"\n```\n", "entry_point": "analyze_dna_sequence", "solution": "def analyze_dna_sequence(sequence: str) -> dict:\n    \"\"\"\n    Analyzes a DNA sequence and provides various statistics about its composition.\n    \n    This function takes a DNA sequence as input and calculates the frequency of\n    each nucleotide (A, C, G, T), the GC content, and identifies any non-standard\n    nucleotides present in the sequence.\n    \n    Args:\n    sequence (str): The DNA sequence to analyze (uppercase letters only).\n    \n    Returns:\n    dict: A dictionary containing nucleotide frequencies, GC content, and non-standard nucleotides.\n    \n\n    [EXAMPLES]\n    \n    assert candidate(\"ATCGATXAGCTCTAGCG\") == {'A': 0.23529411764705882, 'C': 0.23529411764705882, 'G': 0.23529411764705882, 'T': 0.23529411764705882, 'GC_content': 0.47058823529411764, 'non_standard': ['X']}\n    assert candidate(\"NNNNNNNN\") == {'A': 0.0, 'C': 0.0, 'G': 0.0, 'T': 0.0, 'GC_content': 0.0, 'non_standard': ['N']}\n\n    [/EXAMPLES]\n    \"\"\"\n    # Initialize counters and lists\n    total_length = len(sequence)\n    nucleotide_counts = {'A': 0, 'C': 0, 'G': 0, 'T': 0}\n    non_standard = set()\n\n    # Count nucleotides and identify non-standard ones\n    for nucleotide in sequence:\n        if nucleotide in nucleotide_counts:\n            nucleotide_counts[nucleotide] += 1\n        else:\n            non_standard.add(nucleotide)\n\n    # Calculate frequencies\n    frequencies = {\n        nucleotide: count / total_length\n        for nucleotide, count in nucleotide_counts.items()\n    }\n\n    # Calculate GC content\n    gc_content = (nucleotide_counts['G'] + nucleotide_counts['C']) / total_length\n\n    # Prepare the result dictionary\n    result = {\n        **frequencies,\n        'GC_content': gc_content,\n        'non_standard': sorted(list(non_standard))\n    }\n\n    return result\n\n", "test": "def check(candidate):\n    assert candidate(\"ATCGATNAGCTCTAGCG\") == {'A': 0.23529411764705882, 'C': 0.23529411764705882, 'G': 0.23529411764705882, 'T': 0.23529411764705882, 'GC_content': 0.47058823529411764, 'non_standard': ['N']}\n    assert candidate(\"NNNNNNNN\") == {'A': 0.0, 'C': 0.0, 'G': 0.0, 'T': 0.0, 'GC_content': 0.0, 'non_standard': ['N']}\n    assert candidate(\"AAAA\") == {'A': 1.0, 'C': 0.0, 'G': 0.0, 'T': 0.0, 'GC_content': 0.0, 'non_standard': []}\n    assert candidate(\"A\") == {'A': 1.0, 'C': 0.0, 'G': 0.0, 'T': 0.0, 'GC_content': 0.0, 'non_standard': []}\n    assert candidate(\"ATCGATXAGCTCTAGCG\") == {'A': 0.23529411764705882, 'C': 0.23529411764705882, 'G': 0.23529411764705882, 'T': 0.23529411764705882, 'GC_content': 0.47058823529411764, 'non_standard': ['X']}\n    assert candidate(\"AAAAAAAAAACCCCCCCCCC\") == {'A': 0.5, 'C': 0.5, 'G': 0.0, 'T': 0.0, 'GC_content': 0.5, 'non_standard': []}\n    assert candidate(\"N\" * 100 + \"ATCG\" * 25) == {'A': 0.125, 'C': 0.125, 'G': 0.125, 'T': 0.125, 'GC_content': 0.25, 'non_standard': ['N']}\n    assert candidate(\"ACGTACGTACGTACGT\") == {'A': 0.25, 'C': 0.25, 'G': 0.25, 'T': 0.25, 'GC_content': 0.5, 'non_standard': []}\n    assert candidate(\"ATCGATCGATCGATCGATCGATCGATCGATCGATCGATCG\") == {'A': 0.25, 'C': 0.25, 'G': 0.25, 'T': 0.25, 'GC_content': 0.5, 'non_standard': []}\n    assert candidate(\"ATCG\") == {'A': 0.25, 'C': 0.25, 'G': 0.25, 'T': 0.25, 'GC_content': 0.5, 'non_standard': []}\n", "language": "python"}
{"task_id": "7f0bab10-f82a-4b44-851e-f3d559a5f5a86669316046793088106", "prompt": "I need you to fill in the given function so it runs correctly. Everything should be in one code block. Don't write any code outside the function. Stick to using only the libraries imported in the problem. If you need auxiliary functions or classes, nest them inside the main function.\n\n```python\nfrom typing import List, Tuple\n\ndef analyze_climate_patterns(temperature_data: List[Tuple[int, int]]) -> int:\n    \"\"\"\n    A climatologist is studying temperature patterns in a specific region. They have collected data \n    points where each data point is a tuple containing the day of the year and the temperature recorded \n    on that day. The climatologist wants to find the length of the longest consecutive sequence of days \n    where the temperature strictly increases.\n\n    Parameters:\n    temperature_data (List[Tuple[int, int]]): A list of tuples where each tuple contains (day, temperature).\n\n    Returns:\n    int: The length of the longest consecutive sequence of days with strictly increasing temperatures.\n\n\n    [EXAMPLES]\n    \n    assert candidate([(1, 0), (2, 1), (3, 2), (4, 1), (5, 2), (6, 3), (7, 4), (8, 3), (9, 4), (10, 5)]) == 4\n    assert candidate([(1, 0), (2, 1), (3, 2), (4, 3), (5, 4), (6, 5), (7, 6), (8, 7), (9, 8), (10, 9), (11, 10)]) == 11\n\n    [/EXAMPLES]\n    \"\"\"\n```\n", "entry_point": "analyze_climate_patterns", "solution": "from typing import List, Tuple\n\ndef analyze_climate_patterns(temperature_data: List[Tuple[int, int]]) -> int:\n    \"\"\"\n    A climatologist is studying temperature patterns in a specific region. They have collected data \n    points where each data point is a tuple containing the day of the year and the temperature recorded \n    on that day. The climatologist wants to find the length of the longest consecutive sequence of days \n    where the temperature strictly increases.\n\n    Parameters:\n    temperature_data (List[Tuple[int, int]]): A list of tuples where each tuple contains (day, temperature).\n\n    Returns:\n    int: The length of the longest consecutive sequence of days with strictly increasing temperatures.\n\n\n    [EXAMPLES]\n    \n    assert candidate([(1, 0), (2, 1), (3, 2), (4, 1), (5, 2), (6, 3), (7, 4), (8, 3), (9, 4), (10, 5)]) == 4\n    assert candidate([(1, 0), (2, 1), (3, 2), (4, 3), (5, 4), (6, 5), (7, 6), (8, 7), (9, 8), (10, 9), (11, 10)]) == 11\n\n    [/EXAMPLES]\n    \"\"\"\n    if not temperature_data:\n        return 0\n\n    # Sort the data by day to ensure chronological order\n    sorted_data = sorted(temperature_data, key=lambda x: x[0])\n\n    max_sequence = 1\n    current_sequence = 1\n    prev_temp = sorted_data[0][1]\n\n    for i in range(1, len(sorted_data)):\n        current_day, current_temp = sorted_data[i]\n        prev_day = sorted_data[i-1][0]\n\n        if current_day == prev_day + 1 and current_temp > prev_temp:\n            current_sequence += 1\n        else:\n            max_sequence = max(max_sequence, current_sequence)\n            current_sequence = 1\n\n        prev_temp = current_temp\n\n    # Check one last time in case the longest sequence ends at the last element\n    max_sequence = max(max_sequence, current_sequence)\n\n    return max_sequence\n\n", "test": "def check(candidate):\n    assert candidate([(1, 20), (2, 21), (3, 22), (4, 23), (5, 22), (6, 23), (7, 24), (8, 25), (9, 26), (10, 27)]) == 6\n    assert candidate([(1, 25), (2, 26), (3, 27), (4, 28), (5, 29), (6, 30), (7, 31)]) == 7\n    assert candidate([(1, 15), (2, 14), (3, 13), (4, 12), (5, 11), (6, 10), (7, 9), (8, 8), (9, 7), (10, 6)]) == 1\n    assert candidate([(1, 100), (2, 101), (3, 102), (4, 103), (5, 104), (6, 105), (7, 106), (8, 107), (9, 108), (10, 109)]) == 10\n    assert candidate([(1, 0), (2, 1), (3, 2), (4, 3), (5, 4), (6, 5), (7, 6), (8, 7), (9, 8), (10, 9), (11, 10)]) == 11\n    assert candidate([(1, 20), (2, 21), (3, 22), (4, 23), (5, 24), (6, 25), (7, 26), (8, 27), (9, 28), (10, 29)]) == 10\n    assert candidate([(1, 1), (2, 2), (3, 3), (4, 4), (5, 5), (6, 4), (7, 3), (8, 2), (9, 1)]) == 5\n    assert candidate([(1, 50), (2, 51), (3, 52), (4, 53), (5, 54), (6, 55), (7, 56), (8, 57), (9, 58), (10, 59)]) == 10\n    assert candidate([(1, 5), (2, 6), (3, 7), (4, 8), (5, 9), (6, 10), (7, 11), (8, 12), (9, 13)]) == 9\n    assert candidate([(1, 0), (2, 1), (3, 2), (4, 1), (5, 2), (6, 3), (7, 4), (8, 3), (9, 4), (10, 5)]) == 4\n", "language": "python"}
{"task_id": "35763e9d-4bcf-42b0-a8ad-5255973fad0f-2532884426628213422", "prompt": "I'll serve as your coding assistant by completing functions that are ready to execute. My solutions will remain within the function's scope, use only the imported libraries, and include any necessary helper functions or classes within the main function definition.\n\n```python\nfrom typing import List\n\ndef calculate_water_flow(landscape: List[int]) -> int:\n    \"\"\"\n    You are given an array of non-negative integers representing the height of walls on a 2D landscape. Imagine water\n    is poured over the entire landscape. Calculate the total volume of water that would be trapped between the walls\n    after the rainfall.\n\n    Each integer in the input list represents the height of a wall, and the width of each wall is 1 unit.\n\n\n    [EXAMPLES]\n    \n    assert candidate([5, 4, 3, 2, 1]) == 0\n    assert candidate([3, 0, 2, 0, 4]) == 7\n\n    [/EXAMPLES]\n    \"\"\"\n```\n", "entry_point": "calculate_water_flow", "solution": "from typing import List\n\ndef calculate_water_flow(landscape: List[int]) -> int:\n    \"\"\"\n    You are given an array of non-negative integers representing the height of walls on a 2D landscape. Imagine water\n    is poured over the entire landscape. Calculate the total volume of water that would be trapped between the walls\n    after the rainfall.\n\n    Each integer in the input list represents the height of a wall, and the width of each wall is 1 unit.\n\n\n    [EXAMPLES]\n    \n    assert candidate([5, 4, 3, 2, 1]) == 0\n    assert candidate([3, 0, 2, 0, 4]) == 7\n\n    [/EXAMPLES]\n    \"\"\"\n    if not landscape:\n        return 0\n\n    n = len(landscape)\n    left_max = [0] * n\n    right_max = [0] * n\n    \n    # Calculate maximum height to the left of each position\n    left_max[0] = landscape[0]\n    for i in range(1, n):\n        left_max[i] = max(left_max[i-1], landscape[i])\n    \n    # Calculate maximum height to the right of each position\n    right_max[-1] = landscape[-1]\n    for i in range(n-2, -1, -1):\n        right_max[i] = max(right_max[i+1], landscape[i])\n    \n    # Calculate water trapped at each position and sum it up\n    total_water = 0\n    for i in range(n):\n        water_level = min(left_max[i], right_max[i])\n        if water_level > landscape[i]:\n            total_water += water_level - landscape[i]\n    \n    return total_water\n\n", "test": "def check(candidate):\n    assert candidate([5, 4, 3, 2, 1]) == 0\n    assert candidate([5, 2, 1, 2, 1, 5]) == 14\n    assert candidate([1, 1, 1, 1, 1]) == 0\n    assert candidate([1, 0, 1]) == 1\n    assert candidate([3, 0, 2, 0, 4]) == 7\n    assert candidate([3, 3, 3, 3]) == 0\n    assert candidate([1, 2, 3, 4, 5]) == 0\n    assert candidate([9, 6, 8, 8, 5, 6, 3]) == 3\n    assert candidate([]) == 0\n    assert candidate([1]) == 0\n", "language": "python"}
{"task_id": "87fe1380-8880-4fe5-aa73-41795eaa71f8-8650225366231490660", "prompt": "The code below requires completion. I'll provide the full solution in one code block, with any additional functions or classes defined inside the main function.\n\n```python\nfrom typing import List, Tuple\n\ndef optimize_crop_rotation(field_sizes: List[int], crop_yields: List[Tuple[str, float]]) -> List[str]:\n    \"\"\"\n    A farmer wants to optimize crop rotation for maximum yield across multiple fields.\n    Given the sizes of different fields and the expected yields of various crops,\n    determine the best crop to plant in each field for the upcoming season.\n\n    Parameters:\n    field_sizes (List[int]): A list of field sizes in acres\n    crop_yields (List[Tuple[str, float]]): A list of tuples containing crop names and their expected yields per acre\n\n    Returns:\n    List[str]: A list of crop names representing the optimal crop for each field\n\n\n    [EXAMPLES]\n    \n    assert candidate([1, 10, 100], [('lavender', 4.0), ('chamomile', 3.5), ('peppermint', 3.8)]) == ['lavender', 'lavender', 'lavender']\n    assert candidate([5, 10, 15], [('rice', 4.0), ('wheat', 2.5), ('barley', 3.0)]) == ['rice', 'rice', 'rice']\n\n    [/EXAMPLES]\n    \"\"\"\n```\n", "entry_point": "optimize_crop_rotation", "solution": "from typing import List, Tuple\n\ndef optimize_crop_rotation(field_sizes: List[int], crop_yields: List[Tuple[str, float]]) -> List[str]:\n    \"\"\"\n    A farmer wants to optimize crop rotation for maximum yield across multiple fields.\n    Given the sizes of different fields and the expected yields of various crops,\n    determine the best crop to plant in each field for the upcoming season.\n\n    Parameters:\n    field_sizes (List[int]): A list of field sizes in acres\n    crop_yields (List[Tuple[str, float]]): A list of tuples containing crop names and their expected yields per acre\n\n    Returns:\n    List[str]: A list of crop names representing the optimal crop for each field\n\n\n    [EXAMPLES]\n    \n    assert candidate([1, 10, 100], [('lavender', 4.0), ('chamomile', 3.5), ('peppermint', 3.8)]) == ['lavender', 'lavender', 'lavender']\n    assert candidate([5, 10, 15], [('rice', 4.0), ('wheat', 2.5), ('barley', 3.0)]) == ['rice', 'rice', 'rice']\n\n    [/EXAMPLES]\n    \"\"\"\n    # Sort crop_yields by yield in descending order\n    sorted_crops = sorted(crop_yields, key=lambda x: x[1], reverse=True)\n    \n    # Initialize the result list\n    optimal_crops = []\n    \n    # For each field, choose the crop with the highest yield\n    for field_size in field_sizes:\n        optimal_crops.append(sorted_crops[0][0])\n    \n    return optimal_crops\n\n", "test": "def check(candidate):\n    assert candidate([1000], [('sugarcane', 8.0)]) == ['sugarcane']\n    assert candidate([1, 10, 100], [('lavender', 4.0), ('chamomile', 3.5), ('peppermint', 3.8)]) == ['lavender', 'lavender', 'lavender']\n    assert candidate([100, 200], [('alfalfa', 4.5), ('clover', 4.0)]) == ['alfalfa', 'alfalfa']\n    assert candidate([10, 20], [('corn', 3.0), ('soybeans', 2.5)]) == ['corn', 'corn']\n    assert candidate([5, 5, 5, 5, 5], [('cotton', 1.5), ('peanuts', 2.0), ('tobacco', 2.2), ('sunflowers', 1.8), ('flax', 1.6)]) == ['tobacco', 'tobacco', 'tobacco', 'tobacco', 'tobacco']\n    assert candidate([10, 20, 30, 40, 50], [('spinach', 3.5), ('kale', 3.3), ('chard', 3.2), ('collards', 3.4), ('arugula', 3.1)]) == ['spinach', 'spinach', 'spinach', 'spinach', 'spinach']\n    assert candidate([5, 10, 15], [('rice', 4.0), ('wheat', 2.5), ('barley', 3.0)]) == ['rice', 'rice', 'rice']\n    assert candidate([1, 2, 3, 4, 5], [('tomatoes', 6.0), ('peppers', 5.5), ('cucumbers', 5.8), ('eggplants', 5.2), ('zucchini', 5.7)]) == ['tomatoes', 'tomatoes', 'tomatoes', 'tomatoes', 'tomatoes']\n    assert candidate([1000, 2000, 3000], [('hemp', 3.0), ('flax', 2.5), ('jute', 2.8)]) == ['hemp', 'hemp', 'hemp']\n    assert candidate([1, 10, 100, 1000], [('quinoa', 2.0), ('amaranth', 1.8), ('buckwheat', 1.5), ('millet', 1.7)]) == ['quinoa', 'quinoa', 'quinoa', 'quinoa']\n", "language": "python"}
{"task_id": "814282bc-d11f-41c1-9799-3b0abe19e4b61619459327151505332", "prompt": "Please provide a function that is fully executable. The function should be self-contained within a single code block. Only use libraries that are imported in the problem statement. Any additional helper functions or classes should be defined inside the main function.\n\n```python\ndef compress_string(text: str) -> str:\n    \"\"\"\n    A data compression algorithm needs to compress strings by replacing consecutive\n    repeated characters with the character followed by the count of repetitions.\n    Single occurrences should not be followed by a count.\n\n    Parameters:\n    text (str): The string to be compressed.\n\n    Returns:\n    str: The compressed string.\n\n\n    [EXAMPLES]\n    \n    assert candidate(\"AABBCCDDEE\") == 'A2B2C2D2E2'\n    assert candidate(\"AABAA\") == 'A2BA2'\n\n    [/EXAMPLES]\n    \"\"\"\n```\n", "entry_point": "compress_string", "solution": "def compress_string(text: str) -> str:\n    \"\"\"\n    A data compression algorithm needs to compress strings by replacing consecutive\n    repeated characters with the character followed by the count of repetitions.\n    Single occurrences should not be followed by a count.\n\n    Parameters:\n    text (str): The string to be compressed.\n\n    Returns:\n    str: The compressed string.\n\n\n    [EXAMPLES]\n    \n    assert candidate(\"AABBCCDDEE\") == 'A2B2C2D2E2'\n    assert candidate(\"AABAA\") == 'A2BA2'\n\n    [/EXAMPLES]\n    \"\"\"\n    if not text:\n        return \"\"\n\n    compressed = []\n    count = 1\n    current_char = text[0]\n\n    for char in text[1:]:\n        if char == current_char:\n            count += 1\n        else:\n            compressed.append(current_char)\n            if count > 1:\n                compressed.append(str(count))\n            current_char = char\n            count = 1\n\n    compressed.append(current_char)\n    if count > 1:\n        compressed.append(str(count))\n\n    return ''.join(compressed)\n\n", "test": "def check(candidate):\n    assert candidate(\"AA\") == 'A2'\n    assert candidate(\"A \" * 10) == 'A A A A A A A A A A '\n    assert candidate(\"AABAA\") == 'A2BA2'\n    assert candidate(\"A\" * 100) == 'A100'\n    assert candidate(\"AABBCCDDEE\") == 'A2B2C2D2E2'\n    assert candidate(\"ZZZZZ\") == 'Z5'\n    assert candidate(\"a1b2c3d4e5\") == 'a1b2c3d4e5'\n    assert candidate(\"AAABBBCCCDDD\") == 'A3B3C3D3'\n    assert candidate(\"AABBCCAABBCC\") == 'A2B2C2A2B2C2'\n    assert candidate(\"AAAABCCCDDEEEE\") == 'A4BC3D2E4'\n", "language": "python"}
{"task_id": "cf98a21f-5dc8-4971-98a7-b6f817513c2d8617653179103558394", "prompt": "Please implement the function as described in the docstring. Provide the complete code in one block.\n\n```python\ndef calculate_delivery_time(orders: list, n_drivers: int) -> int:\n    \"\"\"A food delivery company wants to optimize its delivery process. They have a list of orders,\n    where each order is represented by the time it takes to complete (in minutes). The company has\n    a fixed number of drivers available.\n\n    Your task is to write a function that calculates the minimum time it will take to complete all\n    orders. Each driver can only handle one order at a time, and they start the next order as soon\n    as they finish their current one.\n\n\n    [EXAMPLES]\n    \n    assert candidate([5, 5, 5, 5, 5, 5], 3) == 10\n    assert candidate([60, 60, 60, 60], 2) == 120\n\n    [/EXAMPLES]\n    \"\"\"\n```\n", "entry_point": "calculate_delivery_time", "solution": "def calculate_delivery_time(orders: list, n_drivers: int) -> int:\n    \"\"\"A food delivery company wants to optimize its delivery process. They have a list of orders,\n    where each order is represented by the time it takes to complete (in minutes). The company has\n    a fixed number of drivers available.\n\n    Your task is to write a function that calculates the minimum time it will take to complete all\n    orders. Each driver can only handle one order at a time, and they start the next order as soon\n    as they finish their current one.\n\n\n    [EXAMPLES]\n    \n    assert candidate([5, 5, 5, 5, 5, 5], 3) == 10\n    assert candidate([60, 60, 60, 60], 2) == 120\n\n    [/EXAMPLES]\n    \"\"\"\n    import heapq\n\n    if not orders or n_drivers <= 0:\n        return 0\n\n    # Initialize a min heap with n_drivers elements, all set to 0\n    drivers = [0] * n_drivers\n    heapq.heapify(drivers)\n\n    # Iterate through all orders\n    for order in orders:\n        # Get the driver with the earliest available time\n        earliest_available = heapq.heappop(drivers)\n        # Assign the order to this driver and update their available time\n        heapq.heappush(drivers, earliest_available + order)\n\n    # The total time is the maximum time among all drivers\n    return max(drivers)\n\n", "test": "def check(candidate):\n    assert candidate([1, 2, 3, 4, 5], 1) == 15\n    assert candidate([30, 20, 10, 40, 50], 3) == 70\n    assert candidate([1, 2, 3, 4, 5, 6, 7, 8, 9, 10], 3) == 22\n    assert candidate([10, 20, 30, 40, 50, 60, 70, 80, 90, 100], 5) == 150\n    assert candidate([5, 5, 5, 5, 5, 5], 3) == 10\n    assert candidate([1, 10, 100, 1000], 2) == 1010\n    assert candidate([100, 200, 300, 400, 500], 5) == 500\n    assert candidate([10, 20, 30], 1) == 60\n    assert candidate([60, 60, 60, 60], 2) == 120\n    assert candidate([50, 50, 50, 50], 1) == 200\n", "language": "python"}
{"task_id": "ccb3a3ae-42fc-4c28-b327-63d2e804a61c-6405096843221861445", "prompt": "Based on the provided doc string, implement the rest of the function in a complete code block. Be thorough in handling edge cases.\n\n```python\nfrom typing import List\n\ndef calculate_genetics_similarity(dna_sequence1: str, dna_sequence2: str) -> float:\n    \"\"\"\n    Calculate the genetic similarity between two DNA sequences using a simple matching coefficient.\n\n    This function compares two DNA sequences and calculates their similarity based on the proportion\n    of matching nucleotides at each position. The similarity score ranges from 0 (completely different)\n    to 1 (identical sequences).\n\n    Args:\n    dna_sequence1 (str): The first DNA sequence, consisting of A, C, G, and T.\n    dna_sequence2 (str): The second DNA sequence, consisting of A, C, G, and T.\n\n    Returns:\n    float: The similarity score between the two DNA sequences.\n\n\n    [EXAMPLES]\n    \n    assert candidate(\"GCTA\", \"GCTA\") == 1.0\n    assert candidate(\"ATCG\", \"TACG\") == 0.5\n\n    [/EXAMPLES]\n    \"\"\"\n```\n", "entry_point": "calculate_genetics_similarity", "solution": "from typing import List\n\ndef calculate_genetics_similarity(dna_sequence1: str, dna_sequence2: str) -> float:\n    \"\"\"\n    Calculate the genetic similarity between two DNA sequences using a simple matching coefficient.\n\n    This function compares two DNA sequences and calculates their similarity based on the proportion\n    of matching nucleotides at each position. The similarity score ranges from 0 (completely different)\n    to 1 (identical sequences).\n\n    Args:\n    dna_sequence1 (str): The first DNA sequence, consisting of A, C, G, and T.\n    dna_sequence2 (str): The second DNA sequence, consisting of A, C, G, and T.\n\n    Returns:\n    float: The similarity score between the two DNA sequences.\n\n\n    [EXAMPLES]\n    \n    assert candidate(\"GCTA\", \"GCTA\") == 1.0\n    assert candidate(\"ATCG\", \"TACG\") == 0.5\n\n    [/EXAMPLES]\n    \"\"\"\n    # Check if the sequences have the same length\n    if len(dna_sequence1) != len(dna_sequence2):\n        raise ValueError(\"DNA sequences must have the same length\")\n\n    # Initialize the count of matching nucleotides\n    matching_count = 0\n\n    # Compare nucleotides at each position\n    for nucleotide1, nucleotide2 in zip(dna_sequence1, dna_sequence2):\n        if nucleotide1 == nucleotide2:\n            matching_count += 1\n\n    # Calculate the similarity score\n    similarity_score = matching_count / len(dna_sequence1)\n\n    return similarity_score\n\n", "test": "def check(candidate):\n    assert candidate(\"GCTA\", \"GCTA\") == 1.0\n    assert candidate(\"CGCGCGCG\", \"GCGCGCGC\") == 0.0\n    assert candidate(\"ATCG\", \"ATCG\") == 1.0\n    assert candidate(\"GCTA\", \"CGAT\") == 0.0\n    assert candidate(\"ATCGATCG\", \"ATCGATCG\") == 1.0\n    assert candidate(\"GATTACA\", \"GATTACA\") == 1.0\n    assert candidate(\"ATCGATCGATCG\", \"ATCGATCGATCG\") == 1.0\n    assert candidate(\"AAAA\", \"TTTT\") == 0.0\n    assert candidate(\"ATCG\", \"TACG\") == 0.5\n    assert candidate(\"AAATTTCCCGGG\", \"GGGCCCTTTTAA\") == 0.0\n", "language": "python"}
{"task_id": "e84ec5ca-68e6-4e82-ac31-61534b6d30a56001972111395625725", "prompt": "I'll finish the function according to the documentation. Please provide the full function in a single code block.\n\n```python\nfrom typing import List\n\ndef earthquake_damage(magnitudes: List[float], distances: List[float]) -> float:\n    \"\"\"\n    Calculate the total potential damage caused by multiple earthquakes in a region.\n\n    This function takes two lists as input: earthquake magnitudes and their corresponding\n    distances from a central point. It uses the concepts of exponential growth and\n    inverse square law to estimate the cumulative damage.\n\n    The damage for each earthquake is calculated as:\n    damage = (10 ** magnitude) / (distance ** 2)\n\n    The total damage is the sum of individual damages.\n\n    Args:\n    magnitudes (List[float]): A list of earthquake magnitudes on the Richter scale.\n    distances (List[float]): A list of distances (in km) from a central point.\n\n    Returns:\n    float: The total calculated damage potential.\n\n\n    [EXAMPLES]\n    \n    assert candidate([5.0], [10]) == 1000.0\n    assert candidate([0.0], [1]) == 1.0\n\n    [/EXAMPLES]\n    \"\"\"\n```\n", "entry_point": "earthquake_damage", "solution": "from typing import List\n\ndef earthquake_damage(magnitudes: List[float], distances: List[float]) -> float:\n    \"\"\"\n    Calculate the total potential damage caused by multiple earthquakes in a region.\n\n    This function takes two lists as input: earthquake magnitudes and their corresponding\n    distances from a central point. It uses the concepts of exponential growth and\n    inverse square law to estimate the cumulative damage.\n\n    The damage for each earthquake is calculated as:\n    damage = (10 ** magnitude) / (distance ** 2)\n\n    The total damage is the sum of individual damages.\n\n    Args:\n    magnitudes (List[float]): A list of earthquake magnitudes on the Richter scale.\n    distances (List[float]): A list of distances (in km) from a central point.\n\n    Returns:\n    float: The total calculated damage potential.\n\n\n    [EXAMPLES]\n    \n    assert candidate([5.0], [10]) == 1000.0\n    assert candidate([0.0], [1]) == 1.0\n\n    [/EXAMPLES]\n    \"\"\"\n    # Check if the input lists have the same length\n    if len(magnitudes) != len(distances):\n        raise ValueError(\"The magnitudes and distances lists must have the same length.\")\n\n    # Calculate the damage for each earthquake and sum them up\n    total_damage = sum((10 ** magnitude) / (distance ** 2) \n                       for magnitude, distance in zip(magnitudes, distances))\n\n    return total_damage\n\n", "test": "def check(candidate):\n    assert candidate([6.0, 6.0, 6.0], [10, 20, 30]) == 13611.111111111111\n    assert candidate([0.0], [1]) == 1.0\n    assert candidate([3.0, 4.0, 5.0, 6.0, 7.0, 8.0], [1, 10, 100, 1000, 10000, 100000]) == 1111.11\n    assert candidate([4.2, 4.4, 4.6, 4.8, 5.0, 5.2], [5, 10, 15, 20, 25, 30]) == 1555.9210201082412\n    assert candidate([7.2, 6.9, 7.1, 7.0], [80, 90, 100, 110]) == 5542.4194476413095\n    assert candidate([1.0], [0.1]) == 999.9999999999998\n    assert candidate([5.5, 5.5, 5.5, 5.5], [5, 10, 15, 20]) == 18007.4144537366\n    assert candidate([3.0, 3.5, 4.0, 4.5, 5.0], [1, 2, 3, 4, 5]) == 8878.104063758443\n    assert candidate([5.0], [10]) == 1000.0\n    assert candidate([7.0, 6.5, 6.8, 5.9], [100, 50, 75, 25]) == 4657.538185368769\n", "language": "python"}
{"task_id": "1fe6a723-2c80-42bb-93ad-8e909a7481d3-7274565430740855387", "prompt": "Implement the remaining portion of the function according to its documentation. Include your solution in one code block and ensure you've considered all potential edge cases.\n\n```python\ndef calculate_population_growth(initial: int, growth_rate: float, years: int) -> int:\n    \"\"\"\n    Predict the population size after a given number of years using exponential growth.\n\n    This function calculates the future population size based on the initial population,\n    annual growth rate, and the number of years into the future.\n\n    Parameters:\n    initial (int): The initial population size\n    growth_rate (float): The annual growth rate as a decimal (e.g., 0.03 for 3% growth)\n    years (int): The number of years to project into the future\n\n    Returns:\n    int: The predicted population size, rounded to the nearest integer\n\n\n    [EXAMPLES]\n    \n    assert candidate(50, 0.5, 3) == 169\n    assert candidate(10, 2.0, 8) == 65610\n\n    [/EXAMPLES]\n    \"\"\"\n```\n", "entry_point": "calculate_population_growth", "solution": "def calculate_population_growth(initial: int, growth_rate: float, years: int) -> int:\n    \"\"\"\n    Predict the population size after a given number of years using exponential growth.\n\n    This function calculates the future population size based on the initial population,\n    annual growth rate, and the number of years into the future.\n\n    Parameters:\n    initial (int): The initial population size\n    growth_rate (float): The annual growth rate as a decimal (e.g., 0.03 for 3% growth)\n    years (int): The number of years to project into the future\n\n    Returns:\n    int: The predicted population size, rounded to the nearest integer\n\n\n    [EXAMPLES]\n    \n    assert candidate(50, 0.5, 3) == 169\n    assert candidate(10, 2.0, 8) == 65610\n\n    [/EXAMPLES]\n    \"\"\"\n    # Calculate the future population using the exponential growth formula\n    future_population = initial * (1 + growth_rate) ** years\n    \n    # Round the result to the nearest integer\n    return round(future_population)\n\n", "test": "def check(candidate):\n    assert candidate(10, 2.0, 8) == 65610\n    assert candidate(5000000, 0.015, 25) == 7254727\n    assert candidate(1000000, 0.1, 1) == 1100000\n    assert candidate(10000, -0.05, 15) == 4633\n    assert candidate(5000, -0.99, 5) == 0\n    assert candidate(50, 0.5, 3) == 169\n    assert candidate(1000000000, -0.01, 40) == 668971759\n    assert candidate(9999, 0.0001, 1000) == 11051\n    assert candidate(1234567, 0.0555, 12) == 2360552\n    assert candidate(8000000000, -0.005, 20) == 7236883842\n", "language": "python"}
{"task_id": "8294ebf0-26f7-4070-8ebe-4a18c702fd41-6692410987209228656", "prompt": "Please complete the provided function so that it can be executed as-is within a single code block. Don't add any code outside the function boundaries. Only utilize the libraries that were imported in the problem statement. If you need to create auxiliary functions or classes, include them inside the main function.\n\n```python\nfrom typing import List, Tuple\n\ndef optimize_study_schedule(subjects: List[Tuple[str, int, int]]) -> List[str]:\n    \"\"\"\n    As a student preparing for exams, you want to create an optimal study schedule. You have a list of subjects, each with a name, the number of hours needed to study it, and its importance (1-10).\n\n    Your goal is to create a schedule that maximizes the total importance of the subjects you can study within a 24-hour period.\n\n    Each subject is represented by a tuple: (name, hours_needed, importance)\n\n    Return a list of subject names in the order they should be studied.\n\n\n    [EXAMPLES]\n    \n    assert candidate([(\"A\", 24, 1), (\"B\", 1, 10)]) == ['B']\n    assert candidate([(\"A\", 5, 10), (\"B\", 5, 9), (\"C\", 5, 8), (\"D\", 5, 7), (\"E\", 5, 6)]) == ['A', 'B', 'C', 'D']\n\n    [/EXAMPLES]\n    \"\"\"\n```\n", "entry_point": "optimize_study_schedule", "solution": "from typing import List, Tuple\n\ndef optimize_study_schedule(subjects: List[Tuple[str, int, int]]) -> List[str]:\n    \"\"\"\n    As a student preparing for exams, you want to create an optimal study schedule. You have a list of subjects, each with a name, the number of hours needed to study it, and its importance (1-10).\n\n    Your goal is to create a schedule that maximizes the total importance of the subjects you can study within a 24-hour period.\n\n    Each subject is represented by a tuple: (name, hours_needed, importance)\n\n    Return a list of subject names in the order they should be studied.\n\n\n    [EXAMPLES]\n    \n    assert candidate([(\"A\", 24, 1), (\"B\", 1, 10)]) == ['B']\n    assert candidate([(\"A\", 5, 10), (\"B\", 5, 9), (\"C\", 5, 8), (\"D\", 5, 7), (\"E\", 5, 6)]) == ['A', 'B', 'C', 'D']\n\n    [/EXAMPLES]\n    \"\"\"\n    # Sort subjects by importance-to-time ratio in descending order\n    sorted_subjects = sorted(subjects, key=lambda x: x[2] / x[1], reverse=True)\n    \n    schedule = []\n    total_hours = 0\n    \n    for subject in sorted_subjects:\n        name, hours, importance = subject\n        if total_hours + hours <= 24:\n            schedule.append(name)\n            total_hours += hours\n        else:\n            break\n    \n    return schedule\n\n", "test": "def check(candidate):\n    assert candidate([(\"Easy\", 1, 1), (\"Medium\", 2, 5), (\"Hard\", 3, 10)]) == ['Hard', 'Medium', 'Easy']\n    assert candidate([(\"A\", 8, 10), (\"B\", 8, 10), (\"C\", 8, 10)]) == ['A', 'B', 'C']\n    assert candidate([]) == []\n    assert candidate([(\"Z\", 1, 1)] * 25) == ['Z', 'Z', 'Z', 'Z', 'Z', 'Z', 'Z', 'Z', 'Z', 'Z', 'Z', 'Z', 'Z', 'Z', 'Z', 'Z', 'Z', 'Z', 'Z', 'Z', 'Z', 'Z', 'Z', 'Z']\n    assert candidate([(\"A\", 24, 1), (\"B\", 1, 10)]) == ['B']\n    assert candidate([(\"A\", 5, 10), (\"B\", 5, 9), (\"C\", 5, 8), (\"D\", 5, 7), (\"E\", 5, 6)]) == ['A', 'B', 'C', 'D']\n    assert candidate([(\"Y\", 25, 10)]) == []\n    assert candidate([(\"Subject1\", 23, 5), (\"Subject2\", 1, 10)]) == ['Subject2', 'Subject1']\n    assert candidate([(\"Hard\", 23, 10), (\"Easy\", 1, 1)]) == ['Easy', 'Hard']\n    assert candidate([(\"Short\", 1, 1), (\"Long\", 23, 10)]) == ['Short', 'Long']\n", "language": "python"}
{"task_id": "aede681a-4cb7-468e-a782-ea4dfc3a7215881577343772322940", "prompt": "I'm your coding assistant. I'll complete the given function to make it executable as-is within a code block. I'll only use libraries that are imported in the problem statement. Any supporting functions or classes needed will be defined inside the main function. No code will appear outside the function boundaries.\n\n```python\nfrom typing import List\n\ndef sequence_encoder(sequence: List[int]) -> int:\n    \"\"\"\n    You are working on a DNA sequencing project and need to encode genetic sequences.\n    Given a list of integers representing a genetic sequence, encode it into a single integer.\n    The encoding process is as follows:\n    1. Start with the first number in the sequence.\n    2. For each subsequent number, multiply the current result by 10 and add the new number.\n    3. If the current number is 0, instead of adding, subtract 5 from the result.\n    4. If the result becomes negative at any point, reset it to 0.\n    Return the final encoded integer.\n\n\n    [EXAMPLES]\n    \n    assert candidate([5, 5, 5, 5, 0]) == 55545\n    assert candidate([9, 0, 9, 0, 9, 0, 9, 0, 9, 0]) == 8585858585\n\n    [/EXAMPLES]\n    \"\"\"\n```\n", "entry_point": "sequence_encoder", "solution": "from typing import List\n\ndef sequence_encoder(sequence: List[int]) -> int:\n    \"\"\"\n    You are working on a DNA sequencing project and need to encode genetic sequences.\n    Given a list of integers representing a genetic sequence, encode it into a single integer.\n    The encoding process is as follows:\n    1. Start with the first number in the sequence.\n    2. For each subsequent number, multiply the current result by 10 and add the new number.\n    3. If the current number is 0, instead of adding, subtract 5 from the result.\n    4. If the result becomes negative at any point, reset it to 0.\n    Return the final encoded integer.\n\n\n    [EXAMPLES]\n    \n    assert candidate([5, 5, 5, 5, 0]) == 55545\n    assert candidate([9, 0, 9, 0, 9, 0, 9, 0, 9, 0]) == 8585858585\n\n    [/EXAMPLES]\n    \"\"\"\n    if not sequence:\n        return 0\n    \n    result = sequence[0]\n    \n    for num in sequence[1:]:\n        result *= 10\n        if num == 0:\n            result -= 5\n        else:\n            result += num\n        \n        if result < 0:\n            result = 0\n    \n    return result\n\n", "test": "def check(candidate):\n    assert candidate([1]) == 1\n    assert candidate([5, 5, 5, 5, 0]) == 55545\n    assert candidate([9, 9, 9, 9, 9]) == 99999\n    assert candidate([0, 0, 0, 0, 0]) == 0\n    assert candidate([9, 8, 7, 6, 5, 4, 3, 2, 1, 0]) == 9876543205\n    assert candidate([1, 1, 1, 1, 1, 1, 1, 1, 1, 1]) == 1111111111\n    assert candidate([9, 0, 9, 0, 9, 0, 9, 0, 9, 0]) == 8585858585\n    assert candidate([1, 0, 1, 0, 1]) == 5051\n    assert candidate([1, 2, 0, 3, 4]) == 11534\n    assert candidate([0, 1, 0, 2, 0, 3, 0, 4, 0, 5]) == 51525355\n", "language": "python"}
{"task_id": "b12c1dda-22b4-4c58-995e-ba7b2fa1997d5830650633432825081", "prompt": "Working as a coding assistant, you'll complete the given function to make it fully executable. Use exclusively the libraries that are imported in the problem. Any additional functionality should be defined inside the main function. Deliver only the completed function in a code block.\n\n```python\nfrom typing import List, Tuple\n\ndef analyze_stock_market(prices: List[int]) -> Tuple[int, int, int]:\n    \"\"\"\n    As a financial analyst, you're tasked with analyzing a stock's price history to determine the best days to buy and sell for maximum profit. You're given a list of stock prices, where the i-th element represents the price on the i-th day. Your goal is to find the maximum profit you can achieve by buying on one day and selling on a later day.\n\n    This function should return a tuple containing three integers: the maximum profit possible, the best day to buy, and the best day to sell. If no profit can be made, return (0, -1, -1).\n\n    Note: You must buy before you sell, and you cannot buy and sell on the same day.\n\n\n    [EXAMPLES]\n    \n    assert candidate([1,2,1,2,1]) == (1, 0, 1)\n    assert candidate([7,1,5,3,6,4]) == (5, 1, 4)\n\n    [/EXAMPLES]\n    \"\"\"\n```\n", "entry_point": "analyze_stock_market", "solution": "from typing import List, Tuple\n\ndef analyze_stock_market(prices: List[int]) -> Tuple[int, int, int]:\n    \"\"\"\n    As a financial analyst, you're tasked with analyzing a stock's price history to determine the best days to buy and sell for maximum profit. You're given a list of stock prices, where the i-th element represents the price on the i-th day. Your goal is to find the maximum profit you can achieve by buying on one day and selling on a later day.\n\n    This function should return a tuple containing three integers: the maximum profit possible, the best day to buy, and the best day to sell. If no profit can be made, return (0, -1, -1).\n\n    Note: You must buy before you sell, and you cannot buy and sell on the same day.\n\n\n    [EXAMPLES]\n    \n    assert candidate([1,2,1,2,1]) == (1, 0, 1)\n    assert candidate([7,1,5,3,6,4]) == (5, 1, 4)\n\n    [/EXAMPLES]\n    \"\"\"\n    if len(prices) < 2:\n        return (0, -1, -1)\n\n    max_profit = 0\n    best_buy_day = -1\n    best_sell_day = -1\n    min_price = float('inf')\n    min_price_day = 0\n\n    for current_day, price in enumerate(prices):\n        if price < min_price:\n            min_price = price\n            min_price_day = current_day\n        \n        current_profit = price - min_price\n        if current_profit > max_profit:\n            max_profit = current_profit\n            best_buy_day = min_price_day\n            best_sell_day = current_day\n\n    if max_profit == 0:\n        return (0, -1, -1)\n    else:\n        return (max_profit, best_buy_day, best_sell_day)\n\n", "test": "def check(candidate):\n    assert candidate([0,1,0,1,0,1,0,1,0,1]) == (1, 0, 1)\n    assert candidate([1,2,1,2,1]) == (1, 0, 1)\n    assert candidate([100]) == (0, -1, -1)\n    assert candidate([5,5,5,5,5,5,5,5,5,5]) == (0, -1, -1)\n    assert candidate([1,2,3,4,5]) == (4, 0, 4)\n    assert candidate([7,1,5,3,6,4]) == (5, 1, 4)\n    assert candidate([10,9,8,7,6,5,4,3,2,1,0]) == (0, -1, -1)\n    assert candidate([1,2,3,4,5,4,3,2,1]) == (4, 0, 4)\n    assert candidate([5,4,3,2,1]) == (0, -1, -1)\n    assert candidate([1,2]) == (1, 0, 1)\n", "language": "python"}
{"task_id": "78c1993d-9883-45e4-a895-17fa65b05867-3100019026524457312", "prompt": "I'll provide a complete, executable function. The entire function will be in one code block without any surrounding code. I'll only use libraries that are imported in the problem statement and define any helper functions within the main function.\n\n```python\ndef calculate_asteroid_impact(mass: float, velocity: float, angle: float) -> float:\n    \"\"\"\n    An astrophysicist is studying the potential impact of asteroids on Earth.\n    This function calculates the energy released upon impact based on the\n    asteroid's mass (in kg), velocity (in m/s), and angle of entry (in degrees).\n\n    The function should use trigonometry to determine the vertical component\n    of the velocity and calculate the impact energy using the kinetic energy\n    formula.\n\n\n    [EXAMPLES]\n    \n    assert candidate(1000, 20000, 45) == 100000000000.0\n    assert candidate(1.5e5, 17000, 35) == 7130856696708.063\n\n    [/EXAMPLES]\n    \"\"\"\n```\n", "entry_point": "calculate_asteroid_impact", "solution": "def calculate_asteroid_impact(mass: float, velocity: float, angle: float) -> float:\n    \"\"\"\n    An astrophysicist is studying the potential impact of asteroids on Earth.\n    This function calculates the energy released upon impact based on the\n    asteroid's mass (in kg), velocity (in m/s), and angle of entry (in degrees).\n\n    The function should use trigonometry to determine the vertical component\n    of the velocity and calculate the impact energy using the kinetic energy\n    formula.\n\n\n    [EXAMPLES]\n    \n    assert candidate(1000, 20000, 45) == 100000000000.0\n    assert candidate(1.5e5, 17000, 35) == 7130856696708.063\n\n    [/EXAMPLES]\n    \"\"\"\n    import math\n\n    # Convert angle from degrees to radians\n    angle_rad = math.radians(angle)\n\n    # Calculate the vertical component of velocity\n    vertical_velocity = velocity * math.sin(angle_rad)\n\n    # Calculate the kinetic energy using the formula: KE = 1/2 * m * v^2\n    impact_energy = 0.5 * mass * (vertical_velocity ** 2)\n\n    return impact_energy\n\n", "test": "def check(candidate):\n    assert candidate(7500, 18000, 75) == 1133610432799.0466\n    assert candidate(4e6, 8000, 55) == 85889289172842.78\n    assert candidate(6e3, 32000, 70) == 2712644264630.7495\n    assert candidate(2e3, 35000, 50) == 718859508820.9949\n    assert candidate(9e1, 45000, 25) == 16275489533.657055\n    assert candidate(100, 50000, 90) == 125000000000.0\n    assert candidate(3e4, 22000, 65) == 5963319023162.137\n    assert candidate(1.5e5, 17000, 35) == 7130856696708.063\n    assert candidate(1000, 20000, 45) == 100000000000.0\n    assert candidate(250, 40000, 10) == 6030737921.409161\n", "language": "python"}
{"task_id": "a3500037-f202-404d-aa3e-e9539d35b9b25974569737782793489", "prompt": "Complete the function based on the documentation string provided. Return a single code block with the implementation.\n\n```python\nfrom typing import List\n\ndef calculate_pascal_triangle(rows: int) -> List[List[int]]:\n    \"\"\"\n    This function generates Pascal's Triangle for a given number of rows.\n    It utilizes dynamic programming to efficiently calculate the values.\n\n    The function takes an integer representing the number of rows to generate.\n    It returns a list of lists, where each inner list represents a row of Pascal's Triangle.\n\n    Pascal's Triangle is a triangular array of the binomial coefficients that arises\n    in probability theory, combinatorics, and algebra. Each number is the sum of the\n    two numbers directly above it.\n\n    This implementation can be used in various mathematical and statistical applications.\n\n\n    [EXAMPLES]\n    \n    assert candidate(7) == [[1], [1, 1], [1, 2, 1], [1, 3, 3, 1], [1, 4, 6, 4, 1], [1, 5, 10, 10, 5, 1], [1, 6, 15, 20, 15, 6, 1]]\n    assert candidate(1) == [[1]]\n\n    [/EXAMPLES]\n    \"\"\"\n```\n", "entry_point": "calculate_pascal_triangle", "solution": "from typing import List\n\ndef calculate_pascal_triangle(rows: int) -> List[List[int]]:\n    \"\"\"\n    This function generates Pascal's Triangle for a given number of rows.\n    It utilizes dynamic programming to efficiently calculate the values.\n\n    The function takes an integer representing the number of rows to generate.\n    It returns a list of lists, where each inner list represents a row of Pascal's Triangle.\n\n    Pascal's Triangle is a triangular array of the binomial coefficients that arises\n    in probability theory, combinatorics, and algebra. Each number is the sum of the\n    two numbers directly above it.\n\n    This implementation can be used in various mathematical and statistical applications.\n\n\n    [EXAMPLES]\n    \n    assert candidate(7) == [[1], [1, 1], [1, 2, 1], [1, 3, 3, 1], [1, 4, 6, 4, 1], [1, 5, 10, 10, 5, 1], [1, 6, 15, 20, 15, 6, 1]]\n    assert candidate(1) == [[1]]\n\n    [/EXAMPLES]\n    \"\"\"\n    if rows <= 0:\n        return []\n\n    # Initialize the triangle with the first row\n    triangle = [[1]]\n\n    # Generate subsequent rows\n    for i in range(1, rows):\n        prev_row = triangle[-1]\n        new_row = [1]  # First element is always 1\n\n        # Calculate middle elements\n        for j in range(1, i):\n            new_row.append(prev_row[j-1] + prev_row[j])\n\n        new_row.append(1)  # Last element is always 1\n        triangle.append(new_row)\n\n    return triangle\n\n", "test": "def check(candidate):\n    assert candidate(4) == [[1], [1, 1], [1, 2, 1], [1, 3, 3, 1]]\n    assert candidate(0) == []\n    assert candidate(25) == [[1], [1, 1], [1, 2, 1], [1, 3, 3, 1], [1, 4, 6, 4, 1], [1, 5, 10, 10, 5, 1], [1, 6, 15, 20, 15, 6, 1], [1, 7, 21, 35, 35, 21, 7, 1], [1, 8, 28, 56, 70, 56, 28, 8, 1], [1, 9, 36, 84, 126, 126, 84, 36, 9, 1], [1, 10, 45, 120, 210, 252, 210, 120, 45, 10, 1], [1, 11, 55, 165, 330, 462, 462, 330, 165, 55, 11, 1], [1, 12, 66, 220, 495, 792, 924, 792, 495, 220, 66, 12, 1], [1, 13, 78, 286, 715, 1287, 1716, 1716, 1287, 715, 286, 78, 13, 1], [1, 14, 91, 364, 1001, 2002, 3003, 3432, 3003, 2002, 1001, 364, 91, 14, 1], [1, 15, 105, 455, 1365, 3003, 5005, 6435, 6435, 5005, 3003, 1365, 455, 105, 15, 1], [1, 16, 120, 560, 1820, 4368, 8008, 11440, 12870, 11440, 8008, 4368, 1820, 560, 120, 16, 1], [1, 17, 136, 680, 2380, 6188, 12376, 19448, 24310, 24310, 19448, 12376, 6188, 2380, 680, 136, 17, 1], [1, 18, 153, 816, 3060, 8568, 18564, 31824, 43758, 48620, 43758, 31824, 18564, 8568, 3060, 816, 153, 18, 1], [1, 19, 171, 969, 3876, 11628, 27132, 50388, 75582, 92378, 92378, 75582, 50388, 27132, 11628, 3876, 969, 171, 19, 1], [1, 20, 190, 1140, 4845, 15504, 38760, 77520, 125970, 167960, 184756, 167960, 125970, 77520, 38760, 15504, 4845, 1140, 190, 20, 1], [1, 21, 210, 1330, 5985, 20349, 54264, 116280, 203490, 293930, 352716, 352716, 293930, 203490, 116280, 54264, 20349, 5985, 1330, 210, 21, 1], [1, 22, 231, 1540, 7315, 26334, 74613, 170544, 319770, 497420, 646646, 705432, 646646, 497420, 319770, 170544, 74613, 26334, 7315, 1540, 231, 22, 1], [1, 23, 253, 1771, 8855, 33649, 100947, 245157, 490314, 817190, 1144066, 1352078, 1352078, 1144066, 817190, 490314, 245157, 100947, 33649, 8855, 1771, 253, 23, 1], [1, 24, 276, 2024, 10626, 42504, 134596, 346104, 735471, 1307504, 1961256, 2496144, 2704156, 2496144, 1961256, 1307504, 735471, 346104, 134596, 42504, 10626, 2024, 276, 24, 1]]\n    assert candidate(20) == [[1], [1, 1], [1, 2, 1], [1, 3, 3, 1], [1, 4, 6, 4, 1], [1, 5, 10, 10, 5, 1], [1, 6, 15, 20, 15, 6, 1], [1, 7, 21, 35, 35, 21, 7, 1], [1, 8, 28, 56, 70, 56, 28, 8, 1], [1, 9, 36, 84, 126, 126, 84, 36, 9, 1], [1, 10, 45, 120, 210, 252, 210, 120, 45, 10, 1], [1, 11, 55, 165, 330, 462, 462, 330, 165, 55, 11, 1], [1, 12, 66, 220, 495, 792, 924, 792, 495, 220, 66, 12, 1], [1, 13, 78, 286, 715, 1287, 1716, 1716, 1287, 715, 286, 78, 13, 1], [1, 14, 91, 364, 1001, 2002, 3003, 3432, 3003, 2002, 1001, 364, 91, 14, 1], [1, 15, 105, 455, 1365, 3003, 5005, 6435, 6435, 5005, 3003, 1365, 455, 105, 15, 1], [1, 16, 120, 560, 1820, 4368, 8008, 11440, 12870, 11440, 8008, 4368, 1820, 560, 120, 16, 1], [1, 17, 136, 680, 2380, 6188, 12376, 19448, 24310, 24310, 19448, 12376, 6188, 2380, 680, 136, 17, 1], [1, 18, 153, 816, 3060, 8568, 18564, 31824, 43758, 48620, 43758, 31824, 18564, 8568, 3060, 816, 153, 18, 1], [1, 19, 171, 969, 3876, 11628, 27132, 50388, 75582, 92378, 92378, 75582, 50388, 27132, 11628, 3876, 969, 171, 19, 1]]\n    assert candidate(3) == [[1], [1, 1], [1, 2, 1]]\n    assert candidate(7) == [[1], [1, 1], [1, 2, 1], [1, 3, 3, 1], [1, 4, 6, 4, 1], [1, 5, 10, 10, 5, 1], [1, 6, 15, 20, 15, 6, 1]]\n    assert candidate(1) == [[1]]\n    assert candidate(6) == [[1], [1, 1], [1, 2, 1], [1, 3, 3, 1], [1, 4, 6, 4, 1], [1, 5, 10, 10, 5, 1]]\n    assert candidate(2) == [[1], [1, 1]]\n    assert candidate(75) == [[1], [1, 1], [1, 2, 1], [1, 3, 3, 1], [1, 4, 6, 4, 1], [1, 5, 10, 10, 5, 1], [1, 6, 15, 20, 15, 6, 1], [1, 7, 21, 35, 35, 21, 7, 1], [1, 8, 28, 56, 70, 56, 28, 8, 1], [1, 9, 36, 84, 126, 126, 84, 36, 9, 1], [1, 10, 45, 120, 210, 252, 210, 120, 45, 10, 1], [1, 11, 55, 165, 330, 462, 462, 330, 165, 55, 11, 1], [1, 12, 66, 220, 495, 792, 924, 792, 495, 220, 66, 12, 1], [1, 13, 78, 286, 715, 1287, 1716, 1716, 1287, 715, 286, 78, 13, 1], [1, 14, 91, 364, 1001, 2002, 3003, 3432, 3003, 2002, 1001, 364, 91, 14, 1], [1, 15, 105, 455, 1365, 3003, 5005, 6435, 6435, 5005, 3003, 1365, 455, 105, 15, 1], [1, 16, 120, 560, 1820, 4368, 8008, 11440, 12870, 11440, 8008, 4368, 1820, 560, 120, 16, 1], [1, 17, 136, 680, 2380, 6188, 12376, 19448, 24310, 24310, 19448, 12376, 6188, 2380, 680, 136, 17, 1], [1, 18, 153, 816, 3060, 8568, 18564, 31824, 43758, 48620, 43758, 31824, 18564, 8568, 3060, 816, 153, 18, 1], [1, 19, 171, 969, 3876, 11628, 27132, 50388, 75582, 92378, 92378, 75582, 50388, 27132, 11628, 3876, 969, 171, 19, 1], [1, 20, 190, 1140, 4845, 15504, 38760, 77520, 125970, 167960, 184756, 167960, 125970, 77520, 38760, 15504, 4845, 1140, 190, 20, 1], [1, 21, 210, 1330, 5985, 20349, 54264, 116280, 203490, 293930, 352716, 352716, 293930, 203490, 116280, 54264, 20349, 5985, 1330, 210, 21, 1], [1, 22, 231, 1540, 7315, 26334, 74613, 170544, 319770, 497420, 646646, 705432, 646646, 497420, 319770, 170544, 74613, 26334, 7315, 1540, 231, 22, 1], [1, 23, 253, 1771, 8855, 33649, 100947, 245157, 490314, 817190, 1144066, 1352078, 1352078, 1144066, 817190, 490314, 245157, 100947, 33649, 8855, 1771, 253, 23, 1], [1, 24, 276, 2024, 10626, 42504, 134596, 346104, 735471, 1307504, 1961256, 2496144, 2704156, 2496144, 1961256, 1307504, 735471, 346104, 134596, 42504, 10626, 2024, 276, 24, 1], [1, 25, 300, 2300, 12650, 53130, 177100, 480700, 1081575, 2042975, 3268760, 4457400, 5200300, 5200300, 4457400, 3268760, 2042975, 1081575, 480700, 177100, 53130, 12650, 2300, 300, 25, 1], [1, 26, 325, 2600, 14950, 65780, 230230, 657800, 1562275, 3124550, 5311735, 7726160, 9657700, 10400600, 9657700, 7726160, 5311735, 3124550, 1562275, 657800, 230230, 65780, 14950, 2600, 325, 26, 1], [1, 27, 351, 2925, 17550, 80730, 296010, 888030, 2220075, 4686825, 8436285, 13037895, 17383860, 20058300, 20058300, 17383860, 13037895, 8436285, 4686825, 2220075, 888030, 296010, 80730, 17550, 2925, 351, 27, 1], [1, 28, 378, 3276, 20475, 98280, 376740, 1184040, 3108105, 6906900, 13123110, 21474180, 30421755, 37442160, 40116600, 37442160, 30421755, 21474180, 13123110, 6906900, 3108105, 1184040, 376740, 98280, 20475, 3276, 378, 28, 1], [1, 29, 406, 3654, 23751, 118755, 475020, 1560780, 4292145, 10015005, 20030010, 34597290, 51895935, 67863915, 77558760, 77558760, 67863915, 51895935, 34597290, 20030010, 10015005, 4292145, 1560780, 475020, 118755, 23751, 3654, 406, 29, 1], [1, 30, 435, 4060, 27405, 142506, 593775, 2035800, 5852925, 14307150, 30045015, 54627300, 86493225, 119759850, 145422675, 155117520, 145422675, 119759850, 86493225, 54627300, 30045015, 14307150, 5852925, 2035800, 593775, 142506, 27405, 4060, 435, 30, 1], [1, 31, 465, 4495, 31465, 169911, 736281, 2629575, 7888725, 20160075, 44352165, 84672315, 141120525, 206253075, 265182525, 300540195, 300540195, 265182525, 206253075, 141120525, 84672315, 44352165, 20160075, 7888725, 2629575, 736281, 169911, 31465, 4495, 465, 31, 1], [1, 32, 496, 4960, 35960, 201376, 906192, 3365856, 10518300, 28048800, 64512240, 129024480, 225792840, 347373600, 471435600, 565722720, 601080390, 565722720, 471435600, 347373600, 225792840, 129024480, 64512240, 28048800, 10518300, 3365856, 906192, 201376, 35960, 4960, 496, 32, 1], [1, 33, 528, 5456, 40920, 237336, 1107568, 4272048, 13884156, 38567100, 92561040, 193536720, 354817320, 573166440, 818809200, 1037158320, 1166803110, 1166803110, 1037158320, 818809200, 573166440, 354817320, 193536720, 92561040, 38567100, 13884156, 4272048, 1107568, 237336, 40920, 5456, 528, 33, 1], [1, 34, 561, 5984, 46376, 278256, 1344904, 5379616, 18156204, 52451256, 131128140, 286097760, 548354040, 927983760, 1391975640, 1855967520, 2203961430, 2333606220, 2203961430, 1855967520, 1391975640, 927983760, 548354040, 286097760, 131128140, 52451256, 18156204, 5379616, 1344904, 278256, 46376, 5984, 561, 34, 1], [1, 35, 595, 6545, 52360, 324632, 1623160, 6724520, 23535820, 70607460, 183579396, 417225900, 834451800, 1476337800, 2319959400, 3247943160, 4059928950, 4537567650, 4537567650, 4059928950, 3247943160, 2319959400, 1476337800, 834451800, 417225900, 183579396, 70607460, 23535820, 6724520, 1623160, 324632, 52360, 6545, 595, 35, 1], [1, 36, 630, 7140, 58905, 376992, 1947792, 8347680, 30260340, 94143280, 254186856, 600805296, 1251677700, 2310789600, 3796297200, 5567902560, 7307872110, 8597496600, 9075135300, 8597496600, 7307872110, 5567902560, 3796297200, 2310789600, 1251677700, 600805296, 254186856, 94143280, 30260340, 8347680, 1947792, 376992, 58905, 7140, 630, 36, 1], [1, 37, 666, 7770, 66045, 435897, 2324784, 10295472, 38608020, 124403620, 348330136, 854992152, 1852482996, 3562467300, 6107086800, 9364199760, 12875774670, 15905368710, 17672631900, 17672631900, 15905368710, 12875774670, 9364199760, 6107086800, 3562467300, 1852482996, 854992152, 348330136, 124403620, 38608020, 10295472, 2324784, 435897, 66045, 7770, 666, 37, 1], [1, 38, 703, 8436, 73815, 501942, 2760681, 12620256, 48903492, 163011640, 472733756, 1203322288, 2707475148, 5414950296, 9669554100, 15471286560, 22239974430, 28781143380, 33578000610, 35345263800, 33578000610, 28781143380, 22239974430, 15471286560, 9669554100, 5414950296, 2707475148, 1203322288, 472733756, 163011640, 48903492, 12620256, 2760681, 501942, 73815, 8436, 703, 38, 1], [1, 39, 741, 9139, 82251, 575757, 3262623, 15380937, 61523748, 211915132, 635745396, 1676056044, 3910797436, 8122425444, 15084504396, 25140840660, 37711260990, 51021117810, 62359143990, 68923264410, 68923264410, 62359143990, 51021117810, 37711260990, 25140840660, 15084504396, 8122425444, 3910797436, 1676056044, 635745396, 211915132, 61523748, 15380937, 3262623, 575757, 82251, 9139, 741, 39, 1], [1, 40, 780, 9880, 91390, 658008, 3838380, 18643560, 76904685, 273438880, 847660528, 2311801440, 5586853480, 12033222880, 23206929840, 40225345056, 62852101650, 88732378800, 113380261800, 131282408400, 137846528820, 131282408400, 113380261800, 88732378800, 62852101650, 40225345056, 23206929840, 12033222880, 5586853480, 2311801440, 847660528, 273438880, 76904685, 18643560, 3838380, 658008, 91390, 9880, 780, 40, 1], [1, 41, 820, 10660, 101270, 749398, 4496388, 22481940, 95548245, 350343565, 1121099408, 3159461968, 7898654920, 17620076360, 35240152720, 63432274896, 103077446706, 151584480450, 202112640600, 244662670200, 269128937220, 269128937220, 244662670200, 202112640600, 151584480450, 103077446706, 63432274896, 35240152720, 17620076360, 7898654920, 3159461968, 1121099408, 350343565, 95548245, 22481940, 4496388, 749398, 101270, 10660, 820, 41, 1], [1, 42, 861, 11480, 111930, 850668, 5245786, 26978328, 118030185, 445891810, 1471442973, 4280561376, 11058116888, 25518731280, 52860229080, 98672427616, 166509721602, 254661927156, 353697121050, 446775310800, 513791607420, 538257874440, 513791607420, 446775310800, 353697121050, 254661927156, 166509721602, 98672427616, 52860229080, 25518731280, 11058116888, 4280561376, 1471442973, 445891810, 118030185, 26978328, 5245786, 850668, 111930, 11480, 861, 42, 1], [1, 43, 903, 12341, 123410, 962598, 6096454, 32224114, 145008513, 563921995, 1917334783, 5752004349, 15338678264, 36576848168, 78378960360, 151532656696, 265182149218, 421171648758, 608359048206, 800472431850, 960566918220, 1052049481860, 1052049481860, 960566918220, 800472431850, 608359048206, 421171648758, 265182149218, 151532656696, 78378960360, 36576848168, 15338678264, 5752004349, 1917334783, 563921995, 145008513, 32224114, 6096454, 962598, 123410, 12341, 903, 43, 1], [1, 44, 946, 13244, 135751, 1086008, 7059052, 38320568, 177232627, 708930508, 2481256778, 7669339132, 21090682613, 51915526432, 114955808528, 229911617056, 416714805914, 686353797976, 1029530696964, 1408831480056, 1761039350070, 2012616400080, 2104098963720, 2012616400080, 1761039350070, 1408831480056, 1029530696964, 686353797976, 416714805914, 229911617056, 114955808528, 51915526432, 21090682613, 7669339132, 2481256778, 708930508, 177232627, 38320568, 7059052, 1086008, 135751, 13244, 946, 44, 1], [1, 45, 990, 14190, 148995, 1221759, 8145060, 45379620, 215553195, 886163135, 3190187286, 10150595910, 28760021745, 73006209045, 166871334960, 344867425584, 646626422970, 1103068603890, 1715884494940, 2438362177020, 3169870830126, 3773655750150, 4116715363800, 4116715363800, 3773655750150, 3169870830126, 2438362177020, 1715884494940, 1103068603890, 646626422970, 344867425584, 166871334960, 73006209045, 28760021745, 10150595910, 3190187286, 886163135, 215553195, 45379620, 8145060, 1221759, 148995, 14190, 990, 45, 1], [1, 46, 1035, 15180, 163185, 1370754, 9366819, 53524680, 260932815, 1101716330, 4076350421, 13340783196, 38910617655, 101766230790, 239877544005, 511738760544, 991493848554, 1749695026860, 2818953098830, 4154246671960, 5608233007146, 6943526580276, 7890371113950, 8233430727600, 7890371113950, 6943526580276, 5608233007146, 4154246671960, 2818953098830, 1749695026860, 991493848554, 511738760544, 239877544005, 101766230790, 38910617655, 13340783196, 4076350421, 1101716330, 260932815, 53524680, 9366819, 1370754, 163185, 15180, 1035, 46, 1], [1, 47, 1081, 16215, 178365, 1533939, 10737573, 62891499, 314457495, 1362649145, 5178066751, 17417133617, 52251400851, 140676848445, 341643774795, 751616304549, 1503232609098, 2741188875414, 4568648125690, 6973199770790, 9762479679106, 12551759587422, 14833897694226, 16123801841550, 16123801841550, 14833897694226, 12551759587422, 9762479679106, 6973199770790, 4568648125690, 2741188875414, 1503232609098, 751616304549, 341643774795, 140676848445, 52251400851, 17417133617, 5178066751, 1362649145, 314457495, 62891499, 10737573, 1533939, 178365, 16215, 1081, 47, 1], [1, 48, 1128, 17296, 194580, 1712304, 12271512, 73629072, 377348994, 1677106640, 6540715896, 22595200368, 69668534468, 192928249296, 482320623240, 1093260079344, 2254848913647, 4244421484512, 7309837001104, 11541847896480, 16735679449896, 22314239266528, 27385657281648, 30957699535776, 32247603683100, 30957699535776, 27385657281648, 22314239266528, 16735679449896, 11541847896480, 7309837001104, 4244421484512, 2254848913647, 1093260079344, 482320623240, 192928249296, 69668534468, 22595200368, 6540715896, 1677106640, 377348994, 73629072, 12271512, 1712304, 194580, 17296, 1128, 48, 1], [1, 49, 1176, 18424, 211876, 1906884, 13983816, 85900584, 450978066, 2054455634, 8217822536, 29135916264, 92263734836, 262596783764, 675248872536, 1575580702584, 3348108992991, 6499270398159, 11554258485616, 18851684897584, 28277527346376, 39049918716424, 49699896548176, 58343356817424, 63205303218876, 63205303218876, 58343356817424, 49699896548176, 39049918716424, 28277527346376, 18851684897584, 11554258485616, 6499270398159, 3348108992991, 1575580702584, 675248872536, 262596783764, 92263734836, 29135916264, 8217822536, 2054455634, 450978066, 85900584, 13983816, 1906884, 211876, 18424, 1176, 49, 1], [1, 50, 1225, 19600, 230300, 2118760, 15890700, 99884400, 536878650, 2505433700, 10272278170, 37353738800, 121399651100, 354860518600, 937845656300, 2250829575120, 4923689695575, 9847379391150, 18053528883775, 30405943383200, 47129212243960, 67327446062800, 88749815264600, 108043253365600, 121548660036300, 126410606437752, 121548660036300, 108043253365600, 88749815264600, 67327446062800, 47129212243960, 30405943383200, 18053528883775, 9847379391150, 4923689695575, 2250829575120, 937845656300, 354860518600, 121399651100, 37353738800, 10272278170, 2505433700, 536878650, 99884400, 15890700, 2118760, 230300, 19600, 1225, 50, 1], [1, 51, 1275, 20825, 249900, 2349060, 18009460, 115775100, 636763050, 3042312350, 12777711870, 47626016970, 158753389900, 476260169700, 1292706174900, 3188675231420, 7174519270695, 14771069086725, 27900908274925, 48459472266975, 77535155627160, 114456658306760, 156077261327400, 196793068630200, 229591913401900, 247959266474052, 247959266474052, 229591913401900, 196793068630200, 156077261327400, 114456658306760, 77535155627160, 48459472266975, 27900908274925, 14771069086725, 7174519270695, 3188675231420, 1292706174900, 476260169700, 158753389900, 47626016970, 12777711870, 3042312350, 636763050, 115775100, 18009460, 2349060, 249900, 20825, 1275, 51, 1], [1, 52, 1326, 22100, 270725, 2598960, 20358520, 133784560, 752538150, 3679075400, 15820024220, 60403728840, 206379406870, 635013559600, 1768966344600, 4481381406320, 10363194502115, 21945588357420, 42671977361650, 76360380541900, 125994627894135, 191991813933920, 270533919634160, 352870329957600, 426384982032100, 477551179875952, 495918532948104, 477551179875952, 426384982032100, 352870329957600, 270533919634160, 191991813933920, 125994627894135, 76360380541900, 42671977361650, 21945588357420, 10363194502115, 4481381406320, 1768966344600, 635013559600, 206379406870, 60403728840, 15820024220, 3679075400, 752538150, 133784560, 20358520, 2598960, 270725, 22100, 1326, 52, 1], [1, 53, 1378, 23426, 292825, 2869685, 22957480, 154143080, 886322710, 4431613550, 19499099620, 76223753060, 266783135710, 841392966470, 2403979904200, 6250347750920, 14844575908435, 32308782859535, 64617565719070, 119032357903550, 202355008436035, 317986441828055, 462525733568080, 623404249591760, 779255311989700, 903936161908052, 973469712824056, 973469712824056, 903936161908052, 779255311989700, 623404249591760, 462525733568080, 317986441828055, 202355008436035, 119032357903550, 64617565719070, 32308782859535, 14844575908435, 6250347750920, 2403979904200, 841392966470, 266783135710, 76223753060, 19499099620, 4431613550, 886322710, 154143080, 22957480, 2869685, 292825, 23426, 1378, 53, 1], [1, 54, 1431, 24804, 316251, 3162510, 25827165, 177100560, 1040465790, 5317936260, 23930713170, 95722852680, 343006888770, 1108176102180, 3245372870670, 8654327655120, 21094923659355, 47153358767970, 96926348578605, 183649923622620, 321387366339585, 520341450264090, 780512175396135, 1085929983159840, 1402659561581460, 1683191473897752, 1877405874732108, 1946939425648112, 1877405874732108, 1683191473897752, 1402659561581460, 1085929983159840, 780512175396135, 520341450264090, 321387366339585, 183649923622620, 96926348578605, 47153358767970, 21094923659355, 8654327655120, 3245372870670, 1108176102180, 343006888770, 95722852680, 23930713170, 5317936260, 1040465790, 177100560, 25827165, 3162510, 316251, 24804, 1431, 54, 1], [1, 55, 1485, 26235, 341055, 3478761, 28989675, 202927725, 1217566350, 6358402050, 29248649430, 119653565850, 438729741450, 1451182990950, 4353548972850, 11899700525790, 29749251314475, 68248282427325, 144079707346575, 280576272201225, 505037289962205, 841728816603675, 1300853625660225, 1866442158555975, 2488589544741300, 3085851035479212, 3560597348629860, 3824345300380220, 3824345300380220, 3560597348629860, 3085851035479212, 2488589544741300, 1866442158555975, 1300853625660225, 841728816603675, 505037289962205, 280576272201225, 144079707346575, 68248282427325, 29749251314475, 11899700525790, 4353548972850, 1451182990950, 438729741450, 119653565850, 29248649430, 6358402050, 1217566350, 202927725, 28989675, 3478761, 341055, 26235, 1485, 55, 1], [1, 56, 1540, 27720, 367290, 3819816, 32468436, 231917400, 1420494075, 7575968400, 35607051480, 148902215280, 558383307300, 1889912732400, 5804731963800, 16253249498640, 41648951840265, 97997533741800, 212327989773900, 424655979547800, 785613562163430, 1346766106565880, 2142582442263900, 3167295784216200, 4355031703297275, 5574440580220512, 6646448384109072, 7384942649010080, 7648690600760440, 7384942649010080, 6646448384109072, 5574440580220512, 4355031703297275, 3167295784216200, 2142582442263900, 1346766106565880, 785613562163430, 424655979547800, 212327989773900, 97997533741800, 41648951840265, 16253249498640, 5804731963800, 1889912732400, 558383307300, 148902215280, 35607051480, 7575968400, 1420494075, 231917400, 32468436, 3819816, 367290, 27720, 1540, 56, 1], [1, 57, 1596, 29260, 395010, 4187106, 36288252, 264385836, 1652411475, 8996462475, 43183019880, 184509266760, 707285522580, 2448296039700, 7694644696200, 22057981462440, 57902201338905, 139646485582065, 310325523515700, 636983969321700, 1210269541711230, 2132379668729310, 3489348548829780, 5309878226480100, 7522327487513475, 9929472283517787, 12220888964329584, 14031391033119152, 15033633249770520, 15033633249770520, 14031391033119152, 12220888964329584, 9929472283517787, 7522327487513475, 5309878226480100, 3489348548829780, 2132379668729310, 1210269541711230, 636983969321700, 310325523515700, 139646485582065, 57902201338905, 22057981462440, 7694644696200, 2448296039700, 707285522580, 184509266760, 43183019880, 8996462475, 1652411475, 264385836, 36288252, 4187106, 395010, 29260, 1596, 57, 1], [1, 58, 1653, 30856, 424270, 4582116, 40475358, 300674088, 1916797311, 10648873950, 52179482355, 227692286640, 891794789340, 3155581562280, 10142940735900, 29752626158640, 79960182801345, 197548686920970, 449972009097765, 947309492837400, 1847253511032930, 3342649210440540, 5621728217559090, 8799226775309880, 12832205713993575, 17451799771031262, 22150361247847371, 26252279997448736, 29065024282889672, 30067266499541040, 29065024282889672, 26252279997448736, 22150361247847371, 17451799771031262, 12832205713993575, 8799226775309880, 5621728217559090, 3342649210440540, 1847253511032930, 947309492837400, 449972009097765, 197548686920970, 79960182801345, 29752626158640, 10142940735900, 3155581562280, 891794789340, 227692286640, 52179482355, 10648873950, 1916797311, 300674088, 40475358, 4582116, 424270, 30856, 1653, 58, 1], [1, 59, 1711, 32509, 455126, 5006386, 45057474, 341149446, 2217471399, 12565671261, 62828356305, 279871768995, 1119487075980, 4047376351620, 13298522298180, 39895566894540, 109712808959985, 277508869722315, 647520696018735, 1397281501935165, 2794563003870330, 5189902721473470, 8964377427999630, 14420954992868970, 21631432489303455, 30284005485024837, 39602161018878633, 48402641245296107, 55317304280338408, 59132290782430712, 59132290782430712, 55317304280338408, 48402641245296107, 39602161018878633, 30284005485024837, 21631432489303455, 14420954992868970, 8964377427999630, 5189902721473470, 2794563003870330, 1397281501935165, 647520696018735, 277508869722315, 109712808959985, 39895566894540, 13298522298180, 4047376351620, 1119487075980, 279871768995, 62828356305, 12565671261, 2217471399, 341149446, 45057474, 5006386, 455126, 32509, 1711, 59, 1], [1, 60, 1770, 34220, 487635, 5461512, 50063860, 386206920, 2558620845, 14783142660, 75394027566, 342700125300, 1399358844975, 5166863427600, 17345898649800, 53194089192720, 149608375854525, 387221678682300, 925029565741050, 2044802197953900, 4191844505805495, 7984465725343800, 14154280149473100, 23385332420868600, 36052387482172425, 51915437974328292, 69886166503903470, 88004802264174740, 103719945525634515, 114449595062769120, 118264581564861424, 114449595062769120, 103719945525634515, 88004802264174740, 69886166503903470, 51915437974328292, 36052387482172425, 23385332420868600, 14154280149473100, 7984465725343800, 4191844505805495, 2044802197953900, 925029565741050, 387221678682300, 149608375854525, 53194089192720, 17345898649800, 5166863427600, 1399358844975, 342700125300, 75394027566, 14783142660, 2558620845, 386206920, 50063860, 5461512, 487635, 34220, 1770, 60, 1], [1, 61, 1830, 35990, 521855, 5949147, 55525372, 436270780, 2944827765, 17341763505, 90177170226, 418094152866, 1742058970275, 6566222272575, 22512762077400, 70539987842520, 202802465047245, 536830054536825, 1312251244423350, 2969831763694950, 6236646703759395, 12176310231149295, 22138745874816900, 37539612570341700, 59437719903041025, 87967825456500717, 121801604478231762, 157890968768078210, 191724747789809255, 218169540588403635, 232714176627630544, 232714176627630544, 218169540588403635, 191724747789809255, 157890968768078210, 121801604478231762, 87967825456500717, 59437719903041025, 37539612570341700, 22138745874816900, 12176310231149295, 6236646703759395, 2969831763694950, 1312251244423350, 536830054536825, 202802465047245, 70539987842520, 22512762077400, 6566222272575, 1742058970275, 418094152866, 90177170226, 17341763505, 2944827765, 436270780, 55525372, 5949147, 521855, 35990, 1830, 61, 1], [1, 62, 1891, 37820, 557845, 6471002, 61474519, 491796152, 3381098545, 20286591270, 107518933731, 508271323092, 2160153123141, 8308281242850, 29078984349975, 93052749919920, 273342452889765, 739632519584070, 1849081298960175, 4282083008118300, 9206478467454345, 18412956934908690, 34315056105966195, 59678358445158600, 96977332473382725, 147405545359541742, 209769429934732479, 279692573246309972, 349615716557887465, 409894288378212890, 450883717216034179, 465428353255261088, 450883717216034179, 409894288378212890, 349615716557887465, 279692573246309972, 209769429934732479, 147405545359541742, 96977332473382725, 59678358445158600, 34315056105966195, 18412956934908690, 9206478467454345, 4282083008118300, 1849081298960175, 739632519584070, 273342452889765, 93052749919920, 29078984349975, 8308281242850, 2160153123141, 508271323092, 107518933731, 20286591270, 3381098545, 491796152, 61474519, 6471002, 557845, 37820, 1891, 62, 1], [1, 63, 1953, 39711, 595665, 7028847, 67945521, 553270671, 3872894697, 23667689815, 127805525001, 615790256823, 2668424446233, 10468434365991, 37387265592825, 122131734269895, 366395202809685, 1012974972473835, 2588713818544245, 6131164307078475, 13488561475572645, 27619435402363035, 52728013040874885, 93993414551124795, 156655690918541325, 244382877832924467, 357174975294274221, 489462003181042451, 629308289804197437, 759510004936100355, 860778005594247069, 916312070471295267, 916312070471295267, 860778005594247069, 759510004936100355, 629308289804197437, 489462003181042451, 357174975294274221, 244382877832924467, 156655690918541325, 93993414551124795, 52728013040874885, 27619435402363035, 13488561475572645, 6131164307078475, 2588713818544245, 1012974972473835, 366395202809685, 122131734269895, 37387265592825, 10468434365991, 2668424446233, 615790256823, 127805525001, 23667689815, 3872894697, 553270671, 67945521, 7028847, 595665, 39711, 1953, 63, 1], [1, 64, 2016, 41664, 635376, 7624512, 74974368, 621216192, 4426165368, 27540584512, 151473214816, 743595781824, 3284214703056, 13136858812224, 47855699958816, 159518999862720, 488526937079580, 1379370175283520, 3601688791018080, 8719878125622720, 19619725782651120, 41107996877935680, 80347448443237920, 146721427591999680, 250649105469666120, 401038568751465792, 601557853127198688, 846636978475316672, 1118770292985239888, 1388818294740297792, 1620288010530347424, 1777090076065542336, 1832624140942590534, 1777090076065542336, 1620288010530347424, 1388818294740297792, 1118770292985239888, 846636978475316672, 601557853127198688, 401038568751465792, 250649105469666120, 146721427591999680, 80347448443237920, 41107996877935680, 19619725782651120, 8719878125622720, 3601688791018080, 1379370175283520, 488526937079580, 159518999862720, 47855699958816, 13136858812224, 3284214703056, 743595781824, 151473214816, 27540584512, 4426165368, 621216192, 74974368, 7624512, 635376, 41664, 2016, 64, 1], [1, 65, 2080, 43680, 677040, 8259888, 82598880, 696190560, 5047381560, 31966749880, 179013799328, 895068996640, 4027810484880, 16421073515280, 60992558771040, 207374699821536, 648045936942300, 1867897112363100, 4981058966301600, 12321566916640800, 28339603908273840, 60727722660586800, 121455445321173600, 227068876035237600, 397370533061665800, 651687674221131912, 1002596421878664480, 1448194831602515360, 1965407271460556560, 2507588587725537680, 3009106305270645216, 3397378086595889760, 3609714217008132870, 3609714217008132870, 3397378086595889760, 3009106305270645216, 2507588587725537680, 1965407271460556560, 1448194831602515360, 1002596421878664480, 651687674221131912, 397370533061665800, 227068876035237600, 121455445321173600, 60727722660586800, 28339603908273840, 12321566916640800, 4981058966301600, 1867897112363100, 648045936942300, 207374699821536, 60992558771040, 16421073515280, 4027810484880, 895068996640, 179013799328, 31966749880, 5047381560, 696190560, 82598880, 8259888, 677040, 43680, 2080, 65, 1], [1, 66, 2145, 45760, 720720, 8936928, 90858768, 778789440, 5743572120, 37014131440, 210980549208, 1074082795968, 4922879481520, 20448884000160, 77413632286320, 268367258592576, 855420636763836, 2515943049305400, 6848956078664700, 17302625882942400, 40661170824914640, 89067326568860640, 182183167981760400, 348524321356411200, 624439409096903400, 1049058207282797712, 1654284096099796392, 2450791253481179840, 3413602103063071920, 4472995859186094240, 5516694892996182896, 6406484391866534976, 7007092303604022630, 7219428434016265740, 7007092303604022630, 6406484391866534976, 5516694892996182896, 4472995859186094240, 3413602103063071920, 2450791253481179840, 1654284096099796392, 1049058207282797712, 624439409096903400, 348524321356411200, 182183167981760400, 89067326568860640, 40661170824914640, 17302625882942400, 6848956078664700, 2515943049305400, 855420636763836, 268367258592576, 77413632286320, 20448884000160, 4922879481520, 1074082795968, 210980549208, 37014131440, 5743572120, 778789440, 90858768, 8936928, 720720, 45760, 2145, 66, 1], [1, 67, 2211, 47905, 766480, 9657648, 99795696, 869648208, 6522361560, 42757703560, 247994680648, 1285063345176, 5996962277488, 25371763481680, 97862516286480, 345780890878896, 1123787895356412, 3371363686069236, 9364899127970100, 24151581961607100, 57963796707857040, 129728497393775280, 271250494550621040, 530707489338171600, 972963730453314600, 1673497616379701112, 2703342303382594104, 4105075349580976232, 5864393356544251760, 7886597962249166160, 9989690752182277136, 11923179284862717872, 13413576695470557606, 14226520737620288370, 14226520737620288370, 13413576695470557606, 11923179284862717872, 9989690752182277136, 7886597962249166160, 5864393356544251760, 4105075349580976232, 2703342303382594104, 1673497616379701112, 972963730453314600, 530707489338171600, 271250494550621040, 129728497393775280, 57963796707857040, 24151581961607100, 9364899127970100, 3371363686069236, 1123787895356412, 345780890878896, 97862516286480, 25371763481680, 5996962277488, 1285063345176, 247994680648, 42757703560, 6522361560, 869648208, 99795696, 9657648, 766480, 47905, 2211, 67, 1], [1, 68, 2278, 50116, 814385, 10424128, 109453344, 969443904, 7392009768, 49280065120, 290752384208, 1533058025824, 7282025622664, 31368725759168, 123234279768160, 443643407165376, 1469568786235308, 4495151581425648, 12736262814039336, 33516481089577200, 82115378669464140, 187692294101632320, 400978991944396320, 801957983888792640, 1503671219791486200, 2646461346833015712, 4376839919762295216, 6808417652963570336, 9969468706125227992, 13750991318793417920, 17876288714431443296, 21912870037044995008, 25336755980333275478, 27640097433090845976, 28453041475240576740, 27640097433090845976, 25336755980333275478, 21912870037044995008, 17876288714431443296, 13750991318793417920, 9969468706125227992, 6808417652963570336, 4376839919762295216, 2646461346833015712, 1503671219791486200, 801957983888792640, 400978991944396320, 187692294101632320, 82115378669464140, 33516481089577200, 12736262814039336, 4495151581425648, 1469568786235308, 443643407165376, 123234279768160, 31368725759168, 7282025622664, 1533058025824, 290752384208, 49280065120, 7392009768, 969443904, 109453344, 10424128, 814385, 50116, 2278, 68, 1], [1, 69, 2346, 52394, 864501, 11238513, 119877472, 1078897248, 8361453672, 56672074888, 340032449328, 1823810410032, 8815083648488, 38650751381832, 154603005527328, 566877686933536, 1913212193400684, 5964720367660956, 17231414395464984, 46252743903616536, 115631859759041340, 269807672771096460, 588671286046028640, 1202936975833188960, 2305629203680278840, 4150132566624501912, 7023301266595310928, 11185257572725865552, 16777886359088798328, 23720460024918645912, 31627280033224861216, 39789158751476438304, 47249626017378270486, 52976853413424121454, 56093138908331422716, 56093138908331422716, 52976853413424121454, 47249626017378270486, 39789158751476438304, 31627280033224861216, 23720460024918645912, 16777886359088798328, 11185257572725865552, 7023301266595310928, 4150132566624501912, 2305629203680278840, 1202936975833188960, 588671286046028640, 269807672771096460, 115631859759041340, 46252743903616536, 17231414395464984, 5964720367660956, 1913212193400684, 566877686933536, 154603005527328, 38650751381832, 8815083648488, 1823810410032, 340032449328, 56672074888, 8361453672, 1078897248, 119877472, 11238513, 864501, 52394, 2346, 69, 1], [1, 70, 2415, 54740, 916895, 12103014, 131115985, 1198774720, 9440350920, 65033528560, 396704524216, 2163842859360, 10638894058520, 47465835030320, 193253756909160, 721480692460864, 2480089880334220, 7877932561061640, 23196134763125940, 63484158299081520, 161884603662657876, 385439532530137800, 858478958817125100, 1791608261879217600, 3508566179513467800, 6455761770304780752, 11173433833219812840, 18208558839321176480, 27963143931814663880, 40498346384007444240, 55347740058143507128, 71416438784701299520, 87038784768854708790, 100226479430802391940, 109069992321755544170, 112186277816662845432, 109069992321755544170, 100226479430802391940, 87038784768854708790, 71416438784701299520, 55347740058143507128, 40498346384007444240, 27963143931814663880, 18208558839321176480, 11173433833219812840, 6455761770304780752, 3508566179513467800, 1791608261879217600, 858478958817125100, 385439532530137800, 161884603662657876, 63484158299081520, 23196134763125940, 7877932561061640, 2480089880334220, 721480692460864, 193253756909160, 47465835030320, 10638894058520, 2163842859360, 396704524216, 65033528560, 9440350920, 1198774720, 131115985, 12103014, 916895, 54740, 2415, 70, 1], [1, 71, 2485, 57155, 971635, 13019909, 143218999, 1329890705, 10639125640, 74473879480, 461738052776, 2560547383576, 12802736917880, 58104729088840, 240719591939480, 914734449370024, 3201570572795084, 10358022441395860, 31074067324187580, 86680293062207460, 225368761961739396, 547324136192795676, 1243918491347262900, 2650087220696342700, 5300174441392685400, 9964327949818248552, 17629195603524593592, 29381992672540989320, 46171702771135840360, 68461490315822108120, 95846086442150951368, 126764178842844806648, 158455223553556008310, 187265264199657100730, 209296471752557936110, 221256270138418389602, 221256270138418389602, 209296471752557936110, 187265264199657100730, 158455223553556008310, 126764178842844806648, 95846086442150951368, 68461490315822108120, 46171702771135840360, 29381992672540989320, 17629195603524593592, 9964327949818248552, 5300174441392685400, 2650087220696342700, 1243918491347262900, 547324136192795676, 225368761961739396, 86680293062207460, 31074067324187580, 10358022441395860, 3201570572795084, 914734449370024, 240719591939480, 58104729088840, 12802736917880, 2560547383576, 461738052776, 74473879480, 10639125640, 1329890705, 143218999, 13019909, 971635, 57155, 2485, 71, 1], [1, 72, 2556, 59640, 1028790, 13991544, 156238908, 1473109704, 11969016345, 85113005120, 536211932256, 3022285436352, 15363284301456, 70907466006720, 298824321028320, 1155454041309504, 4116305022165108, 13559593014190944, 41432089765583440, 117754360386395040, 312049055023946856, 772692898154535072, 1791242627540058576, 3894005712043605600, 7950261662089028100, 15264502391210933952, 27593523553342842144, 47011188276065582912, 75553695443676829680, 114633193086957948480, 164307576757973059488, 222610265284995758016, 285219402396400814958, 345720487753213109040, 396561735952215036840, 430552741890976325712, 442512540276836779204, 430552741890976325712, 396561735952215036840, 345720487753213109040, 285219402396400814958, 222610265284995758016, 164307576757973059488, 114633193086957948480, 75553695443676829680, 47011188276065582912, 27593523553342842144, 15264502391210933952, 7950261662089028100, 3894005712043605600, 1791242627540058576, 772692898154535072, 312049055023946856, 117754360386395040, 41432089765583440, 13559593014190944, 4116305022165108, 1155454041309504, 298824321028320, 70907466006720, 15363284301456, 3022285436352, 536211932256, 85113005120, 11969016345, 1473109704, 156238908, 13991544, 1028790, 59640, 2556, 72, 1], [1, 73, 2628, 62196, 1088430, 15020334, 170230452, 1629348612, 13442126049, 97082021465, 621324937376, 3558497368608, 18385569737808, 86270750308176, 369731787035040, 1454278362337824, 5271759063474612, 17675898036356052, 54991682779774384, 159186450151978480, 429803415410341896, 1084741953178481928, 2563935525694593648, 5685248339583664176, 11844267374132633700, 23214764053299962052, 42858025944553776096, 74604711829408425056, 122564883719742412592, 190186888530634778160, 278940769844931007968, 386917842042968817504, 507829667681396572974, 630939890149613923998, 742282223705428145880, 827114477843191362552, 873065282167813104916, 873065282167813104916, 827114477843191362552, 742282223705428145880, 630939890149613923998, 507829667681396572974, 386917842042968817504, 278940769844931007968, 190186888530634778160, 122564883719742412592, 74604711829408425056, 42858025944553776096, 23214764053299962052, 11844267374132633700, 5685248339583664176, 2563935525694593648, 1084741953178481928, 429803415410341896, 159186450151978480, 54991682779774384, 17675898036356052, 5271759063474612, 1454278362337824, 369731787035040, 86270750308176, 18385569737808, 3558497368608, 621324937376, 97082021465, 13442126049, 1629348612, 170230452, 15020334, 1088430, 62196, 2628, 73, 1], [1, 74, 2701, 64824, 1150626, 16108764, 185250786, 1799579064, 15071474661, 110524147514, 718406958841, 4179822305984, 21944067106416, 104656320045984, 456002537343216, 1824010149372864, 6726037425812436, 22947657099830664, 72667580816130436, 214178132931752864, 588989865562320376, 1514545368588823824, 3648677478873075576, 8249183865278257824, 17529515713716297876, 35059031427432595752, 66072789997853738148, 117462737773962201152, 197169595549150837648, 312751772250377190752, 469127658375565786128, 665858611887899825472, 894747509724365390478, 1138769557831010496972, 1373222113855042069878, 1569396701548619508432, 1700179760011004467468, 1746130564335626209832, 1700179760011004467468, 1569396701548619508432, 1373222113855042069878, 1138769557831010496972, 894747509724365390478, 665858611887899825472, 469127658375565786128, 312751772250377190752, 197169595549150837648, 117462737773962201152, 66072789997853738148, 35059031427432595752, 17529515713716297876, 8249183865278257824, 3648677478873075576, 1514545368588823824, 588989865562320376, 214178132931752864, 72667580816130436, 22947657099830664, 6726037425812436, 1824010149372864, 456002537343216, 104656320045984, 21944067106416, 4179822305984, 718406958841, 110524147514, 15071474661, 1799579064, 185250786, 16108764, 1150626, 64824, 2701, 74, 1]]\n", "language": "python"}
{"task_id": "e41f2b1c-5854-46b1-85f9-a00fc8255df6297235373277371252", "prompt": "Following the function's documentation, write the complete implementation in one code block. Ensure your solution handles all possible edge cases.\n\n```python\ndef decode_morse(morse_code: str) -> str:\n    \"\"\"\n    In a historical reenactment of early telegraph communication, participants need to\n    decode Morse code messages. This function takes a string of Morse code and returns\n    the decoded message in uppercase English letters.\n\n    The Morse code is represented by dots (.) and dashes (-), with spaces between letters\n    and double spaces between words. You should use a dictionary to map Morse code to letters.\n\n\n    [EXAMPLES]\n    \n    assert candidate(\".--. .-.. . .- ... .\") == 'PLEASE'\n    assert candidate(\"- .... .- -. -.-  -.-- --- ..-\") == 'THANK YOU'\n\n    [/EXAMPLES]\n    \"\"\"\n```\n", "entry_point": "decode_morse", "solution": "def decode_morse(morse_code: str) -> str:\n    \"\"\"\n    In a historical reenactment of early telegraph communication, participants need to\n    decode Morse code messages. This function takes a string of Morse code and returns\n    the decoded message in uppercase English letters.\n\n    The Morse code is represented by dots (.) and dashes (-), with spaces between letters\n    and double spaces between words. You should use a dictionary to map Morse code to letters.\n\n\n    [EXAMPLES]\n    \n    assert candidate(\".--. .-.. . .- ... .\") == 'PLEASE'\n    assert candidate(\"- .... .- -. -.-  -.-- --- ..-\") == 'THANK YOU'\n\n    [/EXAMPLES]\n    \"\"\"\n    # Morse code to letter mapping\n    morse_dict = {\n        '.-': 'A', '-...': 'B', '-.-.': 'C', '-..': 'D', '.': 'E',\n        '..-.': 'F', '--.': 'G', '....': 'H', '..': 'I', '.---': 'J',\n        '-.-': 'K', '.-..': 'L', '--': 'M', '-.': 'N', '---': 'O',\n        '.--.': 'P', '--.-': 'Q', '.-.': 'R', '...': 'S', '-': 'T',\n        '..-': 'U', '...-': 'V', '.--': 'W', '-..-': 'X', '-.--': 'Y',\n        '--..': 'Z'\n    }\n\n    # Split the morse code into words\n    words = morse_code.strip().split('  ')\n    decoded_message = []\n\n    for word in words:\n        # Split each word into letters\n        letters = word.split(' ')\n        decoded_word = ''.join(morse_dict.get(letter, '') for letter in letters)\n        decoded_message.append(decoded_word)\n\n    # Join the decoded words with spaces\n    return ' '.join(decoded_message)\n\n", "test": "def check(candidate):\n    assert candidate(\".--- ..- ... - .. -.-. .\") == 'JUSTICE'\n    assert candidate(\"--. --- --- -..  -- --- .-. -. .. -. --.\") == 'GOOD MORNING'\n    assert candidate(\"--. --- --- -..  -. .. --. .... -\") == 'GOOD NIGHT'\n    assert candidate(\"..- ...- .-- -..- -.-- --..  .---- ..--- ...-- ....- .....  -.... --... ---.. ----. -----\") == 'UVWXYZ  '\n    assert candidate(\"- .... .  --.- ..- .. -.-. -.-  -... .-. --- .-- -.  ..-. --- -..-  .--- ..- -- .--. ...  --- ...- . .-.  - .... .  .-.. .- --.. -.--  -.. --- --.\") == 'THE QUICK BROWN FOX JUMPS OVER THE LAZY DOG'\n    assert candidate(\"- .... .- -. -.-  -.-- --- ..-\") == 'THANK YOU'\n    assert candidate(\".--. .-.. . .- ... .\") == 'PLEASE'\n    assert candidate(\".- -... -.-. -.. .  ..-. --. .... .. .---\") == 'ABCDE FGHIJ'\n    assert candidate(\".--. . .- -.-. .\") == 'PEACE'\n    assert candidate(\"-- --- .-. ... .  -.-. --- -.. .\") == 'MORSE CODE'\n", "language": "python"}
{"task_id": "476b85c1-f1df-4dd0-b4ab-e29c32cbc9f9602853644459518108", "prompt": "I'll code the entire function according to what's described in the docstring. The implementation will be in one complete code block.\n\n```python\nfrom typing import List, Tuple\n\ndef optimize_study_schedule(subjects: List[str], difficulties: List[int], time_available: int) -> Tuple[List[str], int]:\n    \"\"\"\n    A student is preparing for exams and wants to optimize their study schedule. They have a list of subjects to study,\n    each with a different difficulty level, and a limited amount of time available.\n\n    This function takes three parameters:\n    - 'subjects': a list of subject names\n    - 'difficulties': a list of integers representing the difficulty level of each subject (1-10)\n    - 'time_available': the total time available for studying (in hours)\n\n    It returns a tuple containing:\n    1. A list of subjects that can be studied within the available time, maximizing the total difficulty\n    2. The total difficulty of the selected subjects\n\n    Assume that each subject takes 1 hour to study, regardless of its difficulty.\n\n\n    [EXAMPLES]\n    \n    assert candidate(['Macroeconomics', 'Microeconomics', 'International Economics'], [7, 8, 6], 2) == (['Microeconomics', 'Macroeconomics'], 15)\n    assert candidate(['Astronomy', 'Geology', 'Meteorology'], [8, 7, 6], 3) == (['Astronomy', 'Geology', 'Meteorology'], 21)\n\n    [/EXAMPLES]\n    \"\"\"\n```\n", "entry_point": "optimize_study_schedule", "solution": "from typing import List, Tuple\n\ndef optimize_study_schedule(subjects: List[str], difficulties: List[int], time_available: int) -> Tuple[List[str], int]:\n    \"\"\"\n    A student is preparing for exams and wants to optimize their study schedule. They have a list of subjects to study,\n    each with a different difficulty level, and a limited amount of time available.\n\n    This function takes three parameters:\n    - 'subjects': a list of subject names\n    - 'difficulties': a list of integers representing the difficulty level of each subject (1-10)\n    - 'time_available': the total time available for studying (in hours)\n\n    It returns a tuple containing:\n    1. A list of subjects that can be studied within the available time, maximizing the total difficulty\n    2. The total difficulty of the selected subjects\n\n    Assume that each subject takes 1 hour to study, regardless of its difficulty.\n\n\n    [EXAMPLES]\n    \n    assert candidate(['Macroeconomics', 'Microeconomics', 'International Economics'], [7, 8, 6], 2) == (['Microeconomics', 'Macroeconomics'], 15)\n    assert candidate(['Astronomy', 'Geology', 'Meteorology'], [8, 7, 6], 3) == (['Astronomy', 'Geology', 'Meteorology'], 21)\n\n    [/EXAMPLES]\n    \"\"\"\n    # Create a list of tuples containing (subject, difficulty)\n    subject_difficulty = list(zip(subjects, difficulties))\n    \n    # Sort the list by difficulty in descending order\n    subject_difficulty.sort(key=lambda x: x[1], reverse=True)\n    \n    selected_subjects = []\n    total_difficulty = 0\n    \n    # Select subjects until time runs out or all subjects are selected\n    for subject, difficulty in subject_difficulty:\n        if time_available > 0:\n            selected_subjects.append(subject)\n            total_difficulty += difficulty\n            time_available -= 1\n        else:\n            break\n    \n    return (selected_subjects, total_difficulty)\n\n", "test": "def check(candidate):\n    assert candidate(['Anatomy', 'Physiology', 'Biochemistry', 'Microbiology'], [8, 7, 9, 6], 4) == (['Biochemistry', 'Anatomy', 'Physiology', 'Microbiology'], 30)\n    assert candidate(['History', 'Literature', 'Geography'], [4, 3, 5], 2) == (['Geography', 'History'], 9)\n    assert candidate(['Ancient History', 'Medieval History', 'Modern History'], [5, 6, 7], 2) == (['Modern History', 'Medieval History'], 13)\n    assert candidate(['Economics', 'Psychology', 'Sociology'], [7, 6, 5], 1) == (['Economics'], 7)\n    assert candidate(['Philosophy', 'Ethics', 'Logic'], [9, 8, 7], 2) == (['Philosophy', 'Ethics'], 17)\n    assert candidate(['Constitutional Law', 'Criminal Law', 'Civil Law', 'International Law'], [9, 8, 7, 6], 3) == (['Constitutional Law', 'Criminal Law', 'Civil Law'], 24)\n    assert candidate(['Astronomy', 'Geology', 'Meteorology'], [8, 7, 6], 3) == (['Astronomy', 'Geology', 'Meteorology'], 21)\n    assert candidate(['Math', 'Physics', 'Chemistry', 'Biology'], [8, 6, 7, 5], 3) == (['Math', 'Chemistry', 'Physics'], 21)\n    assert candidate(['Macroeconomics', 'Microeconomics', 'International Economics'], [7, 8, 6], 2) == (['Microeconomics', 'Macroeconomics'], 15)\n    assert candidate(['Robotics', 'Artificial Intelligence', 'Machine Learning', 'Computer Vision'], [9, 10, 8, 7], 3) == (['Artificial Intelligence', 'Robotics', 'Machine Learning'], 27)\n", "language": "python"}
{"task_id": "9a234a30-2244-4b45-a66b-a16734cd384d3849321446602328092", "prompt": "Below is a complete implementation of the requested function. The solution is contained in a single code block, relies only on libraries imported in the problem, and includes any necessary helper functions or classes nested within the main function definition.\n\n```python\nfrom typing import List, Tuple\n\ndef optimize_network(nodes: int, connections: List[Tuple[int, int, int]]) -> int:\n    \"\"\"You are tasked with optimizing a computer network for a large corporation.\n    The network consists of 'nodes' number of computers, labeled from 0 to nodes-1.\n    The 'connections' list represents network cables between computers, where each tuple (a, b, latency)\n    indicates a bidirectional connection between computers a and b with a latency of 'latency' milliseconds.\n\n    Your goal is to minimize the maximum latency between any two connected computers by removing some of the cables.\n    However, you must ensure that all computers remain connected (directly or indirectly).\n\n    Return the minimum achievable maximum latency in the optimized network.\n    If it's impossible to connect all computers, return -1.\n\n    Use Kruskal's algorithm and Union-Find data structure to solve this problem.\n\n\n    [EXAMPLES]\n    \n    assert candidate(5, [(0,1,1), (1,2,2), (2,3,3), (3,4,4), (4,0,5), (0,2,6), (1,3,7), (2,4,8)]) == 4\n    assert candidate(5, [(0,1,10), (1,2,20), (2,3,30), (3,4,40), (4,0,50)]) == 40\n\n    [/EXAMPLES]\n    \"\"\"\n```\n", "entry_point": "optimize_network", "solution": "from typing import List, Tuple\n\ndef optimize_network(nodes: int, connections: List[Tuple[int, int, int]]) -> int:\n    \"\"\"You are tasked with optimizing a computer network for a large corporation.\n    The network consists of 'nodes' number of computers, labeled from 0 to nodes-1.\n    The 'connections' list represents network cables between computers, where each tuple (a, b, latency)\n    indicates a bidirectional connection between computers a and b with a latency of 'latency' milliseconds.\n\n    Your goal is to minimize the maximum latency between any two connected computers by removing some of the cables.\n    However, you must ensure that all computers remain connected (directly or indirectly).\n\n    Return the minimum achievable maximum latency in the optimized network.\n    If it's impossible to connect all computers, return -1.\n\n    Use Kruskal's algorithm and Union-Find data structure to solve this problem.\n\n\n    [EXAMPLES]\n    \n    assert candidate(5, [(0,1,1), (1,2,2), (2,3,3), (3,4,4), (4,0,5), (0,2,6), (1,3,7), (2,4,8)]) == 4\n    assert candidate(5, [(0,1,10), (1,2,20), (2,3,30), (3,4,40), (4,0,50)]) == 40\n\n    [/EXAMPLES]\n    \"\"\"\n    \n    class UnionFind:\n        def __init__(self, size):\n            self.parent = list(range(size))\n            self.rank = [0] * size\n        \n        def find(self, x):\n            if self.parent[x] != x:\n                self.parent[x] = self.find(self.parent[x])\n            return self.parent[x]\n        \n        def union(self, x, y):\n            px, py = self.find(x), self.find(y)\n            if px == py:\n                return False\n            if self.rank[px] < self.rank[py]:\n                self.parent[px] = py\n            elif self.rank[px] > self.rank[py]:\n                self.parent[py] = px\n            else:\n                self.parent[py] = px\n                self.rank[px] += 1\n            return True\n\n    # Sort connections by latency\n    connections.sort(key=lambda x: x[2])\n    \n    uf = UnionFind(nodes)\n    max_latency = 0\n    edges_added = 0\n    \n    for a, b, latency in connections:\n        if uf.union(a, b):\n            max_latency = max(max_latency, latency)\n            edges_added += 1\n            if edges_added == nodes - 1:\n                return max_latency\n    \n    # If we can't connect all nodes, return -1\n    return -1 if edges_added < nodes - 1 else max_latency\n\n", "test": "def check(candidate):\n    assert candidate(5, [(0,1,1), (1,2,2), (2,3,3), (3,4,4), (4,0,5), (0,2,6), (1,3,7), (2,4,8)]) == 4\n    assert candidate(10, [(i,i+1,1) for i in range(9)]) == 1\n    assert candidate(2, [(0,1,10)]) == 10\n    assert candidate(5, [(0,1,10), (1,2,20), (2,3,30), (3,4,40), (4,0,50)]) == 40\n    assert candidate(7, [(0,1,1), (1,2,2), (2,3,3), (3,4,4), (4,5,5), (5,6,6), (6,0,7), (0,3,8), (1,4,9), (2,5,10)]) == 6\n    assert candidate(4, [(0,1,10), (0,2,20), (0,3,30), (1,2,40), (1,3,50), (2,3,60)]) == 30\n    assert candidate(3, [(0,1,1), (1,2,2), (0,2,3)]) == 2\n    assert candidate(5, [(0,1,1), (1,2,2), (2,3,3), (3,4,4)]) == 4\n    assert candidate(8, [(i,i+1,i+1) for i in range(7)] + [(7,0,8)]) == 7\n    assert candidate(3, [(0,1,100), (1,2,200), (0,2,300)]) == 200\n", "language": "python"}
{"task_id": "9aab13b1-e7c4-46cc-954b-780cb46703247468270564033361926", "prompt": "Implement the function as requested so it can be run immediately in a single code block. Use only the libraries that are already imported. Any helper functions or classes should be defined within the main function, not outside it.\n\n```python\nfrom typing import List\n\ndef analyze_stock_prices(prices: List[float]) -> int:\n    \"\"\"\n    An investor wants to analyze a series of daily stock prices to find the\n    maximum profit that could have been made by buying on one day and selling\n    on a later day. The function should return the maximum profit possible.\n    If no profit is possible, return 0.\n\n\n    [EXAMPLES]\n    \n    assert candidate([1, 2, 3, 4, 5]) == 4\n    assert candidate([0.5, 0.4, 0.3, 0.2, 0.1]) == 0\n\n    [/EXAMPLES]\n    \"\"\"\n```\n", "entry_point": "analyze_stock_prices", "solution": "from typing import List\n\ndef analyze_stock_prices(prices: List[float]) -> int:\n    \"\"\"\n    An investor wants to analyze a series of daily stock prices to find the\n    maximum profit that could have been made by buying on one day and selling\n    on a later day. The function should return the maximum profit possible.\n    If no profit is possible, return 0.\n\n\n    [EXAMPLES]\n    \n    assert candidate([1, 2, 3, 4, 5]) == 4\n    assert candidate([0.5, 0.4, 0.3, 0.2, 0.1]) == 0\n\n    [/EXAMPLES]\n    \"\"\"\n    if not prices or len(prices) < 2:\n        return 0\n\n    min_price = float('inf')\n    max_profit = 0\n\n    for price in prices:\n        if price < min_price:\n            min_price = price\n        else:\n            current_profit = price - min_price\n            max_profit = max(max_profit, current_profit)\n\n    return max_profit\n\n", "test": "def check(candidate):\n    assert candidate([1000.0, 999.0, 998.0, 997.0, 996.0]) == 0\n    assert candidate([5, 4, 3, 2, 1]) == 0\n    assert candidate([1, 2, 3, 4, 5]) == 4\n    assert candidate([1, 1, 1, 1, 1]) == 0\n    assert candidate([1.0]) == 0\n    assert candidate([10.0, 10.0, 10.0, 10.0, 10.0]) == 0\n    assert candidate([]) == 0\n    assert candidate([0.5, 0.4, 0.3, 0.2, 0.1]) == 0\n", "language": "python"}
{"task_id": "e1714070-dd52-40ec-809f-cfbe30cd190d-692706100376657995", "prompt": "I'm your coding assistant today. When you provide a function to complete, I'll fill in the implementation so it can be executed directly. My code will stay within the function boundaries, use only the libraries that are already imported, and any helper functions or classes I create will be defined inside the given function.\n\n```python\nimport re\nimport string\nfrom typing import List, Dict\n\ndef word_frequency_analyzer(text: str, ignored_words: List[str]) -> Dict[str, int]:\n    \"\"\"\n    Analyze the frequency of words in a given text, excluding a list of ignored words.\n\n    This function processes a text string and returns a dictionary with word frequencies.\n    It utilizes string manipulation and dictionary data structures to count word occurrences.\n\n    Parameters:\n    - text: A string containing the text to be analyzed.\n    - ignored_words: A list of words to be excluded from the analysis.\n\n    Returns a dictionary where keys are words and values are their frequencies in the text.\n\n\n    [EXAMPLES]\n    \n    assert candidate(\"\", []) == {}\n    assert candidate(\"This is a test. This is only a test.\", [\"this\", \"is\", \"a\"]) == {'test': 2, 'only': 1}\n\n    [/EXAMPLES]\n    \"\"\"\n```\n", "entry_point": "word_frequency_analyzer", "solution": "import re\nimport string\nfrom typing import List, Dict\n\ndef word_frequency_analyzer(text: str, ignored_words: List[str]) -> Dict[str, int]:\n    \"\"\"\n    Analyze the frequency of words in a given text, excluding a list of ignored words.\n\n    This function processes a text string and returns a dictionary with word frequencies.\n    It utilizes string manipulation and dictionary data structures to count word occurrences.\n\n    Parameters:\n    - text: A string containing the text to be analyzed.\n    - ignored_words: A list of words to be excluded from the analysis.\n\n    Returns a dictionary where keys are words and values are their frequencies in the text.\n\n\n    [EXAMPLES]\n    \n    assert candidate(\"\", []) == {}\n    assert candidate(\"This is a test. This is only a test.\", [\"this\", \"is\", \"a\"]) == {'test': 2, 'only': 1}\n\n    [/EXAMPLES]\n    \"\"\"\n    # Convert ignored words to lowercase for case-insensitive comparison\n    ignored_words = set(word.lower() for word in ignored_words)\n\n    # Use regex to split the text into words\n    words = re.findall(r'\\b\\w+\\b', text.lower())\n\n    # Initialize a dictionary to store word frequencies\n    frequency = {}\n\n    # Count the frequency of each word, excluding ignored words\n    for word in words:\n        if word not in ignored_words:\n            frequency[word] = frequency.get(word, 0) + 1\n\n    return frequency\n\n", "test": "def check(candidate):\n    assert candidate(\"The the THE tHe ThE\", [\"the\"]) == {}\n    assert candidate(\"Hello world!\", [\"hello\"]) == {'world': 1}\n    assert candidate(\"!@#$%^&*()_+\", []) == {'_': 1}\n    assert candidate(\"To be or not to be, that is the question.\", [\"to\", \"be\", \"or\", \"the\"]) == {'not': 1, 'that': 1, 'is': 1, 'question': 1}\n    assert candidate(\"\", []) == {}\n    assert candidate(\"This is a test. This is only a test.\", [\"this\", \"is\", \"a\"]) == {'test': 2, 'only': 1}\n    assert candidate(\"To be or not to be\", []) == {'to': 2, 'be': 2, 'or': 1, 'not': 1}\n    assert candidate(\"supercalifragilisticexpialidocious\", [\"supercalifragilisticexpialidocious\"]) == {}\n    assert candidate(\"A B C D E F G\", [\"a\", \"b\", \"c\", \"d\", \"e\", \"f\", \"g\"]) == {}\n    assert candidate(\"a b c a b c a b c\", [\"b\"]) == {'a': 3, 'c': 3}\n", "language": "python"}
{"task_id": "409e0986-8069-48f9-87b4-4379a7139fe0-2297192756377824129", "prompt": "I'll implement the rest of the function following the specifications in the docstring. The complete code will be in a single block.\n\n```python\nfrom typing import List, Tuple\n\ndef quantum_entanglement(particles: List[Tuple[int, int]]) -> List[List[int]]:\n    \"\"\"\n    In a quantum physics experiment, you are studying the entanglement of particles. Each particle has two \n    properties: spin and charge. Particles with the same spin or charge are considered entangled. Your task is \n    to group the entangled particles together.\n\n    The function takes one parameter:\n    - particles: A list of tuples, where each tuple contains two integers representing a particle's spin and charge.\n\n    The function should return a list of lists, where each inner list contains the indices of entangled particles.\n\n    Rules for entanglement:\n    1. Particles with the same spin OR the same charge are entangled.\n    2. Entanglement is transitive: if A is entangled with B, and B is entangled with C, then A is also entangled with C.\n    3. Each particle should appear in exactly one group.\n    4. Groups should be sorted by the lowest index particle they contain, and particles within a group should be sorted by their index.\n\n\n    [EXAMPLES]\n    \n    assert candidate([(1, 1), (1, 2), (1, 3), (2, 1), (2, 2), (2, 3)]) == [[0, 1, 2, 3, 4, 5]]\n    assert candidate([(100, 200), (200, 300), (300, 400), (400, 100)]) == [[0], [1], [2], [3]]\n\n    [/EXAMPLES]\n    \"\"\"\n```\n", "entry_point": "quantum_entanglement", "solution": "from typing import List, Tuple\n\ndef quantum_entanglement(particles: List[Tuple[int, int]]) -> List[List[int]]:\n    \"\"\"\n    In a quantum physics experiment, you are studying the entanglement of particles. Each particle has two \n    properties: spin and charge. Particles with the same spin or charge are considered entangled. Your task is \n    to group the entangled particles together.\n\n    The function takes one parameter:\n    - particles: A list of tuples, where each tuple contains two integers representing a particle's spin and charge.\n\n    The function should return a list of lists, where each inner list contains the indices of entangled particles.\n\n    Rules for entanglement:\n    1. Particles with the same spin OR the same charge are entangled.\n    2. Entanglement is transitive: if A is entangled with B, and B is entangled with C, then A is also entangled with C.\n    3. Each particle should appear in exactly one group.\n    4. Groups should be sorted by the lowest index particle they contain, and particles within a group should be sorted by their index.\n\n\n    [EXAMPLES]\n    \n    assert candidate([(1, 1), (1, 2), (1, 3), (2, 1), (2, 2), (2, 3)]) == [[0, 1, 2, 3, 4, 5]]\n    assert candidate([(100, 200), (200, 300), (300, 400), (400, 100)]) == [[0], [1], [2], [3]]\n\n    [/EXAMPLES]\n    \"\"\"\n    def find(x):\n        if parent[x] != x:\n            parent[x] = find(parent[x])\n        return parent[x]\n\n    def union(x, y):\n        px, py = find(x), find(y)\n        if px != py:\n            if rank[px] < rank[py]:\n                parent[px] = py\n            elif rank[px] > rank[py]:\n                parent[py] = px\n            else:\n                parent[py] = px\n                rank[px] += 1\n\n    n = len(particles)\n    parent = list(range(n))\n    rank = [0] * n\n\n    # Group particles by spin and charge\n    spin_groups = {}\n    charge_groups = {}\n    for i, (spin, charge) in enumerate(particles):\n        if spin in spin_groups:\n            union(i, spin_groups[spin])\n        else:\n            spin_groups[spin] = i\n        \n        if charge in charge_groups:\n            union(i, charge_groups[charge])\n        else:\n            charge_groups[charge] = i\n\n    # Create groups of entangled particles\n    groups = {}\n    for i in range(n):\n        root = find(i)\n        if root not in groups:\n            groups[root] = []\n        groups[root].append(i)\n\n    # Sort groups and particles within groups\n    result = sorted(groups.values(), key=lambda g: min(g))\n    return [sorted(group) for group in result]\n\n", "test": "def check(candidate):\n    assert candidate([(-1, -1), (-1, 1), (1, -1), (1, 1)]) == [[0, 1, 2, 3]]\n    assert candidate([(1, 1), (2, 2), (3, 3), (4, 4), (5, 5), (1, 2), (2, 3), (3, 4), (4, 5), (5, 1)]) == [[0, 1, 2, 3, 4, 5, 6, 7, 8, 9]]\n    assert candidate([(100, 200), (200, 300), (300, 400), (400, 100)]) == [[0], [1], [2], [3]]\n    assert candidate([(1, 1), (1, 2), (1, 3), (2, 1), (2, 2), (2, 3)]) == [[0, 1, 2, 3, 4, 5]]\n    assert candidate([(1, 1), (2, 2), (1, 2), (2, 1)]) == [[0, 1, 2, 3]]\n    assert candidate([(0, 0), (0, 1), (1, 0), (1, 1)]) == [[0, 1, 2, 3]]\n    assert candidate([(10, 10), (20, 20), (30, 30), (10, 20), (20, 30), (30, 10)]) == [[0, 1, 2, 3, 4, 5]]\n    assert candidate([(1, 2), (3, 4), (5, 6), (7, 8), (9, 10)]) == [[0], [1], [2], [3], [4]]\n    assert candidate([(1, 1)]) == [[0]]\n    assert candidate([(0, 0), (1, 1), (2, 2), (3, 3), (4, 4)]) == [[0], [1], [2], [3], [4]]\n", "language": "python"}
{"task_id": "40ffbf53-bfad-4673-953b-a378f9473afc5626331098050177584", "prompt": "Based on the docstring, I'll write the complete implementation of the function. The code will be in one block, and I'll maintain the existing function name and parameters.\n\n```python\nfrom typing import List, Dict\nfrom collections import defaultdict\nfrom collections import Counter\nfrom typing import List\n\ndef analyze_genetic_variations(dna_sequences: List[str]) -> Dict[str, int]:\n    \"\"\"In a genetic research lab, scientists are studying DNA sequences from various individuals\n    to identify genetic variations. They need a tool to efficiently analyze these sequences and\n    count the occurrences of specific patterns.\n\n    This function takes a list of DNA sequences as input and returns a dictionary containing\n    the count of each unique subsequence of length 3 (codon) found in the sequences.\n\n\n    [EXAMPLES]\n    \n    assert candidate([\"ATCG\" * 100]) == {'ATC': 100, 'TCG': 100, 'CGA': 99, 'GAT': 99}\n    assert candidate([\"ATCGATCGATCG\", \"GATCGATCGATC\", \"TCGATCGATCGA\"]) == {'ATC': 8, 'TCG': 8, 'CGA': 7, 'GAT': 7}\n\n    [/EXAMPLES]\n    \"\"\"\n```\n", "entry_point": "analyze_genetic_variations", "solution": "from typing import List, Dict\nfrom collections import defaultdict\nfrom collections import Counter\nfrom typing import List\n\ndef analyze_genetic_variations(dna_sequences: List[str]) -> Dict[str, int]:\n    \"\"\"In a genetic research lab, scientists are studying DNA sequences from various individuals\n    to identify genetic variations. They need a tool to efficiently analyze these sequences and\n    count the occurrences of specific patterns.\n\n    This function takes a list of DNA sequences as input and returns a dictionary containing\n    the count of each unique subsequence of length 3 (codon) found in the sequences.\n\n\n    [EXAMPLES]\n    \n    assert candidate([\"ATCG\" * 100]) == {'ATC': 100, 'TCG': 100, 'CGA': 99, 'GAT': 99}\n    assert candidate([\"ATCGATCGATCG\", \"GATCGATCGATC\", \"TCGATCGATCGA\"]) == {'ATC': 8, 'TCG': 8, 'CGA': 7, 'GAT': 7}\n\n    [/EXAMPLES]\n    \"\"\"\n    codon_count = defaultdict(int)\n    \n    for sequence in dna_sequences:\n        for i in range(len(sequence) - 2):\n            codon = sequence[i:i+3]\n            codon_count[codon] += 1\n    \n    return dict(codon_count)\n\n", "test": "def check(candidate):\n    assert candidate([\"AAAAAAAAAA\", \"TTTTTTTTTT\"]) == {'AAA': 8, 'TTT': 8}\n    assert candidate([]) == {}\n    assert candidate([\"ATCG\" * 10, \"GATC\" * 10, \"CGAT\" * 10, \"TCGA\" * 10]) == {'ATC': 38, 'TCG': 38, 'CGA': 38, 'GAT': 38}\n    assert candidate([\"ATATATATATAT\", \"CGCGCGCGCGCG\"]) == {'ATA': 5, 'TAT': 5, 'CGC': 5, 'GCG': 5}\n    assert candidate([\"AT\", \"CG\", \"TA\", \"GC\"]) == {}\n    assert candidate([\"ATCG\" * 100]) == {'ATC': 100, 'TCG': 100, 'CGA': 99, 'GAT': 99}\n    assert candidate([\"ATCGATCG\", \"ATCGATCG\", \"ATCGATCG\"]) == {'ATC': 6, 'TCG': 6, 'CGA': 3, 'GAT': 3}\n    assert candidate([\"\"]) == {}\n    assert candidate([\"ATCGATCGATCG\", \"GATCGATCGATC\", \"TCGATCGATCGA\"]) == {'ATC': 8, 'TCG': 8, 'CGA': 7, 'GAT': 7}\n    assert candidate([\"ATCG\" * 250, \"GATC\" * 250]) == {'ATC': 500, 'TCG': 499, 'CGA': 498, 'GAT': 499}\n", "language": "python"}
{"task_id": "0289d325-4418-4043-96f1-42c66a5f6ded471185869855337340", "prompt": "I'm a coding assistant focused on completing functions that are ready to run. I'll provide code only within the function boundaries without external code. I'll use exclusively the libraries mentioned in the import statements of the problem. Any auxiliary functions or classes needed will be defined inside the main function I'm completing.\n\n```python\ndef calculate_solar_power(panel_area: float, efficiency: float, sunlight_hours: float) -> float:\n    \"\"\"\n    Calculate the daily power output of a solar panel system based on its area, efficiency, and sunlight hours.\n\n    This function uses the concepts of area calculation and energy conversion to determine\n    the power output of a solar panel system. It assumes an average solar irradiance of 1000 W/m\u00b2.\n\n    Parameters:\n    panel_area (float): The total area of the solar panels in square meters.\n    efficiency (float): The efficiency of the solar panels as a decimal (e.g., 0.15 for 15% efficiency).\n    sunlight_hours (float): The average number of peak sunlight hours per day.\n\n    Returns:\n    float: The estimated daily power output in kilowatt-hours (kWh).\n\n\n    [EXAMPLES]\n    \n    assert candidate(40, 0.19, 6.8) == 51.68\n    assert candidate(100, 0.25, 8) == 200.0\n\n    [/EXAMPLES]\n    \"\"\"\n```\n", "entry_point": "calculate_solar_power", "solution": "def calculate_solar_power(panel_area: float, efficiency: float, sunlight_hours: float) -> float:\n    \"\"\"\n    Calculate the daily power output of a solar panel system based on its area, efficiency, and sunlight hours.\n\n    This function uses the concepts of area calculation and energy conversion to determine\n    the power output of a solar panel system. It assumes an average solar irradiance of 1000 W/m\u00b2.\n\n    Parameters:\n    panel_area (float): The total area of the solar panels in square meters.\n    efficiency (float): The efficiency of the solar panels as a decimal (e.g., 0.15 for 15% efficiency).\n    sunlight_hours (float): The average number of peak sunlight hours per day.\n\n    Returns:\n    float: The estimated daily power output in kilowatt-hours (kWh).\n\n\n    [EXAMPLES]\n    \n    assert candidate(40, 0.19, 6.8) == 51.68\n    assert candidate(100, 0.25, 8) == 200.0\n\n    [/EXAMPLES]\n    \"\"\"\n    # Solar irradiance constant (W/m\u00b2)\n    SOLAR_IRRADIANCE = 1000\n\n    # Calculate the power output\n    power_output = panel_area * efficiency * SOLAR_IRRADIANCE * sunlight_hours\n\n    # Convert from watt-hours to kilowatt-hours\n    power_output_kwh = power_output / 1000\n\n    return power_output_kwh\n\n", "test": "def check(candidate):\n    assert candidate(40, 0.19, 6.8) == 51.68\n    assert candidate(150, 0.23, 8.7) == 300.15\n    assert candidate(0.001, 0.01, 0.1) == 1e-06\n    assert candidate(2.5, 0.08, 4.2) == 0.84\n    assert candidate(5.5, 0.12, 3.7) == 2.4419999999999997\n    assert candidate(0, 0.15, 5) == 0.0\n    assert candidate(1, 0.1, 1) == 0.1\n    assert candidate(100, 0.25, 8) == 200.0\n    assert candidate(200, 0.28, 9.5) == 532.0000000000001\n    assert candidate(15.75, 0.17, 6.2) == 16.6005\n", "language": "python"}
{"task_id": "7a13f1bb-eb17-4ec9-9223-e968f78b47e1-372129781310691825", "prompt": "Your implementation should be contained entirely within the function provided, as a single executable code block. Do not write any code outside of this function. Use only the libraries that have been imported in the problem statement. Define any supporting functions or classes inside the main function itself.\n\n```python\nfrom typing import List\nimport re\n\ndef decode_alien_message(message: str, codebook: List[str]) -> str:\n    \"\"\"\n    A cryptographer working for SETI (Search for Extraterrestrial Intelligence) has\n    intercepted a strange message believed to be from an alien civilization. The message\n    is encoded using an unknown substitution cipher. Luckily, the cryptographer has also\n    obtained a partial codebook that maps some alien words to their English equivalents.\n\n    This function attempts to decode the alien message using the provided codebook.\n\n    Parameters:\n    message (str): The encoded alien message.\n    codebook (List[str]): A list of strings where each string is in the format \"alien_word:english_word\".\n\n    Returns:\n    str: The partially decoded message, with known words translated to English and unknown words left as is.\n\n\n    [EXAMPLES]\n    \n    assert candidate(\"red green blue\", [\"red:rouge\", \"green:vert\", \"blue:bleu\"]) == 'rouge vert bleu'\n    assert candidate(\"lorem ipsum dolor sit amet\", [\"lorem:Lorem\", \"ipsum:Ipsum\", \"dolor:Dolor\", \"sit:Sit\", \"amet:Amet\"]) == 'Lorem Ipsum Dolor Sit Amet'\n\n    [/EXAMPLES]\n    \"\"\"\n```\n", "entry_point": "decode_alien_message", "solution": "from typing import List\nimport re\n\ndef decode_alien_message(message: str, codebook: List[str]) -> str:\n    \"\"\"\n    A cryptographer working for SETI (Search for Extraterrestrial Intelligence) has\n    intercepted a strange message believed to be from an alien civilization. The message\n    is encoded using an unknown substitution cipher. Luckily, the cryptographer has also\n    obtained a partial codebook that maps some alien words to their English equivalents.\n\n    This function attempts to decode the alien message using the provided codebook.\n\n    Parameters:\n    message (str): The encoded alien message.\n    codebook (List[str]): A list of strings where each string is in the format \"alien_word:english_word\".\n\n    Returns:\n    str: The partially decoded message, with known words translated to English and unknown words left as is.\n\n\n    [EXAMPLES]\n    \n    assert candidate(\"red green blue\", [\"red:rouge\", \"green:vert\", \"blue:bleu\"]) == 'rouge vert bleu'\n    assert candidate(\"lorem ipsum dolor sit amet\", [\"lorem:Lorem\", \"ipsum:Ipsum\", \"dolor:Dolor\", \"sit:Sit\", \"amet:Amet\"]) == 'Lorem Ipsum Dolor Sit Amet'\n\n    [/EXAMPLES]\n    \"\"\"\n    # Create a dictionary from the codebook\n    translation_dict = dict(entry.split(':') for entry in codebook)\n    \n    # Split the message into words\n    words = message.split()\n    \n    # Translate each word if it's in the codebook, otherwise leave it as is\n    translated_words = [translation_dict.get(word, word) for word in words]\n    \n    # Join the translated words back into a string\n    decoded_message = ' '.join(translated_words)\n    \n    return decoded_message\n\n", "test": "def check(candidate):\n    assert candidate(\"sun moon stars\", [\"sun:soleil\", \"moon:lune\", \"stars:\u00e9toiles\"]) == 'soleil lune \u00e9toiles'\n    assert candidate(\"gloop zork bloop flub\", [\"zork:earth\", \"bloop:is\", \"flub:beautiful\"]) == 'gloop earth is beautiful'\n    assert candidate(\"abc def ghi\", [\"abc:123\", \"def:456\", \"ghi:789\"]) == '123 456 789'\n    assert candidate(\"lorem ipsum dolor sit amet\", [\"lorem:Lorem\", \"ipsum:Ipsum\", \"dolor:Dolor\", \"sit:Sit\", \"amet:Amet\"]) == 'Lorem Ipsum Dolor Sit Amet'\n    assert candidate(\"aa bb cc dd ee\", [\"aa:11\", \"bb:22\", \"cc:33\", \"dd:44\", \"ee:55\"]) == '11 22 33 44 55'\n    assert candidate(\"red green blue\", [\"red:rouge\", \"green:vert\", \"blue:bleu\"]) == 'rouge vert bleu'\n    assert candidate(\"hello hello world world\", [\"hello:bonjour\", \"world:monde\"]) == 'bonjour bonjour monde monde'\n    assert candidate(\"the quick brown fox\", [\"the:le\", \"quick:rapide\", \"brown:brun\", \"fox:renard\"]) == 'le rapide brun renard'\n    assert candidate(\"foo bar baz qux\", [\"foo:1\", \"bar:2\", \"baz:3\", \"qux:4\"]) == '1 2 3 4'\n    assert candidate(\"foo bar baz\", [\"foo:hello\", \"baz:world\"]) == 'hello bar world'\n", "language": "python"}
{"task_id": "476b85c1-f1df-4dd0-b4ab-e29c32cbc9f9-3481057210500423610", "prompt": "Write the complete implementation of the function following the documentation comment. Provide your solution in one code block, with appropriate handling of edge cases.\n\n```python\ndef encode_message(message: str, key: str) -> str:\n    \"\"\"\n    A secret agent needs to encode a message using a special cipher.\n    This function takes a message and a key, and returns the encoded message.\n    \n    The encoding process involves XORing each character of the message with the corresponding character of the key.\n    If the key is shorter than the message, it is repeated cyclically.\n    \n    Parameters:\n    message (str): The message to be encoded.\n    key (str): The key used for encoding.\n    \n    Returns:\n    str: The encoded message as a hexadecimal string.\n    \n\n    [EXAMPLES]\n    \n    assert candidate(\"Aa Bb Cc Dd\", \"Xx Yy Zz\") == '1919001b1b001919783c44'\n    assert candidate(\"ShortMessage\", \"VeryLongKey\" * 100) == '050d1d0b38220b1438041e33'\n\n    [/EXAMPLES]\n    \"\"\"\n```\n", "entry_point": "encode_message", "solution": "def encode_message(message: str, key: str) -> str:\n    \"\"\"\n    A secret agent needs to encode a message using a special cipher.\n    This function takes a message and a key, and returns the encoded message.\n    \n    The encoding process involves XORing each character of the message with the corresponding character of the key.\n    If the key is shorter than the message, it is repeated cyclically.\n    \n    Parameters:\n    message (str): The message to be encoded.\n    key (str): The key used for encoding.\n    \n    Returns:\n    str: The encoded message as a hexadecimal string.\n    \n\n    [EXAMPLES]\n    \n    assert candidate(\"Aa Bb Cc Dd\", \"Xx Yy Zz\") == '1919001b1b001919783c44'\n    assert candidate(\"ShortMessage\", \"VeryLongKey\" * 100) == '050d1d0b38220b1438041e33'\n\n    [/EXAMPLES]\n    \"\"\"\n    def xor_bytes(a, b):\n        return bytes([x ^ y for x, y in zip(a, b)])\n\n    # Convert message and key to bytes\n    message_bytes = message.encode('utf-8')\n    key_bytes = key.encode('utf-8')\n\n    # Repeat the key to match the length of the message\n    repeated_key = (key_bytes * (len(message_bytes) // len(key_bytes) + 1))[:len(message_bytes)]\n\n    # XOR the message with the repeated key\n    encoded_bytes = xor_bytes(message_bytes, repeated_key)\n\n    # Convert the result to a hexadecimal string\n    return encoded_bytes.hex()\n\n", "test": "def check(candidate):\n    assert candidate(\"TabTest\\t\", \"Tab\\tKey\") == '0000005d2e160d5d'\n    assert candidate(\"OpenAI\", \"KEY\") == '04353c250410'\n    assert candidate(\"LongMessage\" * 100, \"ShortKey\") == '1f070115392e160a320f0a3e1b250234361b1c13132e29163d0f22170738041e3624001c1306000a2009081738240b1e1e0d1c01152c00353c06083f11381618340d231d1a2c281c201b0e1511070a1734250a01072a021c1f070115392e160a320f0a3e1b250234361b1c13132e29163d0f22170738041e3624001c1306000a2009081738240b1e1e0d1c01152c00353c06083f11381618340d231d1a2c281c201b0e1511070a1734250a01072a021c1f070115392e160a320f0a3e1b250234361b1c13132e29163d0f22170738041e3624001c1306000a2009081738240b1e1e0d1c01152c00353c06083f11381618340d231d1a2c281c201b0e1511070a1734250a01072a021c1f070115392e160a320f0a3e1b250234361b1c13132e29163d0f22170738041e3624001c1306000a2009081738240b1e1e0d1c01152c00353c06083f11381618340d231d1a2c281c201b0e1511070a1734250a01072a021c1f070115392e160a320f0a3e1b250234361b1c13132e29163d0f22170738041e3624001c1306000a2009081738240b1e1e0d1c01152c00353c06083f11381618340d231d1a2c281c201b0e1511070a1734250a01072a021c1f070115392e160a320f0a3e1b250234361b1c13132e29163d0f22170738041e3624001c1306000a2009081738240b1e1e0d1c01152c00353c06083f11381618340d231d1a2c281c201b0e1511070a1734250a01072a021c1f070115392e160a320f0a3e1b250234361b1c13132e29163d0f22170738041e3624001c1306000a2009081738240b1e1e0d1c01152c00353c06083f11381618340d231d1a2c281c201b0e1511070a1734250a01072a021c1f070115392e160a320f0a3e1b250234361b1c13132e29163d0f22170738041e3624001c1306000a2009081738240b1e1e0d1c01152c00353c06083f11381618340d231d1a2c281c201b0e1511070a1734250a01072a021c1f070115392e160a320f0a3e1b250234361b1c13132e29163d0f22170738041e3624001c1306000a2009081738240b1e1e0d1c01152c00353c06083f11381618340d231d1a2c281c201b0e1511070a1734250a01072a021c1f070115392e160a320f0a3e1b250234361b1c13132e29163d0f22170738041e3624001c1306000a2009081738240b1e1e0d1c01152c00353c06083f11381618340d231d1a2c281c201b0e1511070a1734250a01072a021c1f070115392e160a320f0a3e1b250234361b1c13132e29163d0f22170738041e3624001c1306000a2009081738240b1e1e0d1c01152c00353c06083f11381618340d231d1a2c281c201b0e1511070a1734250a01072a021c1f070115392e160a320f0a3e1b250234361b1c13132e29163d0f22170738041e3624001c1306000a2009081738240b1e1e0d1c01152c00353c06083f11381618340d231d1a2c281c201b0e1511070a1734250a01072a021c1f070115392e160a320f0a3e1b250234361b1c13132e29163d0f22170738041e3624001c1306000a20090817'\n    assert candidate(\"ShortMessage\", \"VeryLongKey\" * 100) == '050d1d0b38220b1438041e33'\n    assert candidate(\"EndWithNewline\\n\", \"KeyWithoutNewline\") == '0e0b1d00000000211003220c190963'\n    assert candidate(\"  Spaces  \", \"NoSpaces\") == '6e4f0000000000006e4f'\n    assert candidate(\"\", \"EMPTY\") == ''\n    assert candidate(\"Aa Bb Cc Dd\", \"Xx Yy Zz\") == '1919001b1b001919783c44'\n    assert candidate(\"SpecialChars: .,;'[]\", \"!@#$%^&*()\") == '723046474c3f4a694048533319040b721d0d7374'\n    assert candidate(\"Hello, World!\", \"SECRET\") == '1b202f3e2a7873122c20293072'\n", "language": "python"}
{"task_id": "af39449f-4285-4309-a3cb-7e162f13fb0b-5239806542402660104", "prompt": "I'll finish writing this function per the documentation string. The complete implementation will be provided in a single code block, with the function name and arguments preserved exactly as given.\n\n```python\nfrom typing import List\nfrom typing import List, Tuple\n\ndef analyze_stock_prices(prices: List[int]) -> Tuple[int, int, int]:\n    \"\"\"\n    Analyzes a list of daily stock prices to find the best days to buy and sell for maximum profit.\n    This function uses list traversal and comparison operations.\n\n    Args:\n    prices (List[int]): A list of daily stock prices.\n\n    Returns:\n    Tuple[int, int, int]: A tuple containing the buy day, sell day, and maximum profit.\n\n\n    [EXAMPLES]\n    \n    assert candidate([7, 6, 4, 3, 1]) == (1, 1, 0)\n    assert candidate([1, 2, 3, 4, 5]) == (1, 5, 4)\n\n    [/EXAMPLES]\n    \"\"\"\n```\n", "entry_point": "analyze_stock_prices", "solution": "from typing import List\nfrom typing import List, Tuple\n\ndef analyze_stock_prices(prices: List[int]) -> Tuple[int, int, int]:\n    \"\"\"\n    Analyzes a list of daily stock prices to find the best days to buy and sell for maximum profit.\n    This function uses list traversal and comparison operations.\n\n    Args:\n    prices (List[int]): A list of daily stock prices.\n\n    Returns:\n    Tuple[int, int, int]: A tuple containing the buy day, sell day, and maximum profit.\n\n\n    [EXAMPLES]\n    \n    assert candidate([7, 6, 4, 3, 1]) == (1, 1, 0)\n    assert candidate([1, 2, 3, 4, 5]) == (1, 5, 4)\n\n    [/EXAMPLES]\n    \"\"\"\n    if not prices or len(prices) < 2:\n        return (1, 1, 0)\n\n    max_profit = 0\n    buy_day = 1\n    sell_day = 1\n    min_price = float('inf')\n    min_price_day = 1\n\n    for current_day, price in enumerate(prices, 1):\n        if price < min_price:\n            min_price = price\n            min_price_day = current_day\n        \n        current_profit = price - min_price\n        if current_profit > max_profit:\n            max_profit = current_profit\n            buy_day = min_price_day\n            sell_day = current_day\n\n    return (buy_day, sell_day, max_profit)\n\n", "test": "def check(candidate):\n    assert candidate([3, 2, 6, 5, 0, 3]) == (2, 3, 4)\n    assert candidate([2, 1, 2, 1, 0, 1, 2]) == (5, 7, 2)\n    assert candidate([2, 4, 1]) == (1, 2, 2)\n    assert candidate([1, 2, 1, 2, 1]) == (1, 2, 1)\n    assert candidate([100, 1]) == (1, 1, 0)\n    assert candidate([7, 6, 4, 3, 1]) == (1, 1, 0)\n    assert candidate([1, 2, 3, 4, 5]) == (1, 5, 4)\n    assert candidate([5, 4, 3, 2, 1]) == (1, 1, 0)\n    assert candidate([1, 2, 3, 4, 5, 4, 3, 2, 1]) == (1, 5, 4)\n    assert candidate([3, 3, 5, 0, 0, 3, 1, 4]) == (4, 8, 4)\n", "language": "python"}
{"task_id": "ec2847d3-617d-4ce5-9ab4-ff74d8be41b3-1177262061531117306", "prompt": "I'm a coding assistant that completes executable functions. I will write code only within the provided function boundaries. I'll utilize just the libraries that are already imported in the problem statement. When additional functionality is needed, I'll define any helper functions or classes inside the main function.\n\n```python\nfrom typing import List\n\ndef calculate_leap_years(start_year: int, end_year: int) -> List[int]:\n    \"\"\"\n    Calculate the leap years between two given years (inclusive).\n\n    This function takes two years as input and returns a list of all\n    leap years between them. A leap year is divisible by 4, except for\n    century years, which must be divisible by 400 to be a leap year.\n    The function uses basic arithmetic operations and list comprehension.\n\n\n    [EXAMPLES]\n    \n    assert candidate(1800, 1900) == [1804, 1808, 1812, 1816, 1820, 1824, 1828, 1832, 1836, 1840, 1844, 1848, 1852, 1856, 1860, 1864, 1868, 1872, 1876, 1880, 1884, 1888, 1892, 1896]\n    assert candidate(1900, 1920) == [1904, 1908, 1912, 1916, 1920]\n\n    [/EXAMPLES]\n    \"\"\"\n```\n", "entry_point": "calculate_leap_years", "solution": "from typing import List\n\ndef calculate_leap_years(start_year: int, end_year: int) -> List[int]:\n    \"\"\"\n    Calculate the leap years between two given years (inclusive).\n\n    This function takes two years as input and returns a list of all\n    leap years between them. A leap year is divisible by 4, except for\n    century years, which must be divisible by 400 to be a leap year.\n    The function uses basic arithmetic operations and list comprehension.\n\n\n    [EXAMPLES]\n    \n    assert candidate(1800, 1900) == [1804, 1808, 1812, 1816, 1820, 1824, 1828, 1832, 1836, 1840, 1844, 1848, 1852, 1856, 1860, 1864, 1868, 1872, 1876, 1880, 1884, 1888, 1892, 1896]\n    assert candidate(1900, 1920) == [1904, 1908, 1912, 1916, 1920]\n\n    [/EXAMPLES]\n    \"\"\"\n    def is_leap_year(year: int) -> bool:\n        \"\"\"Helper function to determine if a year is a leap year.\"\"\"\n        return year % 4 == 0 and (year % 100 != 0 or year % 400 == 0)\n\n    return [year for year in range(start_year, end_year + 1) if is_leap_year(year)]\n\n", "test": "def check(candidate):\n    assert candidate(1, 1) == []\n    assert candidate(2100, 2200) == [2104, 2108, 2112, 2116, 2120, 2124, 2128, 2132, 2136, 2140, 2144, 2148, 2152, 2156, 2160, 2164, 2168, 2172, 2176, 2180, 2184, 2188, 2192, 2196]\n    assert candidate(1800, 1900) == [1804, 1808, 1812, 1816, 1820, 1824, 1828, 1832, 1836, 1840, 1844, 1848, 1852, 1856, 1860, 1864, 1868, 1872, 1876, 1880, 1884, 1888, 1892, 1896]\n    assert candidate(1600, 1700) == [1600, 1604, 1608, 1612, 1616, 1620, 1624, 1628, 1632, 1636, 1640, 1644, 1648, 1652, 1656, 1660, 1664, 1668, 1672, 1676, 1680, 1684, 1688, 1692, 1696]\n    assert candidate(2019, 2020) == [2020]\n    assert candidate(2020, 2020) == [2020]\n    assert candidate(1900, 1920) == [1904, 1908, 1912, 1916, 1920]\n    assert candidate(0, 4) == [0, 4]\n    assert candidate(2000, 2001) == [2000]\n    assert candidate(1, 2023) == [4, 8, 12, 16, 20, 24, 28, 32, 36, 40, 44, 48, 52, 56, 60, 64, 68, 72, 76, 80, 84, 88, 92, 96, 104, 108, 112, 116, 120, 124, 128, 132, 136, 140, 144, 148, 152, 156, 160, 164, 168, 172, 176, 180, 184, 188, 192, 196, 204, 208, 212, 216, 220, 224, 228, 232, 236, 240, 244, 248, 252, 256, 260, 264, 268, 272, 276, 280, 284, 288, 292, 296, 304, 308, 312, 316, 320, 324, 328, 332, 336, 340, 344, 348, 352, 356, 360, 364, 368, 372, 376, 380, 384, 388, 392, 396, 400, 404, 408, 412, 416, 420, 424, 428, 432, 436, 440, 444, 448, 452, 456, 460, 464, 468, 472, 476, 480, 484, 488, 492, 496, 504, 508, 512, 516, 520, 524, 528, 532, 536, 540, 544, 548, 552, 556, 560, 564, 568, 572, 576, 580, 584, 588, 592, 596, 604, 608, 612, 616, 620, 624, 628, 632, 636, 640, 644, 648, 652, 656, 660, 664, 668, 672, 676, 680, 684, 688, 692, 696, 704, 708, 712, 716, 720, 724, 728, 732, 736, 740, 744, 748, 752, 756, 760, 764, 768, 772, 776, 780, 784, 788, 792, 796, 800, 804, 808, 812, 816, 820, 824, 828, 832, 836, 840, 844, 848, 852, 856, 860, 864, 868, 872, 876, 880, 884, 888, 892, 896, 904, 908, 912, 916, 920, 924, 928, 932, 936, 940, 944, 948, 952, 956, 960, 964, 968, 972, 976, 980, 984, 988, 992, 996, 1004, 1008, 1012, 1016, 1020, 1024, 1028, 1032, 1036, 1040, 1044, 1048, 1052, 1056, 1060, 1064, 1068, 1072, 1076, 1080, 1084, 1088, 1092, 1096, 1104, 1108, 1112, 1116, 1120, 1124, 1128, 1132, 1136, 1140, 1144, 1148, 1152, 1156, 1160, 1164, 1168, 1172, 1176, 1180, 1184, 1188, 1192, 1196, 1200, 1204, 1208, 1212, 1216, 1220, 1224, 1228, 1232, 1236, 1240, 1244, 1248, 1252, 1256, 1260, 1264, 1268, 1272, 1276, 1280, 1284, 1288, 1292, 1296, 1304, 1308, 1312, 1316, 1320, 1324, 1328, 1332, 1336, 1340, 1344, 1348, 1352, 1356, 1360, 1364, 1368, 1372, 1376, 1380, 1384, 1388, 1392, 1396, 1404, 1408, 1412, 1416, 1420, 1424, 1428, 1432, 1436, 1440, 1444, 1448, 1452, 1456, 1460, 1464, 1468, 1472, 1476, 1480, 1484, 1488, 1492, 1496, 1504, 1508, 1512, 1516, 1520, 1524, 1528, 1532, 1536, 1540, 1544, 1548, 1552, 1556, 1560, 1564, 1568, 1572, 1576, 1580, 1584, 1588, 1592, 1596, 1600, 1604, 1608, 1612, 1616, 1620, 1624, 1628, 1632, 1636, 1640, 1644, 1648, 1652, 1656, 1660, 1664, 1668, 1672, 1676, 1680, 1684, 1688, 1692, 1696, 1704, 1708, 1712, 1716, 1720, 1724, 1728, 1732, 1736, 1740, 1744, 1748, 1752, 1756, 1760, 1764, 1768, 1772, 1776, 1780, 1784, 1788, 1792, 1796, 1804, 1808, 1812, 1816, 1820, 1824, 1828, 1832, 1836, 1840, 1844, 1848, 1852, 1856, 1860, 1864, 1868, 1872, 1876, 1880, 1884, 1888, 1892, 1896, 1904, 1908, 1912, 1916, 1920, 1924, 1928, 1932, 1936, 1940, 1944, 1948, 1952, 1956, 1960, 1964, 1968, 1972, 1976, 1980, 1984, 1988, 1992, 1996, 2000, 2004, 2008, 2012, 2016, 2020]\n", "language": "python"}
{"task_id": "cb1e6c04-218a-4aa6-ae4a-339f87e09a227622345210527741358", "prompt": "Kindly complete the function implementation based on the provided documentation. Please maintain the existing function signature without altering the parameter list or function name. Present your solution as a single code block.\n\n```python\nfrom typing import List\nfrom typing import List, Tuple\n\ndef gene_mutation(dna_sequence: str, mutation_points: List[Tuple[int, str]]) -> str:\n    \"\"\"\n    A biologist is studying gene mutations. Given a DNA sequence (a string of A, T, C, G)\n    and a list of mutation points, apply the mutations to the DNA sequence. Each mutation\n    point is represented by a tuple (position, new_nucleotide).\n\n    This function uses string manipulation and list comprehension to efficiently\n    apply the mutations.\n\n    Args:\n    dna_sequence (str): The original DNA sequence\n    mutation_points (List[Tuple[int, str]]): List of mutation points\n\n    Returns:\n    str: The mutated DNA sequence\n\n\n    [EXAMPLES]\n    \n    assert candidate(\"GGGGGGGGGGGG\", []) == 'GGGGGGGGGGGG'\n    assert candidate(\"ATCG\", [(1, 'G'), (3, 'T')]) == 'AGCT'\n\n    [/EXAMPLES]\n    \"\"\"\n```\n", "entry_point": "gene_mutation", "solution": "from typing import List\nfrom typing import List, Tuple\n\ndef gene_mutation(dna_sequence: str, mutation_points: List[Tuple[int, str]]) -> str:\n    \"\"\"\n    A biologist is studying gene mutations. Given a DNA sequence (a string of A, T, C, G)\n    and a list of mutation points, apply the mutations to the DNA sequence. Each mutation\n    point is represented by a tuple (position, new_nucleotide).\n\n    This function uses string manipulation and list comprehension to efficiently\n    apply the mutations.\n\n    Args:\n    dna_sequence (str): The original DNA sequence\n    mutation_points (List[Tuple[int, str]]): List of mutation points\n\n    Returns:\n    str: The mutated DNA sequence\n\n\n    [EXAMPLES]\n    \n    assert candidate(\"GGGGGGGGGGGG\", []) == 'GGGGGGGGGGGG'\n    assert candidate(\"ATCG\", [(1, 'G'), (3, 'T')]) == 'AGCT'\n\n    [/EXAMPLES]\n    \"\"\"\n    # Convert the DNA sequence to a list for easier manipulation\n    dna_list = list(dna_sequence)\n    \n    # Apply mutations using list comprehension\n    [dna_list.__setitem__(pos, nucleotide) for pos, nucleotide in mutation_points]\n    \n    # Convert the list back to a string and return\n    return ''.join(dna_list)\n\n", "test": "def check(candidate):\n    assert candidate(\"AAAAGGGGCCCCTTTT\", [(i, 'A') for i in range(16)]) == 'AAAAAAAAAAAAAAAA'\n    assert candidate(\"GGGGGGGGGGGG\", []) == 'GGGGGGGGGGGG'\n    assert candidate(\"ACGT\" * 100, [(i, 'T') for i in range(0, 400, 10)]) == 'TCGTACGTACTTACGTACGTTCGTACGTACTTACGTACGTTCGTACGTACTTACGTACGTTCGTACGTACTTACGTACGTTCGTACGTACTTACGTACGTTCGTACGTACTTACGTACGTTCGTACGTACTTACGTACGTTCGTACGTACTTACGTACGTTCGTACGTACTTACGTACGTTCGTACGTACTTACGTACGTTCGTACGTACTTACGTACGTTCGTACGTACTTACGTACGTTCGTACGTACTTACGTACGTTCGTACGTACTTACGTACGTTCGTACGTACTTACGTACGTTCGTACGTACTTACGTACGTTCGTACGTACTTACGTACGTTCGTACGTACTTACGTACGTTCGTACGTACTTACGTACGTTCGTACGTACTTACGTACGT'\n    assert candidate(\"AAAAAAAA\", [(i, 'T') for i in range(8)]) == 'TTTTTTTT'\n    assert candidate(\"ATCG\", [(1, 'G'), (3, 'T')]) == 'AGCT'\n    assert candidate(\"ATATATATATAT\", [(0, 'C'), (2, 'G'), (4, 'C'), (6, 'G'), (8, 'C'), (10, 'G')]) == 'CTGTCTGTCTGT'\n    assert candidate(\"AAAA\", []) == 'AAAA'\n    assert candidate(\"GATTACA\", [(0, 'C'), (3, 'G'), (6, 'T')]) == 'CATGACT'\n", "language": "python"}
{"task_id": "6bf5c6c2-8665-4446-892d-252586bc56b14353133883121547198", "prompt": "I'll implement the remainder of this function according to the documentation comments. The complete code will be in a single block.\n\n```python\nfrom typing import List, Dict\n\ndef decode_alien_message(transmission: str, dictionary: Dict[str, str]) -> List[str]:\n    \"\"\"An alien civilization has sent a coded message to Earth. Your task is to decode it using a partial translation dictionary.\n    The message consists of alien words separated by spaces. Some words may not have a known translation.\n\n    Take as input the alien transmission as a string and a dictionary mapping some alien words to their English translations.\n    Return a list of the decoded words, preserving the order. For unknown words, include the original alien word.\n\n\n    [EXAMPLES]\n    \n    assert candidate(\"a b c\", {\"a\": \"1\", \"b\": \"2\", \"c\": \"3\"}) == ['1', '2', '3']\n    assert candidate(\"special !@#$ characters\", {\"special\": \"normal\", \"characters\": \"letters\"}) == ['normal', '!@#$', 'letters']\n\n    [/EXAMPLES]\n    \"\"\"\n```\n", "entry_point": "decode_alien_message", "solution": "from typing import List, Dict\n\ndef decode_alien_message(transmission: str, dictionary: Dict[str, str]) -> List[str]:\n    \"\"\"An alien civilization has sent a coded message to Earth. Your task is to decode it using a partial translation dictionary.\n    The message consists of alien words separated by spaces. Some words may not have a known translation.\n\n    Take as input the alien transmission as a string and a dictionary mapping some alien words to their English translations.\n    Return a list of the decoded words, preserving the order. For unknown words, include the original alien word.\n\n\n    [EXAMPLES]\n    \n    assert candidate(\"a b c\", {\"a\": \"1\", \"b\": \"2\", \"c\": \"3\"}) == ['1', '2', '3']\n    assert candidate(\"special !@#$ characters\", {\"special\": \"normal\", \"characters\": \"letters\"}) == ['normal', '!@#$', 'letters']\n\n    [/EXAMPLES]\n    \"\"\"\n    # Split the transmission into individual words\n    alien_words = transmission.split()\n    \n    # Initialize an empty list to store the decoded words\n    decoded_message = []\n    \n    # Iterate through each word in the alien message\n    for word in alien_words:\n        # If the word is in the dictionary, add its translation\n        # Otherwise, add the original alien word\n        decoded_message.append(dictionary.get(word, word))\n    \n    return decoded_message\n\n", "test": "def check(candidate):\n    assert candidate(\"\", {}) == []\n    assert candidate(\"a b c\", {\"a\": \"1\", \"b\": \"2\", \"c\": \"3\"}) == ['1', '2', '3']\n    assert candidate(\"special !@#$ characters\", {\"special\": \"normal\", \"characters\": \"letters\"}) == ['normal', '!@#$', 'letters']\n    assert candidate(\"zorg blarg flub zorb\", {\"zorg\": \"hello\", \"flub\": \"world\"}) == ['hello', 'blarg', 'world', 'zorb']\n    assert candidate(\"all known words\", {\"all\": \"every\", \"known\": \"familiar\", \"words\": \"terms\"}) == ['every', 'familiar', 'terms']\n    assert candidate(\"a\" * 1000, {\"a\": \"letter_a\"}) == ['aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa']\n    assert candidate(\"a b \" * 500, {\"a\": \"first\", \"b\": \"second\"}) == ['first', 'second', 'first', 'second', 'first', 'second', 'first', 'second', 'first', 'second', 'first', 'second', 'first', 'second', 'first', 'second', 'first', 'second', 'first', 'second', 'first', 'second', 'first', 'second', 'first', 'second', 'first', 'second', 'first', 'second', 'first', 'second', 'first', 'second', 'first', 'second', 'first', 'second', 'first', 'second', 'first', 'second', 'first', 'second', 'first', 'second', 'first', 'second', 'first', 'second', 'first', 'second', 'first', 'second', 'first', 'second', 'first', 'second', 'first', 'second', 'first', 'second', 'first', 'second', 'first', 'second', 'first', 'second', 'first', 'second', 'first', 'second', 'first', 'second', 'first', 'second', 'first', 'second', 'first', 'second', 'first', 'second', 'first', 'second', 'first', 'second', 'first', 'second', 'first', 'second', 'first', 'second', 'first', 'second', 'first', 'second', 'first', 'second', 'first', 'second', 'first', 'second', 'first', 'second', 'first', 'second', 'first', 'second', 'first', 'second', 'first', 'second', 'first', 'second', 'first', 'second', 'first', 'second', 'first', 'second', 'first', 'second', 'first', 'second', 'first', 'second', 'first', 'second', 'first', 'second', 'first', 'second', 'first', 'second', 'first', 'second', 'first', 'second', 'first', 'second', 'first', 'second', 'first', 'second', 'first', 'second', 'first', 'second', 'first', 'second', 'first', 'second', 'first', 'second', 'first', 'second', 'first', 'second', 'first', 'second', 'first', 'second', 'first', 'second', 'first', 'second', 'first', 'second', 'first', 'second', 'first', 'second', 'first', 'second', 'first', 'second', 'first', 'second', 'first', 'second', 'first', 'second', 'first', 'second', 'first', 'second', 'first', 'second', 'first', 'second', 'first', 'second', 'first', 'second', 'first', 'second', 'first', 'second', 'first', 'second', 'first', 'second', 'first', 'second', 'first', 'second', 'first', 'second', 'first', 'second', 'first', 'second', 'first', 'second', 'first', 'second', 'first', 'second', 'first', 'second', 'first', 'second', 'first', 'second', 'first', 'second', 'first', 'second', 'first', 'second', 'first', 'second', 'first', 'second', 'first', 'second', 'first', 'second', 'first', 'second', 'first', 'second', 'first', 'second', 'first', 'second', 'first', 'second', 'first', 'second', 'first', 'second', 'first', 'second', 'first', 'second', 'first', 'second', 'first', 'second', 'first', 'second', 'first', 'second', 'first', 'second', 'first', 'second', 'first', 'second', 'first', 'second', 'first', 'second', 'first', 'second', 'first', 'second', 'first', 'second', 'first', 'second', 'first', 'second', 'first', 'second', 'first', 'second', 'first', 'second', 'first', 'second', 'first', 'second', 'first', 'second', 'first', 'second', 'first', 'second', 'first', 'second', 'first', 'second', 'first', 'second', 'first', 'second', 'first', 'second', 'first', 'second', 'first', 'second', 'first', 'second', 'first', 'second', 'first', 'second', 'first', 'second', 'first', 'second', 'first', 'second', 'first', 'second', 'first', 'second', 'first', 'second', 'first', 'second', 'first', 'second', 'first', 'second', 'first', 'second', 'first', 'second', 'first', 'second', 'first', 'second', 'first', 'second', 'first', 'second', 'first', 'second', 'first', 'second', 'first', 'second', 'first', 'second', 'first', 'second', 'first', 'second', 'first', 'second', 'first', 'second', 'first', 'second', 'first', 'second', 'first', 'second', 'first', 'second', 'first', 'second', 'first', 'second', 'first', 'second', 'first', 'second', 'first', 'second', 'first', 'second', 'first', 'second', 'first', 'second', 'first', 'second', 'first', 'second', 'first', 'second', 'first', 'second', 'first', 'second', 'first', 'second', 'first', 'second', 'first', 'second', 'first', 'second', 'first', 'second', 'first', 'second', 'first', 'second', 'first', 'second', 'first', 'second', 'first', 'second', 'first', 'second', 'first', 'second', 'first', 'second', 'first', 'second', 'first', 'second', 'first', 'second', 'first', 'second', 'first', 'second', 'first', 'second', 'first', 'second', 'first', 'second', 'first', 'second', 'first', 'second', 'first', 'second', 'first', 'second', 'first', 'second', 'first', 'second', 'first', 'second', 'first', 'second', 'first', 'second', 'first', 'second', 'first', 'second', 'first', 'second', 'first', 'second', 'first', 'second', 'first', 'second', 'first', 'second', 'first', 'second', 'first', 'second', 'first', 'second', 'first', 'second', 'first', 'second', 'first', 'second', 'first', 'second', 'first', 'second', 'first', 'second', 'first', 'second', 'first', 'second', 'first', 'second', 'first', 'second', 'first', 'second', 'first', 'second', 'first', 'second', 'first', 'second', 'first', 'second', 'first', 'second', 'first', 'second', 'first', 'second', 'first', 'second', 'first', 'second', 'first', 'second', 'first', 'second', 'first', 'second', 'first', 'second', 'first', 'second', 'first', 'second', 'first', 'second', 'first', 'second', 'first', 'second', 'first', 'second', 'first', 'second', 'first', 'second', 'first', 'second', 'first', 'second', 'first', 'second', 'first', 'second', 'first', 'second', 'first', 'second', 'first', 'second', 'first', 'second', 'first', 'second', 'first', 'second', 'first', 'second', 'first', 'second', 'first', 'second', 'first', 'second', 'first', 'second', 'first', 'second', 'first', 'second', 'first', 'second', 'first', 'second', 'first', 'second', 'first', 'second', 'first', 'second', 'first', 'second', 'first', 'second', 'first', 'second', 'first', 'second', 'first', 'second', 'first', 'second', 'first', 'second', 'first', 'second', 'first', 'second', 'first', 'second', 'first', 'second', 'first', 'second', 'first', 'second', 'first', 'second', 'first', 'second', 'first', 'second', 'first', 'second', 'first', 'second', 'first', 'second', 'first', 'second', 'first', 'second', 'first', 'second', 'first', 'second', 'first', 'second', 'first', 'second', 'first', 'second', 'first', 'second', 'first', 'second', 'first', 'second', 'first', 'second', 'first', 'second', 'first', 'second', 'first', 'second', 'first', 'second', 'first', 'second', 'first', 'second', 'first', 'second', 'first', 'second', 'first', 'second', 'first', 'second', 'first', 'second', 'first', 'second', 'first', 'second', 'first', 'second', 'first', 'second', 'first', 'second', 'first', 'second', 'first', 'second', 'first', 'second', 'first', 'second', 'first', 'second', 'first', 'second', 'first', 'second', 'first', 'second', 'first', 'second', 'first', 'second', 'first', 'second', 'first', 'second', 'first', 'second', 'first', 'second', 'first', 'second', 'first', 'second', 'first', 'second', 'first', 'second', 'first', 'second', 'first', 'second', 'first', 'second', 'first', 'second', 'first', 'second', 'first', 'second', 'first', 'second', 'first', 'second', 'first', 'second', 'first', 'second', 'first', 'second', 'first', 'second', 'first', 'second', 'first', 'second', 'first', 'second', 'first', 'second', 'first', 'second', 'first', 'second', 'first', 'second', 'first', 'second', 'first', 'second', 'first', 'second', 'first', 'second', 'first', 'second', 'first', 'second', 'first', 'second', 'first', 'second', 'first', 'second', 'first', 'second', 'first', 'second', 'first', 'second', 'first', 'second', 'first', 'second', 'first', 'second', 'first', 'second', 'first', 'second', 'first', 'second', 'first', 'second', 'first', 'second', 'first', 'second', 'first', 'second', 'first', 'second', 'first', 'second', 'first', 'second', 'first', 'second', 'first', 'second', 'first', 'second', 'first', 'second', 'first', 'second', 'first', 'second', 'first', 'second', 'first', 'second', 'first', 'second', 'first', 'second', 'first', 'second', 'first', 'second', 'first', 'second', 'first', 'second', 'first', 'second', 'first', 'second', 'first', 'second', 'first', 'second', 'first', 'second', 'first', 'second', 'first', 'second', 'first', 'second', 'first', 'second', 'first', 'second', 'first', 'second', 'first', 'second', 'first', 'second', 'first', 'second', 'first', 'second', 'first', 'second', 'first', 'second', 'first', 'second', 'first', 'second', 'first', 'second', 'first', 'second', 'first', 'second', 'first', 'second', 'first', 'second', 'first', 'second', 'first', 'second', 'first', 'second', 'first', 'second', 'first', 'second', 'first', 'second', 'first', 'second', 'first', 'second', 'first', 'second', 'first', 'second', 'first', 'second', 'first', 'second', 'first', 'second', 'first', 'second', 'first', 'second', 'first', 'second', 'first', 'second', 'first', 'second', 'first', 'second', 'first', 'second', 'first', 'second', 'first', 'second', 'first', 'second', 'first', 'second', 'first', 'second', 'first', 'second', 'first', 'second', 'first', 'second', 'first', 'second', 'first', 'second', 'first', 'second', 'first', 'second', 'first', 'second', 'first', 'second', 'first', 'second', 'first', 'second', 'first', 'second', 'first', 'second', 'first', 'second', 'first', 'second', 'first', 'second', 'first', 'second', 'first', 'second', 'first', 'second', 'first', 'second', 'first', 'second', 'first', 'second', 'first', 'second', 'first', 'second', 'first', 'second', 'first', 'second', 'first', 'second', 'first', 'second', 'first', 'second', 'first', 'second', 'first', 'second', 'first', 'second', 'first', 'second', 'first', 'second', 'first', 'second']\n    assert candidate(\"mixed CASE wOrDs\", {\"mixed\": \"uniform\", \"CASE\": \"style\"}) == ['uniform', 'style', 'wOrDs']\n    assert candidate(\"single\", {\"single\": \"word\"}) == ['word']\n    assert candidate(\"gloop bleep fleep gloop\", {\"gloop\": \"start\", \"fleep\": \"end\"}) == ['start', 'bleep', 'end', 'start']\n", "language": "python"}
{"task_id": "9a73578d-f80a-4c8d-89d6-7e41e41ec0dd7496796011881175586", "prompt": "Working as your coding assistant, I'll complete the specified function to be execution-ready. I'll stay within the function code block, use only the imported libraries, and nest any supporting functions or classes inside the main function.\n\n```python\nfrom typing import List, Tuple\n\ndef optimize_warehouse(items: List[Tuple[str, int, int]]) -> List[Tuple[str, int]]:\n    \"\"\"\n    A warehouse manager needs to optimize the storage of items based on their popularity and size.\n    Each item has a name, popularity score (1-100), and size (in cubic meters).\n    The goal is to arrange items so that more popular items are easier to access.\n\n    The function should return a list of tuples containing the item name and its optimal shelf number,\n    where lower shelf numbers are more accessible.\n\n    The optimization should consider both popularity and size, giving priority to items with\n    higher popularity-to-size ratios.\n\n\n    [EXAMPLES]\n    \n    assert candidate([(\"Plate\", 60, 1), (\"Bowl\", 65, 1), (\"Cup\", 70, 1), (\"Utensils\", 75, 1)]) == [('Utensils', 1), ('Cup', 2), ('Bowl', 3), ('Plate', 4)]\n    assert candidate([(\"Phone\", 95, 1), (\"Tablet\", 80, 2), (\"Laptop\", 85, 3), (\"Smartwatch\", 75, 1)]) == [('Phone', 1), ('Smartwatch', 2), ('Tablet', 3), ('Laptop', 4)]\n\n    [/EXAMPLES]\n    \"\"\"\n```\n", "entry_point": "optimize_warehouse", "solution": "from typing import List, Tuple\n\ndef optimize_warehouse(items: List[Tuple[str, int, int]]) -> List[Tuple[str, int]]:\n    \"\"\"\n    A warehouse manager needs to optimize the storage of items based on their popularity and size.\n    Each item has a name, popularity score (1-100), and size (in cubic meters).\n    The goal is to arrange items so that more popular items are easier to access.\n\n    The function should return a list of tuples containing the item name and its optimal shelf number,\n    where lower shelf numbers are more accessible.\n\n    The optimization should consider both popularity and size, giving priority to items with\n    higher popularity-to-size ratios.\n\n\n    [EXAMPLES]\n    \n    assert candidate([(\"Plate\", 60, 1), (\"Bowl\", 65, 1), (\"Cup\", 70, 1), (\"Utensils\", 75, 1)]) == [('Utensils', 1), ('Cup', 2), ('Bowl', 3), ('Plate', 4)]\n    assert candidate([(\"Phone\", 95, 1), (\"Tablet\", 80, 2), (\"Laptop\", 85, 3), (\"Smartwatch\", 75, 1)]) == [('Phone', 1), ('Smartwatch', 2), ('Tablet', 3), ('Laptop', 4)]\n\n    [/EXAMPLES]\n    \"\"\"\n    def calculate_priority(item: Tuple[str, int, int]) -> float:\n        \"\"\"Calculate the priority of an item based on its popularity-to-size ratio.\"\"\"\n        _, popularity, size = item\n        return popularity / size\n\n    # Sort items based on their priority (popularity-to-size ratio) in descending order\n    sorted_items = sorted(items, key=calculate_priority, reverse=True)\n\n    # Assign shelf numbers to items\n    optimized_arrangement = [(item[0], shelf_num + 1) for shelf_num, item in enumerate(sorted_items)]\n\n    return optimized_arrangement\n\n", "test": "def check(candidate):\n    assert candidate([(\"Toothbrush\", 80, 1), (\"Toothpaste\", 75, 1), (\"Floss\", 70, 1), (\"Mouthwash\", 65, 2)]) == [('Toothbrush', 1), ('Toothpaste', 2), ('Floss', 3), ('Mouthwash', 4)]\n    assert candidate([(\"Keyboard\", 85, 2), (\"Mouse\", 90, 1), (\"Monitor\", 80, 5), (\"Speakers\", 75, 3)]) == [('Mouse', 1), ('Keyboard', 2), ('Speakers', 3), ('Monitor', 4)]\n    assert candidate([(\"Toy\", 85, 2), (\"Game\", 90, 3), (\"Puzzle\", 75, 1), (\"Doll\", 80, 2)]) == [('Puzzle', 1), ('Toy', 2), ('Doll', 3), ('Game', 4)]\n    assert candidate([(\"Pencil\", 90, 1), (\"Desk\", 70, 10), (\"Computer\", 85, 5), (\"Notebook\", 75, 2)]) == [('Pencil', 1), ('Notebook', 2), ('Computer', 3), ('Desk', 4)]\n    assert candidate([(\"Pillow\", 70, 3), (\"Blanket\", 75, 5), (\"Sheet\", 65, 2), (\"Duvet\", 60, 6)]) == [('Sheet', 1), ('Pillow', 2), ('Blanket', 3), ('Duvet', 4)]\n    assert candidate([(\"Plate\", 60, 1), (\"Bowl\", 65, 1), (\"Cup\", 70, 1), (\"Utensils\", 75, 1)]) == [('Utensils', 1), ('Cup', 2), ('Bowl', 3), ('Plate', 4)]\n    assert candidate([(\"Helmet\", 90, 3), (\"Gloves\", 85, 1), (\"Jacket\", 80, 5), (\"Boots\", 75, 4)]) == [('Gloves', 1), ('Helmet', 2), ('Boots', 3), ('Jacket', 4)]\n    assert candidate([(\"Phone\", 95, 1), (\"Tablet\", 80, 2), (\"Laptop\", 85, 3), (\"Smartwatch\", 75, 1)]) == [('Phone', 1), ('Smartwatch', 2), ('Tablet', 3), ('Laptop', 4)]\n    assert candidate([(\"Camera\", 75, 2), (\"Tripod\", 65, 3), (\"Lens\", 70, 1), (\"Memory Card\", 80, 1)]) == [('Memory Card', 1), ('Lens', 2), ('Camera', 3), ('Tripod', 4)]\n    assert candidate([(\"Fork\", 60, 1), (\"Spoon\", 60, 1), (\"Knife\", 60, 1), (\"Chopsticks\", 55, 1)]) == [('Fork', 1), ('Spoon', 2), ('Knife', 3), ('Chopsticks', 4)]\n", "language": "python"}
{"task_id": "3e132387-0e31-4e7f-939d-47803f6270184768023120519899478", "prompt": "Please complete the function implementation based on the provided documentation string. Present the entire code block with your implementation.\n\n```python\nfrom typing import List, Tuple\nfrom collections import defaultdict\n\ndef analyze_dna_sequences(sequences: List[str]) -> Tuple[dict, List[Tuple[str, str]]]:\n    \"\"\"\n    Analyze a list of DNA sequences to find common subsequences and complementary pairs.\n\n    This function utilizes defaultdict for efficient counting and list comprehension\n    for generating complementary pairs. It processes multiple DNA sequences to identify\n    frequently occurring subsequences and potential complementary strands.\n\n    Args:\n    sequences (List[str]): A list of DNA sequences to analyze.\n\n    Returns:\n    Tuple[dict, List[Tuple[str, str]]]: A tuple containing:\n        1. A dictionary of common subsequences (length 3) and their frequencies.\n        2. A list of tuples representing complementary sequence pairs.\n\n\n    [EXAMPLES]\n    \n    assert candidate([\"ATCGATCG\", \"CGATATCG\", \"TCGATCGA\", \"ATCGATCG\"]) == ({'ATC': 6, 'TCG': 7, 'CGA': 5, 'GAT': 4, 'ATA': 1, 'TAT': 1}, [])\n    assert candidate([\"ATCG\", \"GCTA\", \"TACG\", \"CGAT\", \"ATGC\", \"GCAT\"]) == ({'ATC': 1, 'TCG': 1, 'GCT': 1, 'CTA': 1, 'TAC': 1, 'ACG': 1, 'CGA': 1, 'GAT': 1, 'ATG': 1, 'TGC': 1, 'GCA': 1, 'CAT': 1}, [('GCTA', 'CGAT'), ('TACG', 'ATGC')])\n\n    [/EXAMPLES]\n    \"\"\"\n```\n", "entry_point": "analyze_dna_sequences", "solution": "from typing import List, Tuple\nfrom collections import defaultdict\n\ndef analyze_dna_sequences(sequences: List[str]) -> Tuple[dict, List[Tuple[str, str]]]:\n    \"\"\"\n    Analyze a list of DNA sequences to find common subsequences and complementary pairs.\n\n    This function utilizes defaultdict for efficient counting and list comprehension\n    for generating complementary pairs. It processes multiple DNA sequences to identify\n    frequently occurring subsequences and potential complementary strands.\n\n    Args:\n    sequences (List[str]): A list of DNA sequences to analyze.\n\n    Returns:\n    Tuple[dict, List[Tuple[str, str]]]: A tuple containing:\n        1. A dictionary of common subsequences (length 3) and their frequencies.\n        2. A list of tuples representing complementary sequence pairs.\n\n\n    [EXAMPLES]\n    \n    assert candidate([\"ATCGATCG\", \"CGATATCG\", \"TCGATCGA\", \"ATCGATCG\"]) == ({'ATC': 6, 'TCG': 7, 'CGA': 5, 'GAT': 4, 'ATA': 1, 'TAT': 1}, [])\n    assert candidate([\"ATCG\", \"GCTA\", \"TACG\", \"CGAT\", \"ATGC\", \"GCAT\"]) == ({'ATC': 1, 'TCG': 1, 'GCT': 1, 'CTA': 1, 'TAC': 1, 'ACG': 1, 'CGA': 1, 'GAT': 1, 'ATG': 1, 'TGC': 1, 'GCA': 1, 'CAT': 1}, [('GCTA', 'CGAT'), ('TACG', 'ATGC')])\n\n    [/EXAMPLES]\n    \"\"\"\n    def complement(sequence):\n        \"\"\"Generate the complement of a DNA sequence.\"\"\"\n        complement_dict = {'A': 'T', 'T': 'A', 'C': 'G', 'G': 'C'}\n        return ''.join(complement_dict[base] for base in sequence)\n\n    # Count subsequences\n    subsequence_counts = defaultdict(int)\n    for sequence in sequences:\n        for i in range(len(sequence) - 2):\n            subsequence = sequence[i:i+3]\n            subsequence_counts[subsequence] += 1\n\n    # Find complementary pairs\n    complementary_pairs = [\n        (seq1, seq2) for i, seq1 in enumerate(sequences)\n        for seq2 in sequences[i+1:]\n        if complement(seq1) == seq2\n    ]\n\n    return dict(subsequence_counts), complementary_pairs\n\n", "test": "def check(candidate):\n    assert candidate([\"ATCG\", \"TCGA\", \"CGAT\", \"GATC\"]) == ({'ATC': 2, 'TCG': 2, 'CGA': 2, 'GAT': 2}, [])\n    assert candidate([\"ATCG\", \"GCTA\", \"TACG\", \"CGAT\"]) == ({'ATC': 1, 'TCG': 1, 'GCT': 1, 'CTA': 1, 'TAC': 1, 'ACG': 1, 'CGA': 1, 'GAT': 1}, [('GCTA', 'CGAT')])\n    assert candidate([\"AAAAA\", \"TTTTT\", \"CCCCC\", \"GGGGG\"]) == ({'AAA': 3, 'TTT': 3, 'CCC': 3, 'GGG': 3}, [('AAAAA', 'TTTTT'), ('CCCCC', 'GGGGG')])\n    assert candidate([\"AAAAAAAAAAAA\", \"TTTTTTTTTTTT\", \"CCCCCCCCCCCC\", \"GGGGGGGGGGGG\"]) == ({'AAA': 10, 'TTT': 10, 'CCC': 10, 'GGG': 10}, [('AAAAAAAAAAAA', 'TTTTTTTTTTTT'), ('CCCCCCCCCCCC', 'GGGGGGGGGGGG')])\n    assert candidate([\"A\", \"T\", \"C\", \"G\"]) == ({}, [('A', 'T'), ('C', 'G')])\n    assert candidate([\"ATCG\", \"CGAT\", \"TAGC\", \"GCTA\", \"TGCA\", \"ACGT\"]) == ({'ATC': 1, 'TCG': 1, 'CGA': 1, 'GAT': 1, 'TAG': 1, 'AGC': 1, 'GCT': 1, 'CTA': 1, 'TGC': 1, 'GCA': 1, 'ACG': 1, 'CGT': 1}, [('ATCG', 'TAGC'), ('CGAT', 'GCTA'), ('TGCA', 'ACGT')])\n    assert candidate([\"ATCGATCG\", \"CGATATCG\", \"TCGATCGA\", \"ATCGATCG\"]) == ({'ATC': 6, 'TCG': 7, 'CGA': 5, 'GAT': 4, 'ATA': 1, 'TAT': 1}, [])\n    assert candidate([\"A\", \"AT\", \"ATC\", \"ATCG\", \"ATCGA\"]) == ({'ATC': 3, 'TCG': 2, 'CGA': 1}, [])\n    assert candidate([\"ATCG\", \"GCTA\", \"TACG\", \"CGAT\", \"ATGC\", \"GCAT\"]) == ({'ATC': 1, 'TCG': 1, 'GCT': 1, 'CTA': 1, 'TAC': 1, 'ACG': 1, 'CGA': 1, 'GAT': 1, 'ATG': 1, 'TGC': 1, 'GCA': 1, 'CAT': 1}, [('GCTA', 'CGAT'), ('TACG', 'ATGC')])\n    assert candidate([\"AT\", \"CG\", \"TA\", \"GC\"]) == ({}, [('AT', 'TA'), ('CG', 'GC')])\n", "language": "python"}
{"task_id": "b8f1762e-4641-4e9a-8888-70e8b18e6e95-2692431209938498555", "prompt": "To complete the provided code, I would need to see the existing code first. Please share the code snippet you'd like me to complete, and I'll provide the full implementation within a single code block.\n\n```python\nfrom typing import List\n\ndef desert_oasis(water_sources: List[int], settlements: int) -> int:\n    \"\"\"\n    In a desert region, there are several water sources with different capacities. The government wants to establish settlements near these sources. Each settlement must have its own water source, and the goal is to maximize the water supply for the least-served settlement.\n\n    Parameters:\n    water_sources (List[int]): A list of integers representing the capacity of each water source.\n    settlements (int): The number of settlements to be established.\n\n    Returns:\n    int: The maximum capacity that can be guaranteed for each settlement.\n\n\n    [EXAMPLES]\n    \n    assert candidate([10], 1) == 10\n    assert candidate([1, 2, 3, 4, 5], 5) == 1\n\n    [/EXAMPLES]\n    \"\"\"\n```\n", "entry_point": "desert_oasis", "solution": "from typing import List\n\ndef desert_oasis(water_sources: List[int], settlements: int) -> int:\n    \"\"\"\n    In a desert region, there are several water sources with different capacities. The government wants to establish settlements near these sources. Each settlement must have its own water source, and the goal is to maximize the water supply for the least-served settlement.\n\n    Parameters:\n    water_sources (List[int]): A list of integers representing the capacity of each water source.\n    settlements (int): The number of settlements to be established.\n\n    Returns:\n    int: The maximum capacity that can be guaranteed for each settlement.\n\n\n    [EXAMPLES]\n    \n    assert candidate([10], 1) == 10\n    assert candidate([1, 2, 3, 4, 5], 5) == 1\n\n    [/EXAMPLES]\n    \"\"\"\n    def can_distribute(capacity: int) -> bool:\n        return sum(1 for source in water_sources if source >= capacity) >= settlements\n\n    left, right = 1, max(water_sources)\n    result = 0\n\n    while left <= right:\n        mid = (left + right) // 2\n        if can_distribute(mid):\n            result = mid\n            left = mid + 1\n        else:\n            right = mid - 1\n\n    return result\n\n", "test": "def check(candidate):\n    assert candidate([100, 100, 100, 100, 100], 5) == 100\n    assert candidate([10], 1) == 10\n    assert candidate([2, 4, 6, 8, 10, 12, 14], 5) == 6\n    assert candidate([1, 2, 3, 4, 5], 5) == 1\n    assert candidate([1, 1, 1, 1, 1], 5) == 1\n    assert candidate([1000000, 2000000, 3000000], 3) == 1000000\n    assert candidate([1, 3, 5, 7, 9, 11, 13, 15], 6) == 5\n    assert candidate([5, 10, 15, 20, 25, 30], 4) == 15\n    assert candidate([7, 14, 21, 28, 35], 3) == 21\n    assert candidate([100, 200, 300, 400, 500], 4) == 200\n", "language": "python"}
{"task_id": "e377ea21-3698-42d1-b53c-3a649dfde35c-221448903404693894", "prompt": "Implement the function body according to what the docstring describes. Keep the original function signature intact.\n\n```python\nfrom typing import List\nimport heapq\n\ndef optimize_delivery_route(cities: int, roads: List[List[int]], start: int, end: int) -> List[int]:\n    \"\"\"As a logistics manager, you need to optimize the delivery route between two cities in a country.\n\n    The country has 'cities' number of cities, numbered from 0 to cities-1. The 'roads' list represents the \n    bidirectional connections between cities, where each road is given as [city1, city2, distance].\n\n    Your task is to find the shortest path from the 'start' city to the 'end' city, considering that some roads \n    might be closed due to construction or other issues.\n\n    Implement Dijkstra's algorithm with a priority queue to solve this problem efficiently. If there's no valid \n    path between the start and end cities, return an empty list.\n\n    Args:\n    cities (int): The total number of cities in the country.\n    roads (List[List[int]]): A list of roads connecting cities and their distances.\n    start (int): The starting city for the delivery route.\n    end (int): The destination city for the delivery route.\n\n    Returns:\n    List[int]: The shortest path from start to end city. Return an empty list if no path exists.\n\n\n    [EXAMPLES]\n    \n    assert candidate(7, [[0,1,1],[1,2,1],[2,3,1],[3,4,1],[4,5,1],[5,6,1]], 0, 6) == [0, 1, 2, 3, 4, 5, 6]\n    assert candidate(4, [[0,1,1],[1,2,1],[2,3,1],[0,3,2]], 0, 3) == [0, 3]\n\n    [/EXAMPLES]\n    \"\"\"\n```\n", "entry_point": "optimize_delivery_route", "solution": "from typing import List\nimport heapq\n\ndef optimize_delivery_route(cities: int, roads: List[List[int]], start: int, end: int) -> List[int]:\n    \"\"\"As a logistics manager, you need to optimize the delivery route between two cities in a country.\n\n    The country has 'cities' number of cities, numbered from 0 to cities-1. The 'roads' list represents the \n    bidirectional connections between cities, where each road is given as [city1, city2, distance].\n\n    Your task is to find the shortest path from the 'start' city to the 'end' city, considering that some roads \n    might be closed due to construction or other issues.\n\n    Implement Dijkstra's algorithm with a priority queue to solve this problem efficiently. If there's no valid \n    path between the start and end cities, return an empty list.\n\n    Args:\n    cities (int): The total number of cities in the country.\n    roads (List[List[int]]): A list of roads connecting cities and their distances.\n    start (int): The starting city for the delivery route.\n    end (int): The destination city for the delivery route.\n\n    Returns:\n    List[int]: The shortest path from start to end city. Return an empty list if no path exists.\n\n\n    [EXAMPLES]\n    \n    assert candidate(7, [[0,1,1],[1,2,1],[2,3,1],[3,4,1],[4,5,1],[5,6,1]], 0, 6) == [0, 1, 2, 3, 4, 5, 6]\n    assert candidate(4, [[0,1,1],[1,2,1],[2,3,1],[0,3,2]], 0, 3) == [0, 3]\n\n    [/EXAMPLES]\n    \"\"\"\n    # Create an adjacency list to represent the graph\n    graph = [[] for _ in range(cities)]\n    for city1, city2, distance in roads:\n        graph[city1].append((city2, distance))\n        graph[city2].append((city1, distance))\n    \n    # Initialize distances and previous nodes\n    distances = [float('inf')] * cities\n    distances[start] = 0\n    previous = [-1] * cities\n    \n    # Priority queue to store (distance, node) pairs\n    pq = [(0, start)]\n    \n    while pq:\n        current_distance, current_city = heapq.heappop(pq)\n        \n        # If we've reached the end city, we can stop\n        if current_city == end:\n            break\n        \n        # If we've found a longer path to the current city, skip it\n        if current_distance > distances[current_city]:\n            continue\n        \n        # Check all neighboring cities\n        for neighbor, weight in graph[current_city]:\n            distance = current_distance + weight\n            \n            # If we've found a shorter path to the neighbor\n            if distance < distances[neighbor]:\n                distances[neighbor] = distance\n                previous[neighbor] = current_city\n                heapq.heappush(pq, (distance, neighbor))\n    \n    # Reconstruct the path\n    if distances[end] == float('inf'):\n        return []  # No path exists\n    \n    path = []\n    current = end\n    while current != -1:\n        path.append(current)\n        current = previous[current]\n    \n    return path[::-1]  # Reverse the path to get start to end\n\n", "test": "def check(candidate):\n    assert candidate(6, [[0,1,1],[1,2,1],[2,3,1],[3,4,1],[4,5,1],[0,5,10]], 0, 5) == [0, 1, 2, 3, 4, 5]\n    assert candidate(5, [[0,1,1],[1,2,1],[2,3,1],[3,4,1],[0,2,2],[1,3,2],[2,4,2]], 0, 4) == [0, 2, 4]\n    assert candidate(4, [[0,1,1],[1,2,1],[2,3,1]], 0, 3) == [0, 1, 2, 3]\n    assert candidate(4, [[0,1,1],[1,2,1],[2,3,1],[0,3,2]], 0, 3) == [0, 3]\n    assert candidate(5, [[0,1,10],[1,2,20],[2,3,30],[3,4,40],[0,4,100]], 0, 4) == [0, 4]\n    assert candidate(3, [], 0, 2) == []\n    assert candidate(7, [[0,1,1],[1,2,1],[2,3,1],[3,4,1],[4,5,1],[5,6,1]], 0, 6) == [0, 1, 2, 3, 4, 5, 6]\n    assert candidate(3, [[0,1,1],[1,2,1]], 0, 1) == [0, 1]\n    assert candidate(4, [[0,1,10],[1,2,10],[2,3,10],[0,3,5]], 0, 3) == [0, 3]\n    assert candidate(6, [[0,1,1],[1,2,1],[2,3,1],[3,4,1],[4,5,1],[0,3,3],[1,4,3],[2,5,3]], 0, 5) == [0, 1, 2, 5]\n", "language": "python"}
{"task_id": "bb1ca402-6b9a-4866-8d48-3640cf0727b03986613710513486767", "prompt": "I'm your coding assistant. When you share a function to complete, I'll ensure my solution works within that function's scope, using only the imported libraries. If I need additional functionality, I'll define those functions or classes inside your main function.\n\n```python\nfrom typing import List, Tuple\n\ndef find_equilibrium_index(temperatures: List[float]) -> Tuple[int, float]:\n    \"\"\"\n    A climatologist is analyzing temperature data from various weather stations along a coast.\n    This function finds the \"equilibrium index\" where the average temperature to the left equals the average to the right.\n\n    Parameters:\n    temperatures (List[float]): A list of temperature readings from weather stations.\n\n    Returns:\n    Tuple[int, float]: A tuple containing the equilibrium index and the average temperature at that point.\n                       If no equilibrium index exists, returns (-1, 0.0).\n\n\n    [EXAMPLES]\n    \n    assert candidate([1.0, 2.0, 3.0, 6.0, 3.0, 2.0, 1.0]) == (3, 6.0)\n    assert candidate([10.0, 10.0]) == (-1, 0.0)\n\n    [/EXAMPLES]\n    \"\"\"\n```\n", "entry_point": "find_equilibrium_index", "solution": "from typing import List, Tuple\n\ndef find_equilibrium_index(temperatures: List[float]) -> Tuple[int, float]:\n    \"\"\"\n    A climatologist is analyzing temperature data from various weather stations along a coast.\n    This function finds the \"equilibrium index\" where the average temperature to the left equals the average to the right.\n\n    Parameters:\n    temperatures (List[float]): A list of temperature readings from weather stations.\n\n    Returns:\n    Tuple[int, float]: A tuple containing the equilibrium index and the average temperature at that point.\n                       If no equilibrium index exists, returns (-1, 0.0).\n\n\n    [EXAMPLES]\n    \n    assert candidate([1.0, 2.0, 3.0, 6.0, 3.0, 2.0, 1.0]) == (3, 6.0)\n    assert candidate([10.0, 10.0]) == (-1, 0.0)\n\n    [/EXAMPLES]\n    \"\"\"\n    if not temperatures:\n        return (-1, 0.0)\n\n    total_sum = sum(temperatures)\n    left_sum = 0\n    \n    for i, temp in enumerate(temperatures):\n        right_sum = total_sum - left_sum - temp\n        \n        left_count = i\n        right_count = len(temperatures) - i - 1\n        \n        if left_count == 0:\n            left_avg = 0\n        else:\n            left_avg = left_sum / left_count\n        \n        if right_count == 0:\n            right_avg = 0\n        else:\n            right_avg = right_sum / right_count\n        \n        if abs(left_avg - right_avg) < 1e-10:  # Using a small epsilon for float comparison\n            return (i, temp)\n        \n        left_sum += temp\n    \n    return (-1, 0.0)\n\n", "test": "def check(candidate):\n    assert candidate([1.0, 2.0, 3.0, 6.0, 3.0, 2.0, 1.0]) == (3, 6.0)\n    assert candidate([10.0, 10.0]) == (-1, 0.0)\n    assert candidate([25.0]) == (0, 25.0)\n    assert candidate([1.0, 3.0, 5.0, 7.0, 5.0, 3.0, 1.0]) == (3, 7.0)\n    assert candidate([100.0, 50.0, 25.0, 12.5, 6.25]) == (-1, 0.0)\n    assert candidate([15.2, 17.8, 16.5, 18.1, 17.3, 19.2, 20.5]) == (-1, 0.0)\n    assert candidate([20.0, 20.0, 20.0, 20.0, 20.0, 20.0, 20.0]) == (1, 20.0)\n    assert candidate([5.0, 5.0, 5.0]) == (1, 5.0)\n    assert candidate([]) == (-1, 0.0)\n    assert candidate([10.5, 11.2, 12.7, 13.4]) == (-1, 0.0)\n", "language": "python"}
{"task_id": "5592f68e-7c51-4a45-9f52-429f747620e05471451014750392781", "prompt": "Please complete the function as specified in the docstring. Provide the entire implementation within a single code block, keeping the function name and parameters unchanged.\n\n```python\ndef calculate_factorial(n: int) -> int:\n    \"\"\"\n    As a mathematics teacher, you want to create a function to help students understand factorials.\n\n    This function calculates the factorial of a given non-negative integer n. The factorial of n (denoted as n!) is the product of all positive integers less than or equal to n.\n    If the input is negative, raise a ValueError with an appropriate message.\n\n\n    [EXAMPLES]\n    \n    assert candidate(0) == 1\n    assert candidate(20) == 2432902008176640000\n\n    [/EXAMPLES]\n    \"\"\"\n```\n", "entry_point": "calculate_factorial", "solution": "def calculate_factorial(n: int) -> int:\n    \"\"\"\n    As a mathematics teacher, you want to create a function to help students understand factorials.\n\n    This function calculates the factorial of a given non-negative integer n. The factorial of n (denoted as n!) is the product of all positive integers less than or equal to n.\n    If the input is negative, raise a ValueError with an appropriate message.\n\n\n    [EXAMPLES]\n    \n    assert candidate(0) == 1\n    assert candidate(20) == 2432902008176640000\n\n    [/EXAMPLES]\n    \"\"\"\n    if n < 0:\n        raise ValueError(\"Factorial is not defined for negative numbers.\")\n    \n    if n == 0 or n == 1:\n        return 1\n    \n    result = 1\n    for i in range(2, n + 1):\n        result *= i\n    \n    return result\n\n", "test": "def check(candidate):\n    assert candidate(2) == 2\n    assert candidate(20) == 2432902008176640000\n    assert candidate(3) == 6\n    assert candidate(0) == 1\n    assert candidate(8) == 40320\n    assert candidate(13) == 6227020800\n    assert candidate(12) == 479001600\n    assert candidate(1) == 1\n", "language": "python"}
{"task_id": "d2c867d8-1b65-4b67-b211-3c7b858bb2d8-2702382136224566131", "prompt": "I'll complete the given function so it's ready for direct execution. Any additional functions or classes will be defined inside the main function. I'll only use libraries that are already imported in the problem.\n\n```python\nfrom collections import deque\nfrom typing import List\n\ndef binary_maze_solver(maze: List[List[int]]) -> int:\n    \"\"\"\n    In a cutting-edge AI research lab, scientists are working on a maze-solving algorithm for\n    binary-coded environments. The maze is represented as a 2D grid where each cell is either\n    0 (representing a wall) or 1 (representing a path). The goal is to find the length of the\n    shortest path from the top-left corner (0, 0) to the bottom-right corner (n-1, m-1), where\n    n and m are the number of rows and columns respectively.\n\n    The algorithm can move in four directions: up, down, left, and right. Diagonal movements\n    are not allowed. If there is no valid path from start to finish, the function should return -1.\n\n    This function takes a 2D list representing the binary maze as input and returns the length\n    of the shortest path or -1 if no path exists.\n\n\n    [EXAMPLES]\n    \n    assert candidate([[1, 1, 1], [1, 0, 1], [1, 1, 0]]) == -1\n    assert candidate([[1, 0], [0, 1]]) == -1\n\n    [/EXAMPLES]\n    \"\"\"\n```\n", "entry_point": "binary_maze_solver", "solution": "from collections import deque\nfrom typing import List\n\ndef binary_maze_solver(maze: List[List[int]]) -> int:\n    \"\"\"\n    In a cutting-edge AI research lab, scientists are working on a maze-solving algorithm for\n    binary-coded environments. The maze is represented as a 2D grid where each cell is either\n    0 (representing a wall) or 1 (representing a path). The goal is to find the length of the\n    shortest path from the top-left corner (0, 0) to the bottom-right corner (n-1, m-1), where\n    n and m are the number of rows and columns respectively.\n\n    The algorithm can move in four directions: up, down, left, and right. Diagonal movements\n    are not allowed. If there is no valid path from start to finish, the function should return -1.\n\n    This function takes a 2D list representing the binary maze as input and returns the length\n    of the shortest path or -1 if no path exists.\n\n\n    [EXAMPLES]\n    \n    assert candidate([[1, 1, 1], [1, 0, 1], [1, 1, 0]]) == -1\n    assert candidate([[1, 0], [0, 1]]) == -1\n\n    [/EXAMPLES]\n    \"\"\"\n    if not maze or not maze[0]:\n        return -1\n\n    n, m = len(maze), len(maze[0])\n    \n    # Check if start and end positions are valid\n    if maze[0][0] == 0 or maze[n-1][m-1] == 0:\n        return -1\n\n    # Define possible movements: up, down, left, right\n    directions = [(-1, 0), (1, 0), (0, -1), (0, 1)]\n\n    # Initialize queue for BFS\n    queue = deque([(0, 0, 1)])  # (row, col, distance)\n    visited = set([(0, 0)])\n\n    while queue:\n        row, col, distance = queue.popleft()\n\n        # Check if we've reached the destination\n        if row == n - 1 and col == m - 1:\n            return distance\n\n        # Explore all possible directions\n        for dr, dc in directions:\n            new_row, new_col = row + dr, col + dc\n\n            # Check if the new position is valid and not visited\n            if (0 <= new_row < n and 0 <= new_col < m and\n                maze[new_row][new_col] == 1 and\n                (new_row, new_col) not in visited):\n                \n                queue.append((new_row, new_col, distance + 1))\n                visited.add((new_row, new_col))\n\n    # If we can't reach the destination\n    return -1\n\n", "test": "def check(candidate):\n    assert candidate([[1, 1, 1, 1], [1, 0, 0, 1], [1, 0, 0, 1], [1, 1, 1, 1]]) == 7\n    assert candidate([[1, 0, 1, 0, 1], [1, 0, 1, 0, 1], [1, 0, 1, 0, 1], [1, 0, 1, 0, 1], [1, 1, 1, 1, 1]]) == 9\n    assert candidate([[1, 1, 1], [1, 1, 1], [1, 1, 1]]) == 5\n    assert candidate([[1, 1, 1, 1, 1, 1], [1, 0, 0, 0, 0, 1], [1, 0, 1, 1, 0, 1], [1, 0, 1, 1, 0, 1], [1, 0, 0, 0, 0, 1], [1, 1, 1, 1, 1, 1]]) == 11\n    assert candidate([[1, 1, 1], [1, 0, 1], [1, 1, 0]]) == -1\n    assert candidate([[1, 0, 0, 0, 0], [1, 1, 1, 1, 1], [0, 0, 0, 0, 1], [1, 1, 1, 1, 1], [1, 0, 0, 0, 1]]) == 9\n    assert candidate([[1, 1, 1], [1, 0, 1], [1, 1, 1], [0, 0, 0], [1, 1, 1]]) == -1\n    assert candidate([[1, 0], [0, 1]]) == -1\n    assert candidate([[0]]) == -1\n    assert candidate([[1, 1, 1, 1, 1], [1, 0, 0, 0, 1], [1, 0, 1, 0, 1], [1, 0, 1, 0, 1], [1, 1, 1, 1, 1]]) == 9\n", "language": "python"}
{"task_id": "25d8647b-992b-4ee2-986a-9595725fb4eb-1211537552912173110", "prompt": "Your function completion will be delivered in a single, executable code block. I'll use only the libraries imported in the original problem and will nest any helper functions or classes within the main function. No additional code will appear outside the function definition. My response will contain exactly one code block.\n\n```python\nfrom typing import List, Tuple\n\ndef design_rollercoaster(heights: List[int], thrill_factor: int) -> Tuple[int, List[Tuple[int, int]]]:\n    \"\"\"\n    As an amusement park engineer, you're tasked with designing a new rollercoaster. The\n    rollercoaster track will be built on a series of support columns of varying heights.\n\n    To create an exciting ride, you need to maximize the number of thrilling drops while\n    ensuring each drop has at least the specified thrill factor. A drop is defined as the\n    difference in height between two non-adjacent support columns, where the first column\n    is taller than the second.\n\n    Parameters:\n    heights (List[int]): A list of integers representing the heights of the support columns.\n    thrill_factor (int): The minimum height difference required for a drop to be considered thrilling.\n\n    Returns:\n    Tuple[int, List[Tuple[int, int]]]: A tuple containing the maximum number of thrilling drops\n    and a list of tuples representing the indices of the start and end columns for each drop.\n\n\n    [EXAMPLES]\n    \n    assert candidate([1], 1) == (0, [])\n    assert candidate([1, 10, 1, 10, 1, 10], 9) == (1, [(1, 4)])\n\n    [/EXAMPLES]\n    \"\"\"\n```\n", "entry_point": "design_rollercoaster", "solution": "from typing import List, Tuple\n\ndef design_rollercoaster(heights: List[int], thrill_factor: int) -> Tuple[int, List[Tuple[int, int]]]:\n    \"\"\"\n    As an amusement park engineer, you're tasked with designing a new rollercoaster. The\n    rollercoaster track will be built on a series of support columns of varying heights.\n\n    To create an exciting ride, you need to maximize the number of thrilling drops while\n    ensuring each drop has at least the specified thrill factor. A drop is defined as the\n    difference in height between two non-adjacent support columns, where the first column\n    is taller than the second.\n\n    Parameters:\n    heights (List[int]): A list of integers representing the heights of the support columns.\n    thrill_factor (int): The minimum height difference required for a drop to be considered thrilling.\n\n    Returns:\n    Tuple[int, List[Tuple[int, int]]]: A tuple containing the maximum number of thrilling drops\n    and a list of tuples representing the indices of the start and end columns for each drop.\n\n\n    [EXAMPLES]\n    \n    assert candidate([1], 1) == (0, [])\n    assert candidate([1, 10, 1, 10, 1, 10], 9) == (1, [(1, 4)])\n\n    [/EXAMPLES]\n    \"\"\"\n    def find_max_drops(start: int, memo: dict) -> Tuple[int, List[Tuple[int, int]]]:\n        if start in memo:\n            return memo[start]\n        \n        max_drops = 0\n        best_drops = []\n        \n        for end in range(start + 2, len(heights)):\n            if heights[start] - heights[end] >= thrill_factor:\n                drops, drop_list = find_max_drops(end, memo)\n                if drops + 1 > max_drops:\n                    max_drops = drops + 1\n                    best_drops = [(start, end)] + drop_list\n        \n        memo[start] = (max_drops, best_drops)\n        return memo[start]\n    \n    memo = {}\n    max_total_drops = 0\n    best_total_drops = []\n    \n    for i in range(len(heights) - 2):\n        drops, drop_list = find_max_drops(i, memo)\n        if drops > max_total_drops:\n            max_total_drops = drops\n            best_total_drops = drop_list\n    \n    return (max_total_drops, best_total_drops)\n\n", "test": "def check(candidate):\n    assert candidate([1, 2, 3, 2, 1, 2, 3, 2, 1], 1) == (2, [(2, 5), (5, 8)])\n    assert candidate([20, 15, 10, 5, 1], 5) == (2, [(0, 2), (2, 4)])\n    assert candidate([], 1) == (0, [])\n    assert candidate([1, 2, 3, 4, 5, 4, 3, 2, 1], 2) == (2, [(4, 6), (6, 8)])\n    assert candidate([1], 1) == (0, [])\n    assert candidate([1, 10, 1, 10, 1, 10], 9) == (1, [(1, 4)])\n    assert candidate([100, 50, 25, 12, 6], 10) == (2, [(0, 2), (2, 4)])\n    assert candidate([100, 99, 98, 97, 96, 95], 2) == (2, [(0, 2), (2, 4)])\n    assert candidate([5, 3, 6, 2, 4, 7, 1], 3) == (1, [(0, 3)])\n    assert candidate([1, 3, 5, 7, 9, 11], 2) == (0, [])\n", "language": "python"}
{"task_id": "6a104abe-24c7-4d5e-b459-e9799c585ba61070410816837402949", "prompt": "I'll provide a completed function within a single code block, using only imported libraries and keeping all necessary definitions inside the function. Any additional helper functions or classes will be defined within the main function's scope.\n\n```python\nfrom typing import List\n\ndef calculate_pollution_spread(cities: List[int], days: int) -> List[int]:\n    \"\"\"\n    Calculate the spread of pollution across cities over a given number of days.\n\n    Each day, the pollution level of each city becomes the maximum of its own pollution\n    and the pollution of its adjacent cities. The first and last cities are not adjacent.\n\n    Args:\n    cities (List[int]): A list of integers representing the initial pollution levels of each city.\n    days (int): The number of days to simulate pollution spread.\n\n    Returns:\n    List[int]: The final pollution levels of each city after the specified number of days.\n\n\n    [EXAMPLES]\n    \n    assert candidate([5, 4, 3, 2, 1], 0) == [5, 4, 3, 2, 1]\n    assert candidate([7, 7, 7, 7, 7], 1) == [7, 7, 7, 7, 7]\n\n    [/EXAMPLES]\n    \"\"\"\n```\n", "entry_point": "calculate_pollution_spread", "solution": "from typing import List\n\ndef calculate_pollution_spread(cities: List[int], days: int) -> List[int]:\n    \"\"\"\n    Calculate the spread of pollution across cities over a given number of days.\n\n    Each day, the pollution level of each city becomes the maximum of its own pollution\n    and the pollution of its adjacent cities. The first and last cities are not adjacent.\n\n    Args:\n    cities (List[int]): A list of integers representing the initial pollution levels of each city.\n    days (int): The number of days to simulate pollution spread.\n\n    Returns:\n    List[int]: The final pollution levels of each city after the specified number of days.\n\n\n    [EXAMPLES]\n    \n    assert candidate([5, 4, 3, 2, 1], 0) == [5, 4, 3, 2, 1]\n    assert candidate([7, 7, 7, 7, 7], 1) == [7, 7, 7, 7, 7]\n\n    [/EXAMPLES]\n    \"\"\"\n    n = len(cities)\n    \n    for _ in range(days):\n        new_cities = cities.copy()\n        \n        # Update first city\n        new_cities[0] = max(cities[0], cities[1])\n        \n        # Update middle cities\n        for i in range(1, n-1):\n            new_cities[i] = max(cities[i-1], cities[i], cities[i+1])\n        \n        # Update last city\n        new_cities[-1] = max(cities[-2], cities[-1])\n        \n        cities = new_cities\n    \n    return cities\n\n", "test": "def check(candidate):\n    assert candidate([10, 0, 10, 0, 10], 5) == [10, 10, 10, 10, 10]\n    assert candidate([7, 7, 7, 7, 7], 1) == [7, 7, 7, 7, 7]\n    assert candidate([1, 2], 5) == [2, 2]\n    assert candidate([5, 3, 7, 1, 4], 3) == [7, 7, 7, 7, 7]\n    assert candidate([5, 4, 3, 2, 1], 0) == [5, 4, 3, 2, 1]\n    assert candidate([1, 2, 3], 10) == [3, 3, 3]\n    assert candidate([0, 0, 0, 0, 0], 100) == [0, 0, 0, 0, 0]\n    assert candidate([1, 2, 3, 4, 5], 1) == [2, 3, 4, 5, 5]\n    assert candidate([100, 99, 98, 97, 96], 4) == [100, 100, 100, 100, 100]\n    assert candidate([5, 5, 5, 5, 5], 100) == [5, 5, 5, 5, 5]\n", "language": "python"}
{"task_id": "e1351f86-389c-4349-a00d-97662f23c7d9-7086467664285593895", "prompt": "Based on the docstring, I'll complete the function implementation. The code will be provided in a single block with edge cases properly handled.\n\n```python\nfrom typing import List, Tuple\n\ndef quantum_entanglement(particles: List[Tuple[int, int]], duration: int) -> int:\n    \"\"\"\n    In a quantum physics experiment, you're studying the behavior of entangled particles.\n    Each particle is represented by a tuple of two integers: its initial state and its\n    oscillation frequency. The particles' states change over time based on their frequency.\n\n    Your task is to determine how many particles will be in a positive state (> 0) after\n    a given duration. A particle's state at time t is calculated as:\n    initial_state + (frequency * t)\n\n    Parameters:\n    particles (List[Tuple[int, int]]): A list of tuples, each containing the initial state\n                                       and oscillation frequency of a particle\n    duration (int): The time duration of the experiment\n\n    Returns:\n    int: The number of particles in a positive state after the given duration\n\n\n    [EXAMPLES]\n    \n    assert candidate([(-10**9, 1)], 10**9 + 1) == 1\n    assert candidate([(100, -10), (50, -5), (25, -2), (10, -1)], 11) == 1\n\n    [/EXAMPLES]\n    \"\"\"\n```\n", "entry_point": "quantum_entanglement", "solution": "from typing import List, Tuple\n\ndef quantum_entanglement(particles: List[Tuple[int, int]], duration: int) -> int:\n    \"\"\"\n    In a quantum physics experiment, you're studying the behavior of entangled particles.\n    Each particle is represented by a tuple of two integers: its initial state and its\n    oscillation frequency. The particles' states change over time based on their frequency.\n\n    Your task is to determine how many particles will be in a positive state (> 0) after\n    a given duration. A particle's state at time t is calculated as:\n    initial_state + (frequency * t)\n\n    Parameters:\n    particles (List[Tuple[int, int]]): A list of tuples, each containing the initial state\n                                       and oscillation frequency of a particle\n    duration (int): The time duration of the experiment\n\n    Returns:\n    int: The number of particles in a positive state after the given duration\n\n\n    [EXAMPLES]\n    \n    assert candidate([(-10**9, 1)], 10**9 + 1) == 1\n    assert candidate([(100, -10), (50, -5), (25, -2), (10, -1)], 11) == 1\n\n    [/EXAMPLES]\n    \"\"\"\n    def calculate_final_state(initial_state: int, frequency: int) -> int:\n        return initial_state + (frequency * duration)\n\n    positive_particles = sum(1 for initial_state, frequency in particles \n                             if calculate_final_state(initial_state, frequency) > 0)\n    \n    return positive_particles\n\n", "test": "def check(candidate):\n    assert candidate([(0, 0)] * 100, 1000000) == 0\n    assert candidate([(10**9, -1)], 10**9 - 1) == 1\n    assert candidate([(0, 1), (0, 2), (0, 3), (0, 4), (0, 5)], 0) == 0\n    assert candidate([(100, -10), (50, -5), (25, -2), (10, -1)], 11) == 1\n    assert candidate([(i, -i) for i in range(1, 11)], 2) == 0\n    assert candidate([(5, -1), (4, -1), (3, -1), (2, -1), (1, -1)], 10) == 0\n    assert candidate([(1000, -1), (-1000, 1)], 1000) == 0\n    assert candidate([(-1, 2), (-2, 3), (-3, 4), (-4, 5)], 1) == 4\n    assert candidate([(-10, 1), (-5, 2), (0, 3), (5, 4), (10, 5)], 1) == 3\n    assert candidate([(-10**9, 1)], 10**9 + 1) == 1\n", "language": "python"}
{"task_id": "37801a35-177a-4264-ae03-3a9c8c265d1e6812134549464815589", "prompt": "In my role as a coding assistant, I complete functions to be execution-ready. I only work within the given function's scope, use exclusively the libraries imported in the problem, and place any supporting functions or classes inside the main function.\n\n```python\nfrom collections import deque\nfrom typing import List\n\ndef maze_escape_time(maze: List[List[int]], start: List[int], exit: List[int]) -> int:\n    \"\"\"\n    In a virtual reality game, players must navigate through a maze to reach the exit.\n    The maze is represented as a 2D grid where 0 represents an open path and 1 represents a wall.\n    Calculate the minimum time required to reach the exit, assuming it takes 1 unit of time to move\n    to an adjacent cell (up, down, left, or right).\n    \n    Args:\n    maze (List[List[int]]): A 2D list representing the maze layout.\n    start (List[int]): The starting position [row, col].\n    exit (List[int]): The exit position [row, col].\n    \n    Returns:\n    int: The minimum time required to reach the exit, or -1 if it's impossible.\n    \n\n    [EXAMPLES]\n    \n    assert candidate([[0,1,0,0],[0,1,1,0],[0,0,0,0]], [0,0], [2,3]) == 5\n    assert candidate([[0,0,0,0,0],[1,1,1,1,0],[0,0,0,0,0]], [0,0], [2,4]) == 6\n\n    [/EXAMPLES]\n    \"\"\"\n```\n", "entry_point": "maze_escape_time", "solution": "from collections import deque\nfrom typing import List\n\ndef maze_escape_time(maze: List[List[int]], start: List[int], exit: List[int]) -> int:\n    \"\"\"\n    In a virtual reality game, players must navigate through a maze to reach the exit.\n    The maze is represented as a 2D grid where 0 represents an open path and 1 represents a wall.\n    Calculate the minimum time required to reach the exit, assuming it takes 1 unit of time to move\n    to an adjacent cell (up, down, left, or right).\n    \n    Args:\n    maze (List[List[int]]): A 2D list representing the maze layout.\n    start (List[int]): The starting position [row, col].\n    exit (List[int]): The exit position [row, col].\n    \n    Returns:\n    int: The minimum time required to reach the exit, or -1 if it's impossible.\n    \n\n    [EXAMPLES]\n    \n    assert candidate([[0,1,0,0],[0,1,1,0],[0,0,0,0]], [0,0], [2,3]) == 5\n    assert candidate([[0,0,0,0,0],[1,1,1,1,0],[0,0,0,0,0]], [0,0], [2,4]) == 6\n\n    [/EXAMPLES]\n    \"\"\"\n    rows, cols = len(maze), len(maze[0])\n    \n    # Define possible movements: up, down, left, right\n    directions = [(-1, 0), (1, 0), (0, -1), (0, 1)]\n    \n    # Initialize the queue with the start position and time\n    queue = deque([(start[0], start[1], 0)])\n    \n    # Initialize visited set to keep track of explored cells\n    visited = set([(start[0], start[1])])\n    \n    while queue:\n        row, col, time = queue.popleft()\n        \n        # Check if we've reached the exit\n        if [row, col] == exit:\n            return time\n        \n        # Explore neighboring cells\n        for dr, dc in directions:\n            new_row, new_col = row + dr, col + dc\n            \n            # Check if the new position is valid and not visited\n            if (0 <= new_row < rows and \n                0 <= new_col < cols and \n                maze[new_row][new_col] == 0 and \n                (new_row, new_col) not in visited):\n                \n                queue.append((new_row, new_col, time + 1))\n                visited.add((new_row, new_col))\n    \n    # If we've explored all reachable cells and haven't found the exit\n    return -1\n\n", "test": "def check(candidate):\n    assert candidate([[0,1],[0,0]], [0,0], [1,1]) == 2\n    assert candidate([[0,0,0,0],[1,1,1,1],[0,0,0,0]], [0,0], [2,3]) == -1\n    assert candidate([[0,1,1,1,0],[0,0,0,1,0],[1,1,0,1,0],[1,1,0,0,0]], [0,0], [3,4]) == 7\n    assert candidate([[0,0,0,0,0],[1,1,1,1,0],[0,0,0,1,0],[0,1,0,1,0],[0,1,0,0,0]], [0,0], [4,4]) == 8\n    assert candidate([[0,0,0],[1,1,0],[0,0,0]], [0,0], [2,2]) == 4\n    assert candidate([[0,0,0,0,0],[1,1,1,1,1],[0,0,0,0,0]], [0,0], [2,4]) == -1\n    assert candidate([[0,0,0,0,0],[1,1,1,1,0],[0,0,0,0,0]], [0,0], [2,4]) == 6\n    assert candidate([[0,1,0],[0,1,0],[0,0,0]], [0,0], [2,1]) == 3\n    assert candidate([[0,0,0,0],[0,1,1,0],[0,1,0,0],[0,0,0,0]], [0,0], [3,3]) == 6\n    assert candidate([[0,1,0,0],[0,1,1,0],[0,0,0,0]], [0,0], [2,3]) == 5\n", "language": "python"}
{"task_id": "925e6e07-0483-4d07-b452-99df1089ad0b-610006882857391538", "prompt": "You function as a coding assistant. Your responsibility is to finish a provided function that can run as-is within a code block. Refrain from supplying code outside the function. Utilize only the libraries that are imported in the problem statement. Any additional functions or classes should be defined solely within the given function.\n\n```python\nfrom typing import List, Tuple\n\ndef genetic_sequence(dna_strand: str, mutation_points: List[Tuple[int, str]]) -> str:\n    \"\"\"\n    A geneticist is studying DNA mutations. Given a DNA strand represented as a string of\n    nucleotides (A, T, C, G) and a list of mutation points, apply the mutations to the DNA strand.\n    Each mutation point is represented by a tuple containing the index to mutate and the new\n    nucleotide.\n\n    This function uses string slicing and concatenation to efficiently apply mutations.\n\n\n    [EXAMPLES]\n    \n    assert candidate(\"GCTA\", []) == 'GCTA'\n    assert candidate(\"ACTG\", [(0, \"T\"), (1, \"A\"), (2, \"G\"), (3, \"C\")]) == 'TAGC'\n\n    [/EXAMPLES]\n    \"\"\"\n```\n", "entry_point": "genetic_sequence", "solution": "from typing import List, Tuple\n\ndef genetic_sequence(dna_strand: str, mutation_points: List[Tuple[int, str]]) -> str:\n    \"\"\"\n    A geneticist is studying DNA mutations. Given a DNA strand represented as a string of\n    nucleotides (A, T, C, G) and a list of mutation points, apply the mutations to the DNA strand.\n    Each mutation point is represented by a tuple containing the index to mutate and the new\n    nucleotide.\n\n    This function uses string slicing and concatenation to efficiently apply mutations.\n\n\n    [EXAMPLES]\n    \n    assert candidate(\"GCTA\", []) == 'GCTA'\n    assert candidate(\"ACTG\", [(0, \"T\"), (1, \"A\"), (2, \"G\"), (3, \"C\")]) == 'TAGC'\n\n    [/EXAMPLES]\n    \"\"\"\n    # Sort mutation points by index in descending order\n    # This allows us to apply mutations from right to left,\n    # avoiding index shifts as we modify the string\n    sorted_mutations = sorted(mutation_points, key=lambda x: x[0], reverse=True)\n    \n    # Convert the DNA strand to a list for easier manipulation\n    dna_list = list(dna_strand)\n    \n    # Apply mutations\n    for index, nucleotide in sorted_mutations:\n        if 0 <= index < len(dna_list):\n            dna_list[index] = nucleotide\n    \n    # Convert the list back to a string and return\n    return ''.join(dna_list)\n\n", "test": "def check(candidate):\n    assert candidate(\"AAAA\", [(0, \"T\"), (1, \"T\"), (2, \"T\"), (3, \"T\")]) == 'TTTT'\n    assert candidate(\"GCTA\", []) == 'GCTA'\n    assert candidate(\"ATATATATATA\", [(0, \"C\"), (2, \"G\"), (4, \"C\"), (6, \"G\"), (8, \"C\"), (10, \"G\")]) == 'CTGTCTGTCTG'\n    assert candidate(\"ATATATATATAT\", [(0, \"G\"), (11, \"C\")]) == 'GTATATATATAC'\n    assert candidate(\"G\", [(0, \"A\")]) == 'A'\n    assert candidate(\"ACTG\", [(0, \"T\"), (1, \"A\"), (2, \"G\"), (3, \"C\")]) == 'TAGC'\n    assert candidate(\"CCCC\", []) == 'CCCC'\n    assert candidate(\"ACGTACGT\", [(0, \"T\"), (7, \"A\")]) == 'TCGTACGA'\n    assert candidate(\"AGTCAGTCAGTC\", [(0, \"T\"), (3, \"A\"), (6, \"G\"), (9, \"C\")]) == 'TGTAAGGCACTC'\n    assert candidate(\"AGCT\", [(0, \"A\"), (1, \"G\"), (2, \"C\"), (3, \"T\")]) == 'AGCT'\n", "language": "python"}
{"task_id": "169fc84e-ce85-4476-88ba-d1bcba79598f6962143490979583377", "prompt": "I'd be happy to complete the code snippet you provided. Please share the partial code you'd like me to complete.\n\n```python\ndef analyze_dna_sequence(sequence: str) -> dict:\n    \"\"\"\n    In a genomics research project, we need to analyze a DNA sequence to identify\n    specific patterns and calculate various metrics. This function takes a DNA\n    sequence as input and returns a dictionary with analysis results.\n\n    The function should use regular expressions to find patterns and set operations\n    to identify unique nucleotides. It should also utilize a generator expression\n    to efficiently calculate the GC content.\n\n\n    [EXAMPLES]\n    \n    assert candidate(\"AAAAAAAA\") == {'length': 8, 'gc_content': 0.0, 'unique_nucleotides': {'A'}, 'start_codons': 0, 'stop_codons': 0}\n    assert candidate(\"ATGATG\") == {'length': 6, 'gc_content': 0.3333333333333333, 'unique_nucleotides': {'G', 'A', 'T'}, 'start_codons': 2, 'stop_codons': 1}\n\n    [/EXAMPLES]\n    \"\"\"\n```\n", "entry_point": "analyze_dna_sequence", "solution": "def analyze_dna_sequence(sequence: str) -> dict:\n    \"\"\"\n    In a genomics research project, we need to analyze a DNA sequence to identify\n    specific patterns and calculate various metrics. This function takes a DNA\n    sequence as input and returns a dictionary with analysis results.\n\n    The function should use regular expressions to find patterns and set operations\n    to identify unique nucleotides. It should also utilize a generator expression\n    to efficiently calculate the GC content.\n\n\n    [EXAMPLES]\n    \n    assert candidate(\"AAAAAAAA\") == {'length': 8, 'gc_content': 0.0, 'unique_nucleotides': {'A'}, 'start_codons': 0, 'stop_codons': 0}\n    assert candidate(\"ATGATG\") == {'length': 6, 'gc_content': 0.3333333333333333, 'unique_nucleotides': {'G', 'A', 'T'}, 'start_codons': 2, 'stop_codons': 1}\n\n    [/EXAMPLES]\n    \"\"\"\n    import re\n\n    def calculate_gc_content(seq):\n        return sum(1 for nucleotide in seq if nucleotide in 'GC') / len(seq)\n\n    result = {\n        'length': len(sequence),\n        'gc_content': calculate_gc_content(sequence),\n        'unique_nucleotides': set(sequence),\n        'start_codons': len(re.findall(r'ATG', sequence)),\n        'stop_codons': len(re.findall(r'TAA|TAG|TGA', sequence))\n    }\n\n    return result\n\n", "test": "def check(candidate):\n    assert candidate(\"A\") == {'length': 1, 'gc_content': 0.0, 'unique_nucleotides': {'A'}, 'start_codons': 0, 'stop_codons': 0}\n    assert candidate(\"AAAAAAAA\") == {'length': 8, 'gc_content': 0.0, 'unique_nucleotides': {'A'}, 'start_codons': 0, 'stop_codons': 0}\n    assert candidate(\"ATGCATGCATGCATGCATGCATGCTAA\") == {'length': 27, 'gc_content': 0.4444444444444444, 'unique_nucleotides': {'G', 'A', 'C', 'T'}, 'start_codons': 6, 'stop_codons': 1}\n    assert candidate(\"ATGCCTAGCTAGCTAGCTAGCTAGCTAGCTAGCTAGCTAGC\") == {'length': 41, 'gc_content': 0.5121951219512195, 'unique_nucleotides': {'G', 'A', 'C', 'T'}, 'start_codons': 1, 'stop_codons': 9}\n    assert candidate(\"ATGAAATAATAATAATAATAATAATAATAA\") == {'length': 30, 'gc_content': 0.03333333333333333, 'unique_nucleotides': {'G', 'A', 'T'}, 'start_codons': 1, 'stop_codons': 9}\n    assert candidate(\"ATGCATGCATGCATGCATGCATGCATGCATGCATGCATGCATGCATGCATGCATGCATGCATGC\") == {'length': 64, 'gc_content': 0.5, 'unique_nucleotides': {'G', 'A', 'C', 'T'}, 'start_codons': 16, 'stop_codons': 0}\n    assert candidate(\"ATGATG\") == {'length': 6, 'gc_content': 0.3333333333333333, 'unique_nucleotides': {'G', 'A', 'T'}, 'start_codons': 2, 'stop_codons': 1}\n    assert candidate(\"GCTAGCTAGCTAGCTAGCTAGCTAGCTAGCTA\") == {'length': 32, 'gc_content': 0.5, 'unique_nucleotides': {'G', 'A', 'T', 'C'}, 'start_codons': 0, 'stop_codons': 7}\n    assert candidate(\"ATGCCCGGGATGCCCGGGATGCCCGGG\") == {'length': 27, 'gc_content': 0.7777777777777778, 'unique_nucleotides': {'G', 'A', 'C', 'T'}, 'start_codons': 3, 'stop_codons': 0}\n    assert candidate(\"ATGCATGCATGCATGCATGCATGCATGCATGC\") == {'length': 32, 'gc_content': 0.5, 'unique_nucleotides': {'G', 'A', 'C', 'T'}, 'start_codons': 8, 'stop_codons': 0}\n", "language": "python"}
{"task_id": "879be55b-a6c7-46aa-8315-76cc8460cd4b-7999879041541999989", "prompt": "Here's the completed code in one block. All extra functions and classes are defined within the scope of the given function as requested.\n\n```python\ndef calculate_climate_impact(actions: dict) -> float:\n    \"\"\"As an environmental scientist, you're developing a model to calculate the climate impact of various human activities. Each action has a different impact on the global temperature.\n    \n    Your function should take a dictionary of actions and their frequencies, and return the total temperature change in degrees Celsius.\n    \n    Impact of each action:\n    - 'plant_tree': -0.0001\u00b0C\n    - 'use_plastic_bag': 0.0002\u00b0C\n    - 'drive_car': 0.00015\u00b0C\n    - 'recycle': -0.0001\u00b0C\n    - 'use_renewable_energy': -0.0003\u00b0C\n    \n    Round the final result to 6 decimal places.\n    \n\n    [EXAMPLES]\n    \n    assert candidate({'drive_car': 75, 'recycle': 100}) == 0.00125\n    assert candidate({'use_plastic_bag': 1}) == 0.0002\n\n    [/EXAMPLES]\n    \"\"\"\n```\n", "entry_point": "calculate_climate_impact", "solution": "def calculate_climate_impact(actions: dict) -> float:\n    \"\"\"As an environmental scientist, you're developing a model to calculate the climate impact of various human activities. Each action has a different impact on the global temperature.\n    \n    Your function should take a dictionary of actions and their frequencies, and return the total temperature change in degrees Celsius.\n    \n    Impact of each action:\n    - 'plant_tree': -0.0001\u00b0C\n    - 'use_plastic_bag': 0.0002\u00b0C\n    - 'drive_car': 0.00015\u00b0C\n    - 'recycle': -0.0001\u00b0C\n    - 'use_renewable_energy': -0.0003\u00b0C\n    \n    Round the final result to 6 decimal places.\n    \n\n    [EXAMPLES]\n    \n    assert candidate({'drive_car': 75, 'recycle': 100}) == 0.00125\n    assert candidate({'use_plastic_bag': 1}) == 0.0002\n\n    [/EXAMPLES]\n    \"\"\"\n    # Define the impact of each action\n    impact = {\n        'plant_tree': -0.0001,\n        'use_plastic_bag': 0.0002,\n        'drive_car': 0.00015,\n        'recycle': -0.0001,\n        'use_renewable_energy': -0.0003\n    }\n    \n    # Calculate the total impact\n    total_impact = 0\n    for action, frequency in actions.items():\n        if action in impact:\n            total_impact += impact[action] * frequency\n    \n    # Round the result to 6 decimal places\n    return round(total_impact, 6)\n\n", "test": "def check(candidate):\n    assert candidate({'use_plastic_bag': 1}) == 0.0002\n    assert candidate({'plant_tree': 10, 'use_plastic_bag': 10, 'drive_car': 10, 'recycle': 10, 'use_renewable_energy': 10}) == -0.0015\n    assert candidate({'use_renewable_energy': 1}) == -0.0003\n    assert candidate({}) == 0\n    assert candidate({'plant_tree': 0, 'use_plastic_bag': 0, 'drive_car': 0, 'recycle': 0, 'use_renewable_energy': 0}) == 0.0\n    assert candidate({'use_renewable_energy': 200, 'recycle': 150, 'drive_car': 100}) == -0.06\n    assert candidate({'drive_car': 1}) == 0.00015\n    assert candidate({'drive_car': 75, 'recycle': 100}) == 0.00125\n    assert candidate({'plant_tree': 100, 'use_plastic_bag': 50, 'drive_car': 1000}) == 0.15\n    assert candidate({'plant_tree': 1000, 'use_plastic_bag': 500, 'drive_car': 750, 'recycle': 1000, 'use_renewable_energy': 1250}) == -0.3625\n", "language": "python"}
{"task_id": "61480a84-7263-4a42-8cdf-82e6c798b2232182698321181859146", "prompt": "Please implement the function to fulfill the requirements specified in the documentation. Write the entire function in one code block, making sure to address any edge cases that might arise.\n\n```python\ndef word_frequency(text: str) -> dict:\n    \"\"\"\n    A linguist is analyzing the frequency of words in a given text. This function takes a string of text\n    and returns a dictionary where the keys are unique words (case-insensitive) and the values are the\n    number of times each word appears in the text. Punctuation should be ignored.\n\n\n    [EXAMPLES]\n    \n    assert candidate(\"a a a a a\") == {'a': 5}\n    assert candidate(\"\") == {}\n\n    [/EXAMPLES]\n    \"\"\"\n```\n", "entry_point": "word_frequency", "solution": "def word_frequency(text: str) -> dict:\n    \"\"\"\n    A linguist is analyzing the frequency of words in a given text. This function takes a string of text\n    and returns a dictionary where the keys are unique words (case-insensitive) and the values are the\n    number of times each word appears in the text. Punctuation should be ignored.\n\n\n    [EXAMPLES]\n    \n    assert candidate(\"a a a a a\") == {'a': 5}\n    assert candidate(\"\") == {}\n\n    [/EXAMPLES]\n    \"\"\"\n    import re\n    from collections import defaultdict\n\n    # Convert text to lowercase\n    text = text.lower()\n    \n    # Remove punctuation and split into words\n    words = re.findall(r'\\b\\w+\\b', text)\n    \n    # Count word frequencies\n    frequency = defaultdict(int)\n    for word in words:\n        frequency[word] += 1\n    \n    # Convert defaultdict to regular dict before returning\n    return dict(frequency)\n\n", "test": "def check(candidate):\n    assert candidate(\"This is a sentence. This is another sentence. This is a third sentence.\") == {'this': 3, 'is': 3, 'a': 2, 'sentence': 3, 'another': 1, 'third': 1}\n    assert candidate(\"a a a a a\") == {'a': 5}\n    assert candidate(\"Hello hello, World world!\") == {'hello': 2, 'world': 2}\n    assert candidate(\"\") == {}\n    assert candidate(\"A B C D E F G H I J K L M N O P Q R S T U V W X Y Z\") == {'a': 1, 'b': 1, 'c': 1, 'd': 1, 'e': 1, 'f': 1, 'g': 1, 'h': 1, 'i': 1, 'j': 1, 'k': 1, 'l': 1, 'm': 1, 'n': 1, 'o': 1, 'p': 1, 'q': 1, 'r': 1, 's': 1, 't': 1, 'u': 1, 'v': 1, 'w': 1, 'x': 1, 'y': 1, 'z': 1}\n    assert candidate(\"UPPER lower MiXeD cAsE\") == {'upper': 1, 'lower': 1, 'mixed': 1, 'case': 1}\n    assert candidate(\"\u00c9l\u00e9phant \u00e0pple \u00f2range \u00fcber\") == {'\u00e9l\u00e9phant': 1, '\u00e0pple': 1, '\u00f2range': 1, '\u00fcber': 1}\n    assert candidate(\"Hyphenated-words and non-hyphenated words\") == {'hyphenated': 2, 'words': 2, 'and': 1, 'non': 1}\n    assert candidate(\"\ud83d\udcbb\ud83d\udda5\ufe0f\u2328\ufe0f\ud83d\uddb1\ufe0f\") == {}\n    assert candidate(\"123 456 789\") == {'123': 1, '456': 1, '789': 1}\n", "language": "python"}
{"task_id": "4e6bf629-2d6a-44a1-9048-9c89020c2d511432090086309723367", "prompt": "I'm a coding assistant ready to help complete your function. I'll ensure my code is contained within the function block, only use libraries that are imported in the problem, and place any helper functions or classes inside the main function.\n\n```python\ndef optimize_delivery_route(packages: list, truck_capacity: int) -> list:\n    \"\"\"\n    You are a logistics manager for a delivery company. \n    You need to optimize the delivery route for a truck, maximizing the value of packages delivered while respecting the truck's weight capacity.\n\n    Create a function that takes two parameters:\n    1. packages: A list of tuples, where each tuple contains (package_id, weight, value).\n    2. truck_capacity: The maximum weight the truck can carry.\n\n    The function should return a list of package_ids representing the optimal selection of packages to maximize total value.\n\n    Constraints:\n    - The truck can't exceed its weight capacity.\n    - Each package can only be selected once.\n    - The function should use dynamic programming to solve this knapsack problem efficiently.\n\n\n    [EXAMPLES]\n    \n    assert candidate([(1, 10, 60), (2, 20, 100), (3, 30, 120)], 50) == [2, 3]\n    assert candidate([(1, 1, 1), (2, 1, 2), (3, 1, 3)], 2) == [2, 3]\n\n    [/EXAMPLES]\n    \"\"\"\n```\n", "entry_point": "optimize_delivery_route", "solution": "def optimize_delivery_route(packages: list, truck_capacity: int) -> list:\n    \"\"\"\n    You are a logistics manager for a delivery company. \n    You need to optimize the delivery route for a truck, maximizing the value of packages delivered while respecting the truck's weight capacity.\n\n    Create a function that takes two parameters:\n    1. packages: A list of tuples, where each tuple contains (package_id, weight, value).\n    2. truck_capacity: The maximum weight the truck can carry.\n\n    The function should return a list of package_ids representing the optimal selection of packages to maximize total value.\n\n    Constraints:\n    - The truck can't exceed its weight capacity.\n    - Each package can only be selected once.\n    - The function should use dynamic programming to solve this knapsack problem efficiently.\n\n\n    [EXAMPLES]\n    \n    assert candidate([(1, 10, 60), (2, 20, 100), (3, 30, 120)], 50) == [2, 3]\n    assert candidate([(1, 1, 1), (2, 1, 2), (3, 1, 3)], 2) == [2, 3]\n\n    [/EXAMPLES]\n    \"\"\"\n    \n    n = len(packages)\n    # Create a 2D table for dynamic programming\n    dp = [[0 for _ in range(truck_capacity + 1)] for _ in range(n + 1)]\n    \n    # Fill the dp table\n    for i in range(1, n + 1):\n        for w in range(1, truck_capacity + 1):\n            if packages[i-1][1] <= w:\n                dp[i][w] = max(dp[i-1][w], dp[i-1][w-packages[i-1][1]] + packages[i-1][2])\n            else:\n                dp[i][w] = dp[i-1][w]\n    \n    # Backtrack to find the selected packages\n    selected_packages = []\n    w = truck_capacity\n    for i in range(n, 0, -1):\n        if dp[i][w] != dp[i-1][w]:\n            selected_packages.append(packages[i-1][0])\n            w -= packages[i-1][1]\n    \n    # Reverse the list to get packages in ascending order of their IDs\n    selected_packages.reverse()\n    \n    return selected_packages\n\n", "test": "def check(candidate):\n    assert candidate([(1, 1, 1), (2, 1, 2), (3, 1, 3)], 2) == [2, 3]\n    assert candidate([(1, 10, 100), (2, 20, 200), (3, 30, 300)], 100) == [1, 2, 3]\n    assert candidate([(1, 5, 5), (2, 4, 4), (3, 3, 3), (4, 2, 2), (5, 1, 1)], 15) == [1, 2, 3, 4, 5]\n    assert candidate([(i, i, i) for i in range(1, 101)], 100) == [1, 2, 3, 4, 6, 7, 8, 9, 10, 11, 12, 13, 14]\n    assert candidate([(1, 1, 1), (2, 2, 2), (3, 3, 3)], 5) == [2, 3]\n    assert candidate([(1, 5, 10), (2, 5, 20), (3, 5, 30), (4, 5, 40)], 15) == [2, 3, 4]\n    assert candidate([(1, 10, 60), (2, 20, 100), (3, 30, 120)], 50) == [2, 3]\n    assert candidate([(1, 5, 10), (2, 4, 40), (3, 6, 30), (4, 3, 50)], 10) == [2, 4]\n    assert candidate([(1, 10, 10), (2, 20, 20), (3, 30, 30)], 40) == [1, 3]\n    assert candidate([(1, 10, 10), (2, 10, 10), (3, 10, 10)], 30) == [1, 2, 3]\n", "language": "python"}
{"task_id": "75cfe3fb-19ad-4a01-b2f2-ef6a2b79e687-4670638416843709717", "prompt": "Using the doc string as a guide, finish implementing the function and provide the complete solution in one code block.\n\n```python\nimport random\nfrom typing import List\n\ndef analyze_stock_data(prices: List[float], window_size: int) -> List[float]:\n    \"\"\"\n    In the world of high-frequency trading, we need to analyze stock price movements quickly.\n    This function takes a list of stock prices and a window size, then calculates the moving\n    average for each window. It uses list comprehension and exception handling to perform\n    the calculations efficiently.\n\n    Args:\n    prices (List[float]): A list of stock prices\n    window_size (int): The size of the moving window\n\n    Returns:\n    List[float]: A list of moving averages\n\n\n    [EXAMPLES]\n    \n    assert candidate([9.99, 10.01, 10.00, 9.98, 10.02], 4) == [10.0, 10.0]\n    assert candidate([1.0, 10.0, 100.0, 1000.0, 10000.0], 2) == [5.5, 55.0, 550.0, 5500.0]\n\n    [/EXAMPLES]\n    \"\"\"\n```\n", "entry_point": "analyze_stock_data", "solution": "import random\nfrom typing import List\n\ndef analyze_stock_data(prices: List[float], window_size: int) -> List[float]:\n    \"\"\"\n    In the world of high-frequency trading, we need to analyze stock price movements quickly.\n    This function takes a list of stock prices and a window size, then calculates the moving\n    average for each window. It uses list comprehension and exception handling to perform\n    the calculations efficiently.\n\n    Args:\n    prices (List[float]): A list of stock prices\n    window_size (int): The size of the moving window\n\n    Returns:\n    List[float]: A list of moving averages\n\n\n    [EXAMPLES]\n    \n    assert candidate([9.99, 10.01, 10.00, 9.98, 10.02], 4) == [10.0, 10.0]\n    assert candidate([1.0, 10.0, 100.0, 1000.0, 10000.0], 2) == [5.5, 55.0, 550.0, 5500.0]\n\n    [/EXAMPLES]\n    \"\"\"\n    def calculate_average(window):\n        try:\n            return round(sum(window) / len(window), 2)\n        except ZeroDivisionError:\n            return 0.0\n\n    if window_size <= 0:\n        raise ValueError(\"Window size must be a positive integer\")\n\n    if len(prices) < window_size:\n        return []\n\n    return [calculate_average(prices[i:i+window_size]) for i in range(len(prices) - window_size + 1)]\n\n", "test": "def check(candidate):\n    assert candidate([50.0, 50.0, 50.0, 50.0, 50.0], 1) == [50.0, 50.0, 50.0, 50.0, 50.0]\n    assert candidate([100.0, 101.0, 102.0, 103.0, 104.0], 3) == [101.0, 102.0, 103.0]\n    assert candidate([1.0, 10.0, 100.0, 1000.0, 10000.0], 2) == [5.5, 55.0, 550.0, 5500.0]\n    assert candidate([1000.0, 900.0, 950.0, 1025.0, 975.0], 2) == [950.0, 925.0, 987.5, 1000.0]\n    assert candidate([100.0, 90.0, 80.0, 70.0, 60.0, 50.0], 6) == [75.0]\n    assert candidate([500.0, 500.0, 500.0, 500.0, 500.0], 3) == [500.0, 500.0, 500.0]\n    assert candidate([100.0, 101.0, 99.0, 102.0, 98.0, 103.0], 5) == [100.0, 100.6]\n    assert candidate([9.99, 10.01, 10.00, 9.98, 10.02], 4) == [10.0, 10.0]\n    assert candidate([10.5, 11.2, 9.8, 10.3, 11.5, 12.0, 11.8], 2) == [10.85, 10.5, 10.05, 10.9, 11.75, 11.9]\n    assert candidate([1.5, 2.5, 3.5, 4.5, 5.5], 1) == [1.5, 2.5, 3.5, 4.5, 5.5]\n", "language": "python"}
{"task_id": "7de87d45-34aa-43f6-bca4-28c303c7f2c76634649078344791383", "prompt": "Please complete the provided function so that it can be run as-is in a single code block. Don't include any code outside the function definition. Only use libraries that are already imported in the problem. If you need additional functions or classes, define them inside the main function. Deliver just one code block with your solution.\n\n```python\nfrom typing import List, Dict\n\ndef decrypt_alien_message(message: str, codebook: Dict[str, str]) -> str:\n    \"\"\"An astronomer has intercepted a message from an alien civilization, but it's encrypted. \n    Luckily, they've also managed to obtain a partial codebook that translates some alien symbols \n    to Earth letters. Your task is to decrypt as much of the message as possible.\n\n    The function should take two parameters:\n    1. A string containing the encrypted message, where each alien symbol is represented by a unique emoji.\n    2. A dictionary where keys are emoji symbols and values are the corresponding Earth letters.\n\n    The function should return the decrypted message, leaving any unknown symbols as they are.\n\n    Rules for decryption:\n    1. If a symbol is in the codebook, replace it with its Earth letter.\n    2. If a symbol is not in the codebook, leave it unchanged.\n    3. Maintain the original spacing and punctuation of the message.\n\n\n    [EXAMPLES]\n    \n    assert candidate(\"\ud83d\udc7d\ud83c\udf1f\ud83d\udc7e \ud83d\udc7d\ud83c\udf0d\ud83c\udf1f \ud83d\udc7d\ud83d\ude80\ud83d\udc7d\ud83c\udf0d\ud83c\udf1f!\", {\"\ud83d\udc7d\": \"E\", \"\ud83c\udf1f\": \"T\", \"\ud83d\udc7e\": \"A\", \"\ud83c\udf0d\": \"R\"}) == 'ETA ERT E\ud83d\ude80ERT!'\n    assert candidate(\"\ud83d\udc31\ud83d\udc36\ud83d\udc30 \ud83d\udc3b\ud83e\udd8a\ud83d\udc3c\", {\"\ud83d\udc31\": \"C\", \"\ud83d\udc36\": \"A\", \"\ud83d\udc30\": \"T\", \"\ud83d\udc3b\": \"D\", \"\ud83e\udd8a\": \"O\", \"\ud83d\udc3c\": \"G\"}) == 'CAT DOG'\n\n    [/EXAMPLES]\n    \"\"\"\n```\n", "entry_point": "decrypt_alien_message", "solution": "from typing import List, Dict\n\ndef decrypt_alien_message(message: str, codebook: Dict[str, str]) -> str:\n    \"\"\"An astronomer has intercepted a message from an alien civilization, but it's encrypted. \n    Luckily, they've also managed to obtain a partial codebook that translates some alien symbols \n    to Earth letters. Your task is to decrypt as much of the message as possible.\n\n    The function should take two parameters:\n    1. A string containing the encrypted message, where each alien symbol is represented by a unique emoji.\n    2. A dictionary where keys are emoji symbols and values are the corresponding Earth letters.\n\n    The function should return the decrypted message, leaving any unknown symbols as they are.\n\n    Rules for decryption:\n    1. If a symbol is in the codebook, replace it with its Earth letter.\n    2. If a symbol is not in the codebook, leave it unchanged.\n    3. Maintain the original spacing and punctuation of the message.\n\n\n    [EXAMPLES]\n    \n    assert candidate(\"\ud83d\udc7d\ud83c\udf1f\ud83d\udc7e \ud83d\udc7d\ud83c\udf0d\ud83c\udf1f \ud83d\udc7d\ud83d\ude80\ud83d\udc7d\ud83c\udf0d\ud83c\udf1f!\", {\"\ud83d\udc7d\": \"E\", \"\ud83c\udf1f\": \"T\", \"\ud83d\udc7e\": \"A\", \"\ud83c\udf0d\": \"R\"}) == 'ETA ERT E\ud83d\ude80ERT!'\n    assert candidate(\"\ud83d\udc31\ud83d\udc36\ud83d\udc30 \ud83d\udc3b\ud83e\udd8a\ud83d\udc3c\", {\"\ud83d\udc31\": \"C\", \"\ud83d\udc36\": \"A\", \"\ud83d\udc30\": \"T\", \"\ud83d\udc3b\": \"D\", \"\ud83e\udd8a\": \"O\", \"\ud83d\udc3c\": \"G\"}) == 'CAT DOG'\n\n    [/EXAMPLES]\n    \"\"\"\n    \n    def decrypt_symbol(symbol: str) -> str:\n        \"\"\"Helper function to decrypt a single symbol.\"\"\"\n        return codebook.get(symbol, symbol)\n    \n    # Use a list comprehension to decrypt each symbol in the message\n    decrypted_symbols = [decrypt_symbol(symbol) for symbol in message]\n    \n    # Join the decrypted symbols back into a string\n    return ''.join(decrypted_symbols)\n\n", "test": "def check(candidate):\n    assert candidate(\"1\ufe0f\u20e32\ufe0f\u20e33\ufe0f\u20e3 4\ufe0f\u20e35\ufe0f\u20e36\ufe0f\u20e3\", {\"1\ufe0f\u20e3\": \"O\", \"2\ufe0f\u20e3\": \"N\", \"3\ufe0f\u20e3\": \"E\", \"4\ufe0f\u20e3\": \"T\", \"5\ufe0f\u20e3\": \"W\", \"6\ufe0f\u20e3\": \"O\"}) == '1\ufe0f\u20e32\ufe0f\u20e33\ufe0f\u20e3 4\ufe0f\u20e35\ufe0f\u20e36\ufe0f\u20e3'\n    assert candidate(\"\ud83c\udfc3\u200d\u2642\ufe0f\ud83d\udeb6\u200d\u2640\ufe0f\ud83c\udfc3\u200d\u2642\ufe0f\ud83d\udeb6\u200d\u2640\ufe0f\ud83c\udfc3\u200d\u2642\ufe0f\ud83d\udeb6\u200d\u2640\ufe0f\", {\"\ud83c\udfc3\u200d\u2642\ufe0f\": \"R\", \"\ud83d\udeb6\u200d\u2640\ufe0f\": \"W\"}) == '\ud83c\udfc3\\u200d\u2642\ufe0f\ud83d\udeb6\\u200d\u2640\ufe0f\ud83c\udfc3\\u200d\u2642\ufe0f\ud83d\udeb6\\u200d\u2640\ufe0f\ud83c\udfc3\\u200d\u2642\ufe0f\ud83d\udeb6\\u200d\u2640\ufe0f'\n    assert candidate(\"\ud83d\udc7d\ud83c\udf1f\ud83d\udc7e \ud83d\udc7d\ud83c\udf0d\ud83c\udf1f \ud83d\udc7d\ud83d\ude80\ud83d\udc7d\ud83c\udf0d\ud83c\udf1f!\", {\"\ud83d\udc7d\": \"E\", \"\ud83c\udf1f\": \"T\", \"\ud83d\udc7e\": \"A\", \"\ud83c\udf0d\": \"R\"}) == 'ETA ERT E\ud83d\ude80ERT!'\n    assert candidate(\"\ud83c\udf1e\ud83c\udf1d\ud83c\udf1e\ud83c\udf1d\ud83c\udf1e\ud83c\udf1d\", {\"\ud83c\udf1e\": \"S\", \"\ud83c\udf1d\": \"M\"}) == 'SMSMSM'\n    assert candidate(\"\ud83d\udd22\ud83d\udd21\ud83d\udd20\ud83d\udd23\ud83d\udd22\ud83d\udd21\", {\"\ud83d\udd22\": \"1\", \"\ud83d\udd21\": \"a\", \"\ud83d\udd20\": \"A\", \"\ud83d\udd23\": \"@\"}) == '1aA@1a'\n    assert candidate(\"\u2660\ufe0f\u2663\ufe0f\u2665\ufe0f\u2666\ufe0f\u2660\ufe0f\u2663\ufe0f\", {\"\u2660\ufe0f\": \"S\", \"\u2663\ufe0f\": \"C\", \"\u2665\ufe0f\": \"H\", \"\u2666\ufe0f\": \"D\"}) == '\u2660\ufe0f\u2663\ufe0f\u2665\ufe0f\u2666\ufe0f\u2660\ufe0f\u2663\ufe0f'\n    assert candidate(\"\ud83d\udc31\ud83d\udc36\ud83d\udc30 \ud83d\udc3b\ud83e\udd8a\ud83d\udc3c\", {\"\ud83d\udc31\": \"C\", \"\ud83d\udc36\": \"A\", \"\ud83d\udc30\": \"T\", \"\ud83d\udc3b\": \"D\", \"\ud83e\udd8a\": \"O\", \"\ud83d\udc3c\": \"G\"}) == 'CAT DOG'\n    assert candidate(\"\ud83c\udf08\ud83c\udf0a\ud83c\udfd4\ufe0f\ud83c\udf0b\ud83c\udf08\ud83c\udf0a\", {\"\ud83c\udf08\": \"R\", \"\ud83c\udf0a\": \"W\", \"\ud83c\udfd4\ufe0f\": \"M\", \"\ud83c\udf0b\": \"V\"}) == 'RW\ud83c\udfd4\ufe0fVRW'\n    assert candidate(\"\ud83d\udc4d\ud83d\udc4e\ud83d\udc4d\ud83d\udc4e\ud83d\udc4d\ud83d\udc4e\", {\"\ud83d\udc4d\": \"Y\", \"\ud83d\udc4e\": \"N\"}) == 'YNYNYN'\n    assert candidate(\"\ud83c\udf89\ud83c\udf8a\ud83c\udf89\ud83c\udf8a\ud83c\udf89\ud83c\udf8a\", {\"\ud83c\udf89\": \"P\", \"\ud83c\udf8a\": \"C\"}) == 'PCPCPC'\n", "language": "python"}
{"task_id": "02e1587b-d6a1-4a85-abb5-8e7b3e552b50839299943188272689", "prompt": "Based on the doc string requirements, I'll implement the rest of the function while preserving the existing signature. The complete implementation will be provided in a single code block.\n\n```python\nfrom typing import List\nfrom typing import List, Tuple\nimport heapq\nimport time\n\ndef network_packet_scheduler(packets: List[Tuple[int, int, int]]) -> List[int]:\n    \"\"\"\n    Simulate a network packet scheduler using a priority queue.\n\n    This function models a network router that needs to schedule packet transmissions\n    based on their priority and arrival time. It uses a priority queue (heap) to\n    efficiently manage packet scheduling, demonstrating the application of data\n    structures in network programming.\n\n    Parameters:\n    packets (List[Tuple[int, int, int]]): A list of tuples, each representing a packet\n                                          with (arrival_time, processing_time, priority).\n\n    Returns:\n    List[int]: A list of packet IDs in the order they are processed.\n\n\n    [EXAMPLES]\n    \n    assert candidate([(0, 5, 1), (1, 4, 1), (2, 3, 1), (3, 2, 1), (4, 1, 1)]) == [0, 1, 2, 3, 4]\n    assert candidate([(5, 2, 1), (3, 4, 2), (1, 3, 3)]) == [2, 1, 0]\n\n    [/EXAMPLES]\n    \"\"\"\n```\n", "entry_point": "network_packet_scheduler", "solution": "from typing import List\nfrom typing import List, Tuple\nimport heapq\nimport time\n\ndef network_packet_scheduler(packets: List[Tuple[int, int, int]]) -> List[int]:\n    \"\"\"\n    Simulate a network packet scheduler using a priority queue.\n\n    This function models a network router that needs to schedule packet transmissions\n    based on their priority and arrival time. It uses a priority queue (heap) to\n    efficiently manage packet scheduling, demonstrating the application of data\n    structures in network programming.\n\n    Parameters:\n    packets (List[Tuple[int, int, int]]): A list of tuples, each representing a packet\n                                          with (arrival_time, processing_time, priority).\n\n    Returns:\n    List[int]: A list of packet IDs in the order they are processed.\n\n\n    [EXAMPLES]\n    \n    assert candidate([(0, 5, 1), (1, 4, 1), (2, 3, 1), (3, 2, 1), (4, 1, 1)]) == [0, 1, 2, 3, 4]\n    assert candidate([(5, 2, 1), (3, 4, 2), (1, 3, 3)]) == [2, 1, 0]\n\n    [/EXAMPLES]\n    \"\"\"\n    # Sort packets by arrival time\n    packets = sorted(enumerate(packets), key=lambda x: x[1][0])\n    \n    current_time = 0\n    packet_queue = []\n    processed_packets = []\n    packet_index = 0\n    \n    while packet_index < len(packets) or packet_queue:\n        # Add all packets that have arrived by the current time to the queue\n        while packet_index < len(packets) and packets[packet_index][1][0] <= current_time:\n            packet_id, (arrival_time, processing_time, priority) = packets[packet_index]\n            heapq.heappush(packet_queue, (-priority, arrival_time, processing_time, packet_id))\n            packet_index += 1\n        \n        if packet_queue:\n            # Process the highest priority packet\n            _, _, processing_time, packet_id = heapq.heappop(packet_queue)\n            processed_packets.append(packet_id)\n            current_time += processing_time\n        else:\n            # If no packets in queue, move time to next packet arrival\n            current_time = packets[packet_index][1][0]\n    \n    return processed_packets\n\n", "test": "def check(candidate):\n    assert candidate([(0, 10, 1), (0, 5, 2), (0, 3, 3), (0, 1, 4)]) == [3, 2, 1, 0]\n    assert candidate([(0, 1, 1), (1, 1, 2), (2, 1, 3), (3, 1, 4)]) == [0, 1, 2, 3]\n    assert candidate([(0, 5, 1), (1, 4, 1), (2, 3, 1), (3, 2, 1), (4, 1, 1)]) == [0, 1, 2, 3, 4]\n    assert candidate([(5, 2, 1), (3, 4, 2), (1, 3, 3)]) == [2, 1, 0]\n    assert candidate([(0, 1000000, 1), (0, 2000000, 2), (0, 3000000, 3)]) == [2, 1, 0]\n    assert candidate([(0, 1, 0)]) == [0]\n    assert candidate([(i, 1, i) for i in range(50)]) == [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49]\n    assert candidate([(0, 1, 1), (1000, 1, 2), (2000, 1, 3), (3000, 1, 4), (4000, 1, 5)]) == [0, 1, 2, 3, 4]\n    assert candidate([(0, 1, 1), (0, 1, 1), (0, 1, 1), (0, 1, 1), (0, 1, 1)]) == [0, 1, 2, 3, 4]\n    assert candidate([(i, i, 1) for i in range(50)]) == [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49]\n", "language": "python"}
{"task_id": "2bbb90ac-c576-4ade-8751-2a65ab6f147f-7487668629536415429", "prompt": "Below is the completed function implementation as specified in the docstring. The entire solution is presented in a single code block.\n\n```python\nfrom typing import List\n\ndef predict_stock_profit(prices: List[int], k: int) -> int:\n    \"\"\"\n    A day trader wants to maximize their profit in the stock market.\n    Given a list of predicted stock prices for the next n days and a maximum\n    number of transactions k, determine the maximum profit that can be made.\n    You can buy one stock and sell it later, but you must sell the stock\n    before buying another one. Use dynamic programming to solve this problem.\n\n    Args:\n    prices (List[int]): A list of integers representing the predicted stock prices\n    k (int): The maximum number of transactions allowed\n\n    Returns:\n    int: The maximum profit that can be made\n\n\n    [EXAMPLES]\n    \n    assert candidate([100], 1) == 0\n    assert candidate([5, 4, 3, 2, 1], 1) == 0\n\n    [/EXAMPLES]\n    \"\"\"\n```\n", "entry_point": "predict_stock_profit", "solution": "from typing import List\n\ndef predict_stock_profit(prices: List[int], k: int) -> int:\n    \"\"\"\n    A day trader wants to maximize their profit in the stock market.\n    Given a list of predicted stock prices for the next n days and a maximum\n    number of transactions k, determine the maximum profit that can be made.\n    You can buy one stock and sell it later, but you must sell the stock\n    before buying another one. Use dynamic programming to solve this problem.\n\n    Args:\n    prices (List[int]): A list of integers representing the predicted stock prices\n    k (int): The maximum number of transactions allowed\n\n    Returns:\n    int: The maximum profit that can be made\n\n\n    [EXAMPLES]\n    \n    assert candidate([100], 1) == 0\n    assert candidate([5, 4, 3, 2, 1], 1) == 0\n\n    [/EXAMPLES]\n    \"\"\"\n    if not prices or k == 0:\n        return 0\n\n    n = len(prices)\n    \n    # If k is larger than n/2, we can make as many transactions as we want\n    if k >= n // 2:\n        return sum(max(0, prices[i] - prices[i-1]) for i in range(1, n))\n\n    # Initialize dp table\n    dp = [[0 for _ in range(n)] for _ in range(k+1)]\n\n    for i in range(1, k+1):\n        max_diff = -prices[0]\n        for j in range(1, n):\n            dp[i][j] = max(dp[i][j-1], prices[j] + max_diff)\n            max_diff = max(max_diff, dp[i-1][j] - prices[j])\n\n    return dp[k][n-1]\n\n", "test": "def check(candidate):\n    assert candidate([1, 1, 1, 1, 1], 3) == 0\n    assert candidate([100], 1) == 0\n    assert candidate([3, 3, 5, 0, 0, 3, 1, 4], 2) == 6\n    assert candidate([1, 2, 3, 0, 2], 2) == 4\n    assert candidate([1, 2, 3, 4, 5], 5) == 4\n    assert candidate([1, 2, 3, 4, 5], 1) == 4\n    assert candidate([3, 2, 6, 5, 0, 3, 1, 4, 7, 2], 3) == 13\n    assert candidate([1, 10, 1, 10, 1, 10], 3) == 27\n    assert candidate([10, 22, 5, 75, 65, 80], 2) == 87\n    assert candidate([5, 4, 3, 2, 1], 1) == 0\n", "language": "python"}
{"task_id": "435e7e17-e1b0-4e22-a8ce-ef79e9ba5a614511911648915809418", "prompt": "Implement the function body according to the documentation string. Present the complete solution in a single code block while maintaining the existing function signature.\n\n```python\nfrom collections import defaultdict\nfrom typing import List, Dict\nfrom typing import List, Dict, Tuple\n\ndef analyze_social_network(connections: List[Tuple[str, str]], interests: Dict[str, List[str]]) -> Dict[str, List[str]]:\n    \"\"\"\n    You are a data scientist working on analyzing a social network. You have data about\n    user connections and their interests. Your task is to create a function that recommends\n    new connections for each user based on shared interests.\n\n    The function should take two parameters:\n    1. connections: A list of tuples, where each tuple represents a connection between two users.\n    2. interests: A dictionary where keys are usernames and values are lists of their interests.\n\n    The function should return a dictionary where:\n    - Keys are usernames.\n    - Values are lists of recommended connections (usernames) for that user, sorted by the number\n      of shared interests in descending order. Only include recommendations that share at least\n      one interest and are not already connected to the user.\n\n    If a user has no recommendations, they should still be included in the output with an empty list.\n\n\n    [EXAMPLES]\n    \n    assert candidate([(\"A\", \"B\"), (\"B\", \"C\"), (\"C\", \"D\")], {\"A\": [\"1\", \"2\"], \"B\": [\"2\", \"3\"], \"C\": [\"3\", \"4\"], \"D\": [\"4\", \"5\"], \"E\": [\"5\", \"1\"]}) == {'A': ['E'], 'B': [], 'C': [], 'D': ['E'], 'E': ['A', 'D']}\n    assert candidate([(\"User1\", \"User2\"), (\"User2\", \"User3\"), (\"User3\", \"User4\")], {\"User1\": [\"gaming\", \"cooking\"], \"User2\": [\"sports\", \"music\"], \"User3\": [\"cooking\", \"sports\"], \"User4\": [\"music\", \"art\"], \"User5\": [\"gaming\", \"art\"]}) == {'User1': ['User3', 'User5'], 'User2': ['User4'], 'User3': ['User1'], 'User4': ['User2', 'User5'], 'User5': ['User1', 'User4']}\n\n    [/EXAMPLES]\n    \"\"\"\n```\n", "entry_point": "analyze_social_network", "solution": "from collections import defaultdict\nfrom typing import List, Dict\nfrom typing import List, Dict, Tuple\n\ndef analyze_social_network(connections: List[Tuple[str, str]], interests: Dict[str, List[str]]) -> Dict[str, List[str]]:\n    \"\"\"\n    You are a data scientist working on analyzing a social network. You have data about\n    user connections and their interests. Your task is to create a function that recommends\n    new connections for each user based on shared interests.\n\n    The function should take two parameters:\n    1. connections: A list of tuples, where each tuple represents a connection between two users.\n    2. interests: A dictionary where keys are usernames and values are lists of their interests.\n\n    The function should return a dictionary where:\n    - Keys are usernames.\n    - Values are lists of recommended connections (usernames) for that user, sorted by the number\n      of shared interests in descending order. Only include recommendations that share at least\n      one interest and are not already connected to the user.\n\n    If a user has no recommendations, they should still be included in the output with an empty list.\n\n\n    [EXAMPLES]\n    \n    assert candidate([(\"A\", \"B\"), (\"B\", \"C\"), (\"C\", \"D\")], {\"A\": [\"1\", \"2\"], \"B\": [\"2\", \"3\"], \"C\": [\"3\", \"4\"], \"D\": [\"4\", \"5\"], \"E\": [\"5\", \"1\"]}) == {'A': ['E'], 'B': [], 'C': [], 'D': ['E'], 'E': ['A', 'D']}\n    assert candidate([(\"User1\", \"User2\"), (\"User2\", \"User3\"), (\"User3\", \"User4\")], {\"User1\": [\"gaming\", \"cooking\"], \"User2\": [\"sports\", \"music\"], \"User3\": [\"cooking\", \"sports\"], \"User4\": [\"music\", \"art\"], \"User5\": [\"gaming\", \"art\"]}) == {'User1': ['User3', 'User5'], 'User2': ['User4'], 'User3': ['User1'], 'User4': ['User2', 'User5'], 'User5': ['User1', 'User4']}\n\n    [/EXAMPLES]\n    \"\"\"\n    def calculate_shared_interests(user1: str, user2: str) -> int:\n        return len(set(interests[user1]) & set(interests[user2]))\n\n    # Create a set of connections for each user\n    user_connections = defaultdict(set)\n    for user1, user2 in connections:\n        user_connections[user1].add(user2)\n        user_connections[user2].add(user1)\n\n    # Initialize the result dictionary\n    recommendations = {user: [] for user in interests}\n\n    # Generate recommendations for each user\n    for user in interests:\n        potential_connections = []\n        for other_user in interests:\n            if other_user != user and other_user not in user_connections[user]:\n                shared = calculate_shared_interests(user, other_user)\n                if shared > 0:\n                    potential_connections.append((other_user, shared))\n        \n        # Sort potential connections by shared interests in descending order\n        potential_connections.sort(key=lambda x: x[1], reverse=True)\n        \n        # Add sorted recommendations to the result\n        recommendations[user] = [conn[0] for conn in potential_connections]\n\n    return recommendations\n\n", "test": "def check(candidate):\n    assert candidate([(\"A\", \"B\"), (\"C\", \"D\"), (\"E\", \"F\")], {\"A\": [\"1\"], \"B\": [\"2\"], \"C\": [\"3\"], \"D\": [\"4\"], \"E\": [\"5\"], \"F\": [\"6\"], \"G\": [\"7\"]}) == {'A': [], 'B': [], 'C': [], 'D': [], 'E': [], 'F': [], 'G': []}\n    assert candidate([(\"1\", \"2\"), (\"2\", \"3\"), (\"3\", \"4\"), (\"4\", \"5\")], {\"1\": [\"a\"], \"2\": [\"a\", \"b\"], \"3\": [\"b\", \"c\"], \"4\": [\"c\", \"d\"], \"5\": [\"d\", \"e\"], \"6\": [\"e\", \"a\"]}) == {'1': ['6'], '2': ['6'], '3': [], '4': [], '5': ['6'], '6': ['1', '2', '5']}\n    assert candidate([(\"X\", \"Y\"), (\"Y\", \"Z\"), (\"Z\", \"W\")], {\"X\": [\"a\", \"b\"], \"Y\": [\"b\", \"c\"], \"Z\": [\"c\", \"d\"], \"W\": [\"d\", \"e\"], \"V\": [\"e\", \"a\"]}) == {'X': ['V'], 'Y': [], 'Z': [], 'W': ['V'], 'V': ['X', 'W']}\n    assert candidate([(\"1\", \"2\"), (\"2\", \"3\"), (\"3\", \"4\"), (\"4\", \"5\"), (\"5\", \"1\")], {\"1\": [\"a\"], \"2\": [\"b\"], \"3\": [\"c\"], \"4\": [\"d\"], \"5\": [\"e\"]}) == {'1': [], '2': [], '3': [], '4': [], '5': []}\n    assert candidate([(\"A\", \"B\")], {\"A\": [\"1\", \"2\", \"3\"], \"B\": [\"3\", \"4\", \"5\"], \"C\": [\"5\", \"6\", \"7\"]}) == {'A': [], 'B': ['C'], 'C': ['B']}\n    assert candidate([(\"X\", \"Y\")], {\"X\": [\"a\"], \"Y\": [\"b\"], \"Z\": [\"c\"]}) == {'X': [], 'Y': [], 'Z': []}\n    assert candidate([(\"X\", \"Y\"), (\"Y\", \"Z\")], {\"X\": [\"a\", \"b\", \"c\"], \"Y\": [\"b\", \"c\", \"d\"], \"Z\": [\"c\", \"d\", \"e\"], \"W\": [\"d\", \"e\", \"f\"]}) == {'X': ['Z'], 'Y': ['W'], 'Z': ['W', 'X'], 'W': ['Z', 'Y']}\n    assert candidate([(\"A\", \"B\"), (\"B\", \"C\"), (\"C\", \"D\")], {\"A\": [\"1\", \"2\"], \"B\": [\"2\", \"3\"], \"C\": [\"3\", \"4\"], \"D\": [\"4\", \"5\"], \"E\": [\"5\", \"1\"]}) == {'A': ['E'], 'B': [], 'C': [], 'D': ['E'], 'E': ['A', 'D']}\n    assert candidate([(\"1\", \"2\"), (\"3\", \"4\")], {\"1\": [\"a\", \"b\"], \"2\": [\"b\", \"c\"], \"3\": [\"c\", \"d\"], \"4\": [\"d\", \"e\"], \"5\": [\"e\", \"a\"]}) == {'1': ['5'], '2': ['3'], '3': ['2'], '4': ['5'], '5': ['1', '4']}\n    assert candidate([(\"User1\", \"User2\"), (\"User2\", \"User3\"), (\"User3\", \"User4\")], {\"User1\": [\"gaming\", \"cooking\"], \"User2\": [\"sports\", \"music\"], \"User3\": [\"cooking\", \"sports\"], \"User4\": [\"music\", \"art\"], \"User5\": [\"gaming\", \"art\"]}) == {'User1': ['User3', 'User5'], 'User2': ['User4'], 'User3': ['User1'], 'User4': ['User2', 'User5'], 'User5': ['User1', 'User4']}\n", "language": "python"}
{"task_id": "d77f8311-aec4-420b-8839-132edd129838844515299872192955", "prompt": "I'd be happy to complete your code, but I need to see the starting point. Could you share the incomplete code you're working with? I'll then provide the complete version in a single code block.\n\n```python\nimport re\nfrom typing import List\n\ndef analyze_password_strength(password: str) -> List[str]:\n    \"\"\"\n    Analyzes the strength of a given password and returns a list of improvement suggestions.\n\n    This function evaluates a password based on several criteria:\n    1. Length (at least 8 characters)\n    2. Contains uppercase letters\n    3. Contains lowercase letters\n    4. Contains numbers\n    5. Contains special characters\n    6. Not a common password\n\n    Args:\n    password (str): The password to be analyzed.\n\n    Returns:\n    List[str]: A list of suggestions for improving the password strength.\n\n\n    [EXAMPLES]\n    \n    assert candidate(\"P@55w0rd\") == []\n    assert candidate(\"ALLUPPERCASE123!@#\") == ['Add lowercase letters']\n\n    [/EXAMPLES]\n    \"\"\"\n```\n", "entry_point": "analyze_password_strength", "solution": "import re\nfrom typing import List\n\ndef analyze_password_strength(password: str) -> List[str]:\n    \"\"\"\n    Analyzes the strength of a given password and returns a list of improvement suggestions.\n\n    This function evaluates a password based on several criteria:\n    1. Length (at least 8 characters)\n    2. Contains uppercase letters\n    3. Contains lowercase letters\n    4. Contains numbers\n    5. Contains special characters\n    6. Not a common password\n\n    Args:\n    password (str): The password to be analyzed.\n\n    Returns:\n    List[str]: A list of suggestions for improving the password strength.\n\n\n    [EXAMPLES]\n    \n    assert candidate(\"P@55w0rd\") == []\n    assert candidate(\"ALLUPPERCASE123!@#\") == ['Add lowercase letters']\n\n    [/EXAMPLES]\n    \"\"\"\n    suggestions = []\n\n    # Check length\n    if len(password) < 8:\n        suggestions.append(\"Make the password at least 8 characters long\")\n\n    # Check for uppercase letters\n    if not re.search(r'[A-Z]', password):\n        suggestions.append(\"Add uppercase letters\")\n\n    # Check for lowercase letters\n    if not re.search(r'[a-z]', password):\n        suggestions.append(\"Add lowercase letters\")\n\n    # Check for numbers\n    if not re.search(r'\\d', password):\n        suggestions.append(\"Add numbers\")\n\n    # Check for special characters\n    if not re.search(r'[!@#$%^&*(),.?\":{}|<>]', password):\n        suggestions.append(\"Add special characters\")\n\n    # Check if it's a common password\n    common_passwords = ['password', '123456', 'qwerty', 'admin', 'letmein', 'welcome']\n    if password.lower() in common_passwords:\n        suggestions.append(\"Avoid common passwords\")\n\n    return suggestions\n\n", "test": "def check(candidate):\n    assert candidate(\"abcdefgh\") == ['Add uppercase letters', 'Add numbers', 'Add special characters']\n    assert candidate(\"!@#$%^&*\") == ['Add uppercase letters', 'Add lowercase letters', 'Add numbers']\n    assert candidate(\"ALLUPPERCASE123!@#\") == ['Add lowercase letters']\n    assert candidate(\"Pass1234\") == ['Add special characters']\n    assert candidate(\"11111111\") == ['Add uppercase letters', 'Add lowercase letters', 'Add special characters']\n    assert candidate(\"P@ssw0rd\") == []\n    assert candidate(\"P@55w0rd\") == []\n    assert candidate(\"password123\") == ['Add uppercase letters', 'Add special characters']\n    assert candidate(\"\") == ['Make the password at least 8 characters long', 'Add uppercase letters', 'Add lowercase letters', 'Add numbers', 'Add special characters']\n    assert candidate(\"a\") == ['Make the password at least 8 characters long', 'Add uppercase letters', 'Add numbers', 'Add special characters']\n", "language": "python"}
{"task_id": "ace7800a-cae5-4336-974d-4edf19597d97440176598334834128", "prompt": "Please finish implementing the function according to its documentation. Provide your solution in a complete code block, ensuring that all edge cases are properly handled.\n\n```python\nfrom typing import List\n\ndef decode_message(encrypted: List[int], key: int) -> str:\n    \"\"\"\n    As a cryptography enthusiast, you've intercepted an encrypted message. The message is a list of integers,\n    and you know the encryption key. To decode the message, you need to perform a bitwise XOR operation\n    between each integer in the list and the key, then convert the result to its corresponding ASCII character.\n    Only the results that fall within the printable ASCII range (32 to 126) should be included in the final message.\n\n    Parameters:\n    encrypted (List[int]): A list of integers representing the encrypted message.\n    key (int): The encryption key used to encode the message.\n\n    Returns:\n    str: The decoded message as a string.\n\n\n    [EXAMPLES]\n    \n    assert candidate([123, 456, 789, 101, 112, 131], 100) == ''\n    assert candidate([48, 49, 50, 51, 52, 53, 54, 55, 56, 57], 16) == ' !\"#$%&\\'()'\n\n    [/EXAMPLES]\n    \"\"\"\n```\n", "entry_point": "decode_message", "solution": "from typing import List\n\ndef decode_message(encrypted: List[int], key: int) -> str:\n    \"\"\"\n    As a cryptography enthusiast, you've intercepted an encrypted message. The message is a list of integers,\n    and you know the encryption key. To decode the message, you need to perform a bitwise XOR operation\n    between each integer in the list and the key, then convert the result to its corresponding ASCII character.\n    Only the results that fall within the printable ASCII range (32 to 126) should be included in the final message.\n\n    Parameters:\n    encrypted (List[int]): A list of integers representing the encrypted message.\n    key (int): The encryption key used to encode the message.\n\n    Returns:\n    str: The decoded message as a string.\n\n\n    [EXAMPLES]\n    \n    assert candidate([123, 456, 789, 101, 112, 131], 100) == ''\n    assert candidate([48, 49, 50, 51, 52, 53, 54, 55, 56, 57], 16) == ' !\"#$%&\\'()'\n\n    [/EXAMPLES]\n    \"\"\"\n    def is_printable_ascii(char_code):\n        return 32 <= char_code <= 126\n\n    decoded_chars = []\n    for num in encrypted:\n        char_code = num ^ key\n        if is_printable_ascii(char_code):\n            decoded_chars.append(chr(char_code))\n\n    return ''.join(decoded_chars)\n\n", "test": "def check(candidate):\n    assert candidate([65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90], 32) == 'abcdefghijklmnopqrstuvwxyz'\n    assert candidate([65, 66, 67, 68, 69, 70], 0) == 'ABCDEF'\n    assert candidate([255, 254, 253, 252, 251, 250], 255) == ''\n    assert candidate([70, 79, 79, 66, 65, 82], 42) == 'leehkx'\n    assert candidate([1, 2, 4, 8, 16, 32, 64, 128], 255) == ''\n    assert candidate([48, 49, 50, 51, 52, 53, 54, 55, 56, 57], 16) == ' !\"#$%&\\'()'\n    assert candidate([123, 456, 789, 101, 112, 131], 100) == ''\n    assert candidate([255, 255, 255, 255, 255], 128) == ''\n    assert candidate([100, 100, 100, 100, 100], 50) == 'VVVVV'\n    assert candidate([0, 0, 0, 0, 0], 127) == ''\n", "language": "python"}
{"task_id": "1a919933-9cde-4411-b916-27d3be73dd3b-4164181355638909808", "prompt": "I function as a coding assistant that completes given functions with executable code. I'll stick to the libraries imported in your problem and won't provide code outside the function. Any auxiliary functions or classes will be defined within the main function.\n\n```python\nfrom typing import List\n\ndef rocket_fuel_efficiency(stages: int, fuel_loads: List[float], gravity_factors: List[float]) -> float:\n    \"\"\"\n    Calculate the overall fuel efficiency of a multi-stage rocket launch.\n\n    In a multi-stage rocket launch, each stage has its own fuel load and experiences different gravity factors.\n    This function computes the overall fuel efficiency based on the number of stages, their respective fuel loads,\n    and the gravity factors experienced during each stage of the launch.\n\n    Args:\n    stages (int): The number of stages in the rocket launch.\n    fuel_loads (List[float]): A list of fuel loads for each stage in kilograms.\n    gravity_factors (List[float]): A list of gravity factors experienced during each stage.\n\n    Returns:\n    float: The overall fuel efficiency of the rocket launch.\n\n\n    [EXAMPLES]\n    \n    assert candidate(4, [2000.0, 1800.0, 1600.0, 1400.0], [1.2, 1.1, 1.0, 0.9]) == 7240.0\n    assert candidate(2, [1000.0, 500.0], [1.0, 0.9]) == 1450.0\n\n    [/EXAMPLES]\n    \"\"\"\n```\n", "entry_point": "rocket_fuel_efficiency", "solution": "from typing import List\n\ndef rocket_fuel_efficiency(stages: int, fuel_loads: List[float], gravity_factors: List[float]) -> float:\n    \"\"\"\n    Calculate the overall fuel efficiency of a multi-stage rocket launch.\n\n    In a multi-stage rocket launch, each stage has its own fuel load and experiences different gravity factors.\n    This function computes the overall fuel efficiency based on the number of stages, their respective fuel loads,\n    and the gravity factors experienced during each stage of the launch.\n\n    Args:\n    stages (int): The number of stages in the rocket launch.\n    fuel_loads (List[float]): A list of fuel loads for each stage in kilograms.\n    gravity_factors (List[float]): A list of gravity factors experienced during each stage.\n\n    Returns:\n    float: The overall fuel efficiency of the rocket launch.\n\n\n    [EXAMPLES]\n    \n    assert candidate(4, [2000.0, 1800.0, 1600.0, 1400.0], [1.2, 1.1, 1.0, 0.9]) == 7240.0\n    assert candidate(2, [1000.0, 500.0], [1.0, 0.9]) == 1450.0\n\n    [/EXAMPLES]\n    \"\"\"\n    if stages != len(fuel_loads) or stages != len(gravity_factors):\n        raise ValueError(\"The number of stages must match the length of fuel_loads and gravity_factors lists.\")\n\n    total_efficiency = 0.0\n    \n    for i in range(stages):\n        stage_efficiency = fuel_loads[i] * gravity_factors[i]\n        total_efficiency += stage_efficiency\n    \n    return total_efficiency\n\n", "test": "def check(candidate):\n    assert candidate(4, [1200.0, 1000.0, 800.0, 600.0], [1.1, 1.0, 0.9, 0.8]) == 3520.0\n    assert candidate(5, [1000.0, 900.0, 800.0, 700.0, 600.0], [1.1, 1.0, 0.9, 0.8, 0.7]) == 3700.0\n    assert candidate(2, [100.0, 50.0], [1.0, 0.5]) == 125.0\n    assert candidate(2, [2000.0, 1000.0], [1.2, 0.8]) == 3200.0\n    assert candidate(2, [3000.0, 2000.0], [1.3, 0.7]) == 5300.0\n    assert candidate(2, [1000.0, 500.0], [1.0, 0.9]) == 1450.0\n    assert candidate(4, [1000.0, 800.0, 600.0, 400.0], [1.2, 1.0, 0.8, 0.6]) == 2720.0\n    assert candidate(4, [2000.0, 1800.0, 1600.0, 1400.0], [1.2, 1.1, 1.0, 0.9]) == 7240.0\n    assert candidate(5, [5000.0, 4000.0, 3000.0, 2000.0, 1000.0], [1.0, 0.95, 0.9, 0.85, 0.8]) == 14000.0\n    assert candidate(3, [2000.0, 1500.0, 1000.0], [1.0, 0.8, 0.6]) == 3800.0\n", "language": "python"}
{"task_id": "fe7ebc35-9544-44ff-81db-e366cd5ac167-7241302727416429797", "prompt": "Your coding assistant here. I'll fill in the implementation for any function you provide, making sure the code is executable as-is. I'll only use libraries that are already imported in the problem statement, and I'll keep any helper functions or classes contained within the main function's scope.\n\n```python\nfrom typing import List\nfrom collections import defaultdict\n\ndef analyze_dna_sequence(sequence: str, motif_length: int) -> List[str]:\n    \"\"\"\n    Analyze a DNA sequence to find recurring motifs of a specified length.\n\n    In genomics research, identifying recurring patterns in DNA sequences can provide insights into gene function and regulation.\n    This function takes a DNA sequence and a motif length as input, and returns a list of all motifs of the specified length\n    that appear more than once in the sequence, allowing for overlapping occurrences.\n\n    :param sequence: A string representing the DNA sequence (containing only A, T, C, G).\n    :param motif_length: An integer specifying the length of motifs to search for.\n    :return: A list of strings, each representing a recurring motif.\n\n\n    [EXAMPLES]\n    \n    assert candidate(\"ATCGATCGATCG\", 6) == ['ATCGAT', 'TCGATC', 'CGATCG']\n    assert candidate(\"CGTAGCTAGCTAGCTA\", 4) == ['TAGC', 'AGCT', 'GCTA', 'CTAG']\n\n    [/EXAMPLES]\n    \"\"\"\n```\n", "entry_point": "analyze_dna_sequence", "solution": "from typing import List\nfrom collections import defaultdict\n\ndef analyze_dna_sequence(sequence: str, motif_length: int) -> List[str]:\n    \"\"\"\n    Analyze a DNA sequence to find recurring motifs of a specified length.\n\n    In genomics research, identifying recurring patterns in DNA sequences can provide insights into gene function and regulation.\n    This function takes a DNA sequence and a motif length as input, and returns a list of all motifs of the specified length\n    that appear more than once in the sequence, allowing for overlapping occurrences.\n\n    :param sequence: A string representing the DNA sequence (containing only A, T, C, G).\n    :param motif_length: An integer specifying the length of motifs to search for.\n    :return: A list of strings, each representing a recurring motif.\n\n\n    [EXAMPLES]\n    \n    assert candidate(\"ATCGATCGATCG\", 6) == ['ATCGAT', 'TCGATC', 'CGATCG']\n    assert candidate(\"CGTAGCTAGCTAGCTA\", 4) == ['TAGC', 'AGCT', 'GCTA', 'CTAG']\n\n    [/EXAMPLES]\n    \"\"\"\n    # Check if the sequence is valid (contains only A, T, C, G)\n    if not set(sequence).issubset({'A', 'T', 'C', 'G'}):\n        raise ValueError(\"Invalid DNA sequence. Only A, T, C, G are allowed.\")\n\n    # Check if motif_length is valid\n    if motif_length <= 0 or motif_length > len(sequence):\n        raise ValueError(\"Invalid motif length. It should be positive and not exceed the sequence length.\")\n\n    # Dictionary to store motif occurrences\n    motif_count = defaultdict(int)\n\n    # Iterate through the sequence to count motif occurrences\n    for i in range(len(sequence) - motif_length + 1):\n        motif = sequence[i:i+motif_length]\n        motif_count[motif] += 1\n\n    # Filter and return motifs that appear more than once\n    recurring_motifs = [motif for motif, count in motif_count.items() if count > 1]\n\n    return recurring_motifs\n\n", "test": "def check(candidate):\n    assert candidate(\"ACGTACGTACGT\", 4) == ['ACGT', 'CGTA', 'GTAC', 'TACG']\n    assert candidate(\"ATGCATGCATGC\", 4) == ['ATGC', 'TGCA', 'GCAT', 'CATG']\n    assert candidate(\"ATCGATCGATCG\", 6) == ['ATCGAT', 'TCGATC', 'CGATCG']\n    assert candidate(\"AGCT\", 1) == []\n    assert candidate(\"ATCGATCGATCGATCG\", 7) == ['ATCGATC', 'TCGATCG', 'CGATCGA', 'GATCGAT']\n    assert candidate(\"TTTTTTTTTTTTT\", 5) == ['TTTTT']\n    assert candidate(\"CGTAGCTAGCTAGCTA\", 4) == ['TAGC', 'AGCT', 'GCTA', 'CTAG']\n    assert candidate(\"AAAACCCGGGTTTT\", 2) == ['AA', 'CC', 'GG', 'TT']\n    assert candidate(\"AAAAAA\", 1) == ['A']\n    assert candidate(\"GCGCGCGCGCGC\", 3) == ['GCG', 'CGC']\n", "language": "python"}
{"task_id": "7de87d45-34aa-43f6-bca4-28c303c7f2c7557593112575185490", "prompt": "I function as a coding assistant. My purpose is to complete given functions in executable form within code blocks. I won't add code outside the function boundaries. I'll restrict myself to using only the libraries imported in the problem. Any helper functions or classes I create will be nested within the main function provided.\n\n```python\nfrom typing import List, Tuple\nfrom typing import List\nimport heapq\n\ndef find_meeting_rooms(meetings: List[Tuple[int, int]]) -> int:\n    \"\"\"You are managing a co-working space and need to determine the minimum number of meeting rooms required\n    to accommodate all scheduled meetings. You are given a list of meetings, where each meeting is represented\n    by a tuple containing the start and end time (in 24-hour format).\n\n    Your task is to find the minimum number of meeting rooms needed to hold all the meetings without any\n    conflicts. Two meetings conflict if they overlap in time.\n\n    Implement an efficient algorithm to solve this problem, considering that there could be a large number of\n    meetings scheduled throughout the day.\n\n\n    [EXAMPLES]\n    \n    assert candidate([(0, 10), (5, 15), (10, 20), (15, 25), (20, 30)]) == 2\n    assert candidate([(0, 1), (1, 2), (2, 3), (3, 4), (4, 5)]) == 1\n\n    [/EXAMPLES]\n    \"\"\"\n```\n", "entry_point": "find_meeting_rooms", "solution": "from typing import List, Tuple\nfrom typing import List\nimport heapq\n\ndef find_meeting_rooms(meetings: List[Tuple[int, int]]) -> int:\n    \"\"\"You are managing a co-working space and need to determine the minimum number of meeting rooms required\n    to accommodate all scheduled meetings. You are given a list of meetings, where each meeting is represented\n    by a tuple containing the start and end time (in 24-hour format).\n\n    Your task is to find the minimum number of meeting rooms needed to hold all the meetings without any\n    conflicts. Two meetings conflict if they overlap in time.\n\n    Implement an efficient algorithm to solve this problem, considering that there could be a large number of\n    meetings scheduled throughout the day.\n\n\n    [EXAMPLES]\n    \n    assert candidate([(0, 10), (5, 15), (10, 20), (15, 25), (20, 30)]) == 2\n    assert candidate([(0, 1), (1, 2), (2, 3), (3, 4), (4, 5)]) == 1\n\n    [/EXAMPLES]\n    \"\"\"\n    if not meetings:\n        return 0\n    \n    # Sort meetings by start time\n    sorted_meetings = sorted(meetings, key=lambda x: x[0])\n    \n    # Initialize a min heap to keep track of end times\n    room_end_times = []\n    \n    # Initialize the number of rooms\n    rooms_needed = 0\n    \n    for start, end in sorted_meetings:\n        # Remove meetings that have ended\n        while room_end_times and room_end_times[0] <= start:\n            heapq.heappop(room_end_times)\n        \n        # Add the current meeting's end time to the heap\n        heapq.heappush(room_end_times, end)\n        \n        # Update the maximum number of rooms needed\n        rooms_needed = max(rooms_needed, len(room_end_times))\n    \n    return rooms_needed\n\n", "test": "def check(candidate):\n    assert candidate([(0, 10), (5, 15), (10, 20), (15, 25), (20, 30)]) == 2\n    assert candidate([(0, 1), (0, 2), (0, 3), (1, 4), (2, 5)]) == 3\n    assert candidate([(0, 1), (1, 2), (2, 3), (3, 4), (4, 5)]) == 1\n    assert candidate([(0, 1), (0, 1), (1, 2), (1, 2), (2, 3), (2, 3)]) == 2\n    assert candidate([(0, 24), (0, 24), (0, 24), (0, 24), (0, 24)]) == 5\n    assert candidate([(0, 5), (1, 6), (2, 7), (3, 8), (4, 9)]) == 5\n    assert candidate([(0, 24), (1, 23), (2, 22), (3, 21), (4, 20)]) == 5\n    assert candidate([(0, 1), (0, 2), (0, 3), (0, 4), (0, 5)]) == 5\n    assert candidate([(8, 9), (9, 10), (10, 11), (11, 12), (12, 13)]) == 1\n    assert candidate([(0, 1), (2, 3), (4, 5), (6, 7), (8, 9)]) == 1\n", "language": "python"}
{"task_id": "43689131-f48e-4abb-8e4b-12ba97f7343c-837685367951361876", "prompt": "I'll finish that code for you in a unified code block.\n\n```python\ndef encode_message(message: str) -> str:\n    \"\"\"\n    Encode a message using a simple substitution cipher where each letter\n    is replaced by its corresponding letter 13 positions down the alphabet.\n    Numbers and special characters remain unchanged.\n\n    This cipher is often called ROT13 and has the property that applying\n    it twice to a message returns the original message.\n\n\n    [EXAMPLES]\n    \n    assert candidate(\"Hello\\nWorld\") == 'Uryyb\\nJbeyq'\n    assert candidate(\"A\" * 1000) == 'NNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNN'\n\n    [/EXAMPLES]\n    \"\"\"\n```\n", "entry_point": "encode_message", "solution": "def encode_message(message: str) -> str:\n    \"\"\"\n    Encode a message using a simple substitution cipher where each letter\n    is replaced by its corresponding letter 13 positions down the alphabet.\n    Numbers and special characters remain unchanged.\n\n    This cipher is often called ROT13 and has the property that applying\n    it twice to a message returns the original message.\n\n\n    [EXAMPLES]\n    \n    assert candidate(\"Hello\\nWorld\") == 'Uryyb\\nJbeyq'\n    assert candidate(\"A\" * 1000) == 'NNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNN'\n\n    [/EXAMPLES]\n    \"\"\"\n    def rot13_char(char: str) -> str:\n        if char.isalpha():\n            # Determine the ASCII offset based on whether the character is uppercase or lowercase\n            offset = 65 if char.isupper() else 97\n            # Apply ROT13 transformation\n            return chr((ord(char) - offset + 13) % 26 + offset)\n        else:\n            # Return non-alphabetic characters unchanged\n            return char\n\n    return ''.join(rot13_char(char) for char in message)\n\n", "test": "def check(candidate):\n    assert candidate(\"A\" * 1000) == 'NNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNN'\n    assert candidate(\"12345!@#$%^&*()\") == '12345!@#$%^&*()'\n    assert candidate(\"!@#$%^&*()_+{}|:<>?\") == '!@#$%^&*()_+{}|:<>?'\n    assert candidate(\"ABCDEFGHIJKLMNOPQRSTUVWXYZ\") == 'NOPQRSTUVWXYZABCDEFGHIJKLM'\n    assert candidate(\"\") == ''\n    assert candidate(\"   Spaces   \") == '   Fcnprf   '\n    assert candidate(\"Z\") == 'M'\n    assert candidate(\"MixEd CaSe 123\") == 'ZvkRq PnFr 123'\n    assert candidate(\"Hello\\nWorld\") == 'Uryyb\\nJbeyq'\n    assert candidate(\"The Quick Brown Fox Jumps Over The Lazy Dog\") == 'Gur Dhvpx Oebja Sbk Whzcf Bire Gur Ynml Qbt'\n", "language": "python"}
{"task_id": "9b76cc10-5143-4928-a08a-83691636fa681389193350908740889", "prompt": "Your function will be completed in a single, executable code block. I'll only use the imported libraries specified in the problem and will nest any additional helper functions or classes within the main function. My response will contain exactly one code block with the complete solution.\n\n```python\nfrom typing import List\nimport itertools\n\ndef ingredient_combinations(pantry: List[str], recipe_size: int) -> List[List[str]]:\n    \"\"\"\n    A chef wants to explore new recipe ideas using ingredients available in their pantry.\n    This function generates all possible combinations of ingredients for a given recipe size.\n\n    Args:\n    pantry (List[str]): A list of ingredients available in the pantry.\n    recipe_size (int): The number of ingredients to use in each recipe combination.\n\n    Returns:\n    List[List[str]]: A list of all possible ingredient combinations for the given recipe size.\n\n\n    [EXAMPLES]\n    \n    assert candidate(['salt'], 1) == [['salt']]\n    assert candidate(['chicken', 'beef', 'pork', 'fish'], 1) == [['chicken'], ['beef'], ['pork'], ['fish']]\n\n    [/EXAMPLES]\n    \"\"\"\n```\n", "entry_point": "ingredient_combinations", "solution": "from typing import List\nimport itertools\n\ndef ingredient_combinations(pantry: List[str], recipe_size: int) -> List[List[str]]:\n    \"\"\"\n    A chef wants to explore new recipe ideas using ingredients available in their pantry.\n    This function generates all possible combinations of ingredients for a given recipe size.\n\n    Args:\n    pantry (List[str]): A list of ingredients available in the pantry.\n    recipe_size (int): The number of ingredients to use in each recipe combination.\n\n    Returns:\n    List[List[str]]: A list of all possible ingredient combinations for the given recipe size.\n\n\n    [EXAMPLES]\n    \n    assert candidate(['salt'], 1) == [['salt']]\n    assert candidate(['chicken', 'beef', 'pork', 'fish'], 1) == [['chicken'], ['beef'], ['pork'], ['fish']]\n\n    [/EXAMPLES]\n    \"\"\"\n    # Check if recipe_size is valid\n    if recipe_size <= 0 or recipe_size > len(pantry):\n        return []\n\n    # Generate all combinations of ingredients\n    combinations = list(itertools.combinations(pantry, recipe_size))\n\n    # Convert tuples to lists\n    return [list(combo) for combo in combinations]\n\n", "test": "def check(candidate):\n    assert candidate(['salt'], 1) == [['salt']]\n    assert candidate(['chicken', 'beef', 'pork', 'fish'], 1) == [['chicken'], ['beef'], ['pork'], ['fish']]\n    assert candidate(['a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j'], 5) == [['a', 'b', 'c', 'd', 'e'], ['a', 'b', 'c', 'd', 'f'], ['a', 'b', 'c', 'd', 'g'], ['a', 'b', 'c', 'd', 'h'], ['a', 'b', 'c', 'd', 'i'], ['a', 'b', 'c', 'd', 'j'], ['a', 'b', 'c', 'e', 'f'], ['a', 'b', 'c', 'e', 'g'], ['a', 'b', 'c', 'e', 'h'], ['a', 'b', 'c', 'e', 'i'], ['a', 'b', 'c', 'e', 'j'], ['a', 'b', 'c', 'f', 'g'], ['a', 'b', 'c', 'f', 'h'], ['a', 'b', 'c', 'f', 'i'], ['a', 'b', 'c', 'f', 'j'], ['a', 'b', 'c', 'g', 'h'], ['a', 'b', 'c', 'g', 'i'], ['a', 'b', 'c', 'g', 'j'], ['a', 'b', 'c', 'h', 'i'], ['a', 'b', 'c', 'h', 'j'], ['a', 'b', 'c', 'i', 'j'], ['a', 'b', 'd', 'e', 'f'], ['a', 'b', 'd', 'e', 'g'], ['a', 'b', 'd', 'e', 'h'], ['a', 'b', 'd', 'e', 'i'], ['a', 'b', 'd', 'e', 'j'], ['a', 'b', 'd', 'f', 'g'], ['a', 'b', 'd', 'f', 'h'], ['a', 'b', 'd', 'f', 'i'], ['a', 'b', 'd', 'f', 'j'], ['a', 'b', 'd', 'g', 'h'], ['a', 'b', 'd', 'g', 'i'], ['a', 'b', 'd', 'g', 'j'], ['a', 'b', 'd', 'h', 'i'], ['a', 'b', 'd', 'h', 'j'], ['a', 'b', 'd', 'i', 'j'], ['a', 'b', 'e', 'f', 'g'], ['a', 'b', 'e', 'f', 'h'], ['a', 'b', 'e', 'f', 'i'], ['a', 'b', 'e', 'f', 'j'], ['a', 'b', 'e', 'g', 'h'], ['a', 'b', 'e', 'g', 'i'], ['a', 'b', 'e', 'g', 'j'], ['a', 'b', 'e', 'h', 'i'], ['a', 'b', 'e', 'h', 'j'], ['a', 'b', 'e', 'i', 'j'], ['a', 'b', 'f', 'g', 'h'], ['a', 'b', 'f', 'g', 'i'], ['a', 'b', 'f', 'g', 'j'], ['a', 'b', 'f', 'h', 'i'], ['a', 'b', 'f', 'h', 'j'], ['a', 'b', 'f', 'i', 'j'], ['a', 'b', 'g', 'h', 'i'], ['a', 'b', 'g', 'h', 'j'], ['a', 'b', 'g', 'i', 'j'], ['a', 'b', 'h', 'i', 'j'], ['a', 'c', 'd', 'e', 'f'], ['a', 'c', 'd', 'e', 'g'], ['a', 'c', 'd', 'e', 'h'], ['a', 'c', 'd', 'e', 'i'], ['a', 'c', 'd', 'e', 'j'], ['a', 'c', 'd', 'f', 'g'], ['a', 'c', 'd', 'f', 'h'], ['a', 'c', 'd', 'f', 'i'], ['a', 'c', 'd', 'f', 'j'], ['a', 'c', 'd', 'g', 'h'], ['a', 'c', 'd', 'g', 'i'], ['a', 'c', 'd', 'g', 'j'], ['a', 'c', 'd', 'h', 'i'], ['a', 'c', 'd', 'h', 'j'], ['a', 'c', 'd', 'i', 'j'], ['a', 'c', 'e', 'f', 'g'], ['a', 'c', 'e', 'f', 'h'], ['a', 'c', 'e', 'f', 'i'], ['a', 'c', 'e', 'f', 'j'], ['a', 'c', 'e', 'g', 'h'], ['a', 'c', 'e', 'g', 'i'], ['a', 'c', 'e', 'g', 'j'], ['a', 'c', 'e', 'h', 'i'], ['a', 'c', 'e', 'h', 'j'], ['a', 'c', 'e', 'i', 'j'], ['a', 'c', 'f', 'g', 'h'], ['a', 'c', 'f', 'g', 'i'], ['a', 'c', 'f', 'g', 'j'], ['a', 'c', 'f', 'h', 'i'], ['a', 'c', 'f', 'h', 'j'], ['a', 'c', 'f', 'i', 'j'], ['a', 'c', 'g', 'h', 'i'], ['a', 'c', 'g', 'h', 'j'], ['a', 'c', 'g', 'i', 'j'], ['a', 'c', 'h', 'i', 'j'], ['a', 'd', 'e', 'f', 'g'], ['a', 'd', 'e', 'f', 'h'], ['a', 'd', 'e', 'f', 'i'], ['a', 'd', 'e', 'f', 'j'], ['a', 'd', 'e', 'g', 'h'], ['a', 'd', 'e', 'g', 'i'], ['a', 'd', 'e', 'g', 'j'], ['a', 'd', 'e', 'h', 'i'], ['a', 'd', 'e', 'h', 'j'], ['a', 'd', 'e', 'i', 'j'], ['a', 'd', 'f', 'g', 'h'], ['a', 'd', 'f', 'g', 'i'], ['a', 'd', 'f', 'g', 'j'], ['a', 'd', 'f', 'h', 'i'], ['a', 'd', 'f', 'h', 'j'], ['a', 'd', 'f', 'i', 'j'], ['a', 'd', 'g', 'h', 'i'], ['a', 'd', 'g', 'h', 'j'], ['a', 'd', 'g', 'i', 'j'], ['a', 'd', 'h', 'i', 'j'], ['a', 'e', 'f', 'g', 'h'], ['a', 'e', 'f', 'g', 'i'], ['a', 'e', 'f', 'g', 'j'], ['a', 'e', 'f', 'h', 'i'], ['a', 'e', 'f', 'h', 'j'], ['a', 'e', 'f', 'i', 'j'], ['a', 'e', 'g', 'h', 'i'], ['a', 'e', 'g', 'h', 'j'], ['a', 'e', 'g', 'i', 'j'], ['a', 'e', 'h', 'i', 'j'], ['a', 'f', 'g', 'h', 'i'], ['a', 'f', 'g', 'h', 'j'], ['a', 'f', 'g', 'i', 'j'], ['a', 'f', 'h', 'i', 'j'], ['a', 'g', 'h', 'i', 'j'], ['b', 'c', 'd', 'e', 'f'], ['b', 'c', 'd', 'e', 'g'], ['b', 'c', 'd', 'e', 'h'], ['b', 'c', 'd', 'e', 'i'], ['b', 'c', 'd', 'e', 'j'], ['b', 'c', 'd', 'f', 'g'], ['b', 'c', 'd', 'f', 'h'], ['b', 'c', 'd', 'f', 'i'], ['b', 'c', 'd', 'f', 'j'], ['b', 'c', 'd', 'g', 'h'], ['b', 'c', 'd', 'g', 'i'], ['b', 'c', 'd', 'g', 'j'], ['b', 'c', 'd', 'h', 'i'], ['b', 'c', 'd', 'h', 'j'], ['b', 'c', 'd', 'i', 'j'], ['b', 'c', 'e', 'f', 'g'], ['b', 'c', 'e', 'f', 'h'], ['b', 'c', 'e', 'f', 'i'], ['b', 'c', 'e', 'f', 'j'], ['b', 'c', 'e', 'g', 'h'], ['b', 'c', 'e', 'g', 'i'], ['b', 'c', 'e', 'g', 'j'], ['b', 'c', 'e', 'h', 'i'], ['b', 'c', 'e', 'h', 'j'], ['b', 'c', 'e', 'i', 'j'], ['b', 'c', 'f', 'g', 'h'], ['b', 'c', 'f', 'g', 'i'], ['b', 'c', 'f', 'g', 'j'], ['b', 'c', 'f', 'h', 'i'], ['b', 'c', 'f', 'h', 'j'], ['b', 'c', 'f', 'i', 'j'], ['b', 'c', 'g', 'h', 'i'], ['b', 'c', 'g', 'h', 'j'], ['b', 'c', 'g', 'i', 'j'], ['b', 'c', 'h', 'i', 'j'], ['b', 'd', 'e', 'f', 'g'], ['b', 'd', 'e', 'f', 'h'], ['b', 'd', 'e', 'f', 'i'], ['b', 'd', 'e', 'f', 'j'], ['b', 'd', 'e', 'g', 'h'], ['b', 'd', 'e', 'g', 'i'], ['b', 'd', 'e', 'g', 'j'], ['b', 'd', 'e', 'h', 'i'], ['b', 'd', 'e', 'h', 'j'], ['b', 'd', 'e', 'i', 'j'], ['b', 'd', 'f', 'g', 'h'], ['b', 'd', 'f', 'g', 'i'], ['b', 'd', 'f', 'g', 'j'], ['b', 'd', 'f', 'h', 'i'], ['b', 'd', 'f', 'h', 'j'], ['b', 'd', 'f', 'i', 'j'], ['b', 'd', 'g', 'h', 'i'], ['b', 'd', 'g', 'h', 'j'], ['b', 'd', 'g', 'i', 'j'], ['b', 'd', 'h', 'i', 'j'], ['b', 'e', 'f', 'g', 'h'], ['b', 'e', 'f', 'g', 'i'], ['b', 'e', 'f', 'g', 'j'], ['b', 'e', 'f', 'h', 'i'], ['b', 'e', 'f', 'h', 'j'], ['b', 'e', 'f', 'i', 'j'], ['b', 'e', 'g', 'h', 'i'], ['b', 'e', 'g', 'h', 'j'], ['b', 'e', 'g', 'i', 'j'], ['b', 'e', 'h', 'i', 'j'], ['b', 'f', 'g', 'h', 'i'], ['b', 'f', 'g', 'h', 'j'], ['b', 'f', 'g', 'i', 'j'], ['b', 'f', 'h', 'i', 'j'], ['b', 'g', 'h', 'i', 'j'], ['c', 'd', 'e', 'f', 'g'], ['c', 'd', 'e', 'f', 'h'], ['c', 'd', 'e', 'f', 'i'], ['c', 'd', 'e', 'f', 'j'], ['c', 'd', 'e', 'g', 'h'], ['c', 'd', 'e', 'g', 'i'], ['c', 'd', 'e', 'g', 'j'], ['c', 'd', 'e', 'h', 'i'], ['c', 'd', 'e', 'h', 'j'], ['c', 'd', 'e', 'i', 'j'], ['c', 'd', 'f', 'g', 'h'], ['c', 'd', 'f', 'g', 'i'], ['c', 'd', 'f', 'g', 'j'], ['c', 'd', 'f', 'h', 'i'], ['c', 'd', 'f', 'h', 'j'], ['c', 'd', 'f', 'i', 'j'], ['c', 'd', 'g', 'h', 'i'], ['c', 'd', 'g', 'h', 'j'], ['c', 'd', 'g', 'i', 'j'], ['c', 'd', 'h', 'i', 'j'], ['c', 'e', 'f', 'g', 'h'], ['c', 'e', 'f', 'g', 'i'], ['c', 'e', 'f', 'g', 'j'], ['c', 'e', 'f', 'h', 'i'], ['c', 'e', 'f', 'h', 'j'], ['c', 'e', 'f', 'i', 'j'], ['c', 'e', 'g', 'h', 'i'], ['c', 'e', 'g', 'h', 'j'], ['c', 'e', 'g', 'i', 'j'], ['c', 'e', 'h', 'i', 'j'], ['c', 'f', 'g', 'h', 'i'], ['c', 'f', 'g', 'h', 'j'], ['c', 'f', 'g', 'i', 'j'], ['c', 'f', 'h', 'i', 'j'], ['c', 'g', 'h', 'i', 'j'], ['d', 'e', 'f', 'g', 'h'], ['d', 'e', 'f', 'g', 'i'], ['d', 'e', 'f', 'g', 'j'], ['d', 'e', 'f', 'h', 'i'], ['d', 'e', 'f', 'h', 'j'], ['d', 'e', 'f', 'i', 'j'], ['d', 'e', 'g', 'h', 'i'], ['d', 'e', 'g', 'h', 'j'], ['d', 'e', 'g', 'i', 'j'], ['d', 'e', 'h', 'i', 'j'], ['d', 'f', 'g', 'h', 'i'], ['d', 'f', 'g', 'h', 'j'], ['d', 'f', 'g', 'i', 'j'], ['d', 'f', 'h', 'i', 'j'], ['d', 'g', 'h', 'i', 'j'], ['e', 'f', 'g', 'h', 'i'], ['e', 'f', 'g', 'h', 'j'], ['e', 'f', 'g', 'i', 'j'], ['e', 'f', 'h', 'i', 'j'], ['e', 'g', 'h', 'i', 'j'], ['f', 'g', 'h', 'i', 'j']]\n    assert candidate(['apple', 'banana', 'cherry', 'date'], 3) == [['apple', 'banana', 'cherry'], ['apple', 'banana', 'date'], ['apple', 'cherry', 'date'], ['banana', 'cherry', 'date']]\n    assert candidate(['red', 'green', 'blue', 'yellow', 'purple'], 5) == [['red', 'green', 'blue', 'yellow', 'purple']]\n    assert candidate(['a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j'], 10) == [['a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j']]\n    assert candidate(['egg'], 1) == [['egg']]\n    assert candidate(['oil', 'vinegar', 'mustard', 'honey', 'lemon'], 3) == [['oil', 'vinegar', 'mustard'], ['oil', 'vinegar', 'honey'], ['oil', 'vinegar', 'lemon'], ['oil', 'mustard', 'honey'], ['oil', 'mustard', 'lemon'], ['oil', 'honey', 'lemon'], ['vinegar', 'mustard', 'honey'], ['vinegar', 'mustard', 'lemon'], ['vinegar', 'honey', 'lemon'], ['mustard', 'honey', 'lemon']]\n    assert candidate(['basil', 'oregano', 'thyme', 'rosemary', 'sage'], 4) == [['basil', 'oregano', 'thyme', 'rosemary'], ['basil', 'oregano', 'thyme', 'sage'], ['basil', 'oregano', 'rosemary', 'sage'], ['basil', 'thyme', 'rosemary', 'sage'], ['oregano', 'thyme', 'rosemary', 'sage']]\n    assert candidate(['rice', 'beans', 'corn', 'peas'], 4) == [['rice', 'beans', 'corn', 'peas']]\n", "language": "python"}
{"task_id": "a42ae8dd-b03b-440d-9e94-7c7e283fdabb-7302320707704866518", "prompt": "Could you finish writing this function according to the documented behavior? Return the entire implementation in one code block.\n\n```python\nfrom typing import List\n\ndef quantum_entanglement(particles: List[int], observations: int) -> float:\n    \"\"\"\n    In a quantum physics experiment, you are studying the phenomenon of quantum entanglement.\n    You have a list of particles with their initial spin states (1 for up, -1 for down).\n    After a series of observations, you need to calculate the entanglement entropy.\n\n    The entanglement entropy is defined as the absolute difference between the number of\n    up spins and down spins, divided by the total number of particles, raised to the power\n    of the number of observations.\n\n    Parameters:\n    particles (List[int]): A list of initial particle spin states (1 or -1)\n    observations (int): The number of observations made\n\n    Returns:\n    float: The calculated entanglement entropy\n\n\n    [EXAMPLES]\n    \n    assert candidate([1, 1, 1, -1, -1, -1], 3) == 0.0\n    assert candidate([-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 1], 9) == 0.1643041066936036\n\n    [/EXAMPLES]\n    \"\"\"\n```\n", "entry_point": "quantum_entanglement", "solution": "from typing import List\n\ndef quantum_entanglement(particles: List[int], observations: int) -> float:\n    \"\"\"\n    In a quantum physics experiment, you are studying the phenomenon of quantum entanglement.\n    You have a list of particles with their initial spin states (1 for up, -1 for down).\n    After a series of observations, you need to calculate the entanglement entropy.\n\n    The entanglement entropy is defined as the absolute difference between the number of\n    up spins and down spins, divided by the total number of particles, raised to the power\n    of the number of observations.\n\n    Parameters:\n    particles (List[int]): A list of initial particle spin states (1 or -1)\n    observations (int): The number of observations made\n\n    Returns:\n    float: The calculated entanglement entropy\n\n\n    [EXAMPLES]\n    \n    assert candidate([1, 1, 1, -1, -1, -1], 3) == 0.0\n    assert candidate([-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 1], 9) == 0.1643041066936036\n\n    [/EXAMPLES]\n    \"\"\"\n    # Count the number of up spins (1) and down spins (-1)\n    up_spins = sum(1 for spin in particles if spin == 1)\n    down_spins = sum(1 for spin in particles if spin == -1)\n    \n    # Calculate the absolute difference between up and down spins\n    spin_difference = abs(up_spins - down_spins)\n    \n    # Calculate the total number of particles\n    total_particles = len(particles)\n    \n    # Calculate the entanglement entropy\n    if total_particles == 0:\n        return 0.0  # Avoid division by zero\n    \n    entropy = (spin_difference / total_particles) ** observations\n    \n    return entropy\n\n", "test": "def check(candidate):\n    assert candidate([-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 1], 9) == 0.1643041066936036\n    assert candidate([1, 1, 1, 1, 1, -1, -1, -1, -1, -1], 0) == 1.0\n    assert candidate([1, 1, 1, 1, 1, 1, 1, 1, 1, 1], 1) == 1.0\n    assert candidate([-1, -1, -1, -1, -1], 7) == 1.0\n    assert candidate([1, -1, 1, -1, 1, -1, 1, -1, 1, -1, 1, -1], 100) == 0.0\n    assert candidate([-1, -1, -1, -1, -1, -1, -1, -1, -1, -1], 6) == 1.0\n    assert candidate([1, 1, 1, 1, 1, 1, 1, 1, 1, 1, -1], 4) == 0.44812512806502297\n    assert candidate([1, -1, 1, -1, 1, -1, 1, -1, 1], 3) == 0.001371742112482853\n    assert candidate([1, -1], 0) == 1.0\n    assert candidate([1, 1, 1, -1, -1, -1], 3) == 0.0\n", "language": "python"}
{"task_id": "1af91305-fdd1-4bed-ab5d-169657326a095790187556447471420", "prompt": "Following the documented requirements, I'll complete the function implementation in one unified code block. All edge cases will be addressed in the solution.\n\n```python\nfrom typing import List, Tuple\n\ndef optimize_time_travel(events: List[Tuple[int, int, int]]) -> int:\n    \"\"\"\n    In a universe where time travel is possible, optimize the sequence of historical events\n    to maximize the positive impact on the timeline.\n    \n    This function takes a list of time travel events, where each event is represented by a tuple\n    containing (start_year, end_year, impact_score). The goal is to select a set of non-overlapping\n    events that maximizes the total impact score.\n    \n    The function employs dynamic programming to solve this optimization problem efficiently.\n    \n    Args:\n    events (List[Tuple[int, int, int]]): A list of time travel events, each represented as\n                                         (start_year, end_year, impact_score).\n    \n    Returns:\n    int: The maximum total impact score achievable.\n    \n\n    [EXAMPLES]\n    \n    assert candidate([(1, 10, 10), (5, 15, 20), (10, 20, 30), (15, 25, 40), (20, 30, 50)]) == 70\n    assert candidate([(1, 5, 5), (3, 7, 7), (5, 9, 9), (7, 11, 11), (9, 13, 13)]) == 20\n\n    [/EXAMPLES]\n    \"\"\"\n```\n", "entry_point": "optimize_time_travel", "solution": "from typing import List, Tuple\n\ndef optimize_time_travel(events: List[Tuple[int, int, int]]) -> int:\n    \"\"\"\n    In a universe where time travel is possible, optimize the sequence of historical events\n    to maximize the positive impact on the timeline.\n    \n    This function takes a list of time travel events, where each event is represented by a tuple\n    containing (start_year, end_year, impact_score). The goal is to select a set of non-overlapping\n    events that maximizes the total impact score.\n    \n    The function employs dynamic programming to solve this optimization problem efficiently.\n    \n    Args:\n    events (List[Tuple[int, int, int]]): A list of time travel events, each represented as\n                                         (start_year, end_year, impact_score).\n    \n    Returns:\n    int: The maximum total impact score achievable.\n    \n\n    [EXAMPLES]\n    \n    assert candidate([(1, 10, 10), (5, 15, 20), (10, 20, 30), (15, 25, 40), (20, 30, 50)]) == 70\n    assert candidate([(1, 5, 5), (3, 7, 7), (5, 9, 9), (7, 11, 11), (9, 13, 13)]) == 20\n\n    [/EXAMPLES]\n    \"\"\"\n    if not events:\n        return 0\n\n    # Sort events by end_year\n    events.sort(key=lambda x: x[1])\n\n    n = len(events)\n    dp = [0] * (n + 1)\n\n    def binary_search(end_year, left, right):\n        while left < right:\n            mid = (left + right) // 2\n            if events[mid][1] <= end_year:\n                left = mid + 1\n            else:\n                right = mid\n        return left - 1\n\n    for i in range(1, n + 1):\n        current_event = events[i - 1]\n        start_year, end_year, impact_score = current_event\n\n        # Find the latest non-overlapping event\n        j = binary_search(start_year, 0, i - 1)\n\n        # Calculate the maximum impact score including the current event\n        dp[i] = max(dp[i - 1], dp[j] + impact_score)\n\n    return dp[n]\n\n", "test": "def check(candidate):\n    assert candidate([(1, 10, 10), (1, 10, 20), (1, 10, 30), (1, 10, 40), (1, 10, 50)]) == 50\n    assert candidate([(1, 100, 100), (2, 3, 1), (4, 5, 1), (6, 7, 1)]) == 100\n    assert candidate([(2000, 2010, 10), (2005, 2015, 15), (2010, 2020, 20)]) == 20\n    assert candidate([(1, 2, 1), (2, 3, 1), (3, 4, 1), (4, 5, 1), (5, 6, 1000)]) == 1002\n    assert candidate([(1, 10, 10), (5, 15, 20), (10, 20, 30), (15, 25, 40), (20, 30, 50)]) == 70\n    assert candidate([(2000, 2001, 1), (2001, 2002, 2)]) == 2\n    assert candidate([(1, 5, 5), (3, 7, 7), (5, 9, 9), (7, 11, 11), (9, 13, 13)]) == 20\n    assert candidate([(1, 2, 1), (2, 3, 1), (3, 4, 1), (4, 5, 1), (5, 6, 1)]) == 3\n    assert candidate([(1, 1000000, 1000000), (2, 3, 1), (4, 5, 1), (6, 7, 1)]) == 1000000\n    assert candidate([(1, 2, 1), (2, 3, 2), (3, 4, 3), (4, 5, 4), (5, 6, 5)]) == 9\n", "language": "python"}
{"task_id": "9947feca-298a-4d74-9952-0017151148b84927409164524396759", "prompt": "Based on the docstring provided, I'll implement the function while maintaining the original function name and parameters. Here's the complete code in a single block:\n\n```python\nfrom typing import List\n\ndef analyze_crop_yield(field_data: List[List[int]], rainfall: int) -> float:\n    \"\"\"\n    A farming cooperative wants to analyze the crop yield of their fields based on soil quality and rainfall.\n    Each sublist in field_data represents a row in the field, where each integer represents the soil quality (0-10).\n    The function should calculate the expected crop yield based on the average soil quality and rainfall.\n\n    The crop yield is calculated as follows:\n    - If rainfall is less than 500mm, yield is (avg_soil_quality * 0.5) tons per hectare\n    - If rainfall is between 500mm and 1000mm, yield is (avg_soil_quality * 0.8) tons per hectare\n    - If rainfall is more than 1000mm, yield is (avg_soil_quality * 1.2) tons per hectare\n\n\n    [EXAMPLES]\n    \n    assert candidate([[5, 5], [5, 5], [5, 5], [5, 5]], 800) == 4.0\n    assert candidate([[i for i in range(11)]] * 5, 600) == 4.0\n\n    [/EXAMPLES]\n    \"\"\"\n```\n", "entry_point": "analyze_crop_yield", "solution": "from typing import List\n\ndef analyze_crop_yield(field_data: List[List[int]], rainfall: int) -> float:\n    \"\"\"\n    A farming cooperative wants to analyze the crop yield of their fields based on soil quality and rainfall.\n    Each sublist in field_data represents a row in the field, where each integer represents the soil quality (0-10).\n    The function should calculate the expected crop yield based on the average soil quality and rainfall.\n\n    The crop yield is calculated as follows:\n    - If rainfall is less than 500mm, yield is (avg_soil_quality * 0.5) tons per hectare\n    - If rainfall is between 500mm and 1000mm, yield is (avg_soil_quality * 0.8) tons per hectare\n    - If rainfall is more than 1000mm, yield is (avg_soil_quality * 1.2) tons per hectare\n\n\n    [EXAMPLES]\n    \n    assert candidate([[5, 5], [5, 5], [5, 5], [5, 5]], 800) == 4.0\n    assert candidate([[i for i in range(11)]] * 5, 600) == 4.0\n\n    [/EXAMPLES]\n    \"\"\"\n    # Calculate the average soil quality\n    total_soil_quality = sum(sum(row) for row in field_data)\n    total_cells = sum(len(row) for row in field_data)\n    avg_soil_quality = total_soil_quality / total_cells\n\n    # Determine the yield multiplier based on rainfall\n    if rainfall < 500:\n        yield_multiplier = 0.5\n    elif 500 <= rainfall <= 1000:\n        yield_multiplier = 0.8\n    else:\n        yield_multiplier = 1.2\n\n    # Calculate and return the crop yield\n    crop_yield = avg_soil_quality * yield_multiplier\n    return round(crop_yield, 2)\n\n", "test": "def check(candidate):\n    assert candidate([[0, 10], [10, 0]], 501) == 4.0\n    assert candidate([[3, 3, 3]], 0) == 1.5\n    assert candidate([[0, 0, 0], [0, 0, 0]], 1000) == 0.0\n    assert candidate([[8, 8, 8, 8], [8, 8, 8, 8]], 400) == 4.0\n    assert candidate([[2, 4, 6, 8, 10]], 900) == 4.8\n    assert candidate([[i for i in range(11)]] * 5, 600) == 4.0\n    assert candidate([[9, 9, 9], [9, 9, 9]], 2000) == 10.8\n    assert candidate([[5, 5], [5, 5], [5, 5], [5, 5]], 800) == 4.0\n    assert candidate([[1], [2], [3], [4], [5]], 1200) == 3.6\n    assert candidate([[1, 2, 3, 4, 5], [6, 7, 8, 9, 10]], 600) == 4.4\n", "language": "python"}
{"task_id": "bbdc7544-8703-49fd-bdfb-c0a77f747604-492320923760272525", "prompt": "As a coding assistant, I'll complete the function you provide so that it works properly when executed. I'll stay within the function boundaries and won't add any code outside of it. I'll only use libraries that are already imported in the problem statement. If I need to create helper functions or classes, I'll define them inside the main function you've provided.\n\n```python\nfrom typing import List\nfrom collections import deque\n\ndef robot_escape_maze(maze: List[List[int]]) -> int:\n    \"\"\"\n    Calculate the minimum number of moves for a robot to escape a maze.\n\n    A robot is trapped in a maze represented by a 2D grid. The robot starts at the top-left\n    corner (0,0) and needs to reach the bottom-right corner. The robot can move up, down,\n    left, or right, but cannot move diagonally. Some cells are blocked (represented by 1),\n    and the robot cannot pass through these cells.\n\n    Parameters:\n    maze (List[List[int]]): A 2D list representing the maze. 0 represents an open cell,\n                            and 1 represents a blocked cell.\n\n    Returns:\n    int: The minimum number of moves required to reach the bottom-right corner.\n         Returns -1 if it's impossible to reach the exit.\n\n\n    [EXAMPLES]\n    \n    assert candidate([[0,0,0,0],[0,1,1,0],[0,1,0,0],[0,0,0,0]]) == 6\n    assert candidate([[0,0,0],[1,1,0],[1,1,0]]) == 4\n\n    [/EXAMPLES]\n    \"\"\"\n```\n", "entry_point": "robot_escape_maze", "solution": "from typing import List\nfrom collections import deque\n\ndef robot_escape_maze(maze: List[List[int]]) -> int:\n    \"\"\"\n    Calculate the minimum number of moves for a robot to escape a maze.\n\n    A robot is trapped in a maze represented by a 2D grid. The robot starts at the top-left\n    corner (0,0) and needs to reach the bottom-right corner. The robot can move up, down,\n    left, or right, but cannot move diagonally. Some cells are blocked (represented by 1),\n    and the robot cannot pass through these cells.\n\n    Parameters:\n    maze (List[List[int]]): A 2D list representing the maze. 0 represents an open cell,\n                            and 1 represents a blocked cell.\n\n    Returns:\n    int: The minimum number of moves required to reach the bottom-right corner.\n         Returns -1 if it's impossible to reach the exit.\n\n\n    [EXAMPLES]\n    \n    assert candidate([[0,0,0,0],[0,1,1,0],[0,1,0,0],[0,0,0,0]]) == 6\n    assert candidate([[0,0,0],[1,1,0],[1,1,0]]) == 4\n\n    [/EXAMPLES]\n    \"\"\"\n    if not maze or not maze[0]:\n        return -1\n\n    rows, cols = len(maze), len(maze[0])\n    \n    # If start or end is blocked, return -1\n    if maze[0][0] == 1 or maze[rows-1][cols-1] == 1:\n        return -1\n\n    # Define possible moves: right, down, left, up\n    directions = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n\n    # Initialize queue for BFS\n    queue = deque([(0, 0, 0)])  # (row, col, moves)\n    visited = set([(0, 0)])\n\n    while queue:\n        row, col, moves = queue.popleft()\n\n        # Check if we've reached the bottom-right corner\n        if row == rows - 1 and col == cols - 1:\n            return moves\n\n        # Explore all possible directions\n        for dr, dc in directions:\n            new_row, new_col = row + dr, col + dc\n\n            # Check if the new position is valid and not visited\n            if (0 <= new_row < rows and 0 <= new_col < cols and \n                maze[new_row][new_col] == 0 and \n                (new_row, new_col) not in visited):\n                \n                queue.append((new_row, new_col, moves + 1))\n                visited.add((new_row, new_col))\n\n    # If we can't reach the exit\n    return -1\n\n", "test": "def check(candidate):\n    assert candidate([[0,1],[1,0]]) == -1\n    assert candidate([[0,0],[0,0]]) == 2\n    assert candidate([[0,0,0],[1,1,0],[1,1,0]]) == 4\n    assert candidate([[0,1],[0,0]]) == 2\n    assert candidate([[0,1,0],[0,1,0],[0,0,0]]) == 4\n    assert candidate([[0,0,0,0,0],[1,1,1,1,0],[0,0,0,0,0],[0,1,1,1,1],[0,0,0,0,0]]) == 16\n    assert candidate([[0,0,0,0],[1,1,1,0],[0,0,0,0],[0,1,1,0]]) == 6\n    assert candidate([[0,0,0,0],[0,1,1,0],[0,1,0,0],[0,0,0,0]]) == 6\n    assert candidate([[0,0,0],[0,1,0],[0,0,0]]) == 4\n    assert candidate([[0,1,0,0,0],[0,1,0,1,0],[0,0,0,1,0],[1,1,0,1,0],[0,0,0,1,0]]) == 12\n", "language": "python"}
{"task_id": "9b490412-df50-47d7-9af0-b1385c56b970-583968284027654972", "prompt": "Based on the docstring, I'll implement the function logic maintaining the exact function signature.\n\n```python\ndef optimal_fertilizer_scoop(bag1: int, bag2: int) -> int:\n    \"\"\"\n    A gardener needs to efficiently distribute fertilizer from two bags of different weights.\n    They want to find the largest scoop size that can empty both bags in a whole number of scoops.\n\n    Parameters:\n    bag1 (int): The weight of the first fertilizer bag in kilograms.\n    bag2 (int): The weight of the second fertilizer bag in kilograms.\n\n    Returns:\n    int: The maximum capacity of the scoop in kilograms.\n\n\n    [EXAMPLES]\n    \n    assert candidate(99, 33) == 33\n    assert candidate(2, 3) == 1\n\n    [/EXAMPLES]\n    \"\"\"\n```\n", "entry_point": "optimal_fertilizer_scoop", "solution": "def optimal_fertilizer_scoop(bag1: int, bag2: int) -> int:\n    \"\"\"\n    A gardener needs to efficiently distribute fertilizer from two bags of different weights.\n    They want to find the largest scoop size that can empty both bags in a whole number of scoops.\n\n    Parameters:\n    bag1 (int): The weight of the first fertilizer bag in kilograms.\n    bag2 (int): The weight of the second fertilizer bag in kilograms.\n\n    Returns:\n    int: The maximum capacity of the scoop in kilograms.\n\n\n    [EXAMPLES]\n    \n    assert candidate(99, 33) == 33\n    assert candidate(2, 3) == 1\n\n    [/EXAMPLES]\n    \"\"\"\n    def gcd(a: int, b: int) -> int:\n        \"\"\"Calculate the Greatest Common Divisor of a and b.\"\"\"\n        while b:\n            a, b = b, a % b\n        return a\n\n    return gcd(bag1, bag2)\n\n", "test": "def check(candidate):\n    assert candidate(17, 23) == 1\n    assert candidate(100, 200) == 100\n    assert candidate(8, 12) == 4\n    assert candidate(1000, 1500) == 500\n    assert candidate(99, 33) == 33\n    assert candidate(5, 7) == 1\n    assert candidate(2, 3) == 1\n    assert candidate(50, 75) == 25\n", "language": "python"}
{"task_id": "92b8de01-e6a2-46d0-8493-2784fb8b01a13408996981096491277", "prompt": "Please complete the function based on the provided docstring. Here's the implementation in a single code block.\n\n```python\nfrom typing import List\nimport math\n\ndef calculate_stellar_energy(star_types: List[str], temperatures: List[int], radii: List[float]) -> float:\n    \"\"\"\n    Calculate the total energy output of a group of stars based on their types, temperatures, and radii.\n\n    Given lists of star types, temperatures (in Kelvin), and radii (in solar radii), compute the total\n    energy output of all stars combined. Use the Stefan-Boltzmann law and type-specific efficiency factors.\n\n    The function should return the total energy output in Joules per second.\n\n\n    [EXAMPLES]\n    \n    assert candidate([\"M\"], [3500], [0.5]) == 7.762477709638876e+24\n    assert candidate([\"M\"], [2800], [0.1]) == 1.2718043479472331e+23\n\n    [/EXAMPLES]\n    \"\"\"\n```\n", "entry_point": "calculate_stellar_energy", "solution": "from typing import List\nimport math\n\ndef calculate_stellar_energy(star_types: List[str], temperatures: List[int], radii: List[float]) -> float:\n    \"\"\"\n    Calculate the total energy output of a group of stars based on their types, temperatures, and radii.\n\n    Given lists of star types, temperatures (in Kelvin), and radii (in solar radii), compute the total\n    energy output of all stars combined. Use the Stefan-Boltzmann law and type-specific efficiency factors.\n\n    The function should return the total energy output in Joules per second.\n\n\n    [EXAMPLES]\n    \n    assert candidate([\"M\"], [3500], [0.5]) == 7.762477709638876e+24\n    assert candidate([\"M\"], [2800], [0.1]) == 1.2718043479472331e+23\n\n    [/EXAMPLES]\n    \"\"\"\n    def get_efficiency_factor(star_type: str) -> float:\n        \"\"\"Return the efficiency factor based on the star type.\"\"\"\n        efficiency_factors = {\n            'O': 0.90,\n            'B': 0.85,\n            'A': 0.80,\n            'F': 0.75,\n            'G': 0.70,\n            'K': 0.65,\n            'M': 0.60\n        }\n        return efficiency_factors.get(star_type, 0.70)  # Default to 0.70 if type is unknown\n\n    # Stefan-Boltzmann constant (in W/m^2/K^4)\n    sigma = 5.67e-8\n\n    # Solar radius in meters\n    solar_radius = 6.957e8\n\n    total_energy = 0.0\n\n    for star_type, temperature, radius in zip(star_types, temperatures, radii):\n        # Convert radius from solar radii to meters\n        radius_meters = radius * solar_radius\n\n        # Calculate surface area of the star\n        surface_area = 4 * math.pi * radius_meters ** 2\n\n        # Calculate energy output using Stefan-Boltzmann law\n        energy = sigma * surface_area * temperature ** 4\n\n        # Apply efficiency factor based on star type\n        efficiency = get_efficiency_factor(star_type)\n        energy *= efficiency\n\n        # Add to total energy\n        total_energy += energy\n\n    return total_energy\n\n\n", "test": "def check(candidate):\n    assert candidate([\"O\"], [50000], [15.0]) == 4.36457513869741e+32\n    assert candidate([\"B\", \"O\", \"B\", \"O\"], [28000, 45000, 30000, 48000], [6.0, 12.0, 7.0, 14.0]) == 5.243147711073921e+32\n    assert candidate([\"M\"], [3500], [0.5]) == 7.762477709638876e+24\n    assert candidate([\"G\", \"K\", \"M\", \"M\", \"K\"], [5700, 4400, 3300, 3100, 4600], [1.05, 0.85, 0.45, 0.35, 0.9]) == 4.3024639832640065e+26\n    assert candidate([\"K\", \"K\", \"K\"], [4000, 4200, 4100], [0.7, 0.75, 0.72]) == 1.0018882538008052e+26\n    assert candidate([\"F\", \"K\", \"G\", \"M\"], [6500, 4500, 5900, 3100], [1.2, 0.8, 1.1, 0.4]) == 1.0806592443657652e+27\n    assert candidate([\"A\"], [8500], [2.0]) == 5.7605322296754e+27\n    assert candidate([\"M\"], [2800], [0.1]) == 1.2718043479472331e+23\n    assert candidate([\"O\", \"O\", \"O\", \"O\"], [35000, 38000, 40000, 42000], [8.0, 9.0, 10.0, 11.0]) == 2.785417482937288e+32\n", "language": "python"}
{"task_id": "7de32c5e-6465-4e01-861a-4941464752a4-6165258980509968565", "prompt": "I'll finish this function implementation based on what the docstring indicates it should do. The function name and arguments will remain the same, and I'll present the complete code in a single block.\n\n```python\nfrom typing import List\nfrom typing import List, Tuple\n\ndef find_equilibrium_indices(temperatures: List[float]) -> List[int]:\n    \"\"\"\n    As a climatologist, you're analyzing temperature data from various weather stations.\n    You want to find \"equilibrium points\" in the data, where the sum of temperatures\n    before a given index equals the sum of temperatures after it.\n\n    This function takes a list of temperatures and returns a list of indices where\n    the equilibrium condition is met. If no such indices exist, return an empty list.\n\n\n    [EXAMPLES]\n    \n    assert candidate([1.0, 2.0, 3.0, 4.0, 5.0]) == []\n    assert candidate([-1.5, 3.0, -1.5, 0.0, 3.0, -1.5, -1.5]) == [1, 3]\n\n    [/EXAMPLES]\n    \"\"\"\n```\n", "entry_point": "find_equilibrium_indices", "solution": "from typing import List\nfrom typing import List, Tuple\n\ndef find_equilibrium_indices(temperatures: List[float]) -> List[int]:\n    \"\"\"\n    As a climatologist, you're analyzing temperature data from various weather stations.\n    You want to find \"equilibrium points\" in the data, where the sum of temperatures\n    before a given index equals the sum of temperatures after it.\n\n    This function takes a list of temperatures and returns a list of indices where\n    the equilibrium condition is met. If no such indices exist, return an empty list.\n\n\n    [EXAMPLES]\n    \n    assert candidate([1.0, 2.0, 3.0, 4.0, 5.0]) == []\n    assert candidate([-1.5, 3.0, -1.5, 0.0, 3.0, -1.5, -1.5]) == [1, 3]\n\n    [/EXAMPLES]\n    \"\"\"\n    total_sum = sum(temperatures)\n    left_sum = 0\n    equilibrium_indices = []\n\n    for i, temp in enumerate(temperatures):\n        right_sum = total_sum - left_sum - temp\n        \n        if left_sum == right_sum:\n            equilibrium_indices.append(i)\n        \n        left_sum += temp\n\n    return equilibrium_indices\n\n", "test": "def check(candidate):\n    assert candidate([1.0, 2.0, 3.0, 4.0, 5.0]) == []\n    assert candidate([5.0, 4.0, 3.0, 2.0, 1.0]) == []\n    assert candidate([-1.5, 3.0, -1.5, 0.0, 3.0, -1.5, -1.5]) == [1, 3]\n    assert candidate([0.0]) == [0]\n    assert candidate([10.0, -10.0, 10.0, -10.0]) == []\n    assert candidate([0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0]) == [3]\n    assert candidate([5.0, 5.0, 5.0, 5.0, 5.0]) == [2]\n    assert candidate([1000.0, -1000.0, 1000.0, -1000.0, 1000.0]) == [0, 1, 2, 3, 4]\n    assert candidate([3.14159, 2.71828, 1.41421, 1.73205, 2.23607]) == []\n    assert candidate([-5.0, 5.0, -5.0, 5.0, -5.0]) == [0, 1, 2, 3, 4]\n", "language": "python"}
{"task_id": "c63cd23d-8dc8-4d91-9dac-31a9ac4419cd8757091908599703047", "prompt": "I'll create a fully executable function containing all necessary code. All helper functions and classes will be defined within the main function scope. I'll only utilize libraries that were imported in the original problem statement.\n\n```python\nfrom typing import List\n\ndef find_treasure_spots(map_grid: List[List[int]]) -> List[tuple]:\n    \"\"\"\n    An archaeologist has discovered an ancient map represented as a 2D grid. Each cell in the grid\n    contains a number indicating the altitude of that location. A treasure spot is defined as a cell\n    where the altitude is strictly greater than all of its adjacent cells (up, down, left, right, and diagonals).\n\n    Write a function that takes the map grid as input and returns a list of tuples representing the\n    coordinates of all treasure spots.\n\n\n    [EXAMPLES]\n    \n    assert candidate([[3, 3, 3], [3, 4, 3], [3, 3, 3]]) == [(1, 1)]\n    assert candidate([[0, 1, 0], [1, 0, 1], [0, 1, 0]]) == []\n\n    [/EXAMPLES]\n    \"\"\"\n```\n", "entry_point": "find_treasure_spots", "solution": "from typing import List\n\ndef find_treasure_spots(map_grid: List[List[int]]) -> List[tuple]:\n    \"\"\"\n    An archaeologist has discovered an ancient map represented as a 2D grid. Each cell in the grid\n    contains a number indicating the altitude of that location. A treasure spot is defined as a cell\n    where the altitude is strictly greater than all of its adjacent cells (up, down, left, right, and diagonals).\n\n    Write a function that takes the map grid as input and returns a list of tuples representing the\n    coordinates of all treasure spots.\n\n\n    [EXAMPLES]\n    \n    assert candidate([[3, 3, 3], [3, 4, 3], [3, 3, 3]]) == [(1, 1)]\n    assert candidate([[0, 1, 0], [1, 0, 1], [0, 1, 0]]) == []\n\n    [/EXAMPLES]\n    \"\"\"\n    def is_treasure_spot(row, col):\n        height = map_grid[row][col]\n        for dr in [-1, 0, 1]:\n            for dc in [-1, 0, 1]:\n                if dr == 0 and dc == 0:\n                    continue\n                nr, nc = row + dr, col + dc\n                if 0 <= nr < rows and 0 <= nc < cols:\n                    if map_grid[nr][nc] >= height:\n                        return False\n        return True\n\n    rows = len(map_grid)\n    cols = len(map_grid[0]) if rows > 0 else 0\n    treasure_spots = []\n\n    for r in range(rows):\n        for c in range(cols):\n            if is_treasure_spot(r, c):\n                treasure_spots.append((r, c))\n\n    return treasure_spots\n\n", "test": "def check(candidate):\n    assert candidate([[9, 8, 7], [6, 5, 4], [3, 2, 1]]) == [(0, 0)]\n    assert candidate([[0, 1, 0], [1, 0, 1], [0, 1, 0]]) == []\n    assert candidate([[1, 1, 1], [1, 2, 1], [1, 1, 1]]) == [(1, 1)]\n    assert candidate([[1, 2, 3], [4, 5, 6], [7, 8, 9]]) == [(2, 2)]\n    assert candidate([[3, 3, 3], [3, 4, 3], [3, 3, 3]]) == [(1, 1)]\n    assert candidate([[10, 20, 30], [40, 50, 60], [70, 80, 90]]) == [(2, 2)]\n    assert candidate([[1, 2, 3, 4, 5], [2, 3, 4, 5, 1], [3, 4, 5, 1, 2], [4, 5, 1, 2, 3], [5, 1, 2, 3, 4]]) == [(4, 4)]\n    assert candidate([[1, 2, 3, 4], [5, 6, 7, 8], [9, 10, 11, 12], [13, 14, 15, 16]]) == [(3, 3)]\n    assert candidate([[1]]) == [(0, 0)]\n    assert candidate([[1, 2], [3, 4]]) == [(1, 1)]\n", "language": "python"}
{"task_id": "a6e20c2d-3a0f-4eb8-9336-b0f43004a90b-3693344676276010659", "prompt": "I'll write the rest of this function according to its doc string. I'll put the complete function in one code block.\n\n```python\ndef encrypt_message(message: str, key: int) -> str:\n    \"\"\"\n    In a secure communication system, we need to encrypt messages before transmission.\n    This function implements a simple substitution cipher where each letter in the message\n    is shifted by a certain number of positions in the alphabet, wrapping around if necessary.\n\n    The function takes a string message (containing only uppercase letters and spaces) and\n    an integer key as input. It returns the encrypted message where each letter has been\n    shifted 'key' positions forward in the alphabet. Spaces remain unchanged.\n\n\n    [EXAMPLES]\n    \n    assert candidate(\"SPACE TEST\", 5) == 'XUFHJ YJXY'\n    assert candidate(\"PYTHON\", 25) == 'OXSGNM'\n\n    [/EXAMPLES]\n    \"\"\"\n```\n", "entry_point": "encrypt_message", "solution": "def encrypt_message(message: str, key: int) -> str:\n    \"\"\"\n    In a secure communication system, we need to encrypt messages before transmission.\n    This function implements a simple substitution cipher where each letter in the message\n    is shifted by a certain number of positions in the alphabet, wrapping around if necessary.\n\n    The function takes a string message (containing only uppercase letters and spaces) and\n    an integer key as input. It returns the encrypted message where each letter has been\n    shifted 'key' positions forward in the alphabet. Spaces remain unchanged.\n\n\n    [EXAMPLES]\n    \n    assert candidate(\"SPACE TEST\", 5) == 'XUFHJ YJXY'\n    assert candidate(\"PYTHON\", 25) == 'OXSGNM'\n\n    [/EXAMPLES]\n    \"\"\"\n    def shift_letter(letter: str, shift: int) -> str:\n        if letter == ' ':\n            return ' '\n        return chr((ord(letter) - 65 + shift) % 26 + 65)\n\n    encrypted_message = ''.join(shift_letter(char, key) for char in message)\n    return encrypted_message\n\n", "test": "def check(candidate):\n    assert candidate(\"XYZ\", 3) == 'ABC'\n    assert candidate(\"SPACE TEST\", 5) == 'XUFHJ YJXY'\n    assert candidate(\"MULTIPLE WORDS IN A SENTENCE\", 7) == 'TBSAPWSL DVYKZ PU H ZLUALUJL'\n    assert candidate(\"CRYPTOGRAPHY IS FUN\", 13) == 'PELCGBTENCUL VF SHA'\n    assert candidate(\"TEST\", 0) == 'TEST'\n    assert candidate(\"A B C D E F G H I J K L M N O P Q R S T U V W X Y Z\", 13) == 'N O P Q R S T U V W X Y Z A B C D E F G H I J K L M'\n    assert candidate(\"PYTHON\", 25) == 'OXSGNM'\n    assert candidate(\"A\", 1) == 'B'\n    assert candidate(\"HELLO WORLD\", 3) == 'KHOOR ZRUOG'\n    assert candidate(\"X\", 25) == 'W'\n", "language": "python"}
{"task_id": "e7d93e99-11e4-4824-a55c-4174fedc3d67-3444324585760028962", "prompt": "You function as a coding assistant whose purpose is completing provided functions that can run directly in code blocks. Never include code outside the function scope. Restrict yourself to libraries already imported in the problem. When needed, define auxiliary functions or classes inside the primary function.\n\n```python\ndef encrypt_message(message: str, key: int) -> str:\n    \"\"\"\n    In a secret agent training program, trainees are given a message and a key. Their task is to encrypt the message\n    using a simple substitution cipher where each letter is replaced by the letter that appears 'key' positions after\n    it in the alphabet. The alphabet wraps around, so 'z' with a key of 1 becomes 'a'.\n\n    This function takes a message (lowercase letters only) and a key, and returns the encrypted message.\n\n\n    [EXAMPLES]\n    \n    assert candidate(\"world\", 5) == 'btwqi'\n    assert candidate(\"hello\", 1) == 'ifmmp'\n\n    [/EXAMPLES]\n    \"\"\"\n```\n", "entry_point": "encrypt_message", "solution": "def encrypt_message(message: str, key: int) -> str:\n    \"\"\"\n    In a secret agent training program, trainees are given a message and a key. Their task is to encrypt the message\n    using a simple substitution cipher where each letter is replaced by the letter that appears 'key' positions after\n    it in the alphabet. The alphabet wraps around, so 'z' with a key of 1 becomes 'a'.\n\n    This function takes a message (lowercase letters only) and a key, and returns the encrypted message.\n\n\n    [EXAMPLES]\n    \n    assert candidate(\"world\", 5) == 'btwqi'\n    assert candidate(\"hello\", 1) == 'ifmmp'\n\n    [/EXAMPLES]\n    \"\"\"\n    def shift_letter(letter: str, shift: int) -> str:\n        if not letter.isalpha():\n            return letter\n        \n        # Calculate the new ASCII value\n        new_ascii = ord(letter) + shift\n        \n        # Wrap around if necessary\n        if new_ascii > ord('z'):\n            new_ascii -= 26\n        \n        return chr(new_ascii)\n\n    # Normalize the key to be within 0-25\n    key = key % 26\n    \n    # Apply the shift to each letter in the message\n    encrypted_message = ''.join(shift_letter(char, key) for char in message)\n    \n    return encrypted_message\n\n", "test": "def check(candidate):\n    assert candidate(\"zzz\", 1) == 'aaa'\n    assert candidate(\"hello\", 1) == 'ifmmp'\n    assert candidate(\"a\", 1) == 'b'\n    assert candidate(\"world\", 5) == 'btwqi'\n    assert candidate(\"\", 5) == ''\n    assert candidate(\"extremeshift\", 100) == 'atpnaiaodebp'\n    assert candidate(\"wraparound\", 26) == 'wraparound'\n    assert candidate(\"z\", 1) == 'a'\n    assert candidate(\"edgecase\", 25) == 'dcfdbzrd'\n    assert candidate(\"repeatedletters\", 9) == 'anynjcnmunccnab'\n", "language": "python"}
{"task_id": "8102b931-d303-451e-8e9b-9e5f53dd1a9b347509223660063891", "prompt": "I'll implement the body of this function to fulfill the requirements in the docstring. The function name and parameter list will remain unchanged.\n\n```python\nimport math\nfrom typing import List, Tuple\n\ndef juggler_sequence(n: int, max_steps: int) -> Tuple[List[int], int]:\n    \"\"\"\n    A juggler at a circus is practicing a new sequence trick. In this trick, he starts with a number n and follows these rules:\n    - If n is even, the next number is the floor of the square root of n.\n    - If n is odd, the next number is the floor of n^(3/2).\n    He continues this sequence until he reaches 1 or the maximum number of steps is reached.\n\n    This function calculates the juggler sequence and returns the sequence along with the number of steps taken.\n\n    :param n: The starting number for the juggler sequence\n    :param max_steps: The maximum number of steps allowed\n    :return: A tuple containing the list of numbers in the sequence and the number of steps taken\n\n\n    [EXAMPLES]\n    \n    assert candidate(2**10, 30) == ([1024, 32, 5, 11, 36, 6, 2, 1], 7)\n    assert candidate(2, 2) == ([2, 1], 1)\n\n    [/EXAMPLES]\n    \"\"\"\n```\n", "entry_point": "juggler_sequence", "solution": "import math\nfrom typing import List, Tuple\n\ndef juggler_sequence(n: int, max_steps: int) -> Tuple[List[int], int]:\n    \"\"\"\n    A juggler at a circus is practicing a new sequence trick. In this trick, he starts with a number n and follows these rules:\n    - If n is even, the next number is the floor of the square root of n.\n    - If n is odd, the next number is the floor of n^(3/2).\n    He continues this sequence until he reaches 1 or the maximum number of steps is reached.\n\n    This function calculates the juggler sequence and returns the sequence along with the number of steps taken.\n\n    :param n: The starting number for the juggler sequence\n    :param max_steps: The maximum number of steps allowed\n    :return: A tuple containing the list of numbers in the sequence and the number of steps taken\n\n\n    [EXAMPLES]\n    \n    assert candidate(2**10, 30) == ([1024, 32, 5, 11, 36, 6, 2, 1], 7)\n    assert candidate(2, 2) == ([2, 1], 1)\n\n    [/EXAMPLES]\n    \"\"\"\n    sequence = [n]\n    steps = 0\n\n    while n != 1 and steps < max_steps:\n        if n % 2 == 0:\n            n = math.isqrt(n)  # floor of square root for even numbers\n        else:\n            n = math.floor(n ** (3/2))  # floor of n^(3/2) for odd numbers\n        \n        sequence.append(n)\n        steps += 1\n\n    return (sequence, steps)\n\n", "test": "def check(candidate):\n    assert candidate(12345, 60) == ([12345, 1371628, 1171, 40071, 8021309, 22717883603, 3424142302979383, 200367697538239835406336, 447624505068, 669047, 547248955, 12801987871111, 45805340629221236736, 6767964289, 556784437230918, 23596280, 4857, 338494, 581, 14004, 118, 10, 3, 5, 11, 36, 6, 2, 1], 28)\n    assert candidate(9999, 100) == ([9999, 999850, 999, 31575, 5610674, 2368, 48, 6, 2, 1], 9)\n    assert candidate(2, 2) == ([2, 1], 1)\n    assert candidate(7, 3) == ([7, 18, 4, 2], 3)\n    assert candidate(10, 15) == ([10, 3, 5, 11, 36, 6, 2, 1], 7)\n    assert candidate(3, 10) == ([3, 5, 11, 36, 6, 2, 1], 6)\n    assert candidate(20, 10) == ([20, 4, 2, 1], 3)\n    assert candidate(2**10, 30) == ([1024, 32, 5, 11, 36, 6, 2, 1], 7)\n    assert candidate(999, 40) == ([999, 31575, 5610674, 2368, 48, 6, 2, 1], 7)\n    assert candidate(3**7, 40) == ([2187, 102275, 32708018, 5719, 432494, 657, 16840, 129, 1465, 56073, 13277939, 48383357647, 10642508495641456, 103162534, 10156, 100, 10, 3, 5, 11, 36, 6, 2, 1], 23)\n", "language": "python"}
{"task_id": "f1e61b2c-9073-465e-951c-119e033d3b051438692158609279227", "prompt": "I need you to complete a function that's ready to run. Provide just the complete function in a code block without any external code. Only use the imported libraries. If you need extra functions or classes, define them within the given function. Please give me only one code block as your response.\n\n```python\nimport math\n\ndef calculate_polygon_area(sides: int, length: float) -> float:\n    \"\"\"\n    Calculate the area of a regular polygon given the number of sides and side length.\n\n    This function computes the area of a regular polygon using the formula:\n    Area = (n * s^2) / (4 * tan(\u03c0/n))\n    where n is the number of sides and s is the length of each side.\n\n\n    [EXAMPLES]\n    \n    assert candidate(1000, 0.001) == 0.07957720974638761\n    assert candidate(6, 3.141592654) == 25.641984416634553\n\n    [/EXAMPLES]\n    \"\"\"\n```\n", "entry_point": "calculate_polygon_area", "solution": "import math\n\ndef calculate_polygon_area(sides: int, length: float) -> float:\n    \"\"\"\n    Calculate the area of a regular polygon given the number of sides and side length.\n\n    This function computes the area of a regular polygon using the formula:\n    Area = (n * s^2) / (4 * tan(\u03c0/n))\n    where n is the number of sides and s is the length of each side.\n\n\n    [EXAMPLES]\n    \n    assert candidate(1000, 0.001) == 0.07957720974638761\n    assert candidate(6, 3.141592654) == 25.641984416634553\n\n    [/EXAMPLES]\n    \"\"\"\n    if sides < 3:\n        raise ValueError(\"Number of sides must be at least 3 for a polygon.\")\n    if length <= 0:\n        raise ValueError(\"Side length must be positive.\")\n\n    area = (sides * length**2) / (4 * math.tan(math.pi / sides))\n    return area\n\n", "test": "def check(candidate):\n    assert candidate(6, 4.2) == 45.830064368272495\n    assert candidate(15, 1.5) == 39.69531654872446\n    assert candidate(1000, 0.001) == 0.07957720974638761\n    assert candidate(5, 3.7) == 23.55333561406296\n    assert candidate(5, 999999.999) == 1720477397148.0117\n    assert candidate(8, 5.5) == 146.05992052357226\n    assert candidate(3, 1.0) == 0.43301270189221946\n    assert candidate(3, 0.1) == 0.004330127018922196\n    assert candidate(6, 3.141592654) == 25.641984416634553\n    assert candidate(12, 2.3) == 59.227646316118076\n", "language": "python"}
{"task_id": "31a89407-ec4e-4f62-995c-a47559812d701413450837775127070", "prompt": "I'll complete this function according to what's described in its docstring. The function signature (name and parameters) will remain the same, and I'll provide the full implementation in one code block.\n\n```python\nfrom typing import List\n\ndef find_optimal_meeting_point(grid: List[List[int]]) -> int:\n    \"\"\"You are a city planner trying to find the optimal location for a new community center. \n    The city is represented by a grid where 1 indicates a house and 0 indicates an empty lot.\n\n    The optimal location for the community center is the point that minimizes the total Manhattan \n    distance that all residents would need to travel to reach it. The Manhattan distance between \n    two points (x1, y1) and (x2, y2) is |x1 - x2| + |y1 - y2|.\n\n    Your task is to find this optimal point and return the total Manhattan distance from all houses to this point.\n\n    Take a 2D list of integers 'grid' as input and return the minimum total distance as an integer.\n\n\n    [EXAMPLES]\n    \n    assert candidate([[1,0,1,0,1],[0,1,0,1,0],[1,0,1,0,1]]) == 16\n    assert candidate([[1,0,0],[0,0,0],[0,0,1]]) == 4\n\n    [/EXAMPLES]\n    \"\"\"\n```\n", "entry_point": "find_optimal_meeting_point", "solution": "from typing import List\n\ndef find_optimal_meeting_point(grid: List[List[int]]) -> int:\n    \"\"\"You are a city planner trying to find the optimal location for a new community center. \n    The city is represented by a grid where 1 indicates a house and 0 indicates an empty lot.\n\n    The optimal location for the community center is the point that minimizes the total Manhattan \n    distance that all residents would need to travel to reach it. The Manhattan distance between \n    two points (x1, y1) and (x2, y2) is |x1 - x2| + |y1 - y2|.\n\n    Your task is to find this optimal point and return the total Manhattan distance from all houses to this point.\n\n    Take a 2D list of integers 'grid' as input and return the minimum total distance as an integer.\n\n\n    [EXAMPLES]\n    \n    assert candidate([[1,0,1,0,1],[0,1,0,1,0],[1,0,1,0,1]]) == 16\n    assert candidate([[1,0,0],[0,0,0],[0,0,1]]) == 4\n\n    [/EXAMPLES]\n    \"\"\"\n    def get_median(arr):\n        arr.sort()\n        n = len(arr)\n        return arr[n // 2]\n\n    rows, cols = len(grid), len(grid[0])\n    houses = []\n\n    # Collect coordinates of all houses\n    for i in range(rows):\n        for j in range(cols):\n            if grid[i][j] == 1:\n                houses.append((i, j))\n\n    if not houses:\n        return 0\n\n    # Separate x and y coordinates\n    x_coords = [x for x, y in houses]\n    y_coords = [y for x, y in houses]\n\n    # Find median coordinates\n    median_x = get_median(x_coords)\n    median_y = get_median(y_coords)\n\n    # Calculate total Manhattan distance\n    total_distance = sum(abs(x - median_x) + abs(y - median_y) for x, y in houses)\n\n    return total_distance\n\n", "test": "def check(candidate):\n    assert candidate([[1,1,1,1],[1,0,0,1],[1,0,0,1],[1,1,1,1]]) == 28\n    assert candidate([[1,0,0,0,1],[0,0,0,0,0],[1,0,0,0,1]]) == 12\n    assert candidate([[1,0,0],[0,0,0],[0,0,1]]) == 4\n    assert candidate([[1,0,1,0,1],[0,1,0,1,0],[1,0,1,0,1]]) == 16\n    assert candidate([[1]]) == 0\n    assert candidate([[1,0,0,0,0,1],[0,0,0,0,0,0],[0,0,1,1,0,0],[0,0,1,1,0,0],[0,0,0,0,0,0],[1,0,0,0,0,1]]) == 24\n    assert candidate([[1,1,1,1],[1,1,1,1],[1,1,1,1]]) == 20\n    assert candidate([[1,1,1,1,1]]) == 6\n    assert candidate([[1,0,0,1,0],[0,0,0,0,0],[0,0,0,0,1]]) == 6\n    assert candidate([[1,0,0,0,1],[0,0,0,0,0],[0,0,1,0,0]]) == 6\n", "language": "python"}
{"task_id": "d2c867d8-1b65-4b67-b211-3c7b858bb2d8-2190145072645787141", "prompt": "I'll finish writing this function according to the docstring specifications. Here's the complete implementation in a single code block:\n\n```python\ndef compress_dna_sequence(dna: str) -> str:\n    \"\"\"A bioinformatics researcher needs to compress long DNA sequences to save storage space. Implement a function \n    that compresses a DNA sequence by replacing consecutive repeated nucleotides with the nucleotide followed by the \n    count of repetitions. If a nucleotide appears only once, it should not be followed by a number.\n\n    The DNA sequence will only contain valid nucleotides: A, C, G, and T.\n\n\n    [EXAMPLES]\n    \n    assert candidate(\"AAAACCCGGGTTT\") == 'A4C3G3T3'\n    assert candidate(\"TTTTT\") == 'T5'\n\n    [/EXAMPLES]\n    \"\"\"\n```\n", "entry_point": "compress_dna_sequence", "solution": "def compress_dna_sequence(dna: str) -> str:\n    \"\"\"A bioinformatics researcher needs to compress long DNA sequences to save storage space. Implement a function \n    that compresses a DNA sequence by replacing consecutive repeated nucleotides with the nucleotide followed by the \n    count of repetitions. If a nucleotide appears only once, it should not be followed by a number.\n\n    The DNA sequence will only contain valid nucleotides: A, C, G, and T.\n\n\n    [EXAMPLES]\n    \n    assert candidate(\"AAAACCCGGGTTT\") == 'A4C3G3T3'\n    assert candidate(\"TTTTT\") == 'T5'\n\n    [/EXAMPLES]\n    \"\"\"\n    if not dna:\n        return \"\"\n\n    compressed = []\n    current_nucleotide = dna[0]\n    count = 1\n\n    for nucleotide in dna[1:]:\n        if nucleotide == current_nucleotide:\n            count += 1\n        else:\n            if count > 1:\n                compressed.append(f\"{current_nucleotide}{count}\")\n            else:\n                compressed.append(current_nucleotide)\n            current_nucleotide = nucleotide\n            count = 1\n\n    # Handle the last group of nucleotides\n    if count > 1:\n        compressed.append(f\"{current_nucleotide}{count}\")\n    else:\n        compressed.append(current_nucleotide)\n\n    return \"\".join(compressed)\n\n", "test": "def check(candidate):\n    assert candidate(\"TTTTT\") == 'T5'\n    assert candidate(\"AGTCAGTCAGTC\") == 'AGTCAGTCAGTC'\n    assert candidate(\"AAAACCCGGGTTT\") == 'A4C3G3T3'\n    assert candidate(\"TGCATGCATGCA\") == 'TGCATGCATGCA'\n    assert candidate(\"ATTGGGCCCTTTAAA\") == 'AT2G3C3T3A3'\n    assert candidate(\"AAAAGGGGCCCCTTTT\") == 'A4G4C4T4'\n    assert candidate(\"GCGCGCGCGCGC\") == 'GCGCGCGCGCGC'\n    assert candidate(\"AAAA\") == 'A4'\n    assert candidate(\"ATATATATATAT\") == 'ATATATATATAT'\n    assert candidate(\"ACTGACTG\") == 'ACTGACTG'\n", "language": "python"}
{"task_id": "a927d946-48fe-46ab-9a8a-6814a874e041-8383175570520064132", "prompt": "Code the function body according to what's described in the docstring. Present your solution as a single code block with the original function name and parameters intact.\n\n```python\nimport math\n\ndef optimize_packaging(box_volume: float, item_radius: float) -> int:\n    \"\"\"You work for a shipping company and need to optimize the packing of spherical items into cubic boxes. Given the volume of a cubic box and the radius of identical spherical items, calculate the maximum number of items that can fit in the box without overlapping.\n\n    The function should take two parameters:\n    1. box_volume: The volume of the cubic box in cubic units.\n    2. item_radius: The radius of each spherical item in linear units.\n\n    Return the maximum number of spherical items that can fit in the box.\n\n    Note: The items cannot be compressed or deformed. Round down to the nearest integer for partial items.\n\n\n    [EXAMPLES]\n    \n    assert candidate(10, 0.5) == 8\n    assert candidate(10000, 5) == 8\n\n    [/EXAMPLES]\n    \"\"\"\n```\n", "entry_point": "optimize_packaging", "solution": "import math\n\ndef optimize_packaging(box_volume: float, item_radius: float) -> int:\n    \"\"\"You work for a shipping company and need to optimize the packing of spherical items into cubic boxes. Given the volume of a cubic box and the radius of identical spherical items, calculate the maximum number of items that can fit in the box without overlapping.\n\n    The function should take two parameters:\n    1. box_volume: The volume of the cubic box in cubic units.\n    2. item_radius: The radius of each spherical item in linear units.\n\n    Return the maximum number of spherical items that can fit in the box.\n\n    Note: The items cannot be compressed or deformed. Round down to the nearest integer for partial items.\n\n\n    [EXAMPLES]\n    \n    assert candidate(10, 0.5) == 8\n    assert candidate(10000, 5) == 8\n\n    [/EXAMPLES]\n    \"\"\"\n    # Calculate the side length of the cubic box\n    box_side = math.pow(box_volume, 1/3)\n    \n    # Calculate the diameter of the spherical item\n    item_diameter = 2 * item_radius\n    \n    # Calculate the maximum number of items that can fit along each dimension\n    items_per_dimension = math.floor(box_side / item_diameter)\n    \n    # Calculate the total number of items that can fit in the box\n    total_items = items_per_dimension ** 3\n    \n    return total_items\n\n", "test": "def check(candidate):\n    assert candidate(729, 3) == 1\n    assert candidate(10000, 5) == 8\n    assert candidate(0.008, 0.1) == 1\n    assert candidate(1000000000, 100) == 64\n    assert candidate(10, 0.5) == 8\n    assert candidate(1000, 1) == 64\n    assert candidate(1000, 0.1) == 117649\n    assert candidate(1, 1) == 0\n    assert candidate(0.001, 0.001) == 125000\n    assert candidate(1000000, 10) == 64\n", "language": "python"}
{"task_id": "35763e9d-4bcf-42b0-a8ad-5255973fad0f-7593939899385581745", "prompt": "I'll help you by completing your function so it's immediately executable. I'll work within the constraints of the libraries already imported and ensure any supplementary code is nested inside your function.\n\n```python\nfrom typing import List\n\ndef find_minimum_platforms(arrival: List[float], departure: List[float]) -> int:\n    \"\"\"\n    At a busy train station, you are given the arrival and departure times of all trains that reach the station on a\n    particular day. Your task is to find the minimum number of platforms required for the station so that no train waits.\n\n    The arrival and departure times are given in 24-hour format as floats, where the decimal part represents minutes.\n    For example, 13.25 represents 13:15 in 24-hour format.\n\n\n    [EXAMPLES]\n    \n    assert candidate([0.00, 23.59, 23.58, 23.57], [0.01, 23.59, 23.58, 23.57]) == 1\n    assert candidate([1.00, 2.00, 3.00, 4.00, 5.00], [2.00, 3.00, 4.00, 5.00, 6.00]) == 1\n\n    [/EXAMPLES]\n    \"\"\"\n```\n", "entry_point": "find_minimum_platforms", "solution": "from typing import List\n\ndef find_minimum_platforms(arrival: List[float], departure: List[float]) -> int:\n    \"\"\"\n    At a busy train station, you are given the arrival and departure times of all trains that reach the station on a\n    particular day. Your task is to find the minimum number of platforms required for the station so that no train waits.\n\n    The arrival and departure times are given in 24-hour format as floats, where the decimal part represents minutes.\n    For example, 13.25 represents 13:15 in 24-hour format.\n\n\n    [EXAMPLES]\n    \n    assert candidate([0.00, 23.59, 23.58, 23.57], [0.01, 23.59, 23.58, 23.57]) == 1\n    assert candidate([1.00, 2.00, 3.00, 4.00, 5.00], [2.00, 3.00, 4.00, 5.00, 6.00]) == 1\n\n    [/EXAMPLES]\n    \"\"\"\n    # Sort both arrival and departure times\n    arrival.sort()\n    departure.sort()\n    \n    n = len(arrival)\n    platforms_needed = 1\n    result = 1\n    i = 1\n    j = 0\n    \n    while i < n and j < n:\n        # If the next event is an arrival\n        if arrival[i] < departure[j]:\n            platforms_needed += 1\n            i += 1\n        # If the next event is a departure\n        elif arrival[i] > departure[j]:\n            platforms_needed -= 1\n            j += 1\n        # If arrival and departure happen at the same time\n        else:\n            i += 1\n            j += 1\n        \n        # Update the result if necessary\n        result = max(result, platforms_needed)\n    \n    return result\n\n", "test": "def check(candidate):\n    assert candidate([0.00, 23.59], [23.58, 23.59]) == 1\n    assert candidate([6.00, 6.30, 7.00, 7.30, 8.00], [6.45, 7.15, 7.45, 8.15, 8.45]) == 2\n    assert candidate([12.00], [12.30]) == 1\n    assert candidate([8.00, 8.00, 8.00], [10.00, 10.00, 10.00]) == 3\n    assert candidate([0.00, 23.59, 23.58, 23.57], [0.01, 23.59, 23.58, 23.57]) == 1\n    assert candidate([8.00, 8.05, 8.10, 8.15, 8.20], [8.30, 8.35, 8.40, 8.45, 8.50]) == 5\n    assert candidate([0.00, 0.01, 0.02, 0.03], [23.57, 23.58, 23.59, 0.04]) == 4\n    assert candidate([1.00, 2.00, 3.00, 4.00, 5.00], [2.00, 3.00, 4.00, 5.00, 6.00]) == 1\n    assert candidate([16.00, 16.30, 17.00, 17.30, 18.00], [18.00, 18.30, 19.00, 19.30, 20.00]) == 4\n    assert candidate([10.00, 10.15, 10.30, 10.45], [10.20, 10.35, 10.50, 11.00]) == 2\n", "language": "python"}
{"task_id": "a42ae8dd-b03b-440d-9e94-7c7e283fdabb5675914358459760734", "prompt": "Implement the function as specified, ensuring it's ready to execute within one code block. All code must be contained within the function itself. Only utilize libraries that are imported in the problem. Define any helper functions or classes inside the main function.\n\n```python\nfrom typing import List\n\ndef morse_cipher(message: str, cipher_key: List[str]) -> str:\n    \"\"\"\n    You are a secret agent tasked with encoding messages using a custom Morse code cipher.\n    Each letter in the alphabet is assigned a unique sequence of dots and dashes.\n    Your task is to encode the given message using the provided cipher key.\n\n    Parameters:\n    message (str): The message to be encoded (uppercase letters only, no spaces)\n    cipher_key (List[str]): A list of 26 strings representing the Morse code for each letter (A-Z)\n\n    Returns:\n    str: The encoded message with each letter's code separated by a space\n\n\n    [EXAMPLES]\n    \n    assert candidate(\"OVER\", [\".-\", \"-...\", \"-.-.\", \"-..\", \".\", \"..-.\", \"--.\", \"....\", \"..\", \".---\", \"-.-\", \".-..\", \"--\", \"-.\", \"---\", \".--.\", \"--.-\", \".-.\", \"...\", \"-\", \"..-\", \"...-\", \".--\", \"-..-\", \"-.--\", \"--..\"]) == '--- ...- . .-.'\n    assert candidate(\"TEST\", [\".-\", \"-...\", \"-.-.\", \"-..\", \".\", \"..-.\", \"--.\", \"....\", \"..\", \".---\", \"-.-\", \".-..\", \"--\", \"-.\", \"---\", \".--.\", \"--.-\", \".-.\", \"...\", \"-\", \"..-\", \"...-\", \".--\", \"-..-\", \"-.--\", \"--..\"]) == '- . ... -'\n\n    [/EXAMPLES]\n    \"\"\"\n```\n", "entry_point": "morse_cipher", "solution": "from typing import List\n\ndef morse_cipher(message: str, cipher_key: List[str]) -> str:\n    \"\"\"\n    You are a secret agent tasked with encoding messages using a custom Morse code cipher.\n    Each letter in the alphabet is assigned a unique sequence of dots and dashes.\n    Your task is to encode the given message using the provided cipher key.\n\n    Parameters:\n    message (str): The message to be encoded (uppercase letters only, no spaces)\n    cipher_key (List[str]): A list of 26 strings representing the Morse code for each letter (A-Z)\n\n    Returns:\n    str: The encoded message with each letter's code separated by a space\n\n\n    [EXAMPLES]\n    \n    assert candidate(\"OVER\", [\".-\", \"-...\", \"-.-.\", \"-..\", \".\", \"..-.\", \"--.\", \"....\", \"..\", \".---\", \"-.-\", \".-..\", \"--\", \"-.\", \"---\", \".--.\", \"--.-\", \".-.\", \"...\", \"-\", \"..-\", \"...-\", \".--\", \"-..-\", \"-.--\", \"--..\"]) == '--- ...- . .-.'\n    assert candidate(\"TEST\", [\".-\", \"-...\", \"-.-.\", \"-..\", \".\", \"..-.\", \"--.\", \"....\", \"..\", \".---\", \"-.-\", \".-..\", \"--\", \"-.\", \"---\", \".--.\", \"--.-\", \".-.\", \"...\", \"-\", \"..-\", \"...-\", \".--\", \"-..-\", \"-.--\", \"--..\"]) == '- . ... -'\n\n    [/EXAMPLES]\n    \"\"\"\n    # Create a dictionary to map letters to their Morse code\n    morse_dict = {chr(65 + i): code for i, code in enumerate(cipher_key)}\n    \n    # Encode each letter in the message\n    encoded_message = []\n    for letter in message:\n        encoded_message.append(morse_dict[letter])\n    \n    # Join the encoded letters with spaces\n    return \" \".join(encoded_message)\n\n", "test": "def check(candidate):\n    assert candidate(\"MESSAGE\", [\".-\", \"-...\", \"-.-.\", \"-..\", \".\", \"..-.\", \"--.\", \"....\", \"..\", \".---\", \"-.-\", \".-..\", \"--\", \"-.\", \"---\", \".--.\", \"--.-\", \".-.\", \"...\", \"-\", \"..-\", \"...-\", \".--\", \"-..-\", \"-.--\", \"--..\"]) == '-- . ... ... .- --. .'\n    assert candidate(\"MORSECODE\", [\".-\", \"-...\", \"-.-.\", \"-..\", \".\", \"..-.\", \"--.\", \"....\", \"..\", \".---\", \"-.-\", \".-..\", \"--\", \"-.\", \"---\", \".--.\", \"--.-\", \".-.\", \"...\", \"-\", \"..-\", \"...-\", \".--\", \"-..-\", \"-.--\", \"--..\"]) == '-- --- .-. ... . -.-. --- -.. .'\n    assert candidate(\"OVER\", [\".-\", \"-...\", \"-.-.\", \"-..\", \".\", \"..-.\", \"--.\", \"....\", \"..\", \".---\", \"-.-\", \".-..\", \"--\", \"-.\", \"---\", \".--.\", \"--.-\", \".-.\", \"...\", \"-\", \"..-\", \"...-\", \".--\", \"-..-\", \"-.--\", \"--..\"]) == '--- ...- . .-.'\n    assert candidate(\"TEST\", [\".-\", \"-...\", \"-.-.\", \"-..\", \".\", \"..-.\", \"--.\", \"....\", \"..\", \".---\", \"-.-\", \".-..\", \"--\", \"-.\", \"---\", \".--.\", \"--.-\", \".-.\", \"...\", \"-\", \"..-\", \"...-\", \".--\", \"-..-\", \"-.--\", \"--..\"]) == '- . ... -'\n    assert candidate(\"FOX\", [\".-\", \"-...\", \"-.-.\", \"-..\", \".\", \"..-.\", \"--.\", \"....\", \"..\", \".---\", \"-.-\", \".-..\", \"--\", \"-.\", \"---\", \".--.\", \"--.-\", \".-.\", \"...\", \"-\", \"..-\", \"...-\", \".--\", \"-..-\", \"-.--\", \"--..\"]) == '..-. --- -..-'\n    assert candidate(\"CIPHER\", [\".-\", \"-...\", \"-.-.\", \"-..\", \".\", \"..-.\", \"--.\", \"....\", \"..\", \".---\", \"-.-\", \".-..\", \"--\", \"-.\", \"---\", \".--.\", \"--.-\", \".-.\", \"...\", \"-\", \"..-\", \"...-\", \".--\", \"-..-\", \"-.--\", \"--..\"]) == '-.-. .. .--. .... . .-.'\n    assert candidate(\"HELLO\", [\".-\", \"-...\", \"-.-.\", \"-..\", \".\", \"..-.\", \"--.\", \"....\", \"..\", \".---\", \"-.-\", \".-..\", \"--\", \"-.\", \"---\", \".--.\", \"--.-\", \".-.\", \"...\", \"-\", \"..-\", \"...-\", \".--\", \"-..-\", \"-.--\", \"--..\"]) == '.... . .-.. .-.. ---'\n    assert candidate(\"SECRETAGENT\", [\".-\", \"-...\", \"-.-.\", \"-..\", \".\", \"..-.\", \"--.\", \"....\", \"..\", \".---\", \"-.-\", \".-..\", \"--\", \"-.\", \"---\", \".--.\", \"--.-\", \".-.\", \"...\", \"-\", \"..-\", \"...-\", \".--\", \"-..-\", \"-.--\", \"--..\"]) == '... . -.-. .-. . - .- --. . -. -'\n    assert candidate(\"JUMPS\", [\".-\", \"-...\", \"-.-.\", \"-..\", \".\", \"..-.\", \"--.\", \"....\", \"..\", \".---\", \"-.-\", \".-..\", \"--\", \"-.\", \"---\", \".--.\", \"--.-\", \".-.\", \"...\", \"-\", \"..-\", \"...-\", \".--\", \"-..-\", \"-.--\", \"--..\"]) == '.--- ..- -- .--. ...'\n    assert candidate(\"QUICK\", [\".-\", \"-...\", \"-.-.\", \"-..\", \".\", \"..-.\", \"--.\", \"....\", \"..\", \".---\", \"-.-\", \".-..\", \"--\", \"-.\", \"---\", \".--.\", \"--.-\", \".-.\", \"...\", \"-\", \"..-\", \"...-\", \".--\", \"-..-\", \"-.--\", \"--..\"]) == '--.- ..- .. -.-. -.-'\n", "language": "python"}
{"task_id": "0d911252-b8d6-4026-b13e-381526fae856-4364695611168610185", "prompt": "I'm a coding assistant who completes functions so they're immediately executable. I'll only write code inside the function block, stick to the imported libraries, and nest any additional functions/classes I create inside the given function.\n\n```python\ndef decrypt_ancient_code(encrypted_text: str, shift: int) -> str:\n    \"\"\"\n    An archaeologist has discovered an ancient encrypted message and needs your help to decipher it.\n    The message was encrypted using a variation of the Caesar cipher, where each letter in the\n    original text is shifted a certain number of positions in the alphabet. Your task is to create\n    a function that decrypts the message.\n\n    The function should take two parameters:\n    1. encrypted_text: A string containing the encrypted message (uppercase letters and spaces only)\n    2. shift: An integer representing the number of positions each letter was shifted\n\n    The function should return the decrypted message as a string.\n\n    Note: The alphabet wraps around, so 'Z' shifted by 1 becomes 'A'.\n\n\n    [EXAMPLES]\n    \n    assert candidate(\"PBZA PZ H ZLJYLA TLZZHNL\", 7) == 'IUST IS A SECRET MESSAGE'\n    assert candidate(\"AAAAAAAAAAAAAAAAAAAAAAAAAAA\", 1) == 'ZZZZZZZZZZZZZZZZZZZZZZZZZZZ'\n\n    [/EXAMPLES]\n    \"\"\"\n```\n", "entry_point": "decrypt_ancient_code", "solution": "def decrypt_ancient_code(encrypted_text: str, shift: int) -> str:\n    \"\"\"\n    An archaeologist has discovered an ancient encrypted message and needs your help to decipher it.\n    The message was encrypted using a variation of the Caesar cipher, where each letter in the\n    original text is shifted a certain number of positions in the alphabet. Your task is to create\n    a function that decrypts the message.\n\n    The function should take two parameters:\n    1. encrypted_text: A string containing the encrypted message (uppercase letters and spaces only)\n    2. shift: An integer representing the number of positions each letter was shifted\n\n    The function should return the decrypted message as a string.\n\n    Note: The alphabet wraps around, so 'Z' shifted by 1 becomes 'A'.\n\n\n    [EXAMPLES]\n    \n    assert candidate(\"PBZA PZ H ZLJYLA TLZZHNL\", 7) == 'IUST IS A SECRET MESSAGE'\n    assert candidate(\"AAAAAAAAAAAAAAAAAAAAAAAAAAA\", 1) == 'ZZZZZZZZZZZZZZZZZZZZZZZZZZZ'\n\n    [/EXAMPLES]\n    \"\"\"\n    def shift_letter(letter: str, shift: int) -> str:\n        if letter == ' ':\n            return ' '\n        ascii_offset = ord('A')\n        shifted_ascii = (ord(letter) - ascii_offset - shift) % 26 + ascii_offset\n        return chr(shifted_ascii)\n\n    decrypted_text = ''.join(shift_letter(char, shift) for char in encrypted_text)\n    return decrypted_text\n\n", "test": "def check(candidate):\n    assert candidate(\"A B C\", 25) == 'B C D'\n    assert candidate(\"THIS IS A TEST\", 1000000) == 'FTUE UE M FQEF'\n    assert candidate(\"HELLO WORLD\", 0) == 'HELLO WORLD'\n    assert candidate(\"ABC XYZ\", 1) == 'ZAB WXY'\n    assert candidate(\"HELLO\", -1) == 'IFMMP'\n    assert candidate(\"KHOOR ZRUOG\", 3) == 'HELLO WORLD'\n    assert candidate(\"AAAAAAAAAAAAAAAAAAAAAAAAAAA\", 1) == 'ZZZZZZZZZZZZZZZZZZZZZZZZZZZ'\n    assert candidate(\"Z\", 1) == 'Y'\n    assert candidate(\"PBZA PZ H ZLJYLA TLZZHNL\", 7) == 'IUST IS A SECRET MESSAGE'\n    assert candidate(\"ABCDEFGHIJKLMNOPQRSTUVWXYZ\", -26) == 'ABCDEFGHIJKLMNOPQRSTUVWXYZ'\n", "language": "python"}
{"task_id": "a42ae8dd-b03b-440d-9e94-7c7e283fdabb-6633815757490445252", "prompt": "Following the doc string specifications, I'll write the full function implementation. Everything will be contained in one code block.\n\n```python\nfrom typing import List, Tuple\nimport heapq\nfrom collections import defaultdict\n\ndef network_latency(connections: List[Tuple[str, str, int]], start: str, end: str) -> int:\n    \"\"\"\n    You are a network engineer analyzing the latency in a computer network.\n    The network consists of nodes (computers) connected by edges with varying latencies.\n    Your task is to find the path with the minimum total latency between two given nodes.\n\n    Parameters:\n    connections (List[Tuple[str, str, int]]): A list of tuples representing connections.\n                                              Each tuple contains (from_node, to_node, latency).\n    start (str): The starting node\n    end (str): The destination node\n\n    Returns:\n    int: The minimum total latency between start and end nodes. Return -1 if no path exists.\n\n\n    [EXAMPLES]\n    \n    assert candidate([(\"A\", \"B\", 1), (\"B\", \"C\", 2), (\"C\", \"D\", 3), (\"D\", \"E\", 4), (\"E\", \"A\", 5)], \"A\", \"A\") == 0\n    assert candidate([(\"X\", \"Y\", 2), (\"Y\", \"Z\", 3), (\"X\", \"W\", 1), (\"W\", \"Z\", 5)], \"X\", \"Z\") == 5\n\n    [/EXAMPLES]\n    \"\"\"\n```\n", "entry_point": "network_latency", "solution": "from typing import List, Tuple\nimport heapq\nfrom collections import defaultdict\n\ndef network_latency(connections: List[Tuple[str, str, int]], start: str, end: str) -> int:\n    \"\"\"\n    You are a network engineer analyzing the latency in a computer network.\n    The network consists of nodes (computers) connected by edges with varying latencies.\n    Your task is to find the path with the minimum total latency between two given nodes.\n\n    Parameters:\n    connections (List[Tuple[str, str, int]]): A list of tuples representing connections.\n                                              Each tuple contains (from_node, to_node, latency).\n    start (str): The starting node\n    end (str): The destination node\n\n    Returns:\n    int: The minimum total latency between start and end nodes. Return -1 if no path exists.\n\n\n    [EXAMPLES]\n    \n    assert candidate([(\"A\", \"B\", 1), (\"B\", \"C\", 2), (\"C\", \"D\", 3), (\"D\", \"E\", 4), (\"E\", \"A\", 5)], \"A\", \"A\") == 0\n    assert candidate([(\"X\", \"Y\", 2), (\"Y\", \"Z\", 3), (\"X\", \"W\", 1), (\"W\", \"Z\", 5)], \"X\", \"Z\") == 5\n\n    [/EXAMPLES]\n    \"\"\"\n    # Create a graph representation using adjacency list\n    graph = defaultdict(list)\n    for from_node, to_node, latency in connections:\n        graph[from_node].append((to_node, latency))\n        graph[to_node].append((from_node, latency))  # Assuming bidirectional connections\n\n    # Initialize distances and priority queue\n    distances = {node: float('inf') for node in graph}\n    distances[start] = 0\n    pq = [(0, start)]\n\n    # Dijkstra's algorithm\n    while pq:\n        current_distance, current_node = heapq.heappop(pq)\n\n        if current_node == end:\n            return current_distance\n\n        if current_distance > distances[current_node]:\n            continue\n\n        for neighbor, latency in graph[current_node]:\n            distance = current_distance + latency\n            if distance < distances[neighbor]:\n                distances[neighbor] = distance\n                heapq.heappush(pq, (distance, neighbor))\n\n    # If we can't reach the end node\n    return -1\n\n", "test": "def check(candidate):\n    assert candidate([(\"X\", \"Y\", 100), (\"Y\", \"Z\", 200), (\"X\", \"Z\", 500)], \"X\", \"Z\") == 300\n    assert candidate([(\"X\", \"Y\", 5), (\"Y\", \"Z\", 5), (\"Z\", \"X\", 5)], \"X\", \"X\") == 0\n    assert candidate([(\"X\", \"Y\", 1), (\"Y\", \"Z\", 1), (\"Z\", \"X\", 1)], \"X\", \"Z\") == 1\n    assert candidate([(\"P\", \"Q\", 1), (\"Q\", \"R\", 2), (\"R\", \"S\", 3)], \"P\", \"S\") == 6\n    assert candidate([(\"P\", \"Q\", 1), (\"Q\", \"R\", 2), (\"R\", \"S\", 3), (\"S\", \"P\", 4)], \"P\", \"S\") == 4\n    assert candidate([(\"P\", \"Q\", 1), (\"Q\", \"R\", 1), (\"R\", \"S\", 1), (\"S\", \"T\", 1), (\"T\", \"U\", 1)], \"P\", \"U\") == 5\n    assert candidate([(\"X\", \"Y\", 2), (\"Y\", \"Z\", 3), (\"X\", \"W\", 1), (\"W\", \"Z\", 5)], \"X\", \"Z\") == 5\n    assert candidate([(\"A\", \"B\", 1), (\"B\", \"C\", 2), (\"C\", \"D\", 3), (\"D\", \"E\", 4), (\"E\", \"A\", 5)], \"A\", \"A\") == 0\n    assert candidate([(\"X\", \"Y\", 10)], \"X\", \"Y\") == 10\n    assert candidate([(\"A\", \"B\", 1), (\"B\", \"C\", 2), (\"C\", \"A\", 3)], \"A\", \"C\") == 3\n", "language": "python"}
{"task_id": "9b490412-df50-47d7-9af0-b1385c56b9708038987922237610862", "prompt": "I'll need you to implement the requested function completely so it runs correctly in one code block. Don't include any code outside the function scope. Stick to using only the libraries that are imported in the problem. Define any additional helper functions or classes within the main function.\n\n```python\nfrom typing import List\n\ndef calculate_city_skyline(buildings: List[int]) -> List[int]:\n    \"\"\"\n    In an urban planning simulation, calculate the visible skyline heights for each building.\n\n    Given a list of building heights, for each building, determine the height of the next taller\n    building to its right. If there is no taller building to the right, use 0.\n\n    This function uses a stack to efficiently process the buildings from right to left,\n    combining the concepts of stack operations and array traversal.\n\n\n    [EXAMPLES]\n    \n    assert candidate([5, 5, 5, 5, 5]) == [0, 0, 0, 0, 0]\n    assert candidate([1, 1]) == [0, 0]\n\n    [/EXAMPLES]\n    \"\"\"\n```\n", "entry_point": "calculate_city_skyline", "solution": "from typing import List\n\ndef calculate_city_skyline(buildings: List[int]) -> List[int]:\n    \"\"\"\n    In an urban planning simulation, calculate the visible skyline heights for each building.\n\n    Given a list of building heights, for each building, determine the height of the next taller\n    building to its right. If there is no taller building to the right, use 0.\n\n    This function uses a stack to efficiently process the buildings from right to left,\n    combining the concepts of stack operations and array traversal.\n\n\n    [EXAMPLES]\n    \n    assert candidate([5, 5, 5, 5, 5]) == [0, 0, 0, 0, 0]\n    assert candidate([1, 1]) == [0, 0]\n\n    [/EXAMPLES]\n    \"\"\"\n    n = len(buildings)\n    result = [0] * n\n    stack = []\n\n    # Process buildings from right to left\n    for i in range(n - 1, -1, -1):\n        # Remove buildings from stack that are shorter than or equal to current\n        while stack and stack[-1] <= buildings[i]:\n            stack.pop()\n        \n        # If stack is not empty, the top of stack is the next taller building\n        if stack:\n            result[i] = stack[-1]\n        \n        # Add current building height to stack\n        stack.append(buildings[i])\n\n    return result\n\n", "test": "def check(candidate):\n    assert candidate([9, 8, 7, 6, 5, 4, 3, 2, 1, 10]) == [10, 10, 10, 10, 10, 10, 10, 10, 10, 0]\n    assert candidate([5, 5, 5, 5, 5]) == [0, 0, 0, 0, 0]\n    assert candidate([100, 50, 75, 25, 150, 120]) == [150, 75, 150, 150, 0, 0]\n    assert candidate([1000000, 999999, 999998, 1000001]) == [1000001, 1000001, 1000001, 0]\n    assert candidate([1, 3, 2]) == [3, 0, 0]\n    assert candidate([1, 10, 1, 10, 1, 10]) == [10, 0, 10, 0, 10, 0]\n    assert candidate([1, 1]) == [0, 0]\n    assert candidate([7, 7, 7, 7, 8, 8, 8, 8]) == [8, 8, 8, 8, 0, 0, 0, 0]\n    assert candidate([10, 9, 8, 7, 6, 5, 4, 3, 2, 1]) == [0, 0, 0, 0, 0, 0, 0, 0, 0, 0]\n    assert candidate([5, 3, 8, 2, 1, 9, 4, 7]) == [8, 8, 9, 9, 9, 0, 7, 0]\n", "language": "python"}
{"task_id": "92bcacdc-3bd8-43ff-b1c0-5b480c553c46-523470285525257332", "prompt": "Ready to assist with your coding needs. I'll complete functions to be executable, using only imported libraries and containing any additional code structures within the function you provide.\n\n```python\ndef analyze_dna_sequence(sequence: str, motif: str) -> dict:\n    \"\"\"\n    Analyzes a DNA sequence for a specific motif and returns various statistics.\n\n    This function takes a DNA sequence and a motif as input, then calculates\n    and returns a dictionary containing the following information:\n    - Number of occurrences of the motif\n    - Positions of the motif (1-indexed)\n    - GC content of the entire sequence\n    - Length of the longest run of consecutive motifs\n\n    Parameters:\n    sequence (str): The DNA sequence to analyze (containing A, T, G, C)\n    motif (str): The motif to search for within the sequence\n\n    Returns:\n    dict: A dictionary containing the analysis results\n\n\n    [EXAMPLES]\n    \n    assert candidate(\"GGGGCCCCAAAATTTT\", \"GC\") == {'occurrences': 1, 'positions': [4], 'gc_content': 0.5, 'longest_run': 1}\n    assert candidate(\"GCGCGCGCGC\", \"GCG\") == {'occurrences': 4, 'positions': [1, 3, 5, 7], 'gc_content': 1.0, 'longest_run': 1}\n\n    [/EXAMPLES]\n    \"\"\"\n```\n", "entry_point": "analyze_dna_sequence", "solution": "def analyze_dna_sequence(sequence: str, motif: str) -> dict:\n    \"\"\"\n    Analyzes a DNA sequence for a specific motif and returns various statistics.\n\n    This function takes a DNA sequence and a motif as input, then calculates\n    and returns a dictionary containing the following information:\n    - Number of occurrences of the motif\n    - Positions of the motif (1-indexed)\n    - GC content of the entire sequence\n    - Length of the longest run of consecutive motifs\n\n    Parameters:\n    sequence (str): The DNA sequence to analyze (containing A, T, G, C)\n    motif (str): The motif to search for within the sequence\n\n    Returns:\n    dict: A dictionary containing the analysis results\n\n\n    [EXAMPLES]\n    \n    assert candidate(\"GGGGCCCCAAAATTTT\", \"GC\") == {'occurrences': 1, 'positions': [4], 'gc_content': 0.5, 'longest_run': 1}\n    assert candidate(\"GCGCGCGCGC\", \"GCG\") == {'occurrences': 4, 'positions': [1, 3, 5, 7], 'gc_content': 1.0, 'longest_run': 1}\n\n    [/EXAMPLES]\n    \"\"\"\n    \n    def find_longest_run(positions):\n        if not positions:\n            return 0\n        longest = 1\n        current = 1\n        for i in range(1, len(positions)):\n            if positions[i] - positions[i-1] == len(motif):\n                current += 1\n                longest = max(longest, current)\n            else:\n                current = 1\n        return longest\n\n    occurrences = 0\n    positions = []\n    gc_count = 0\n    \n    for i in range(len(sequence)):\n        if sequence[i] in 'GC':\n            gc_count += 1\n        if sequence[i:i+len(motif)] == motif:\n            occurrences += 1\n            positions.append(i + 1)  # 1-indexed position\n    \n    gc_content = gc_count / len(sequence) if len(sequence) > 0 else 0\n    longest_run = find_longest_run(positions)\n    \n    return {\n        'occurrences': occurrences,\n        'positions': positions,\n        'gc_content': gc_content,\n        'longest_run': longest_run\n    }\n\n", "test": "def check(candidate):\n    assert candidate(\"AGTCAGTCAGTCAGTC\", \"AGTC\") == {'occurrences': 4, 'positions': [1, 5, 9, 13], 'gc_content': 0.5, 'longest_run': 4}\n    assert candidate(\"\", \"A\") == {'occurrences': 0, 'positions': [], 'gc_content': 0, 'longest_run': 0}\n    assert candidate(\"ACGTACGTACGT\", \"ACGT\") == {'occurrences': 3, 'positions': [1, 5, 9], 'gc_content': 0.5, 'longest_run': 3}\n    assert candidate(\"ATCG\", \"ATCG\") == {'occurrences': 1, 'positions': [1], 'gc_content': 0.5, 'longest_run': 1}\n    assert candidate(\"ATCGATCGATCG\", \"AT\") == {'occurrences': 3, 'positions': [1, 5, 9], 'gc_content': 0.5, 'longest_run': 1}\n    assert candidate(\"AAAGGGTTTCCC\", \"GGG\") == {'occurrences': 1, 'positions': [4], 'gc_content': 0.5, 'longest_run': 1}\n    assert candidate(\"ATCGATCGATCGATCG\", \"ATC\") == {'occurrences': 4, 'positions': [1, 5, 9, 13], 'gc_content': 0.5, 'longest_run': 1}\n    assert candidate(\"GGGGCCCCAAAATTTT\", \"GC\") == {'occurrences': 1, 'positions': [4], 'gc_content': 0.5, 'longest_run': 1}\n    assert candidate(\"A\" * 1000, \"AA\") == {'occurrences': 999, 'positions': [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112, 113, 114, 115, 116, 117, 118, 119, 120, 121, 122, 123, 124, 125, 126, 127, 128, 129, 130, 131, 132, 133, 134, 135, 136, 137, 138, 139, 140, 141, 142, 143, 144, 145, 146, 147, 148, 149, 150, 151, 152, 153, 154, 155, 156, 157, 158, 159, 160, 161, 162, 163, 164, 165, 166, 167, 168, 169, 170, 171, 172, 173, 174, 175, 176, 177, 178, 179, 180, 181, 182, 183, 184, 185, 186, 187, 188, 189, 190, 191, 192, 193, 194, 195, 196, 197, 198, 199, 200, 201, 202, 203, 204, 205, 206, 207, 208, 209, 210, 211, 212, 213, 214, 215, 216, 217, 218, 219, 220, 221, 222, 223, 224, 225, 226, 227, 228, 229, 230, 231, 232, 233, 234, 235, 236, 237, 238, 239, 240, 241, 242, 243, 244, 245, 246, 247, 248, 249, 250, 251, 252, 253, 254, 255, 256, 257, 258, 259, 260, 261, 262, 263, 264, 265, 266, 267, 268, 269, 270, 271, 272, 273, 274, 275, 276, 277, 278, 279, 280, 281, 282, 283, 284, 285, 286, 287, 288, 289, 290, 291, 292, 293, 294, 295, 296, 297, 298, 299, 300, 301, 302, 303, 304, 305, 306, 307, 308, 309, 310, 311, 312, 313, 314, 315, 316, 317, 318, 319, 320, 321, 322, 323, 324, 325, 326, 327, 328, 329, 330, 331, 332, 333, 334, 335, 336, 337, 338, 339, 340, 341, 342, 343, 344, 345, 346, 347, 348, 349, 350, 351, 352, 353, 354, 355, 356, 357, 358, 359, 360, 361, 362, 363, 364, 365, 366, 367, 368, 369, 370, 371, 372, 373, 374, 375, 376, 377, 378, 379, 380, 381, 382, 383, 384, 385, 386, 387, 388, 389, 390, 391, 392, 393, 394, 395, 396, 397, 398, 399, 400, 401, 402, 403, 404, 405, 406, 407, 408, 409, 410, 411, 412, 413, 414, 415, 416, 417, 418, 419, 420, 421, 422, 423, 424, 425, 426, 427, 428, 429, 430, 431, 432, 433, 434, 435, 436, 437, 438, 439, 440, 441, 442, 443, 444, 445, 446, 447, 448, 449, 450, 451, 452, 453, 454, 455, 456, 457, 458, 459, 460, 461, 462, 463, 464, 465, 466, 467, 468, 469, 470, 471, 472, 473, 474, 475, 476, 477, 478, 479, 480, 481, 482, 483, 484, 485, 486, 487, 488, 489, 490, 491, 492, 493, 494, 495, 496, 497, 498, 499, 500, 501, 502, 503, 504, 505, 506, 507, 508, 509, 510, 511, 512, 513, 514, 515, 516, 517, 518, 519, 520, 521, 522, 523, 524, 525, 526, 527, 528, 529, 530, 531, 532, 533, 534, 535, 536, 537, 538, 539, 540, 541, 542, 543, 544, 545, 546, 547, 548, 549, 550, 551, 552, 553, 554, 555, 556, 557, 558, 559, 560, 561, 562, 563, 564, 565, 566, 567, 568, 569, 570, 571, 572, 573, 574, 575, 576, 577, 578, 579, 580, 581, 582, 583, 584, 585, 586, 587, 588, 589, 590, 591, 592, 593, 594, 595, 596, 597, 598, 599, 600, 601, 602, 603, 604, 605, 606, 607, 608, 609, 610, 611, 612, 613, 614, 615, 616, 617, 618, 619, 620, 621, 622, 623, 624, 625, 626, 627, 628, 629, 630, 631, 632, 633, 634, 635, 636, 637, 638, 639, 640, 641, 642, 643, 644, 645, 646, 647, 648, 649, 650, 651, 652, 653, 654, 655, 656, 657, 658, 659, 660, 661, 662, 663, 664, 665, 666, 667, 668, 669, 670, 671, 672, 673, 674, 675, 676, 677, 678, 679, 680, 681, 682, 683, 684, 685, 686, 687, 688, 689, 690, 691, 692, 693, 694, 695, 696, 697, 698, 699, 700, 701, 702, 703, 704, 705, 706, 707, 708, 709, 710, 711, 712, 713, 714, 715, 716, 717, 718, 719, 720, 721, 722, 723, 724, 725, 726, 727, 728, 729, 730, 731, 732, 733, 734, 735, 736, 737, 738, 739, 740, 741, 742, 743, 744, 745, 746, 747, 748, 749, 750, 751, 752, 753, 754, 755, 756, 757, 758, 759, 760, 761, 762, 763, 764, 765, 766, 767, 768, 769, 770, 771, 772, 773, 774, 775, 776, 777, 778, 779, 780, 781, 782, 783, 784, 785, 786, 787, 788, 789, 790, 791, 792, 793, 794, 795, 796, 797, 798, 799, 800, 801, 802, 803, 804, 805, 806, 807, 808, 809, 810, 811, 812, 813, 814, 815, 816, 817, 818, 819, 820, 821, 822, 823, 824, 825, 826, 827, 828, 829, 830, 831, 832, 833, 834, 835, 836, 837, 838, 839, 840, 841, 842, 843, 844, 845, 846, 847, 848, 849, 850, 851, 852, 853, 854, 855, 856, 857, 858, 859, 860, 861, 862, 863, 864, 865, 866, 867, 868, 869, 870, 871, 872, 873, 874, 875, 876, 877, 878, 879, 880, 881, 882, 883, 884, 885, 886, 887, 888, 889, 890, 891, 892, 893, 894, 895, 896, 897, 898, 899, 900, 901, 902, 903, 904, 905, 906, 907, 908, 909, 910, 911, 912, 913, 914, 915, 916, 917, 918, 919, 920, 921, 922, 923, 924, 925, 926, 927, 928, 929, 930, 931, 932, 933, 934, 935, 936, 937, 938, 939, 940, 941, 942, 943, 944, 945, 946, 947, 948, 949, 950, 951, 952, 953, 954, 955, 956, 957, 958, 959, 960, 961, 962, 963, 964, 965, 966, 967, 968, 969, 970, 971, 972, 973, 974, 975, 976, 977, 978, 979, 980, 981, 982, 983, 984, 985, 986, 987, 988, 989, 990, 991, 992, 993, 994, 995, 996, 997, 998, 999], 'gc_content': 0.0, 'longest_run': 1}\n    assert candidate(\"GCGCGCGCGC\", \"GCG\") == {'occurrences': 4, 'positions': [1, 3, 5, 7], 'gc_content': 1.0, 'longest_run': 1}\n", "language": "python"}
{"task_id": "a44568b0-9eb5-4657-8f61-5ae4f7925b55-3718543784812431238", "prompt": "I need you to finish coding the function as described in the documentation string. Place the entire function in one code block.\n\n```python\nfrom typing import List, Tuple\n\ndef time_travel_paradox(events: List[Tuple[int, int, str]]) -> bool:\n    \"\"\"\n    You are a scientist working on a time travel experiment. You've recorded a series of\n    events that occurred during your experiments, each with a start time, end time, and\n    a brief description. Your task is to determine if there's a paradox in the timeline,\n    which occurs when two events overlap in time.\n\n    :param events: A list of tuples, where each tuple contains three elements:\n                   (start_time, end_time, description). Times are represented as integers.\n    :return: True if a paradox exists (i.e., if any two events overlap), False otherwise.\n\n\n    [EXAMPLES]\n    \n    assert candidate([(-5, 0, \"BC Event\"), (0, 5, \"AD Event\"), (10, 15, \"Future Event\")]) == False\n    assert candidate([(-100, -50, \"Past Event\"), (-75, -25, \"Overlapping Past Event\"), (0, 50, \"Present Event\")]) == True\n\n    [/EXAMPLES]\n    \"\"\"\n```\n", "entry_point": "time_travel_paradox", "solution": "from typing import List, Tuple\n\ndef time_travel_paradox(events: List[Tuple[int, int, str]]) -> bool:\n    \"\"\"\n    You are a scientist working on a time travel experiment. You've recorded a series of\n    events that occurred during your experiments, each with a start time, end time, and\n    a brief description. Your task is to determine if there's a paradox in the timeline,\n    which occurs when two events overlap in time.\n\n    :param events: A list of tuples, where each tuple contains three elements:\n                   (start_time, end_time, description). Times are represented as integers.\n    :return: True if a paradox exists (i.e., if any two events overlap), False otherwise.\n\n\n    [EXAMPLES]\n    \n    assert candidate([(-5, 0, \"BC Event\"), (0, 5, \"AD Event\"), (10, 15, \"Future Event\")]) == False\n    assert candidate([(-100, -50, \"Past Event\"), (-75, -25, \"Overlapping Past Event\"), (0, 50, \"Present Event\")]) == True\n\n    [/EXAMPLES]\n    \"\"\"\n    # Sort events by start time\n    sorted_events = sorted(events, key=lambda x: x[0])\n    \n    # Check for overlaps\n    for i in range(len(sorted_events) - 1):\n        current_end = sorted_events[i][1]\n        next_start = sorted_events[i + 1][0]\n        \n        # If the end time of the current event is greater than the start time of the next event,\n        # we have found an overlap (paradox)\n        if current_end > next_start:\n            return True\n    \n    # If we've gone through all events without finding an overlap, there's no paradox\n    return False\n\n", "test": "def check(candidate):\n    assert candidate([(1, 5, \"Event A\"), (6, 10, \"Event B\"), (11, 15, \"Event C\"), (16, 20, \"Event D\"), (21, 25, \"Event E\")]) == False\n    assert candidate([(1, 1000000, \"Long Event\"), (1000001, 2000000, \"Another Long Event\")]) == False\n    assert candidate([(-100, -50, \"Past Event\"), (-75, -25, \"Overlapping Past Event\"), (0, 50, \"Present Event\")]) == True\n    assert candidate([(0, 100, \"Very Long Event\"), (50, 60, \"Mid Event\"), (101, 102, \"Last Event\")]) == True\n    assert candidate([(-5, 0, \"BC Event\"), (0, 5, \"AD Event\"), (10, 15, \"Future Event\")]) == False\n    assert candidate([(1, 5, \"Event A\"), (2, 4, \"Event B\"), (3, 7, \"Event C\"), (6, 8, \"Event D\")]) == True\n    assert candidate([(1, 2, \"Event A\"), (2, 3, \"Event B\"), (3, 4, \"Event C\")]) == False\n    assert candidate([(1, 2, \"A\"), (2, 3, \"B\"), (3, 4, \"C\"), (4, 5, \"D\"), (5, 6, \"E\"), (1, 6, \"Overlapping All\")]) == True\n    assert candidate([]) == False\n    assert candidate([(0, 0, \"Zero-duration Event\"), (1, 1, \"Another Zero-duration Event\"), (2, 3, \"Normal Event\")]) == False\n", "language": "python"}
{"task_id": "70b2080d-42e4-4a9e-829c-8cc5f40cd5b33185091560551093053", "prompt": "I'll complete the function according to the requirements outlined in the docstring. The entire function will be in one code block.\n\n```python\nfrom typing import List\n\ndef calculate_max_profit(prices: List[int], k: int) -> int:\n    \"\"\"\n    You are a time-traveling stock trader with a special device that allows you to make at most k\n    round trips (buy and sell) in the stock market. You are given an array of stock prices, where\n    prices[i] is the price of a particular stock on the i-th day.\n    \n    Find the maximum profit you can achieve. You may complete at most k transactions, but you may not\n    engage in multiple transactions simultaneously (i.e., you must sell the stock before you buy again).\n    \n    Parameters:\n    prices (List[int]): An array of stock prices, where prices[i] is the price on the i-th day\n    k (int): The maximum number of transactions you can make\n    \n    Returns:\n    int: The maximum profit achievable\n    \n\n    [EXAMPLES]\n    \n    assert candidate([2, 4, 1], 2) == 2\n    assert candidate([3, 2, 6, 5, 0, 3], 2) == 7\n\n    [/EXAMPLES]\n    \"\"\"\n```\n", "entry_point": "calculate_max_profit", "solution": "from typing import List\n\ndef calculate_max_profit(prices: List[int], k: int) -> int:\n    \"\"\"\n    You are a time-traveling stock trader with a special device that allows you to make at most k\n    round trips (buy and sell) in the stock market. You are given an array of stock prices, where\n    prices[i] is the price of a particular stock on the i-th day.\n    \n    Find the maximum profit you can achieve. You may complete at most k transactions, but you may not\n    engage in multiple transactions simultaneously (i.e., you must sell the stock before you buy again).\n    \n    Parameters:\n    prices (List[int]): An array of stock prices, where prices[i] is the price on the i-th day\n    k (int): The maximum number of transactions you can make\n    \n    Returns:\n    int: The maximum profit achievable\n    \n\n    [EXAMPLES]\n    \n    assert candidate([2, 4, 1], 2) == 2\n    assert candidate([3, 2, 6, 5, 0, 3], 2) == 7\n\n    [/EXAMPLES]\n    \"\"\"\n    if not prices or k == 0:\n        return 0\n\n    n = len(prices)\n    \n    # If k is large enough, we can make as many transactions as we want\n    if k >= n // 2:\n        return sum(max(0, prices[i] - prices[i-1]) for i in range(1, n))\n    \n    # dp[i][j] represents the max profit up to day i with at most j transactions\n    dp = [[0 for _ in range(k + 1)] for _ in range(n)]\n    \n    for j in range(1, k + 1):\n        max_diff = -prices[0]\n        for i in range(1, n):\n            dp[i][j] = max(dp[i-1][j], prices[i] + max_diff)\n            max_diff = max(max_diff, dp[i][j-1] - prices[i])\n    \n    return dp[n-1][k]\n\n", "test": "def check(candidate):\n    assert candidate([100, 180, 260, 310, 40, 535, 695], 3) == 865\n    assert candidate([1, 1, 1, 1, 1], 5) == 0\n    assert candidate([3, 2, 6, 5, 0, 3], 2) == 7\n    assert candidate([3, 3, 5, 0, 0, 3, 1, 4], 2) == 6\n    assert candidate([2, 4, 1], 2) == 2\n    assert candidate([1, 2, 3, 2, 1], 1) == 2\n    assert candidate([1], 1) == 0\n    assert candidate([10, 22, 5, 75, 65, 80], 2) == 87\n    assert candidate([1, 2, 3, 4, 5], 2) == 4\n    assert candidate([100, 90, 80, 70, 60, 50, 40, 30, 20, 10], 0) == 0\n", "language": "python"}
{"task_id": "99d838c4-9d8c-461f-a341-786ecf2274057064547563514610590", "prompt": "I'll implement the function described in the docstring while preserving the original function name and argument structure. The complete solution should be placed in a single code block.\n\n```python\nimport heapq\nfrom typing import List\n\ndef haunted_house_escape(rooms: List[List[int]]) -> int:\n    \"\"\"\n    You're trapped in a haunted house with multiple rooms. Each room has a certain number of ghosts.\n    Your goal is to escape the house by moving through the rooms, but you can only move to adjacent rooms.\n    You start in the top-left room and need to reach the bottom-right room.\n    The function should return the minimum number of ghosts you'll encounter on your escape route.\n\n\n    [EXAMPLES]\n    \n    assert candidate([[1, 2, 3, 4, 5], [6, 7, 8, 9, 10], [11, 12, 13, 14, 15], [16, 17, 18, 19, 20], [21, 22, 23, 24, 25]]) == 85\n    assert candidate([[0, 0, 0], [0, 1000000, 0], [0, 0, 0]]) == 0\n\n    [/EXAMPLES]\n    \"\"\"\n```\n", "entry_point": "haunted_house_escape", "solution": "import heapq\nfrom typing import List\n\ndef haunted_house_escape(rooms: List[List[int]]) -> int:\n    \"\"\"\n    You're trapped in a haunted house with multiple rooms. Each room has a certain number of ghosts.\n    Your goal is to escape the house by moving through the rooms, but you can only move to adjacent rooms.\n    You start in the top-left room and need to reach the bottom-right room.\n    The function should return the minimum number of ghosts you'll encounter on your escape route.\n\n\n    [EXAMPLES]\n    \n    assert candidate([[1, 2, 3, 4, 5], [6, 7, 8, 9, 10], [11, 12, 13, 14, 15], [16, 17, 18, 19, 20], [21, 22, 23, 24, 25]]) == 85\n    assert candidate([[0, 0, 0], [0, 1000000, 0], [0, 0, 0]]) == 0\n\n    [/EXAMPLES]\n    \"\"\"\n    if not rooms or not rooms[0]:\n        return 0\n\n    m, n = len(rooms), len(rooms[0])\n    dp = [[float('inf')] * n for _ in range(m)]\n    \n    # Initialize the starting room\n    dp[0][0] = rooms[0][0]\n    \n    # Fill the first row\n    for j in range(1, n):\n        dp[0][j] = dp[0][j-1] + rooms[0][j]\n    \n    # Fill the first column\n    for i in range(1, m):\n        dp[i][0] = dp[i-1][0] + rooms[i][0]\n    \n    # Fill the rest of the dp table\n    for i in range(1, m):\n        for j in range(1, n):\n            dp[i][j] = min(dp[i-1][j], dp[i][j-1]) + rooms[i][j]\n    \n    # Return the minimum number of ghosts encountered\n    return dp[m-1][n-1]\n\n", "test": "def check(candidate):\n    assert candidate([[0, 0, 0], [0, 1, 0], [0, 0, 0]]) == 0\n    assert candidate([[0, 0, 0], [0, 1000000, 0], [0, 0, 0]]) == 0\n    assert candidate([[1, 1], [1, 1]]) == 3\n    assert candidate([[1, 2, 3], [4, 5, 6], [7, 8, 9]]) == 21\n    assert candidate([[1, 2, 3], [4, 5, 6], [7, 8, 9], [10, 11, 12]]) == 33\n    assert candidate([[1, 1, 1, 1], [1, 1, 1, 1], [1, 1, 1, 1]]) == 6\n    assert candidate([[100, 100], [100, 0]]) == 200\n    assert candidate([[1]]) == 1\n    assert candidate([[5, 1], [2, 3]]) == 9\n    assert candidate([[1, 2, 3, 4, 5], [6, 7, 8, 9, 10], [11, 12, 13, 14, 15], [16, 17, 18, 19, 20], [21, 22, 23, 24, 25]]) == 85\n", "language": "python"}
{"task_id": "46034d91-59a5-4bc0-a43b-ca47076d4776-1266654724936417065", "prompt": "You are a coding assistant. Your task is to complete a given function that can be executed as it is in a code block. Do not provide code outside the function. Use only the libraries imported in the problem. Only define additional functions or classes inside the given function.\n\n```python\nfrom copy import deepcopy\nfrom typing import List\n\ndef forest_fire_spread(forest: List[List[str]], days: int) -> List[List[str]]:\n    \"\"\"\n    In a forest represented by a 2D grid, we want to simulate the spread of a forest fire.\n    The forest is represented by a grid where:\n    'T' represents a healthy tree\n    'F' represents a burning tree\n    'A' represents ash (a burnt tree)\n    ' ' represents an empty space\n\n    Each day, the fire spreads to adjacent (up, down, left, right) healthy trees.\n    After a tree burns for a day, it turns to ash.\n\n    This function simulates the spread of the fire for a given number of days.\n\n    Args:\n    forest (List[List[str]]): The initial state of the forest\n    days (int): The number of days to simulate\n\n    Returns:\n    List[List[str]]: The state of the forest after the specified number of days\n\n\n    [EXAMPLES]\n    \n    assert candidate([['T', 'F', 'T'], ['F', 'T', 'F'], ['T', 'F', 'T']], 3) == [['A', 'A', 'A'], ['A', 'A', 'A'], ['A', 'A', 'A']]\n    assert candidate([['F', 'T', 'F'], ['T', 'T', 'T'], ['F', 'T', 'F']], 1) == [['A', 'F', 'A'], ['F', 'T', 'F'], ['A', 'F', 'A']]\n\n    [/EXAMPLES]\n    \"\"\"\n```\n", "entry_point": "forest_fire_spread", "solution": "from copy import deepcopy\nfrom typing import List\n\ndef forest_fire_spread(forest: List[List[str]], days: int) -> List[List[str]]:\n    \"\"\"\n    In a forest represented by a 2D grid, we want to simulate the spread of a forest fire.\n    The forest is represented by a grid where:\n    'T' represents a healthy tree\n    'F' represents a burning tree\n    'A' represents ash (a burnt tree)\n    ' ' represents an empty space\n\n    Each day, the fire spreads to adjacent (up, down, left, right) healthy trees.\n    After a tree burns for a day, it turns to ash.\n\n    This function simulates the spread of the fire for a given number of days.\n\n    Args:\n    forest (List[List[str]]): The initial state of the forest\n    days (int): The number of days to simulate\n\n    Returns:\n    List[List[str]]: The state of the forest after the specified number of days\n\n\n    [EXAMPLES]\n    \n    assert candidate([['T', 'F', 'T'], ['F', 'T', 'F'], ['T', 'F', 'T']], 3) == [['A', 'A', 'A'], ['A', 'A', 'A'], ['A', 'A', 'A']]\n    assert candidate([['F', 'T', 'F'], ['T', 'T', 'T'], ['F', 'T', 'F']], 1) == [['A', 'F', 'A'], ['F', 'T', 'F'], ['A', 'F', 'A']]\n\n    [/EXAMPLES]\n    \"\"\"\n    def get_adjacent(i, j):\n        return [(i-1, j), (i+1, j), (i, j-1), (i, j+1)]\n\n    rows, cols = len(forest), len(forest[0])\n\n    for _ in range(days):\n        new_forest = [row[:] for row in forest]\n        \n        for i in range(rows):\n            for j in range(cols):\n                if forest[i][j] == 'F':\n                    new_forest[i][j] = 'A'\n                    for ni, nj in get_adjacent(i, j):\n                        if 0 <= ni < rows and 0 <= nj < cols and forest[ni][nj] == 'T':\n                            new_forest[ni][nj] = 'F'\n        \n        forest = new_forest\n\n    return forest\n\n", "test": "def check(candidate):\n    assert candidate([['T', 'T', 'T'], ['T', 'T', 'T'], ['T', 'T', 'T']], 5) == [['T', 'T', 'T'], ['T', 'T', 'T'], ['T', 'T', 'T']]\n    assert candidate([['T', 'T', 'T'], ['T', ' ', 'T'], ['T', 'T', 'F']], 3) == [['T', 'F', 'A'], ['F', ' ', 'A'], ['A', 'A', 'A']]\n    assert candidate([['F', 'T', 'F'], ['T', 'T', 'T'], ['F', 'T', 'F']], 1) == [['A', 'F', 'A'], ['F', 'T', 'F'], ['A', 'F', 'A']]\n    assert candidate([[' ']], 1) == [[' ']]\n    assert candidate([['T', 'T', 'T'], ['T', 'F', 'T'], ['T', 'T', 'T']], 3) == [['A', 'A', 'A'], ['A', 'A', 'A'], ['A', 'A', 'A']]\n    assert candidate([['T', 'T', 'T'], ['T', 'F', 'T'], ['T', 'T', 'T']], 2) == [['F', 'A', 'F'], ['A', 'A', 'A'], ['F', 'A', 'F']]\n    assert candidate([['T', 'T', 'T'], ['T', 'T', 'T'], ['T', 'T', 'F']], 4) == [['F', 'A', 'A'], ['A', 'A', 'A'], ['A', 'A', 'A']]\n    assert candidate([['T']], 1) == [['T']]\n    assert candidate([['F']], 1) == [['A']]\n    assert candidate([['T', 'F', 'T'], ['F', 'T', 'F'], ['T', 'F', 'T']], 3) == [['A', 'A', 'A'], ['A', 'A', 'A'], ['A', 'A', 'A']]\n", "language": "python"}
{"task_id": "8d68a986-c02d-4da3-b2ae-92875b46ced9-7641350220921875424", "prompt": "I'll provide the implementation for the specified function that can be executed directly. I'll only use the libraries that are already imported in the problem, and any additional functions or classes needed will be defined inside the main function.\n\n```python\nfrom typing import List\n\ndef optimize_student_arrangement(ages: List[int]) -> int:\n    \"\"\"\n    In a classroom, students are initially arranged in a line. We want to rearrange them\n    so that their ages are in non-decreasing order, moving as few students as possible.\n    This function calculates the minimum number of moves required to achieve this order.\n\n    :param ages: A list of integers representing the ages of students in their initial order\n    :return: The minimum number of moves required to sort the students by age\n\n\n    [EXAMPLES]\n    \n    assert candidate([1, 2, 1, 2, 1, 2, 1, 2]) == 3\n    assert candidate([7, 7, 7, 7, 1, 1, 1, 1]) == 4\n\n    [/EXAMPLES]\n    \"\"\"\n```\n", "entry_point": "optimize_student_arrangement", "solution": "from typing import List\n\ndef optimize_student_arrangement(ages: List[int]) -> int:\n    \"\"\"\n    In a classroom, students are initially arranged in a line. We want to rearrange them\n    so that their ages are in non-decreasing order, moving as few students as possible.\n    This function calculates the minimum number of moves required to achieve this order.\n\n    :param ages: A list of integers representing the ages of students in their initial order\n    :return: The minimum number of moves required to sort the students by age\n\n\n    [EXAMPLES]\n    \n    assert candidate([1, 2, 1, 2, 1, 2, 1, 2]) == 3\n    assert candidate([7, 7, 7, 7, 1, 1, 1, 1]) == 4\n\n    [/EXAMPLES]\n    \"\"\"\n    def lis_length(arr):\n        \"\"\"\n        Helper function to calculate the length of the Longest Increasing Subsequence (LIS)\n        \"\"\"\n        n = len(arr)\n        lis = [1] * n\n        for i in range(1, n):\n            for j in range(i):\n                if arr[i] >= arr[j] and lis[i] < lis[j] + 1:\n                    lis[i] = lis[j] + 1\n        return max(lis)\n\n    # The minimum number of moves is the total number of students\n    # minus the length of the longest non-decreasing subsequence\n    total_students = len(ages)\n    longest_non_decreasing_subsequence = lis_length(ages)\n    min_moves = total_students - longest_non_decreasing_subsequence\n\n    return min_moves\n\n", "test": "def check(candidate):\n    assert candidate([1, 2, 1, 2, 1, 2, 1, 2]) == 3\n    assert candidate([7, 7, 7, 7, 1, 1, 1, 1]) == 4\n    assert candidate([1, 10, 100, 1000, 10000, 100000]) == 0\n    assert candidate([1, 10, 2, 9, 3, 8, 4, 7, 5, 6]) == 4\n    assert candidate([7, 7, 7, 7, 6, 6, 6, 6, 5, 5, 5, 5]) == 8\n    assert candidate([2, 1, 3, 5, 4]) == 2\n    assert candidate([5, 4, 3, 2, 1, 1, 2, 3, 4, 5]) == 4\n    assert candidate([1, 2, 3, 4, 5, 5, 4, 3, 2, 1]) == 4\n    assert candidate([100, 1, 99, 2, 98, 3, 97, 4, 96, 5]) == 5\n    assert candidate([1, 1, 1, 1, 1]) == 0\n", "language": "python"}
{"task_id": "fd75da5f-1fe6-4f4e-aac8-18a34a155ed2-4194119197296504214", "prompt": "Code the function completely according to the specifications in the documentation string. Present your solution as a single code block.\n\n```python\nfrom typing import List\n\ndef terrain_analyzer(heights: List[int]) -> int:\n    \"\"\"\n    In a geological survey of a mountain range, we need to count the number of peaks in the terrain.\n    A peak is defined as an element that is strictly greater than its neighboring elements.\n    Analyze the terrain heights and return the number of peaks.\n\n    Parameters:\n    heights (List[int]): A list of integers representing the heights of the terrain\n\n    Returns:\n    int: The number of peaks in the terrain\n\n\n    [EXAMPLES]\n    \n    assert candidate([1, 2, 3, 4, 5]) == 0\n    assert candidate([1, 1, 1, 1, 1]) == 0\n\n    [/EXAMPLES]\n    \"\"\"\n```\n", "entry_point": "terrain_analyzer", "solution": "from typing import List\n\ndef terrain_analyzer(heights: List[int]) -> int:\n    \"\"\"\n    In a geological survey of a mountain range, we need to count the number of peaks in the terrain.\n    A peak is defined as an element that is strictly greater than its neighboring elements.\n    Analyze the terrain heights and return the number of peaks.\n\n    Parameters:\n    heights (List[int]): A list of integers representing the heights of the terrain\n\n    Returns:\n    int: The number of peaks in the terrain\n\n\n    [EXAMPLES]\n    \n    assert candidate([1, 2, 3, 4, 5]) == 0\n    assert candidate([1, 1, 1, 1, 1]) == 0\n\n    [/EXAMPLES]\n    \"\"\"\n    def is_peak(index: int) -> bool:\n        \"\"\"\n        Helper function to check if the element at the given index is a peak.\n        \"\"\"\n        if index == 0 or index == len(heights) - 1:\n            return False\n        return heights[index] > heights[index-1] and heights[index] > heights[index+1]\n\n    peak_count = 0\n    for i in range(1, len(heights) - 1):\n        if is_peak(i):\n            peak_count += 1\n\n    return peak_count\n\n", "test": "def check(candidate):\n    assert candidate([10, 9, 8, 7, 8, 9, 10]) == 0\n    assert candidate([7, 6, 5, 4, 5, 6, 7]) == 0\n    assert candidate([1, 1, 1, 1, 1]) == 0\n    assert candidate([]) == 0\n    assert candidate([5, 4, 3, 4, 5]) == 0\n    assert candidate([1, 2, 3, 4, 5]) == 0\n    assert candidate([1, 2, 1, 2, 1, 2, 1]) == 3\n    assert candidate([100, 99, 98, 97, 96, 95]) == 0\n    assert candidate([5, 4, 3, 2, 1]) == 0\n    assert candidate([1, 2, 1, 2, 1, 2, 1, 2]) == 3\n", "language": "python"}
{"task_id": "02e658f3-6f2f-4877-a878-da775e31befd-1020737873373872311", "prompt": "I'll serve as your coding helper by completing functions that are ready to run. I'll stick to using the libraries mentioned in the problem and place any auxiliary functions or classes inside the main function.\n\n```python\nfrom typing import List\n\ndef decode_alien_message(encoded_message: str, codebook: List[str]) -> str:\n    \"\"\"\n    Decode an alien message using a provided codebook of alien words.\n\n    You've intercepted a message from an alien civilization, but it's encoded\n    using their unique language. Given the encoded message and a codebook of\n    known alien words, this function attempts to decode the message by finding\n    the longest possible matches in the codebook for each part of the message.\n\n    Args:\n    encoded_message (str): The intercepted alien message as a string of symbols.\n    codebook (List[str]): A list of known alien words and their meanings.\n\n    Returns:\n    str: The decoded message in human-readable form.\n\n\n    [EXAMPLES]\n    \n    assert candidate(\"ABCDEFGHIJKLMNOP\", [\"ABC\", \"DEF\", \"GHI\", \"JKL\", \"MNO\"]) == 'ABC DEF GHI JKL MNO P'\n    assert candidate(\"ZYXWVUTSRQPONMLKJIHGFEDCBA\", [\"ZYX\", \"WVU\", \"TSR\", \"QP\", \"ON\", \"MLK\", \"JIH\", \"GFE\", \"DCBA\"]) == 'ZYX WVU TSR QP ON MLK JIH GFE DCBA'\n\n    [/EXAMPLES]\n    \"\"\"\n```\n", "entry_point": "decode_alien_message", "solution": "from typing import List\n\ndef decode_alien_message(encoded_message: str, codebook: List[str]) -> str:\n    \"\"\"\n    Decode an alien message using a provided codebook of alien words.\n\n    You've intercepted a message from an alien civilization, but it's encoded\n    using their unique language. Given the encoded message and a codebook of\n    known alien words, this function attempts to decode the message by finding\n    the longest possible matches in the codebook for each part of the message.\n\n    Args:\n    encoded_message (str): The intercepted alien message as a string of symbols.\n    codebook (List[str]): A list of known alien words and their meanings.\n\n    Returns:\n    str: The decoded message in human-readable form.\n\n\n    [EXAMPLES]\n    \n    assert candidate(\"ABCDEFGHIJKLMNOP\", [\"ABC\", \"DEF\", \"GHI\", \"JKL\", \"MNO\"]) == 'ABC DEF GHI JKL MNO P'\n    assert candidate(\"ZYXWVUTSRQPONMLKJIHGFEDCBA\", [\"ZYX\", \"WVU\", \"TSR\", \"QP\", \"ON\", \"MLK\", \"JIH\", \"GFE\", \"DCBA\"]) == 'ZYX WVU TSR QP ON MLK JIH GFE DCBA'\n\n    [/EXAMPLES]\n    \"\"\"\n    def find_longest_match(substring, codebook):\n        longest_match = \"\"\n        for word in codebook:\n            if substring.startswith(word) and len(word) > len(longest_match):\n                longest_match = word\n        return longest_match\n\n    decoded_message = []\n    i = 0\n    while i < len(encoded_message):\n        match = find_longest_match(encoded_message[i:], codebook)\n        if match:\n            decoded_message.append(match)\n            i += len(match)\n        else:\n            decoded_message.append(encoded_message[i])\n            i += 1\n\n    return \" \".join(decoded_message)\n\n", "test": "def check(candidate):\n    assert candidate(\"AAABBBCCC\", [\"AAA\", \"BBB\", \"CCC\"]) == 'AAA BBB CCC'\n    assert candidate(\"ASDFGHJKL\", [\"AS\", \"DF\", \"GH\", \"JKL\"]) == 'AS DF GH JKL'\n    assert candidate(\"ABCDEFG\", [\"ABCDEFG\"]) == 'ABCDEFG'\n    assert candidate(\"ABCDEFGHIJKLMNOP\", [\"ABC\", \"DEF\", \"GHI\", \"JKL\", \"MNO\"]) == 'ABC DEF GHI JKL MNO P'\n    assert candidate(\"AABBCCDDEE\", [\"AA\", \"BB\", \"CC\", \"DD\", \"EE\"]) == 'AA BB CC DD EE'\n    assert candidate(\"XXYYZZ\", [\"X\", \"Y\", \"Z\", \"XX\", \"YY\", \"ZZ\"]) == 'XX YY ZZ'\n    assert candidate(\"ABCABCABC\", [\"ABC\", \"AB\", \"C\"]) == 'ABC ABC ABC'\n    assert candidate(\"ZYXWVUTSRQPONMLKJIHGFEDCBA\", [\"ZYX\", \"WVU\", \"TSR\", \"QP\", \"ON\", \"MLK\", \"JIH\", \"GFE\", \"DCBA\"]) == 'ZYX WVU TSR QP ON MLK JIH GFE DCBA'\n    assert candidate(\"AAAABBBBCCCC\", [\"A\", \"AA\", \"AAA\", \"AAAA\", \"B\", \"BB\", \"BBB\", \"BBBB\", \"C\", \"CC\", \"CCC\", \"CCCC\"]) == 'AAAA BBBB CCCC'\n    assert candidate(\"ABCDEFGHIJKLMNOPQRSTUVWXYZ\", [\"A\", \"B\", \"C\", \"D\", \"E\", \"F\", \"G\", \"H\", \"I\", \"J\", \"K\", \"L\", \"M\", \"N\", \"O\", \"P\", \"Q\", \"R\", \"S\", \"T\", \"U\", \"V\", \"W\", \"X\", \"Y\", \"Z\"]) == 'A B C D E F G H I J K L M N O P Q R S T U V W X Y Z'\n", "language": "python"}
{"task_id": "50ca0d2c-8752-4442-b4bc-2fea939ac7e2-5028343327513912563", "prompt": "Your assignment is to implement a function that's ready to execute in a single code block. Don't add any code outside this function. Only use libraries that are already imported in the problem statement. Any auxiliary functions or classes should be nested within the main function. Provide just one complete code block.\n\n```python\nfrom typing import List\n\ndef knight_tour(board_size: int, start_x: int, start_y: int) -> List[List[int]]:\n    \"\"\"You are a chess enthusiast studying the Knight's Tour problem. Implement a function\n    that finds a knight's tour on a square chessboard of given size, starting from a specified position.\n\n    A knight's tour is a sequence of moves by a knight on a chessboard such that the knight\n    visits every square exactly once. If a tour doesn't exist, return an empty list.\n\n    The function should take the board size (N x N) and the starting coordinates (x, y) as input,\n    where (0, 0) represents the top-left corner of the board. It should return a list of coordinates\n    representing the knight's path, including the starting position.\n\n    Use Warnsdorff's rule to improve the efficiency of your solution: always move to the square\n    with the fewest onward moves available.\n\n\n    [EXAMPLES]\n    \n    assert candidate(1, 0, 0) == [[0, 0]]\n    assert candidate(7, 0, 6) == [[0, 6], [1, 4], [0, 2], [1, 0], [3, 1], [5, 0], [6, 2], [4, 1], [6, 0], [5, 2], [4, 0], [6, 1], [5, 3], [6, 5], [4, 6], [2, 5], [0, 4], [1, 6], [3, 5], [5, 6], [6, 4], [4, 3], [5, 1], [3, 0], [1, 1], [0, 3], [2, 2], [0, 1], [2, 0], [1, 2], [0, 0], [2, 1], [3, 3], [5, 4], [6, 6], [4, 5], [2, 6], [0, 5], [1, 3], [3, 2], [2, 4], [3, 6], [1, 5], [2, 3], [4, 4], [6, 3], [4, 2], [3, 4], [5, 5]]\n\n    [/EXAMPLES]\n    \"\"\"\n```\n", "entry_point": "knight_tour", "solution": "from typing import List\n\ndef knight_tour(board_size: int, start_x: int, start_y: int) -> List[List[int]]:\n    \"\"\"You are a chess enthusiast studying the Knight's Tour problem. Implement a function\n    that finds a knight's tour on a square chessboard of given size, starting from a specified position.\n\n    A knight's tour is a sequence of moves by a knight on a chessboard such that the knight\n    visits every square exactly once. If a tour doesn't exist, return an empty list.\n\n    The function should take the board size (N x N) and the starting coordinates (x, y) as input,\n    where (0, 0) represents the top-left corner of the board. It should return a list of coordinates\n    representing the knight's path, including the starting position.\n\n    Use Warnsdorff's rule to improve the efficiency of your solution: always move to the square\n    with the fewest onward moves available.\n\n\n    [EXAMPLES]\n    \n    assert candidate(1, 0, 0) == [[0, 0]]\n    assert candidate(7, 0, 6) == [[0, 6], [1, 4], [0, 2], [1, 0], [3, 1], [5, 0], [6, 2], [4, 1], [6, 0], [5, 2], [4, 0], [6, 1], [5, 3], [6, 5], [4, 6], [2, 5], [0, 4], [1, 6], [3, 5], [5, 6], [6, 4], [4, 3], [5, 1], [3, 0], [1, 1], [0, 3], [2, 2], [0, 1], [2, 0], [1, 2], [0, 0], [2, 1], [3, 3], [5, 4], [6, 6], [4, 5], [2, 6], [0, 5], [1, 3], [3, 2], [2, 4], [3, 6], [1, 5], [2, 3], [4, 4], [6, 3], [4, 2], [3, 4], [5, 5]]\n\n    [/EXAMPLES]\n    \"\"\"\n    def is_valid_move(x, y):\n        return 0 <= x < board_size and 0 <= y < board_size and board[x][y] == -1\n\n    def count_valid_moves(x, y):\n        return sum(1 for dx, dy in moves if is_valid_move(x + dx, y + dy))\n\n    def warnsdorff_move(x, y):\n        valid_moves = [(x + dx, y + dy) for dx, dy in moves if is_valid_move(x + dx, y + dy)]\n        return min(valid_moves, key=lambda pos: count_valid_moves(*pos), default=None)\n\n    def tour(x, y, move_count):\n        board[x][y] = move_count\n        path.append([x, y])\n\n        if move_count == board_size ** 2 - 1:\n            return True\n\n        next_move = warnsdorff_move(x, y)\n        if next_move:\n            if tour(*next_move, move_count + 1):\n                return True\n\n        board[x][y] = -1\n        path.pop()\n        return False\n\n    moves = [\n        (-2, -1), (-2, 1), (-1, -2), (-1, 2),\n        (1, -2), (1, 2), (2, -1), (2, 1)\n    ]\n    board = [[-1] * board_size for _ in range(board_size)]\n    path = []\n\n    if tour(start_x, start_y, 0):\n        return path\n    return []\n\n", "test": "def check(candidate):\n    assert candidate(1, 0, 0) == [[0, 0]]\n    assert candidate(7, 3, 3) == [[3, 3], [1, 2], [0, 0], [2, 1], [0, 2], [1, 0], [3, 1], [5, 0], [6, 2], [4, 1], [6, 0], [5, 2], [4, 0], [6, 1], [5, 3], [6, 5], [4, 6], [5, 4], [6, 6], [4, 5], [6, 4], [5, 6], [3, 5], [1, 6], [0, 4], [2, 5], [0, 6], [1, 4], [2, 6], [0, 5], [1, 3], [0, 1], [2, 0], [3, 2], [1, 1], [0, 3], [2, 4], [3, 6], [1, 5], [2, 3], [4, 4], [6, 3], [4, 2], [3, 0], [5, 1], [4, 3], [2, 2], [3, 4], [5, 5]]\n    assert candidate(6, 5, 5) == [[5, 5], [3, 4], [1, 5], [0, 3], [1, 1], [3, 0], [5, 1], [4, 3], [3, 5], [5, 4], [4, 2], [5, 0], [3, 1], [1, 0], [0, 2], [1, 4], [2, 2], [0, 1], [2, 0], [4, 1], [5, 3], [4, 5], [2, 4], [0, 5], [1, 3], [3, 2], [4, 0], [2, 1], [0, 0], [1, 2], [0, 4], [2, 3], [4, 4], [2, 5], [3, 3], [5, 2]]\n    assert candidate(7, 0, 6) == [[0, 6], [1, 4], [0, 2], [1, 0], [3, 1], [5, 0], [6, 2], [4, 1], [6, 0], [5, 2], [4, 0], [6, 1], [5, 3], [6, 5], [4, 6], [2, 5], [0, 4], [1, 6], [3, 5], [5, 6], [6, 4], [4, 3], [5, 1], [3, 0], [1, 1], [0, 3], [2, 2], [0, 1], [2, 0], [1, 2], [0, 0], [2, 1], [3, 3], [5, 4], [6, 6], [4, 5], [2, 6], [0, 5], [1, 3], [3, 2], [2, 4], [3, 6], [1, 5], [2, 3], [4, 4], [6, 3], [4, 2], [3, 4], [5, 5]]\n    assert candidate(4, 3, 2) == []\n    assert candidate(8, 7, 7) == [[7, 7], [5, 6], [3, 7], [1, 6], [0, 4], [1, 2], [0, 0], [2, 1], [0, 2], [1, 0], [3, 1], [5, 0], [7, 1], [6, 3], [7, 5], [6, 7], [4, 6], [2, 7], [0, 6], [1, 4], [3, 5], [4, 7], [6, 6], [7, 4], [5, 5], [7, 6], [5, 7], [6, 5], [7, 3], [5, 4], [6, 2], [7, 0], [5, 1], [3, 0], [1, 1], [0, 3], [1, 5], [0, 7], [2, 6], [0, 5], [1, 7], [3, 6], [2, 4], [4, 3], [2, 2], [0, 1], [2, 0], [4, 1], [6, 0], [7, 2], [6, 4], [4, 5], [3, 3], [2, 5], [1, 3], [3, 4], [4, 2], [2, 3], [4, 4], [5, 2], [4, 0], [3, 2], [5, 3], [6, 1]]\n    assert candidate(6, 0, 0) == [[0, 0], [1, 2], [0, 4], [2, 5], [4, 4], [5, 2], [4, 0], [2, 1], [0, 2], [1, 0], [3, 1], [5, 0], [4, 2], [5, 4], [3, 3], [1, 4], [3, 5], [2, 3], [1, 5], [0, 3], [1, 1], [3, 0], [5, 1], [4, 3], [5, 5], [3, 4], [2, 2], [0, 1], [1, 3], [0, 5], [2, 4], [4, 5], [5, 3], [3, 2], [2, 0], [4, 1]]\n    assert candidate(4, 0, 3) == []\n    assert candidate(6, 2, 3) == [[2, 3], [0, 4], [2, 5], [4, 4], [5, 2], [4, 0], [2, 1], [0, 0], [1, 2], [2, 0], [0, 1], [1, 3], [0, 5], [2, 4], [4, 5], [3, 3], [4, 1], [5, 3], [3, 2], [1, 1], [0, 3], [1, 5], [3, 4], [5, 5], [4, 3], [5, 1], [3, 0], [2, 2], [1, 0], [0, 2], [1, 4], [3, 5], [5, 4], [4, 2], [5, 0], [3, 1]]\n    assert candidate(8, 3, 5) == [[3, 5], [1, 6], [0, 4], [1, 2], [0, 0], [2, 1], [0, 2], [1, 0], [3, 1], [5, 0], [7, 1], [6, 3], [7, 5], [6, 7], [4, 6], [2, 7], [0, 6], [1, 4], [2, 6], [0, 7], [1, 5], [0, 3], [1, 1], [2, 3], [4, 2], [3, 0], [2, 2], [0, 1], [2, 0], [4, 1], [6, 0], [7, 2], [5, 1], [7, 0], [6, 2], [4, 3], [2, 4], [0, 5], [1, 7], [3, 6], [5, 7], [7, 6], [5, 5], [4, 7], [6, 6], [7, 4], [5, 3], [3, 4], [1, 3], [3, 2], [4, 0], [6, 1], [7, 3], [5, 4], [3, 3], [2, 5], [3, 7], [4, 5], [6, 4], [5, 2], [4, 4], [5, 6], [7, 7], [6, 5]]\n", "language": "python"}
{"task_id": "31aa3604-4bbe-4eab-b716-5982962d93e74606675774569795778", "prompt": "My goal is to implement a fully functional solution in one code block. I'll ensure the function is complete and can run independently using only the imported libraries mentioned. All helper functions or classes will be defined inside the main function. I'll provide just the code implementation without any surrounding explanations.\n\n```python\nfrom typing import List, Tuple\nfrom collections import defaultdict\n\ndef space_station_repair(parts: List[int], repairs: List[Tuple[int, int]]) -> int:\n    \"\"\"\n    The International Space Station needs urgent repairs. You are given a list of parts, where each part has a unique ID (integer).\n    Some parts need to be repaired before they can be used. The repairs list contains tuples, where each tuple (a, b) means\n    that part 'a' needs to be repaired before part 'b' can be used.\n\n    Your task is to determine the minimum number of repair steps needed to fix all the parts, assuming that only one part\n    can be repaired in each step, and a part can only be repaired if all the parts it depends on have already been repaired.\n\n\n    [EXAMPLES]\n    \n    assert candidate([1, 2, 3], [(1, 2), (2, 3), (1, 3)]) == 3\n    assert candidate([1, 2, 3, 4, 5, 6], [(1, 2), (2, 3), (3, 4), (4, 5), (5, 6), (1, 6)]) == 6\n\n    [/EXAMPLES]\n    \"\"\"\n```\n", "entry_point": "space_station_repair", "solution": "from typing import List, Tuple\nfrom collections import defaultdict\n\ndef space_station_repair(parts: List[int], repairs: List[Tuple[int, int]]) -> int:\n    \"\"\"\n    The International Space Station needs urgent repairs. You are given a list of parts, where each part has a unique ID (integer).\n    Some parts need to be repaired before they can be used. The repairs list contains tuples, where each tuple (a, b) means\n    that part 'a' needs to be repaired before part 'b' can be used.\n\n    Your task is to determine the minimum number of repair steps needed to fix all the parts, assuming that only one part\n    can be repaired in each step, and a part can only be repaired if all the parts it depends on have already been repaired.\n\n\n    [EXAMPLES]\n    \n    assert candidate([1, 2, 3], [(1, 2), (2, 3), (1, 3)]) == 3\n    assert candidate([1, 2, 3, 4, 5, 6], [(1, 2), (2, 3), (3, 4), (4, 5), (5, 6), (1, 6)]) == 6\n\n    [/EXAMPLES]\n    \"\"\"\n    def topological_sort(graph, in_degree):\n        queue = [node for node in graph if in_degree[node] == 0]\n        sorted_order = []\n        \n        while queue:\n            node = queue.pop(0)\n            sorted_order.append(node)\n            \n            for neighbor in graph[node]:\n                in_degree[neighbor] -= 1\n                if in_degree[neighbor] == 0:\n                    queue.append(neighbor)\n        \n        return sorted_order\n\n    # Create a graph and calculate in-degree for each part\n    graph = defaultdict(list)\n    in_degree = defaultdict(int)\n    \n    for part in parts:\n        graph[part]\n        in_degree[part]\n    \n    for a, b in repairs:\n        graph[a].append(b)\n        in_degree[b] += 1\n    \n    # Perform topological sort\n    repair_order = topological_sort(graph, in_degree)\n    \n    # Check if all parts can be repaired (no cycles)\n    if len(repair_order) != len(parts):\n        return -1  # Impossible to repair all parts\n    \n    return len(repair_order)\n\n", "test": "def check(candidate):\n    assert candidate([1, 2, 3, 4, 5], [(1, 3), (2, 4), (3, 5)]) == 5\n    assert candidate([1, 2, 3, 4, 5], [(1, 2), (2, 3), (3, 4), (4, 5), (1, 5)]) == 5\n    assert candidate([1, 2, 3, 4, 5, 6, 7], [(1, 2), (1, 3), (2, 4), (2, 5), (3, 6), (3, 7)]) == 7\n    assert candidate([1, 2, 3, 4, 5], [(1, 2), (2, 3), (3, 4), (4, 5), (5, 1)]) == -1\n    assert candidate([1, 2, 3, 4, 5, 6], [(1, 2), (2, 3), (3, 4), (4, 5), (5, 6), (1, 6)]) == 6\n    assert candidate([10, 20, 30, 40, 50], [(10, 20), (20, 30), (30, 40), (40, 50)]) == 5\n    assert candidate([1, 2, 3], [(1, 2), (2, 3), (1, 3)]) == 3\n    assert candidate([1, 2, 3, 4, 5], [(1, 2), (2, 3), (3, 4), (4, 5), (1, 5), (2, 4), (3, 5)]) == 5\n    assert candidate([1, 2, 3, 4, 5], []) == 5\n    assert candidate([1, 2, 3, 4, 5], [(1, 2), (1, 3), (1, 4), (1, 5)]) == 5\n", "language": "python"}
{"task_id": "330dc419-085f-4fa1-8355-6b717719e2e8-4688224768572999162", "prompt": "Implement the given function so it's executable in a single code block. Don't include any code outside the function definition. Limit your use of libraries to only those imported in the problem statement. Any auxiliary functions or classes should be nested within the main function.\n\n```python\ndef generate_spiral_matrix(n: int) -> list[list[int]]:\n    \"\"\"\n    In a robotics lab, you need to program a robot to move in a spiral pattern.\n    Given an integer n, generate an n x n matrix filled with elements from 1 to n^2 in spiral order.\n    The spiral should start from the top-left corner and move clockwise.\n    Return the resulting matrix.\n\n\n    [EXAMPLES]\n    \n    assert candidate(6) == [[1, 2, 3, 4, 5, 6], [20, 21, 22, 23, 24, 7], [19, 32, 33, 34, 25, 8], [18, 31, 36, 35, 26, 9], [17, 30, 29, 28, 27, 10], [16, 15, 14, 13, 12, 11]]\n    assert candidate(5) == [[1, 2, 3, 4, 5], [16, 17, 18, 19, 6], [15, 24, 25, 20, 7], [14, 23, 22, 21, 8], [13, 12, 11, 10, 9]]\n\n    [/EXAMPLES]\n    \"\"\"\n```\n", "entry_point": "generate_spiral_matrix", "solution": "def generate_spiral_matrix(n: int) -> list[list[int]]:\n    \"\"\"\n    In a robotics lab, you need to program a robot to move in a spiral pattern.\n    Given an integer n, generate an n x n matrix filled with elements from 1 to n^2 in spiral order.\n    The spiral should start from the top-left corner and move clockwise.\n    Return the resulting matrix.\n\n\n    [EXAMPLES]\n    \n    assert candidate(6) == [[1, 2, 3, 4, 5, 6], [20, 21, 22, 23, 24, 7], [19, 32, 33, 34, 25, 8], [18, 31, 36, 35, 26, 9], [17, 30, 29, 28, 27, 10], [16, 15, 14, 13, 12, 11]]\n    assert candidate(5) == [[1, 2, 3, 4, 5], [16, 17, 18, 19, 6], [15, 24, 25, 20, 7], [14, 23, 22, 21, 8], [13, 12, 11, 10, 9]]\n\n    [/EXAMPLES]\n    \"\"\"\n    def fill_spiral(matrix, start_row, start_col, size, num):\n        if size <= 0:\n            return num\n\n        # Fill top row\n        for col in range(start_col, start_col + size):\n            matrix[start_row][col] = num\n            num += 1\n\n        # Fill right column\n        for row in range(start_row + 1, start_row + size):\n            matrix[row][start_col + size - 1] = num\n            num += 1\n\n        # Fill bottom row\n        if size > 1:\n            for col in range(start_col + size - 2, start_col - 1, -1):\n                matrix[start_row + size - 1][col] = num\n                num += 1\n\n        # Fill left column\n        if size > 1:\n            for row in range(start_row + size - 2, start_row, -1):\n                matrix[row][start_col] = num\n                num += 1\n\n        # Recursively fill the inner spiral\n        return fill_spiral(matrix, start_row + 1, start_col + 1, size - 2, num)\n\n    # Initialize the matrix with zeros\n    matrix = [[0 for _ in range(n)] for _ in range(n)]\n    \n    # Start filling the spiral\n    fill_spiral(matrix, 0, 0, n, 1)\n    \n    return matrix\n\n", "test": "def check(candidate):\n    assert candidate(5) == [[1, 2, 3, 4, 5], [16, 17, 18, 19, 6], [15, 24, 25, 20, 7], [14, 23, 22, 21, 8], [13, 12, 11, 10, 9]]\n    assert candidate(6) == [[1, 2, 3, 4, 5, 6], [20, 21, 22, 23, 24, 7], [19, 32, 33, 34, 25, 8], [18, 31, 36, 35, 26, 9], [17, 30, 29, 28, 27, 10], [16, 15, 14, 13, 12, 11]]\n    assert candidate(20) == [[1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20], [76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 21], [75, 144, 145, 146, 147, 148, 149, 150, 151, 152, 153, 154, 155, 156, 157, 158, 159, 160, 95, 22], [74, 143, 204, 205, 206, 207, 208, 209, 210, 211, 212, 213, 214, 215, 216, 217, 218, 161, 96, 23], [73, 142, 203, 256, 257, 258, 259, 260, 261, 262, 263, 264, 265, 266, 267, 268, 219, 162, 97, 24], [72, 141, 202, 255, 300, 301, 302, 303, 304, 305, 306, 307, 308, 309, 310, 269, 220, 163, 98, 25], [71, 140, 201, 254, 299, 336, 337, 338, 339, 340, 341, 342, 343, 344, 311, 270, 221, 164, 99, 26], [70, 139, 200, 253, 298, 335, 364, 365, 366, 367, 368, 369, 370, 345, 312, 271, 222, 165, 100, 27], [69, 138, 199, 252, 297, 334, 363, 384, 385, 386, 387, 388, 371, 346, 313, 272, 223, 166, 101, 28], [68, 137, 198, 251, 296, 333, 362, 383, 396, 397, 398, 389, 372, 347, 314, 273, 224, 167, 102, 29], [67, 136, 197, 250, 295, 332, 361, 382, 395, 400, 399, 390, 373, 348, 315, 274, 225, 168, 103, 30], [66, 135, 196, 249, 294, 331, 360, 381, 394, 393, 392, 391, 374, 349, 316, 275, 226, 169, 104, 31], [65, 134, 195, 248, 293, 330, 359, 380, 379, 378, 377, 376, 375, 350, 317, 276, 227, 170, 105, 32], [64, 133, 194, 247, 292, 329, 358, 357, 356, 355, 354, 353, 352, 351, 318, 277, 228, 171, 106, 33], [63, 132, 193, 246, 291, 328, 327, 326, 325, 324, 323, 322, 321, 320, 319, 278, 229, 172, 107, 34], [62, 131, 192, 245, 290, 289, 288, 287, 286, 285, 284, 283, 282, 281, 280, 279, 230, 173, 108, 35], [61, 130, 191, 244, 243, 242, 241, 240, 239, 238, 237, 236, 235, 234, 233, 232, 231, 174, 109, 36], [60, 129, 190, 189, 188, 187, 186, 185, 184, 183, 182, 181, 180, 179, 178, 177, 176, 175, 110, 37], [59, 128, 127, 126, 125, 124, 123, 122, 121, 120, 119, 118, 117, 116, 115, 114, 113, 112, 111, 38], [58, 57, 56, 55, 54, 53, 52, 51, 50, 49, 48, 47, 46, 45, 44, 43, 42, 41, 40, 39]]\n    assert candidate(100) == [[1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99, 100], [396, 397, 398, 399, 400, 401, 402, 403, 404, 405, 406, 407, 408, 409, 410, 411, 412, 413, 414, 415, 416, 417, 418, 419, 420, 421, 422, 423, 424, 425, 426, 427, 428, 429, 430, 431, 432, 433, 434, 435, 436, 437, 438, 439, 440, 441, 442, 443, 444, 445, 446, 447, 448, 449, 450, 451, 452, 453, 454, 455, 456, 457, 458, 459, 460, 461, 462, 463, 464, 465, 466, 467, 468, 469, 470, 471, 472, 473, 474, 475, 476, 477, 478, 479, 480, 481, 482, 483, 484, 485, 486, 487, 488, 489, 490, 491, 492, 493, 494, 101], [395, 784, 785, 786, 787, 788, 789, 790, 791, 792, 793, 794, 795, 796, 797, 798, 799, 800, 801, 802, 803, 804, 805, 806, 807, 808, 809, 810, 811, 812, 813, 814, 815, 816, 817, 818, 819, 820, 821, 822, 823, 824, 825, 826, 827, 828, 829, 830, 831, 832, 833, 834, 835, 836, 837, 838, 839, 840, 841, 842, 843, 844, 845, 846, 847, 848, 849, 850, 851, 852, 853, 854, 855, 856, 857, 858, 859, 860, 861, 862, 863, 864, 865, 866, 867, 868, 869, 870, 871, 872, 873, 874, 875, 876, 877, 878, 879, 880, 495, 102], [394, 783, 1164, 1165, 1166, 1167, 1168, 1169, 1170, 1171, 1172, 1173, 1174, 1175, 1176, 1177, 1178, 1179, 1180, 1181, 1182, 1183, 1184, 1185, 1186, 1187, 1188, 1189, 1190, 1191, 1192, 1193, 1194, 1195, 1196, 1197, 1198, 1199, 1200, 1201, 1202, 1203, 1204, 1205, 1206, 1207, 1208, 1209, 1210, 1211, 1212, 1213, 1214, 1215, 1216, 1217, 1218, 1219, 1220, 1221, 1222, 1223, 1224, 1225, 1226, 1227, 1228, 1229, 1230, 1231, 1232, 1233, 1234, 1235, 1236, 1237, 1238, 1239, 1240, 1241, 1242, 1243, 1244, 1245, 1246, 1247, 1248, 1249, 1250, 1251, 1252, 1253, 1254, 1255, 1256, 1257, 1258, 881, 496, 103], [393, 782, 1163, 1536, 1537, 1538, 1539, 1540, 1541, 1542, 1543, 1544, 1545, 1546, 1547, 1548, 1549, 1550, 1551, 1552, 1553, 1554, 1555, 1556, 1557, 1558, 1559, 1560, 1561, 1562, 1563, 1564, 1565, 1566, 1567, 1568, 1569, 1570, 1571, 1572, 1573, 1574, 1575, 1576, 1577, 1578, 1579, 1580, 1581, 1582, 1583, 1584, 1585, 1586, 1587, 1588, 1589, 1590, 1591, 1592, 1593, 1594, 1595, 1596, 1597, 1598, 1599, 1600, 1601, 1602, 1603, 1604, 1605, 1606, 1607, 1608, 1609, 1610, 1611, 1612, 1613, 1614, 1615, 1616, 1617, 1618, 1619, 1620, 1621, 1622, 1623, 1624, 1625, 1626, 1627, 1628, 1259, 882, 497, 104], [392, 781, 1162, 1535, 1900, 1901, 1902, 1903, 1904, 1905, 1906, 1907, 1908, 1909, 1910, 1911, 1912, 1913, 1914, 1915, 1916, 1917, 1918, 1919, 1920, 1921, 1922, 1923, 1924, 1925, 1926, 1927, 1928, 1929, 1930, 1931, 1932, 1933, 1934, 1935, 1936, 1937, 1938, 1939, 1940, 1941, 1942, 1943, 1944, 1945, 1946, 1947, 1948, 1949, 1950, 1951, 1952, 1953, 1954, 1955, 1956, 1957, 1958, 1959, 1960, 1961, 1962, 1963, 1964, 1965, 1966, 1967, 1968, 1969, 1970, 1971, 1972, 1973, 1974, 1975, 1976, 1977, 1978, 1979, 1980, 1981, 1982, 1983, 1984, 1985, 1986, 1987, 1988, 1989, 1990, 1629, 1260, 883, 498, 105], [391, 780, 1161, 1534, 1899, 2256, 2257, 2258, 2259, 2260, 2261, 2262, 2263, 2264, 2265, 2266, 2267, 2268, 2269, 2270, 2271, 2272, 2273, 2274, 2275, 2276, 2277, 2278, 2279, 2280, 2281, 2282, 2283, 2284, 2285, 2286, 2287, 2288, 2289, 2290, 2291, 2292, 2293, 2294, 2295, 2296, 2297, 2298, 2299, 2300, 2301, 2302, 2303, 2304, 2305, 2306, 2307, 2308, 2309, 2310, 2311, 2312, 2313, 2314, 2315, 2316, 2317, 2318, 2319, 2320, 2321, 2322, 2323, 2324, 2325, 2326, 2327, 2328, 2329, 2330, 2331, 2332, 2333, 2334, 2335, 2336, 2337, 2338, 2339, 2340, 2341, 2342, 2343, 2344, 1991, 1630, 1261, 884, 499, 106], [390, 779, 1160, 1533, 1898, 2255, 2604, 2605, 2606, 2607, 2608, 2609, 2610, 2611, 2612, 2613, 2614, 2615, 2616, 2617, 2618, 2619, 2620, 2621, 2622, 2623, 2624, 2625, 2626, 2627, 2628, 2629, 2630, 2631, 2632, 2633, 2634, 2635, 2636, 2637, 2638, 2639, 2640, 2641, 2642, 2643, 2644, 2645, 2646, 2647, 2648, 2649, 2650, 2651, 2652, 2653, 2654, 2655, 2656, 2657, 2658, 2659, 2660, 2661, 2662, 2663, 2664, 2665, 2666, 2667, 2668, 2669, 2670, 2671, 2672, 2673, 2674, 2675, 2676, 2677, 2678, 2679, 2680, 2681, 2682, 2683, 2684, 2685, 2686, 2687, 2688, 2689, 2690, 2345, 1992, 1631, 1262, 885, 500, 107], [389, 778, 1159, 1532, 1897, 2254, 2603, 2944, 2945, 2946, 2947, 2948, 2949, 2950, 2951, 2952, 2953, 2954, 2955, 2956, 2957, 2958, 2959, 2960, 2961, 2962, 2963, 2964, 2965, 2966, 2967, 2968, 2969, 2970, 2971, 2972, 2973, 2974, 2975, 2976, 2977, 2978, 2979, 2980, 2981, 2982, 2983, 2984, 2985, 2986, 2987, 2988, 2989, 2990, 2991, 2992, 2993, 2994, 2995, 2996, 2997, 2998, 2999, 3000, 3001, 3002, 3003, 3004, 3005, 3006, 3007, 3008, 3009, 3010, 3011, 3012, 3013, 3014, 3015, 3016, 3017, 3018, 3019, 3020, 3021, 3022, 3023, 3024, 3025, 3026, 3027, 3028, 2691, 2346, 1993, 1632, 1263, 886, 501, 108], [388, 777, 1158, 1531, 1896, 2253, 2602, 2943, 3276, 3277, 3278, 3279, 3280, 3281, 3282, 3283, 3284, 3285, 3286, 3287, 3288, 3289, 3290, 3291, 3292, 3293, 3294, 3295, 3296, 3297, 3298, 3299, 3300, 3301, 3302, 3303, 3304, 3305, 3306, 3307, 3308, 3309, 3310, 3311, 3312, 3313, 3314, 3315, 3316, 3317, 3318, 3319, 3320, 3321, 3322, 3323, 3324, 3325, 3326, 3327, 3328, 3329, 3330, 3331, 3332, 3333, 3334, 3335, 3336, 3337, 3338, 3339, 3340, 3341, 3342, 3343, 3344, 3345, 3346, 3347, 3348, 3349, 3350, 3351, 3352, 3353, 3354, 3355, 3356, 3357, 3358, 3029, 2692, 2347, 1994, 1633, 1264, 887, 502, 109], [387, 776, 1157, 1530, 1895, 2252, 2601, 2942, 3275, 3600, 3601, 3602, 3603, 3604, 3605, 3606, 3607, 3608, 3609, 3610, 3611, 3612, 3613, 3614, 3615, 3616, 3617, 3618, 3619, 3620, 3621, 3622, 3623, 3624, 3625, 3626, 3627, 3628, 3629, 3630, 3631, 3632, 3633, 3634, 3635, 3636, 3637, 3638, 3639, 3640, 3641, 3642, 3643, 3644, 3645, 3646, 3647, 3648, 3649, 3650, 3651, 3652, 3653, 3654, 3655, 3656, 3657, 3658, 3659, 3660, 3661, 3662, 3663, 3664, 3665, 3666, 3667, 3668, 3669, 3670, 3671, 3672, 3673, 3674, 3675, 3676, 3677, 3678, 3679, 3680, 3359, 3030, 2693, 2348, 1995, 1634, 1265, 888, 503, 110], [386, 775, 1156, 1529, 1894, 2251, 2600, 2941, 3274, 3599, 3916, 3917, 3918, 3919, 3920, 3921, 3922, 3923, 3924, 3925, 3926, 3927, 3928, 3929, 3930, 3931, 3932, 3933, 3934, 3935, 3936, 3937, 3938, 3939, 3940, 3941, 3942, 3943, 3944, 3945, 3946, 3947, 3948, 3949, 3950, 3951, 3952, 3953, 3954, 3955, 3956, 3957, 3958, 3959, 3960, 3961, 3962, 3963, 3964, 3965, 3966, 3967, 3968, 3969, 3970, 3971, 3972, 3973, 3974, 3975, 3976, 3977, 3978, 3979, 3980, 3981, 3982, 3983, 3984, 3985, 3986, 3987, 3988, 3989, 3990, 3991, 3992, 3993, 3994, 3681, 3360, 3031, 2694, 2349, 1996, 1635, 1266, 889, 504, 111], [385, 774, 1155, 1528, 1893, 2250, 2599, 2940, 3273, 3598, 3915, 4224, 4225, 4226, 4227, 4228, 4229, 4230, 4231, 4232, 4233, 4234, 4235, 4236, 4237, 4238, 4239, 4240, 4241, 4242, 4243, 4244, 4245, 4246, 4247, 4248, 4249, 4250, 4251, 4252, 4253, 4254, 4255, 4256, 4257, 4258, 4259, 4260, 4261, 4262, 4263, 4264, 4265, 4266, 4267, 4268, 4269, 4270, 4271, 4272, 4273, 4274, 4275, 4276, 4277, 4278, 4279, 4280, 4281, 4282, 4283, 4284, 4285, 4286, 4287, 4288, 4289, 4290, 4291, 4292, 4293, 4294, 4295, 4296, 4297, 4298, 4299, 4300, 3995, 3682, 3361, 3032, 2695, 2350, 1997, 1636, 1267, 890, 505, 112], [384, 773, 1154, 1527, 1892, 2249, 2598, 2939, 3272, 3597, 3914, 4223, 4524, 4525, 4526, 4527, 4528, 4529, 4530, 4531, 4532, 4533, 4534, 4535, 4536, 4537, 4538, 4539, 4540, 4541, 4542, 4543, 4544, 4545, 4546, 4547, 4548, 4549, 4550, 4551, 4552, 4553, 4554, 4555, 4556, 4557, 4558, 4559, 4560, 4561, 4562, 4563, 4564, 4565, 4566, 4567, 4568, 4569, 4570, 4571, 4572, 4573, 4574, 4575, 4576, 4577, 4578, 4579, 4580, 4581, 4582, 4583, 4584, 4585, 4586, 4587, 4588, 4589, 4590, 4591, 4592, 4593, 4594, 4595, 4596, 4597, 4598, 4301, 3996, 3683, 3362, 3033, 2696, 2351, 1998, 1637, 1268, 891, 506, 113], [383, 772, 1153, 1526, 1891, 2248, 2597, 2938, 3271, 3596, 3913, 4222, 4523, 4816, 4817, 4818, 4819, 4820, 4821, 4822, 4823, 4824, 4825, 4826, 4827, 4828, 4829, 4830, 4831, 4832, 4833, 4834, 4835, 4836, 4837, 4838, 4839, 4840, 4841, 4842, 4843, 4844, 4845, 4846, 4847, 4848, 4849, 4850, 4851, 4852, 4853, 4854, 4855, 4856, 4857, 4858, 4859, 4860, 4861, 4862, 4863, 4864, 4865, 4866, 4867, 4868, 4869, 4870, 4871, 4872, 4873, 4874, 4875, 4876, 4877, 4878, 4879, 4880, 4881, 4882, 4883, 4884, 4885, 4886, 4887, 4888, 4599, 4302, 3997, 3684, 3363, 3034, 2697, 2352, 1999, 1638, 1269, 892, 507, 114], [382, 771, 1152, 1525, 1890, 2247, 2596, 2937, 3270, 3595, 3912, 4221, 4522, 4815, 5100, 5101, 5102, 5103, 5104, 5105, 5106, 5107, 5108, 5109, 5110, 5111, 5112, 5113, 5114, 5115, 5116, 5117, 5118, 5119, 5120, 5121, 5122, 5123, 5124, 5125, 5126, 5127, 5128, 5129, 5130, 5131, 5132, 5133, 5134, 5135, 5136, 5137, 5138, 5139, 5140, 5141, 5142, 5143, 5144, 5145, 5146, 5147, 5148, 5149, 5150, 5151, 5152, 5153, 5154, 5155, 5156, 5157, 5158, 5159, 5160, 5161, 5162, 5163, 5164, 5165, 5166, 5167, 5168, 5169, 5170, 4889, 4600, 4303, 3998, 3685, 3364, 3035, 2698, 2353, 2000, 1639, 1270, 893, 508, 115], [381, 770, 1151, 1524, 1889, 2246, 2595, 2936, 3269, 3594, 3911, 4220, 4521, 4814, 5099, 5376, 5377, 5378, 5379, 5380, 5381, 5382, 5383, 5384, 5385, 5386, 5387, 5388, 5389, 5390, 5391, 5392, 5393, 5394, 5395, 5396, 5397, 5398, 5399, 5400, 5401, 5402, 5403, 5404, 5405, 5406, 5407, 5408, 5409, 5410, 5411, 5412, 5413, 5414, 5415, 5416, 5417, 5418, 5419, 5420, 5421, 5422, 5423, 5424, 5425, 5426, 5427, 5428, 5429, 5430, 5431, 5432, 5433, 5434, 5435, 5436, 5437, 5438, 5439, 5440, 5441, 5442, 5443, 5444, 5171, 4890, 4601, 4304, 3999, 3686, 3365, 3036, 2699, 2354, 2001, 1640, 1271, 894, 509, 116], [380, 769, 1150, 1523, 1888, 2245, 2594, 2935, 3268, 3593, 3910, 4219, 4520, 4813, 5098, 5375, 5644, 5645, 5646, 5647, 5648, 5649, 5650, 5651, 5652, 5653, 5654, 5655, 5656, 5657, 5658, 5659, 5660, 5661, 5662, 5663, 5664, 5665, 5666, 5667, 5668, 5669, 5670, 5671, 5672, 5673, 5674, 5675, 5676, 5677, 5678, 5679, 5680, 5681, 5682, 5683, 5684, 5685, 5686, 5687, 5688, 5689, 5690, 5691, 5692, 5693, 5694, 5695, 5696, 5697, 5698, 5699, 5700, 5701, 5702, 5703, 5704, 5705, 5706, 5707, 5708, 5709, 5710, 5445, 5172, 4891, 4602, 4305, 4000, 3687, 3366, 3037, 2700, 2355, 2002, 1641, 1272, 895, 510, 117], [379, 768, 1149, 1522, 1887, 2244, 2593, 2934, 3267, 3592, 3909, 4218, 4519, 4812, 5097, 5374, 5643, 5904, 5905, 5906, 5907, 5908, 5909, 5910, 5911, 5912, 5913, 5914, 5915, 5916, 5917, 5918, 5919, 5920, 5921, 5922, 5923, 5924, 5925, 5926, 5927, 5928, 5929, 5930, 5931, 5932, 5933, 5934, 5935, 5936, 5937, 5938, 5939, 5940, 5941, 5942, 5943, 5944, 5945, 5946, 5947, 5948, 5949, 5950, 5951, 5952, 5953, 5954, 5955, 5956, 5957, 5958, 5959, 5960, 5961, 5962, 5963, 5964, 5965, 5966, 5967, 5968, 5711, 5446, 5173, 4892, 4603, 4306, 4001, 3688, 3367, 3038, 2701, 2356, 2003, 1642, 1273, 896, 511, 118], [378, 767, 1148, 1521, 1886, 2243, 2592, 2933, 3266, 3591, 3908, 4217, 4518, 4811, 5096, 5373, 5642, 5903, 6156, 6157, 6158, 6159, 6160, 6161, 6162, 6163, 6164, 6165, 6166, 6167, 6168, 6169, 6170, 6171, 6172, 6173, 6174, 6175, 6176, 6177, 6178, 6179, 6180, 6181, 6182, 6183, 6184, 6185, 6186, 6187, 6188, 6189, 6190, 6191, 6192, 6193, 6194, 6195, 6196, 6197, 6198, 6199, 6200, 6201, 6202, 6203, 6204, 6205, 6206, 6207, 6208, 6209, 6210, 6211, 6212, 6213, 6214, 6215, 6216, 6217, 6218, 5969, 5712, 5447, 5174, 4893, 4604, 4307, 4002, 3689, 3368, 3039, 2702, 2357, 2004, 1643, 1274, 897, 512, 119], [377, 766, 1147, 1520, 1885, 2242, 2591, 2932, 3265, 3590, 3907, 4216, 4517, 4810, 5095, 5372, 5641, 5902, 6155, 6400, 6401, 6402, 6403, 6404, 6405, 6406, 6407, 6408, 6409, 6410, 6411, 6412, 6413, 6414, 6415, 6416, 6417, 6418, 6419, 6420, 6421, 6422, 6423, 6424, 6425, 6426, 6427, 6428, 6429, 6430, 6431, 6432, 6433, 6434, 6435, 6436, 6437, 6438, 6439, 6440, 6441, 6442, 6443, 6444, 6445, 6446, 6447, 6448, 6449, 6450, 6451, 6452, 6453, 6454, 6455, 6456, 6457, 6458, 6459, 6460, 6219, 5970, 5713, 5448, 5175, 4894, 4605, 4308, 4003, 3690, 3369, 3040, 2703, 2358, 2005, 1644, 1275, 898, 513, 120], [376, 765, 1146, 1519, 1884, 2241, 2590, 2931, 3264, 3589, 3906, 4215, 4516, 4809, 5094, 5371, 5640, 5901, 6154, 6399, 6636, 6637, 6638, 6639, 6640, 6641, 6642, 6643, 6644, 6645, 6646, 6647, 6648, 6649, 6650, 6651, 6652, 6653, 6654, 6655, 6656, 6657, 6658, 6659, 6660, 6661, 6662, 6663, 6664, 6665, 6666, 6667, 6668, 6669, 6670, 6671, 6672, 6673, 6674, 6675, 6676, 6677, 6678, 6679, 6680, 6681, 6682, 6683, 6684, 6685, 6686, 6687, 6688, 6689, 6690, 6691, 6692, 6693, 6694, 6461, 6220, 5971, 5714, 5449, 5176, 4895, 4606, 4309, 4004, 3691, 3370, 3041, 2704, 2359, 2006, 1645, 1276, 899, 514, 121], [375, 764, 1145, 1518, 1883, 2240, 2589, 2930, 3263, 3588, 3905, 4214, 4515, 4808, 5093, 5370, 5639, 5900, 6153, 6398, 6635, 6864, 6865, 6866, 6867, 6868, 6869, 6870, 6871, 6872, 6873, 6874, 6875, 6876, 6877, 6878, 6879, 6880, 6881, 6882, 6883, 6884, 6885, 6886, 6887, 6888, 6889, 6890, 6891, 6892, 6893, 6894, 6895, 6896, 6897, 6898, 6899, 6900, 6901, 6902, 6903, 6904, 6905, 6906, 6907, 6908, 6909, 6910, 6911, 6912, 6913, 6914, 6915, 6916, 6917, 6918, 6919, 6920, 6695, 6462, 6221, 5972, 5715, 5450, 5177, 4896, 4607, 4310, 4005, 3692, 3371, 3042, 2705, 2360, 2007, 1646, 1277, 900, 515, 122], [374, 763, 1144, 1517, 1882, 2239, 2588, 2929, 3262, 3587, 3904, 4213, 4514, 4807, 5092, 5369, 5638, 5899, 6152, 6397, 6634, 6863, 7084, 7085, 7086, 7087, 7088, 7089, 7090, 7091, 7092, 7093, 7094, 7095, 7096, 7097, 7098, 7099, 7100, 7101, 7102, 7103, 7104, 7105, 7106, 7107, 7108, 7109, 7110, 7111, 7112, 7113, 7114, 7115, 7116, 7117, 7118, 7119, 7120, 7121, 7122, 7123, 7124, 7125, 7126, 7127, 7128, 7129, 7130, 7131, 7132, 7133, 7134, 7135, 7136, 7137, 7138, 6921, 6696, 6463, 6222, 5973, 5716, 5451, 5178, 4897, 4608, 4311, 4006, 3693, 3372, 3043, 2706, 2361, 2008, 1647, 1278, 901, 516, 123], [373, 762, 1143, 1516, 1881, 2238, 2587, 2928, 3261, 3586, 3903, 4212, 4513, 4806, 5091, 5368, 5637, 5898, 6151, 6396, 6633, 6862, 7083, 7296, 7297, 7298, 7299, 7300, 7301, 7302, 7303, 7304, 7305, 7306, 7307, 7308, 7309, 7310, 7311, 7312, 7313, 7314, 7315, 7316, 7317, 7318, 7319, 7320, 7321, 7322, 7323, 7324, 7325, 7326, 7327, 7328, 7329, 7330, 7331, 7332, 7333, 7334, 7335, 7336, 7337, 7338, 7339, 7340, 7341, 7342, 7343, 7344, 7345, 7346, 7347, 7348, 7139, 6922, 6697, 6464, 6223, 5974, 5717, 5452, 5179, 4898, 4609, 4312, 4007, 3694, 3373, 3044, 2707, 2362, 2009, 1648, 1279, 902, 517, 124], [372, 761, 1142, 1515, 1880, 2237, 2586, 2927, 3260, 3585, 3902, 4211, 4512, 4805, 5090, 5367, 5636, 5897, 6150, 6395, 6632, 6861, 7082, 7295, 7500, 7501, 7502, 7503, 7504, 7505, 7506, 7507, 7508, 7509, 7510, 7511, 7512, 7513, 7514, 7515, 7516, 7517, 7518, 7519, 7520, 7521, 7522, 7523, 7524, 7525, 7526, 7527, 7528, 7529, 7530, 7531, 7532, 7533, 7534, 7535, 7536, 7537, 7538, 7539, 7540, 7541, 7542, 7543, 7544, 7545, 7546, 7547, 7548, 7549, 7550, 7349, 7140, 6923, 6698, 6465, 6224, 5975, 5718, 5453, 5180, 4899, 4610, 4313, 4008, 3695, 3374, 3045, 2708, 2363, 2010, 1649, 1280, 903, 518, 125], [371, 760, 1141, 1514, 1879, 2236, 2585, 2926, 3259, 3584, 3901, 4210, 4511, 4804, 5089, 5366, 5635, 5896, 6149, 6394, 6631, 6860, 7081, 7294, 7499, 7696, 7697, 7698, 7699, 7700, 7701, 7702, 7703, 7704, 7705, 7706, 7707, 7708, 7709, 7710, 7711, 7712, 7713, 7714, 7715, 7716, 7717, 7718, 7719, 7720, 7721, 7722, 7723, 7724, 7725, 7726, 7727, 7728, 7729, 7730, 7731, 7732, 7733, 7734, 7735, 7736, 7737, 7738, 7739, 7740, 7741, 7742, 7743, 7744, 7551, 7350, 7141, 6924, 6699, 6466, 6225, 5976, 5719, 5454, 5181, 4900, 4611, 4314, 4009, 3696, 3375, 3046, 2709, 2364, 2011, 1650, 1281, 904, 519, 126], [370, 759, 1140, 1513, 1878, 2235, 2584, 2925, 3258, 3583, 3900, 4209, 4510, 4803, 5088, 5365, 5634, 5895, 6148, 6393, 6630, 6859, 7080, 7293, 7498, 7695, 7884, 7885, 7886, 7887, 7888, 7889, 7890, 7891, 7892, 7893, 7894, 7895, 7896, 7897, 7898, 7899, 7900, 7901, 7902, 7903, 7904, 7905, 7906, 7907, 7908, 7909, 7910, 7911, 7912, 7913, 7914, 7915, 7916, 7917, 7918, 7919, 7920, 7921, 7922, 7923, 7924, 7925, 7926, 7927, 7928, 7929, 7930, 7745, 7552, 7351, 7142, 6925, 6700, 6467, 6226, 5977, 5720, 5455, 5182, 4901, 4612, 4315, 4010, 3697, 3376, 3047, 2710, 2365, 2012, 1651, 1282, 905, 520, 127], [369, 758, 1139, 1512, 1877, 2234, 2583, 2924, 3257, 3582, 3899, 4208, 4509, 4802, 5087, 5364, 5633, 5894, 6147, 6392, 6629, 6858, 7079, 7292, 7497, 7694, 7883, 8064, 8065, 8066, 8067, 8068, 8069, 8070, 8071, 8072, 8073, 8074, 8075, 8076, 8077, 8078, 8079, 8080, 8081, 8082, 8083, 8084, 8085, 8086, 8087, 8088, 8089, 8090, 8091, 8092, 8093, 8094, 8095, 8096, 8097, 8098, 8099, 8100, 8101, 8102, 8103, 8104, 8105, 8106, 8107, 8108, 7931, 7746, 7553, 7352, 7143, 6926, 6701, 6468, 6227, 5978, 5721, 5456, 5183, 4902, 4613, 4316, 4011, 3698, 3377, 3048, 2711, 2366, 2013, 1652, 1283, 906, 521, 128], [368, 757, 1138, 1511, 1876, 2233, 2582, 2923, 3256, 3581, 3898, 4207, 4508, 4801, 5086, 5363, 5632, 5893, 6146, 6391, 6628, 6857, 7078, 7291, 7496, 7693, 7882, 8063, 8236, 8237, 8238, 8239, 8240, 8241, 8242, 8243, 8244, 8245, 8246, 8247, 8248, 8249, 8250, 8251, 8252, 8253, 8254, 8255, 8256, 8257, 8258, 8259, 8260, 8261, 8262, 8263, 8264, 8265, 8266, 8267, 8268, 8269, 8270, 8271, 8272, 8273, 8274, 8275, 8276, 8277, 8278, 8109, 7932, 7747, 7554, 7353, 7144, 6927, 6702, 6469, 6228, 5979, 5722, 5457, 5184, 4903, 4614, 4317, 4012, 3699, 3378, 3049, 2712, 2367, 2014, 1653, 1284, 907, 522, 129], [367, 756, 1137, 1510, 1875, 2232, 2581, 2922, 3255, 3580, 3897, 4206, 4507, 4800, 5085, 5362, 5631, 5892, 6145, 6390, 6627, 6856, 7077, 7290, 7495, 7692, 7881, 8062, 8235, 8400, 8401, 8402, 8403, 8404, 8405, 8406, 8407, 8408, 8409, 8410, 8411, 8412, 8413, 8414, 8415, 8416, 8417, 8418, 8419, 8420, 8421, 8422, 8423, 8424, 8425, 8426, 8427, 8428, 8429, 8430, 8431, 8432, 8433, 8434, 8435, 8436, 8437, 8438, 8439, 8440, 8279, 8110, 7933, 7748, 7555, 7354, 7145, 6928, 6703, 6470, 6229, 5980, 5723, 5458, 5185, 4904, 4615, 4318, 4013, 3700, 3379, 3050, 2713, 2368, 2015, 1654, 1285, 908, 523, 130], [366, 755, 1136, 1509, 1874, 2231, 2580, 2921, 3254, 3579, 3896, 4205, 4506, 4799, 5084, 5361, 5630, 5891, 6144, 6389, 6626, 6855, 7076, 7289, 7494, 7691, 7880, 8061, 8234, 8399, 8556, 8557, 8558, 8559, 8560, 8561, 8562, 8563, 8564, 8565, 8566, 8567, 8568, 8569, 8570, 8571, 8572, 8573, 8574, 8575, 8576, 8577, 8578, 8579, 8580, 8581, 8582, 8583, 8584, 8585, 8586, 8587, 8588, 8589, 8590, 8591, 8592, 8593, 8594, 8441, 8280, 8111, 7934, 7749, 7556, 7355, 7146, 6929, 6704, 6471, 6230, 5981, 5724, 5459, 5186, 4905, 4616, 4319, 4014, 3701, 3380, 3051, 2714, 2369, 2016, 1655, 1286, 909, 524, 131], [365, 754, 1135, 1508, 1873, 2230, 2579, 2920, 3253, 3578, 3895, 4204, 4505, 4798, 5083, 5360, 5629, 5890, 6143, 6388, 6625, 6854, 7075, 7288, 7493, 7690, 7879, 8060, 8233, 8398, 8555, 8704, 8705, 8706, 8707, 8708, 8709, 8710, 8711, 8712, 8713, 8714, 8715, 8716, 8717, 8718, 8719, 8720, 8721, 8722, 8723, 8724, 8725, 8726, 8727, 8728, 8729, 8730, 8731, 8732, 8733, 8734, 8735, 8736, 8737, 8738, 8739, 8740, 8595, 8442, 8281, 8112, 7935, 7750, 7557, 7356, 7147, 6930, 6705, 6472, 6231, 5982, 5725, 5460, 5187, 4906, 4617, 4320, 4015, 3702, 3381, 3052, 2715, 2370, 2017, 1656, 1287, 910, 525, 132], [364, 753, 1134, 1507, 1872, 2229, 2578, 2919, 3252, 3577, 3894, 4203, 4504, 4797, 5082, 5359, 5628, 5889, 6142, 6387, 6624, 6853, 7074, 7287, 7492, 7689, 7878, 8059, 8232, 8397, 8554, 8703, 8844, 8845, 8846, 8847, 8848, 8849, 8850, 8851, 8852, 8853, 8854, 8855, 8856, 8857, 8858, 8859, 8860, 8861, 8862, 8863, 8864, 8865, 8866, 8867, 8868, 8869, 8870, 8871, 8872, 8873, 8874, 8875, 8876, 8877, 8878, 8741, 8596, 8443, 8282, 8113, 7936, 7751, 7558, 7357, 7148, 6931, 6706, 6473, 6232, 5983, 5726, 5461, 5188, 4907, 4618, 4321, 4016, 3703, 3382, 3053, 2716, 2371, 2018, 1657, 1288, 911, 526, 133], [363, 752, 1133, 1506, 1871, 2228, 2577, 2918, 3251, 3576, 3893, 4202, 4503, 4796, 5081, 5358, 5627, 5888, 6141, 6386, 6623, 6852, 7073, 7286, 7491, 7688, 7877, 8058, 8231, 8396, 8553, 8702, 8843, 8976, 8977, 8978, 8979, 8980, 8981, 8982, 8983, 8984, 8985, 8986, 8987, 8988, 8989, 8990, 8991, 8992, 8993, 8994, 8995, 8996, 8997, 8998, 8999, 9000, 9001, 9002, 9003, 9004, 9005, 9006, 9007, 9008, 8879, 8742, 8597, 8444, 8283, 8114, 7937, 7752, 7559, 7358, 7149, 6932, 6707, 6474, 6233, 5984, 5727, 5462, 5189, 4908, 4619, 4322, 4017, 3704, 3383, 3054, 2717, 2372, 2019, 1658, 1289, 912, 527, 134], [362, 751, 1132, 1505, 1870, 2227, 2576, 2917, 3250, 3575, 3892, 4201, 4502, 4795, 5080, 5357, 5626, 5887, 6140, 6385, 6622, 6851, 7072, 7285, 7490, 7687, 7876, 8057, 8230, 8395, 8552, 8701, 8842, 8975, 9100, 9101, 9102, 9103, 9104, 9105, 9106, 9107, 9108, 9109, 9110, 9111, 9112, 9113, 9114, 9115, 9116, 9117, 9118, 9119, 9120, 9121, 9122, 9123, 9124, 9125, 9126, 9127, 9128, 9129, 9130, 9009, 8880, 8743, 8598, 8445, 8284, 8115, 7938, 7753, 7560, 7359, 7150, 6933, 6708, 6475, 6234, 5985, 5728, 5463, 5190, 4909, 4620, 4323, 4018, 3705, 3384, 3055, 2718, 2373, 2020, 1659, 1290, 913, 528, 135], [361, 750, 1131, 1504, 1869, 2226, 2575, 2916, 3249, 3574, 3891, 4200, 4501, 4794, 5079, 5356, 5625, 5886, 6139, 6384, 6621, 6850, 7071, 7284, 7489, 7686, 7875, 8056, 8229, 8394, 8551, 8700, 8841, 8974, 9099, 9216, 9217, 9218, 9219, 9220, 9221, 9222, 9223, 9224, 9225, 9226, 9227, 9228, 9229, 9230, 9231, 9232, 9233, 9234, 9235, 9236, 9237, 9238, 9239, 9240, 9241, 9242, 9243, 9244, 9131, 9010, 8881, 8744, 8599, 8446, 8285, 8116, 7939, 7754, 7561, 7360, 7151, 6934, 6709, 6476, 6235, 5986, 5729, 5464, 5191, 4910, 4621, 4324, 4019, 3706, 3385, 3056, 2719, 2374, 2021, 1660, 1291, 914, 529, 136], [360, 749, 1130, 1503, 1868, 2225, 2574, 2915, 3248, 3573, 3890, 4199, 4500, 4793, 5078, 5355, 5624, 5885, 6138, 6383, 6620, 6849, 7070, 7283, 7488, 7685, 7874, 8055, 8228, 8393, 8550, 8699, 8840, 8973, 9098, 9215, 9324, 9325, 9326, 9327, 9328, 9329, 9330, 9331, 9332, 9333, 9334, 9335, 9336, 9337, 9338, 9339, 9340, 9341, 9342, 9343, 9344, 9345, 9346, 9347, 9348, 9349, 9350, 9245, 9132, 9011, 8882, 8745, 8600, 8447, 8286, 8117, 7940, 7755, 7562, 7361, 7152, 6935, 6710, 6477, 6236, 5987, 5730, 5465, 5192, 4911, 4622, 4325, 4020, 3707, 3386, 3057, 2720, 2375, 2022, 1661, 1292, 915, 530, 137], [359, 748, 1129, 1502, 1867, 2224, 2573, 2914, 3247, 3572, 3889, 4198, 4499, 4792, 5077, 5354, 5623, 5884, 6137, 6382, 6619, 6848, 7069, 7282, 7487, 7684, 7873, 8054, 8227, 8392, 8549, 8698, 8839, 8972, 9097, 9214, 9323, 9424, 9425, 9426, 9427, 9428, 9429, 9430, 9431, 9432, 9433, 9434, 9435, 9436, 9437, 9438, 9439, 9440, 9441, 9442, 9443, 9444, 9445, 9446, 9447, 9448, 9351, 9246, 9133, 9012, 8883, 8746, 8601, 8448, 8287, 8118, 7941, 7756, 7563, 7362, 7153, 6936, 6711, 6478, 6237, 5988, 5731, 5466, 5193, 4912, 4623, 4326, 4021, 3708, 3387, 3058, 2721, 2376, 2023, 1662, 1293, 916, 531, 138], [358, 747, 1128, 1501, 1866, 2223, 2572, 2913, 3246, 3571, 3888, 4197, 4498, 4791, 5076, 5353, 5622, 5883, 6136, 6381, 6618, 6847, 7068, 7281, 7486, 7683, 7872, 8053, 8226, 8391, 8548, 8697, 8838, 8971, 9096, 9213, 9322, 9423, 9516, 9517, 9518, 9519, 9520, 9521, 9522, 9523, 9524, 9525, 9526, 9527, 9528, 9529, 9530, 9531, 9532, 9533, 9534, 9535, 9536, 9537, 9538, 9449, 9352, 9247, 9134, 9013, 8884, 8747, 8602, 8449, 8288, 8119, 7942, 7757, 7564, 7363, 7154, 6937, 6712, 6479, 6238, 5989, 5732, 5467, 5194, 4913, 4624, 4327, 4022, 3709, 3388, 3059, 2722, 2377, 2024, 1663, 1294, 917, 532, 139], [357, 746, 1127, 1500, 1865, 2222, 2571, 2912, 3245, 3570, 3887, 4196, 4497, 4790, 5075, 5352, 5621, 5882, 6135, 6380, 6617, 6846, 7067, 7280, 7485, 7682, 7871, 8052, 8225, 8390, 8547, 8696, 8837, 8970, 9095, 9212, 9321, 9422, 9515, 9600, 9601, 9602, 9603, 9604, 9605, 9606, 9607, 9608, 9609, 9610, 9611, 9612, 9613, 9614, 9615, 9616, 9617, 9618, 9619, 9620, 9539, 9450, 9353, 9248, 9135, 9014, 8885, 8748, 8603, 8450, 8289, 8120, 7943, 7758, 7565, 7364, 7155, 6938, 6713, 6480, 6239, 5990, 5733, 5468, 5195, 4914, 4625, 4328, 4023, 3710, 3389, 3060, 2723, 2378, 2025, 1664, 1295, 918, 533, 140], [356, 745, 1126, 1499, 1864, 2221, 2570, 2911, 3244, 3569, 3886, 4195, 4496, 4789, 5074, 5351, 5620, 5881, 6134, 6379, 6616, 6845, 7066, 7279, 7484, 7681, 7870, 8051, 8224, 8389, 8546, 8695, 8836, 8969, 9094, 9211, 9320, 9421, 9514, 9599, 9676, 9677, 9678, 9679, 9680, 9681, 9682, 9683, 9684, 9685, 9686, 9687, 9688, 9689, 9690, 9691, 9692, 9693, 9694, 9621, 9540, 9451, 9354, 9249, 9136, 9015, 8886, 8749, 8604, 8451, 8290, 8121, 7944, 7759, 7566, 7365, 7156, 6939, 6714, 6481, 6240, 5991, 5734, 5469, 5196, 4915, 4626, 4329, 4024, 3711, 3390, 3061, 2724, 2379, 2026, 1665, 1296, 919, 534, 141], [355, 744, 1125, 1498, 1863, 2220, 2569, 2910, 3243, 3568, 3885, 4194, 4495, 4788, 5073, 5350, 5619, 5880, 6133, 6378, 6615, 6844, 7065, 7278, 7483, 7680, 7869, 8050, 8223, 8388, 8545, 8694, 8835, 8968, 9093, 9210, 9319, 9420, 9513, 9598, 9675, 9744, 9745, 9746, 9747, 9748, 9749, 9750, 9751, 9752, 9753, 9754, 9755, 9756, 9757, 9758, 9759, 9760, 9695, 9622, 9541, 9452, 9355, 9250, 9137, 9016, 8887, 8750, 8605, 8452, 8291, 8122, 7945, 7760, 7567, 7366, 7157, 6940, 6715, 6482, 6241, 5992, 5735, 5470, 5197, 4916, 4627, 4330, 4025, 3712, 3391, 3062, 2725, 2380, 2027, 1666, 1297, 920, 535, 142], [354, 743, 1124, 1497, 1862, 2219, 2568, 2909, 3242, 3567, 3884, 4193, 4494, 4787, 5072, 5349, 5618, 5879, 6132, 6377, 6614, 6843, 7064, 7277, 7482, 7679, 7868, 8049, 8222, 8387, 8544, 8693, 8834, 8967, 9092, 9209, 9318, 9419, 9512, 9597, 9674, 9743, 9804, 9805, 9806, 9807, 9808, 9809, 9810, 9811, 9812, 9813, 9814, 9815, 9816, 9817, 9818, 9761, 9696, 9623, 9542, 9453, 9356, 9251, 9138, 9017, 8888, 8751, 8606, 8453, 8292, 8123, 7946, 7761, 7568, 7367, 7158, 6941, 6716, 6483, 6242, 5993, 5736, 5471, 5198, 4917, 4628, 4331, 4026, 3713, 3392, 3063, 2726, 2381, 2028, 1667, 1298, 921, 536, 143], [353, 742, 1123, 1496, 1861, 2218, 2567, 2908, 3241, 3566, 3883, 4192, 4493, 4786, 5071, 5348, 5617, 5878, 6131, 6376, 6613, 6842, 7063, 7276, 7481, 7678, 7867, 8048, 8221, 8386, 8543, 8692, 8833, 8966, 9091, 9208, 9317, 9418, 9511, 9596, 9673, 9742, 9803, 9856, 9857, 9858, 9859, 9860, 9861, 9862, 9863, 9864, 9865, 9866, 9867, 9868, 9819, 9762, 9697, 9624, 9543, 9454, 9357, 9252, 9139, 9018, 8889, 8752, 8607, 8454, 8293, 8124, 7947, 7762, 7569, 7368, 7159, 6942, 6717, 6484, 6243, 5994, 5737, 5472, 5199, 4918, 4629, 4332, 4027, 3714, 3393, 3064, 2727, 2382, 2029, 1668, 1299, 922, 537, 144], [352, 741, 1122, 1495, 1860, 2217, 2566, 2907, 3240, 3565, 3882, 4191, 4492, 4785, 5070, 5347, 5616, 5877, 6130, 6375, 6612, 6841, 7062, 7275, 7480, 7677, 7866, 8047, 8220, 8385, 8542, 8691, 8832, 8965, 9090, 9207, 9316, 9417, 9510, 9595, 9672, 9741, 9802, 9855, 9900, 9901, 9902, 9903, 9904, 9905, 9906, 9907, 9908, 9909, 9910, 9869, 9820, 9763, 9698, 9625, 9544, 9455, 9358, 9253, 9140, 9019, 8890, 8753, 8608, 8455, 8294, 8125, 7948, 7763, 7570, 7369, 7160, 6943, 6718, 6485, 6244, 5995, 5738, 5473, 5200, 4919, 4630, 4333, 4028, 3715, 3394, 3065, 2728, 2383, 2030, 1669, 1300, 923, 538, 145], [351, 740, 1121, 1494, 1859, 2216, 2565, 2906, 3239, 3564, 3881, 4190, 4491, 4784, 5069, 5346, 5615, 5876, 6129, 6374, 6611, 6840, 7061, 7274, 7479, 7676, 7865, 8046, 8219, 8384, 8541, 8690, 8831, 8964, 9089, 9206, 9315, 9416, 9509, 9594, 9671, 9740, 9801, 9854, 9899, 9936, 9937, 9938, 9939, 9940, 9941, 9942, 9943, 9944, 9911, 9870, 9821, 9764, 9699, 9626, 9545, 9456, 9359, 9254, 9141, 9020, 8891, 8754, 8609, 8456, 8295, 8126, 7949, 7764, 7571, 7370, 7161, 6944, 6719, 6486, 6245, 5996, 5739, 5474, 5201, 4920, 4631, 4334, 4029, 3716, 3395, 3066, 2729, 2384, 2031, 1670, 1301, 924, 539, 146], [350, 739, 1120, 1493, 1858, 2215, 2564, 2905, 3238, 3563, 3880, 4189, 4490, 4783, 5068, 5345, 5614, 5875, 6128, 6373, 6610, 6839, 7060, 7273, 7478, 7675, 7864, 8045, 8218, 8383, 8540, 8689, 8830, 8963, 9088, 9205, 9314, 9415, 9508, 9593, 9670, 9739, 9800, 9853, 9898, 9935, 9964, 9965, 9966, 9967, 9968, 9969, 9970, 9945, 9912, 9871, 9822, 9765, 9700, 9627, 9546, 9457, 9360, 9255, 9142, 9021, 8892, 8755, 8610, 8457, 8296, 8127, 7950, 7765, 7572, 7371, 7162, 6945, 6720, 6487, 6246, 5997, 5740, 5475, 5202, 4921, 4632, 4335, 4030, 3717, 3396, 3067, 2730, 2385, 2032, 1671, 1302, 925, 540, 147], [349, 738, 1119, 1492, 1857, 2214, 2563, 2904, 3237, 3562, 3879, 4188, 4489, 4782, 5067, 5344, 5613, 5874, 6127, 6372, 6609, 6838, 7059, 7272, 7477, 7674, 7863, 8044, 8217, 8382, 8539, 8688, 8829, 8962, 9087, 9204, 9313, 9414, 9507, 9592, 9669, 9738, 9799, 9852, 9897, 9934, 9963, 9984, 9985, 9986, 9987, 9988, 9971, 9946, 9913, 9872, 9823, 9766, 9701, 9628, 9547, 9458, 9361, 9256, 9143, 9022, 8893, 8756, 8611, 8458, 8297, 8128, 7951, 7766, 7573, 7372, 7163, 6946, 6721, 6488, 6247, 5998, 5741, 5476, 5203, 4922, 4633, 4336, 4031, 3718, 3397, 3068, 2731, 2386, 2033, 1672, 1303, 926, 541, 148], [348, 737, 1118, 1491, 1856, 2213, 2562, 2903, 3236, 3561, 3878, 4187, 4488, 4781, 5066, 5343, 5612, 5873, 6126, 6371, 6608, 6837, 7058, 7271, 7476, 7673, 7862, 8043, 8216, 8381, 8538, 8687, 8828, 8961, 9086, 9203, 9312, 9413, 9506, 9591, 9668, 9737, 9798, 9851, 9896, 9933, 9962, 9983, 9996, 9997, 9998, 9989, 9972, 9947, 9914, 9873, 9824, 9767, 9702, 9629, 9548, 9459, 9362, 9257, 9144, 9023, 8894, 8757, 8612, 8459, 8298, 8129, 7952, 7767, 7574, 7373, 7164, 6947, 6722, 6489, 6248, 5999, 5742, 5477, 5204, 4923, 4634, 4337, 4032, 3719, 3398, 3069, 2732, 2387, 2034, 1673, 1304, 927, 542, 149], [347, 736, 1117, 1490, 1855, 2212, 2561, 2902, 3235, 3560, 3877, 4186, 4487, 4780, 5065, 5342, 5611, 5872, 6125, 6370, 6607, 6836, 7057, 7270, 7475, 7672, 7861, 8042, 8215, 8380, 8537, 8686, 8827, 8960, 9085, 9202, 9311, 9412, 9505, 9590, 9667, 9736, 9797, 9850, 9895, 9932, 9961, 9982, 9995, 10000, 9999, 9990, 9973, 9948, 9915, 9874, 9825, 9768, 9703, 9630, 9549, 9460, 9363, 9258, 9145, 9024, 8895, 8758, 8613, 8460, 8299, 8130, 7953, 7768, 7575, 7374, 7165, 6948, 6723, 6490, 6249, 6000, 5743, 5478, 5205, 4924, 4635, 4338, 4033, 3720, 3399, 3070, 2733, 2388, 2035, 1674, 1305, 928, 543, 150], [346, 735, 1116, 1489, 1854, 2211, 2560, 2901, 3234, 3559, 3876, 4185, 4486, 4779, 5064, 5341, 5610, 5871, 6124, 6369, 6606, 6835, 7056, 7269, 7474, 7671, 7860, 8041, 8214, 8379, 8536, 8685, 8826, 8959, 9084, 9201, 9310, 9411, 9504, 9589, 9666, 9735, 9796, 9849, 9894, 9931, 9960, 9981, 9994, 9993, 9992, 9991, 9974, 9949, 9916, 9875, 9826, 9769, 9704, 9631, 9550, 9461, 9364, 9259, 9146, 9025, 8896, 8759, 8614, 8461, 8300, 8131, 7954, 7769, 7576, 7375, 7166, 6949, 6724, 6491, 6250, 6001, 5744, 5479, 5206, 4925, 4636, 4339, 4034, 3721, 3400, 3071, 2734, 2389, 2036, 1675, 1306, 929, 544, 151], [345, 734, 1115, 1488, 1853, 2210, 2559, 2900, 3233, 3558, 3875, 4184, 4485, 4778, 5063, 5340, 5609, 5870, 6123, 6368, 6605, 6834, 7055, 7268, 7473, 7670, 7859, 8040, 8213, 8378, 8535, 8684, 8825, 8958, 9083, 9200, 9309, 9410, 9503, 9588, 9665, 9734, 9795, 9848, 9893, 9930, 9959, 9980, 9979, 9978, 9977, 9976, 9975, 9950, 9917, 9876, 9827, 9770, 9705, 9632, 9551, 9462, 9365, 9260, 9147, 9026, 8897, 8760, 8615, 8462, 8301, 8132, 7955, 7770, 7577, 7376, 7167, 6950, 6725, 6492, 6251, 6002, 5745, 5480, 5207, 4926, 4637, 4340, 4035, 3722, 3401, 3072, 2735, 2390, 2037, 1676, 1307, 930, 545, 152], [344, 733, 1114, 1487, 1852, 2209, 2558, 2899, 3232, 3557, 3874, 4183, 4484, 4777, 5062, 5339, 5608, 5869, 6122, 6367, 6604, 6833, 7054, 7267, 7472, 7669, 7858, 8039, 8212, 8377, 8534, 8683, 8824, 8957, 9082, 9199, 9308, 9409, 9502, 9587, 9664, 9733, 9794, 9847, 9892, 9929, 9958, 9957, 9956, 9955, 9954, 9953, 9952, 9951, 9918, 9877, 9828, 9771, 9706, 9633, 9552, 9463, 9366, 9261, 9148, 9027, 8898, 8761, 8616, 8463, 8302, 8133, 7956, 7771, 7578, 7377, 7168, 6951, 6726, 6493, 6252, 6003, 5746, 5481, 5208, 4927, 4638, 4341, 4036, 3723, 3402, 3073, 2736, 2391, 2038, 1677, 1308, 931, 546, 153], [343, 732, 1113, 1486, 1851, 2208, 2557, 2898, 3231, 3556, 3873, 4182, 4483, 4776, 5061, 5338, 5607, 5868, 6121, 6366, 6603, 6832, 7053, 7266, 7471, 7668, 7857, 8038, 8211, 8376, 8533, 8682, 8823, 8956, 9081, 9198, 9307, 9408, 9501, 9586, 9663, 9732, 9793, 9846, 9891, 9928, 9927, 9926, 9925, 9924, 9923, 9922, 9921, 9920, 9919, 9878, 9829, 9772, 9707, 9634, 9553, 9464, 9367, 9262, 9149, 9028, 8899, 8762, 8617, 8464, 8303, 8134, 7957, 7772, 7579, 7378, 7169, 6952, 6727, 6494, 6253, 6004, 5747, 5482, 5209, 4928, 4639, 4342, 4037, 3724, 3403, 3074, 2737, 2392, 2039, 1678, 1309, 932, 547, 154], [342, 731, 1112, 1485, 1850, 2207, 2556, 2897, 3230, 3555, 3872, 4181, 4482, 4775, 5060, 5337, 5606, 5867, 6120, 6365, 6602, 6831, 7052, 7265, 7470, 7667, 7856, 8037, 8210, 8375, 8532, 8681, 8822, 8955, 9080, 9197, 9306, 9407, 9500, 9585, 9662, 9731, 9792, 9845, 9890, 9889, 9888, 9887, 9886, 9885, 9884, 9883, 9882, 9881, 9880, 9879, 9830, 9773, 9708, 9635, 9554, 9465, 9368, 9263, 9150, 9029, 8900, 8763, 8618, 8465, 8304, 8135, 7958, 7773, 7580, 7379, 7170, 6953, 6728, 6495, 6254, 6005, 5748, 5483, 5210, 4929, 4640, 4343, 4038, 3725, 3404, 3075, 2738, 2393, 2040, 1679, 1310, 933, 548, 155], [341, 730, 1111, 1484, 1849, 2206, 2555, 2896, 3229, 3554, 3871, 4180, 4481, 4774, 5059, 5336, 5605, 5866, 6119, 6364, 6601, 6830, 7051, 7264, 7469, 7666, 7855, 8036, 8209, 8374, 8531, 8680, 8821, 8954, 9079, 9196, 9305, 9406, 9499, 9584, 9661, 9730, 9791, 9844, 9843, 9842, 9841, 9840, 9839, 9838, 9837, 9836, 9835, 9834, 9833, 9832, 9831, 9774, 9709, 9636, 9555, 9466, 9369, 9264, 9151, 9030, 8901, 8764, 8619, 8466, 8305, 8136, 7959, 7774, 7581, 7380, 7171, 6954, 6729, 6496, 6255, 6006, 5749, 5484, 5211, 4930, 4641, 4344, 4039, 3726, 3405, 3076, 2739, 2394, 2041, 1680, 1311, 934, 549, 156], [340, 729, 1110, 1483, 1848, 2205, 2554, 2895, 3228, 3553, 3870, 4179, 4480, 4773, 5058, 5335, 5604, 5865, 6118, 6363, 6600, 6829, 7050, 7263, 7468, 7665, 7854, 8035, 8208, 8373, 8530, 8679, 8820, 8953, 9078, 9195, 9304, 9405, 9498, 9583, 9660, 9729, 9790, 9789, 9788, 9787, 9786, 9785, 9784, 9783, 9782, 9781, 9780, 9779, 9778, 9777, 9776, 9775, 9710, 9637, 9556, 9467, 9370, 9265, 9152, 9031, 8902, 8765, 8620, 8467, 8306, 8137, 7960, 7775, 7582, 7381, 7172, 6955, 6730, 6497, 6256, 6007, 5750, 5485, 5212, 4931, 4642, 4345, 4040, 3727, 3406, 3077, 2740, 2395, 2042, 1681, 1312, 935, 550, 157], [339, 728, 1109, 1482, 1847, 2204, 2553, 2894, 3227, 3552, 3869, 4178, 4479, 4772, 5057, 5334, 5603, 5864, 6117, 6362, 6599, 6828, 7049, 7262, 7467, 7664, 7853, 8034, 8207, 8372, 8529, 8678, 8819, 8952, 9077, 9194, 9303, 9404, 9497, 9582, 9659, 9728, 9727, 9726, 9725, 9724, 9723, 9722, 9721, 9720, 9719, 9718, 9717, 9716, 9715, 9714, 9713, 9712, 9711, 9638, 9557, 9468, 9371, 9266, 9153, 9032, 8903, 8766, 8621, 8468, 8307, 8138, 7961, 7776, 7583, 7382, 7173, 6956, 6731, 6498, 6257, 6008, 5751, 5486, 5213, 4932, 4643, 4346, 4041, 3728, 3407, 3078, 2741, 2396, 2043, 1682, 1313, 936, 551, 158], [338, 727, 1108, 1481, 1846, 2203, 2552, 2893, 3226, 3551, 3868, 4177, 4478, 4771, 5056, 5333, 5602, 5863, 6116, 6361, 6598, 6827, 7048, 7261, 7466, 7663, 7852, 8033, 8206, 8371, 8528, 8677, 8818, 8951, 9076, 9193, 9302, 9403, 9496, 9581, 9658, 9657, 9656, 9655, 9654, 9653, 9652, 9651, 9650, 9649, 9648, 9647, 9646, 9645, 9644, 9643, 9642, 9641, 9640, 9639, 9558, 9469, 9372, 9267, 9154, 9033, 8904, 8767, 8622, 8469, 8308, 8139, 7962, 7777, 7584, 7383, 7174, 6957, 6732, 6499, 6258, 6009, 5752, 5487, 5214, 4933, 4644, 4347, 4042, 3729, 3408, 3079, 2742, 2397, 2044, 1683, 1314, 937, 552, 159], [337, 726, 1107, 1480, 1845, 2202, 2551, 2892, 3225, 3550, 3867, 4176, 4477, 4770, 5055, 5332, 5601, 5862, 6115, 6360, 6597, 6826, 7047, 7260, 7465, 7662, 7851, 8032, 8205, 8370, 8527, 8676, 8817, 8950, 9075, 9192, 9301, 9402, 9495, 9580, 9579, 9578, 9577, 9576, 9575, 9574, 9573, 9572, 9571, 9570, 9569, 9568, 9567, 9566, 9565, 9564, 9563, 9562, 9561, 9560, 9559, 9470, 9373, 9268, 9155, 9034, 8905, 8768, 8623, 8470, 8309, 8140, 7963, 7778, 7585, 7384, 7175, 6958, 6733, 6500, 6259, 6010, 5753, 5488, 5215, 4934, 4645, 4348, 4043, 3730, 3409, 3080, 2743, 2398, 2045, 1684, 1315, 938, 553, 160], [336, 725, 1106, 1479, 1844, 2201, 2550, 2891, 3224, 3549, 3866, 4175, 4476, 4769, 5054, 5331, 5600, 5861, 6114, 6359, 6596, 6825, 7046, 7259, 7464, 7661, 7850, 8031, 8204, 8369, 8526, 8675, 8816, 8949, 9074, 9191, 9300, 9401, 9494, 9493, 9492, 9491, 9490, 9489, 9488, 9487, 9486, 9485, 9484, 9483, 9482, 9481, 9480, 9479, 9478, 9477, 9476, 9475, 9474, 9473, 9472, 9471, 9374, 9269, 9156, 9035, 8906, 8769, 8624, 8471, 8310, 8141, 7964, 7779, 7586, 7385, 7176, 6959, 6734, 6501, 6260, 6011, 5754, 5489, 5216, 4935, 4646, 4349, 4044, 3731, 3410, 3081, 2744, 2399, 2046, 1685, 1316, 939, 554, 161], [335, 724, 1105, 1478, 1843, 2200, 2549, 2890, 3223, 3548, 3865, 4174, 4475, 4768, 5053, 5330, 5599, 5860, 6113, 6358, 6595, 6824, 7045, 7258, 7463, 7660, 7849, 8030, 8203, 8368, 8525, 8674, 8815, 8948, 9073, 9190, 9299, 9400, 9399, 9398, 9397, 9396, 9395, 9394, 9393, 9392, 9391, 9390, 9389, 9388, 9387, 9386, 9385, 9384, 9383, 9382, 9381, 9380, 9379, 9378, 9377, 9376, 9375, 9270, 9157, 9036, 8907, 8770, 8625, 8472, 8311, 8142, 7965, 7780, 7587, 7386, 7177, 6960, 6735, 6502, 6261, 6012, 5755, 5490, 5217, 4936, 4647, 4350, 4045, 3732, 3411, 3082, 2745, 2400, 2047, 1686, 1317, 940, 555, 162], [334, 723, 1104, 1477, 1842, 2199, 2548, 2889, 3222, 3547, 3864, 4173, 4474, 4767, 5052, 5329, 5598, 5859, 6112, 6357, 6594, 6823, 7044, 7257, 7462, 7659, 7848, 8029, 8202, 8367, 8524, 8673, 8814, 8947, 9072, 9189, 9298, 9297, 9296, 9295, 9294, 9293, 9292, 9291, 9290, 9289, 9288, 9287, 9286, 9285, 9284, 9283, 9282, 9281, 9280, 9279, 9278, 9277, 9276, 9275, 9274, 9273, 9272, 9271, 9158, 9037, 8908, 8771, 8626, 8473, 8312, 8143, 7966, 7781, 7588, 7387, 7178, 6961, 6736, 6503, 6262, 6013, 5756, 5491, 5218, 4937, 4648, 4351, 4046, 3733, 3412, 3083, 2746, 2401, 2048, 1687, 1318, 941, 556, 163], [333, 722, 1103, 1476, 1841, 2198, 2547, 2888, 3221, 3546, 3863, 4172, 4473, 4766, 5051, 5328, 5597, 5858, 6111, 6356, 6593, 6822, 7043, 7256, 7461, 7658, 7847, 8028, 8201, 8366, 8523, 8672, 8813, 8946, 9071, 9188, 9187, 9186, 9185, 9184, 9183, 9182, 9181, 9180, 9179, 9178, 9177, 9176, 9175, 9174, 9173, 9172, 9171, 9170, 9169, 9168, 9167, 9166, 9165, 9164, 9163, 9162, 9161, 9160, 9159, 9038, 8909, 8772, 8627, 8474, 8313, 8144, 7967, 7782, 7589, 7388, 7179, 6962, 6737, 6504, 6263, 6014, 5757, 5492, 5219, 4938, 4649, 4352, 4047, 3734, 3413, 3084, 2747, 2402, 2049, 1688, 1319, 942, 557, 164], [332, 721, 1102, 1475, 1840, 2197, 2546, 2887, 3220, 3545, 3862, 4171, 4472, 4765, 5050, 5327, 5596, 5857, 6110, 6355, 6592, 6821, 7042, 7255, 7460, 7657, 7846, 8027, 8200, 8365, 8522, 8671, 8812, 8945, 9070, 9069, 9068, 9067, 9066, 9065, 9064, 9063, 9062, 9061, 9060, 9059, 9058, 9057, 9056, 9055, 9054, 9053, 9052, 9051, 9050, 9049, 9048, 9047, 9046, 9045, 9044, 9043, 9042, 9041, 9040, 9039, 8910, 8773, 8628, 8475, 8314, 8145, 7968, 7783, 7590, 7389, 7180, 6963, 6738, 6505, 6264, 6015, 5758, 5493, 5220, 4939, 4650, 4353, 4048, 3735, 3414, 3085, 2748, 2403, 2050, 1689, 1320, 943, 558, 165], [331, 720, 1101, 1474, 1839, 2196, 2545, 2886, 3219, 3544, 3861, 4170, 4471, 4764, 5049, 5326, 5595, 5856, 6109, 6354, 6591, 6820, 7041, 7254, 7459, 7656, 7845, 8026, 8199, 8364, 8521, 8670, 8811, 8944, 8943, 8942, 8941, 8940, 8939, 8938, 8937, 8936, 8935, 8934, 8933, 8932, 8931, 8930, 8929, 8928, 8927, 8926, 8925, 8924, 8923, 8922, 8921, 8920, 8919, 8918, 8917, 8916, 8915, 8914, 8913, 8912, 8911, 8774, 8629, 8476, 8315, 8146, 7969, 7784, 7591, 7390, 7181, 6964, 6739, 6506, 6265, 6016, 5759, 5494, 5221, 4940, 4651, 4354, 4049, 3736, 3415, 3086, 2749, 2404, 2051, 1690, 1321, 944, 559, 166], [330, 719, 1100, 1473, 1838, 2195, 2544, 2885, 3218, 3543, 3860, 4169, 4470, 4763, 5048, 5325, 5594, 5855, 6108, 6353, 6590, 6819, 7040, 7253, 7458, 7655, 7844, 8025, 8198, 8363, 8520, 8669, 8810, 8809, 8808, 8807, 8806, 8805, 8804, 8803, 8802, 8801, 8800, 8799, 8798, 8797, 8796, 8795, 8794, 8793, 8792, 8791, 8790, 8789, 8788, 8787, 8786, 8785, 8784, 8783, 8782, 8781, 8780, 8779, 8778, 8777, 8776, 8775, 8630, 8477, 8316, 8147, 7970, 7785, 7592, 7391, 7182, 6965, 6740, 6507, 6266, 6017, 5760, 5495, 5222, 4941, 4652, 4355, 4050, 3737, 3416, 3087, 2750, 2405, 2052, 1691, 1322, 945, 560, 167], [329, 718, 1099, 1472, 1837, 2194, 2543, 2884, 3217, 3542, 3859, 4168, 4469, 4762, 5047, 5324, 5593, 5854, 6107, 6352, 6589, 6818, 7039, 7252, 7457, 7654, 7843, 8024, 8197, 8362, 8519, 8668, 8667, 8666, 8665, 8664, 8663, 8662, 8661, 8660, 8659, 8658, 8657, 8656, 8655, 8654, 8653, 8652, 8651, 8650, 8649, 8648, 8647, 8646, 8645, 8644, 8643, 8642, 8641, 8640, 8639, 8638, 8637, 8636, 8635, 8634, 8633, 8632, 8631, 8478, 8317, 8148, 7971, 7786, 7593, 7392, 7183, 6966, 6741, 6508, 6267, 6018, 5761, 5496, 5223, 4942, 4653, 4356, 4051, 3738, 3417, 3088, 2751, 2406, 2053, 1692, 1323, 946, 561, 168], [328, 717, 1098, 1471, 1836, 2193, 2542, 2883, 3216, 3541, 3858, 4167, 4468, 4761, 5046, 5323, 5592, 5853, 6106, 6351, 6588, 6817, 7038, 7251, 7456, 7653, 7842, 8023, 8196, 8361, 8518, 8517, 8516, 8515, 8514, 8513, 8512, 8511, 8510, 8509, 8508, 8507, 8506, 8505, 8504, 8503, 8502, 8501, 8500, 8499, 8498, 8497, 8496, 8495, 8494, 8493, 8492, 8491, 8490, 8489, 8488, 8487, 8486, 8485, 8484, 8483, 8482, 8481, 8480, 8479, 8318, 8149, 7972, 7787, 7594, 7393, 7184, 6967, 6742, 6509, 6268, 6019, 5762, 5497, 5224, 4943, 4654, 4357, 4052, 3739, 3418, 3089, 2752, 2407, 2054, 1693, 1324, 947, 562, 169], [327, 716, 1097, 1470, 1835, 2192, 2541, 2882, 3215, 3540, 3857, 4166, 4467, 4760, 5045, 5322, 5591, 5852, 6105, 6350, 6587, 6816, 7037, 7250, 7455, 7652, 7841, 8022, 8195, 8360, 8359, 8358, 8357, 8356, 8355, 8354, 8353, 8352, 8351, 8350, 8349, 8348, 8347, 8346, 8345, 8344, 8343, 8342, 8341, 8340, 8339, 8338, 8337, 8336, 8335, 8334, 8333, 8332, 8331, 8330, 8329, 8328, 8327, 8326, 8325, 8324, 8323, 8322, 8321, 8320, 8319, 8150, 7973, 7788, 7595, 7394, 7185, 6968, 6743, 6510, 6269, 6020, 5763, 5498, 5225, 4944, 4655, 4358, 4053, 3740, 3419, 3090, 2753, 2408, 2055, 1694, 1325, 948, 563, 170], [326, 715, 1096, 1469, 1834, 2191, 2540, 2881, 3214, 3539, 3856, 4165, 4466, 4759, 5044, 5321, 5590, 5851, 6104, 6349, 6586, 6815, 7036, 7249, 7454, 7651, 7840, 8021, 8194, 8193, 8192, 8191, 8190, 8189, 8188, 8187, 8186, 8185, 8184, 8183, 8182, 8181, 8180, 8179, 8178, 8177, 8176, 8175, 8174, 8173, 8172, 8171, 8170, 8169, 8168, 8167, 8166, 8165, 8164, 8163, 8162, 8161, 8160, 8159, 8158, 8157, 8156, 8155, 8154, 8153, 8152, 8151, 7974, 7789, 7596, 7395, 7186, 6969, 6744, 6511, 6270, 6021, 5764, 5499, 5226, 4945, 4656, 4359, 4054, 3741, 3420, 3091, 2754, 2409, 2056, 1695, 1326, 949, 564, 171], [325, 714, 1095, 1468, 1833, 2190, 2539, 2880, 3213, 3538, 3855, 4164, 4465, 4758, 5043, 5320, 5589, 5850, 6103, 6348, 6585, 6814, 7035, 7248, 7453, 7650, 7839, 8020, 8019, 8018, 8017, 8016, 8015, 8014, 8013, 8012, 8011, 8010, 8009, 8008, 8007, 8006, 8005, 8004, 8003, 8002, 8001, 8000, 7999, 7998, 7997, 7996, 7995, 7994, 7993, 7992, 7991, 7990, 7989, 7988, 7987, 7986, 7985, 7984, 7983, 7982, 7981, 7980, 7979, 7978, 7977, 7976, 7975, 7790, 7597, 7396, 7187, 6970, 6745, 6512, 6271, 6022, 5765, 5500, 5227, 4946, 4657, 4360, 4055, 3742, 3421, 3092, 2755, 2410, 2057, 1696, 1327, 950, 565, 172], [324, 713, 1094, 1467, 1832, 2189, 2538, 2879, 3212, 3537, 3854, 4163, 4464, 4757, 5042, 5319, 5588, 5849, 6102, 6347, 6584, 6813, 7034, 7247, 7452, 7649, 7838, 7837, 7836, 7835, 7834, 7833, 7832, 7831, 7830, 7829, 7828, 7827, 7826, 7825, 7824, 7823, 7822, 7821, 7820, 7819, 7818, 7817, 7816, 7815, 7814, 7813, 7812, 7811, 7810, 7809, 7808, 7807, 7806, 7805, 7804, 7803, 7802, 7801, 7800, 7799, 7798, 7797, 7796, 7795, 7794, 7793, 7792, 7791, 7598, 7397, 7188, 6971, 6746, 6513, 6272, 6023, 5766, 5501, 5228, 4947, 4658, 4361, 4056, 3743, 3422, 3093, 2756, 2411, 2058, 1697, 1328, 951, 566, 173], [323, 712, 1093, 1466, 1831, 2188, 2537, 2878, 3211, 3536, 3853, 4162, 4463, 4756, 5041, 5318, 5587, 5848, 6101, 6346, 6583, 6812, 7033, 7246, 7451, 7648, 7647, 7646, 7645, 7644, 7643, 7642, 7641, 7640, 7639, 7638, 7637, 7636, 7635, 7634, 7633, 7632, 7631, 7630, 7629, 7628, 7627, 7626, 7625, 7624, 7623, 7622, 7621, 7620, 7619, 7618, 7617, 7616, 7615, 7614, 7613, 7612, 7611, 7610, 7609, 7608, 7607, 7606, 7605, 7604, 7603, 7602, 7601, 7600, 7599, 7398, 7189, 6972, 6747, 6514, 6273, 6024, 5767, 5502, 5229, 4948, 4659, 4362, 4057, 3744, 3423, 3094, 2757, 2412, 2059, 1698, 1329, 952, 567, 174], [322, 711, 1092, 1465, 1830, 2187, 2536, 2877, 3210, 3535, 3852, 4161, 4462, 4755, 5040, 5317, 5586, 5847, 6100, 6345, 6582, 6811, 7032, 7245, 7450, 7449, 7448, 7447, 7446, 7445, 7444, 7443, 7442, 7441, 7440, 7439, 7438, 7437, 7436, 7435, 7434, 7433, 7432, 7431, 7430, 7429, 7428, 7427, 7426, 7425, 7424, 7423, 7422, 7421, 7420, 7419, 7418, 7417, 7416, 7415, 7414, 7413, 7412, 7411, 7410, 7409, 7408, 7407, 7406, 7405, 7404, 7403, 7402, 7401, 7400, 7399, 7190, 6973, 6748, 6515, 6274, 6025, 5768, 5503, 5230, 4949, 4660, 4363, 4058, 3745, 3424, 3095, 2758, 2413, 2060, 1699, 1330, 953, 568, 175], [321, 710, 1091, 1464, 1829, 2186, 2535, 2876, 3209, 3534, 3851, 4160, 4461, 4754, 5039, 5316, 5585, 5846, 6099, 6344, 6581, 6810, 7031, 7244, 7243, 7242, 7241, 7240, 7239, 7238, 7237, 7236, 7235, 7234, 7233, 7232, 7231, 7230, 7229, 7228, 7227, 7226, 7225, 7224, 7223, 7222, 7221, 7220, 7219, 7218, 7217, 7216, 7215, 7214, 7213, 7212, 7211, 7210, 7209, 7208, 7207, 7206, 7205, 7204, 7203, 7202, 7201, 7200, 7199, 7198, 7197, 7196, 7195, 7194, 7193, 7192, 7191, 6974, 6749, 6516, 6275, 6026, 5769, 5504, 5231, 4950, 4661, 4364, 4059, 3746, 3425, 3096, 2759, 2414, 2061, 1700, 1331, 954, 569, 176], [320, 709, 1090, 1463, 1828, 2185, 2534, 2875, 3208, 3533, 3850, 4159, 4460, 4753, 5038, 5315, 5584, 5845, 6098, 6343, 6580, 6809, 7030, 7029, 7028, 7027, 7026, 7025, 7024, 7023, 7022, 7021, 7020, 7019, 7018, 7017, 7016, 7015, 7014, 7013, 7012, 7011, 7010, 7009, 7008, 7007, 7006, 7005, 7004, 7003, 7002, 7001, 7000, 6999, 6998, 6997, 6996, 6995, 6994, 6993, 6992, 6991, 6990, 6989, 6988, 6987, 6986, 6985, 6984, 6983, 6982, 6981, 6980, 6979, 6978, 6977, 6976, 6975, 6750, 6517, 6276, 6027, 5770, 5505, 5232, 4951, 4662, 4365, 4060, 3747, 3426, 3097, 2760, 2415, 2062, 1701, 1332, 955, 570, 177], [319, 708, 1089, 1462, 1827, 2184, 2533, 2874, 3207, 3532, 3849, 4158, 4459, 4752, 5037, 5314, 5583, 5844, 6097, 6342, 6579, 6808, 6807, 6806, 6805, 6804, 6803, 6802, 6801, 6800, 6799, 6798, 6797, 6796, 6795, 6794, 6793, 6792, 6791, 6790, 6789, 6788, 6787, 6786, 6785, 6784, 6783, 6782, 6781, 6780, 6779, 6778, 6777, 6776, 6775, 6774, 6773, 6772, 6771, 6770, 6769, 6768, 6767, 6766, 6765, 6764, 6763, 6762, 6761, 6760, 6759, 6758, 6757, 6756, 6755, 6754, 6753, 6752, 6751, 6518, 6277, 6028, 5771, 5506, 5233, 4952, 4663, 4366, 4061, 3748, 3427, 3098, 2761, 2416, 2063, 1702, 1333, 956, 571, 178], [318, 707, 1088, 1461, 1826, 2183, 2532, 2873, 3206, 3531, 3848, 4157, 4458, 4751, 5036, 5313, 5582, 5843, 6096, 6341, 6578, 6577, 6576, 6575, 6574, 6573, 6572, 6571, 6570, 6569, 6568, 6567, 6566, 6565, 6564, 6563, 6562, 6561, 6560, 6559, 6558, 6557, 6556, 6555, 6554, 6553, 6552, 6551, 6550, 6549, 6548, 6547, 6546, 6545, 6544, 6543, 6542, 6541, 6540, 6539, 6538, 6537, 6536, 6535, 6534, 6533, 6532, 6531, 6530, 6529, 6528, 6527, 6526, 6525, 6524, 6523, 6522, 6521, 6520, 6519, 6278, 6029, 5772, 5507, 5234, 4953, 4664, 4367, 4062, 3749, 3428, 3099, 2762, 2417, 2064, 1703, 1334, 957, 572, 179], [317, 706, 1087, 1460, 1825, 2182, 2531, 2872, 3205, 3530, 3847, 4156, 4457, 4750, 5035, 5312, 5581, 5842, 6095, 6340, 6339, 6338, 6337, 6336, 6335, 6334, 6333, 6332, 6331, 6330, 6329, 6328, 6327, 6326, 6325, 6324, 6323, 6322, 6321, 6320, 6319, 6318, 6317, 6316, 6315, 6314, 6313, 6312, 6311, 6310, 6309, 6308, 6307, 6306, 6305, 6304, 6303, 6302, 6301, 6300, 6299, 6298, 6297, 6296, 6295, 6294, 6293, 6292, 6291, 6290, 6289, 6288, 6287, 6286, 6285, 6284, 6283, 6282, 6281, 6280, 6279, 6030, 5773, 5508, 5235, 4954, 4665, 4368, 4063, 3750, 3429, 3100, 2763, 2418, 2065, 1704, 1335, 958, 573, 180], [316, 705, 1086, 1459, 1824, 2181, 2530, 2871, 3204, 3529, 3846, 4155, 4456, 4749, 5034, 5311, 5580, 5841, 6094, 6093, 6092, 6091, 6090, 6089, 6088, 6087, 6086, 6085, 6084, 6083, 6082, 6081, 6080, 6079, 6078, 6077, 6076, 6075, 6074, 6073, 6072, 6071, 6070, 6069, 6068, 6067, 6066, 6065, 6064, 6063, 6062, 6061, 6060, 6059, 6058, 6057, 6056, 6055, 6054, 6053, 6052, 6051, 6050, 6049, 6048, 6047, 6046, 6045, 6044, 6043, 6042, 6041, 6040, 6039, 6038, 6037, 6036, 6035, 6034, 6033, 6032, 6031, 5774, 5509, 5236, 4955, 4666, 4369, 4064, 3751, 3430, 3101, 2764, 2419, 2066, 1705, 1336, 959, 574, 181], [315, 704, 1085, 1458, 1823, 2180, 2529, 2870, 3203, 3528, 3845, 4154, 4455, 4748, 5033, 5310, 5579, 5840, 5839, 5838, 5837, 5836, 5835, 5834, 5833, 5832, 5831, 5830, 5829, 5828, 5827, 5826, 5825, 5824, 5823, 5822, 5821, 5820, 5819, 5818, 5817, 5816, 5815, 5814, 5813, 5812, 5811, 5810, 5809, 5808, 5807, 5806, 5805, 5804, 5803, 5802, 5801, 5800, 5799, 5798, 5797, 5796, 5795, 5794, 5793, 5792, 5791, 5790, 5789, 5788, 5787, 5786, 5785, 5784, 5783, 5782, 5781, 5780, 5779, 5778, 5777, 5776, 5775, 5510, 5237, 4956, 4667, 4370, 4065, 3752, 3431, 3102, 2765, 2420, 2067, 1706, 1337, 960, 575, 182], [314, 703, 1084, 1457, 1822, 2179, 2528, 2869, 3202, 3527, 3844, 4153, 4454, 4747, 5032, 5309, 5578, 5577, 5576, 5575, 5574, 5573, 5572, 5571, 5570, 5569, 5568, 5567, 5566, 5565, 5564, 5563, 5562, 5561, 5560, 5559, 5558, 5557, 5556, 5555, 5554, 5553, 5552, 5551, 5550, 5549, 5548, 5547, 5546, 5545, 5544, 5543, 5542, 5541, 5540, 5539, 5538, 5537, 5536, 5535, 5534, 5533, 5532, 5531, 5530, 5529, 5528, 5527, 5526, 5525, 5524, 5523, 5522, 5521, 5520, 5519, 5518, 5517, 5516, 5515, 5514, 5513, 5512, 5511, 5238, 4957, 4668, 4371, 4066, 3753, 3432, 3103, 2766, 2421, 2068, 1707, 1338, 961, 576, 183], [313, 702, 1083, 1456, 1821, 2178, 2527, 2868, 3201, 3526, 3843, 4152, 4453, 4746, 5031, 5308, 5307, 5306, 5305, 5304, 5303, 5302, 5301, 5300, 5299, 5298, 5297, 5296, 5295, 5294, 5293, 5292, 5291, 5290, 5289, 5288, 5287, 5286, 5285, 5284, 5283, 5282, 5281, 5280, 5279, 5278, 5277, 5276, 5275, 5274, 5273, 5272, 5271, 5270, 5269, 5268, 5267, 5266, 5265, 5264, 5263, 5262, 5261, 5260, 5259, 5258, 5257, 5256, 5255, 5254, 5253, 5252, 5251, 5250, 5249, 5248, 5247, 5246, 5245, 5244, 5243, 5242, 5241, 5240, 5239, 4958, 4669, 4372, 4067, 3754, 3433, 3104, 2767, 2422, 2069, 1708, 1339, 962, 577, 184], [312, 701, 1082, 1455, 1820, 2177, 2526, 2867, 3200, 3525, 3842, 4151, 4452, 4745, 5030, 5029, 5028, 5027, 5026, 5025, 5024, 5023, 5022, 5021, 5020, 5019, 5018, 5017, 5016, 5015, 5014, 5013, 5012, 5011, 5010, 5009, 5008, 5007, 5006, 5005, 5004, 5003, 5002, 5001, 5000, 4999, 4998, 4997, 4996, 4995, 4994, 4993, 4992, 4991, 4990, 4989, 4988, 4987, 4986, 4985, 4984, 4983, 4982, 4981, 4980, 4979, 4978, 4977, 4976, 4975, 4974, 4973, 4972, 4971, 4970, 4969, 4968, 4967, 4966, 4965, 4964, 4963, 4962, 4961, 4960, 4959, 4670, 4373, 4068, 3755, 3434, 3105, 2768, 2423, 2070, 1709, 1340, 963, 578, 185], [311, 700, 1081, 1454, 1819, 2176, 2525, 2866, 3199, 3524, 3841, 4150, 4451, 4744, 4743, 4742, 4741, 4740, 4739, 4738, 4737, 4736, 4735, 4734, 4733, 4732, 4731, 4730, 4729, 4728, 4727, 4726, 4725, 4724, 4723, 4722, 4721, 4720, 4719, 4718, 4717, 4716, 4715, 4714, 4713, 4712, 4711, 4710, 4709, 4708, 4707, 4706, 4705, 4704, 4703, 4702, 4701, 4700, 4699, 4698, 4697, 4696, 4695, 4694, 4693, 4692, 4691, 4690, 4689, 4688, 4687, 4686, 4685, 4684, 4683, 4682, 4681, 4680, 4679, 4678, 4677, 4676, 4675, 4674, 4673, 4672, 4671, 4374, 4069, 3756, 3435, 3106, 2769, 2424, 2071, 1710, 1341, 964, 579, 186], [310, 699, 1080, 1453, 1818, 2175, 2524, 2865, 3198, 3523, 3840, 4149, 4450, 4449, 4448, 4447, 4446, 4445, 4444, 4443, 4442, 4441, 4440, 4439, 4438, 4437, 4436, 4435, 4434, 4433, 4432, 4431, 4430, 4429, 4428, 4427, 4426, 4425, 4424, 4423, 4422, 4421, 4420, 4419, 4418, 4417, 4416, 4415, 4414, 4413, 4412, 4411, 4410, 4409, 4408, 4407, 4406, 4405, 4404, 4403, 4402, 4401, 4400, 4399, 4398, 4397, 4396, 4395, 4394, 4393, 4392, 4391, 4390, 4389, 4388, 4387, 4386, 4385, 4384, 4383, 4382, 4381, 4380, 4379, 4378, 4377, 4376, 4375, 4070, 3757, 3436, 3107, 2770, 2425, 2072, 1711, 1342, 965, 580, 187], [309, 698, 1079, 1452, 1817, 2174, 2523, 2864, 3197, 3522, 3839, 4148, 4147, 4146, 4145, 4144, 4143, 4142, 4141, 4140, 4139, 4138, 4137, 4136, 4135, 4134, 4133, 4132, 4131, 4130, 4129, 4128, 4127, 4126, 4125, 4124, 4123, 4122, 4121, 4120, 4119, 4118, 4117, 4116, 4115, 4114, 4113, 4112, 4111, 4110, 4109, 4108, 4107, 4106, 4105, 4104, 4103, 4102, 4101, 4100, 4099, 4098, 4097, 4096, 4095, 4094, 4093, 4092, 4091, 4090, 4089, 4088, 4087, 4086, 4085, 4084, 4083, 4082, 4081, 4080, 4079, 4078, 4077, 4076, 4075, 4074, 4073, 4072, 4071, 3758, 3437, 3108, 2771, 2426, 2073, 1712, 1343, 966, 581, 188], [308, 697, 1078, 1451, 1816, 2173, 2522, 2863, 3196, 3521, 3838, 3837, 3836, 3835, 3834, 3833, 3832, 3831, 3830, 3829, 3828, 3827, 3826, 3825, 3824, 3823, 3822, 3821, 3820, 3819, 3818, 3817, 3816, 3815, 3814, 3813, 3812, 3811, 3810, 3809, 3808, 3807, 3806, 3805, 3804, 3803, 3802, 3801, 3800, 3799, 3798, 3797, 3796, 3795, 3794, 3793, 3792, 3791, 3790, 3789, 3788, 3787, 3786, 3785, 3784, 3783, 3782, 3781, 3780, 3779, 3778, 3777, 3776, 3775, 3774, 3773, 3772, 3771, 3770, 3769, 3768, 3767, 3766, 3765, 3764, 3763, 3762, 3761, 3760, 3759, 3438, 3109, 2772, 2427, 2074, 1713, 1344, 967, 582, 189], [307, 696, 1077, 1450, 1815, 2172, 2521, 2862, 3195, 3520, 3519, 3518, 3517, 3516, 3515, 3514, 3513, 3512, 3511, 3510, 3509, 3508, 3507, 3506, 3505, 3504, 3503, 3502, 3501, 3500, 3499, 3498, 3497, 3496, 3495, 3494, 3493, 3492, 3491, 3490, 3489, 3488, 3487, 3486, 3485, 3484, 3483, 3482, 3481, 3480, 3479, 3478, 3477, 3476, 3475, 3474, 3473, 3472, 3471, 3470, 3469, 3468, 3467, 3466, 3465, 3464, 3463, 3462, 3461, 3460, 3459, 3458, 3457, 3456, 3455, 3454, 3453, 3452, 3451, 3450, 3449, 3448, 3447, 3446, 3445, 3444, 3443, 3442, 3441, 3440, 3439, 3110, 2773, 2428, 2075, 1714, 1345, 968, 583, 190], [306, 695, 1076, 1449, 1814, 2171, 2520, 2861, 3194, 3193, 3192, 3191, 3190, 3189, 3188, 3187, 3186, 3185, 3184, 3183, 3182, 3181, 3180, 3179, 3178, 3177, 3176, 3175, 3174, 3173, 3172, 3171, 3170, 3169, 3168, 3167, 3166, 3165, 3164, 3163, 3162, 3161, 3160, 3159, 3158, 3157, 3156, 3155, 3154, 3153, 3152, 3151, 3150, 3149, 3148, 3147, 3146, 3145, 3144, 3143, 3142, 3141, 3140, 3139, 3138, 3137, 3136, 3135, 3134, 3133, 3132, 3131, 3130, 3129, 3128, 3127, 3126, 3125, 3124, 3123, 3122, 3121, 3120, 3119, 3118, 3117, 3116, 3115, 3114, 3113, 3112, 3111, 2774, 2429, 2076, 1715, 1346, 969, 584, 191], [305, 694, 1075, 1448, 1813, 2170, 2519, 2860, 2859, 2858, 2857, 2856, 2855, 2854, 2853, 2852, 2851, 2850, 2849, 2848, 2847, 2846, 2845, 2844, 2843, 2842, 2841, 2840, 2839, 2838, 2837, 2836, 2835, 2834, 2833, 2832, 2831, 2830, 2829, 2828, 2827, 2826, 2825, 2824, 2823, 2822, 2821, 2820, 2819, 2818, 2817, 2816, 2815, 2814, 2813, 2812, 2811, 2810, 2809, 2808, 2807, 2806, 2805, 2804, 2803, 2802, 2801, 2800, 2799, 2798, 2797, 2796, 2795, 2794, 2793, 2792, 2791, 2790, 2789, 2788, 2787, 2786, 2785, 2784, 2783, 2782, 2781, 2780, 2779, 2778, 2777, 2776, 2775, 2430, 2077, 1716, 1347, 970, 585, 192], [304, 693, 1074, 1447, 1812, 2169, 2518, 2517, 2516, 2515, 2514, 2513, 2512, 2511, 2510, 2509, 2508, 2507, 2506, 2505, 2504, 2503, 2502, 2501, 2500, 2499, 2498, 2497, 2496, 2495, 2494, 2493, 2492, 2491, 2490, 2489, 2488, 2487, 2486, 2485, 2484, 2483, 2482, 2481, 2480, 2479, 2478, 2477, 2476, 2475, 2474, 2473, 2472, 2471, 2470, 2469, 2468, 2467, 2466, 2465, 2464, 2463, 2462, 2461, 2460, 2459, 2458, 2457, 2456, 2455, 2454, 2453, 2452, 2451, 2450, 2449, 2448, 2447, 2446, 2445, 2444, 2443, 2442, 2441, 2440, 2439, 2438, 2437, 2436, 2435, 2434, 2433, 2432, 2431, 2078, 1717, 1348, 971, 586, 193], [303, 692, 1073, 1446, 1811, 2168, 2167, 2166, 2165, 2164, 2163, 2162, 2161, 2160, 2159, 2158, 2157, 2156, 2155, 2154, 2153, 2152, 2151, 2150, 2149, 2148, 2147, 2146, 2145, 2144, 2143, 2142, 2141, 2140, 2139, 2138, 2137, 2136, 2135, 2134, 2133, 2132, 2131, 2130, 2129, 2128, 2127, 2126, 2125, 2124, 2123, 2122, 2121, 2120, 2119, 2118, 2117, 2116, 2115, 2114, 2113, 2112, 2111, 2110, 2109, 2108, 2107, 2106, 2105, 2104, 2103, 2102, 2101, 2100, 2099, 2098, 2097, 2096, 2095, 2094, 2093, 2092, 2091, 2090, 2089, 2088, 2087, 2086, 2085, 2084, 2083, 2082, 2081, 2080, 2079, 1718, 1349, 972, 587, 194], [302, 691, 1072, 1445, 1810, 1809, 1808, 1807, 1806, 1805, 1804, 1803, 1802, 1801, 1800, 1799, 1798, 1797, 1796, 1795, 1794, 1793, 1792, 1791, 1790, 1789, 1788, 1787, 1786, 1785, 1784, 1783, 1782, 1781, 1780, 1779, 1778, 1777, 1776, 1775, 1774, 1773, 1772, 1771, 1770, 1769, 1768, 1767, 1766, 1765, 1764, 1763, 1762, 1761, 1760, 1759, 1758, 1757, 1756, 1755, 1754, 1753, 1752, 1751, 1750, 1749, 1748, 1747, 1746, 1745, 1744, 1743, 1742, 1741, 1740, 1739, 1738, 1737, 1736, 1735, 1734, 1733, 1732, 1731, 1730, 1729, 1728, 1727, 1726, 1725, 1724, 1723, 1722, 1721, 1720, 1719, 1350, 973, 588, 195], [301, 690, 1071, 1444, 1443, 1442, 1441, 1440, 1439, 1438, 1437, 1436, 1435, 1434, 1433, 1432, 1431, 1430, 1429, 1428, 1427, 1426, 1425, 1424, 1423, 1422, 1421, 1420, 1419, 1418, 1417, 1416, 1415, 1414, 1413, 1412, 1411, 1410, 1409, 1408, 1407, 1406, 1405, 1404, 1403, 1402, 1401, 1400, 1399, 1398, 1397, 1396, 1395, 1394, 1393, 1392, 1391, 1390, 1389, 1388, 1387, 1386, 1385, 1384, 1383, 1382, 1381, 1380, 1379, 1378, 1377, 1376, 1375, 1374, 1373, 1372, 1371, 1370, 1369, 1368, 1367, 1366, 1365, 1364, 1363, 1362, 1361, 1360, 1359, 1358, 1357, 1356, 1355, 1354, 1353, 1352, 1351, 974, 589, 196], [300, 689, 1070, 1069, 1068, 1067, 1066, 1065, 1064, 1063, 1062, 1061, 1060, 1059, 1058, 1057, 1056, 1055, 1054, 1053, 1052, 1051, 1050, 1049, 1048, 1047, 1046, 1045, 1044, 1043, 1042, 1041, 1040, 1039, 1038, 1037, 1036, 1035, 1034, 1033, 1032, 1031, 1030, 1029, 1028, 1027, 1026, 1025, 1024, 1023, 1022, 1021, 1020, 1019, 1018, 1017, 1016, 1015, 1014, 1013, 1012, 1011, 1010, 1009, 1008, 1007, 1006, 1005, 1004, 1003, 1002, 1001, 1000, 999, 998, 997, 996, 995, 994, 993, 992, 991, 990, 989, 988, 987, 986, 985, 984, 983, 982, 981, 980, 979, 978, 977, 976, 975, 590, 197], [299, 688, 687, 686, 685, 684, 683, 682, 681, 680, 679, 678, 677, 676, 675, 674, 673, 672, 671, 670, 669, 668, 667, 666, 665, 664, 663, 662, 661, 660, 659, 658, 657, 656, 655, 654, 653, 652, 651, 650, 649, 648, 647, 646, 645, 644, 643, 642, 641, 640, 639, 638, 637, 636, 635, 634, 633, 632, 631, 630, 629, 628, 627, 626, 625, 624, 623, 622, 621, 620, 619, 618, 617, 616, 615, 614, 613, 612, 611, 610, 609, 608, 607, 606, 605, 604, 603, 602, 601, 600, 599, 598, 597, 596, 595, 594, 593, 592, 591, 198], [298, 297, 296, 295, 294, 293, 292, 291, 290, 289, 288, 287, 286, 285, 284, 283, 282, 281, 280, 279, 278, 277, 276, 275, 274, 273, 272, 271, 270, 269, 268, 267, 266, 265, 264, 263, 262, 261, 260, 259, 258, 257, 256, 255, 254, 253, 252, 251, 250, 249, 248, 247, 246, 245, 244, 243, 242, 241, 240, 239, 238, 237, 236, 235, 234, 233, 232, 231, 230, 229, 228, 227, 226, 225, 224, 223, 222, 221, 220, 219, 218, 217, 216, 215, 214, 213, 212, 211, 210, 209, 208, 207, 206, 205, 204, 203, 202, 201, 200, 199]]\n    assert candidate(9) == [[1, 2, 3, 4, 5, 6, 7, 8, 9], [32, 33, 34, 35, 36, 37, 38, 39, 10], [31, 56, 57, 58, 59, 60, 61, 40, 11], [30, 55, 72, 73, 74, 75, 62, 41, 12], [29, 54, 71, 80, 81, 76, 63, 42, 13], [28, 53, 70, 79, 78, 77, 64, 43, 14], [27, 52, 69, 68, 67, 66, 65, 44, 15], [26, 51, 50, 49, 48, 47, 46, 45, 16], [25, 24, 23, 22, 21, 20, 19, 18, 17]]\n    assert candidate(50) == [[1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50], [196, 197, 198, 199, 200, 201, 202, 203, 204, 205, 206, 207, 208, 209, 210, 211, 212, 213, 214, 215, 216, 217, 218, 219, 220, 221, 222, 223, 224, 225, 226, 227, 228, 229, 230, 231, 232, 233, 234, 235, 236, 237, 238, 239, 240, 241, 242, 243, 244, 51], [195, 384, 385, 386, 387, 388, 389, 390, 391, 392, 393, 394, 395, 396, 397, 398, 399, 400, 401, 402, 403, 404, 405, 406, 407, 408, 409, 410, 411, 412, 413, 414, 415, 416, 417, 418, 419, 420, 421, 422, 423, 424, 425, 426, 427, 428, 429, 430, 245, 52], [194, 383, 564, 565, 566, 567, 568, 569, 570, 571, 572, 573, 574, 575, 576, 577, 578, 579, 580, 581, 582, 583, 584, 585, 586, 587, 588, 589, 590, 591, 592, 593, 594, 595, 596, 597, 598, 599, 600, 601, 602, 603, 604, 605, 606, 607, 608, 431, 246, 53], [193, 382, 563, 736, 737, 738, 739, 740, 741, 742, 743, 744, 745, 746, 747, 748, 749, 750, 751, 752, 753, 754, 755, 756, 757, 758, 759, 760, 761, 762, 763, 764, 765, 766, 767, 768, 769, 770, 771, 772, 773, 774, 775, 776, 777, 778, 609, 432, 247, 54], [192, 381, 562, 735, 900, 901, 902, 903, 904, 905, 906, 907, 908, 909, 910, 911, 912, 913, 914, 915, 916, 917, 918, 919, 920, 921, 922, 923, 924, 925, 926, 927, 928, 929, 930, 931, 932, 933, 934, 935, 936, 937, 938, 939, 940, 779, 610, 433, 248, 55], [191, 380, 561, 734, 899, 1056, 1057, 1058, 1059, 1060, 1061, 1062, 1063, 1064, 1065, 1066, 1067, 1068, 1069, 1070, 1071, 1072, 1073, 1074, 1075, 1076, 1077, 1078, 1079, 1080, 1081, 1082, 1083, 1084, 1085, 1086, 1087, 1088, 1089, 1090, 1091, 1092, 1093, 1094, 941, 780, 611, 434, 249, 56], [190, 379, 560, 733, 898, 1055, 1204, 1205, 1206, 1207, 1208, 1209, 1210, 1211, 1212, 1213, 1214, 1215, 1216, 1217, 1218, 1219, 1220, 1221, 1222, 1223, 1224, 1225, 1226, 1227, 1228, 1229, 1230, 1231, 1232, 1233, 1234, 1235, 1236, 1237, 1238, 1239, 1240, 1095, 942, 781, 612, 435, 250, 57], [189, 378, 559, 732, 897, 1054, 1203, 1344, 1345, 1346, 1347, 1348, 1349, 1350, 1351, 1352, 1353, 1354, 1355, 1356, 1357, 1358, 1359, 1360, 1361, 1362, 1363, 1364, 1365, 1366, 1367, 1368, 1369, 1370, 1371, 1372, 1373, 1374, 1375, 1376, 1377, 1378, 1241, 1096, 943, 782, 613, 436, 251, 58], [188, 377, 558, 731, 896, 1053, 1202, 1343, 1476, 1477, 1478, 1479, 1480, 1481, 1482, 1483, 1484, 1485, 1486, 1487, 1488, 1489, 1490, 1491, 1492, 1493, 1494, 1495, 1496, 1497, 1498, 1499, 1500, 1501, 1502, 1503, 1504, 1505, 1506, 1507, 1508, 1379, 1242, 1097, 944, 783, 614, 437, 252, 59], [187, 376, 557, 730, 895, 1052, 1201, 1342, 1475, 1600, 1601, 1602, 1603, 1604, 1605, 1606, 1607, 1608, 1609, 1610, 1611, 1612, 1613, 1614, 1615, 1616, 1617, 1618, 1619, 1620, 1621, 1622, 1623, 1624, 1625, 1626, 1627, 1628, 1629, 1630, 1509, 1380, 1243, 1098, 945, 784, 615, 438, 253, 60], [186, 375, 556, 729, 894, 1051, 1200, 1341, 1474, 1599, 1716, 1717, 1718, 1719, 1720, 1721, 1722, 1723, 1724, 1725, 1726, 1727, 1728, 1729, 1730, 1731, 1732, 1733, 1734, 1735, 1736, 1737, 1738, 1739, 1740, 1741, 1742, 1743, 1744, 1631, 1510, 1381, 1244, 1099, 946, 785, 616, 439, 254, 61], [185, 374, 555, 728, 893, 1050, 1199, 1340, 1473, 1598, 1715, 1824, 1825, 1826, 1827, 1828, 1829, 1830, 1831, 1832, 1833, 1834, 1835, 1836, 1837, 1838, 1839, 1840, 1841, 1842, 1843, 1844, 1845, 1846, 1847, 1848, 1849, 1850, 1745, 1632, 1511, 1382, 1245, 1100, 947, 786, 617, 440, 255, 62], [184, 373, 554, 727, 892, 1049, 1198, 1339, 1472, 1597, 1714, 1823, 1924, 1925, 1926, 1927, 1928, 1929, 1930, 1931, 1932, 1933, 1934, 1935, 1936, 1937, 1938, 1939, 1940, 1941, 1942, 1943, 1944, 1945, 1946, 1947, 1948, 1851, 1746, 1633, 1512, 1383, 1246, 1101, 948, 787, 618, 441, 256, 63], [183, 372, 553, 726, 891, 1048, 1197, 1338, 1471, 1596, 1713, 1822, 1923, 2016, 2017, 2018, 2019, 2020, 2021, 2022, 2023, 2024, 2025, 2026, 2027, 2028, 2029, 2030, 2031, 2032, 2033, 2034, 2035, 2036, 2037, 2038, 1949, 1852, 1747, 1634, 1513, 1384, 1247, 1102, 949, 788, 619, 442, 257, 64], [182, 371, 552, 725, 890, 1047, 1196, 1337, 1470, 1595, 1712, 1821, 1922, 2015, 2100, 2101, 2102, 2103, 2104, 2105, 2106, 2107, 2108, 2109, 2110, 2111, 2112, 2113, 2114, 2115, 2116, 2117, 2118, 2119, 2120, 2039, 1950, 1853, 1748, 1635, 1514, 1385, 1248, 1103, 950, 789, 620, 443, 258, 65], [181, 370, 551, 724, 889, 1046, 1195, 1336, 1469, 1594, 1711, 1820, 1921, 2014, 2099, 2176, 2177, 2178, 2179, 2180, 2181, 2182, 2183, 2184, 2185, 2186, 2187, 2188, 2189, 2190, 2191, 2192, 2193, 2194, 2121, 2040, 1951, 1854, 1749, 1636, 1515, 1386, 1249, 1104, 951, 790, 621, 444, 259, 66], [180, 369, 550, 723, 888, 1045, 1194, 1335, 1468, 1593, 1710, 1819, 1920, 2013, 2098, 2175, 2244, 2245, 2246, 2247, 2248, 2249, 2250, 2251, 2252, 2253, 2254, 2255, 2256, 2257, 2258, 2259, 2260, 2195, 2122, 2041, 1952, 1855, 1750, 1637, 1516, 1387, 1250, 1105, 952, 791, 622, 445, 260, 67], [179, 368, 549, 722, 887, 1044, 1193, 1334, 1467, 1592, 1709, 1818, 1919, 2012, 2097, 2174, 2243, 2304, 2305, 2306, 2307, 2308, 2309, 2310, 2311, 2312, 2313, 2314, 2315, 2316, 2317, 2318, 2261, 2196, 2123, 2042, 1953, 1856, 1751, 1638, 1517, 1388, 1251, 1106, 953, 792, 623, 446, 261, 68], [178, 367, 548, 721, 886, 1043, 1192, 1333, 1466, 1591, 1708, 1817, 1918, 2011, 2096, 2173, 2242, 2303, 2356, 2357, 2358, 2359, 2360, 2361, 2362, 2363, 2364, 2365, 2366, 2367, 2368, 2319, 2262, 2197, 2124, 2043, 1954, 1857, 1752, 1639, 1518, 1389, 1252, 1107, 954, 793, 624, 447, 262, 69], [177, 366, 547, 720, 885, 1042, 1191, 1332, 1465, 1590, 1707, 1816, 1917, 2010, 2095, 2172, 2241, 2302, 2355, 2400, 2401, 2402, 2403, 2404, 2405, 2406, 2407, 2408, 2409, 2410, 2369, 2320, 2263, 2198, 2125, 2044, 1955, 1858, 1753, 1640, 1519, 1390, 1253, 1108, 955, 794, 625, 448, 263, 70], [176, 365, 546, 719, 884, 1041, 1190, 1331, 1464, 1589, 1706, 1815, 1916, 2009, 2094, 2171, 2240, 2301, 2354, 2399, 2436, 2437, 2438, 2439, 2440, 2441, 2442, 2443, 2444, 2411, 2370, 2321, 2264, 2199, 2126, 2045, 1956, 1859, 1754, 1641, 1520, 1391, 1254, 1109, 956, 795, 626, 449, 264, 71], [175, 364, 545, 718, 883, 1040, 1189, 1330, 1463, 1588, 1705, 1814, 1915, 2008, 2093, 2170, 2239, 2300, 2353, 2398, 2435, 2464, 2465, 2466, 2467, 2468, 2469, 2470, 2445, 2412, 2371, 2322, 2265, 2200, 2127, 2046, 1957, 1860, 1755, 1642, 1521, 1392, 1255, 1110, 957, 796, 627, 450, 265, 72], [174, 363, 544, 717, 882, 1039, 1188, 1329, 1462, 1587, 1704, 1813, 1914, 2007, 2092, 2169, 2238, 2299, 2352, 2397, 2434, 2463, 2484, 2485, 2486, 2487, 2488, 2471, 2446, 2413, 2372, 2323, 2266, 2201, 2128, 2047, 1958, 1861, 1756, 1643, 1522, 1393, 1256, 1111, 958, 797, 628, 451, 266, 73], [173, 362, 543, 716, 881, 1038, 1187, 1328, 1461, 1586, 1703, 1812, 1913, 2006, 2091, 2168, 2237, 2298, 2351, 2396, 2433, 2462, 2483, 2496, 2497, 2498, 2489, 2472, 2447, 2414, 2373, 2324, 2267, 2202, 2129, 2048, 1959, 1862, 1757, 1644, 1523, 1394, 1257, 1112, 959, 798, 629, 452, 267, 74], [172, 361, 542, 715, 880, 1037, 1186, 1327, 1460, 1585, 1702, 1811, 1912, 2005, 2090, 2167, 2236, 2297, 2350, 2395, 2432, 2461, 2482, 2495, 2500, 2499, 2490, 2473, 2448, 2415, 2374, 2325, 2268, 2203, 2130, 2049, 1960, 1863, 1758, 1645, 1524, 1395, 1258, 1113, 960, 799, 630, 453, 268, 75], [171, 360, 541, 714, 879, 1036, 1185, 1326, 1459, 1584, 1701, 1810, 1911, 2004, 2089, 2166, 2235, 2296, 2349, 2394, 2431, 2460, 2481, 2494, 2493, 2492, 2491, 2474, 2449, 2416, 2375, 2326, 2269, 2204, 2131, 2050, 1961, 1864, 1759, 1646, 1525, 1396, 1259, 1114, 961, 800, 631, 454, 269, 76], [170, 359, 540, 713, 878, 1035, 1184, 1325, 1458, 1583, 1700, 1809, 1910, 2003, 2088, 2165, 2234, 2295, 2348, 2393, 2430, 2459, 2480, 2479, 2478, 2477, 2476, 2475, 2450, 2417, 2376, 2327, 2270, 2205, 2132, 2051, 1962, 1865, 1760, 1647, 1526, 1397, 1260, 1115, 962, 801, 632, 455, 270, 77], [169, 358, 539, 712, 877, 1034, 1183, 1324, 1457, 1582, 1699, 1808, 1909, 2002, 2087, 2164, 2233, 2294, 2347, 2392, 2429, 2458, 2457, 2456, 2455, 2454, 2453, 2452, 2451, 2418, 2377, 2328, 2271, 2206, 2133, 2052, 1963, 1866, 1761, 1648, 1527, 1398, 1261, 1116, 963, 802, 633, 456, 271, 78], [168, 357, 538, 711, 876, 1033, 1182, 1323, 1456, 1581, 1698, 1807, 1908, 2001, 2086, 2163, 2232, 2293, 2346, 2391, 2428, 2427, 2426, 2425, 2424, 2423, 2422, 2421, 2420, 2419, 2378, 2329, 2272, 2207, 2134, 2053, 1964, 1867, 1762, 1649, 1528, 1399, 1262, 1117, 964, 803, 634, 457, 272, 79], [167, 356, 537, 710, 875, 1032, 1181, 1322, 1455, 1580, 1697, 1806, 1907, 2000, 2085, 2162, 2231, 2292, 2345, 2390, 2389, 2388, 2387, 2386, 2385, 2384, 2383, 2382, 2381, 2380, 2379, 2330, 2273, 2208, 2135, 2054, 1965, 1868, 1763, 1650, 1529, 1400, 1263, 1118, 965, 804, 635, 458, 273, 80], [166, 355, 536, 709, 874, 1031, 1180, 1321, 1454, 1579, 1696, 1805, 1906, 1999, 2084, 2161, 2230, 2291, 2344, 2343, 2342, 2341, 2340, 2339, 2338, 2337, 2336, 2335, 2334, 2333, 2332, 2331, 2274, 2209, 2136, 2055, 1966, 1869, 1764, 1651, 1530, 1401, 1264, 1119, 966, 805, 636, 459, 274, 81], [165, 354, 535, 708, 873, 1030, 1179, 1320, 1453, 1578, 1695, 1804, 1905, 1998, 2083, 2160, 2229, 2290, 2289, 2288, 2287, 2286, 2285, 2284, 2283, 2282, 2281, 2280, 2279, 2278, 2277, 2276, 2275, 2210, 2137, 2056, 1967, 1870, 1765, 1652, 1531, 1402, 1265, 1120, 967, 806, 637, 460, 275, 82], [164, 353, 534, 707, 872, 1029, 1178, 1319, 1452, 1577, 1694, 1803, 1904, 1997, 2082, 2159, 2228, 2227, 2226, 2225, 2224, 2223, 2222, 2221, 2220, 2219, 2218, 2217, 2216, 2215, 2214, 2213, 2212, 2211, 2138, 2057, 1968, 1871, 1766, 1653, 1532, 1403, 1266, 1121, 968, 807, 638, 461, 276, 83], [163, 352, 533, 706, 871, 1028, 1177, 1318, 1451, 1576, 1693, 1802, 1903, 1996, 2081, 2158, 2157, 2156, 2155, 2154, 2153, 2152, 2151, 2150, 2149, 2148, 2147, 2146, 2145, 2144, 2143, 2142, 2141, 2140, 2139, 2058, 1969, 1872, 1767, 1654, 1533, 1404, 1267, 1122, 969, 808, 639, 462, 277, 84], [162, 351, 532, 705, 870, 1027, 1176, 1317, 1450, 1575, 1692, 1801, 1902, 1995, 2080, 2079, 2078, 2077, 2076, 2075, 2074, 2073, 2072, 2071, 2070, 2069, 2068, 2067, 2066, 2065, 2064, 2063, 2062, 2061, 2060, 2059, 1970, 1873, 1768, 1655, 1534, 1405, 1268, 1123, 970, 809, 640, 463, 278, 85], [161, 350, 531, 704, 869, 1026, 1175, 1316, 1449, 1574, 1691, 1800, 1901, 1994, 1993, 1992, 1991, 1990, 1989, 1988, 1987, 1986, 1985, 1984, 1983, 1982, 1981, 1980, 1979, 1978, 1977, 1976, 1975, 1974, 1973, 1972, 1971, 1874, 1769, 1656, 1535, 1406, 1269, 1124, 971, 810, 641, 464, 279, 86], [160, 349, 530, 703, 868, 1025, 1174, 1315, 1448, 1573, 1690, 1799, 1900, 1899, 1898, 1897, 1896, 1895, 1894, 1893, 1892, 1891, 1890, 1889, 1888, 1887, 1886, 1885, 1884, 1883, 1882, 1881, 1880, 1879, 1878, 1877, 1876, 1875, 1770, 1657, 1536, 1407, 1270, 1125, 972, 811, 642, 465, 280, 87], [159, 348, 529, 702, 867, 1024, 1173, 1314, 1447, 1572, 1689, 1798, 1797, 1796, 1795, 1794, 1793, 1792, 1791, 1790, 1789, 1788, 1787, 1786, 1785, 1784, 1783, 1782, 1781, 1780, 1779, 1778, 1777, 1776, 1775, 1774, 1773, 1772, 1771, 1658, 1537, 1408, 1271, 1126, 973, 812, 643, 466, 281, 88], [158, 347, 528, 701, 866, 1023, 1172, 1313, 1446, 1571, 1688, 1687, 1686, 1685, 1684, 1683, 1682, 1681, 1680, 1679, 1678, 1677, 1676, 1675, 1674, 1673, 1672, 1671, 1670, 1669, 1668, 1667, 1666, 1665, 1664, 1663, 1662, 1661, 1660, 1659, 1538, 1409, 1272, 1127, 974, 813, 644, 467, 282, 89], [157, 346, 527, 700, 865, 1022, 1171, 1312, 1445, 1570, 1569, 1568, 1567, 1566, 1565, 1564, 1563, 1562, 1561, 1560, 1559, 1558, 1557, 1556, 1555, 1554, 1553, 1552, 1551, 1550, 1549, 1548, 1547, 1546, 1545, 1544, 1543, 1542, 1541, 1540, 1539, 1410, 1273, 1128, 975, 814, 645, 468, 283, 90], [156, 345, 526, 699, 864, 1021, 1170, 1311, 1444, 1443, 1442, 1441, 1440, 1439, 1438, 1437, 1436, 1435, 1434, 1433, 1432, 1431, 1430, 1429, 1428, 1427, 1426, 1425, 1424, 1423, 1422, 1421, 1420, 1419, 1418, 1417, 1416, 1415, 1414, 1413, 1412, 1411, 1274, 1129, 976, 815, 646, 469, 284, 91], [155, 344, 525, 698, 863, 1020, 1169, 1310, 1309, 1308, 1307, 1306, 1305, 1304, 1303, 1302, 1301, 1300, 1299, 1298, 1297, 1296, 1295, 1294, 1293, 1292, 1291, 1290, 1289, 1288, 1287, 1286, 1285, 1284, 1283, 1282, 1281, 1280, 1279, 1278, 1277, 1276, 1275, 1130, 977, 816, 647, 470, 285, 92], [154, 343, 524, 697, 862, 1019, 1168, 1167, 1166, 1165, 1164, 1163, 1162, 1161, 1160, 1159, 1158, 1157, 1156, 1155, 1154, 1153, 1152, 1151, 1150, 1149, 1148, 1147, 1146, 1145, 1144, 1143, 1142, 1141, 1140, 1139, 1138, 1137, 1136, 1135, 1134, 1133, 1132, 1131, 978, 817, 648, 471, 286, 93], [153, 342, 523, 696, 861, 1018, 1017, 1016, 1015, 1014, 1013, 1012, 1011, 1010, 1009, 1008, 1007, 1006, 1005, 1004, 1003, 1002, 1001, 1000, 999, 998, 997, 996, 995, 994, 993, 992, 991, 990, 989, 988, 987, 986, 985, 984, 983, 982, 981, 980, 979, 818, 649, 472, 287, 94], [152, 341, 522, 695, 860, 859, 858, 857, 856, 855, 854, 853, 852, 851, 850, 849, 848, 847, 846, 845, 844, 843, 842, 841, 840, 839, 838, 837, 836, 835, 834, 833, 832, 831, 830, 829, 828, 827, 826, 825, 824, 823, 822, 821, 820, 819, 650, 473, 288, 95], [151, 340, 521, 694, 693, 692, 691, 690, 689, 688, 687, 686, 685, 684, 683, 682, 681, 680, 679, 678, 677, 676, 675, 674, 673, 672, 671, 670, 669, 668, 667, 666, 665, 664, 663, 662, 661, 660, 659, 658, 657, 656, 655, 654, 653, 652, 651, 474, 289, 96], [150, 339, 520, 519, 518, 517, 516, 515, 514, 513, 512, 511, 510, 509, 508, 507, 506, 505, 504, 503, 502, 501, 500, 499, 498, 497, 496, 495, 494, 493, 492, 491, 490, 489, 488, 487, 486, 485, 484, 483, 482, 481, 480, 479, 478, 477, 476, 475, 290, 97], [149, 338, 337, 336, 335, 334, 333, 332, 331, 330, 329, 328, 327, 326, 325, 324, 323, 322, 321, 320, 319, 318, 317, 316, 315, 314, 313, 312, 311, 310, 309, 308, 307, 306, 305, 304, 303, 302, 301, 300, 299, 298, 297, 296, 295, 294, 293, 292, 291, 98], [148, 147, 146, 145, 144, 143, 142, 141, 140, 139, 138, 137, 136, 135, 134, 133, 132, 131, 130, 129, 128, 127, 126, 125, 124, 123, 122, 121, 120, 119, 118, 117, 116, 115, 114, 113, 112, 111, 110, 109, 108, 107, 106, 105, 104, 103, 102, 101, 100, 99]]\n    assert candidate(3) == [[1, 2, 3], [8, 9, 4], [7, 6, 5]]\n    assert candidate(0) == []\n    assert candidate(4) == [[1, 2, 3, 4], [12, 13, 14, 5], [11, 16, 15, 6], [10, 9, 8, 7]]\n    assert candidate(-5) == []\n", "language": "python"}
{"task_id": "3ad63291-f4fe-403a-aa0c-a07aac49f8b7-2153856718424531705", "prompt": "Could you finish this function based on the docstring? Please write the complete implementation in one code block.\n\n```python\nfrom typing import List\n\ndef optimize_wind_farm(turbines: List[int], max_power: int) -> int:\n    \"\"\"\n    A wind farm engineer is tasked with optimizing the power output of a wind farm.\n    The farm consists of a line of wind turbines, each with a different power output.\n    The engineer can choose to activate any contiguous subset of turbines,\n    but the total power output must not exceed a given maximum.\n\n    This function takes a list of turbine power outputs and the maximum allowed\n    power, and returns the length of the longest contiguous subset of turbines\n    that can be activated without exceeding the maximum power.\n\n\n    [EXAMPLES]\n    \n    assert candidate([1, 1, 1, 1, 1], 3) == 3\n    assert candidate([1000000, 1000000, 1000000], 2000000) == 2\n\n    [/EXAMPLES]\n    \"\"\"\n```\n", "entry_point": "optimize_wind_farm", "solution": "from typing import List\n\ndef optimize_wind_farm(turbines: List[int], max_power: int) -> int:\n    \"\"\"\n    A wind farm engineer is tasked with optimizing the power output of a wind farm.\n    The farm consists of a line of wind turbines, each with a different power output.\n    The engineer can choose to activate any contiguous subset of turbines,\n    but the total power output must not exceed a given maximum.\n\n    This function takes a list of turbine power outputs and the maximum allowed\n    power, and returns the length of the longest contiguous subset of turbines\n    that can be activated without exceeding the maximum power.\n\n\n    [EXAMPLES]\n    \n    assert candidate([1, 1, 1, 1, 1], 3) == 3\n    assert candidate([1000000, 1000000, 1000000], 2000000) == 2\n\n    [/EXAMPLES]\n    \"\"\"\n    n = len(turbines)\n    start = 0\n    end = 0\n    current_sum = 0\n    max_length = 0\n\n    while end < n:\n        # Add the current turbine to the sum\n        current_sum += turbines[end]\n\n        # If the sum exceeds max_power, move the start pointer\n        while current_sum > max_power and start <= end:\n            current_sum -= turbines[start]\n            start += 1\n\n        # Update the max_length if the current window is larger\n        max_length = max(max_length, end - start + 1)\n\n        # Move the end pointer\n        end += 1\n\n    return max_length\n\n", "test": "def check(candidate):\n    assert candidate([1, 2, 3, 4, 5, 6, 7, 8, 9, 10], 30) == 7\n    assert candidate([1, 1, 1, 1, 1, 1, 1, 1, 1, 1], 5) == 5\n    assert candidate([1, 1, 1, 1, 1], 3) == 3\n    assert candidate([1000000, 1000000, 1000000], 2000000) == 2\n    assert candidate([1, 2, 3, 4, 5], 15) == 5\n    assert candidate([100, 1, 1, 1, 100], 3) == 3\n    assert candidate([100, 200, 300, 400, 500], 1000) == 4\n    assert candidate([5, 4, 3, 2, 1], 5) == 2\n    assert candidate([1, 2, 3, 4, 5, 4, 3, 2, 1], 10) == 4\n    assert candidate([5, 5, 5, 5, 5], 20) == 4\n", "language": "python"}
{"task_id": "a50dcbf9-3435-4b6f-a11b-aa3c1a0890847971309279572858744", "prompt": "Based on the documentation provided, I'll complete the function implementation. The full code will be presented in a single block.\n\n```python\nfrom typing import List, Set\n\ndef critical_network_nodes(nodes: int, connections: List[List[int]]) -> Set[int]:\n    \"\"\"\n    You're a network engineer tasked with identifying critical nodes in a computer network.\n    The network consists of several nodes connected by bidirectional links.\n    A critical node is one that, if removed, would disconnect the entire network.\n\n    This function takes the number of nodes and a list of connections (where each connection\n    is represented by a pair of node IDs), and returns a set of all critical nodes in the network.\n\n    The function uses depth-first search and articulation point algorithm to identify critical nodes.\n\n\n    [EXAMPLES]\n    \n    assert candidate(7, [[0,1],[1,2],[2,3],[3,4],[4,5],[5,6],[6,0],[0,3],[1,4],[2,5]]) == set()\n    assert candidate(5, [[0,1],[1,2],[2,3],[3,4]]) == {1, 2, 3}\n\n    [/EXAMPLES]\n    \"\"\"\n```\n", "entry_point": "critical_network_nodes", "solution": "from typing import List, Set\n\ndef critical_network_nodes(nodes: int, connections: List[List[int]]) -> Set[int]:\n    \"\"\"\n    You're a network engineer tasked with identifying critical nodes in a computer network.\n    The network consists of several nodes connected by bidirectional links.\n    A critical node is one that, if removed, would disconnect the entire network.\n\n    This function takes the number of nodes and a list of connections (where each connection\n    is represented by a pair of node IDs), and returns a set of all critical nodes in the network.\n\n    The function uses depth-first search and articulation point algorithm to identify critical nodes.\n\n\n    [EXAMPLES]\n    \n    assert candidate(7, [[0,1],[1,2],[2,3],[3,4],[4,5],[5,6],[6,0],[0,3],[1,4],[2,5]]) == set()\n    assert candidate(5, [[0,1],[1,2],[2,3],[3,4]]) == {1, 2, 3}\n\n    [/EXAMPLES]\n    \"\"\"\n    def dfs(node: int, parent: int, low: List[int], disc: List[int], ap: Set[int]):\n        nonlocal time\n        children = 0\n        disc[node] = low[node] = time\n        time += 1\n\n        for neighbor in graph[node]:\n            if disc[neighbor] == -1:\n                children += 1\n                dfs(neighbor, node, low, disc, ap)\n                low[node] = min(low[node], low[neighbor])\n\n                if parent != -1 and low[neighbor] >= disc[node]:\n                    ap.add(node)\n                elif parent == -1 and children > 1:\n                    ap.add(node)\n            elif neighbor != parent:\n                low[node] = min(low[node], disc[neighbor])\n\n    graph = {i: [] for i in range(nodes)}\n    for u, v in connections:\n        graph[u].append(v)\n        graph[v].append(u)\n\n    low = [-1] * nodes\n    disc = [-1] * nodes\n    ap = set()\n    time = 0\n\n    for i in range(nodes):\n        if disc[i] == -1:\n            dfs(i, -1, low, disc, ap)\n\n    return ap\n\n", "test": "def check(candidate):\n    assert candidate(8, [[0,1],[1,2],[2,3],[3,4],[4,5],[5,6],[6,7],[7,0],[0,4]]) == set()\n    assert candidate(4, [[0,1],[0,2],[0,3],[1,2],[1,3],[2,3]]) == set()\n    assert candidate(5, [[0,1],[1,2],[2,3],[3,4]]) == {1, 2, 3}\n    assert candidate(4, [[0,1],[1,2],[2,3],[3,0]]) == set()\n    assert candidate(3, [[0,1],[1,2]]) == {1}\n    assert candidate(1, []) == set()\n    assert candidate(7, [[0,1],[1,2],[2,3],[3,4],[4,5],[5,6],[6,0],[0,3],[1,4],[2,5]]) == set()\n    assert candidate(6, [[0,1],[1,2],[2,3],[3,4],[4,5],[5,0],[0,3]]) == set()\n    assert candidate(6, [[0,1],[1,2],[2,3],[3,4],[4,5],[5,0],[0,2],[1,3],[2,4],[3,5]]) == set()\n    assert candidate(5, [[0,1],[1,2],[2,0],[1,3],[3,4]]) == {1, 3}\n", "language": "python"}
{"task_id": "77407aa1-b468-45b9-a316-d6182c83e26b-8984717454585873904", "prompt": "Write the implementation for the function that fulfills the requirements in the doc string. Don't modify the function name or parameters. Present the complete function in a single code block.\n\n```python\ndef word_pattern_match(pattern: str, text: str) -> bool:\n    \"\"\"\n    In cryptography, pattern matching is crucial for decoding messages. This function determines if a given\n    text follows a specific pattern.\n\n    The function takes two strings as input: a pattern string and a text string. It returns True if the text\n    follows the pattern, and False otherwise. Each character in the pattern should map to a unique word in the text,\n    and each word should map to a unique character in the pattern.\n\n    This function utilizes string manipulation and dictionary operations for pattern matching.\n\n\n    [EXAMPLES]\n    \n    assert candidate(\"abba\", \"dog dog dog dog\") == False\n    assert candidate(\"abcba\", \"foo bar baz bar foo\") == True\n\n    [/EXAMPLES]\n    \"\"\"\n```\n", "entry_point": "word_pattern_match", "solution": "def word_pattern_match(pattern: str, text: str) -> bool:\n    \"\"\"\n    In cryptography, pattern matching is crucial for decoding messages. This function determines if a given\n    text follows a specific pattern.\n\n    The function takes two strings as input: a pattern string and a text string. It returns True if the text\n    follows the pattern, and False otherwise. Each character in the pattern should map to a unique word in the text,\n    and each word should map to a unique character in the pattern.\n\n    This function utilizes string manipulation and dictionary operations for pattern matching.\n\n\n    [EXAMPLES]\n    \n    assert candidate(\"abba\", \"dog dog dog dog\") == False\n    assert candidate(\"abcba\", \"foo bar baz bar foo\") == True\n\n    [/EXAMPLES]\n    \"\"\"\n    def split_text(text: str) -> list:\n        return text.split()\n\n    words = split_text(text)\n    \n    if len(pattern) != len(words):\n        return False\n    \n    char_to_word = {}\n    word_to_char = {}\n    \n    for char, word in zip(pattern, words):\n        if char in char_to_word:\n            if char_to_word[char] != word:\n                return False\n        else:\n            if word in word_to_char:\n                return False\n            char_to_word[char] = word\n            word_to_char[word] = char\n    \n    return True\n\n", "test": "def check(candidate):\n    assert candidate(\"ab\", \"cat cat\") == False\n    assert candidate(\"\", \"\") == True\n    assert candidate(\"\", \"word\") == False\n    assert candidate(\"abba\", \"dog cat cat   dog\") == True\n    assert candidate(\"abcba\", \"foo bar baz bar foo\") == True\n    assert candidate(\"abcdefghijklmnopqrstuvwxyz\", \"the quick brown fox jumps over the lazy dog\") == False\n    assert candidate(\"aba\", \"cat dog cat\") == True\n    assert candidate(\"abcde\", \"one two three four five\") == True\n    assert candidate(\"abba\", \"dog cat cat dog\") == True\n    assert candidate(\"abba\", \"dog dog dog dog\") == False\n", "language": "python"}
{"task_id": "615ecdde-a7e2-4515-b6cb-15607504d6a2-8663741963660874910", "prompt": "Based on the docstring, I'll complete the function below. The code will be presented in one block and will account for all potential edge cases.\n\n```python\nfrom typing import List\n\ndef calculate_water_flow(heights: List[int]) -> int:\n    \"\"\"\n    In a mountainous region, there are several peaks of varying heights. When it rains, water flows down the mountains\n    and collects in the valleys between the peaks. Your task is to calculate the total amount of water that can be\n    trapped between the peaks after a heavy rainfall.\n\n    The heights of the peaks are represented by a list of integers, where each integer represents the height of a\n    peak at that position. Water can be trapped between two peaks if there are lower peaks between them.\n\n\n    [EXAMPLES]\n    \n    assert candidate([3, 0, 0, 3]) == 6\n    assert candidate([3, 0, 3]) == 3\n\n    [/EXAMPLES]\n    \"\"\"\n```\n", "entry_point": "calculate_water_flow", "solution": "from typing import List\n\ndef calculate_water_flow(heights: List[int]) -> int:\n    \"\"\"\n    In a mountainous region, there are several peaks of varying heights. When it rains, water flows down the mountains\n    and collects in the valleys between the peaks. Your task is to calculate the total amount of water that can be\n    trapped between the peaks after a heavy rainfall.\n\n    The heights of the peaks are represented by a list of integers, where each integer represents the height of a\n    peak at that position. Water can be trapped between two peaks if there are lower peaks between them.\n\n\n    [EXAMPLES]\n    \n    assert candidate([3, 0, 0, 3]) == 6\n    assert candidate([3, 0, 3]) == 3\n\n    [/EXAMPLES]\n    \"\"\"\n    if not heights:\n        return 0\n\n    n = len(heights)\n    left_max = [0] * n\n    right_max = [0] * n\n    water = 0\n\n    # Calculate the maximum height to the left of each position\n    left_max[0] = heights[0]\n    for i in range(1, n):\n        left_max[i] = max(left_max[i-1], heights[i])\n\n    # Calculate the maximum height to the right of each position\n    right_max[n-1] = heights[n-1]\n    for i in range(n-2, -1, -1):\n        right_max[i] = max(right_max[i+1], heights[i])\n\n    # Calculate the amount of water trapped at each position\n    for i in range(n):\n        water_level = min(left_max[i], right_max[i])\n        if water_level > heights[i]:\n            water += water_level - heights[i]\n\n    return water\n\n", "test": "def check(candidate):\n    assert candidate([5, 2, 1, 2, 1, 5]) == 14\n    assert candidate([0, 0, 0]) == 0\n    assert candidate([1, 1, 1, 1]) == 0\n    assert candidate([3, 0, 3]) == 3\n    assert candidate([9, 6, 8, 8, 5, 6, 3]) == 3\n    assert candidate([3, 0, 0, 3]) == 6\n    assert candidate([1, 2, 1, 2, 1]) == 1\n    assert candidate([7, 0, 4, 2, 5, 0, 6, 4, 0, 5]) == 25\n    assert candidate([5, 4, 3, 2, 1, 2, 3, 4, 5]) == 16\n    assert candidate([1, 2, 3, 4, 5]) == 0\n", "language": "python"}
{"task_id": "70b2080d-42e4-4a9e-829c-8cc5f40cd5b33174873963425969167", "prompt": "Complete the function following the doc string. Provide a single code block with the implementation, keeping the function name and parameters unchanged.\n\n```python\nfrom typing import List, Tuple\n\ndef optimize_martian_greenhouse(crops: List[str], yields: List[int], water_usage: List[int], available_water: int) -> Tuple[List[str], int]:\n    \"\"\"\n    You are a botanist on the first Mars colony, tasked with maximizing food production in the Martian greenhouse. You have a list of potential crops, their respective yields (in kg per square meter), and their water usage (in liters per square meter). Given the limited water supply available, you need to determine the optimal combination of crops to maximize total yield.\n\n    Write a function that takes the following inputs:\n    - A list of crop names\n    - A list of corresponding crop yields\n    - A list of corresponding water usage for each crop\n    - The total available water supply\n\n    The function should return a tuple containing:\n    - A list of the selected crops that maximize yield while staying within the water constraint\n    - The total yield of the selected crops\n\n    Assume each crop can only be planted once, and you must use whole numbers of crops (no fractional planting).\n\n\n    [EXAMPLES]\n    \n    assert candidate([\"Tomato\", \"Potato\", \"Carrot\"], [5, 4, 3], [3, 2, 1], 10) == (['Tomato', 'Potato', 'Carrot'], 12)\n    assert candidate([\"A\", \"B\", \"C\", \"D\"], [10, 20, 30, 40], [25, 35, 45, 55], 100) == (['C', 'D'], 70)\n\n    [/EXAMPLES]\n    \"\"\"\n```\n", "entry_point": "optimize_martian_greenhouse", "solution": "from typing import List, Tuple\n\ndef optimize_martian_greenhouse(crops: List[str], yields: List[int], water_usage: List[int], available_water: int) -> Tuple[List[str], int]:\n    \"\"\"\n    You are a botanist on the first Mars colony, tasked with maximizing food production in the Martian greenhouse. You have a list of potential crops, their respective yields (in kg per square meter), and their water usage (in liters per square meter). Given the limited water supply available, you need to determine the optimal combination of crops to maximize total yield.\n\n    Write a function that takes the following inputs:\n    - A list of crop names\n    - A list of corresponding crop yields\n    - A list of corresponding water usage for each crop\n    - The total available water supply\n\n    The function should return a tuple containing:\n    - A list of the selected crops that maximize yield while staying within the water constraint\n    - The total yield of the selected crops\n\n    Assume each crop can only be planted once, and you must use whole numbers of crops (no fractional planting).\n\n\n    [EXAMPLES]\n    \n    assert candidate([\"Tomato\", \"Potato\", \"Carrot\"], [5, 4, 3], [3, 2, 1], 10) == (['Tomato', 'Potato', 'Carrot'], 12)\n    assert candidate([\"A\", \"B\", \"C\", \"D\"], [10, 20, 30, 40], [25, 35, 45, 55], 100) == (['C', 'D'], 70)\n\n    [/EXAMPLES]\n    \"\"\"\n    n = len(crops)\n    \n    # Create a 2D table for dynamic programming\n    dp = [[0] * (available_water + 1) for _ in range(n + 1)]\n    \n    # Fill the dp table\n    for i in range(1, n + 1):\n        for w in range(available_water + 1):\n            if water_usage[i-1] <= w:\n                dp[i][w] = max(dp[i-1][w], dp[i-1][w-water_usage[i-1]] + yields[i-1])\n            else:\n                dp[i][w] = dp[i-1][w]\n    \n    # Backtrack to find the selected crops\n    selected_crops = []\n    w = available_water\n    for i in range(n, 0, -1):\n        if dp[i][w] != dp[i-1][w]:\n            selected_crops.append(crops[i-1])\n            w -= water_usage[i-1]\n    \n    selected_crops.reverse()  # Reverse to get the correct order\n    \n    return (selected_crops, dp[n][available_water])\n\n", "test": "def check(candidate):\n    assert candidate([\"A\", \"B\", \"C\", \"D\", \"E\"], [1, 1, 1, 1, 1], [1, 1, 1, 1, 1], 5) == (['A', 'B', 'C', 'D', 'E'], 5)\n    assert candidate([\"Crop X\", \"Crop Y\"], [1000000, 1000001], [1000000, 1000001], 2000000) == (['Crop Y'], 1000001)\n    assert candidate([\"Crop A\", \"Crop B\"], [1000, 999], [1000, 999], 1000) == (['Crop A'], 1000)\n    assert candidate([\"A\", \"B\", \"C\"], [1, 2, 3], [1, 2, 3], 6) == (['A', 'B', 'C'], 6)\n    assert candidate([\"X\", \"Y\", \"Z\"], [10, 10, 10], [5, 5, 5], 15) == (['X', 'Y', 'Z'], 30)\n    assert candidate([\"A\", \"B\", \"C\", \"D\"], [10, 20, 30, 40], [25, 35, 45, 55], 100) == (['C', 'D'], 70)\n    assert candidate([\"Crop1\", \"Crop2\"], [1, 2], [2, 1], 3) == (['Crop1', 'Crop2'], 3)\n    assert candidate([\"Crop1\", \"Crop2\"], [10, 5], [5, 3], 100) == (['Crop1', 'Crop2'], 15)\n    assert candidate([\"Tomato\", \"Potato\", \"Carrot\"], [5, 4, 3], [3, 2, 1], 10) == (['Tomato', 'Potato', 'Carrot'], 12)\n    assert candidate([\"X\", \"Y\", \"Z\"], [100, 200, 300], [50, 100, 150], 300) == (['X', 'Y', 'Z'], 600)\n", "language": "python"}
{"task_id": "d92cfbd8-4446-435f-8d55-aac7d58d33f1-6531331098899900644", "prompt": "Your job is to fill in the given function to make it ready for execution in a single block. Don't write any code outside the function definition. Limit yourself to the libraries that are already imported. Any additional functions or classes must be defined within the main function.\n\n```python\ndef ancient_egyptian_multiplication(a: int, b: int) -> int:\n    \"\"\"\n    Ancient Egyptians used a method of multiplication that only involved doubling, halving, and adding.\n    This function implements the ancient Egyptian multiplication algorithm to multiply two positive integers.\n\n    The algorithm works by repeatedly halving one number and doubling the other, then summing the doublings\n    corresponding to the odd halvings.\n\n\n    [EXAMPLES]\n    \n    assert candidate(0, 5) == 0\n    assert candidate(10, 10) == 100\n\n    [/EXAMPLES]\n    \"\"\"\n```\n", "entry_point": "ancient_egyptian_multiplication", "solution": "def ancient_egyptian_multiplication(a: int, b: int) -> int:\n    \"\"\"\n    Ancient Egyptians used a method of multiplication that only involved doubling, halving, and adding.\n    This function implements the ancient Egyptian multiplication algorithm to multiply two positive integers.\n\n    The algorithm works by repeatedly halving one number and doubling the other, then summing the doublings\n    corresponding to the odd halvings.\n\n\n    [EXAMPLES]\n    \n    assert candidate(0, 5) == 0\n    assert candidate(10, 10) == 100\n\n    [/EXAMPLES]\n    \"\"\"\n    def double(n: int) -> int:\n        return n << 1\n\n    def halve(n: int) -> int:\n        return n >> 1\n\n    def is_odd(n: int) -> bool:\n        return n & 1 == 1\n\n    # Ensure a is the smaller number\n    if a > b:\n        a, b = b, a\n\n    result = 0\n    while a > 0:\n        if is_odd(a):\n            result += b\n        a = halve(a)\n        b = double(b)\n\n    return result\n\n", "test": "def check(candidate):\n    assert candidate(99, 99) == 9801\n    assert candidate(8, 125) == 1000\n    assert candidate(0, 5) == 0\n    assert candidate(1000, 2) == 2000\n    assert candidate(33, 3) == 99\n    assert candidate(50, 50) == 2500\n    assert candidate(100, 1) == 100\n    assert candidate(10, 10) == 100\n    assert candidate(1, 100) == 100\n    assert candidate(5, 0) == 0\n", "language": "python"}
{"task_id": "324843db-cd66-4b50-afb7-aefe1998b1c76914700938659548307", "prompt": "Acting as your coding assistant, I'll complete functions that are immediately executable. I'll stay within the function's scope, use only pre-imported libraries, and nest any additional helper functions or classes inside the main function you provide.\n\n```python\ndef calculate_water_bill(consumption: int) -> float:\n    \"\"\"\n    A water utility company needs to calculate bills for its customers based on their water consumption.\n    The billing rules are as follows:\n    - First 10 units: $1 per unit\n    - Next 20 units: $1.5 per unit\n    - Next 30 units: $2 per unit\n    - Above 60 units: $3 per unit\n\n    Args:\n    consumption (int): The total water consumption in units.\n\n    Returns:\n    float: The total water bill amount.\n\n\n    [EXAMPLES]\n    \n    assert candidate(60) == 100.0\n    assert candidate(200) == 520.0\n\n    [/EXAMPLES]\n    \"\"\"\n```\n", "entry_point": "calculate_water_bill", "solution": "def calculate_water_bill(consumption: int) -> float:\n    \"\"\"\n    A water utility company needs to calculate bills for its customers based on their water consumption.\n    The billing rules are as follows:\n    - First 10 units: $1 per unit\n    - Next 20 units: $1.5 per unit\n    - Next 30 units: $2 per unit\n    - Above 60 units: $3 per unit\n\n    Args:\n    consumption (int): The total water consumption in units.\n\n    Returns:\n    float: The total water bill amount.\n\n\n    [EXAMPLES]\n    \n    assert candidate(60) == 100.0\n    assert candidate(200) == 520.0\n\n    [/EXAMPLES]\n    \"\"\"\n    bill = 0.0\n    \n    # First 10 units\n    if consumption <= 10:\n        bill = consumption * 1.0\n    else:\n        bill += 10 * 1.0\n        remaining = consumption - 10\n        \n        # Next 20 units\n        if remaining <= 20:\n            bill += remaining * 1.5\n        else:\n            bill += 20 * 1.5\n            remaining -= 20\n            \n            # Next 30 units\n            if remaining <= 30:\n                bill += remaining * 2.0\n            else:\n                bill += 30 * 2.0\n                remaining -= 30\n                \n                # Above 60 units\n                bill += remaining * 3.0\n    \n    return bill\n\n", "test": "def check(candidate):\n    assert candidate(10) == 10\n    assert candidate(61) == 103.0\n    assert candidate(50) == 80.0\n    assert candidate(31) == 42.0\n    assert candidate(80) == 160.0\n    assert candidate(0) == 0\n    assert candidate(40) == 60.0\n    assert candidate(200) == 520.0\n    assert candidate(60) == 100.0\n    assert candidate(20) == 25.0\n", "language": "python"}
{"task_id": "1aba6423-faea-4708-ad6b-d321f39ec707-1159649769738752377", "prompt": "You are a coding assistant. Your task is to complete a provided function in an executable manner within a code block. All code must remain within the function scope. Utilize only libraries that are imported in the problem description. Any additional functions or classes must be defined inside the given function.\n\n```python\nfrom typing import List, Tuple\n\ndef analyze_stock_prices(prices: List[float]) -> Tuple[float, float, int, int]:\n    \"\"\"\n    Analyzes a series of stock prices to find the best time to buy and sell for maximum profit.\n\n    This function takes a list of stock prices, where each price represents the stock value at\n    the end of each day. It determines the maximum profit that could be made by buying on one\n    day and selling on a later day, as well as the days to perform these actions.\n\n    Args:\n    prices (List[float]): A list of stock prices, where prices[i] is the price on the i-th day.\n\n    Returns:\n    Tuple[float, float, int, int]: A tuple containing (max_profit, buy_price, buy_day, sell_day).\n        max_profit: The maximum profit that could be made.\n        buy_price: The price at which the stock should be bought.\n        buy_day: The day on which to buy (0-indexed).\n        sell_day: The day on which to sell (0-indexed).\n\n\n    [EXAMPLES]\n    \n    assert candidate([1.5, 2.5, 3.5, 2.5, 1.5]) == (2.0, 1.5, 0, 2)\n    assert candidate([1.0, 1.0, 1.0, 1.0, 1.0]) == (0.0, 1.0, 0, 0)\n\n    [/EXAMPLES]\n    \"\"\"\n```\n", "entry_point": "analyze_stock_prices", "solution": "from typing import List, Tuple\n\ndef analyze_stock_prices(prices: List[float]) -> Tuple[float, float, int, int]:\n    \"\"\"\n    Analyzes a series of stock prices to find the best time to buy and sell for maximum profit.\n\n    This function takes a list of stock prices, where each price represents the stock value at\n    the end of each day. It determines the maximum profit that could be made by buying on one\n    day and selling on a later day, as well as the days to perform these actions.\n\n    Args:\n    prices (List[float]): A list of stock prices, where prices[i] is the price on the i-th day.\n\n    Returns:\n    Tuple[float, float, int, int]: A tuple containing (max_profit, buy_price, buy_day, sell_day).\n        max_profit: The maximum profit that could be made.\n        buy_price: The price at which the stock should be bought.\n        buy_day: The day on which to buy (0-indexed).\n        sell_day: The day on which to sell (0-indexed).\n\n\n    [EXAMPLES]\n    \n    assert candidate([1.5, 2.5, 3.5, 2.5, 1.5]) == (2.0, 1.5, 0, 2)\n    assert candidate([1.0, 1.0, 1.0, 1.0, 1.0]) == (0.0, 1.0, 0, 0)\n\n    [/EXAMPLES]\n    \"\"\"\n    if len(prices) < 2:\n        return (0.0, prices[0] if prices else 0.0, 0, 0)\n\n    max_profit = 0.0\n    min_price = float('inf')\n    min_day = 0\n    buy_day = 0\n    sell_day = 0\n\n    for current_day, price in enumerate(prices):\n        if price < min_price:\n            min_price = price\n            min_day = current_day\n\n        current_profit = price - min_price\n        if current_profit > max_profit:\n            max_profit = current_profit\n            buy_day = min_day\n            sell_day = current_day\n\n    return (max_profit, prices[buy_day], buy_day, sell_day)\n\n", "test": "def check(candidate):\n    assert candidate([0.01, 0.02, 0.03, 0.02, 0.01]) == (0.019999999999999997, 0.01, 0, 2)\n    assert candidate([1.0]) == (0.0, 1.0, 0, 0)\n    assert candidate([100.0, 180.0, 260.0, 310.0, 40.0, 535.0, 695.0]) == (655.0, 40.0, 4, 6)\n    assert candidate([50.0, 25.0, 12.5, 6.25, 3.125]) == (0.0, 50.0, 0, 0)\n    assert candidate([100.0, 90.0, 80.0, 70.0, 60.0, 50.0]) == (0.0, 100.0, 0, 0)\n    assert candidate([5.0, 4.0, 3.0, 2.0, 1.0]) == (0.0, 5.0, 0, 0)\n    assert candidate([1000000.0, 999999.0, 999998.0, 1000001.0]) == (3.0, 999998.0, 2, 3)\n    assert candidate([1.0, 1.0, 1.0, 1.0, 1.0]) == (0.0, 1.0, 0, 0)\n    assert candidate([1.5, 2.5, 3.5, 2.5, 1.5]) == (2.0, 1.5, 0, 2)\n    assert candidate([0.1, 0.2, 0.3, 0.4, 0.5]) == (0.4, 0.1, 0, 4)\n", "language": "python"}
{"task_id": "03ac3aeb-1ac3-4b67-9483-9d8a0800cbee912632470756355270", "prompt": "I'll implement a function that can be executed as-is within a single code block. My solution will be self-contained, using only the libraries imported in the original problem. Any additional functionality will be defined within the main function through inner functions or classes.\n\n```python\nimport re\nfrom typing import List, Tuple\n\ndef parse_dna_sequence(sequence: str, motifs: List[str]) -> List[Tuple[str, List[int]]]:\n    \"\"\"Parse a DNA sequence to find specific motifs and their positions.\n\n    Given a DNA sequence and a list of motifs (short sequences), find all occurrences of each motif\n    in the DNA sequence. The search should be case-insensitive and allow for overlapping matches.\n    Return a list of tuples, each containing a motif and a list of its starting positions in the sequence.\n\n    Args:\n    sequence (str): A string representing the DNA sequence (containing only A, T, C, G).\n    motifs (List[str]): A list of motifs to search for in the sequence.\n\n    Returns:\n    List[Tuple[str, List[int]]]: A list of tuples, each containing a motif and its positions.\n\n\n    [EXAMPLES]\n    \n    assert candidate(\"ACTGACTGACTG\", [\"ACT\", \"CTG\", \"TGA\"]) == [('ACT', [0, 4, 8]), ('CTG', [1, 5, 9]), ('TGA', [2, 6])]\n    assert candidate(\"GATTACA\", [\"GAT\", \"ATT\", \"TTA\", \"TAC\", \"ACA\"]) == [('GAT', [0]), ('ATT', [1]), ('TTA', [2]), ('TAC', [3]), ('ACA', [4])]\n\n    [/EXAMPLES]\n    \"\"\"\n```\n", "entry_point": "parse_dna_sequence", "solution": "import re\nfrom typing import List, Tuple\n\ndef parse_dna_sequence(sequence: str, motifs: List[str]) -> List[Tuple[str, List[int]]]:\n    \"\"\"Parse a DNA sequence to find specific motifs and their positions.\n\n    Given a DNA sequence and a list of motifs (short sequences), find all occurrences of each motif\n    in the DNA sequence. The search should be case-insensitive and allow for overlapping matches.\n    Return a list of tuples, each containing a motif and a list of its starting positions in the sequence.\n\n    Args:\n    sequence (str): A string representing the DNA sequence (containing only A, T, C, G).\n    motifs (List[str]): A list of motifs to search for in the sequence.\n\n    Returns:\n    List[Tuple[str, List[int]]]: A list of tuples, each containing a motif and its positions.\n\n\n    [EXAMPLES]\n    \n    assert candidate(\"ACTGACTGACTG\", [\"ACT\", \"CTG\", \"TGA\"]) == [('ACT', [0, 4, 8]), ('CTG', [1, 5, 9]), ('TGA', [2, 6])]\n    assert candidate(\"GATTACA\", [\"GAT\", \"ATT\", \"TTA\", \"TAC\", \"ACA\"]) == [('GAT', [0]), ('ATT', [1]), ('TTA', [2]), ('TAC', [3]), ('ACA', [4])]\n\n    [/EXAMPLES]\n    \"\"\"\n    result = []\n    \n    for motif in motifs:\n        positions = []\n        # Use case-insensitive regex with positive lookahead for overlapping matches\n        pattern = f'(?=({re.escape(motif)}))'\n        for match in re.finditer(pattern, sequence, re.IGNORECASE):\n            positions.append(match.start())\n        \n        if positions:\n            result.append((motif, positions))\n    \n    return result\n\n", "test": "def check(candidate):\n    assert candidate(\"ATATATATATAT\", [\"ATA\", \"TAT\"]) == [('ATA', [0, 2, 4, 6, 8]), ('TAT', [1, 3, 5, 7, 9])]\n    assert candidate(\"GCGCGCGCGCGC\", [\"GC\", \"CGC\", \"GCGC\"]) == [('GC', [0, 2, 4, 6, 8, 10]), ('CGC', [1, 3, 5, 7, 9]), ('GCGC', [0, 2, 4, 6, 8])]\n    assert candidate(\"TTTTGGGGCCCC\", [\"TT\", \"GG\", \"CC\"]) == [('TT', [0, 1, 2]), ('GG', [4, 5, 6]), ('CC', [8, 9, 10])]\n    assert candidate(\"AAACCCGGGTTT\", [\"AAA\", \"CCC\", \"GGG\", \"TTT\"]) == [('AAA', [0]), ('CCC', [3]), ('GGG', [6]), ('TTT', [9])]\n    assert candidate(\"CCCCCAAAAA\", [\"CCC\", \"AAA\"]) == [('CCC', [0, 1, 2]), ('AAA', [5, 6, 7])]\n    assert candidate(\"GATTACA\", [\"GAT\", \"ATT\", \"TTA\", \"TAC\", \"ACA\"]) == [('GAT', [0]), ('ATT', [1]), ('TTA', [2]), ('TAC', [3]), ('ACA', [4])]\n    assert candidate(\"TATATATATATA\", [\"TA\", \"ATA\", \"TATA\"]) == [('TA', [0, 2, 4, 6, 8, 10]), ('ATA', [1, 3, 5, 7, 9]), ('TATA', [0, 2, 4, 6, 8])]\n    assert candidate(\"CGCGCGCG\", [\"CG\", \"CGC\", \"CGCG\"]) == [('CG', [0, 2, 4, 6]), ('CGC', [0, 2, 4]), ('CGCG', [0, 2, 4])]\n    assert candidate(\"AAAAGGGGCCCCTTTT\", [\"AAAA\", \"GGGG\", \"CCCC\", \"TTTT\"]) == [('AAAA', [0]), ('GGGG', [4]), ('CCCC', [8]), ('TTTT', [12])]\n    assert candidate(\"ACTGACTGACTG\", [\"ACT\", \"CTG\", \"TGA\"]) == [('ACT', [0, 4, 8]), ('CTG', [1, 5, 9]), ('TGA', [2, 6])]\n", "language": "python"}
{"task_id": "90df0e0d-3858-45c3-bd8d-0a5f7ba68c45501525601130964592", "prompt": "To properly complete the requested code, I need the initial code fragment or function signature. Once you provide the starting code, I can implement the remaining functionality within that single code block.\n\n```python\nfrom typing import List, Tuple\n\ndef optimize_solar_panel_placement(roof_dimensions: Tuple[int, int], obstacles: List[Tuple[int, int, int, int]]) -> int:\n    \"\"\"\n    A sustainable energy company is designing a system to maximize solar panel coverage on building rooftops.\n    Given the dimensions of a rectangular roof and a list of rectangular obstacles (like chimneys or skylights),\n    calculate the maximum number of 1x1 solar panels that can be placed on the roof without overlapping obstacles.\n\n    This function takes the roof dimensions as a tuple (length, width) and a list of obstacles. Each obstacle is\n    represented by a tuple (x, y, length, width) where (x, y) is the top-left corner of the obstacle. Return the\n    maximum number of solar panels that can be placed.\n\n\n    [EXAMPLES]\n    \n    assert candidate((4, 4), [(1, 1, 2, 2)]) == 12\n    assert candidate((5, 5), [(1, 1, 2, 2), (3, 3, 1, 1)]) == 20\n\n    [/EXAMPLES]\n    \"\"\"\n```\n", "entry_point": "optimize_solar_panel_placement", "solution": "from typing import List, Tuple\n\ndef optimize_solar_panel_placement(roof_dimensions: Tuple[int, int], obstacles: List[Tuple[int, int, int, int]]) -> int:\n    \"\"\"\n    A sustainable energy company is designing a system to maximize solar panel coverage on building rooftops.\n    Given the dimensions of a rectangular roof and a list of rectangular obstacles (like chimneys or skylights),\n    calculate the maximum number of 1x1 solar panels that can be placed on the roof without overlapping obstacles.\n\n    This function takes the roof dimensions as a tuple (length, width) and a list of obstacles. Each obstacle is\n    represented by a tuple (x, y, length, width) where (x, y) is the top-left corner of the obstacle. Return the\n    maximum number of solar panels that can be placed.\n\n\n    [EXAMPLES]\n    \n    assert candidate((4, 4), [(1, 1, 2, 2)]) == 12\n    assert candidate((5, 5), [(1, 1, 2, 2), (3, 3, 1, 1)]) == 20\n\n    [/EXAMPLES]\n    \"\"\"\n    def create_grid(length, width):\n        return [[1 for _ in range(width)] for _ in range(length)]\n\n    def mark_obstacle(grid, x, y, length, width):\n        for i in range(y, min(y + width, len(grid))):\n            for j in range(x, min(x + length, len(grid[0]))):\n                grid[i][j] = 0\n\n    length, width = roof_dimensions\n    grid = create_grid(length, width)\n\n    for obstacle in obstacles:\n        x, y, obs_length, obs_width = obstacle\n        mark_obstacle(grid, x, y, obs_length, obs_width)\n\n    return sum(sum(row) for row in grid)\n\n", "test": "def check(candidate):\n    assert candidate((7, 7), [(2, 2, 3, 3)]) == 40\n    assert candidate((15, 10), [(0, 0, 5, 10), (10, 0, 5, 10)]) == 100\n    assert candidate((5, 5), [(1, 1, 2, 2), (3, 3, 1, 1)]) == 20\n    assert candidate((10, 5), [(0, 0, 1, 5), (9, 0, 1, 5)]) == 45\n    assert candidate((20, 20), [(5, 5, 10, 10)]) == 300\n    assert candidate((10, 10), [(0, 0, 1, 10), (2, 0, 1, 10), (4, 0, 1, 10), (6, 0, 1, 10), (8, 0, 1, 10)]) == 50\n    assert candidate((9, 9), [(0, 0, 3, 3), (3, 3, 3, 3), (6, 6, 3, 3)]) == 54\n    assert candidate((4, 4), [(1, 1, 2, 2)]) == 12\n    assert candidate((6, 6), [(0, 0, 2, 2), (2, 2, 2, 2), (4, 4, 2, 2)]) == 24\n    assert candidate((10, 10), []) == 100\n", "language": "python"}
{"task_id": "74e216ac-b613-4fba-be26-659fb4e32083-7373327150502939417", "prompt": "Your response should be a single code block containing the completed function that can be executed immediately. Only use libraries mentioned in the imports. Place any auxiliary functions or classes inside the main function. Provide nothing but the executable code block.\n\n```python\nimport math\nfrom typing import List, Tuple\n\ndef design_circular_garden(total_area: float, num_sections: int) -> List[Tuple[float, float]]:\n    \"\"\"\n    As a landscape architect, you've been tasked with designing a circular garden divided into equal\n    sections, each dedicated to different types of plants. The garden will have a pathway running from\n    the center to the outer edge, separating each section.\n\n    This function takes two parameters:\n    - total_area: The total area of the circular garden in square meters\n    - num_sections: The number of equal sections the garden should be divided into\n\n    The function returns a list of tuples, where each tuple contains:\n    1. The area of each section in square meters (rounded to 2 decimal places)\n    2. The length of the outer arc of each section in meters (rounded to 2 decimal places)\n\n\n    [EXAMPLES]\n    \n    assert candidate(450.75, 9) == [(50.08, 8.36)]\n    assert candidate(600, 12) == [(50.0, 7.24)]\n\n    [/EXAMPLES]\n    \"\"\"\n```\n", "entry_point": "design_circular_garden", "solution": "import math\nfrom typing import List, Tuple\n\ndef design_circular_garden(total_area: float, num_sections: int) -> List[Tuple[float, float]]:\n    \"\"\"\n    As a landscape architect, you've been tasked with designing a circular garden divided into equal\n    sections, each dedicated to different types of plants. The garden will have a pathway running from\n    the center to the outer edge, separating each section.\n\n    This function takes two parameters:\n    - total_area: The total area of the circular garden in square meters\n    - num_sections: The number of equal sections the garden should be divided into\n\n    The function returns a list of tuples, where each tuple contains:\n    1. The area of each section in square meters (rounded to 2 decimal places)\n    2. The length of the outer arc of each section in meters (rounded to 2 decimal places)\n\n\n    [EXAMPLES]\n    \n    assert candidate(450.75, 9) == [(50.08, 8.36)]\n    assert candidate(600, 12) == [(50.0, 7.24)]\n\n    [/EXAMPLES]\n    \"\"\"\n    # Calculate the radius of the circular garden\n    radius = math.sqrt(total_area / math.pi)\n    \n    # Calculate the area of each section\n    section_area = total_area / num_sections\n    \n    # Calculate the circumference of the garden\n    circumference = 2 * math.pi * radius\n    \n    # Calculate the length of the outer arc for each section\n    arc_length = circumference / num_sections\n    \n    # Round the results to 2 decimal places\n    section_area = round(section_area, 2)\n    arc_length = round(arc_length, 2)\n    \n    # Return the result as a list containing a single tuple\n    return [(section_area, arc_length)]\n\n", "test": "def check(candidate):\n    assert candidate(450.75, 9) == [(50.08, 8.36)]\n    assert candidate(5000, 25) == [(200.0, 10.03)]\n    assert candidate(1500, 15) == [(100.0, 9.15)]\n    assert candidate(500, 5) == [(100.0, 15.85)]\n    assert candidate(300, 10) == [(30.0, 6.14)]\n    assert candidate(600, 12) == [(50.0, 7.24)]\n    assert candidate(75.5, 2) == [(37.75, 15.4)]\n    assert candidate(1.5, 3) == [(0.5, 1.45)]\n    assert candidate(1000, 8) == [(125.0, 14.01)]\n    assert candidate(2000, 20) == [(100.0, 7.93)]\n", "language": "python"}
{"task_id": "db5e5745-ac0d-4590-9466-22bdb7835b8f-4628822090417127701", "prompt": "Please implement the function body according to the specifications in the documentation string. Maintain the original function name and parameter list, and provide your solution in one unified code block.\n\n```python\nfrom typing import List, Tuple\n\ndef recipe_scaler(ingredients: List[Tuple[str, float, str]], servings: int, target_servings: int) -> List[Tuple[str, float, str]]:\n    \"\"\"\n    A chef needs to scale a recipe for a different number of servings.\n\n    This function takes a list of ingredients (each represented as a tuple\n    containing the name, amount, and unit), the current number of servings,\n    and the target number of servings. It returns a new list of ingredients\n    with adjusted amounts.\n\n    The function uses list comprehension and tuple unpacking to scale the recipe.\n\n\n    [EXAMPLES]\n    \n    assert candidate([('ground coffee', 15.0, 'g'), ('water', 250.0, 'ml')], 1, 10) == [('ground coffee', 150.0, 'g'), ('water', 2500.0, 'ml')]\n    assert candidate([('flour', 2.0, 'cups'), ('sugar', 1.5, 'cups'), ('eggs', 3.0, '')], 4, 8) == [('flour', 4.0, 'cups'), ('sugar', 3.0, 'cups'), ('eggs', 6.0, '')]\n\n    [/EXAMPLES]\n    \"\"\"\n```\n", "entry_point": "recipe_scaler", "solution": "from typing import List, Tuple\n\ndef recipe_scaler(ingredients: List[Tuple[str, float, str]], servings: int, target_servings: int) -> List[Tuple[str, float, str]]:\n    \"\"\"\n    A chef needs to scale a recipe for a different number of servings.\n\n    This function takes a list of ingredients (each represented as a tuple\n    containing the name, amount, and unit), the current number of servings,\n    and the target number of servings. It returns a new list of ingredients\n    with adjusted amounts.\n\n    The function uses list comprehension and tuple unpacking to scale the recipe.\n\n\n    [EXAMPLES]\n    \n    assert candidate([('ground coffee', 15.0, 'g'), ('water', 250.0, 'ml')], 1, 10) == [('ground coffee', 150.0, 'g'), ('water', 2500.0, 'ml')]\n    assert candidate([('flour', 2.0, 'cups'), ('sugar', 1.5, 'cups'), ('eggs', 3.0, '')], 4, 8) == [('flour', 4.0, 'cups'), ('sugar', 3.0, 'cups'), ('eggs', 6.0, '')]\n\n    [/EXAMPLES]\n    \"\"\"\n    scale_factor = target_servings / servings\n    return [(name, amount * scale_factor, unit) for name, amount, unit in ingredients]\n\n", "test": "def check(candidate):\n    assert candidate([('apple', 3.0, ''), ('cinnamon', 1.0, 'tsp'), ('sugar', 50.0, 'g')], 6, 2) == [('apple', 1.0, ''), ('cinnamon', 0.3333333333333333, 'tsp'), ('sugar', 16.666666666666664, 'g')]\n    assert candidate([('ground beef', 500.0, 'g'), ('onion', 1.0, ''), ('tomato', 2.0, '')], 4, 1) == [('ground beef', 125.0, 'g'), ('onion', 0.25, ''), ('tomato', 0.5, '')]\n    assert candidate([('bread', 2.0, 'slices'), ('cheese', 30.0, 'g'), ('butter', 10.0, 'g')], 1, 4) == [('bread', 8.0, 'slices'), ('cheese', 120.0, 'g'), ('butter', 40.0, 'g')]\n    assert candidate([('chicken', 500.0, 'g'), ('onion', 1.0, ''), ('garlic', 2.0, 'cloves')], 2, 5) == [('chicken', 1250.0, 'g'), ('onion', 2.5, ''), ('garlic', 5.0, 'cloves')]\n    assert candidate([('flour', 300.0, 'g'), ('yeast', 7.0, 'g'), ('salt', 5.0, 'g'), ('water', 200.0, 'ml')], 1, 3) == [('flour', 900.0, 'g'), ('yeast', 21.0, 'g'), ('salt', 15.0, 'g'), ('water', 600.0, 'ml')]\n    assert candidate([('ground coffee', 15.0, 'g'), ('water', 250.0, 'ml')], 1, 10) == [('ground coffee', 150.0, 'g'), ('water', 2500.0, 'ml')]\n    assert candidate([('chocolate chips', 100.0, 'g'), ('flour', 200.0, 'g'), ('eggs', 2.0, '')], 12, 24) == [('chocolate chips', 200.0, 'g'), ('flour', 400.0, 'g'), ('eggs', 4.0, '')]\n    assert candidate([('chicken broth', 1000.0, 'ml'), ('noodles', 200.0, 'g'), ('vegetables', 150.0, 'g')], 6, 3) == [('chicken broth', 500.0, 'ml'), ('noodles', 100.0, 'g'), ('vegetables', 75.0, 'g')]\n    assert candidate([('flour', 2.0, 'cups'), ('sugar', 1.5, 'cups'), ('eggs', 3.0, '')], 4, 8) == [('flour', 4.0, 'cups'), ('sugar', 3.0, 'cups'), ('eggs', 6.0, '')]\n    assert candidate([('rice', 1.0, 'cup'), ('water', 2.0, 'cups')], 3, 9) == [('rice', 3.0, 'cup'), ('water', 6.0, 'cups')]\n", "language": "python"}
{"task_id": "c3629556-3b5c-49cc-8856-09afb5b2b3b6-379413477441745951", "prompt": "Based on the docstring, I'll complete the function implementation. The entire function will be presented in one code block without altering the function name or parameter list.\n\n```python\nfrom collections import defaultdict\nfrom typing import List, Dict\n\ndef analyze_dna_sequences(sequences: List[str]) -> Dict[str, int]:\n    \"\"\"\n    A geneticist is studying various DNA sequences and needs to analyze the frequency\n    of different nucleotide patterns. They want to identify the most common patterns\n    and their occurrences in a large dataset of DNA sequences.\n\n    This function uses hashing to efficiently count the occurrences of each unique\n    nucleotide pattern in the given DNA sequences.\n\n    :param sequences: A list of DNA sequences\n    :return: A dictionary with nucleotide patterns as keys and their frequencies as values\n\n\n    [EXAMPLES]\n    \n    assert candidate([\"ATCG\", \"CGAT\", \"GATC\", \"TCGA\"] * 250) == {'ATCG': 250, 'CGAT': 250, 'GATC': 250, 'TCGA': 250}\n    assert candidate([\"AAAAA\", \"AAAA\", \"AAA\", \"AA\", \"A\"]) == {'AAAAA': 1, 'AAAA': 1, 'AAA': 1, 'AA': 1, 'A': 1}\n\n    [/EXAMPLES]\n    \"\"\"\n```\n", "entry_point": "analyze_dna_sequences", "solution": "from collections import defaultdict\nfrom typing import List, Dict\n\ndef analyze_dna_sequences(sequences: List[str]) -> Dict[str, int]:\n    \"\"\"\n    A geneticist is studying various DNA sequences and needs to analyze the frequency\n    of different nucleotide patterns. They want to identify the most common patterns\n    and their occurrences in a large dataset of DNA sequences.\n\n    This function uses hashing to efficiently count the occurrences of each unique\n    nucleotide pattern in the given DNA sequences.\n\n    :param sequences: A list of DNA sequences\n    :return: A dictionary with nucleotide patterns as keys and their frequencies as values\n\n\n    [EXAMPLES]\n    \n    assert candidate([\"ATCG\", \"CGAT\", \"GATC\", \"TCGA\"] * 250) == {'ATCG': 250, 'CGAT': 250, 'GATC': 250, 'TCGA': 250}\n    assert candidate([\"AAAAA\", \"AAAA\", \"AAA\", \"AA\", \"A\"]) == {'AAAAA': 1, 'AAAA': 1, 'AAA': 1, 'AA': 1, 'A': 1}\n\n    [/EXAMPLES]\n    \"\"\"\n    # Use defaultdict to automatically initialize counts to 0\n    pattern_counts = defaultdict(int)\n    \n    # Iterate through each sequence in the input list\n    for sequence in sequences:\n        # Increment the count for the current sequence\n        pattern_counts[sequence] += 1\n    \n    # Convert defaultdict to a regular dictionary before returning\n    return dict(pattern_counts)\n\n", "test": "def check(candidate):\n    assert candidate([\"AC\" * i + \"TG\" * i for i in range(1, 51)]) == {'ACTG': 1, 'ACACTGTG': 1, 'ACACACTGTGTG': 1, 'ACACACACTGTGTGTG': 1, 'ACACACACACTGTGTGTGTG': 1, 'ACACACACACACTGTGTGTGTGTG': 1, 'ACACACACACACACTGTGTGTGTGTGTG': 1, 'ACACACACACACACACTGTGTGTGTGTGTGTG': 1, 'ACACACACACACACACACTGTGTGTGTGTGTGTGTG': 1, 'ACACACACACACACACACACTGTGTGTGTGTGTGTGTGTG': 1, 'ACACACACACACACACACACACTGTGTGTGTGTGTGTGTGTGTG': 1, 'ACACACACACACACACACACACACTGTGTGTGTGTGTGTGTGTGTGTG': 1, 'ACACACACACACACACACACACACACTGTGTGTGTGTGTGTGTGTGTGTGTG': 1, 'ACACACACACACACACACACACACACACTGTGTGTGTGTGTGTGTGTGTGTGTGTG': 1, 'ACACACACACACACACACACACACACACACTGTGTGTGTGTGTGTGTGTGTGTGTGTGTG': 1, 'ACACACACACACACACACACACACACACACACTGTGTGTGTGTGTGTGTGTGTGTGTGTGTGTG': 1, 'ACACACACACACACACACACACACACACACACACTGTGTGTGTGTGTGTGTGTGTGTGTGTGTGTGTG': 1, 'ACACACACACACACACACACACACACACACACACACTGTGTGTGTGTGTGTGTGTGTGTGTGTGTGTGTGTG': 1, 'ACACACACACACACACACACACACACACACACACACACTGTGTGTGTGTGTGTGTGTGTGTGTGTGTGTGTGTGTG': 1, 'ACACACACACACACACACACACACACACACACACACACACTGTGTGTGTGTGTGTGTGTGTGTGTGTGTGTGTGTGTGTG': 1, 'ACACACACACACACACACACACACACACACACACACACACACTGTGTGTGTGTGTGTGTGTGTGTGTGTGTGTGTGTGTGTGTG': 1, 'ACACACACACACACACACACACACACACACACACACACACACACTGTGTGTGTGTGTGTGTGTGTGTGTGTGTGTGTGTGTGTGTGTG': 1, 'ACACACACACACACACACACACACACACACACACACACACACACACTGTGTGTGTGTGTGTGTGTGTGTGTGTGTGTGTGTGTGTGTGTGTG': 1, 'ACACACACACACACACACACACACACACACACACACACACACACACACTGTGTGTGTGTGTGTGTGTGTGTGTGTGTGTGTGTGTGTGTGTGTGTG': 1, 'ACACACACACACACACACACACACACACACACACACACACACACACACACTGTGTGTGTGTGTGTGTGTGTGTGTGTGTGTGTGTGTGTGTGTGTGTGTG': 1, 'ACACACACACACACACACACACACACACACACACACACACACACACACACACTGTGTGTGTGTGTGTGTGTGTGTGTGTGTGTGTGTGTGTGTGTGTGTGTGTG': 1, 'ACACACACACACACACACACACACACACACACACACACACACACACACACACACTGTGTGTGTGTGTGTGTGTGTGTGTGTGTGTGTGTGTGTGTGTGTGTGTGTGTG': 1, 'ACACACACACACACACACACACACACACACACACACACACACACACACACACACACTGTGTGTGTGTGTGTGTGTGTGTGTGTGTGTGTGTGTGTGTGTGTGTGTGTGTGTG': 1, 'ACACACACACACACACACACACACACACACACACACACACACACACACACACACACACTGTGTGTGTGTGTGTGTGTGTGTGTGTGTGTGTGTGTGTGTGTGTGTGTGTGTGTGTG': 1, 'ACACACACACACACACACACACACACACACACACACACACACACACACACACACACACACTGTGTGTGTGTGTGTGTGTGTGTGTGTGTGTGTGTGTGTGTGTGTGTGTGTGTGTGTGTG': 1, 'ACACACACACACACACACACACACACACACACACACACACACACACACACACACACACACACTGTGTGTGTGTGTGTGTGTGTGTGTGTGTGTGTGTGTGTGTGTGTGTGTGTGTGTGTGTGTG': 1, 'ACACACACACACACACACACACACACACACACACACACACACACACACACACACACACACACACTGTGTGTGTGTGTGTGTGTGTGTGTGTGTGTGTGTGTGTGTGTGTGTGTGTGTGTGTGTGTGTG': 1, 'ACACACACACACACACACACACACACACACACACACACACACACACACACACACACACACACACACTGTGTGTGTGTGTGTGTGTGTGTGTGTGTGTGTGTGTGTGTGTGTGTGTGTGTGTGTGTGTGTGTG': 1, 'ACACACACACACACACACACACACACACACACACACACACACACACACACACACACACACACACACACTGTGTGTGTGTGTGTGTGTGTGTGTGTGTGTGTGTGTGTGTGTGTGTGTGTGTGTGTGTGTGTGTGTG': 1, 'ACACACACACACACACACACACACACACACACACACACACACACACACACACACACACACACACACACACTGTGTGTGTGTGTGTGTGTGTGTGTGTGTGTGTGTGTGTGTGTGTGTGTGTGTGTGTGTGTGTGTGTGTG': 1, 'ACACACACACACACACACACACACACACACACACACACACACACACACACACACACACACACACACACACACTGTGTGTGTGTGTGTGTGTGTGTGTGTGTGTGTGTGTGTGTGTGTGTGTGTGTGTGTGTGTGTGTGTGTGTG': 1, 'ACACACACACACACACACACACACACACACACACACACACACACACACACACACACACACACACACACACACACTGTGTGTGTGTGTGTGTGTGTGTGTGTGTGTGTGTGTGTGTGTGTGTGTGTGTGTGTGTGTGTGTGTGTGTGTG': 1, 'ACACACACACACACACACACACACACACACACACACACACACACACACACACACACACACACACACACACACACACTGTGTGTGTGTGTGTGTGTGTGTGTGTGTGTGTGTGTGTGTGTGTGTGTGTGTGTGTGTGTGTGTGTGTGTGTGTG': 1, 'ACACACACACACACACACACACACACACACACACACACACACACACACACACACACACACACACACACACACACACACTGTGTGTGTGTGTGTGTGTGTGTGTGTGTGTGTGTGTGTGTGTGTGTGTGTGTGTGTGTGTGTGTGTGTGTGTGTGTG': 1, 'ACACACACACACACACACACACACACACACACACACACACACACACACACACACACACACACACACACACACACACACACTGTGTGTGTGTGTGTGTGTGTGTGTGTGTGTGTGTGTGTGTGTGTGTGTGTGTGTGTGTGTGTGTGTGTGTGTGTGTGTG': 1, 'ACACACACACACACACACACACACACACACACACACACACACACACACACACACACACACACACACACACACACACACACACTGTGTGTGTGTGTGTGTGTGTGTGTGTGTGTGTGTGTGTGTGTGTGTGTGTGTGTGTGTGTGTGTGTGTGTGTGTGTGTGTG': 1, 'ACACACACACACACACACACACACACACACACACACACACACACACACACACACACACACACACACACACACACACACACACACTGTGTGTGTGTGTGTGTGTGTGTGTGTGTGTGTGTGTGTGTGTGTGTGTGTGTGTGTGTGTGTGTGTGTGTGTGTGTGTGTGTG': 1, 'ACACACACACACACACACACACACACACACACACACACACACACACACACACACACACACACACACACACACACACACACACACACTGTGTGTGTGTGTGTGTGTGTGTGTGTGTGTGTGTGTGTGTGTGTGTGTGTGTGTGTGTGTGTGTGTGTGTGTGTGTGTGTGTGTG': 1, 'ACACACACACACACACACACACACACACACACACACACACACACACACACACACACACACACACACACACACACACACACACACACACTGTGTGTGTGTGTGTGTGTGTGTGTGTGTGTGTGTGTGTGTGTGTGTGTGTGTGTGTGTGTGTGTGTGTGTGTGTGTGTGTGTGTGTG': 1, 'ACACACACACACACACACACACACACACACACACACACACACACACACACACACACACACACACACACACACACACACACACACACACACTGTGTGTGTGTGTGTGTGTGTGTGTGTGTGTGTGTGTGTGTGTGTGTGTGTGTGTGTGTGTGTGTGTGTGTGTGTGTGTGTGTGTGTGTG': 1, 'ACACACACACACACACACACACACACACACACACACACACACACACACACACACACACACACACACACACACACACACACACACACACACACTGTGTGTGTGTGTGTGTGTGTGTGTGTGTGTGTGTGTGTGTGTGTGTGTGTGTGTGTGTGTGTGTGTGTGTGTGTGTGTGTGTGTGTGTGTG': 1, 'ACACACACACACACACACACACACACACACACACACACACACACACACACACACACACACACACACACACACACACACACACACACACACACACTGTGTGTGTGTGTGTGTGTGTGTGTGTGTGTGTGTGTGTGTGTGTGTGTGTGTGTGTGTGTGTGTGTGTGTGTGTGTGTGTGTGTGTGTGTGTG': 1, 'ACACACACACACACACACACACACACACACACACACACACACACACACACACACACACACACACACACACACACACACACACACACACACACACACTGTGTGTGTGTGTGTGTGTGTGTGTGTGTGTGTGTGTGTGTGTGTGTGTGTGTGTGTGTGTGTGTGTGTGTGTGTGTGTGTGTGTGTGTGTGTGTG': 1, 'ACACACACACACACACACACACACACACACACACACACACACACACACACACACACACACACACACACACACACACACACACACACACACACACACACTGTGTGTGTGTGTGTGTGTGTGTGTGTGTGTGTGTGTGTGTGTGTGTGTGTGTGTGTGTGTGTGTGTGTGTGTGTGTGTGTGTGTGTGTGTGTGTGTG': 1, 'ACACACACACACACACACACACACACACACACACACACACACACACACACACACACACACACACACACACACACACACACACACACACACACACACACACTGTGTGTGTGTGTGTGTGTGTGTGTGTGTGTGTGTGTGTGTGTGTGTGTGTGTGTGTGTGTGTGTGTGTGTGTGTGTGTGTGTGTGTGTGTGTGTGTGTG': 1}\n    assert candidate([\"A\" * i for i in range(1, 101)]) == {'A': 1, 'AA': 1, 'AAA': 1, 'AAAA': 1, 'AAAAA': 1, 'AAAAAA': 1, 'AAAAAAA': 1, 'AAAAAAAA': 1, 'AAAAAAAAA': 1, 'AAAAAAAAAA': 1, 'AAAAAAAAAAA': 1, 'AAAAAAAAAAAA': 1, 'AAAAAAAAAAAAA': 1, 'AAAAAAAAAAAAAA': 1, 'AAAAAAAAAAAAAAA': 1, 'AAAAAAAAAAAAAAAA': 1, 'AAAAAAAAAAAAAAAAA': 1, 'AAAAAAAAAAAAAAAAAA': 1, 'AAAAAAAAAAAAAAAAAAA': 1, 'AAAAAAAAAAAAAAAAAAAA': 1, 'AAAAAAAAAAAAAAAAAAAAA': 1, 'AAAAAAAAAAAAAAAAAAAAAA': 1, 'AAAAAAAAAAAAAAAAAAAAAAA': 1, 'AAAAAAAAAAAAAAAAAAAAAAAA': 1, 'AAAAAAAAAAAAAAAAAAAAAAAAA': 1, 'AAAAAAAAAAAAAAAAAAAAAAAAAA': 1, 'AAAAAAAAAAAAAAAAAAAAAAAAAAA': 1, 'AAAAAAAAAAAAAAAAAAAAAAAAAAAA': 1, 'AAAAAAAAAAAAAAAAAAAAAAAAAAAAA': 1, 'AAAAAAAAAAAAAAAAAAAAAAAAAAAAAA': 1, 'AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA': 1, 'AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA': 1, 'AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA': 1, 'AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA': 1, 'AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA': 1, 'AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA': 1, 'AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA': 1, 'AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA': 1, 'AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA': 1, 'AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA': 1, 'AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA': 1, 'AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA': 1, 'AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA': 1, 'AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA': 1, 'AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA': 1, 'AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA': 1, 'AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA': 1, 'AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA': 1, 'AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA': 1, 'AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA': 1, 'AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA': 1, 'AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA': 1, 'AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA': 1, 'AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA': 1, 'AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA': 1, 'AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA': 1, 'AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA': 1, 'AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA': 1, 'AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA': 1, 'AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA': 1, 'AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA': 1, 'AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA': 1, 'AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA': 1, 'AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA': 1, 'AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA': 1, 'AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA': 1, 'AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA': 1, 'AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA': 1, 'AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA': 1, 'AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA': 1, 'AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA': 1, 'AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA': 1, 'AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA': 1, 'AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA': 1, 'AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA': 1, 'AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA': 1, 'AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA': 1, 'AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA': 1, 'AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA': 1, 'AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA': 1, 'AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA': 1, 'AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA': 1, 'AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA': 1, 'AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA': 1, 'AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA': 1, 'AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA': 1, 'AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA': 1, 'AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA': 1, 'AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA': 1, 'AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA': 1, 'AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA': 1, 'AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA': 1, 'AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA': 1, 'AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA': 1, 'AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA': 1, 'AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA': 1, 'AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA': 1, 'AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA': 1, 'AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA': 1, 'AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA': 1}\n    assert candidate([\"A\", \"AT\", \"ATC\", \"ATCG\", \"ATCGA\"]) == {'A': 1, 'AT': 1, 'ATC': 1, 'ATCG': 1, 'ATCGA': 1}\n    assert candidate([\"AAAAA\", \"AAAA\", \"AAA\", \"AA\", \"A\"]) == {'AAAAA': 1, 'AAAA': 1, 'AAA': 1, 'AA': 1, 'A': 1}\n    assert candidate([\"ATCG\", \"CGAT\", \"GATC\", \"TCGA\"] * 250) == {'ATCG': 250, 'CGAT': 250, 'GATC': 250, 'TCGA': 250}\n    assert candidate([\"ATCG\", \"GACT\", \"ATCG\", \"TGCA\", \"ATCG\"]) == {'ATCG': 3, 'GACT': 1, 'TGCA': 1}\n    assert candidate([\"N\" * 100, \"A\" * 100, \"T\" * 100, \"C\" * 100, \"G\" * 100]) == {'NNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNN': 1, 'AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA': 1, 'TTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTT': 1, 'CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC': 1, 'GGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGG': 1}\n    assert candidate([\"A\" * 10000, \"T\" * 10000, \"C\" * 10000, \"G\" * 10000]) == {'AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA': 1, 'TTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTT': 1, 'CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC': 1, 'GGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGG': 1}\n    assert candidate([\"ATG\", \"CAT\", \"GTA\", \"TAC\"] * 25) == {'ATG': 25, 'CAT': 25, 'GTA': 25, 'TAC': 25}\n    assert candidate([\"ATCGATCG\", \"CGTAGCTA\", \"ATCGATCG\"]) == {'ATCGATCG': 2, 'CGTAGCTA': 1}\n", "language": "python"}
{"task_id": "adfaaa2a-cce1-47e2-b0bf-dfdc5e76099d-8249482197168000922", "prompt": "Below I'll implement the complete function that can be executed directly. My response will contain only one code block with the function implementation, including any necessary helper functions or classes defined within it, and I'll only use libraries that are already imported in the problem.\n\n```python\nfrom typing import List, Tuple\n\ndef optimize_warehouse_layout(items: List[Tuple[int, int]], capacity: int) -> int:\n    \"\"\"\n    A warehouse manager needs to optimize the storage of items to maximize the total value\n    stored while respecting the weight capacity of the shelves. Each item has a weight and a value.\n\n    This function takes a list of items (each represented as a tuple of weight and value)\n    and the weight capacity of the shelf. It returns the maximum total value that can be stored.\n\n    The function implements a knapsack algorithm to find the optimal combination of items.\n\n\n    [EXAMPLES]\n    \n    assert candidate([(5, 10), (4, 8), (3, 6), (2, 4), (1, 2)], 10) == 20\n    assert candidate([(10, 100), (20, 200), (30, 300)], 50) == 500\n\n    [/EXAMPLES]\n    \"\"\"\n```\n", "entry_point": "optimize_warehouse_layout", "solution": "from typing import List, Tuple\n\ndef optimize_warehouse_layout(items: List[Tuple[int, int]], capacity: int) -> int:\n    \"\"\"\n    A warehouse manager needs to optimize the storage of items to maximize the total value\n    stored while respecting the weight capacity of the shelves. Each item has a weight and a value.\n\n    This function takes a list of items (each represented as a tuple of weight and value)\n    and the weight capacity of the shelf. It returns the maximum total value that can be stored.\n\n    The function implements a knapsack algorithm to find the optimal combination of items.\n\n\n    [EXAMPLES]\n    \n    assert candidate([(5, 10), (4, 8), (3, 6), (2, 4), (1, 2)], 10) == 20\n    assert candidate([(10, 100), (20, 200), (30, 300)], 50) == 500\n\n    [/EXAMPLES]\n    \"\"\"\n    n = len(items)\n    \n    # Create a 2D table to store the maximum values\n    dp = [[0 for _ in range(capacity + 1)] for _ in range(n + 1)]\n    \n    # Fill the dp table\n    for i in range(1, n + 1):\n        for w in range(capacity + 1):\n            weight, value = items[i-1]\n            if weight <= w:\n                dp[i][w] = max(dp[i-1][w], dp[i-1][w-weight] + value)\n            else:\n                dp[i][w] = dp[i-1][w]\n    \n    # Return the maximum value that can be stored\n    return dp[n][capacity]\n\n", "test": "def check(candidate):\n    assert candidate([(1, 1000), (2, 2000), (3, 3000)], 3) == 3000\n    assert candidate([(1, 1000000), (2, 2000000), (3, 3000000)], 3) == 3000000\n    assert candidate([], 10) == 0\n    assert candidate([(1, 1), (1, 1), (1, 1), (1, 1), (1, 1)], 5) == 5\n    assert candidate([(5, 10), (4, 8), (3, 6), (2, 4), (1, 2)], 10) == 20\n    assert candidate([(5, 5), (4, 4), (3, 3), (2, 2), (1, 1)], 15) == 15\n    assert candidate([(100, 1), (50, 2), (25, 4), (10, 8), (5, 16)], 100) == 30\n    assert candidate([(1, 1), (2, 2), (3, 3)], 5) == 5\n    assert candidate([(10, 100), (20, 200), (30, 300)], 50) == 500\n    assert candidate([(1, 1)], 1) == 1\n", "language": "python"}
{"task_id": "423ff826-842f-4ed5-b10a-520403139e2b-8086352138529784668", "prompt": "Implement the function according to the provided documentation. Deliver your solution as a single code block with comprehensive edge case handling.\n\n```python\nfrom typing import List\nimport heapq\n\ndef optimize_meeting_rooms(meetings: List[List[int]]) -> int:\n    \"\"\"\n    Determine the minimum number of conference rooms required for a series of meetings.\n\n    Given a list of meetings, where each meeting is represented by a list of two integers [start_time, end_time],\n    calculate the minimum number of conference rooms needed to accommodate all meetings without any overlap.\n\n\n    [EXAMPLES]\n    \n    assert candidate([[4, 5], [2, 3], [2, 4], [3, 5]]) == 2\n    assert candidate([[1, 2]]) == 1\n\n    [/EXAMPLES]\n    \"\"\"\n```\n", "entry_point": "optimize_meeting_rooms", "solution": "from typing import List\nimport heapq\n\ndef optimize_meeting_rooms(meetings: List[List[int]]) -> int:\n    \"\"\"\n    Determine the minimum number of conference rooms required for a series of meetings.\n\n    Given a list of meetings, where each meeting is represented by a list of two integers [start_time, end_time],\n    calculate the minimum number of conference rooms needed to accommodate all meetings without any overlap.\n\n\n    [EXAMPLES]\n    \n    assert candidate([[4, 5], [2, 3], [2, 4], [3, 5]]) == 2\n    assert candidate([[1, 2]]) == 1\n\n    [/EXAMPLES]\n    \"\"\"\n    if not meetings:\n        return 0\n\n    # Sort meetings by start time\n    meetings.sort(key=lambda x: x[0])\n\n    # Initialize a min heap to keep track of end times\n    rooms = []\n    heapq.heappush(rooms, meetings[0][1])\n\n    for meeting in meetings[1:]:\n        # If the earliest ending meeting has finished, remove it\n        if rooms[0] <= meeting[0]:\n            heapq.heappop(rooms)\n\n        # Add the current meeting's end time to the heap\n        heapq.heappush(rooms, meeting[1])\n\n    # The size of the heap represents the number of rooms needed\n    return len(rooms)\n\n", "test": "def check(candidate):\n    assert candidate([[1, 10], [2, 7], [3, 19], [8, 12], [10, 20], [11, 30]]) == 4\n    assert candidate([[1, 2]]) == 1\n    assert candidate([[1, 10], [2, 9], [3, 8], [4, 7], [5, 6]]) == 5\n    assert candidate([[0, 5], [1, 2], [1, 10]]) == 3\n    assert candidate([[4, 5], [2, 3], [2, 4], [3, 5]]) == 2\n    assert candidate([[7, 10], [2, 4]]) == 1\n    assert candidate([[0, 30], [5, 10], [15, 20]]) == 2\n    assert candidate([[0, 1], [23, 24]]) == 1\n    assert candidate([[0, 1000000]]) == 1\n    assert candidate([[1, 4], [2, 5], [7, 9], [6, 8]]) == 2\n", "language": "python"}
{"task_id": "9e23591a-1f68-45df-9bed-6a075ac897ae4172295357146112746", "prompt": "Based on the docstring provided, finish coding the function implementation. Keep the function signature intact and present your solution in one comprehensive code block.\n\n```python\nfrom typing import List\n\ndef genetic_mutation(dna: str, mutations: List[str]) -> int:\n    \"\"\"\n    A geneticist is studying DNA mutations. They have a string representing a DNA sequence\n    and a list of mutation operations. Each mutation operation is a string in the format\n    \"X Y Z\", where X is either 'A', 'C', 'G', or 'T', Y is an integer index, and Z is\n    either 'A', 'C', 'G', or 'T'.\n\n    For each mutation operation, if the character at index Y in the DNA sequence is X,\n    it should be changed to Z. If it's not X, no change occurs.\n\n    After applying all mutations, return the number of distinct characters in the final DNA sequence.\n\n\n    [EXAMPLES]\n    \n    assert candidate(\"TTTT\", [\"T 0 A\", \"T 1 C\", \"T 2 G\", \"T 3 A\"]) == 3\n    assert candidate(\"GGGG\", [\"G 0 A\", \"G 1 C\", \"G 2 T\"]) == 4\n\n    [/EXAMPLES]\n    \"\"\"\n```\n", "entry_point": "genetic_mutation", "solution": "from typing import List\n\ndef genetic_mutation(dna: str, mutations: List[str]) -> int:\n    \"\"\"\n    A geneticist is studying DNA mutations. They have a string representing a DNA sequence\n    and a list of mutation operations. Each mutation operation is a string in the format\n    \"X Y Z\", where X is either 'A', 'C', 'G', or 'T', Y is an integer index, and Z is\n    either 'A', 'C', 'G', or 'T'.\n\n    For each mutation operation, if the character at index Y in the DNA sequence is X,\n    it should be changed to Z. If it's not X, no change occurs.\n\n    After applying all mutations, return the number of distinct characters in the final DNA sequence.\n\n\n    [EXAMPLES]\n    \n    assert candidate(\"TTTT\", [\"T 0 A\", \"T 1 C\", \"T 2 G\", \"T 3 A\"]) == 3\n    assert candidate(\"GGGG\", [\"G 0 A\", \"G 1 C\", \"G 2 T\"]) == 4\n\n    [/EXAMPLES]\n    \"\"\"\n    # Convert DNA string to a list for easier mutation\n    dna_list = list(dna)\n    \n    # Apply mutations\n    for mutation in mutations:\n        x, y, z = mutation.split()\n        y = int(y)\n        if y < len(dna_list) and dna_list[y] == x:\n            dna_list[y] = z\n    \n    # Convert back to string and count distinct characters\n    final_dna = ''.join(dna_list)\n    return len(set(final_dna))\n\n", "test": "def check(candidate):\n    assert candidate(\"A\", [\"A 0 T\"]) == 1\n    assert candidate(\"ACGT\", [\"A 0 C\", \"C 1 G\", \"G 2 T\", \"T 3 A\", \"C 0 G\", \"G 1 T\", \"T 2 A\", \"A 3 C\"]) == 4\n    assert candidate(\"CCCC\", [\"C 0 A\", \"C 1 T\", \"C 2 G\", \"C 3 A\"]) == 3\n    assert candidate(\"GGGG\", [\"G 0 A\", \"G 1 C\", \"G 2 T\"]) == 4\n    assert candidate(\"ACGTACGT\", [\"A 0 T\", \"C 1 G\", \"G 2 C\", \"T 3 A\", \"A 4 T\", \"C 5 G\", \"G 6 C\", \"T 7 A\"]) == 4\n    assert candidate(\"ATCG\", [\"A 0 T\", \"T 1 A\", \"C 2 G\", \"G 3 C\"]) == 4\n    assert candidate(\"ACGT\", [\"A 0 C\", \"C 2 T\"]) == 3\n    assert candidate(\"ACTG\", [\"G 3 T\", \"C 1 A\", \"A 0 G\"]) == 3\n    assert candidate(\"TTTT\", [\"T 0 A\", \"T 1 C\", \"T 2 G\", \"T 3 A\"]) == 3\n    assert candidate(\"ACGT\", [\"A 0 T\", \"C 1 G\", \"G 2 C\", \"T 3 A\"]) == 4\n", "language": "python"}
{"task_id": "bcadcc89-8dd1-4901-98a7-924f230de3913703373698000655626", "prompt": "Your role is to be a coding assistant who completes provided functions in an executable manner. Don't include any code outside the function boundaries. Stick to using only the libraries that are imported in the problem. If you need additional functionality, define those helper functions or classes within the main function itself.\n\n```python\ndef dna_mutation_analyzer(original_sequence: str, mutated_sequence: str) -> dict:\n    \"\"\"\n    A geneticist is studying DNA mutations and needs a tool to analyze the differences between\n    an original DNA sequence and a mutated one. This function takes two DNA sequences as input\n    and returns a dictionary containing information about the mutations.\n\n    The function utilizes string manipulation and set operations to identify the mutations.\n\n\n    [EXAMPLES]\n    \n    assert candidate(\"GAATTC\", \"GAATTC\") == {'mutations': 0, 'positions': [], 'original': '', 'mutated': ''}\n    assert candidate(\"GCTA\", \"GCAT\") == {'mutations': 2, 'positions': [2, 3], 'original': 'TA', 'mutated': 'AT'}\n\n    [/EXAMPLES]\n    \"\"\"\n```\n", "entry_point": "dna_mutation_analyzer", "solution": "def dna_mutation_analyzer(original_sequence: str, mutated_sequence: str) -> dict:\n    \"\"\"\n    A geneticist is studying DNA mutations and needs a tool to analyze the differences between\n    an original DNA sequence and a mutated one. This function takes two DNA sequences as input\n    and returns a dictionary containing information about the mutations.\n\n    The function utilizes string manipulation and set operations to identify the mutations.\n\n\n    [EXAMPLES]\n    \n    assert candidate(\"GAATTC\", \"GAATTC\") == {'mutations': 0, 'positions': [], 'original': '', 'mutated': ''}\n    assert candidate(\"GCTA\", \"GCAT\") == {'mutations': 2, 'positions': [2, 3], 'original': 'TA', 'mutated': 'AT'}\n\n    [/EXAMPLES]\n    \"\"\"\n    # Initialize the result dictionary\n    result = {\n        'mutations': 0,\n        'positions': [],\n        'original': '',\n        'mutated': ''\n    }\n    \n    # Check if the sequences have the same length\n    if len(original_sequence) != len(mutated_sequence):\n        raise ValueError(\"The original and mutated sequences must have the same length.\")\n    \n    # Compare the sequences character by character\n    for i, (orig, mut) in enumerate(zip(original_sequence, mutated_sequence)):\n        if orig != mut:\n            result['mutations'] += 1\n            result['positions'].append(i)\n            result['original'] += orig\n            result['mutated'] += mut\n    \n    return result\n\n", "test": "def check(candidate):\n    assert candidate(\"GGGGGGGG\", \"GGAGGGGG\") == {'mutations': 1, 'positions': [2], 'original': 'G', 'mutated': 'A'}\n    assert candidate(\"ATCGATCGATCGATCG\", \"ATCGATCGATCGATCA\") == {'mutations': 1, 'positions': [15], 'original': 'G', 'mutated': 'A'}\n    assert candidate(\"ATCG\", \"TACG\") == {'mutations': 2, 'positions': [0, 1], 'original': 'AT', 'mutated': 'TA'}\n    assert candidate(\"CCCCC\", \"CCCCA\") == {'mutations': 1, 'positions': [4], 'original': 'C', 'mutated': 'A'}\n    assert candidate(\"GCTA\", \"GCAT\") == {'mutations': 2, 'positions': [2, 3], 'original': 'TA', 'mutated': 'AT'}\n    assert candidate(\"GAATTC\", \"GAATTC\") == {'mutations': 0, 'positions': [], 'original': '', 'mutated': ''}\n    assert candidate(\"AAAAA\", \"TTTTT\") == {'mutations': 5, 'positions': [0, 1, 2, 3, 4], 'original': 'AAAAA', 'mutated': 'TTTTT'}\n    assert candidate(\"CGCGCGCGCG\", \"CGCGCGCGCG\") == {'mutations': 0, 'positions': [], 'original': '', 'mutated': ''}\n    assert candidate(\"ATCG\", \"GTCA\") == {'mutations': 2, 'positions': [0, 3], 'original': 'AG', 'mutated': 'GA'}\n    assert candidate(\"CGTA\", \"CGTT\") == {'mutations': 1, 'positions': [3], 'original': 'A', 'mutated': 'T'}\n", "language": "python"}
{"task_id": "e4a9d722-e162-431c-a7e4-5a2b41152e0e-5191461496302522357", "prompt": "Please complete the function based on the provided docstring. Present the entire implementation in one code block, ensuring that edge cases are handled appropriately.\n\n```python\nimport re\nfrom typing import List\nfrom typing import List, Tuple\n\ndef parse_chemical_formula(formula: str) -> List[Tuple[str, int]]:\n    \"\"\"Parse a chemical formula and return a list of elements with their respective counts.\n\n    The function should handle complex formulas with parentheses, multiple-digit subscripts,\n    and nested structures. It should return a list of tuples, where each tuple contains\n    an element symbol and its count in the formula.\n\n\n    [EXAMPLES]\n    \n    assert candidate(\"((CH3)3C)3Al\") == [('Al', 1), ('C', 12), ('H', 27)]\n    assert candidate(\"Ca(OH)2\") == [('Ca', 1), ('H', 2), ('O', 2)]\n\n    [/EXAMPLES]\n    \"\"\"\n```\n", "entry_point": "parse_chemical_formula", "solution": "import re\nfrom typing import List\nfrom typing import List, Tuple\n\ndef parse_chemical_formula(formula: str) -> List[Tuple[str, int]]:\n    \"\"\"Parse a chemical formula and return a list of elements with their respective counts.\n\n    The function should handle complex formulas with parentheses, multiple-digit subscripts,\n    and nested structures. It should return a list of tuples, where each tuple contains\n    an element symbol and its count in the formula.\n\n\n    [EXAMPLES]\n    \n    assert candidate(\"((CH3)3C)3Al\") == [('Al', 1), ('C', 12), ('H', 27)]\n    assert candidate(\"Ca(OH)2\") == [('Ca', 1), ('H', 2), ('O', 2)]\n\n    [/EXAMPLES]\n    \"\"\"\n    def parse_group(group: str, multiplier: int = 1) -> dict:\n        element_counts = {}\n        pattern = re.compile(r'([A-Z][a-z]*)(\\d*)')\n        i = 0\n        while i < len(group):\n            if group[i] == '(':\n                j = i + 1\n                paren_count = 1\n                while paren_count > 0:\n                    if group[j] == '(':\n                        paren_count += 1\n                    elif group[j] == ')':\n                        paren_count -= 1\n                    j += 1\n                subgroup = group[i+1:j-1]\n                i = j\n                m = re.match(r'\\d+', group[i:])\n                if m:\n                    submultiplier = int(m.group())\n                    i += len(m.group())\n                else:\n                    submultiplier = 1\n                subgroup_counts = parse_group(subgroup, submultiplier * multiplier)\n                for element, count in subgroup_counts.items():\n                    element_counts[element] = element_counts.get(element, 0) + count\n            else:\n                match = pattern.match(group[i:])\n                if match:\n                    element, count = match.groups()\n                    count = int(count) if count else 1\n                    element_counts[element] = element_counts.get(element, 0) + count * multiplier\n                    i += len(match.group())\n                else:\n                    i += 1\n        return element_counts\n\n    element_counts = parse_group(formula)\n    return [(element, count) for element, count in sorted(element_counts.items())]\n\n", "test": "def check(candidate):\n    assert candidate(\"Cu(NO3)2\") == [('Cu', 1), ('N', 2), ('O', 6)]\n    assert candidate(\"H2O\") == [('H', 2), ('O', 1)]\n    assert candidate(\"K4[Fe(CN)6]\") == [('C', 6), ('Fe', 1), ('K', 4), ('N', 6)]\n    assert candidate(\"(C6H10O5)n\") == [('C', 6), ('H', 10), ('O', 5)]\n    assert candidate(\"Na2CO3\") == [('C', 1), ('Na', 2), ('O', 3)]\n    assert candidate(\"((CH3)3C)3Al\") == [('Al', 1), ('C', 12), ('H', 27)]\n    assert candidate(\"Ca(OH)2\") == [('Ca', 1), ('H', 2), ('O', 2)]\n    assert candidate(\"Fe2(SO4)3\") == [('Fe', 2), ('O', 12), ('S', 3)]\n    assert candidate(\"CH3COOH\") == [('C', 2), ('H', 4), ('O', 2)]\n    assert candidate(\"NaCl\") == [('Cl', 1), ('Na', 1)]\n", "language": "python"}
{"task_id": "6c799ed7-ad8c-428e-8151-8b49fdd32ae6-2331038873012812086", "prompt": "Based on the function's docstring, I'll write the complete implementation in one coherent code block. My solution will address any edge cases that might arise during execution.\n\n```python\nfrom typing import List, Tuple\n\ndef optimize_warehouse_layout(items: List[Tuple[str, int, int]]) -> List[Tuple[str, int, int]]:\n    \"\"\"\n    A warehouse manager needs to optimize the layout of items based on their popularity and weight.\n    Each item is represented by a tuple containing its name, popularity score (1-100), and weight in kg.\n    The function should return a list of items sorted for optimal placement, with the most popular and\n    lightest items placed nearest to the shipping area.\n\n    The sorting criteria are:\n    1. Higher popularity score takes precedence\n    2. If popularity scores are equal, lighter items come first\n    3. If both popularity and weight are equal, maintain original order\n\n\n    [EXAMPLES]\n    \n    assert candidate([(\"A\", 1, 1), (\"B\", 100, 100), (\"C\", 50, 50), (\"D\", 25, 75), (\"E\", 75, 25)]) == [('B', 100, 100), ('E', 75, 25), ('C', 50, 50), ('D', 25, 75), ('A', 1, 1)]\n    assert candidate([(\"Item1\", 50, 5), (\"Item2\", 50, 5), (\"Item3\", 50, 5)]) == [('Item1', 50, 5), ('Item2', 50, 5), ('Item3', 50, 5)]\n\n    [/EXAMPLES]\n    \"\"\"\n```\n", "entry_point": "optimize_warehouse_layout", "solution": "from typing import List, Tuple\n\ndef optimize_warehouse_layout(items: List[Tuple[str, int, int]]) -> List[Tuple[str, int, int]]:\n    \"\"\"\n    A warehouse manager needs to optimize the layout of items based on their popularity and weight.\n    Each item is represented by a tuple containing its name, popularity score (1-100), and weight in kg.\n    The function should return a list of items sorted for optimal placement, with the most popular and\n    lightest items placed nearest to the shipping area.\n\n    The sorting criteria are:\n    1. Higher popularity score takes precedence\n    2. If popularity scores are equal, lighter items come first\n    3. If both popularity and weight are equal, maintain original order\n\n\n    [EXAMPLES]\n    \n    assert candidate([(\"A\", 1, 1), (\"B\", 100, 100), (\"C\", 50, 50), (\"D\", 25, 75), (\"E\", 75, 25)]) == [('B', 100, 100), ('E', 75, 25), ('C', 50, 50), ('D', 25, 75), ('A', 1, 1)]\n    assert candidate([(\"Item1\", 50, 5), (\"Item2\", 50, 5), (\"Item3\", 50, 5)]) == [('Item1', 50, 5), ('Item2', 50, 5), ('Item3', 50, 5)]\n\n    [/EXAMPLES]\n    \"\"\"\n    def sort_key(item):\n        name, popularity, weight = item\n        return (-popularity, weight, items.index(item))\n    \n    return sorted(items, key=sort_key)\n\n", "test": "def check(candidate):\n    assert candidate([(\"A\", 100, 1), (\"B\", 99, 2), (\"C\", 98, 3), (\"D\", 97, 4), (\"E\", 96, 5)]) == [('A', 100, 1), ('B', 99, 2), ('C', 98, 3), ('D', 97, 4), ('E', 96, 5)]\n    assert candidate([(\"A\", 1, 1), (\"B\", 100, 100), (\"C\", 50, 50), (\"D\", 25, 75), (\"E\", 75, 25)]) == [('B', 100, 100), ('E', 75, 25), ('C', 50, 50), ('D', 25, 75), ('A', 1, 1)]\n    assert candidate([(\"A\", 1, 1), (\"B\", 1, 2), (\"C\", 2, 1), (\"D\", 2, 2)]) == [('C', 2, 1), ('D', 2, 2), ('A', 1, 1), ('B', 1, 2)]\n    assert candidate([(\"Item1\", 50, 5), (\"Item2\", 50, 5), (\"Item3\", 50, 5)]) == [('Item1', 50, 5), ('Item2', 50, 5), ('Item3', 50, 5)]\n    assert candidate([(\"Item\", 50, 5)] * 10) == [('Item', 50, 5), ('Item', 50, 5), ('Item', 50, 5), ('Item', 50, 5), ('Item', 50, 5), ('Item', 50, 5), ('Item', 50, 5), ('Item', 50, 5), ('Item', 50, 5), ('Item', 50, 5)]\n    assert candidate([(\"Heavy\", 10, 1000), (\"Light\", 10, 1), (\"Medium\", 10, 100)]) == [('Light', 10, 1), ('Medium', 10, 100), ('Heavy', 10, 1000)]\n    assert candidate([(\"Product\", i, 100-i) for i in range(1, 101)]) == [('Product', 100, 0), ('Product', 99, 1), ('Product', 98, 2), ('Product', 97, 3), ('Product', 96, 4), ('Product', 95, 5), ('Product', 94, 6), ('Product', 93, 7), ('Product', 92, 8), ('Product', 91, 9), ('Product', 90, 10), ('Product', 89, 11), ('Product', 88, 12), ('Product', 87, 13), ('Product', 86, 14), ('Product', 85, 15), ('Product', 84, 16), ('Product', 83, 17), ('Product', 82, 18), ('Product', 81, 19), ('Product', 80, 20), ('Product', 79, 21), ('Product', 78, 22), ('Product', 77, 23), ('Product', 76, 24), ('Product', 75, 25), ('Product', 74, 26), ('Product', 73, 27), ('Product', 72, 28), ('Product', 71, 29), ('Product', 70, 30), ('Product', 69, 31), ('Product', 68, 32), ('Product', 67, 33), ('Product', 66, 34), ('Product', 65, 35), ('Product', 64, 36), ('Product', 63, 37), ('Product', 62, 38), ('Product', 61, 39), ('Product', 60, 40), ('Product', 59, 41), ('Product', 58, 42), ('Product', 57, 43), ('Product', 56, 44), ('Product', 55, 45), ('Product', 54, 46), ('Product', 53, 47), ('Product', 52, 48), ('Product', 51, 49), ('Product', 50, 50), ('Product', 49, 51), ('Product', 48, 52), ('Product', 47, 53), ('Product', 46, 54), ('Product', 45, 55), ('Product', 44, 56), ('Product', 43, 57), ('Product', 42, 58), ('Product', 41, 59), ('Product', 40, 60), ('Product', 39, 61), ('Product', 38, 62), ('Product', 37, 63), ('Product', 36, 64), ('Product', 35, 65), ('Product', 34, 66), ('Product', 33, 67), ('Product', 32, 68), ('Product', 31, 69), ('Product', 30, 70), ('Product', 29, 71), ('Product', 28, 72), ('Product', 27, 73), ('Product', 26, 74), ('Product', 25, 75), ('Product', 24, 76), ('Product', 23, 77), ('Product', 22, 78), ('Product', 21, 79), ('Product', 20, 80), ('Product', 19, 81), ('Product', 18, 82), ('Product', 17, 83), ('Product', 16, 84), ('Product', 15, 85), ('Product', 14, 86), ('Product', 13, 87), ('Product', 12, 88), ('Product', 11, 89), ('Product', 10, 90), ('Product', 9, 91), ('Product', 8, 92), ('Product', 7, 93), ('Product', 6, 94), ('Product', 5, 95), ('Product', 4, 96), ('Product', 3, 97), ('Product', 2, 98), ('Product', 1, 99)]\n    assert candidate([(\"Book\", 80, 1), (\"Chair\", 60, 5), (\"Lamp\", 80, 2), (\"Table\", 70, 20)]) == [('Book', 80, 1), ('Lamp', 80, 2), ('Table', 70, 20), ('Chair', 60, 5)]\n    assert candidate([(\"Item1\", 50, 10), (\"Item2\", 50, 10), (\"Item3\", 50, 10), (\"Item4\", 50, 10)]) == [('Item1', 50, 10), ('Item2', 50, 10), ('Item3', 50, 10), ('Item4', 50, 10)]\n    assert candidate([(\"A\", 1, 100), (\"B\", 100, 1), (\"C\", 50, 50)]) == [('B', 100, 1), ('C', 50, 50), ('A', 1, 100)]\n", "language": "python"}
{"task_id": "f245fc6f-664e-4f84-8045-eb715c1505f31269654705184770221", "prompt": "I need you to finish implementing a function that's ready to run. Write the complete function in a single code block, without any code outside it. Use only libraries that are imported in the problem statement. If you need helper functions or classes, define them within the main function. Provide just one code block in your solution.\n\n```python\ndef encode_message(message: str) -> str:\n    \"\"\"\n    A group of friends has developed a simple encoding system for their secret messages.\n    This function takes a string message and encodes it by replacing each character with its ASCII value,\n    separated by dashes.\n\n\n    [EXAMPLES]\n    \n    assert candidate(\"Secret\") == '83-101-99-114-101-116'\n    assert candidate(\"A\") == '65'\n\n    [/EXAMPLES]\n    \"\"\"\n```\n", "entry_point": "encode_message", "solution": "def encode_message(message: str) -> str:\n    \"\"\"\n    A group of friends has developed a simple encoding system for their secret messages.\n    This function takes a string message and encodes it by replacing each character with its ASCII value,\n    separated by dashes.\n\n\n    [EXAMPLES]\n    \n    assert candidate(\"Secret\") == '83-101-99-114-101-116'\n    assert candidate(\"A\") == '65'\n\n    [/EXAMPLES]\n    \"\"\"\n    # Convert each character to its ASCII value\n    ascii_values = [str(ord(char)) for char in message]\n    \n    # Join the ASCII values with dashes\n    encoded_message = \"-\".join(ascii_values)\n    \n    return encoded_message\n\n", "test": "def check(candidate):\n    assert candidate(\"Python\") == '80-121-116-104-111-110'\n    assert candidate(\"abcdefghijklmnopqrstuvwxyz\") == '97-98-99-100-101-102-103-104-105-106-107-108-109-110-111-112-113-114-115-116-117-118-119-120-121-122'\n    assert candidate(\"A\") == '65'\n    assert candidate(\"Secret\") == '83-101-99-114-101-116'\n", "language": "python"}
{"task_id": "6809eab0-8356-457c-a69d-3420e1c62841-9174008002093955618", "prompt": "Please complete the function implementation according to the documentation string. Maintain the existing function signature (name and parameters) and provide the entire solution in one code block.\n\n```python\ndef decode_alien_message(encoded_message: str, codebook: dict) -> str:\n    \"\"\"\n    An alien civilization has sent a message to Earth, but it's encoded using their unique language.\n    Scientists have managed to create a codebook that maps alien symbols to Earth letters, but they need\n    help decoding the full message.\n\n    Write a function that takes an encoded message (string of alien symbols) and a codebook (dictionary\n    mapping alien symbols to Earth letters) as input, and returns the decoded message in Earth language.\n\n    If a symbol in the encoded message is not found in the codebook, leave it unchanged in the output.\n\n\n    [EXAMPLES]\n    \n    assert candidate(\"123abc\", {\"1\": \"X\", \"2\": \"Y\", \"3\": \"Z\", \"a\": \"P\", \"b\": \"Q\", \"c\": \"R\"}) == 'XYZPQR'\n    assert candidate(\"abc\", {\"a\": \"1\", \"b\": \"2\", \"c\": \"3\"}) == '123'\n\n    [/EXAMPLES]\n    \"\"\"\n```\n", "entry_point": "decode_alien_message", "solution": "def decode_alien_message(encoded_message: str, codebook: dict) -> str:\n    \"\"\"\n    An alien civilization has sent a message to Earth, but it's encoded using their unique language.\n    Scientists have managed to create a codebook that maps alien symbols to Earth letters, but they need\n    help decoding the full message.\n\n    Write a function that takes an encoded message (string of alien symbols) and a codebook (dictionary\n    mapping alien symbols to Earth letters) as input, and returns the decoded message in Earth language.\n\n    If a symbol in the encoded message is not found in the codebook, leave it unchanged in the output.\n\n\n    [EXAMPLES]\n    \n    assert candidate(\"123abc\", {\"1\": \"X\", \"2\": \"Y\", \"3\": \"Z\", \"a\": \"P\", \"b\": \"Q\", \"c\": \"R\"}) == 'XYZPQR'\n    assert candidate(\"abc\", {\"a\": \"1\", \"b\": \"2\", \"c\": \"3\"}) == '123'\n\n    [/EXAMPLES]\n    \"\"\"\n    decoded_message = \"\"\n    for symbol in encoded_message:\n        decoded_message += codebook.get(symbol, symbol)\n    return decoded_message\n\n", "test": "def check(candidate):\n    assert candidate(\"abcdefghijklmnopqrstuvwxyz\", {\"a\": \"z\", \"b\": \"y\", \"c\": \"x\", \"d\": \"w\", \"e\": \"v\", \"f\": \"u\", \"g\": \"t\", \"h\": \"s\", \"i\": \"r\", \"j\": \"q\", \"k\": \"p\", \"l\": \"o\", \"m\": \"n\", \"n\": \"m\", \"o\": \"l\", \"p\": \"k\", \"q\": \"j\", \"r\": \"i\", \"s\": \"h\", \"t\": \"g\", \"u\": \"f\", \"v\": \"e\", \"w\": \"d\", \"x\": \"c\", \"y\": \"b\", \"z\": \"a\"}) == 'zyxwvutsrqponmlkjihgfedcba'\n    assert candidate(\"hello world\", {\"h\": \"H\", \"e\": \"E\", \"l\": \"L\", \"o\": \"O\", \"w\": \"W\", \"r\": \"R\", \"d\": \"D\"}) == 'HELLO WORLD'\n    assert candidate(\"abcABC123\", {\"a\": \"1\", \"b\": \"2\", \"c\": \"3\", \"A\": \"X\", \"B\": \"Y\", \"C\": \"Z\"}) == '123XYZ123'\n    assert candidate(\"xyz\", {}) == 'xyz'\n    assert candidate(\"aA1!bB2@\", {\"a\": \"1\", \"A\": \"2\", \"1\": \"3\", \"!\": \"4\", \"b\": \"5\", \"B\": \"6\", \"2\": \"7\", \"@\": \"8\"}) == '12345678'\n    assert candidate(\"#@%&\", {\"#\": \"h\", \"@\": \"e\", \"%\": \"l\", \"&\": \"o\"}) == 'helo'\n    assert candidate(\"hello\", {\"h\": \"H\", \"e\": \"E\", \"l\": \"L\", \"o\": \"O\"}) == 'HELLO'\n    assert candidate(\"abcdefg\", {\"a\": \"z\", \"b\": \"y\", \"c\": \"x\", \"d\": \"w\", \"e\": \"v\", \"f\": \"u\", \"g\": \"t\"}) == 'zyxwvut'\n    assert candidate(\"123abc\", {\"1\": \"X\", \"2\": \"Y\", \"3\": \"Z\", \"a\": \"P\", \"b\": \"Q\", \"c\": \"R\"}) == 'XYZPQR'\n    assert candidate(\"abc\", {\"a\": \"1\", \"b\": \"2\", \"c\": \"3\"}) == '123'\n", "language": "python"}
{"task_id": "70fa54c4-1fa0-4ae6-b83d-c4be8eeb979f1329317056288222129", "prompt": "I'll complete the given function so it's ready to run. The solution will be contained in one code block with no external code. Any additional functions will be nested within the main function, and I'll only use libraries that were imported in the problem.\n\n```python\nfrom typing import List, Tuple\n\ndef analyze_stock_data(prices: List[float], dates: List[str]) -> Tuple[float, str, str]:\n    \"\"\"\n    A financial analyst needs to determine the best time to buy and sell a stock\n    to maximize profit. Given a list of stock prices and corresponding dates,\n    find the maximum profit that could have been made by buying on one day and\n    selling on a later day.\n\n    This function takes two parallel lists: one with daily stock prices and another\n    with corresponding dates. It returns the maximum profit possible, along with\n    the optimal buy and sell dates.\n\n\n    [EXAMPLES]\n    \n    assert candidate([1.0, 2.0], ['2023-01-01', '2023-01-02']) == (1.0, '2023-01-01', '2023-01-02')\n    assert candidate([5.0, 5.0, 5.0, 5.0, 10.0], ['2023-01-01', '2023-01-02', '2023-01-03', '2023-01-04', '2023-01-05']) == (5.0, '2023-01-01', '2023-01-05')\n\n    [/EXAMPLES]\n    \"\"\"\n```\n", "entry_point": "analyze_stock_data", "solution": "from typing import List, Tuple\n\ndef analyze_stock_data(prices: List[float], dates: List[str]) -> Tuple[float, str, str]:\n    \"\"\"\n    A financial analyst needs to determine the best time to buy and sell a stock\n    to maximize profit. Given a list of stock prices and corresponding dates,\n    find the maximum profit that could have been made by buying on one day and\n    selling on a later day.\n\n    This function takes two parallel lists: one with daily stock prices and another\n    with corresponding dates. It returns the maximum profit possible, along with\n    the optimal buy and sell dates.\n\n\n    [EXAMPLES]\n    \n    assert candidate([1.0, 2.0], ['2023-01-01', '2023-01-02']) == (1.0, '2023-01-01', '2023-01-02')\n    assert candidate([5.0, 5.0, 5.0, 5.0, 10.0], ['2023-01-01', '2023-01-02', '2023-01-03', '2023-01-04', '2023-01-05']) == (5.0, '2023-01-01', '2023-01-05')\n\n    [/EXAMPLES]\n    \"\"\"\n    if len(prices) != len(dates) or len(prices) < 2:\n        return (0.0, \"\", \"\")\n\n    max_profit = 0.0\n    buy_date = sell_date = \"\"\n    min_price = float('inf')\n    min_date = \"\"\n\n    for i in range(len(prices)):\n        if prices[i] < min_price:\n            min_price = prices[i]\n            min_date = dates[i]\n        \n        current_profit = prices[i] - min_price\n        if current_profit > max_profit:\n            max_profit = current_profit\n            buy_date = min_date\n            sell_date = dates[i]\n\n    return (max_profit, buy_date, sell_date)\n\n", "test": "def check(candidate):\n    assert candidate([5.0, 5.0, 5.0, 5.0, 10.0], ['2023-01-01', '2023-01-02', '2023-01-03', '2023-01-04', '2023-01-05']) == (5.0, '2023-01-01', '2023-01-05')\n    assert candidate([10.0, 7.5, 5.0, 8.0, 11.5, 9.0], ['2023-01-01', '2023-01-02', '2023-01-03', '2023-01-04', '2023-01-05', '2023-01-06']) == (6.5, '2023-01-03', '2023-01-05')\n    assert candidate([1000.0, 1000.0, 1000.0, 1000.0, 1000.1], ['2023-01-01', '2023-01-02', '2023-01-03', '2023-01-04', '2023-01-05']) == (0.10000000000002274, '2023-01-01', '2023-01-05')\n    assert candidate([50.0, 50.0, 50.0, 50.0, 50.0], ['2023-01-01', '2023-01-02', '2023-01-03', '2023-01-04', '2023-01-05']) == (0.0, '', '')\n    assert candidate([1.0, 2.0], ['2023-01-01', '2023-01-02']) == (1.0, '2023-01-01', '2023-01-02')\n    assert candidate([100.0, 180.0, 260.0, 310.0, 40.0, 535.0, 695.0], ['2023-01-01', '2023-01-02', '2023-01-03', '2023-01-04', '2023-01-05', '2023-01-06', '2023-01-07']) == (655.0, '2023-01-05', '2023-01-07')\n    assert candidate([10.5, 11.2, 10.8, 11.7, 12.3, 11.9], ['2023-01-01', '2023-01-02', '2023-01-03', '2023-01-04', '2023-01-05', '2023-01-06']) == (1.8000000000000007, '2023-01-01', '2023-01-05')\n    assert candidate([10.0, 20.0, 30.0, 20.0, 10.0], ['2023-01-01', '2023-01-02', '2023-01-03', '2023-01-04', '2023-01-05']) == (20.0, '2023-01-01', '2023-01-03')\n    assert candidate([1.0, 1.1, 1.2, 1.3, 1.4, 1.5, 1.6, 1.7, 1.8, 1.9], ['2023-01-01', '2023-01-02', '2023-01-03', '2023-01-04', '2023-01-05', '2023-01-06', '2023-01-07', '2023-01-08', '2023-01-09', '2023-01-10']) == (0.8999999999999999, '2023-01-01', '2023-01-10')\n    assert candidate([1000.0, 900.0, 800.0, 700.0, 600.0, 500.0], ['2023-01-01', '2023-01-02', '2023-01-03', '2023-01-04', '2023-01-05', '2023-01-06']) == (0.0, '', '')\n", "language": "python"}
{"task_id": "80daaf82-6802-4ba2-8277-e7e2c380fb1e-430999869035194447", "prompt": "Complete the function implementation based on the provided docstring. Include a single code block with the full function. Handle edge cases appropriately.\n\n```python\nfrom typing import List\n\ndef optimize_fruit_harvest(trees: List[int]) -> int:\n    \"\"\"\n    You are managing an orchard with a row of fruit trees. Each tree produces a certain number of fruits,\n    represented by the integer list 'trees'. You want to optimize the harvest by selecting trees to pick\n    fruits from, but you can't pick from adjacent trees due to a harvesting machine constraint.\n\n    Your task is to determine the maximum number of fruits you can harvest while following this constraint.\n\n\n    [EXAMPLES]\n    \n    assert candidate([100]) == 100\n    assert candidate([1, 1, 1, 1, 1, 1, 1, 1]) == 4\n\n    [/EXAMPLES]\n    \"\"\"\n```\n", "entry_point": "optimize_fruit_harvest", "solution": "from typing import List\n\ndef optimize_fruit_harvest(trees: List[int]) -> int:\n    \"\"\"\n    You are managing an orchard with a row of fruit trees. Each tree produces a certain number of fruits,\n    represented by the integer list 'trees'. You want to optimize the harvest by selecting trees to pick\n    fruits from, but you can't pick from adjacent trees due to a harvesting machine constraint.\n\n    Your task is to determine the maximum number of fruits you can harvest while following this constraint.\n\n\n    [EXAMPLES]\n    \n    assert candidate([100]) == 100\n    assert candidate([1, 1, 1, 1, 1, 1, 1, 1]) == 4\n\n    [/EXAMPLES]\n    \"\"\"\n    if not trees:\n        return 0\n    \n    n = len(trees)\n    \n    if n == 1:\n        return trees[0]\n    \n    if n == 2:\n        return max(trees[0], trees[1])\n    \n    # Initialize dp array\n    dp = [0] * n\n    \n    # Base cases\n    dp[0] = trees[0]\n    dp[1] = max(trees[0], trees[1])\n    \n    # Fill dp array\n    for i in range(2, n):\n        dp[i] = max(dp[i-1], dp[i-2] + trees[i])\n    \n    # Return the maximum number of fruits that can be harvested\n    return dp[-1]\n\n", "test": "def check(candidate):\n    assert candidate([100]) == 100\n    assert candidate([1, 5, 1, 5, 1, 5, 1, 5, 1, 5]) == 25\n    assert candidate([1000000, 1, 1000000, 1, 1000000]) == 3000000\n    assert candidate([1, 10, 1, 10, 1]) == 20\n    assert candidate([100, 1, 1, 1, 100]) == 201\n    assert candidate([5, 5, 5, 5, 5]) == 15\n    assert candidate([10, 1, 10, 1, 10]) == 30\n    assert candidate([]) == 0\n    assert candidate([1, 1, 1, 1, 1, 1, 1, 1]) == 4\n    assert candidate([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15]) == 64\n", "language": "python"}
{"task_id": "d87ebc9d-d599-4bcb-9372-44fff3b7c00c8185191049395876120", "prompt": "Complete the specified function in a single code block that can be executed as provided. Don't include any code outside the function body. Only use libraries that were imported in the problem description. Any helper functions or classes must be defined within the main function. Deliver only one complete code block.\n\n```python\nfrom typing import List, Tuple\n\ndef decrypt_alien_message(message: str, key: List[Tuple[str, str]]) -> str:\n    \"\"\"\n    A team of cryptographers has intercepted an alien message. They've determined that the aliens use a substitution\n    cipher, where each symbol in their language is replaced by a different symbol. The team has partially cracked the\n    code and needs your help to decipher the rest of the message.\n\n    This function takes the encrypted message as a string and a list of known symbol substitutions (as tuples). It\n    should return the decrypted message. Use string manipulation and dictionary data structures to solve this problem.\n\n    :param message: The encrypted alien message\n    :param key: A list of tuples representing known symbol substitutions (alien_symbol, earth_symbol)\n    :return: The decrypted message\n\n\n    [EXAMPLES]\n    \n    assert candidate(\"!@#$%^&*()\", [(\"!\", \"S\"), (\"@\", \"P\"), (\"#\", \"A\"), (\"$\", \"C\"), (\"%\", \"E\")]) == 'SPACE?????'\n    assert candidate(\"\", []) == ''\n\n    [/EXAMPLES]\n    \"\"\"\n```\n", "entry_point": "decrypt_alien_message", "solution": "from typing import List, Tuple\n\ndef decrypt_alien_message(message: str, key: List[Tuple[str, str]]) -> str:\n    \"\"\"\n    A team of cryptographers has intercepted an alien message. They've determined that the aliens use a substitution\n    cipher, where each symbol in their language is replaced by a different symbol. The team has partially cracked the\n    code and needs your help to decipher the rest of the message.\n\n    This function takes the encrypted message as a string and a list of known symbol substitutions (as tuples). It\n    should return the decrypted message. Use string manipulation and dictionary data structures to solve this problem.\n\n    :param message: The encrypted alien message\n    :param key: A list of tuples representing known symbol substitutions (alien_symbol, earth_symbol)\n    :return: The decrypted message\n\n\n    [EXAMPLES]\n    \n    assert candidate(\"!@#$%^&*()\", [(\"!\", \"S\"), (\"@\", \"P\"), (\"#\", \"A\"), (\"$\", \"C\"), (\"%\", \"E\")]) == 'SPACE?????'\n    assert candidate(\"\", []) == ''\n\n    [/EXAMPLES]\n    \"\"\"\n    # Create a dictionary from the key tuples\n    substitution_dict = dict(key)\n    \n    # Initialize the decrypted message\n    decrypted_message = \"\"\n    \n    # Iterate through each character in the message\n    for char in message:\n        # If the character is in the substitution dictionary, replace it\n        # Otherwise, use a question mark\n        decrypted_message += substitution_dict.get(char, \"?\")\n    \n    return decrypted_message\n\n", "test": "def check(candidate):\n    assert candidate(\"12345\", [(\"1\", \"O\"), (\"2\", \"N\"), (\"3\", \"E\")]) == 'ONE??'\n    assert candidate(\"abcdefghijklmnopqrstuvwxyz\", [(\"a\", \"Z\"), (\"z\", \"A\")]) == 'Z????????????????????????A'\n    assert candidate(\"QWERTYUIOP\", [(\"Q\", \"A\"), (\"W\", \"B\"), (\"E\", \"C\"), (\"R\", \"D\"), (\"T\", \"E\")]) == 'ABCDE?????'\n    assert candidate(\"ABCDEFG\", [(\"A\", \"H\"), (\"C\", \"L\"), (\"E\", \"O\")]) == 'H?L?O??'\n    assert candidate(\"The quick brown fox\", [(\"T\", \"A\"), (\"q\", \"b\"), (\"f\", \"g\")]) == 'A???b???????????g??'\n    assert candidate(\"!@#$%^&*()\", [(\"!\", \"S\"), (\"@\", \"P\"), (\"#\", \"A\"), (\"$\", \"C\"), (\"%\", \"E\")]) == 'SPACE?????'\n    assert candidate(\"AABBCCDD\", [(\"A\", \"1\"), (\"B\", \"2\"), (\"C\", \"3\"), (\"D\", \"4\")]) == '11223344'\n    assert candidate(\"ZYXWVUTSRQPONMLKJIHGFEDCBA\", [(\"A\", \"Z\"), (\"Z\", \"A\")]) == 'A????????????????????????Z'\n    assert candidate(\"\", []) == ''\n    assert candidate(\"a1b2c3d4e5f6g7h8i9j0\", [(\"a\", \"1\"), (\"b\", \"2\"), (\"c\", \"3\"), (\"d\", \"4\"), (\"e\", \"5\")]) == '1?2?3?4?5???????????'\n", "language": "python"}
{"task_id": "2f012d35-2f61-48d7-8b23-addafba10d08-7773659987719219490", "prompt": "Your role is to assist with coding tasks by completing functions that are executable in code blocks. Restrict your code to the function itself without adding external code. Utilize only the libraries that are imported in the original problem. Any additional functions or classes must be defined within the scope of the given function.\n\n```python\nfrom typing import List\n\ndef space_colony_resource_allocation(resources: List[int], colonists: int) -> int:\n    \"\"\"\n    In a future Mars colony, we need to allocate limited resources among colonists. \n    Given a list of available resource units and the number of colonists, determine \n    the maximum number of resource units that can be equally distributed to each colonist \n    without any remainder.\n\n    This function uses binary search to efficiently find the optimal allocation.\n\n\n    [EXAMPLES]\n    \n    assert candidate([1], 1) == 0\n    assert candidate([1000000, 2000000, 3000000], 1000000) == 5\n\n    [/EXAMPLES]\n    \"\"\"\n```\n", "entry_point": "space_colony_resource_allocation", "solution": "from typing import List\n\ndef space_colony_resource_allocation(resources: List[int], colonists: int) -> int:\n    \"\"\"\n    In a future Mars colony, we need to allocate limited resources among colonists. \n    Given a list of available resource units and the number of colonists, determine \n    the maximum number of resource units that can be equally distributed to each colonist \n    without any remainder.\n\n    This function uses binary search to efficiently find the optimal allocation.\n\n\n    [EXAMPLES]\n    \n    assert candidate([1], 1) == 0\n    assert candidate([1000000, 2000000, 3000000], 1000000) == 5\n\n    [/EXAMPLES]\n    \"\"\"\n    def can_allocate(amount):\n        return sum(resource // amount for resource in resources) >= colonists\n\n    left, right = 0, max(resources)\n    result = 0\n\n    while left <= right:\n        mid = (left + right) // 2\n        if mid == 0:\n            return 0\n        \n        if can_allocate(mid):\n            result = mid\n            left = mid + 1\n        else:\n            right = mid - 1\n\n    return result\n\n", "test": "def check(candidate):\n    assert candidate([1, 2, 3, 4, 5, 6, 7, 8, 9, 10], 10) == 4\n    assert candidate([1, 10, 100, 1000], 4) == 250\n    assert candidate([1000000] * 10, 1000000) == 10\n    assert candidate([1, 2, 3, 4, 5], 1) == 5\n    assert candidate([999, 1000, 1001], 3) == 999\n    assert candidate([2, 4, 6, 8, 10], 3) == 6\n    assert candidate([1], 1) == 0\n    assert candidate([1, 3, 5, 7, 9], 2) == 7\n    assert candidate([1000000, 2000000, 3000000], 1000000) == 5\n    assert candidate([1, 1, 1, 1, 1], 10) == 0\n", "language": "python"}
{"task_id": "099a13c7-37a4-47a1-a2bc-50c30d4e32d024880556517059632", "prompt": "Finalize this function based on the provided docstring. Deliver your solution in one code block, with thorough handling of edge cases.\n\n```python\nfrom typing import List\n\ndef optimize_production_line(machines: List[int], target: int) -> int:\n    \"\"\"\n    A factory manager needs to optimize a production line to meet a target output.\n    Each machine in the line has a different production rate (items per hour).\n    The goal is to find the minimum number of hours needed to produce at least\n    the target number of items.\n\n    This function uses binary search to efficiently find the optimal time.\n\n\n    [EXAMPLES]\n    \n    assert candidate([1, 1, 2, 3, 5, 8, 13], 100) == 32\n    assert candidate([9999], 1000000) == 9999000000\n\n    [/EXAMPLES]\n    \"\"\"\n```\n", "entry_point": "optimize_production_line", "solution": "from typing import List\n\ndef optimize_production_line(machines: List[int], target: int) -> int:\n    \"\"\"\n    A factory manager needs to optimize a production line to meet a target output.\n    Each machine in the line has a different production rate (items per hour).\n    The goal is to find the minimum number of hours needed to produce at least\n    the target number of items.\n\n    This function uses binary search to efficiently find the optimal time.\n\n\n    [EXAMPLES]\n    \n    assert candidate([1, 1, 2, 3, 5, 8, 13], 100) == 32\n    assert candidate([9999], 1000000) == 9999000000\n\n    [/EXAMPLES]\n    \"\"\"\n    def can_produce(hours: int) -> bool:\n        return sum(hours // rate for rate in machines) >= target\n\n    left, right = 0, target * max(machines)  # Initialize search range\n\n    while left < right:\n        mid = (left + right) // 2\n        if can_produce(mid):\n            right = mid\n        else:\n            left = mid + 1\n\n    return left\n\n", "test": "def check(candidate):\n    assert candidate([10, 20, 30], 1000) == 5460\n    assert candidate([2, 3, 5], 10) == 10\n    assert candidate([9999], 1000000) == 9999000000\n    assert candidate([1, 3, 5, 7, 9], 100) == 57\n    assert candidate([5, 5, 5], 100) == 170\n    assert candidate([1], 5) == 5\n    assert candidate([1, 10, 100, 1000], 10000) == 9001\n    assert candidate([1, 1, 2, 3, 5, 8, 13], 100) == 32\n    assert candidate([2, 2, 2, 2, 2], 50) == 20\n    assert candidate([10], 100) == 1000\n", "language": "python"}
{"task_id": "f75f4274-59c8-48e7-bf5c-42c6bb1fc891-4441260891438213172", "prompt": "Your goal is to implement the provided function so it works when executed directly. All code must remain contained within the function - do not add external code. Use only the libraries that are imported in the original problem. If you need supplementary functions or classes, define them inside the main function.\n\n```python\nfrom typing import List\n\ndef predict_stock_prices(historical_data: List[int], future_days: int) -> List[int]:\n    \"\"\"\n    A financial analyst is developing a model to predict future stock prices based on historical\n    data. The model assumes that stock prices follow a pattern where each day's price is the sum\n    of the previous three days' prices, modulo 100 (to keep the values manageable).\n\n    Given a list of historical stock prices and the number of future days to predict, return a\n    list of predicted stock prices for those future days.\n\n\n    [EXAMPLES]\n    \n    assert candidate([1, 2, 3, 4, 5], 3) == [12, 21, 38]\n    assert candidate([99, 99, 99], 10) == [97, 95, 91, 83, 69, 43, 95, 7, 45, 47]\n\n    [/EXAMPLES]\n    \"\"\"\n```\n", "entry_point": "predict_stock_prices", "solution": "from typing import List\n\ndef predict_stock_prices(historical_data: List[int], future_days: int) -> List[int]:\n    \"\"\"\n    A financial analyst is developing a model to predict future stock prices based on historical\n    data. The model assumes that stock prices follow a pattern where each day's price is the sum\n    of the previous three days' prices, modulo 100 (to keep the values manageable).\n\n    Given a list of historical stock prices and the number of future days to predict, return a\n    list of predicted stock prices for those future days.\n\n\n    [EXAMPLES]\n    \n    assert candidate([1, 2, 3, 4, 5], 3) == [12, 21, 38]\n    assert candidate([99, 99, 99], 10) == [97, 95, 91, 83, 69, 43, 95, 7, 45, 47]\n\n    [/EXAMPLES]\n    \"\"\"\n    def predict_next_price(prices):\n        return sum(prices[-3:]) % 100\n\n    predictions = []\n    current_data = historical_data[:]\n\n    for _ in range(future_days):\n        next_price = predict_next_price(current_data)\n        predictions.append(next_price)\n        current_data.append(next_price)\n\n    return predictions\n\n", "test": "def check(candidate):\n    assert candidate([1, 1, 1, 1, 1], 10) == [3, 5, 9, 17, 31, 57, 5, 93, 55, 53]\n    assert candidate([25, 50, 75, 0], 8) == [25, 0, 25, 50, 75, 50, 75, 0]\n    assert candidate([100, 200, 300], 8) == [0, 0, 0, 0, 0, 0, 0, 0]\n    assert candidate([100], 20) == [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]\n    assert candidate([3, 6, 9, 12, 15, 18, 21], 6) == [54, 93, 68, 15, 76, 59]\n    assert candidate([50, 25, 75, 50], 6) == [50, 75, 75, 0, 50, 25]\n    assert candidate([11, 22, 33, 44, 55], 4) == [32, 31, 18, 81]\n    assert candidate([99, 99, 99], 10) == [97, 95, 91, 83, 69, 43, 95, 7, 45, 47]\n    assert candidate([1, 2, 3, 4, 5], 3) == [12, 21, 38]\n    assert candidate([9, 8, 7, 6, 5, 4, 3, 2, 1], 3) == [6, 9, 16]\n", "language": "python"}
