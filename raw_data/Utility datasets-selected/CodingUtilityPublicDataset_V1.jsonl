{"task_id": "b36c02e6-b553-44a0-9715-b6aef66df0227159192211925794875", "prompt": "Finish coding the function, adhering to the specifications outlined in the doc string. Present the entire function in a single code block, keeping the function name and arguments as they are.\n\n```python\ndef chess_knight_moves(start: str, end: str) -> int:\n    \"\"\"\n    In the game of chess, a knight has a unique L-shaped move.\n    This function calculates the minimum number of moves a knight needs to reach a target position on a standard 8x8 chessboard.\n\n    The start and end positions are given in algebraic notation (e.g., \"a1\", \"h8\").\n    Implement a breadth-first search algorithm to find the shortest path.\n\n\n    [EXAMPLES]\n    \n    assert candidate(\"a1\", \"h8\") == 6\n    assert candidate(\"f8\", \"b4\") == 4\n\n    [/EXAMPLES]\n    \"\"\"\n```\n", "entry_point": "chess_knight_moves", "solution": "def chess_knight_moves(start: str, end: str) -> int:\n    \"\"\"\n    In the game of chess, a knight has a unique L-shaped move.\n    This function calculates the minimum number of moves a knight needs to reach a target position on a standard 8x8 chessboard.\n\n    The start and end positions are given in algebraic notation (e.g., \"a1\", \"h8\").\n    Implement a breadth-first search algorithm to find the shortest path.\n\n\n    [EXAMPLES]\n    \n    assert candidate(\"a1\", \"h8\") == 6\n    assert candidate(\"f8\", \"b4\") == 4\n\n    [/EXAMPLES]\n    \"\"\"\n    from collections import deque\n\n    def algebraic_to_coords(pos):\n        return (ord(pos[0]) - ord('a'), int(pos[1]) - 1)\n\n    def is_valid(x, y):\n        return 0 <= x < 8 and 0 <= y < 8\n\n    def get_neighbors(x, y):\n        moves = [\n            (-2, -1), (-2, 1), (-1, -2), (-1, 2),\n            (1, -2), (1, 2), (2, -1), (2, 1)\n        ]\n        return [(x + dx, y + dy) for dx, dy in moves if is_valid(x + dx, y + dy)]\n\n    start_pos = algebraic_to_coords(start)\n    end_pos = algebraic_to_coords(end)\n\n    queue = deque([(start_pos, 0)])\n    visited = set([start_pos])\n\n    while queue:\n        (x, y), moves = queue.popleft()\n\n        if (x, y) == end_pos:\n            return moves\n\n        for nx, ny in get_neighbors(x, y):\n            if (nx, ny) not in visited:\n                visited.add((nx, ny))\n                queue.append(((nx, ny), moves + 1))\n\n    return -1  # If the end position is unreachable (which shouldn't happen on a standard chessboard)\n\n", "test": "def check(candidate):\n    assert candidate(\"g3\", \"b8\") == 4\n    assert candidate(\"f1\", \"f8\") == 5\n    assert candidate(\"e2\", \"e7\") == 3\n    assert candidate(\"f8\", \"b4\") == 4\n    assert candidate(\"h8\", \"a1\") == 6\n    assert candidate(\"d1\", \"d8\") == 5\n    assert candidate(\"d4\", \"f5\") == 1\n    assert candidate(\"a1\", \"h8\") == 6\n    assert candidate(\"e4\", \"e4\") == 0\n    assert candidate(\"h4\", \"a5\") == 4\n", "language": "python"}
{"task_id": "e84ec5ca-68e6-4e82-ac31-61534b6d30a5-1072357988645329395", "prompt": "Your goal is to fill in the given function, ensuring it's self-contained and executable in one code block. Refrain from adding any code outside the function. Restrict yourself to using only the libraries that are already imported in the problem. If necessary, define any additional functions or classes inside the main function. Present your solution as a single code block.\n\n```python\nfrom typing import List\nfrom collections import Counter\nimport math\n\ndef calculate_dinosaur_diversity(fossil_records: List[str], time_period: int) -> float:\n    \"\"\"\n    Analyze the diversity of dinosaur species based on fossil records from a specific geological time period.\n\n    This function takes a list of fossil records and a time period as input, then calculates the Shannon diversity index\n    for the dinosaur species present during that time. The Shannon diversity index is a measure of species diversity\n    in a community that considers both the number of species present and their relative abundances.\n\n    Args:\n    fossil_records (List[str]): A list of strings, each representing a fossil record in the format \"species_name,time_period\".\n    time_period (int): The geological time period of interest (in millions of years ago).\n\n    Returns:\n    float: The calculated Shannon diversity index for the specified time period.\n\n\n    [EXAMPLES]\n    \n    assert candidate([\"Tyrannosaurus,68\", \"Triceratops,68\", \"Velociraptor,75\", \"Stegosaurus,150\", \"Brachiosaurus,154\"], 68) == 0.6931471805599453\n    assert candidate([\"Tyrannosaurus,68\", \"Triceratops,68\", \"Velociraptor,75\", \"Stegosaurus,150\", \"Brachiosaurus,154\"], 200) == 0\n\n    [/EXAMPLES]\n    \"\"\"\n```\n", "entry_point": "calculate_dinosaur_diversity", "solution": "from typing import List\nfrom collections import Counter\nimport math\n\ndef calculate_dinosaur_diversity(fossil_records: List[str], time_period: int) -> float:\n    \"\"\"\n    Analyze the diversity of dinosaur species based on fossil records from a specific geological time period.\n\n    This function takes a list of fossil records and a time period as input, then calculates the Shannon diversity index\n    for the dinosaur species present during that time. The Shannon diversity index is a measure of species diversity\n    in a community that considers both the number of species present and their relative abundances.\n\n    Args:\n    fossil_records (List[str]): A list of strings, each representing a fossil record in the format \"species_name,time_period\".\n    time_period (int): The geological time period of interest (in millions of years ago).\n\n    Returns:\n    float: The calculated Shannon diversity index for the specified time period.\n\n\n    [EXAMPLES]\n    \n    assert candidate([\"Tyrannosaurus,68\", \"Triceratops,68\", \"Velociraptor,75\", \"Stegosaurus,150\", \"Brachiosaurus,154\"], 68) == 0.6931471805599453\n    assert candidate([\"Tyrannosaurus,68\", \"Triceratops,68\", \"Velociraptor,75\", \"Stegosaurus,150\", \"Brachiosaurus,154\"], 200) == 0\n\n    [/EXAMPLES]\n    \"\"\"\n    # Filter fossil records for the specified time period\n    relevant_fossils = [record.split(',')[0] for record in fossil_records if int(record.split(',')[1]) == time_period]\n    \n    # If no fossils found for the given time period, return 0\n    if not relevant_fossils:\n        return 0.0\n    \n    # Count the occurrences of each species\n    species_counts = Counter(relevant_fossils)\n    \n    # Calculate the total number of individuals\n    total_count = sum(species_counts.values())\n    \n    # Calculate Shannon diversity index\n    shannon_index = 0\n    for count in species_counts.values():\n        proportion = count / total_count\n        shannon_index -= proportion * math.log(proportion)\n    \n    return shannon_index\n\n", "test": "def check(candidate):\n    assert candidate([\"Tyrannosaurus,68\"], 68) == 0.0\n    assert candidate([\"Tyrannosaurus,68\", \"Triceratops,68\", \"Velociraptor,68\", \"Stegosaurus,68\", \"Brachiosaurus,68\"], 70) == 0\n    assert candidate([\"A,1\", \"B,2\", \"C,3\", \"D,4\", \"E,5\"], 3) == 0.0\n    assert candidate([\"Tyrannosaurus,68\", \"Triceratops,68\", \"Velociraptor,75\", \"Stegosaurus,150\", \"Brachiosaurus,154\"], 0) == 0.0\n    assert candidate([\"Tyrannosaurus,68\", \"Triceratops,68\", \"Velociraptor,75\", \"Stegosaurus,150\", \"Brachiosaurus,154\"], 200) == 0\n    assert candidate([\"Tyrannosaurus,68\", \"Triceratops,68\", \"Velociraptor,68\", \"Stegosaurus,68\", \"Brachiosaurus,68\"], 70) == 0.0\n    assert candidate([\"Tyrannosaurus,68\", \"Triceratops,68\", \"Tyrannosaurus,68\", \"Triceratops,68\"], 68) == 0.6931471805599453\n    assert candidate([\"A,1\", \"B,1\", \"C,1\", \"D,1\", \"E,1\", \"F,1\", \"G,1\", \"H,1\", \"I,1\", \"J,1\"], 1) == 2.3025850929940455\n    assert candidate([\"Tyrannosaurus,68\", \"Triceratops,68\", \"Velociraptor,75\", \"Stegosaurus,150\", \"Brachiosaurus,154\"], 0) == 0\n    assert candidate([\"Tyrannosaurus,68\", \"Triceratops,68\", \"Velociraptor,75\", \"Stegosaurus,150\", \"Brachiosaurus,154\"], 68) == 0.6931471805599453\n", "language": "python"}
{"task_id": "cfa6e909-6b43-493b-99b7-1204eb7f9d151939090157697497355", "prompt": "Kindly finish writing the function, ensuring it adheres to the specifications outlined in the doc string. Include the full function in one cohesive code block. Be sure to take into account any possible edge cases.\n\n```python\ndef generate_alien_language(seed: int, length: int) -> str:\n    \"\"\"\n    Generate an alien language sample based on a seed value and desired length.\n\n    This function creates a sample of an alien language using a combination of\n    consonants and vowels. The seed value determines the initial state of the\n    random number generator, ensuring reproducibility. The generated language\n    follows certain phonetic rules and structures typical of the fictional alien race.\n\n    Args:\n    seed (int): The seed value for the random number generator.\n    length (int): The desired length of the generated language sample.\n\n    Returns:\n    str: A string representing a sample of the alien language.\n\n\n    [EXAMPLES]\n    \n    assert candidate(0, 1000) == 'ralu qiti jugiga luzema ditufi nuju sula baqazo kide kegusa nu fiwi funuju xisazo xeme ha lodage du quluke xoxiso panufo nekala kihira ge xu dafezu qa faza ha jabu zala di recu cufo li tuhece nu fuse to vipole bodicu geti mixugi rabu ne ko xoco xocesa hovo zaconi coju debori ja buzaja jilefo dalo le vifela ce lunixa zosopu jo mageli panu ci gu powe foka hudi nira wo nifo to mi gexoda je qa qu motujo pe xere fabu jato jaju fe qiwe zo xo rutito juzebi nicugi goxita va ke ma nego vovu xa vudoji zotozu ba hivuli ti roqa ge naco goza girazo safo ba zenawi qo cu sunazi qi fujaqo jopa co buxu ka vuruma ru dara re borobo lapa pa pebe duge ja bipaze ho ti lebepi miwi xa wu hoge nu ke poce bodago wogu mide puco bono pi defi wu goqero ko vepo dojibo sajifi zerodo wo bala lo xosali juda li naveha mive vewaru lisi gefaqo sewipo retovi come tazebi qava dobica bimegu jaro nohiro se nejesi roqe se cocede ceku zavi rocu woxoti tenica hi ma do kuquko nu za nusi buce devi ji mivolo kamu bo saro sada fe'\n    assert candidate(65535, 60) == 'lo garami si daze zi zomoha woruqe nide ma vo nereso wece'\n\n    [/EXAMPLES]\n    \"\"\"\n```\n", "entry_point": "generate_alien_language", "solution": "def generate_alien_language(seed: int, length: int) -> str:\n    \"\"\"\n    Generate an alien language sample based on a seed value and desired length.\n\n    This function creates a sample of an alien language using a combination of\n    consonants and vowels. The seed value determines the initial state of the\n    random number generator, ensuring reproducibility. The generated language\n    follows certain phonetic rules and structures typical of the fictional alien race.\n\n    Args:\n    seed (int): The seed value for the random number generator.\n    length (int): The desired length of the generated language sample.\n\n    Returns:\n    str: A string representing a sample of the alien language.\n\n\n    [EXAMPLES]\n    \n    assert candidate(0, 1000) == 'ralu qiti jugiga luzema ditufi nuju sula baqazo kide kegusa nu fiwi funuju xisazo xeme ha lodage du quluke xoxiso panufo nekala kihira ge xu dafezu qa faza ha jabu zala di recu cufo li tuhece nu fuse to vipole bodicu geti mixugi rabu ne ko xoco xocesa hovo zaconi coju debori ja buzaja jilefo dalo le vifela ce lunixa zosopu jo mageli panu ci gu powe foka hudi nira wo nifo to mi gexoda je qa qu motujo pe xere fabu jato jaju fe qiwe zo xo rutito juzebi nicugi goxita va ke ma nego vovu xa vudoji zotozu ba hivuli ti roqa ge naco goza girazo safo ba zenawi qo cu sunazi qi fujaqo jopa co buxu ka vuruma ru dara re borobo lapa pa pebe duge ja bipaze ho ti lebepi miwi xa wu hoge nu ke poce bodago wogu mide puco bono pi defi wu goqero ko vepo dojibo sajifi zerodo wo bala lo xosali juda li naveha mive vewaru lisi gefaqo sewipo retovi come tazebi qava dobica bimegu jaro nohiro se nejesi roqe se cocede ceku zavi rocu woxoti tenica hi ma do kuquko nu za nusi buce devi ji mivolo kamu bo saro sada fe'\n    assert candidate(65535, 60) == 'lo garami si daze zi zomoha woruqe nide ma vo nereso wece'\n\n    [/EXAMPLES]\n    \"\"\"\n    import random\n\n    def generate_syllable():\n        consonants = 'bcdfghjklmnpqrstvwxz'\n        vowels = 'aeiou'\n        return random.choice(consonants) + random.choice(vowels)\n\n    def generate_word():\n        word_length = random.randint(1, 3)\n        return ''.join(generate_syllable() for _ in range(word_length))\n\n    random.seed(seed)\n    \n    words = []\n    current_length = 0\n    \n    while current_length < length:\n        new_word = generate_word()\n        if current_length + len(new_word) + (1 if words else 0) <= length:\n            words.append(new_word)\n            current_length += len(new_word) + (1 if words else 0)\n        else:\n            break\n    \n    return ' '.join(words)\n\n", "test": "def check(candidate):\n    assert candidate(65535, 60) == 'lo garami si daze zi zomoha woruqe nide ma vo nereso wece'\n    assert candidate(123456789, 150) == 'suzomo wiqo jubize ze noxidi qaba rudazu sofo li ka wapo kevepa wivo vojigu rorufi qoxo lovefu bova ligaxi wi qiqe le moqoni gi tu juvaca rotu kusuke'\n    assert candidate(0, 1000) == 'ralu qiti jugiga luzema ditufi nuju sula baqazo kide kegusa nu fiwi funuju xisazo xeme ha lodage du quluke xoxiso panufo nekala kihira ge xu dafezu qa faza ha jabu zala di recu cufo li tuhece nu fuse to vipole bodicu geti mixugi rabu ne ko xoco xocesa hovo zaconi coju debori ja buzaja jilefo dalo le vifela ce lunixa zosopu jo mageli panu ci gu powe foka hudi nira wo nifo to mi gexoda je qa qu motujo pe xere fabu jato jaju fe qiwe zo xo rutito juzebi nicugi goxita va ke ma nego vovu xa vudoji zotozu ba hivuli ti roqa ge naco goza girazo safo ba zenawi qo cu sunazi qi fujaqo jopa co buxu ka vuruma ru dara re borobo lapa pa pebe duge ja bipaze ho ti lebepi miwi xa wu hoge nu ke poce bodago wogu mide puco bono pi defi wu goqero ko vepo dojibo sajifi zerodo wo bala lo xosali juda li naveha mive vewaru lisi gefaqo sewipo retovi come tazebi qava dobica bimegu jaro nohiro se nejesi roqe se cocede ceku zavi rocu woxoti tenica hi ma do kuquko nu za nusi buce devi ji mivolo kamu bo saro sada fe'\n    assert candidate(999, 30) == 'duxuto na jeluci kodi ju hi'\n    assert candidate(-100, 25) == 'so qi vawa si ji me ge'\n    assert candidate(555, 5) == 'le'\n    assert candidate(42, 20) == 'faleke fudura de vu'\n", "language": "python"}
{"task_id": "bf574237-da41-4cf6-b462-3970a559552f5544883870961951478", "prompt": "Complete the specified function to make it self-contained and runnable. Refrain from adding code external to the function. Employ solely the libraries mentioned in the problem setup. If necessary, nest any extra functions or classes within the main function definition.\n\n```python\ndef calculate_robot_escape_probability(n: int, k: int, r: int, c: int) -> float:\n    \"\"\"\n    A robot is placed on an n x n grid. It starts at cell (r, c) and can move in any of the four cardinal directions.\n    The robot is programmed to make exactly k moves, choosing a random direction for each move.\n    If the robot moves off the grid at any point during its k moves, it is considered to have escaped.\n    \n    Calculate the probability that the robot will escape the grid after exactly k moves.\n    Return the result rounded to 6 decimal places.\n    \n\n    [EXAMPLES]\n    \n    assert candidate(7, 3, 6, 0) == 0.15625\n    assert candidate(2, 5, 1, 0) == 0.060547\n\n    [/EXAMPLES]\n    \"\"\"\n```\n", "entry_point": "calculate_robot_escape_probability", "solution": "def calculate_robot_escape_probability(n: int, k: int, r: int, c: int) -> float:\n    \"\"\"\n    A robot is placed on an n x n grid. It starts at cell (r, c) and can move in any of the four cardinal directions.\n    The robot is programmed to make exactly k moves, choosing a random direction for each move.\n    If the robot moves off the grid at any point during its k moves, it is considered to have escaped.\n    \n    Calculate the probability that the robot will escape the grid after exactly k moves.\n    Return the result rounded to 6 decimal places.\n    \n\n    [EXAMPLES]\n    \n    assert candidate(7, 3, 6, 0) == 0.15625\n    assert candidate(2, 5, 1, 0) == 0.060547\n\n    [/EXAMPLES]\n    \"\"\"\n    def dfs(x: int, y: int, moves: int) -> int:\n        if x < 0 or x >= n or y < 0 or y >= n:\n            return 1\n        if moves == 0:\n            return 0\n        \n        total_escapes = 0\n        for dx, dy in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n            total_escapes += dfs(x + dx, y + dy, moves - 1)\n        \n        return total_escapes\n\n    total_possibilities = 4 ** k\n    escape_count = dfs(r, c, k)\n    probability = escape_count / total_possibilities\n    \n    return round(probability, 6)\n\n", "test": "def check(candidate):\n    assert candidate(8, 1, 7, 7) == 0.5\n    assert candidate(4, 3, 3, 3) == 0.15625\n    assert candidate(4, 4, 1, 1) == 0.179688\n    assert candidate(6, 6, 5, 5) == 0.040039\n    assert candidate(3, 10, 1, 1) == 0.026783\n    assert candidate(2, 5, 1, 0) == 0.060547\n    assert candidate(7, 3, 6, 0) == 0.15625\n    assert candidate(7, 2, 3, 3) == 0.0\n    assert candidate(3, 2, 0, 0) == 0.25\n    assert candidate(10, 10, 9, 9) == 0.014883\n", "language": "python"}
{"task_id": "44abf5be-9881-4d91-a301-cf30a9c58ef6-37652503694738642", "prompt": "Please implement the function as specified in the docstring. Ensure all code, including any additional functions or classes, is contained within a single code block. Do not define any external functions or classes outside the provided function.\n\n```python\nfrom typing import List\n\ndef calculate_revenue(prices: List[float], discounts: List[float]) -> float:\n    \"\"\"\n    A boutique wants to calculate its total revenue after applying discounts to its products.\n    This function takes two lists: one containing the original prices of items and another\n    containing the discount percentages for each item. It then calculates and returns the\n    total revenue after applying the discounts.\n\n    The function utilizes list comprehension and the built-in sum() function to perform\n    the calculation efficiently.\n\n\n    [EXAMPLES]\n    \n    assert candidate([1.99, 2.99, 3.99, 4.99], [1, 2, 3, 4]) == 13.561\n    assert candidate([100000], [99.9]) == 99.99999999998899\n\n    [/EXAMPLES]\n    \"\"\"\n```\n", "entry_point": "calculate_revenue", "solution": "from typing import List\n\ndef calculate_revenue(prices: List[float], discounts: List[float]) -> float:\n    \"\"\"\n    A boutique wants to calculate its total revenue after applying discounts to its products.\n    This function takes two lists: one containing the original prices of items and another\n    containing the discount percentages for each item. It then calculates and returns the\n    total revenue after applying the discounts.\n\n    The function utilizes list comprehension and the built-in sum() function to perform\n    the calculation efficiently.\n\n\n    [EXAMPLES]\n    \n    assert candidate([1.99, 2.99, 3.99, 4.99], [1, 2, 3, 4]) == 13.561\n    assert candidate([100000], [99.9]) == 99.99999999998899\n\n    [/EXAMPLES]\n    \"\"\"\n    # Calculate the discounted prices using list comprehension\n    discounted_prices = [price * (1 - discount / 100) for price, discount in zip(prices, discounts)]\n    \n    # Calculate the total revenue by summing up the discounted prices\n    total_revenue = sum(discounted_prices)\n    \n    return total_revenue\n\n", "test": "def check(candidate):\n    assert candidate([], []) == 0\n    assert candidate([0.01, 0.02, 0.03], [1, 2, 3]) == 0.0586\n    assert candidate([100000], [99.9]) == 99.99999999998899\n    assert candidate([10, 20, 30, 40, 50], [50, 40, 30, 20, 10]) == 115.0\n    assert candidate([100] * 100, [1] * 100) == 9900.0\n    assert candidate([1.99, 2.99, 3.99, 4.99], [1, 2, 3, 4]) == 13.561\n    assert candidate([50, 75, 100, 125], [5, 10, 15, 20]) == 300.0\n    assert candidate([0.1, 0.01, 0.001], [90, 99, 99.9]) == 0.010100999999999997\n    assert candidate([9.99] * 10, [5] * 10) == 94.90499999999999\n    assert candidate([1.23, 4.56, 7.89], [10, 20, 30]) == 10.277999999999999\n", "language": "python"}
{"task_id": "92c04938-650d-4982-af72-9d4216ef65de-1424465393022473249", "prompt": "Your objective is to finish the provided function in a way that allows it to be executed in one code segment. Refrain from adding code beyond the function's scope. Restrict yourself to using only the libraries mentioned in the problem description. If needed, define extra functions or classes solely within the main function. Present your answer as one unified code block.\n\n```python\ndef optimize_network_flow(graph: dict, source: str, sink: str) -> int:\n    \"\"\"\n    A city planner is designing a new water distribution system and needs to calculate the maximum\n    flow of water from a source reservoir to a destination area through a network of pipes.\n    This function takes a graph representing the pipe network (where keys are node names and values\n    are dictionaries of connected nodes and their capacities), a source node, and a sink node.\n    It returns the maximum flow possible in the network using concepts of graph traversal and network flow.\n\n\n    [EXAMPLES]\n    \n    assert candidate({'A': {'B': 5}, 'B': {'C': 5}, 'C': {}}, 'A', 'C') == 5\n    assert candidate({'1': {'2': 100, '3': 50}, '2': {'4': 80}, '3': {'4': 60}, '4': {'5': 150}}, '1', '5') == 130\n\n    [/EXAMPLES]\n    \"\"\"\n```\n", "entry_point": "optimize_network_flow", "solution": "def optimize_network_flow(graph: dict, source: str, sink: str) -> int:\n    \"\"\"\n    A city planner is designing a new water distribution system and needs to calculate the maximum\n    flow of water from a source reservoir to a destination area through a network of pipes.\n    This function takes a graph representing the pipe network (where keys are node names and values\n    are dictionaries of connected nodes and their capacities), a source node, and a sink node.\n    It returns the maximum flow possible in the network using concepts of graph traversal and network flow.\n\n\n    [EXAMPLES]\n    \n    assert candidate({'A': {'B': 5}, 'B': {'C': 5}, 'C': {}}, 'A', 'C') == 5\n    assert candidate({'1': {'2': 100, '3': 50}, '2': {'4': 80}, '3': {'4': 60}, '4': {'5': 150}}, '1', '5') == 130\n\n    [/EXAMPLES]\n    \"\"\"\n    def bfs(graph, source, sink, parent):\n        visited = set()\n        queue = [source]\n        visited.add(source)\n        \n        while queue:\n            u = queue.pop(0)\n            for v in graph[u]:\n                if v not in visited and graph[u][v] > 0:\n                    queue.append(v)\n                    visited.add(v)\n                    parent[v] = u\n                    if v == sink:\n                        return True\n        return False\n\n    def ford_fulkerson(graph, source, sink):\n        parent = {}\n        max_flow = 0\n\n        while bfs(graph, source, sink, parent):\n            path_flow = float('inf')\n            s = sink\n            while s != source:\n                path_flow = min(path_flow, graph[parent[s]][s])\n                s = parent[s]\n\n            max_flow += path_flow\n\n            v = sink\n            while v != source:\n                u = parent[v]\n                graph[u][v] -= path_flow\n                if v not in graph:\n                    graph[v] = {}\n                if u not in graph[v]:\n                    graph[v][u] = 0\n                graph[v][u] += path_flow\n                v = parent[v]\n\n        return max_flow\n\n    # Create a residual graph\n    residual_graph = {node: dict(connections) for node, connections in graph.items()}\n\n    # Calculate the maximum flow\n    max_flow = ford_fulkerson(residual_graph, source, sink)\n\n    return max_flow\n\n", "test": "def check(candidate):\n    assert candidate({'S': {'A': 10, 'B': 10}, 'A': {'C': 4, 'D': 8}, 'B': {'C': 2, 'D': 9}, 'C': {'T': 10}, 'D': {'T': 10}}, 'S', 'T') == 16\n    assert candidate({'M': {'N': 7, 'O': 3}, 'N': {'P': 5}, 'O': {'P': 5}, 'P': {'Q': 8, 'R': 4}, 'Q': {'S': 3}, 'R': {'S': 5}}, 'M', 'S') == 7\n    assert candidate({'S': {'A': 3, 'B': 2}, 'A': {'T': 3}, 'B': {'T': 5}, 'T': {}}, 'S', 'T') == 5\n    assert candidate({'1': {'2': 10}, '2': {'3': 5, '4': 5}, '3': {'5': 10}, '4': {'5': 10}, '5': {}}, '1', '5') == 10\n    assert candidate({'A': {'B': 5}, 'B': {'C': 5}, 'C': {}}, 'A', 'C') == 5\n    assert candidate({'X': {'A': 4, 'B': 3}, 'A': {'C': 3}, 'B': {'C': 5, 'D': 4}, 'C': {'E': 2, 'D': 1}, 'D': {'F': 2}, 'E': {'F': 3}, 'F': {'Y': 5}}, 'X', 'Y') == 4\n    assert candidate({'S': {'A': 5, 'B': 3}, 'A': {'C': 4}, 'B': {'C': 2}, 'C': {'D': 3, 'E': 1}, 'D': {'T': 2}, 'E': {'T': 3}}, 'S', 'T') == 3\n    assert candidate({'A': {'B': 7, 'C': 3}, 'B': {'C': 1, 'D': 6}, 'C': {'D': 5}, 'D': {'E': 8}}, 'A', 'E') == 8\n    assert candidate({'1': {'2': 100, '3': 50}, '2': {'4': 80}, '3': {'4': 60}, '4': {'5': 150}}, '1', '5') == 130\n    assert candidate({'A': {'B': 10, 'C': 10, 'D': 10}, 'B': {'E': 10}, 'C': {'E': 10}, 'D': {'E': 10}, 'E': {}}, 'A', 'E') == 30\n", "language": "python"}
{"task_id": "0d911252-b8d6-4026-b13e-381526fae8566921396457715911427", "prompt": "Using the doc string as a guide, implement the remainder of the function. Ensure the entire function is contained in a single code block. Do not alter the function name or its parameters.\n\n```python\nfrom typing import List, Tuple\nimport re\nfrom typing import List\n\ndef dna_pattern_search(dna_sequence: str, patterns: List[str]) -> List[Tuple[str, List[int]]]:\n    \"\"\"Search for specific DNA patterns in a given DNA sequence and return their positions.\n\n    Given a DNA sequence and a list of pattern strings, find all occurrences of each pattern\n    in the DNA sequence. The search should be case-insensitive and allow for overlapping matches.\n\n    Parameters:\n    dna_sequence (str): The DNA sequence to search in (containing A, T, C, G)\n    patterns (List[str]): List of DNA patterns to search for\n\n    Returns:\n    List[Tuple[str, List[int]]]: List of tuples containing the pattern and a list of its starting positions\n\n\n    [EXAMPLES]\n    \n    assert candidate(\"ATGCATGCATGC\", [\"ATG\", \"TGC\", \"GCA\"]) == [('ATG', [0, 4, 8]), ('TGC', [1, 5, 9]), ('GCA', [2, 6])]\n    assert candidate(\"ATGC\", []) == []\n\n    [/EXAMPLES]\n    \"\"\"\n```\n", "entry_point": "dna_pattern_search", "solution": "from typing import List, Tuple\nimport re\nfrom typing import List\n\ndef dna_pattern_search(dna_sequence: str, patterns: List[str]) -> List[Tuple[str, List[int]]]:\n    \"\"\"Search for specific DNA patterns in a given DNA sequence and return their positions.\n\n    Given a DNA sequence and a list of pattern strings, find all occurrences of each pattern\n    in the DNA sequence. The search should be case-insensitive and allow for overlapping matches.\n\n    Parameters:\n    dna_sequence (str): The DNA sequence to search in (containing A, T, C, G)\n    patterns (List[str]): List of DNA patterns to search for\n\n    Returns:\n    List[Tuple[str, List[int]]]: List of tuples containing the pattern and a list of its starting positions\n\n\n    [EXAMPLES]\n    \n    assert candidate(\"ATGCATGCATGC\", [\"ATG\", \"TGC\", \"GCA\"]) == [('ATG', [0, 4, 8]), ('TGC', [1, 5, 9]), ('GCA', [2, 6])]\n    assert candidate(\"ATGC\", []) == []\n\n    [/EXAMPLES]\n    \"\"\"\n    result = []\n    \n    for pattern in patterns:\n        positions = []\n        for match in re.finditer(f'(?={re.escape(pattern)})', dna_sequence, re.IGNORECASE):\n            positions.append(match.start())\n        result.append((pattern, positions))\n    \n    return result\n\n", "test": "def check(candidate):\n    assert candidate(\"ATGC\", []) == []\n    assert candidate(\"GCGCGCGCGC\", [\"GCG\", \"CGC\"]) == [('GCG', [0, 2, 4, 6]), ('CGC', [1, 3, 5, 7])]\n    assert candidate(\"ATGCATGCATGC\", [\"ATG\", \"TGC\", \"GCA\"]) == [('ATG', [0, 4, 8]), ('TGC', [1, 5, 9]), ('GCA', [2, 6])]\n    assert candidate(\"atgc\", [\"AT\", \"GC\"]) == [('AT', [0]), ('GC', [2])]\n    assert candidate(\"ATGCATGCATGC\", [\"ATG\", \"GC\", \"AT\"]) == [('ATG', [0, 4, 8]), ('GC', [2, 6, 10]), ('AT', [0, 4, 8])]\n    assert candidate(\"AGTCAGTCAGTC\", [\"AG\", \"TC\", \"CA\", \"GT\"]) == [('AG', [0, 4, 8]), ('TC', [2, 6, 10]), ('CA', [3, 7]), ('GT', [1, 5, 9])]\n    assert candidate(\"ATGC\", [\"ATGC\"]) == [('ATGC', [0])]\n    assert candidate(\"\", [\"A\", \"T\", \"G\", \"C\"]) == [('A', []), ('T', []), ('G', []), ('C', [])]\n    assert candidate(\"ATGC\", [\"X\"]) == [('X', [])]\n    assert candidate(\"AAAAAA\", [\"AA\"]) == [('AA', [0, 1, 2, 3, 4])]\n", "language": "python"}
{"task_id": "adc1b3e0-047d-4c86-91fc-f7b79c12aa30-7519722696870179757", "prompt": "Your assignment is to complete the given function so that it can run as a standalone unit. Exclude any code that falls outside the function's scope. Use exclusively the libraries that are imported in the problem setup. Should you need additional functions or classes, define them within the main function. Output your solution as one integrated code block.\n\n```python\ndef simulate_ecosystem(initial_population: dict, years: int, birth_rates: dict, predator_prey: dict) -> dict:\n    \"\"\"\n    An ecologist wants to simulate the population dynamics of an ecosystem over time. The simulation\n    takes into account birth rates and predator-prey relationships.\n\n    Parameters:\n    - initial_population: A dictionary with species names as keys and their initial populations as values.\n    - years: The number of years to simulate.\n    - birth_rates: A dictionary with species names as keys and their annual birth rates as values.\n    - predator_prey: A dictionary where keys are predator species and values are dictionaries mapping\n      prey species to the number of prey consumed per predator per year.\n\n    The function should return a dictionary with species names as keys and their final populations as values.\n    Round all final populations to the nearest integer.\n\n\n    [EXAMPLES]\n    \n    assert candidate({'mice': 100, 'owls': 100, 'seeds': 1000}, 3, {'mice': 1.5, 'owls': 0.9, 'seeds': 2.2}, {'mice': {'seeds': 20}, 'owls': {'mice': 15}}) == {'mice': 0, 'owls': 73, 'seeds': 968}\n    assert candidate({'ants': 1000000, 'anteaters': 50, 'leaves': 10000000}, 8, {'ants': 2.0, 'anteaters': 0.8, 'leaves': 1.5}, {'ants': {'leaves': 1}, 'anteaters': {'ants': 10000}}) == {'ants': 149403238, 'anteaters': 8, 'leaves': 0}\n\n    [/EXAMPLES]\n    \"\"\"\n```\n", "entry_point": "simulate_ecosystem", "solution": "def simulate_ecosystem(initial_population: dict, years: int, birth_rates: dict, predator_prey: dict) -> dict:\n    \"\"\"\n    An ecologist wants to simulate the population dynamics of an ecosystem over time. The simulation\n    takes into account birth rates and predator-prey relationships.\n\n    Parameters:\n    - initial_population: A dictionary with species names as keys and their initial populations as values.\n    - years: The number of years to simulate.\n    - birth_rates: A dictionary with species names as keys and their annual birth rates as values.\n    - predator_prey: A dictionary where keys are predator species and values are dictionaries mapping\n      prey species to the number of prey consumed per predator per year.\n\n    The function should return a dictionary with species names as keys and their final populations as values.\n    Round all final populations to the nearest integer.\n\n\n    [EXAMPLES]\n    \n    assert candidate({'mice': 100, 'owls': 100, 'seeds': 1000}, 3, {'mice': 1.5, 'owls': 0.9, 'seeds': 2.2}, {'mice': {'seeds': 20}, 'owls': {'mice': 15}}) == {'mice': 0, 'owls': 73, 'seeds': 968}\n    assert candidate({'ants': 1000000, 'anteaters': 50, 'leaves': 10000000}, 8, {'ants': 2.0, 'anteaters': 0.8, 'leaves': 1.5}, {'ants': {'leaves': 1}, 'anteaters': {'ants': 10000}}) == {'ants': 149403238, 'anteaters': 8, 'leaves': 0}\n\n    [/EXAMPLES]\n    \"\"\"\n    population = initial_population.copy()\n\n    for _ in range(years):\n        new_population = {}\n        \n        # Calculate prey consumption\n        prey_consumed = {species: 0 for species in population}\n        for predator, preys in predator_prey.items():\n            for prey, consumption_rate in preys.items():\n                prey_consumed[prey] += population[predator] * consumption_rate\n\n        # Update population for each species\n        for species in population:\n            # Growth\n            new_count = population[species] * birth_rates[species]\n            \n            # Subtract consumed individuals\n            new_count -= prey_consumed[species]\n            \n            # Ensure population doesn't go negative\n            new_population[species] = max(0, new_count)\n\n        population = new_population\n\n    # Round final populations to nearest integer\n    return {species: round(count) for species, count in population.items()}\n\n", "test": "def check(candidate):\n    assert candidate({'ants': 1000000, 'anteaters': 50, 'leaves': 10000000}, 8, {'ants': 2.0, 'anteaters': 0.8, 'leaves': 1.5}, {'ants': {'leaves': 1}, 'anteaters': {'ants': 10000}}) == {'ants': 149403238, 'anteaters': 8, 'leaves': 0}\n    assert candidate({'plankton': 5000000, 'small_fish': 50000, 'big_fish': 1000}, 5, {'plankton': 2.5, 'small_fish': 1.2, 'big_fish': 0.9}, {'small_fish': {'plankton': 50}, 'big_fish': {'small_fish': 20}}) == {'plankton': 347066000, 'small_fish': 0, 'big_fish': 590}\n    assert candidate({'deer': 1000, 'wolves': 0, 'grass': 50000}, 5, {'deer': 1.3, 'wolves': 0.8, 'grass': 1.5}, {'deer': {'grass': 100}, 'wolves': {'deer': 5}}) == {'deer': 3713, 'wolves': 0, 'grass': 0}\n    assert candidate({'mice': 100, 'owls': 100, 'seeds': 1000}, 3, {'mice': 1.5, 'owls': 0.9, 'seeds': 2.2}, {'mice': {'seeds': 20}, 'owls': {'mice': 15}}) == {'mice': 0, 'owls': 73, 'seeds': 968}\n    assert candidate({'fish': 100000, 'sharks': 1000, 'plankton': 10000000}, 1, {'fish': 1.1, 'sharks': 0.95, 'plankton': 2.5}, {'fish': {'plankton': 1000}, 'sharks': {'fish': 50}}) == {'fish': 60000, 'sharks': 950, 'plankton': 0}\n", "language": "python"}
{"task_id": "3ba8d5ad-6331-440f-8cba-4dc097384fd51227076871769318025", "prompt": "You are an AI coding assistant designed to help with programming tasks. Your primary function is to complete provided code snippets, specifically focusing on finishing given functions so they can be executed as-is within a code block. It's important that you confine your code to the function provided and avoid adding any code outside of it. You should only use libraries that are explicitly imported in the problem statement. If additional functions or classes are necessary, they should be defined within the main function you're completing.\n\n```python\nfrom typing import List\n\ndef longest_mountain_range(elevations: List[int]) -> int:\n    \"\"\"\n    In a geological survey of a mountainous region, we want to find the longest mountain range.\n    A mountain range is defined as a sequence of elevations where there is a strictly increasing\n    sequence followed by a strictly decreasing sequence. The peak of the mountain must be higher\n    than its base on both sides.\n\n    This function takes a list of elevations and returns the length of the longest mountain range.\n    If no mountain range exists, it returns 0.\n\n\n    [EXAMPLES]\n    \n    assert candidate([100, 101, 102, 101, 100, 99, 100, 101, 102, 103, 102, 101, 100]) == 8\n    assert candidate([1]) == 0\n\n    [/EXAMPLES]\n    \"\"\"\n```\n", "entry_point": "longest_mountain_range", "solution": "from typing import List\n\ndef longest_mountain_range(elevations: List[int]) -> int:\n    \"\"\"\n    In a geological survey of a mountainous region, we want to find the longest mountain range.\n    A mountain range is defined as a sequence of elevations where there is a strictly increasing\n    sequence followed by a strictly decreasing sequence. The peak of the mountain must be higher\n    than its base on both sides.\n\n    This function takes a list of elevations and returns the length of the longest mountain range.\n    If no mountain range exists, it returns 0.\n\n\n    [EXAMPLES]\n    \n    assert candidate([100, 101, 102, 101, 100, 99, 100, 101, 102, 103, 102, 101, 100]) == 8\n    assert candidate([1]) == 0\n\n    [/EXAMPLES]\n    \"\"\"\n    n = len(elevations)\n    longest_range = 0\n    i = 1\n\n    while i < n - 1:\n        # Check if current point is a peak\n        if elevations[i-1] < elevations[i] > elevations[i+1]:\n            # Find left boundary\n            left = i - 1\n            while left > 0 and elevations[left-1] < elevations[left]:\n                left -= 1\n\n            # Find right boundary\n            right = i + 1\n            while right < n - 1 and elevations[right] > elevations[right+1]:\n                right += 1\n\n            # Update longest range\n            longest_range = max(longest_range, right - left + 1)\n\n            # Move i to the right boundary\n            i = right\n        else:\n            i += 1\n\n    return longest_range\n\n", "test": "def check(candidate):\n    assert candidate([1, 2, 3, 4, 5, 5, 4, 3, 2, 1]) == 0\n    assert candidate([5, 4, 3, 2, 1]) == 0\n    assert candidate([1, 2]) == 0\n    assert candidate([100, 101, 102, 101, 100, 99, 100, 101, 102, 103, 102, 101, 100]) == 8\n    assert candidate([1, 3, 2, 4, 5, 3, 2, 1]) == 6\n    assert candidate([1]) == 0\n    assert candidate([1, 2, 3, 4, 5]) == 0\n    assert candidate([2, 1]) == 0\n    assert candidate([1, 2, 3, 3, 2, 1]) == 0\n    assert candidate([1, 1, 1, 1, 1]) == 0\n", "language": "python"}
{"task_id": "c44d4289-fc96-4403-b898-186706b2a46b4498609757326924554", "prompt": "Following the instructions in the docstring, complete the function's implementation. Retain the given function name and parameter list. Provide the full function, including both existing and new code, in a single block.\n\n```python\ndef calculate_water_storage(terrain: list) -> int:\n    \"\"\"\n    In a post-apocalyptic world, survivors need to calculate how much rainwater can be trapped between buildings of varying heights. Given a list of integers representing the height of each building, determine the total amount of water that can be stored after a rainstorm.\n\n    This function uses list manipulation and two-pointer technique concepts to solve the problem.\n\n\n    [EXAMPLES]\n    \n    assert candidate([]) == 0\n    assert candidate([3, 3, 3, 3]) == 0\n\n    [/EXAMPLES]\n    \"\"\"\n```\n", "entry_point": "calculate_water_storage", "solution": "def calculate_water_storage(terrain: list) -> int:\n    \"\"\"\n    In a post-apocalyptic world, survivors need to calculate how much rainwater can be trapped between buildings of varying heights. Given a list of integers representing the height of each building, determine the total amount of water that can be stored after a rainstorm.\n\n    This function uses list manipulation and two-pointer technique concepts to solve the problem.\n\n\n    [EXAMPLES]\n    \n    assert candidate([]) == 0\n    assert candidate([3, 3, 3, 3]) == 0\n\n    [/EXAMPLES]\n    \"\"\"\n    if not terrain or len(terrain) < 3:\n        return 0\n\n    left, right = 0, len(terrain) - 1\n    left_max, right_max = 0, 0\n    water = 0\n\n    while left < right:\n        if terrain[left] < terrain[right]:\n            if terrain[left] >= left_max:\n                left_max = terrain[left]\n            else:\n                water += left_max - terrain[left]\n            left += 1\n        else:\n            if terrain[right] >= right_max:\n                right_max = terrain[right]\n            else:\n                water += right_max - terrain[right]\n            right -= 1\n\n    return water\n\n", "test": "def check(candidate):\n    assert candidate([1, 2, 3, 2, 1]) == 0\n    assert candidate([]) == 0\n    assert candidate([3, 3, 3, 3]) == 0\n    assert candidate([7, 0, 1, 3, 4, 1, 2, 1, 5, 3, 2, 1]) == 23\n    assert candidate([1, 1, 1, 1]) == 0\n    assert candidate([5, 2, 1, 2, 1, 5]) == 14\n    assert candidate([4, 2, 0, 3, 2, 5]) == 9\n    assert candidate([0, 1, 0, 2, 1, 0, 1, 3, 2, 1, 2, 1]) == 6\n    assert candidate([0, 0, 0, 5, 0, 0, 0]) == 0\n    assert candidate([5, 0, 0, 0, 5]) == 15\n", "language": "python"}
{"task_id": "106fe049-7f0f-4212-b9e4-e509cea799ab8436764288880065463", "prompt": "You serve as a programming assistant. Your mission is to complete a designated function that can be run without modification in a code block. Avoid providing any code outside of the function's boundaries. Use only the libraries that are imported as part of the problem description. Should you need to create additional functions or classes, ensure they are defined exclusively within the given function.\n\n```python\nfrom typing import List, Dict\n\ndef recipe_scaling(ingredients: Dict[str, float], servings: int, target_servings: int) -> Dict[str, float]:\n    \"\"\"\n    A chef needs to scale a recipe for a different number of servings. This function takes the original recipe ingredients,\n    the number of servings it's designed for, and the target number of servings. It then returns the scaled ingredients.\n\n    Parameters:\n    ingredients (Dict[str, float]): A dictionary of ingredient names and their quantities in grams\n    servings (int): The number of servings the original recipe is designed for\n    target_servings (int): The desired number of servings\n\n    Returns:\n    Dict[str, float]: A dictionary of scaled ingredient quantities\n\n\n    [EXAMPLES]\n    \n    assert candidate({'shrimp': 200, 'pasta': 300, 'cream': 100, 'garlic': 10}, 2, 8) == {'shrimp': 800.0, 'pasta': 1200.0, 'cream': 400.0, 'garlic': 40.0}\n    assert candidate({'oats': 50, 'milk': 150, 'banana': 100}, 1, 5) == {'oats': 250.0, 'milk': 750.0, 'banana': 500.0}\n\n    [/EXAMPLES]\n    \"\"\"\n```\n", "entry_point": "recipe_scaling", "solution": "from typing import List, Dict\n\ndef recipe_scaling(ingredients: Dict[str, float], servings: int, target_servings: int) -> Dict[str, float]:\n    \"\"\"\n    A chef needs to scale a recipe for a different number of servings. This function takes the original recipe ingredients,\n    the number of servings it's designed for, and the target number of servings. It then returns the scaled ingredients.\n\n    Parameters:\n    ingredients (Dict[str, float]): A dictionary of ingredient names and their quantities in grams\n    servings (int): The number of servings the original recipe is designed for\n    target_servings (int): The desired number of servings\n\n    Returns:\n    Dict[str, float]: A dictionary of scaled ingredient quantities\n\n\n    [EXAMPLES]\n    \n    assert candidate({'shrimp': 200, 'pasta': 300, 'cream': 100, 'garlic': 10}, 2, 8) == {'shrimp': 800.0, 'pasta': 1200.0, 'cream': 400.0, 'garlic': 40.0}\n    assert candidate({'oats': 50, 'milk': 150, 'banana': 100}, 1, 5) == {'oats': 250.0, 'milk': 750.0, 'banana': 500.0}\n\n    [/EXAMPLES]\n    \"\"\"\n    scaling_factor = target_servings / servings\n    scaled_ingredients = {}\n\n    for ingredient, quantity in ingredients.items():\n        scaled_quantity = quantity * scaling_factor\n        scaled_ingredients[ingredient] = round(scaled_quantity, 1)\n\n    return scaled_ingredients\n\n", "test": "def check(candidate):\n    assert candidate({'flour': 200, 'sugar': 100, 'butter': 50}, 4, 8) == {'flour': 400.0, 'sugar': 200.0, 'butter': 100.0}\n    assert candidate({'quinoa': 100, 'black_beans': 150, 'corn': 100, 'avocado': 50}, 2, 5) == {'quinoa': 250.0, 'black_beans': 375.0, 'corn': 250.0, 'avocado': 125.0}\n    assert candidate({'beef': 400, 'broth': 500, 'vegetables': 200}, 6, 3) == {'beef': 200.0, 'broth': 250.0, 'vegetables': 100.0}\n    assert candidate({'oats': 50, 'milk': 150, 'banana': 100}, 1, 5) == {'oats': 250.0, 'milk': 750.0, 'banana': 500.0}\n    assert candidate({'ground_beef': 500, 'onion': 100, 'breadcrumbs': 50, 'egg': 60}, 4, 6) == {'ground_beef': 750.0, 'onion': 150.0, 'breadcrumbs': 75.0, 'egg': 90.0}\n    assert candidate({'pasta': 300, 'tomato_sauce': 200, 'cheese': 100}, 3, 6) == {'pasta': 600.0, 'tomato_sauce': 400.0, 'cheese': 200.0}\n    assert candidate({'chicken_breast': 200, 'spinach': 50, 'feta': 30}, 1, 4) == {'chicken_breast': 800.0, 'spinach': 200.0, 'feta': 120.0}\n    assert candidate({'apple': 200, 'cinnamon': 5, 'sugar': 50}, 4, 1) == {'apple': 50.0, 'cinnamon': 1.2, 'sugar': 12.5}\n    assert candidate({'shrimp': 200, 'pasta': 300, 'cream': 100, 'garlic': 10}, 2, 8) == {'shrimp': 800.0, 'pasta': 1200.0, 'cream': 400.0, 'garlic': 40.0}\n    assert candidate({'chicken': 500, 'onion': 100, 'garlic': 20}, 2, 4) == {'chicken': 1000.0, 'onion': 200.0, 'garlic': 40.0}\n", "language": "python"}
{"task_id": "a352ba5a-80fb-4027-9baf-47e7c5b2d62d-8093149628026337161", "prompt": "Kindly fill in the missing parts of this code and present it as a complete block.\n\n```python\nfrom typing import List, Tuple\nfrom typing import List\n\ndef analyze_dna_mutations(original_sequence: str, mutated_sequences: List[str]) -> List[Tuple[str, float]]:\n    \"\"\"\n    Analyzes mutations in DNA sequences and calculates their impact scores.\n\n    This function compares a list of mutated DNA sequences to an original sequence,\n    identifies the mutations, and calculates an impact score for each mutated sequence.\n    The impact score is based on the number and type of mutations present.\n\n    Args:\n    original_sequence (str): The original DNA sequence as a string of nucleotides (A, C, G, T).\n    mutated_sequences (List[str]): A list of mutated DNA sequences to be analyzed.\n\n    Returns:\n    List[Tuple[str, float]]: A list of tuples, each containing a mutated sequence and its impact score.\n\n\n    [EXAMPLES]\n    \n    assert candidate(\"ACGTACGTACGT\", [\"ACGTACGTACGT\", \"ACGTACGTACGA\", \"ACGTACGTACGC\"]) == [('ACGTACGTACGT', 0.0), ('ACGTACGTACGA', 0.0833), ('ACGTACGTACGC', 0.0833)]\n    assert candidate(\"A\" * 100, [\"A\" * 99 + \"T\", \"A\" * 100, \"T\" + \"A\" * 99]) == [('AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAT', 0.01), ('AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA', 0.0), ('TAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA', 0.01)]\n\n    [/EXAMPLES]\n    \"\"\"\n```\n", "entry_point": "analyze_dna_mutations", "solution": "from typing import List, Tuple\nfrom typing import List\n\ndef analyze_dna_mutations(original_sequence: str, mutated_sequences: List[str]) -> List[Tuple[str, float]]:\n    \"\"\"\n    Analyzes mutations in DNA sequences and calculates their impact scores.\n\n    This function compares a list of mutated DNA sequences to an original sequence,\n    identifies the mutations, and calculates an impact score for each mutated sequence.\n    The impact score is based on the number and type of mutations present.\n\n    Args:\n    original_sequence (str): The original DNA sequence as a string of nucleotides (A, C, G, T).\n    mutated_sequences (List[str]): A list of mutated DNA sequences to be analyzed.\n\n    Returns:\n    List[Tuple[str, float]]: A list of tuples, each containing a mutated sequence and its impact score.\n\n\n    [EXAMPLES]\n    \n    assert candidate(\"ACGTACGTACGT\", [\"ACGTACGTACGT\", \"ACGTACGTACGA\", \"ACGTACGTACGC\"]) == [('ACGTACGTACGT', 0.0), ('ACGTACGTACGA', 0.0833), ('ACGTACGTACGC', 0.0833)]\n    assert candidate(\"A\" * 100, [\"A\" * 99 + \"T\", \"A\" * 100, \"T\" + \"A\" * 99]) == [('AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAT', 0.01), ('AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA', 0.0), ('TAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA', 0.01)]\n\n    [/EXAMPLES]\n    \"\"\"\n    def calculate_impact_score(original: str, mutated: str) -> float:\n        if len(original) != len(mutated):\n            raise ValueError(\"Sequences must be of equal length\")\n        \n        mutations = sum(1 for o, m in zip(original, mutated) if o != m)\n        return round(mutations / len(original), 4)\n\n    result = []\n    for sequence in mutated_sequences:\n        impact_score = calculate_impact_score(original_sequence, sequence)\n        result.append((sequence, impact_score))\n    \n    return result\n\n", "test": "def check(candidate):\n    assert candidate(\"A\" * 100, [\"A\" * 99 + \"T\", \"A\" * 100, \"T\" + \"A\" * 99]) == [('AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAT', 0.01), ('AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA', 0.0), ('TAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA', 0.01)]\n    assert candidate(\"ATCG\", [\"ATCG\", \"ATCG\", \"ATCG\"]) == [('ATCG', 0.0), ('ATCG', 0.0), ('ATCG', 0.0)]\n    assert candidate(\"TTTTTAAAAA\", [\"TTTTTAAAAA\", \"TTTTTAAAAT\", \"TTTTTAAATA\"]) == [('TTTTTAAAAA', 0.0), ('TTTTTAAAAT', 0.1), ('TTTTTAAATA', 0.1)]\n    assert candidate(\"ACGTACGTACGT\", [\"ACGTACGTACGT\", \"ACGTACGTACGA\", \"ACGTACGTACGC\"]) == [('ACGTACGTACGT', 0.0), ('ACGTACGTACGA', 0.0833), ('ACGTACGTACGC', 0.0833)]\n    assert candidate(\"ATATATATATAT\", [\"ATATATATATAT\", \"CGCGCGCGCGCG\"]) == [('ATATATATATAT', 0.0), ('CGCGCGCGCGCG', 1.0)]\n    assert candidate(\"AAAAAA\", [\"AAAAAA\", \"CCCCCC\", \"GGGGGG\", \"TTTTTT\", \"AAAAAA\"]) == [('AAAAAA', 0.0), ('CCCCCC', 1.0), ('GGGGGG', 1.0), ('TTTTTT', 1.0), ('AAAAAA', 0.0)]\n    assert candidate(\"ACGT\", [\"ACGT\", \"ACGT\", \"ACGT\", \"ACGA\"]) == [('ACGT', 0.0), ('ACGT', 0.0), ('ACGT', 0.0), ('ACGA', 0.25)]\n    assert candidate(\"A\", [\"A\", \"C\", \"G\", \"T\"]) == [('A', 0.0), ('C', 1.0), ('G', 1.0), ('T', 1.0)]\n    assert candidate(\"AAATTTCCCGGG\", [\"AAATTTCCCGGA\", \"AAATTTCCCGGG\", \"AAATTTCCCAGG\"]) == [('AAATTTCCCGGA', 0.0833), ('AAATTTCCCGGG', 0.0), ('AAATTTCCCAGG', 0.0833)]\n    assert candidate(\"ATCGATCGATCG\", [\"ATCGATCGATCG\", \"ATCGATCGATCA\", \"ATCGATCGATCT\"]) == [('ATCGATCGATCG', 0.0), ('ATCGATCGATCA', 0.0833), ('ATCGATCGATCT', 0.0833)]\n", "language": "python"}
{"task_id": "cc7a6b52-055a-4555-a081-ff1fe41632659222905699995654284", "prompt": "Adhere to the guidelines outlined in the doc string to finalize the function within a code block. Any supplementary functions or classes should be established solely within the given function's scope.\n\n```python\nimport re\nfrom typing import List\n\ndef analyze_text_sentiment(text: str, positive_words: List[str], negative_words: List[str]) -> float:\n    \"\"\"\n    Analyzes the sentiment of a given text based on the presence of positive and negative words.\n\n    This function uses regular expressions to tokenize the input text and compares each word\n    against lists of positive and negative words. It then calculates a sentiment score\n    based on the relative frequency of positive and negative words.\n\n    Args:\n    text (str): The input text to analyze.\n    positive_words (List[str]): A list of words considered positive.\n    negative_words (List[str]): A list of words considered negative.\n\n    Returns:\n    float: A sentiment score between -1 and 1, where -1 is very negative, 0 is neutral, and 1 is very positive.\n\n\n    [EXAMPLES]\n    \n    assert candidate(\"Not bad, not good, just okay.\", [\"good\"], [\"bad\"]) == 0.0\n    assert candidate(\"Mixed feelings: happy but also sad.\", [\"happy\"], [\"sad\"]) == 0.0\n\n    [/EXAMPLES]\n    \"\"\"\n```\n", "entry_point": "analyze_text_sentiment", "solution": "import re\nfrom typing import List\n\ndef analyze_text_sentiment(text: str, positive_words: List[str], negative_words: List[str]) -> float:\n    \"\"\"\n    Analyzes the sentiment of a given text based on the presence of positive and negative words.\n\n    This function uses regular expressions to tokenize the input text and compares each word\n    against lists of positive and negative words. It then calculates a sentiment score\n    based on the relative frequency of positive and negative words.\n\n    Args:\n    text (str): The input text to analyze.\n    positive_words (List[str]): A list of words considered positive.\n    negative_words (List[str]): A list of words considered negative.\n\n    Returns:\n    float: A sentiment score between -1 and 1, where -1 is very negative, 0 is neutral, and 1 is very positive.\n\n\n    [EXAMPLES]\n    \n    assert candidate(\"Not bad, not good, just okay.\", [\"good\"], [\"bad\"]) == 0.0\n    assert candidate(\"Mixed feelings: happy but also sad.\", [\"happy\"], [\"sad\"]) == 0.0\n\n    [/EXAMPLES]\n    \"\"\"\n    # Tokenize the text into words\n    words = re.findall(r'\\b\\w+\\b', text.lower())\n    \n    # Count positive and negative words\n    positive_count = sum(1 for word in words if word in positive_words)\n    negative_count = sum(1 for word in words if word in negative_words)\n    \n    # Calculate total sentiment words\n    total_sentiment_words = positive_count + negative_count\n    \n    # If no sentiment words are found, return 0 (neutral)\n    if total_sentiment_words == 0:\n        return 0.0\n    \n    # Calculate sentiment score\n    sentiment_score = (positive_count - negative_count) / total_sentiment_words\n    \n    return sentiment_score\n\n", "test": "def check(candidate):\n    assert candidate(\"Not bad, not good, just okay.\", [\"good\"], [\"bad\"]) == 0.0\n    assert candidate(\"I love this product! It's amazing and works great.\", [\"love\", \"amazing\", \"great\"], [\"bad\", \"terrible\", \"awful\"]) == 1.0\n    assert candidate(\"Mixed feelings: happy but also sad.\", [\"happy\"], [\"sad\"]) == 0.0\n    assert candidate(\"Worst day ever...\", [], [\"worst\"]) == -1.0\n    assert candidate(\"The movie was a rollercoaster of emotions.\", [\"emotions\"], []) == 1.0\n    assert candidate(\"Neutral text without any sentiment.\", [\"positive\"], [\"negative\"]) == 0.0\n    assert candidate(\"Absolutely fantastic experience!\", [\"fantastic\"], []) == 1.0\n    assert candidate(\"\", [], []) == 0.0\n    assert candidate(\"Excellent! Perfect! Wonderful!\", [\"excellent\", \"perfect\", \"wonderful\"], [\"bad\"]) == 1.0\n    assert candidate(\"hate hate hate\", [], [\"hate\"]) == -1.0\n", "language": "python"}
{"task_id": "b2aabdaa-abc5-4e5b-b146-353b51bca8a8801638761543324764", "prompt": "You're acting as a coding assistant. Your job is to finalize a pre-existing function that's ready for execution in a code block. Don't include any code beyond the function's scope. Stick to using only the libraries mentioned in the problem. If you need to create extra functions or classes, make sure they're nested within the main function.\n\n```python\nfrom collections import deque\nfrom typing import List\n\ndef reconstruct_binary_tree(inorder: List[int], postorder: List[int]) -> List[List[int]]:\n    \"\"\"You are given the inorder and postorder traversals of a binary tree. Your task is to reconstruct the binary tree\n    and return its level order traversal.\n\n    In a binary tree:\n    - Inorder traversal is [left subtree, root, right subtree]\n    - Postorder traversal is [left subtree, right subtree, root]\n    - Level order traversal visits nodes level by level from top to bottom, left to right\n\n    Args:\n    inorder (List[int]): The inorder traversal of the binary tree.\n    postorder (List[int]): The postorder traversal of the binary tree.\n\n    Returns:\n    List[List[int]]: The level order traversal of the reconstructed binary tree.\n\n\n    [EXAMPLES]\n    \n    assert candidate([1, 2, 3, 4], [1, 4, 3, 2]) == [[2], [1, 3], [4]]\n    assert candidate([1, 2, 3], [2, 3, 1]) == [[1], [3], [2]]\n\n    [/EXAMPLES]\n    \"\"\"\n```\n", "entry_point": "reconstruct_binary_tree", "solution": "from collections import deque\nfrom typing import List\n\ndef reconstruct_binary_tree(inorder: List[int], postorder: List[int]) -> List[List[int]]:\n    \"\"\"You are given the inorder and postorder traversals of a binary tree. Your task is to reconstruct the binary tree\n    and return its level order traversal.\n\n    In a binary tree:\n    - Inorder traversal is [left subtree, root, right subtree]\n    - Postorder traversal is [left subtree, right subtree, root]\n    - Level order traversal visits nodes level by level from top to bottom, left to right\n\n    Args:\n    inorder (List[int]): The inorder traversal of the binary tree.\n    postorder (List[int]): The postorder traversal of the binary tree.\n\n    Returns:\n    List[List[int]]: The level order traversal of the reconstructed binary tree.\n\n\n    [EXAMPLES]\n    \n    assert candidate([1, 2, 3, 4], [1, 4, 3, 2]) == [[2], [1, 3], [4]]\n    assert candidate([1, 2, 3], [2, 3, 1]) == [[1], [3], [2]]\n\n    [/EXAMPLES]\n    \"\"\"\n    def build_tree(in_start, in_end, post_start, post_end):\n        if in_start > in_end:\n            return None\n\n        root_val = postorder[post_end]\n        root = TreeNode(root_val)\n\n        root_index = inorder_map[root_val]\n        left_subtree_size = root_index - in_start\n\n        root.left = build_tree(in_start, root_index - 1, post_start, post_start + left_subtree_size - 1)\n        root.right = build_tree(root_index + 1, in_end, post_start + left_subtree_size, post_end - 1)\n\n        return root\n\n    def level_order_traversal(root):\n        if not root:\n            return []\n\n        result = []\n        queue = deque([root])\n\n        while queue:\n            level_size = len(queue)\n            level = []\n\n            for _ in range(level_size):\n                node = queue.popleft()\n                level.append(node.val)\n\n                if node.left:\n                    queue.append(node.left)\n                if node.right:\n                    queue.append(node.right)\n\n            result.append(level)\n\n        return result\n\n    class TreeNode:\n        def __init__(self, val=0, left=None, right=None):\n            self.val = val\n            self.left = left\n            self.right = right\n\n    if not inorder or not postorder or len(inorder) != len(postorder):\n        return []\n\n    inorder_map = {val: idx for idx, val in enumerate(inorder)}\n    root = build_tree(0, len(inorder) - 1, 0, len(postorder) - 1)\n    return level_order_traversal(root)\n\n", "test": "def check(candidate):\n    assert candidate([1, 2, 3, 4, 5, 6], [1, 3, 5, 6, 4, 2]) == [[2], [1, 4], [3, 6], [5]]\n    assert candidate([4, 2, 5, 1, 3], [4, 5, 2, 3, 1]) == [[1], [2, 3], [4, 5]]\n    assert candidate([1, 3, 2], [3, 2, 1]) == [[1], [2], [3]]\n    assert candidate([1, 2, 3, 4, 5, 6, 7, 8, 9, 10], [1, 3, 5, 7, 9, 10, 8, 6, 4, 2]) == [[2], [1, 4], [3, 6], [5, 8], [7, 10], [9]]\n    assert candidate([1, 2, 3], [1, 3, 2]) == [[2], [1, 3]]\n    assert candidate([1, 2, 3], [2, 3, 1]) == [[1], [3], [2]]\n    assert candidate([1, 2, 3, 4], [1, 4, 3, 2]) == [[2], [1, 3], [4]]\n    assert candidate([1, 2], [1, 2]) == [[2], [1]]\n    assert candidate([4, 2, 5, 1, 6, 3, 7], [4, 5, 2, 6, 7, 3, 1]) == [[1], [2, 3], [4, 5, 6, 7]]\n    assert candidate([2, 1, 3, 4], [2, 4, 3, 1]) == [[1], [2, 3], [4]]\n", "language": "python"}
{"task_id": "16706cb7-e992-4d78-9f56-a0b00c7831bf7785205132927450407", "prompt": "Could you please finalize the function according to the given doc string? Ensure that the function is written as a single, cohesive code block, and remember to consider and manage potential edge cases.\n\n```python\nfrom typing import List\n\ndef calculate_max_profit(prices: List[int], k: int) -> int:\n    \"\"\"\n    A stock trader wants to maximize their profit by buying and selling stocks.\n    Given a list of stock prices for consecutive days and a maximum number of\n    transactions allowed (k), this function calculates the maximum profit that\n    can be achieved.\n\n    The trader can buy and sell multiple times, but can only hold one stock at a time.\n\n\n    [EXAMPLES]\n    \n    assert candidate([100, 1, 100, 1, 100], 3) == 198\n    assert candidate([1, 2, 3, 4, 5], 1) == 4\n\n    [/EXAMPLES]\n    \"\"\"\n```\n", "entry_point": "calculate_max_profit", "solution": "from typing import List\n\ndef calculate_max_profit(prices: List[int], k: int) -> int:\n    \"\"\"\n    A stock trader wants to maximize their profit by buying and selling stocks.\n    Given a list of stock prices for consecutive days and a maximum number of\n    transactions allowed (k), this function calculates the maximum profit that\n    can be achieved.\n\n    The trader can buy and sell multiple times, but can only hold one stock at a time.\n\n\n    [EXAMPLES]\n    \n    assert candidate([100, 1, 100, 1, 100], 3) == 198\n    assert candidate([1, 2, 3, 4, 5], 1) == 4\n\n    [/EXAMPLES]\n    \"\"\"\n    if not prices or k == 0:\n        return 0\n\n    n = len(prices)\n    \n    # If k is large enough, we can make as many transactions as we want\n    if k >= n // 2:\n        return sum(max(prices[i] - prices[i-1], 0) for i in range(1, n))\n\n    # Initialize dp table\n    # dp[i][j][0] represents the max profit on day i with j transactions, not holding a stock\n    # dp[i][j][1] represents the max profit on day i with j transactions, holding a stock\n    dp = [[[0, 0] for _ in range(k + 1)] for _ in range(n)]\n\n    for i in range(n):\n        for j in range(1, k + 1):\n            if i == 0:\n                # On the first day, we can only buy\n                dp[i][j][1] = -prices[i]\n            else:\n                # Not holding a stock: either do nothing or sell\n                dp[i][j][0] = max(dp[i-1][j][0], dp[i-1][j][1] + prices[i])\n                \n                # Holding a stock: either do nothing or buy\n                dp[i][j][1] = max(dp[i-1][j][1], dp[i-1][j-1][0] - prices[i])\n\n    # The maximum profit is achieved on the last day, after k transactions, not holding a stock\n    return dp[n-1][k][0]\n\n", "test": "def check(candidate):\n    assert candidate([100, 1, 100, 1, 100], 3) == 198\n    assert candidate([1, 2], 1) == 1\n    assert candidate([1, 2, 3, 4, 5], 1) == 4\n    assert candidate([1], 1) == 0\n    assert candidate([5, 0, 0, 0, 0], 1) == 0\n    assert candidate([1, 4, 2, 7, 3, 9], 3) == 14\n    assert candidate([1, 2, 1, 2, 1], 3) == 2\n    assert candidate([3, 2, 6, 5, 0, 3, 1, 4], 3) == 10\n    assert candidate([0, 0, 0, 0, 5], 1) == 5\n    assert candidate([1, 1, 1, 1], 4) == 0\n", "language": "python"}
{"task_id": "56f1ad91-c5d2-4a35-9646-361b12f6106e-3522430745504106831", "prompt": "Using the doc string as a guide, please fill in the remaining code for the function. Enclose the entire function within a single code block. Remember to handle any edge cases that may arise in your implementation.\n\n```python\nimport math\nfrom typing import List, Tuple\n\ndef decode_alien_message(signal: List[int], codebook: List[Tuple[int, str]]) -> str:\n    \"\"\"\n    Decode an alien message using a given codebook and signal processing rules.\n    \n    The alien signal is a list of integers, and the codebook is a list of tuples (frequency, character).\n    To decode the message:\n    1. Group the signal into subsequences where the absolute difference between adjacent numbers is <= 5.\n    2. For each subsequence, calculate the average frequency (rounded down to nearest integer).\n    3. Look up the character corresponding to this frequency in the codebook.\n    4. If a frequency is not in the codebook, use '?' for that part of the message.\n    5. Concatenate the decoded characters to form the final message.\n    \n\n    [EXAMPLES]\n    \n    assert candidate([100, 200, 300], [(100, 'X'), (200, 'Y'), (300, 'Z')]) == 'XYZ'\n    assert candidate([1, 10, 100, 1000], [(1, 'A'), (10, 'B'), (100, 'C'), (1000, 'D')]) == 'ABCD'\n\n    [/EXAMPLES]\n    \"\"\"\n```\n", "entry_point": "decode_alien_message", "solution": "import math\nfrom typing import List, Tuple\n\ndef decode_alien_message(signal: List[int], codebook: List[Tuple[int, str]]) -> str:\n    \"\"\"\n    Decode an alien message using a given codebook and signal processing rules.\n    \n    The alien signal is a list of integers, and the codebook is a list of tuples (frequency, character).\n    To decode the message:\n    1. Group the signal into subsequences where the absolute difference between adjacent numbers is <= 5.\n    2. For each subsequence, calculate the average frequency (rounded down to nearest integer).\n    3. Look up the character corresponding to this frequency in the codebook.\n    4. If a frequency is not in the codebook, use '?' for that part of the message.\n    5. Concatenate the decoded characters to form the final message.\n    \n\n    [EXAMPLES]\n    \n    assert candidate([100, 200, 300], [(100, 'X'), (200, 'Y'), (300, 'Z')]) == 'XYZ'\n    assert candidate([1, 10, 100, 1000], [(1, 'A'), (10, 'B'), (100, 'C'), (1000, 'D')]) == 'ABCD'\n\n    [/EXAMPLES]\n    \"\"\"\n    def group_subsequences(signal):\n        subsequences = []\n        current_subsequence = [signal[0]]\n        \n        for i in range(1, len(signal)):\n            if abs(signal[i] - signal[i-1]) <= 5:\n                current_subsequence.append(signal[i])\n            else:\n                subsequences.append(current_subsequence)\n                current_subsequence = [signal[i]]\n        \n        subsequences.append(current_subsequence)\n        return subsequences\n\n    def average_frequency(subsequence):\n        return math.floor(sum(subsequence) / len(subsequence))\n\n    def lookup_character(frequency, codebook):\n        for code_freq, char in codebook:\n            if code_freq == frequency:\n                return char\n        return '?'\n\n    # Group the signal into subsequences\n    subsequences = group_subsequences(signal)\n\n    # Process each subsequence and build the message\n    message = \"\"\n    for subsequence in subsequences:\n        avg_freq = average_frequency(subsequence)\n        char = lookup_character(avg_freq, codebook)\n        message += char\n\n    return message\n\n", "test": "def check(candidate):\n    assert candidate([1, 2, 10, 11, 20, 21], [(1, 'A'), (11, 'B'), (21, 'C')]) == 'A??'\n    assert candidate([1, 6, 11, 16, 21], [(1, 'A'), (6, 'B'), (11, 'C'), (16, 'D'), (21, 'E')]) == 'C'\n    assert candidate([1, 1, 1, 1, 1], [(1, 'X')]) == 'X'\n    assert candidate([100], [(100, 'X')]) == 'X'\n    assert candidate([1, 10, 100, 1000], [(1, 'A'), (10, 'B'), (100, 'C'), (1000, 'D')]) == 'ABCD'\n    assert candidate([1, 2, 10, 11, 20, 21], [(1, 'X'), (10, 'Y'), (20, 'Z')]) == 'XYZ'\n    assert candidate([1, 2, 3, 10, 20, 30], [(2, 'A'), (20, 'B')]) == 'A?B?'\n    assert candidate([5, 10, 15, 20, 25], [(7, 'A'), (12, 'B'), (17, 'C'), (22, 'D')]) == '?'\n    assert candidate([1, 2, 3, 10, 11, 12], [(2, 'X'), (11, 'Y')]) == 'XY'\n    assert candidate([100, 200, 300], [(100, 'X'), (200, 'Y'), (300, 'Z')]) == 'XYZ'\n", "language": "python"}
{"task_id": "ec2847d3-617d-4ce5-9ab4-ff74d8be41b3146016226331305729", "prompt": "Develop the function as outlined in the doc string, encapsulating all code within one block. Refrain from defining separate functions or classes outside the main function's scope.\n\n```python\nfrom typing import List\n\ndef stock_profit_calculator(prices: List[int]) -> int:\n    \"\"\"\n    As a financial analyst, you need to determine the maximum profit that can be made\n    by buying and selling a stock once, given a list of stock prices over time.\n    This function takes a list of integers representing daily stock prices and returns\n    the maximum profit that can be achieved.\n    If no profit can be made, return 0.\n\n\n    [EXAMPLES]\n    \n    assert candidate([10000, 1000, 100, 10, 1]) == 0\n    assert candidate([1, 10, 100, 1000, 10000]) == 9999\n\n    [/EXAMPLES]\n    \"\"\"\n```\n", "entry_point": "stock_profit_calculator", "solution": "from typing import List\n\ndef stock_profit_calculator(prices: List[int]) -> int:\n    \"\"\"\n    As a financial analyst, you need to determine the maximum profit that can be made\n    by buying and selling a stock once, given a list of stock prices over time.\n    This function takes a list of integers representing daily stock prices and returns\n    the maximum profit that can be achieved.\n    If no profit can be made, return 0.\n\n\n    [EXAMPLES]\n    \n    assert candidate([10000, 1000, 100, 10, 1]) == 0\n    assert candidate([1, 10, 100, 1000, 10000]) == 9999\n\n    [/EXAMPLES]\n    \"\"\"\n    if not prices or len(prices) < 2:\n        return 0\n\n    min_price = float('inf')\n    max_profit = 0\n\n    for price in prices:\n        if price < min_price:\n            min_price = price\n        else:\n            current_profit = price - min_price\n            max_profit = max(max_profit, current_profit)\n\n    return max_profit\n\n", "test": "def check(candidate):\n    assert candidate([1, 2]) == 1\n    assert candidate([10000, 1000, 100, 10, 1]) == 0\n    assert candidate([1, 10, 100, 1000, 10000]) == 9999\n    assert candidate([1000000, 1, 999999, 2, 999998]) == 999998\n", "language": "python"}
{"task_id": "ad19aa57-4044-493f-bb58-746ac5e9fab85605248660288108825", "prompt": "In your role as a coding helper, you're tasked with completing a predefined function that can be executed directly in a code block. Don't include any code beyond the function's boundaries. Stick to using only the libraries that are mentioned as imports in the problem statement. If you need to create extra functions or classes, make sure to define them inside the main function provided.\n\n```python\nimport math\nfrom typing import List, Tuple\n\ndef design_circular_fortress(n: int, m: int) -> List[Tuple[int, int]]:\n    \"\"\"\n    In an ancient kingdom, the royal architect is tasked with designing a circular fortress with n towers.\n    The fortress must have m secret passages connecting pairs of towers. The function should return the\n    coordinates of the towers on a 2D plane to optimize the fortress's defensive capabilities.\n\n    Parameters:\n    n (int): The number of towers in the fortress\n    m (int): The number of secret passages to be built\n\n    Returns:\n    List[Tuple[int, int]]: A list of (x, y) coordinates for each tower\n\n\n    [EXAMPLES]\n    \n    assert candidate(25, 20) == [(100, 0), (97, 25), (88, 48), (73, 68), (54, 84), (31, 95), (6, 100), (-19, 98), (-43, 90), (-64, 77), (-81, 59), (-93, 37), (-99, 13), (-99, -13), (-93, -37), (-81, -59), (-64, -77), (-43, -90), (-19, -98), (6, -100), (31, -95), (54, -84), (73, -68), (88, -48), (97, -25)]\n    assert candidate(16, 14) == [(100, 0), (92, 38), (71, 71), (38, 92), (0, 100), (-38, 92), (-71, 71), (-92, 38), (-100, 0), (-92, -38), (-71, -71), (-38, -92), (0, -100), (38, -92), (71, -71), (92, -38)]\n\n    [/EXAMPLES]\n    \"\"\"\n```\n", "entry_point": "design_circular_fortress", "solution": "import math\nfrom typing import List, Tuple\n\ndef design_circular_fortress(n: int, m: int) -> List[Tuple[int, int]]:\n    \"\"\"\n    In an ancient kingdom, the royal architect is tasked with designing a circular fortress with n towers.\n    The fortress must have m secret passages connecting pairs of towers. The function should return the\n    coordinates of the towers on a 2D plane to optimize the fortress's defensive capabilities.\n\n    Parameters:\n    n (int): The number of towers in the fortress\n    m (int): The number of secret passages to be built\n\n    Returns:\n    List[Tuple[int, int]]: A list of (x, y) coordinates for each tower\n\n\n    [EXAMPLES]\n    \n    assert candidate(25, 20) == [(100, 0), (97, 25), (88, 48), (73, 68), (54, 84), (31, 95), (6, 100), (-19, 98), (-43, 90), (-64, 77), (-81, 59), (-93, 37), (-99, 13), (-99, -13), (-93, -37), (-81, -59), (-64, -77), (-43, -90), (-19, -98), (6, -100), (31, -95), (54, -84), (73, -68), (88, -48), (97, -25)]\n    assert candidate(16, 14) == [(100, 0), (92, 38), (71, 71), (38, 92), (0, 100), (-38, 92), (-71, 71), (-92, 38), (-100, 0), (-92, -38), (-71, -71), (-38, -92), (0, -100), (38, -92), (71, -71), (92, -38)]\n\n    [/EXAMPLES]\n    \"\"\"\n    def calculate_coordinates(radius: int, angle: float) -> Tuple[int, int]:\n        x = int(round(radius * math.cos(angle)))\n        y = int(round(radius * math.sin(angle)))\n        return (x, y)\n\n    radius = 100  # Arbitrary radius for the circular fortress\n    coordinates = []\n\n    for i in range(n):\n        angle = 2 * math.pi * i / n\n        coordinates.append(calculate_coordinates(radius, angle))\n\n    return coordinates\n\n", "test": "def check(candidate):\n    assert candidate(7, 5) == [(100, 0), (62, 78), (-22, 97), (-90, 43), (-90, -43), (-22, -97), (62, -78)]\n    assert candidate(20, 15) == [(100, 0), (95, 31), (81, 59), (59, 81), (31, 95), (0, 100), (-31, 95), (-59, 81), (-81, 59), (-95, 31), (-100, 0), (-95, -31), (-81, -59), (-59, -81), (-31, -95), (0, -100), (31, -95), (59, -81), (81, -59), (95, -31)]\n    assert candidate(12, 10) == [(100, 0), (87, 50), (50, 87), (0, 100), (-50, 87), (-87, 50), (-100, 0), (-87, -50), (-50, -87), (0, -100), (50, -87), (87, -50)]\n    assert candidate(10, 8) == [(100, 0), (81, 59), (31, 95), (-31, 95), (-81, 59), (-100, 0), (-81, -59), (-31, -95), (31, -95), (81, -59)]\n    assert candidate(8, 6) == [(100, 0), (71, 71), (0, 100), (-71, 71), (-100, 0), (-71, -71), (0, -100), (71, -71)]\n    assert candidate(30, 25) == [(100, 0), (98, 21), (91, 41), (81, 59), (67, 74), (50, 87), (31, 95), (10, 99), (-10, 99), (-31, 95), (-50, 87), (-67, 74), (-81, 59), (-91, 41), (-98, 21), (-100, 0), (-98, -21), (-91, -41), (-81, -59), (-67, -74), (-50, -87), (-31, -95), (-10, -99), (10, -99), (31, -95), (50, -87), (67, -74), (81, -59), (91, -41), (98, -21)]\n    assert candidate(16, 14) == [(100, 0), (92, 38), (71, 71), (38, 92), (0, 100), (-38, 92), (-71, 71), (-92, 38), (-100, 0), (-92, -38), (-71, -71), (-38, -92), (0, -100), (38, -92), (71, -71), (92, -38)]\n    assert candidate(3, 1) == [(100, 0), (-50, 87), (-50, -87)]\n    assert candidate(18, 16) == [(100, 0), (94, 34), (77, 64), (50, 87), (17, 98), (-17, 98), (-50, 87), (-77, 64), (-94, 34), (-100, 0), (-94, -34), (-77, -64), (-50, -87), (-17, -98), (17, -98), (50, -87), (77, -64), (94, -34)]\n    assert candidate(25, 20) == [(100, 0), (97, 25), (88, 48), (73, 68), (54, 84), (31, 95), (6, 100), (-19, 98), (-43, 90), (-64, 77), (-81, 59), (-93, 37), (-99, 13), (-99, -13), (-93, -37), (-81, -59), (-64, -77), (-43, -90), (-19, -98), (6, -100), (31, -95), (54, -84), (73, -68), (88, -48), (97, -25)]\n", "language": "python"}
{"task_id": "3e77befd-7948-4fd7-bef9-bf7cca116a76-5396485549600277188", "prompt": "Focus on completing the given function so that it can be executed independently in a single code block. Do not write any code outside of the function's boundaries. Limit yourself to using only the libraries that are imported in the problem description. Any additional functions or classes should be defined exclusively within the provided function.\n\n```python\nfrom typing import List, Dict, Tuple\nfrom collections import defaultdict\nfrom typing import List, Dict\n\ndef analyze_social_network(connections: List[Tuple[str, str]]) -> Dict[str, int]:\n    \"\"\"\n    A social media analyst wants to understand the structure of a small social network. This function analyzes\n    the connections between people in the network and determines the number of friends each person has.\n\n    The function takes one parameter:\n    - connections: A list of tuples, where each tuple represents a friendship between two people\n\n    The function should use a dictionary to count friends, set comprehension to find unique individuals,\n    and a dictionary comprehension to create the final result.\n\n\n    [EXAMPLES]\n    \n    assert candidate([('John', 'Mary'), ('Mary', 'Peter'), ('Peter', 'John'), ('Sarah', 'John')]) == {'Mary': 2, 'John': 3, 'Peter': 2, 'Sarah': 1}\n    assert candidate([]) == {}\n\n    [/EXAMPLES]\n    \"\"\"\n```\n", "entry_point": "analyze_social_network", "solution": "from typing import List, Dict, Tuple\nfrom collections import defaultdict\nfrom typing import List, Dict\n\ndef analyze_social_network(connections: List[Tuple[str, str]]) -> Dict[str, int]:\n    \"\"\"\n    A social media analyst wants to understand the structure of a small social network. This function analyzes\n    the connections between people in the network and determines the number of friends each person has.\n\n    The function takes one parameter:\n    - connections: A list of tuples, where each tuple represents a friendship between two people\n\n    The function should use a dictionary to count friends, set comprehension to find unique individuals,\n    and a dictionary comprehension to create the final result.\n\n\n    [EXAMPLES]\n    \n    assert candidate([('John', 'Mary'), ('Mary', 'Peter'), ('Peter', 'John'), ('Sarah', 'John')]) == {'Mary': 2, 'John': 3, 'Peter': 2, 'Sarah': 1}\n    assert candidate([]) == {}\n\n    [/EXAMPLES]\n    \"\"\"\n    # Use defaultdict to count friends\n    friend_count = defaultdict(int)\n    \n    # Count friends for each person\n    for person1, person2 in connections:\n        friend_count[person1] += 1\n        friend_count[person2] += 1\n    \n    # Use set comprehension to find unique individuals\n    unique_individuals = {person for connection in connections for person in connection}\n    \n    # Use dictionary comprehension to create the final result\n    return {person: friend_count[person] for person in unique_individuals}\n\n", "test": "def check(candidate):\n    assert candidate([('X', 'Y' + str(i)) for i in range(10)] + [('Z', 'Y' + str(i)) for i in range(10)]) == {'Y6': 2, 'X': 10, 'Y7': 2, 'Y2': 2, 'Y4': 2, 'Z': 10, 'Y1': 2, 'Y9': 2, 'Y5': 2, 'Y0': 2, 'Y8': 2, 'Y3': 2}\n    assert candidate([('X', 'X')]) == {'X': 2}\n    assert candidate([('', '')]) == {'': 2}\n    assert candidate([('John', 'Mary'), ('Mary', 'Peter'), ('Peter', 'John'), ('Sarah', 'John')]) == {'Mary': 2, 'John': 3, 'Peter': 2, 'Sarah': 1}\n    assert candidate([('A', 'B')]) == {'A': 1, 'B': 1}\n    assert candidate([('A', 'B'), ('B', 'C'), ('C', 'D'), ('D', 'A'), ('A', 'C'), ('B', 'D')]) == {'D': 3, 'A': 3, 'C': 3, 'B': 3}\n    assert candidate([]) == {}\n    assert candidate([('Alice', 'Bob'), ('Bob', 'Alice')]) == {'Alice': 2, 'Bob': 2}\n    assert candidate([('  ', '  ')]) == {'  ': 2}\n    assert candidate([('A', 'B'), ('C', 'D'), ('E', 'F'), ('G', 'H'), ('I', 'J')]) == {'A': 1, 'E': 1, 'I': 1, 'D': 1, 'F': 1, 'G': 1, 'H': 1, 'C': 1, 'J': 1, 'B': 1}\n", "language": "python"}
{"task_id": "6c799ed7-ad8c-428e-8151-8b49fdd32ae6-2819856852286884468", "prompt": "Your mission is to complete a pre-defined function that is executable as-is within a code block. Abstain from writing code outside the function's scope. Use exclusively the libraries that are imported in the problem setup. Should you need to introduce additional functions or classes, make sure to define them strictly inside the provided function.\n\n```python\nfrom typing import List, Tuple\n\ndef optimize_study_schedule(subjects: List[str], difficulties: List[int], available_time: int) -> List[str]:\n    \"\"\"Create an optimized study schedule based on subject difficulties and available time.\n\n    As a student preparing for exams, you want to create an efficient study schedule. You have a list\n    of subjects, their corresponding difficulties, and a limited amount of study time available.\n    Your task is to implement a function that determines the optimal set of subjects to study\n    within the given time constraint, maximizing the total difficulty covered.\n\n    The function should take three parameters:\n    1. subjects: A list of strings representing subject names\n    2. difficulties: A list of integers representing the difficulty level of each subject (1-10)\n    3. available_time: An integer representing the total available study time in hours\n\n    Assume that each subject takes 1 hour to study, regardless of its difficulty.\n    Return a list of subject names that should be studied to maximize the total difficulty covered.\n\n\n    [EXAMPLES]\n    \n    assert candidate([\"Geography\", \"History\", \"Civics\"], [4, 5, 3], 3) == ['Geography', 'History', 'Civics']\n    assert candidate([\"Discrete Math\", \"Data Structures\", \"Algorithms\", \"Operating Systems\", \"Networks\"], [9, 8, 10, 7, 6], 3) == ['Discrete Math', 'Data Structures', 'Algorithms']\n\n    [/EXAMPLES]\n    \"\"\"\n```\n", "entry_point": "optimize_study_schedule", "solution": "from typing import List, Tuple\n\ndef optimize_study_schedule(subjects: List[str], difficulties: List[int], available_time: int) -> List[str]:\n    \"\"\"Create an optimized study schedule based on subject difficulties and available time.\n\n    As a student preparing for exams, you want to create an efficient study schedule. You have a list\n    of subjects, their corresponding difficulties, and a limited amount of study time available.\n    Your task is to implement a function that determines the optimal set of subjects to study\n    within the given time constraint, maximizing the total difficulty covered.\n\n    The function should take three parameters:\n    1. subjects: A list of strings representing subject names\n    2. difficulties: A list of integers representing the difficulty level of each subject (1-10)\n    3. available_time: An integer representing the total available study time in hours\n\n    Assume that each subject takes 1 hour to study, regardless of its difficulty.\n    Return a list of subject names that should be studied to maximize the total difficulty covered.\n\n\n    [EXAMPLES]\n    \n    assert candidate([\"Geography\", \"History\", \"Civics\"], [4, 5, 3], 3) == ['Geography', 'History', 'Civics']\n    assert candidate([\"Discrete Math\", \"Data Structures\", \"Algorithms\", \"Operating Systems\", \"Networks\"], [9, 8, 10, 7, 6], 3) == ['Discrete Math', 'Data Structures', 'Algorithms']\n\n    [/EXAMPLES]\n    \"\"\"\n    \n    def knapsack(n: int, W: int, weights: List[int], values: List[int]) -> Tuple[int, List[int]]:\n        \"\"\"Solve 0/1 Knapsack problem using dynamic programming.\"\"\"\n        K = [[0 for _ in range(W + 1)] for _ in range(n + 1)]\n        \n        for i in range(n + 1):\n            for w in range(W + 1):\n                if i == 0 or w == 0:\n                    K[i][w] = 0\n                elif weights[i-1] <= w:\n                    K[i][w] = max(values[i-1] + K[i-1][w-weights[i-1]], K[i-1][w])\n                else:\n                    K[i][w] = K[i-1][w]\n        \n        # Backtrack to find the selected items\n        selected = []\n        i, w = n, W\n        while i > 0 and w > 0:\n            if K[i][w] != K[i-1][w]:\n                selected.append(i-1)\n                w -= weights[i-1]\n            i -= 1\n        \n        return K[n][W], selected[::-1]\n\n    n = len(subjects)\n    weights = [1] * n  # Each subject takes 1 hour\n    values = difficulties\n    \n    _, selected_indices = knapsack(n, available_time, weights, values)\n    \n    return [subjects[i] for i in selected_indices]\n\n", "test": "def check(candidate):\n    assert candidate([\"Calculus\", \"Linear Algebra\", \"Probability\", \"Statistics\"], [10, 9, 8, 7], 2) == ['Calculus', 'Linear Algebra']\n    assert candidate([\"Geography\", \"History\", \"Civics\"], [4, 5, 3], 3) == ['Geography', 'History', 'Civics']\n    assert candidate([\"Biology\", \"Chemistry\", \"Economics\", \"Psychology\", \"Art\"], [7, 8, 6, 5, 3], 4) == ['Biology', 'Chemistry', 'Economics', 'Psychology']\n    assert candidate([\"English\", \"French\", \"Spanish\", \"German\", \"Italian\"], [5, 6, 7, 8, 9], 3) == ['Spanish', 'German', 'Italian']\n    assert candidate([\"Programming\", \"Algorithms\", \"Databases\"], [9, 10, 8], 2) == ['Programming', 'Algorithms']\n    assert candidate([], [], 5) == []\n    assert candidate([\"Math\", \"History\", \"Physics\", \"Literature\"], [8, 5, 9, 6], 3) == ['Math', 'Physics', 'Literature']\n    assert candidate([\"Ancient History\", \"Medieval History\", \"Modern History\"], [5, 6, 7], 3) == ['Ancient History', 'Medieval History', 'Modern History']\n    assert candidate([\"Discrete Math\", \"Data Structures\", \"Algorithms\", \"Operating Systems\", \"Networks\"], [9, 8, 10, 7, 6], 3) == ['Discrete Math', 'Data Structures', 'Algorithms']\n    assert candidate([\"Robotics\", \"AI\", \"Machine Learning\", \"Computer Vision\"], [9, 10, 8, 7], 2) == ['Robotics', 'AI']\n", "language": "python"}
{"task_id": "0d04938a-7ab0-4af3-819b-f1983256a9f43270186890793787988", "prompt": "Finish writing the function to match the specifications outlined in the doc string. Ensure the complete function is contained in one unified code block.\n\n```python\nfrom typing import List\n\ndef minimize_array_jumps(arr: List[int]) -> int:\n    \"\"\"\n    Calculate the minimum number of jumps to reach the end of the array.\n\n    Given an array of non-negative integers, where each element represents the\n    maximum number of steps that can be jumped forward from that element, find\n    the minimum number of jumps needed to reach the last index. If it's not\n    possible to reach the end, return -1.\n\n    Args:\n    arr (List[int]): A list of non-negative integers representing maximum jump lengths.\n\n    Returns:\n    int: The minimum number of jumps needed to reach the end, or -1 if impossible.\n\n\n    [EXAMPLES]\n    \n    assert candidate([2,3,1,1,4]) == 2\n    assert candidate([1,2,3]) == 2\n\n    [/EXAMPLES]\n    \"\"\"\n```\n", "entry_point": "minimize_array_jumps", "solution": "from typing import List\n\ndef minimize_array_jumps(arr: List[int]) -> int:\n    \"\"\"\n    Calculate the minimum number of jumps to reach the end of the array.\n\n    Given an array of non-negative integers, where each element represents the\n    maximum number of steps that can be jumped forward from that element, find\n    the minimum number of jumps needed to reach the last index. If it's not\n    possible to reach the end, return -1.\n\n    Args:\n    arr (List[int]): A list of non-negative integers representing maximum jump lengths.\n\n    Returns:\n    int: The minimum number of jumps needed to reach the end, or -1 if impossible.\n\n\n    [EXAMPLES]\n    \n    assert candidate([2,3,1,1,4]) == 2\n    assert candidate([1,2,3]) == 2\n\n    [/EXAMPLES]\n    \"\"\"\n    n = len(arr)\n    if n <= 1:\n        return 0\n\n    if arr[0] == 0:\n        return -1\n\n    max_reach = arr[0]\n    steps_left = arr[0]\n    jumps = 1\n\n    for i in range(1, n - 1):\n        max_reach = max(max_reach, i + arr[i])\n        steps_left -= 1\n\n        if steps_left == 0:\n            jumps += 1\n            if i >= max_reach:\n                return -1\n            steps_left = max_reach - i\n\n    return jumps\n\n", "test": "def check(candidate):\n    assert candidate([3,4,2,1,2,3,7,1,1,1,3]) == 4\n    assert candidate([3,3,3,3,3]) == 2\n    assert candidate([1]) == 0\n    assert candidate([1,1,1,1]) == 3\n    assert candidate([1]*100) == 99\n    assert candidate([1,2,3]) == 2\n    assert candidate([2,3,1,1,4]) == 2\n    assert candidate([0,1,2,3]) == -1\n    assert candidate([10]) == 0\n    assert candidate([5,4,3,2,1,0]) == 1\n", "language": "python"}
{"task_id": "eed70b34-772c-4340-a7fa-f44e0a6127b7218483985121895599", "prompt": "Follow the doc string's directions to implement the function. Keep all code confined to one code block. Any extra functions or classes must be declared within the scope of the provided function.\n\n```python\nfrom typing import List, Tuple\n\ndef optimize_rescue_mission(grid: List[List[int]]) -> List[Tuple[int, int]]:\n    \"\"\"\n    Plan an optimal rescue mission path for a team of rescuers in a disaster-struck area.\n\n    Given a grid representing the affected area, where each cell contains an integer\n    indicating the number of people needing rescue, find the optimal path that maximizes\n    the number of people rescued while minimizing the distance traveled.\n\n    The rescue team starts from the top-left corner (0, 0) and can move only right or down.\n    The mission ends when they reach the bottom-right corner.\n\n    This function uses dynamic programming and backtracking to find the optimal path.\n\n    :param grid: A 2D list representing the disaster area with people needing rescue\n    :return: A list of tuples representing the optimal path coordinates\n\n\n    [EXAMPLES]\n    \n    assert candidate([[1, 2, 3, 4, 5], [6, 7, 8, 9, 10], [11, 12, 13, 14, 15], [16, 17, 18, 19, 20], [21, 22, 23, 24, 25]]) == [(0, 0), (1, 0), (2, 0), (3, 0), (4, 0), (4, 1), (4, 2), (4, 3), (4, 4)]\n    assert candidate([[1, 2], [3, 4], [5, 6], [7, 8]]) == [(0, 0), (1, 0), (2, 0), (3, 0), (3, 1)]\n\n    [/EXAMPLES]\n    \"\"\"\n```\n", "entry_point": "optimize_rescue_mission", "solution": "from typing import List, Tuple\n\ndef optimize_rescue_mission(grid: List[List[int]]) -> List[Tuple[int, int]]:\n    \"\"\"\n    Plan an optimal rescue mission path for a team of rescuers in a disaster-struck area.\n\n    Given a grid representing the affected area, where each cell contains an integer\n    indicating the number of people needing rescue, find the optimal path that maximizes\n    the number of people rescued while minimizing the distance traveled.\n\n    The rescue team starts from the top-left corner (0, 0) and can move only right or down.\n    The mission ends when they reach the bottom-right corner.\n\n    This function uses dynamic programming and backtracking to find the optimal path.\n\n    :param grid: A 2D list representing the disaster area with people needing rescue\n    :return: A list of tuples representing the optimal path coordinates\n\n\n    [EXAMPLES]\n    \n    assert candidate([[1, 2, 3, 4, 5], [6, 7, 8, 9, 10], [11, 12, 13, 14, 15], [16, 17, 18, 19, 20], [21, 22, 23, 24, 25]]) == [(0, 0), (1, 0), (2, 0), (3, 0), (4, 0), (4, 1), (4, 2), (4, 3), (4, 4)]\n    assert candidate([[1, 2], [3, 4], [5, 6], [7, 8]]) == [(0, 0), (1, 0), (2, 0), (3, 0), (3, 1)]\n\n    [/EXAMPLES]\n    \"\"\"\n    if not grid or not grid[0]:\n        return []\n\n    rows, cols = len(grid), len(grid[0])\n    \n    # Initialize dp table with the same dimensions as the grid\n    dp = [[0] * cols for _ in range(rows)]\n    \n    # Fill the dp table\n    for i in range(rows):\n        for j in range(cols):\n            if i == 0 and j == 0:\n                dp[i][j] = grid[i][j]\n            elif i == 0:\n                dp[i][j] = dp[i][j-1] + grid[i][j]\n            elif j == 0:\n                dp[i][j] = dp[i-1][j] + grid[i][j]\n            else:\n                dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + grid[i][j]\n    \n    # Backtrack to find the optimal path\n    path = []\n    i, j = rows - 1, cols - 1\n    \n    while i > 0 or j > 0:\n        path.append((i, j))\n        if i == 0:\n            j -= 1\n        elif j == 0:\n            i -= 1\n        elif dp[i-1][j] > dp[i][j-1]:\n            i -= 1\n        else:\n            j -= 1\n    \n    path.append((0, 0))\n    path.reverse()\n    \n    return path\n\n", "test": "def check(candidate):\n    assert candidate([[1, 2], [3, 4], [5, 6], [7, 8]]) == [(0, 0), (1, 0), (2, 0), (3, 0), (3, 1)]\n    assert candidate([[1, 2, 3], [4, 5, 6], [7, 8, 9], [10, 11, 12], [13, 14, 15]]) == [(0, 0), (1, 0), (2, 0), (3, 0), (4, 0), (4, 1), (4, 2)]\n    assert candidate([[1, 2, 3, 4], [5, 6, 7, 8], [9, 10, 11, 12]]) == [(0, 0), (1, 0), (2, 0), (2, 1), (2, 2), (2, 3)]\n    assert candidate([[1, 1], [1, 1]]) == [(0, 0), (1, 0), (1, 1)]\n    assert candidate([[100]]) == [(0, 0)]\n    assert candidate([[5, 1, 2], [3, 7, 4], [2, 3, 6]]) == [(0, 0), (1, 0), (1, 1), (1, 2), (2, 2)]\n    assert candidate([[1, 2, 3, 4, 5], [6, 7, 8, 9, 10], [11, 12, 13, 14, 15], [16, 17, 18, 19, 20], [21, 22, 23, 24, 25]]) == [(0, 0), (1, 0), (2, 0), (3, 0), (4, 0), (4, 1), (4, 2), (4, 3), (4, 4)]\n    assert candidate([[1, 2, 3], [4, 5, 6], [7, 8, 9]]) == [(0, 0), (1, 0), (2, 0), (2, 1), (2, 2)]\n    assert candidate([[9, 9, 9], [9, 1, 9], [9, 9, 9]]) == [(0, 0), (1, 0), (2, 0), (2, 1), (2, 2)]\n    assert candidate([[10, 20, 30], [40, 50, 60]]) == [(0, 0), (1, 0), (1, 1), (1, 2)]\n", "language": "python"}
{"task_id": "a2b11015-32c3-4880-b5af-2df78817f99c-8394865543636008584", "prompt": "Craft the full code solution, integrating all components into one comprehensive block.\n\n```python\nfrom typing import List\n\ndef binary_matrix_paths(matrix: List[List[int]]) -> int:\n    \"\"\"\n    As a robot navigator, you're tasked with finding the number of unique paths through a binary matrix.\n    The matrix consists of 0s and 1s, where 0 represents a clear path and 1 represents an obstacle.\n    You can only move right or down, and your goal is to reach the bottom-right corner from the top-left corner.\n\n    Your task is to calculate the number of unique paths from the start to the end, avoiding obstacles.\n    If there's no valid path, return 0.\n\n\n    [EXAMPLES]\n    \n    assert candidate([[0,0,0,0],[0,1,0,0],[0,0,1,0],[0,0,0,0]]) == 4\n    assert candidate([[0]]) == 1\n\n    [/EXAMPLES]\n    \"\"\"\n```\n", "entry_point": "binary_matrix_paths", "solution": "from typing import List\n\ndef binary_matrix_paths(matrix: List[List[int]]) -> int:\n    \"\"\"\n    As a robot navigator, you're tasked with finding the number of unique paths through a binary matrix.\n    The matrix consists of 0s and 1s, where 0 represents a clear path and 1 represents an obstacle.\n    You can only move right or down, and your goal is to reach the bottom-right corner from the top-left corner.\n\n    Your task is to calculate the number of unique paths from the start to the end, avoiding obstacles.\n    If there's no valid path, return 0.\n\n\n    [EXAMPLES]\n    \n    assert candidate([[0,0,0,0],[0,1,0,0],[0,0,1,0],[0,0,0,0]]) == 4\n    assert candidate([[0]]) == 1\n\n    [/EXAMPLES]\n    \"\"\"\n    if not matrix or not matrix[0] or matrix[0][0] == 1:\n        return 0\n\n    m, n = len(matrix), len(matrix[0])\n    dp = [[0] * n for _ in range(m)]\n\n    # Initialize the first row and column\n    for i in range(m):\n        if matrix[i][0] == 1:\n            break\n        dp[i][0] = 1\n\n    for j in range(n):\n        if matrix[0][j] == 1:\n            break\n        dp[0][j] = 1\n\n    # Fill the DP table\n    for i in range(1, m):\n        for j in range(1, n):\n            if matrix[i][j] == 0:\n                dp[i][j] = dp[i-1][j] + dp[i][j-1]\n\n    return dp[m-1][n-1]\n\n", "test": "def check(candidate):\n    assert candidate([[0,0,0,0],[0,1,0,0],[0,0,1,0],[0,0,0,0]]) == 4\n    assert candidate([[0,1,0],[1,0,0],[0,0,0]]) == 0\n    assert candidate([[1,1,1,1],[1,1,1,1],[1,1,1,1],[1,1,1,0]]) == 0\n    assert candidate([[0,0,0,0,0],[0,1,1,1,0],[0,0,0,0,0],[1,1,1,1,0],[0,0,0,0,0]]) == 2\n    assert candidate([[0,1],[0,0]]) == 1\n    assert candidate([[0]]) == 1\n    assert candidate([[0,0,0,0],[0,0,0,0],[0,0,0,0],[0,0,0,0]]) == 20\n    assert candidate([[1,1,1],[1,1,1],[1,1,0]]) == 0\n    assert candidate([[1]]) == 0\n    assert candidate([[0,1,1,1],[1,0,1,1],[1,1,0,1],[1,1,1,0]]) == 0\n", "language": "python"}
{"task_id": "f972ae77-3d0b-47ca-bf94-a9bd241e5bee-8728543721465857796", "prompt": "Implement the remaining part of the function according to the specifications in the doc string. Enclose the complete function in one code block, and remember to consider all possible scenarios, including edge cases.\n\n```python\ndef word_pattern(pattern: str, words: str) -> bool:\n    \"\"\"\n    A linguistics researcher is developing a tool to identify word patterns in sentences.\n    Given a pattern string and a string of words, this function determines if the word pattern\n    matches the string of words.\n\n    In the pattern string, each letter represents a word, and the same letter should always\n    represent the same word. Different letters must represent different words.\n\n    The function should return True if the pattern matches the words, and False otherwise.\n\n\n    [EXAMPLES]\n    \n    assert candidate(\"abc\", \"dog cat dog\") == False\n    assert candidate(\"abc\", \"dog cat fish\") == True\n\n    [/EXAMPLES]\n    \"\"\"\n```\n", "entry_point": "word_pattern", "solution": "def word_pattern(pattern: str, words: str) -> bool:\n    \"\"\"\n    A linguistics researcher is developing a tool to identify word patterns in sentences.\n    Given a pattern string and a string of words, this function determines if the word pattern\n    matches the string of words.\n\n    In the pattern string, each letter represents a word, and the same letter should always\n    represent the same word. Different letters must represent different words.\n\n    The function should return True if the pattern matches the words, and False otherwise.\n\n\n    [EXAMPLES]\n    \n    assert candidate(\"abc\", \"dog cat dog\") == False\n    assert candidate(\"abc\", \"dog cat fish\") == True\n\n    [/EXAMPLES]\n    \"\"\"\n    word_list = words.split()\n    \n    # Check if the lengths match\n    if len(pattern) != len(word_list):\n        return False\n    \n    # Create dictionaries to store mappings\n    pattern_to_word = {}\n    word_to_pattern = {}\n    \n    # Iterate through the pattern and words simultaneously\n    for p, w in zip(pattern, word_list):\n        # If the pattern letter is already mapped\n        if p in pattern_to_word:\n            # Check if it matches the current word\n            if pattern_to_word[p] != w:\n                return False\n        # If the word is already mapped\n        elif w in word_to_pattern:\n            # Check if it matches the current pattern letter\n            if word_to_pattern[w] != p:\n                return False\n        else:\n            # Create new mappings\n            pattern_to_word[p] = w\n            word_to_pattern[w] = p\n    \n    # If we've made it through the loop, the pattern matches\n    return True\n\n", "test": "def check(candidate):\n    assert candidate(\"a\", \"single\") == True\n    assert candidate(\"aabb\", \"cat cat dog dog\") == True\n    assert candidate(\"abc\", \"dog cat dog\") == False\n    assert candidate(\"abcd\", \"cat dog fish bird\") == True\n    assert candidate(\"ab\", \"cat\") == False\n    assert candidate(\"abcd\", \"cat cat cat cat\") == False\n    assert candidate(\"aaaa\", \"cat cat cat cat\") == True\n    assert candidate(\"abc\", \"dog cat fish\") == True\n    assert candidate(\"aba\", \"cat dog cat\") == True\n    assert candidate(\"abab\", \"cat dog cat dog\") == True\n", "language": "python"}
{"task_id": "3cb3fcee-d8ca-41d0-98cb-c074665beebb5943952122120349423", "prompt": "Kindly implement the function as specified in the docstring instructions, ensuring all code is contained within one code block. If necessary, define any supplementary functions or classes exclusively inside the provided function.\n\n```python\nfrom collections import defaultdict\nfrom typing import List, Tuple, Dict\n\ndef analyze_social_network(connections: List[Tuple[str, str]]) -> Dict[str, int]:\n    \"\"\"\n    Analyzes a social network to determine the most influential individuals.\n\n    This function takes a list of connections between individuals in a social\n    network and uses graph theory to calculate the degree centrality of each\n    person. The degree centrality is a measure of how many direct connections\n    a person has in the network.\n\n    Args:\n    connections (List[Tuple[str, str]]): A list of tuples representing connections between individuals.\n\n    Returns:\n    Dict[str, int]: A dictionary with individuals as keys and their degree centrality as values.\n\n\n    [EXAMPLES]\n    \n    assert candidate([(\"One\", \"Two\"), (\"Two\", \"Three\"), (\"Three\", \"Four\")] * 100 + [(\"Isolated\", \"Node\")]) == {'One': 100, 'Two': 200, 'Three': 200, 'Four': 100, 'Isolated': 1, 'Node': 1}\n    assert candidate([(\"1\", \"2\"), (\"2\", \"3\"), (\"3\", \"1\"), (\"1\", \"4\"), (\"2\", \"4\"), (\"3\", \"4\")]) == {'1': 3, '2': 3, '3': 3, '4': 3}\n\n    [/EXAMPLES]\n    \"\"\"\n```\n", "entry_point": "analyze_social_network", "solution": "from collections import defaultdict\nfrom typing import List, Tuple, Dict\n\ndef analyze_social_network(connections: List[Tuple[str, str]]) -> Dict[str, int]:\n    \"\"\"\n    Analyzes a social network to determine the most influential individuals.\n\n    This function takes a list of connections between individuals in a social\n    network and uses graph theory to calculate the degree centrality of each\n    person. The degree centrality is a measure of how many direct connections\n    a person has in the network.\n\n    Args:\n    connections (List[Tuple[str, str]]): A list of tuples representing connections between individuals.\n\n    Returns:\n    Dict[str, int]: A dictionary with individuals as keys and their degree centrality as values.\n\n\n    [EXAMPLES]\n    \n    assert candidate([(\"One\", \"Two\"), (\"Two\", \"Three\"), (\"Three\", \"Four\")] * 100 + [(\"Isolated\", \"Node\")]) == {'One': 100, 'Two': 200, 'Three': 200, 'Four': 100, 'Isolated': 1, 'Node': 1}\n    assert candidate([(\"1\", \"2\"), (\"2\", \"3\"), (\"3\", \"1\"), (\"1\", \"4\"), (\"2\", \"4\"), (\"3\", \"4\")]) == {'1': 3, '2': 3, '3': 3, '4': 3}\n\n    [/EXAMPLES]\n    \"\"\"\n    # Initialize a dictionary to store the degree centrality of each person\n    degree_centrality = {}\n\n    # Iterate through each connection in the list\n    for person1, person2 in connections:\n        # Increment the degree centrality for person1\n        degree_centrality[person1] = degree_centrality.get(person1, 0) + 1\n        # Increment the degree centrality for person2\n        degree_centrality[person2] = degree_centrality.get(person2, 0) + 1\n\n    return degree_centrality\n\n", "test": "def check(candidate):\n    assert candidate([(f\"User{i}\", f\"User{i+1}\") for i in range(999)] + [(\"User999\", \"User0\")]) == {'User0': 2, 'User1': 2, 'User2': 2, 'User3': 2, 'User4': 2, 'User5': 2, 'User6': 2, 'User7': 2, 'User8': 2, 'User9': 2, 'User10': 2, 'User11': 2, 'User12': 2, 'User13': 2, 'User14': 2, 'User15': 2, 'User16': 2, 'User17': 2, 'User18': 2, 'User19': 2, 'User20': 2, 'User21': 2, 'User22': 2, 'User23': 2, 'User24': 2, 'User25': 2, 'User26': 2, 'User27': 2, 'User28': 2, 'User29': 2, 'User30': 2, 'User31': 2, 'User32': 2, 'User33': 2, 'User34': 2, 'User35': 2, 'User36': 2, 'User37': 2, 'User38': 2, 'User39': 2, 'User40': 2, 'User41': 2, 'User42': 2, 'User43': 2, 'User44': 2, 'User45': 2, 'User46': 2, 'User47': 2, 'User48': 2, 'User49': 2, 'User50': 2, 'User51': 2, 'User52': 2, 'User53': 2, 'User54': 2, 'User55': 2, 'User56': 2, 'User57': 2, 'User58': 2, 'User59': 2, 'User60': 2, 'User61': 2, 'User62': 2, 'User63': 2, 'User64': 2, 'User65': 2, 'User66': 2, 'User67': 2, 'User68': 2, 'User69': 2, 'User70': 2, 'User71': 2, 'User72': 2, 'User73': 2, 'User74': 2, 'User75': 2, 'User76': 2, 'User77': 2, 'User78': 2, 'User79': 2, 'User80': 2, 'User81': 2, 'User82': 2, 'User83': 2, 'User84': 2, 'User85': 2, 'User86': 2, 'User87': 2, 'User88': 2, 'User89': 2, 'User90': 2, 'User91': 2, 'User92': 2, 'User93': 2, 'User94': 2, 'User95': 2, 'User96': 2, 'User97': 2, 'User98': 2, 'User99': 2, 'User100': 2, 'User101': 2, 'User102': 2, 'User103': 2, 'User104': 2, 'User105': 2, 'User106': 2, 'User107': 2, 'User108': 2, 'User109': 2, 'User110': 2, 'User111': 2, 'User112': 2, 'User113': 2, 'User114': 2, 'User115': 2, 'User116': 2, 'User117': 2, 'User118': 2, 'User119': 2, 'User120': 2, 'User121': 2, 'User122': 2, 'User123': 2, 'User124': 2, 'User125': 2, 'User126': 2, 'User127': 2, 'User128': 2, 'User129': 2, 'User130': 2, 'User131': 2, 'User132': 2, 'User133': 2, 'User134': 2, 'User135': 2, 'User136': 2, 'User137': 2, 'User138': 2, 'User139': 2, 'User140': 2, 'User141': 2, 'User142': 2, 'User143': 2, 'User144': 2, 'User145': 2, 'User146': 2, 'User147': 2, 'User148': 2, 'User149': 2, 'User150': 2, 'User151': 2, 'User152': 2, 'User153': 2, 'User154': 2, 'User155': 2, 'User156': 2, 'User157': 2, 'User158': 2, 'User159': 2, 'User160': 2, 'User161': 2, 'User162': 2, 'User163': 2, 'User164': 2, 'User165': 2, 'User166': 2, 'User167': 2, 'User168': 2, 'User169': 2, 'User170': 2, 'User171': 2, 'User172': 2, 'User173': 2, 'User174': 2, 'User175': 2, 'User176': 2, 'User177': 2, 'User178': 2, 'User179': 2, 'User180': 2, 'User181': 2, 'User182': 2, 'User183': 2, 'User184': 2, 'User185': 2, 'User186': 2, 'User187': 2, 'User188': 2, 'User189': 2, 'User190': 2, 'User191': 2, 'User192': 2, 'User193': 2, 'User194': 2, 'User195': 2, 'User196': 2, 'User197': 2, 'User198': 2, 'User199': 2, 'User200': 2, 'User201': 2, 'User202': 2, 'User203': 2, 'User204': 2, 'User205': 2, 'User206': 2, 'User207': 2, 'User208': 2, 'User209': 2, 'User210': 2, 'User211': 2, 'User212': 2, 'User213': 2, 'User214': 2, 'User215': 2, 'User216': 2, 'User217': 2, 'User218': 2, 'User219': 2, 'User220': 2, 'User221': 2, 'User222': 2, 'User223': 2, 'User224': 2, 'User225': 2, 'User226': 2, 'User227': 2, 'User228': 2, 'User229': 2, 'User230': 2, 'User231': 2, 'User232': 2, 'User233': 2, 'User234': 2, 'User235': 2, 'User236': 2, 'User237': 2, 'User238': 2, 'User239': 2, 'User240': 2, 'User241': 2, 'User242': 2, 'User243': 2, 'User244': 2, 'User245': 2, 'User246': 2, 'User247': 2, 'User248': 2, 'User249': 2, 'User250': 2, 'User251': 2, 'User252': 2, 'User253': 2, 'User254': 2, 'User255': 2, 'User256': 2, 'User257': 2, 'User258': 2, 'User259': 2, 'User260': 2, 'User261': 2, 'User262': 2, 'User263': 2, 'User264': 2, 'User265': 2, 'User266': 2, 'User267': 2, 'User268': 2, 'User269': 2, 'User270': 2, 'User271': 2, 'User272': 2, 'User273': 2, 'User274': 2, 'User275': 2, 'User276': 2, 'User277': 2, 'User278': 2, 'User279': 2, 'User280': 2, 'User281': 2, 'User282': 2, 'User283': 2, 'User284': 2, 'User285': 2, 'User286': 2, 'User287': 2, 'User288': 2, 'User289': 2, 'User290': 2, 'User291': 2, 'User292': 2, 'User293': 2, 'User294': 2, 'User295': 2, 'User296': 2, 'User297': 2, 'User298': 2, 'User299': 2, 'User300': 2, 'User301': 2, 'User302': 2, 'User303': 2, 'User304': 2, 'User305': 2, 'User306': 2, 'User307': 2, 'User308': 2, 'User309': 2, 'User310': 2, 'User311': 2, 'User312': 2, 'User313': 2, 'User314': 2, 'User315': 2, 'User316': 2, 'User317': 2, 'User318': 2, 'User319': 2, 'User320': 2, 'User321': 2, 'User322': 2, 'User323': 2, 'User324': 2, 'User325': 2, 'User326': 2, 'User327': 2, 'User328': 2, 'User329': 2, 'User330': 2, 'User331': 2, 'User332': 2, 'User333': 2, 'User334': 2, 'User335': 2, 'User336': 2, 'User337': 2, 'User338': 2, 'User339': 2, 'User340': 2, 'User341': 2, 'User342': 2, 'User343': 2, 'User344': 2, 'User345': 2, 'User346': 2, 'User347': 2, 'User348': 2, 'User349': 2, 'User350': 2, 'User351': 2, 'User352': 2, 'User353': 2, 'User354': 2, 'User355': 2, 'User356': 2, 'User357': 2, 'User358': 2, 'User359': 2, 'User360': 2, 'User361': 2, 'User362': 2, 'User363': 2, 'User364': 2, 'User365': 2, 'User366': 2, 'User367': 2, 'User368': 2, 'User369': 2, 'User370': 2, 'User371': 2, 'User372': 2, 'User373': 2, 'User374': 2, 'User375': 2, 'User376': 2, 'User377': 2, 'User378': 2, 'User379': 2, 'User380': 2, 'User381': 2, 'User382': 2, 'User383': 2, 'User384': 2, 'User385': 2, 'User386': 2, 'User387': 2, 'User388': 2, 'User389': 2, 'User390': 2, 'User391': 2, 'User392': 2, 'User393': 2, 'User394': 2, 'User395': 2, 'User396': 2, 'User397': 2, 'User398': 2, 'User399': 2, 'User400': 2, 'User401': 2, 'User402': 2, 'User403': 2, 'User404': 2, 'User405': 2, 'User406': 2, 'User407': 2, 'User408': 2, 'User409': 2, 'User410': 2, 'User411': 2, 'User412': 2, 'User413': 2, 'User414': 2, 'User415': 2, 'User416': 2, 'User417': 2, 'User418': 2, 'User419': 2, 'User420': 2, 'User421': 2, 'User422': 2, 'User423': 2, 'User424': 2, 'User425': 2, 'User426': 2, 'User427': 2, 'User428': 2, 'User429': 2, 'User430': 2, 'User431': 2, 'User432': 2, 'User433': 2, 'User434': 2, 'User435': 2, 'User436': 2, 'User437': 2, 'User438': 2, 'User439': 2, 'User440': 2, 'User441': 2, 'User442': 2, 'User443': 2, 'User444': 2, 'User445': 2, 'User446': 2, 'User447': 2, 'User448': 2, 'User449': 2, 'User450': 2, 'User451': 2, 'User452': 2, 'User453': 2, 'User454': 2, 'User455': 2, 'User456': 2, 'User457': 2, 'User458': 2, 'User459': 2, 'User460': 2, 'User461': 2, 'User462': 2, 'User463': 2, 'User464': 2, 'User465': 2, 'User466': 2, 'User467': 2, 'User468': 2, 'User469': 2, 'User470': 2, 'User471': 2, 'User472': 2, 'User473': 2, 'User474': 2, 'User475': 2, 'User476': 2, 'User477': 2, 'User478': 2, 'User479': 2, 'User480': 2, 'User481': 2, 'User482': 2, 'User483': 2, 'User484': 2, 'User485': 2, 'User486': 2, 'User487': 2, 'User488': 2, 'User489': 2, 'User490': 2, 'User491': 2, 'User492': 2, 'User493': 2, 'User494': 2, 'User495': 2, 'User496': 2, 'User497': 2, 'User498': 2, 'User499': 2, 'User500': 2, 'User501': 2, 'User502': 2, 'User503': 2, 'User504': 2, 'User505': 2, 'User506': 2, 'User507': 2, 'User508': 2, 'User509': 2, 'User510': 2, 'User511': 2, 'User512': 2, 'User513': 2, 'User514': 2, 'User515': 2, 'User516': 2, 'User517': 2, 'User518': 2, 'User519': 2, 'User520': 2, 'User521': 2, 'User522': 2, 'User523': 2, 'User524': 2, 'User525': 2, 'User526': 2, 'User527': 2, 'User528': 2, 'User529': 2, 'User530': 2, 'User531': 2, 'User532': 2, 'User533': 2, 'User534': 2, 'User535': 2, 'User536': 2, 'User537': 2, 'User538': 2, 'User539': 2, 'User540': 2, 'User541': 2, 'User542': 2, 'User543': 2, 'User544': 2, 'User545': 2, 'User546': 2, 'User547': 2, 'User548': 2, 'User549': 2, 'User550': 2, 'User551': 2, 'User552': 2, 'User553': 2, 'User554': 2, 'User555': 2, 'User556': 2, 'User557': 2, 'User558': 2, 'User559': 2, 'User560': 2, 'User561': 2, 'User562': 2, 'User563': 2, 'User564': 2, 'User565': 2, 'User566': 2, 'User567': 2, 'User568': 2, 'User569': 2, 'User570': 2, 'User571': 2, 'User572': 2, 'User573': 2, 'User574': 2, 'User575': 2, 'User576': 2, 'User577': 2, 'User578': 2, 'User579': 2, 'User580': 2, 'User581': 2, 'User582': 2, 'User583': 2, 'User584': 2, 'User585': 2, 'User586': 2, 'User587': 2, 'User588': 2, 'User589': 2, 'User590': 2, 'User591': 2, 'User592': 2, 'User593': 2, 'User594': 2, 'User595': 2, 'User596': 2, 'User597': 2, 'User598': 2, 'User599': 2, 'User600': 2, 'User601': 2, 'User602': 2, 'User603': 2, 'User604': 2, 'User605': 2, 'User606': 2, 'User607': 2, 'User608': 2, 'User609': 2, 'User610': 2, 'User611': 2, 'User612': 2, 'User613': 2, 'User614': 2, 'User615': 2, 'User616': 2, 'User617': 2, 'User618': 2, 'User619': 2, 'User620': 2, 'User621': 2, 'User622': 2, 'User623': 2, 'User624': 2, 'User625': 2, 'User626': 2, 'User627': 2, 'User628': 2, 'User629': 2, 'User630': 2, 'User631': 2, 'User632': 2, 'User633': 2, 'User634': 2, 'User635': 2, 'User636': 2, 'User637': 2, 'User638': 2, 'User639': 2, 'User640': 2, 'User641': 2, 'User642': 2, 'User643': 2, 'User644': 2, 'User645': 2, 'User646': 2, 'User647': 2, 'User648': 2, 'User649': 2, 'User650': 2, 'User651': 2, 'User652': 2, 'User653': 2, 'User654': 2, 'User655': 2, 'User656': 2, 'User657': 2, 'User658': 2, 'User659': 2, 'User660': 2, 'User661': 2, 'User662': 2, 'User663': 2, 'User664': 2, 'User665': 2, 'User666': 2, 'User667': 2, 'User668': 2, 'User669': 2, 'User670': 2, 'User671': 2, 'User672': 2, 'User673': 2, 'User674': 2, 'User675': 2, 'User676': 2, 'User677': 2, 'User678': 2, 'User679': 2, 'User680': 2, 'User681': 2, 'User682': 2, 'User683': 2, 'User684': 2, 'User685': 2, 'User686': 2, 'User687': 2, 'User688': 2, 'User689': 2, 'User690': 2, 'User691': 2, 'User692': 2, 'User693': 2, 'User694': 2, 'User695': 2, 'User696': 2, 'User697': 2, 'User698': 2, 'User699': 2, 'User700': 2, 'User701': 2, 'User702': 2, 'User703': 2, 'User704': 2, 'User705': 2, 'User706': 2, 'User707': 2, 'User708': 2, 'User709': 2, 'User710': 2, 'User711': 2, 'User712': 2, 'User713': 2, 'User714': 2, 'User715': 2, 'User716': 2, 'User717': 2, 'User718': 2, 'User719': 2, 'User720': 2, 'User721': 2, 'User722': 2, 'User723': 2, 'User724': 2, 'User725': 2, 'User726': 2, 'User727': 2, 'User728': 2, 'User729': 2, 'User730': 2, 'User731': 2, 'User732': 2, 'User733': 2, 'User734': 2, 'User735': 2, 'User736': 2, 'User737': 2, 'User738': 2, 'User739': 2, 'User740': 2, 'User741': 2, 'User742': 2, 'User743': 2, 'User744': 2, 'User745': 2, 'User746': 2, 'User747': 2, 'User748': 2, 'User749': 2, 'User750': 2, 'User751': 2, 'User752': 2, 'User753': 2, 'User754': 2, 'User755': 2, 'User756': 2, 'User757': 2, 'User758': 2, 'User759': 2, 'User760': 2, 'User761': 2, 'User762': 2, 'User763': 2, 'User764': 2, 'User765': 2, 'User766': 2, 'User767': 2, 'User768': 2, 'User769': 2, 'User770': 2, 'User771': 2, 'User772': 2, 'User773': 2, 'User774': 2, 'User775': 2, 'User776': 2, 'User777': 2, 'User778': 2, 'User779': 2, 'User780': 2, 'User781': 2, 'User782': 2, 'User783': 2, 'User784': 2, 'User785': 2, 'User786': 2, 'User787': 2, 'User788': 2, 'User789': 2, 'User790': 2, 'User791': 2, 'User792': 2, 'User793': 2, 'User794': 2, 'User795': 2, 'User796': 2, 'User797': 2, 'User798': 2, 'User799': 2, 'User800': 2, 'User801': 2, 'User802': 2, 'User803': 2, 'User804': 2, 'User805': 2, 'User806': 2, 'User807': 2, 'User808': 2, 'User809': 2, 'User810': 2, 'User811': 2, 'User812': 2, 'User813': 2, 'User814': 2, 'User815': 2, 'User816': 2, 'User817': 2, 'User818': 2, 'User819': 2, 'User820': 2, 'User821': 2, 'User822': 2, 'User823': 2, 'User824': 2, 'User825': 2, 'User826': 2, 'User827': 2, 'User828': 2, 'User829': 2, 'User830': 2, 'User831': 2, 'User832': 2, 'User833': 2, 'User834': 2, 'User835': 2, 'User836': 2, 'User837': 2, 'User838': 2, 'User839': 2, 'User840': 2, 'User841': 2, 'User842': 2, 'User843': 2, 'User844': 2, 'User845': 2, 'User846': 2, 'User847': 2, 'User848': 2, 'User849': 2, 'User850': 2, 'User851': 2, 'User852': 2, 'User853': 2, 'User854': 2, 'User855': 2, 'User856': 2, 'User857': 2, 'User858': 2, 'User859': 2, 'User860': 2, 'User861': 2, 'User862': 2, 'User863': 2, 'User864': 2, 'User865': 2, 'User866': 2, 'User867': 2, 'User868': 2, 'User869': 2, 'User870': 2, 'User871': 2, 'User872': 2, 'User873': 2, 'User874': 2, 'User875': 2, 'User876': 2, 'User877': 2, 'User878': 2, 'User879': 2, 'User880': 2, 'User881': 2, 'User882': 2, 'User883': 2, 'User884': 2, 'User885': 2, 'User886': 2, 'User887': 2, 'User888': 2, 'User889': 2, 'User890': 2, 'User891': 2, 'User892': 2, 'User893': 2, 'User894': 2, 'User895': 2, 'User896': 2, 'User897': 2, 'User898': 2, 'User899': 2, 'User900': 2, 'User901': 2, 'User902': 2, 'User903': 2, 'User904': 2, 'User905': 2, 'User906': 2, 'User907': 2, 'User908': 2, 'User909': 2, 'User910': 2, 'User911': 2, 'User912': 2, 'User913': 2, 'User914': 2, 'User915': 2, 'User916': 2, 'User917': 2, 'User918': 2, 'User919': 2, 'User920': 2, 'User921': 2, 'User922': 2, 'User923': 2, 'User924': 2, 'User925': 2, 'User926': 2, 'User927': 2, 'User928': 2, 'User929': 2, 'User930': 2, 'User931': 2, 'User932': 2, 'User933': 2, 'User934': 2, 'User935': 2, 'User936': 2, 'User937': 2, 'User938': 2, 'User939': 2, 'User940': 2, 'User941': 2, 'User942': 2, 'User943': 2, 'User944': 2, 'User945': 2, 'User946': 2, 'User947': 2, 'User948': 2, 'User949': 2, 'User950': 2, 'User951': 2, 'User952': 2, 'User953': 2, 'User954': 2, 'User955': 2, 'User956': 2, 'User957': 2, 'User958': 2, 'User959': 2, 'User960': 2, 'User961': 2, 'User962': 2, 'User963': 2, 'User964': 2, 'User965': 2, 'User966': 2, 'User967': 2, 'User968': 2, 'User969': 2, 'User970': 2, 'User971': 2, 'User972': 2, 'User973': 2, 'User974': 2, 'User975': 2, 'User976': 2, 'User977': 2, 'User978': 2, 'User979': 2, 'User980': 2, 'User981': 2, 'User982': 2, 'User983': 2, 'User984': 2, 'User985': 2, 'User986': 2, 'User987': 2, 'User988': 2, 'User989': 2, 'User990': 2, 'User991': 2, 'User992': 2, 'User993': 2, 'User994': 2, 'User995': 2, 'User996': 2, 'User997': 2, 'User998': 2, 'User999': 2}\n    assert candidate([(\"Node1\", \"Node1\")]) == {'Node1': 2}\n    assert candidate([(\"One\", \"Two\"), (\"Two\", \"Three\"), (\"Three\", \"Four\")] * 100 + [(\"Isolated\", \"Node\")]) == {'One': 100, 'Two': 200, 'Three': 200, 'Four': 100, 'Isolated': 1, 'Node': 1}\n    assert candidate([(\"1\", \"2\"), (\"2\", \"3\"), (\"3\", \"4\"), (\"4\", \"5\"), (\"5\", \"1\")]) == {'1': 2, '2': 2, '3': 2, '4': 2, '5': 2}\n    assert candidate([(\"A\", \"B\"), (\"B\", \"C\"), (\"C\", \"D\"), (\"D\", \"E\"), (\"E\", \"A\"), (\"A\", \"C\"), (\"B\", \"D\"), (\"C\", \"E\")]) == {'A': 3, 'B': 3, 'C': 4, 'D': 3, 'E': 3}\n    assert candidate([(\"A\", \"B\"), (\"B\", \"A\"), (\"A\", \"B\"), (\"B\", \"A\")]) == {'A': 4, 'B': 4}\n    assert candidate([(\"1\", \"2\"), (\"2\", \"3\"), (\"3\", \"1\"), (\"1\", \"4\"), (\"2\", \"4\"), (\"3\", \"4\")]) == {'1': 3, '2': 3, '3': 3, '4': 3}\n    assert candidate([(chr(65+i), chr(65+j)) for i in range(26) for j in range(26) if i != j]) == {'A': 50, 'B': 50, 'C': 50, 'D': 50, 'E': 50, 'F': 50, 'G': 50, 'H': 50, 'I': 50, 'J': 50, 'K': 50, 'L': 50, 'M': 50, 'N': 50, 'O': 50, 'P': 50, 'Q': 50, 'R': 50, 'S': 50, 'T': 50, 'U': 50, 'V': 50, 'W': 50, 'X': 50, 'Y': 50, 'Z': 50}\n    assert candidate([(\"Hub\", f\"Spoke{i}\") for i in range(100)]) == {'Hub': 100, 'Spoke0': 1, 'Spoke1': 1, 'Spoke2': 1, 'Spoke3': 1, 'Spoke4': 1, 'Spoke5': 1, 'Spoke6': 1, 'Spoke7': 1, 'Spoke8': 1, 'Spoke9': 1, 'Spoke10': 1, 'Spoke11': 1, 'Spoke12': 1, 'Spoke13': 1, 'Spoke14': 1, 'Spoke15': 1, 'Spoke16': 1, 'Spoke17': 1, 'Spoke18': 1, 'Spoke19': 1, 'Spoke20': 1, 'Spoke21': 1, 'Spoke22': 1, 'Spoke23': 1, 'Spoke24': 1, 'Spoke25': 1, 'Spoke26': 1, 'Spoke27': 1, 'Spoke28': 1, 'Spoke29': 1, 'Spoke30': 1, 'Spoke31': 1, 'Spoke32': 1, 'Spoke33': 1, 'Spoke34': 1, 'Spoke35': 1, 'Spoke36': 1, 'Spoke37': 1, 'Spoke38': 1, 'Spoke39': 1, 'Spoke40': 1, 'Spoke41': 1, 'Spoke42': 1, 'Spoke43': 1, 'Spoke44': 1, 'Spoke45': 1, 'Spoke46': 1, 'Spoke47': 1, 'Spoke48': 1, 'Spoke49': 1, 'Spoke50': 1, 'Spoke51': 1, 'Spoke52': 1, 'Spoke53': 1, 'Spoke54': 1, 'Spoke55': 1, 'Spoke56': 1, 'Spoke57': 1, 'Spoke58': 1, 'Spoke59': 1, 'Spoke60': 1, 'Spoke61': 1, 'Spoke62': 1, 'Spoke63': 1, 'Spoke64': 1, 'Spoke65': 1, 'Spoke66': 1, 'Spoke67': 1, 'Spoke68': 1, 'Spoke69': 1, 'Spoke70': 1, 'Spoke71': 1, 'Spoke72': 1, 'Spoke73': 1, 'Spoke74': 1, 'Spoke75': 1, 'Spoke76': 1, 'Spoke77': 1, 'Spoke78': 1, 'Spoke79': 1, 'Spoke80': 1, 'Spoke81': 1, 'Spoke82': 1, 'Spoke83': 1, 'Spoke84': 1, 'Spoke85': 1, 'Spoke86': 1, 'Spoke87': 1, 'Spoke88': 1, 'Spoke89': 1, 'Spoke90': 1, 'Spoke91': 1, 'Spoke92': 1, 'Spoke93': 1, 'Spoke94': 1, 'Spoke95': 1, 'Spoke96': 1, 'Spoke97': 1, 'Spoke98': 1, 'Spoke99': 1}\n    assert candidate([(\"A\", \"B\")]) == {'A': 1, 'B': 1}\n", "language": "python"}
{"task_id": "4af45135-058c-4801-8a21-25c7783298b24055490748247926605", "prompt": "Kindly finish the function implementation as described in the docstring. Present the entire function in one code block, keeping the given function name and arguments intact.\n\n```python\nfrom datetime import datetime, timedelta\n\ndef next_friday_13th(date_str: str) -> str:\n    \"\"\"\n    As a superstitious event planner, you need to find the next Friday the 13th after a given date.\n    This function takes a date string in the format 'YYYY-MM-DD' and returns the date of the next\n    Friday the 13th in the same format.\n\n\n    [EXAMPLES]\n    \n    assert candidate('2024-09-13') == '2024-12-13'\n    assert candidate('2023-10-14') == '2024-09-13'\n\n    [/EXAMPLES]\n    \"\"\"\n```\n", "entry_point": "next_friday_13th", "solution": "from datetime import datetime, timedelta\n\ndef next_friday_13th(date_str: str) -> str:\n    \"\"\"\n    As a superstitious event planner, you need to find the next Friday the 13th after a given date.\n    This function takes a date string in the format 'YYYY-MM-DD' and returns the date of the next\n    Friday the 13th in the same format.\n\n\n    [EXAMPLES]\n    \n    assert candidate('2024-09-13') == '2024-12-13'\n    assert candidate('2023-10-14') == '2024-09-13'\n\n    [/EXAMPLES]\n    \"\"\"\n    # Convert the input string to a datetime object\n    current_date = datetime.strptime(date_str, '%Y-%m-%d')\n    \n    # If the current date is a Friday the 13th, start from the next day\n    if current_date.day == 13 and current_date.weekday() == 4:\n        current_date += timedelta(days=1)\n    \n    # Loop until we find the next Friday the 13th\n    while True:\n        # Move to the next 13th of the month\n        current_date = (current_date.replace(day=13) + timedelta(days=32)).replace(day=13)\n        \n        # Check if it's a Friday\n        if current_date.weekday() == 4:\n            return current_date.strftime('%Y-%m-%d')\n\n", "test": "def check(candidate):\n    assert candidate('2000-01-01') == '2000-10-13'\n    assert candidate('2023-12-31') == '2024-09-13'\n    assert candidate('2024-09-13') == '2024-12-13'\n    assert candidate('2024-09-14') == '2024-12-13'\n    assert candidate('2030-09-13') == '2030-12-13'\n    assert candidate('2099-12-31') == '2100-08-13'\n    assert candidate('2027-08-13') == '2028-10-13'\n    assert candidate('2023-10-14') == '2024-09-13'\n    assert candidate('2023-01-01') == '2023-10-13'\n    assert candidate('2024-01-01') == '2024-09-13'\n", "language": "python"}
{"task_id": "be9f7f25-4013-43e3-82d5-2e34c833b27f3478027440111086965", "prompt": "Develop the required function as a complete, executable unit within one code block. Do not include any code outside the function's boundaries. Limit yourself to using only the libraries specified in the problem. If necessary, define any helper functions or classes inside the main function.\n\n```python\nfrom typing import List, Dict\n\ndef decode_alien_message(message: str, codebook: Dict[str, str]) -> str:\n    \"\"\"An alien civilization has sent a coded message to Earth. Scientists have partially decrypted\n    their language and created a codebook. Your task is to write a function that decodes the alien message\n    using the provided codebook.\n\n    The message consists of alien words separated by spaces. Each alien word in the codebook is mapped to\n    an English word. If an alien word is not in the codebook, leave it as is in the decoded message.\n\n    Write a function that takes the alien message and codebook as input, and returns the decoded message.\n\n    Constraints:\n    - 1 <= len(message) <= 1000\n    - 1 <= len(codebook) <= 100\n    - All alien words consist of lowercase letters a-z\n    - The decoded message should maintain the original word order\n\n\n    [EXAMPLES]\n    \n    assert candidate(\"qux baz foo bar\", {\"foo\": \"the\", \"bar\": \"end\"}) == 'qux baz the end'\n    assert candidate(\"\", {}) == ''\n\n    [/EXAMPLES]\n    \"\"\"\n```\n", "entry_point": "decode_alien_message", "solution": "from typing import List, Dict\n\ndef decode_alien_message(message: str, codebook: Dict[str, str]) -> str:\n    \"\"\"An alien civilization has sent a coded message to Earth. Scientists have partially decrypted\n    their language and created a codebook. Your task is to write a function that decodes the alien message\n    using the provided codebook.\n\n    The message consists of alien words separated by spaces. Each alien word in the codebook is mapped to\n    an English word. If an alien word is not in the codebook, leave it as is in the decoded message.\n\n    Write a function that takes the alien message and codebook as input, and returns the decoded message.\n\n    Constraints:\n    - 1 <= len(message) <= 1000\n    - 1 <= len(codebook) <= 100\n    - All alien words consist of lowercase letters a-z\n    - The decoded message should maintain the original word order\n\n\n    [EXAMPLES]\n    \n    assert candidate(\"qux baz foo bar\", {\"foo\": \"the\", \"bar\": \"end\"}) == 'qux baz the end'\n    assert candidate(\"\", {}) == ''\n\n    [/EXAMPLES]\n    \"\"\"\n    # Split the message into individual words\n    alien_words = message.split()\n    \n    # Create a list to store the decoded words\n    decoded_words = []\n    \n    # Iterate through each alien word\n    for word in alien_words:\n        # If the word is in the codebook, use the decoded version\n        # Otherwise, keep the original word\n        decoded_word = codebook.get(word, word)\n        decoded_words.append(decoded_word)\n    \n    # Join the decoded words back into a single string\n    decoded_message = \" \".join(decoded_words)\n    \n    return decoded_message\n\n", "test": "def check(candidate):\n    assert candidate(\"a b c d e\", {\"a\": \"1\", \"b\": \"2\", \"c\": \"3\", \"d\": \"4\", \"e\": \"5\"}) == '1 2 3 4 5'\n    assert candidate(\"test test test\", {\"test\": \"example\"}) == 'example example example'\n    assert candidate(\"a b c d e f g h i j\", {chr(97+i): str(i) for i in range(10)}) == '0 1 2 3 4 5 6 7 8 9'\n    assert candidate(\"zork flup brap\", {\"zork\": \"hello\", \"brap\": \"world\"}) == 'hello flup world'\n    assert candidate(\"qux baz foo bar\", {\"foo\": \"the\", \"bar\": \"end\"}) == 'qux baz the end'\n    assert candidate(\"a\" * 1000, {\"a\": \"b\"}) == 'aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa'\n    assert candidate(\"abcdefghijklmnopqrstuvwxyz\", {\"a\": \"z\", \"z\": \"a\"}) == 'abcdefghijklmnopqrstuvwxyz'\n    assert candidate(\"\", {}) == ''\n    assert candidate(\"single\", {\"single\": \"multiple\"}) == 'multiple'\n    assert candidate(\"long message with many words\", {\"long\": \"short\", \"with\": \"without\", \"words\": \"letters\"}) == 'short message without many letters'\n", "language": "python"}
{"task_id": "f7ca2193-2fbf-45a5-aa87-ab97f3a5b6d0-2806618939148863047", "prompt": "Implement the remaining portions of the given code, ensuring all modifications are contained within one cohesive code segment.\n\n```python\nfrom typing import List, Tuple\n\ndef analyze_stock_trends(prices: List[int], k: int) -> List[Tuple[int, int]]:\n    \"\"\"\n    A financial analyst wants to identify significant price movements in a stock's historical data.\n    Given a list of daily closing prices and a threshold 'k', find all pairs of days where the price\n    difference is greater than or equal to 'k'.\n\n    Parameters:\n    prices (List[int]): A list of integers representing daily closing prices of a stock.\n    k (int): The threshold value for significant price movements.\n\n    Returns:\n    List[Tuple[int, int]]: A list of tuples, where each tuple contains two indices (i, j) such that\n                           prices[j] - prices[i] >= k and j > i.\n\n\n    [EXAMPLES]\n    \n    assert candidate([1, 2, 3, 4, 5], 1) == [(0, 1), (0, 2), (0, 3), (0, 4), (1, 2), (1, 3), (1, 4), (2, 3), (2, 4), (3, 4)]\n    assert candidate([10, 10, 10, 10, 10], 1) == []\n\n    [/EXAMPLES]\n    \"\"\"\n```\n", "entry_point": "analyze_stock_trends", "solution": "from typing import List, Tuple\n\ndef analyze_stock_trends(prices: List[int], k: int) -> List[Tuple[int, int]]:\n    \"\"\"\n    A financial analyst wants to identify significant price movements in a stock's historical data.\n    Given a list of daily closing prices and a threshold 'k', find all pairs of days where the price\n    difference is greater than or equal to 'k'.\n\n    Parameters:\n    prices (List[int]): A list of integers representing daily closing prices of a stock.\n    k (int): The threshold value for significant price movements.\n\n    Returns:\n    List[Tuple[int, int]]: A list of tuples, where each tuple contains two indices (i, j) such that\n                           prices[j] - prices[i] >= k and j > i.\n\n\n    [EXAMPLES]\n    \n    assert candidate([1, 2, 3, 4, 5], 1) == [(0, 1), (0, 2), (0, 3), (0, 4), (1, 2), (1, 3), (1, 4), (2, 3), (2, 4), (3, 4)]\n    assert candidate([10, 10, 10, 10, 10], 1) == []\n\n    [/EXAMPLES]\n    \"\"\"\n    result = []\n    n = len(prices)\n    \n    for i in range(n):\n        for j in range(i + 1, n):\n            if prices[j] - prices[i] >= k:\n                result.append((i, j))\n    \n    return result\n\n", "test": "def check(candidate):\n    assert candidate([1, 10, 100, 1000, 10000], 9000) == [(0, 4), (1, 4), (2, 4), (3, 4)]\n    assert candidate([100, 105, 110, 115, 120], 15) == [(0, 3), (0, 4), (1, 4)]\n    assert candidate([10, 20, 30, 40, 50, 60, 70, 80, 90, 100], 50) == [(0, 5), (0, 6), (0, 7), (0, 8), (0, 9), (1, 6), (1, 7), (1, 8), (1, 9), (2, 7), (2, 8), (2, 9), (3, 8), (3, 9), (4, 9)]\n    assert candidate([20, 19, 18, 17, 16, 15, 14, 13, 12, 11], 5) == []\n    assert candidate([10000, 1000, 100, 10, 1], 9000) == []\n    assert candidate([10, 10, 10, 10, 10], 1) == []\n    assert candidate([1, 2, 3, 4, 5], 1) == [(0, 1), (0, 2), (0, 3), (0, 4), (1, 2), (1, 3), (1, 4), (2, 3), (2, 4), (3, 4)]\n    assert candidate([60, 70, 80, 90, 100], 10) == [(0, 1), (0, 2), (0, 3), (0, 4), (1, 2), (1, 3), (1, 4), (2, 3), (2, 4), (3, 4)]\n", "language": "python"}
{"task_id": "395dea9e-8e6c-44f8-99a0-8893146abfbd4717850676424529089", "prompt": "Finish the subsequent programming segment in a single, cohesive block of code.\n\n```python\ndef calculate_asteroid_impact(mass: float, velocity: float) -> float:\n    \"\"\"\n    As part of a planetary defense system, scientists need to estimate the potential energy released\n    by an asteroid impact. This function calculates the kinetic energy of an asteroid based on its\n    mass (in kilograms) and velocity (in meters per second).\n\n    The kinetic energy is calculated using the formula: E = 0.5 * m * v^2\n    where E is energy in joules, m is mass in kg, and v is velocity in m/s.\n\n    The function returns the energy in megatons of TNT, where 1 megaton = 4.184 * 10^15 joules.\n\n\n    [EXAMPLES]\n    \n    assert candidate(100000, 30000) == 0.010755258126195029\n    assert candidate(6.022e23, 1e-10) == 7.196462715105164e-13\n\n    [/EXAMPLES]\n    \"\"\"\n```\n", "entry_point": "calculate_asteroid_impact", "solution": "def calculate_asteroid_impact(mass: float, velocity: float) -> float:\n    \"\"\"\n    As part of a planetary defense system, scientists need to estimate the potential energy released\n    by an asteroid impact. This function calculates the kinetic energy of an asteroid based on its\n    mass (in kilograms) and velocity (in meters per second).\n\n    The kinetic energy is calculated using the formula: E = 0.5 * m * v^2\n    where E is energy in joules, m is mass in kg, and v is velocity in m/s.\n\n    The function returns the energy in megatons of TNT, where 1 megaton = 4.184 * 10^15 joules.\n\n\n    [EXAMPLES]\n    \n    assert candidate(100000, 30000) == 0.010755258126195029\n    assert candidate(6.022e23, 1e-10) == 7.196462715105164e-13\n\n    [/EXAMPLES]\n    \"\"\"\n    # Calculate kinetic energy in joules\n    kinetic_energy = 0.5 * mass * (velocity ** 2)\n    \n    # Convert joules to megatons of TNT\n    megaton_tnt = 4.184 * (10 ** 15)  # joules in 1 megaton of TNT\n    energy_in_megatons = kinetic_energy / megaton_tnt\n    \n    return energy_in_megatons\n\n", "test": "def check(candidate):\n    assert candidate(1000000000, 1000) == 0.11950286806883365\n    assert candidate(1e12, 100) == 1.1950286806883366\n    assert candidate(1e9, 1e-3) == 1.1950286806883366e-13\n    assert candidate(1e-6, 1e6) == 1.1950286806883366e-10\n    assert candidate(6.022e23, 1e-10) == 7.196462715105164e-13\n    assert candidate(1e-12, 1e12) == 0.00011950286806883365\n    assert candidate(100000, 30000) == 0.010755258126195029\n    assert candidate(1000000, 20000) == 0.04780114722753346\n    assert candidate(5000000, 15000) == 0.13444072657743786\n    assert candidate(1, 1000) == 1.1950286806883366e-10\n", "language": "python"}
{"task_id": "a62e2364-e426-4910-9a46-ecbd1d2bfa29-3561255969089562446", "prompt": "Please complete the function implementation based on the provided documentation string. Present the entire function within a single code block.\n\n```python\ndef decrypt_message(encrypted: str, key: int) -> str:\n    \"\"\"You are a cryptographer working for a secret agency. You've intercepted an encrypted message\n    and you need to decrypt it using a special algorithm. The encryption method used is a variant\n    of the Caesar cipher, where each letter in the original message has been shifted forward in the\n    alphabet by a certain number of positions (the key).\n\n    Your task is to write a function that takes the encrypted message and the key as input, and\n    returns the decrypted message. The message may contain uppercase letters, lowercase letters,\n    numbers, and special characters. Only letters should be shifted, and they should wrap around\n    the alphabet if necessary (e.g., 'Z' shifted by 1 becomes 'A').\n\n\n    [EXAMPLES]\n    \n    assert candidate(\"xyz\", 1) == 'wxy'\n    assert candidate(\"Fdhvdu flskhu lv qrw vhfxuh\", 3) == 'Caesar cipher is not secure'\n\n    [/EXAMPLES]\n    \"\"\"\n```\n", "entry_point": "decrypt_message", "solution": "def decrypt_message(encrypted: str, key: int) -> str:\n    \"\"\"You are a cryptographer working for a secret agency. You've intercepted an encrypted message\n    and you need to decrypt it using a special algorithm. The encryption method used is a variant\n    of the Caesar cipher, where each letter in the original message has been shifted forward in the\n    alphabet by a certain number of positions (the key).\n\n    Your task is to write a function that takes the encrypted message and the key as input, and\n    returns the decrypted message. The message may contain uppercase letters, lowercase letters,\n    numbers, and special characters. Only letters should be shifted, and they should wrap around\n    the alphabet if necessary (e.g., 'Z' shifted by 1 becomes 'A').\n\n\n    [EXAMPLES]\n    \n    assert candidate(\"xyz\", 1) == 'wxy'\n    assert candidate(\"Fdhvdu flskhu lv qrw vhfxuh\", 3) == 'Caesar cipher is not secure'\n\n    [/EXAMPLES]\n    \"\"\"\n    def shift_char(char: str, shift: int) -> str:\n        if char.isalpha():\n            # Determine the ASCII offset based on whether it's uppercase or lowercase\n            offset = ord('A') if char.isupper() else ord('a')\n            # Shift the character and wrap around the alphabet\n            return chr((ord(char) - offset - shift) % 26 + offset)\n        else:\n            # Return non-alphabetic characters unchanged\n            return char\n\n    # Create the decrypted message by shifting each character\n    decrypted = ''.join(shift_char(char, key) for char in encrypted)\n    return decrypted\n\n", "test": "def check(candidate):\n    assert candidate(\"Khoor, Zruog!\", 3) == 'Hello, World!'\n    assert candidate(\"ABC\", 1) == 'ZAB'\n    assert candidate(\"Vjku ku c vguv oguucig.\", 2) == 'This is a test message.'\n    assert candidate(\"Xli Uymgo Fvsar Jsb Nyqtw Sziv xli Pedc Hsk\", 4) == 'The Quick Brown Fox Jumps Over the Lazy Dog'\n    assert candidate(\"xyz\", 1) == 'wxy'\n    assert candidate(\"Qrstqburwdwlrq lv ixq!\", 3) == 'Nopqnyrotation is fun!'\n    assert candidate(\"!@#$%^&*()_+\", 15) == '!@#$%^&*()_+'\n    assert candidate(\"Fdhvdu flskhu lv qrw vhfxuh\", 3) == 'Caesar cipher is not secure'\n    assert candidate(\"AaZz\", 25) == 'BbAa'\n    assert candidate(\"Hello, World!\", 0) == 'Hello, World!'\n", "language": "python"}
{"task_id": "4d22d5d8-2d5b-4026-ac95-f1fbf8eb0d2a-9115809065061596545", "prompt": "To fulfill your requirements, I'll create a function that is entirely self-sufficient and can be executed independently. This function will include all necessary components within its scope, such as any helper functions or classes it may need. I'll strictly adhere to using only the libraries mentioned in the problem statement. The output will be a single, cohesive code block that encompasses the complete function, ready for immediate use without any external dependencies or modifications.\n\n```python\ndef analyze_text_sentiment(text: str) -> str:\n    \"\"\"\n    As a natural language processing researcher, you're developing a basic sentiment analysis tool\n    for social media posts. Your task is to categorize the overall sentiment of a given text as\n    positive, negative, or neutral.\n\n    This function takes a string of text as input and returns a string indicating the overall\n    sentiment: \"positive\", \"negative\", or \"neutral\". The sentiment is determined by counting the\n    number of positive and negative words in the text.\n\n    Use the following lists of positive and negative words for this analysis:\n    positive_words = [\"good\", \"great\", \"excellent\", \"amazing\", \"wonderful\", \"fantastic\", \"happy\"]\n    negative_words = [\"bad\", \"terrible\", \"awful\", \"horrible\", \"disappointing\", \"sad\", \"angry\"]\n\n    If there are more positive words, return \"positive\". If there are more negative words,\n    return \"negative\". If the counts are equal or there are no sentiment words, return \"neutral\".\n\n\n    [EXAMPLES]\n    \n    assert candidate(\"Excellent service and fantastic results!\") == 'positive'\n    assert candidate(\"GOOD BAD GOOD BAD GOOD BAD GOOD\") == 'positive'\n\n    [/EXAMPLES]\n    \"\"\"\n```\n", "entry_point": "analyze_text_sentiment", "solution": "def analyze_text_sentiment(text: str) -> str:\n    \"\"\"\n    As a natural language processing researcher, you're developing a basic sentiment analysis tool\n    for social media posts. Your task is to categorize the overall sentiment of a given text as\n    positive, negative, or neutral.\n\n    This function takes a string of text as input and returns a string indicating the overall\n    sentiment: \"positive\", \"negative\", or \"neutral\". The sentiment is determined by counting the\n    number of positive and negative words in the text.\n\n    Use the following lists of positive and negative words for this analysis:\n    positive_words = [\"good\", \"great\", \"excellent\", \"amazing\", \"wonderful\", \"fantastic\", \"happy\"]\n    negative_words = [\"bad\", \"terrible\", \"awful\", \"horrible\", \"disappointing\", \"sad\", \"angry\"]\n\n    If there are more positive words, return \"positive\". If there are more negative words,\n    return \"negative\". If the counts are equal or there are no sentiment words, return \"neutral\".\n\n\n    [EXAMPLES]\n    \n    assert candidate(\"Excellent service and fantastic results!\") == 'positive'\n    assert candidate(\"GOOD BAD GOOD BAD GOOD BAD GOOD\") == 'positive'\n\n    [/EXAMPLES]\n    \"\"\"\n    positive_words = [\"good\", \"great\", \"excellent\", \"amazing\", \"wonderful\", \"fantastic\", \"happy\"]\n    negative_words = [\"bad\", \"terrible\", \"awful\", \"horrible\", \"disappointing\", \"sad\", \"angry\"]\n    \n    # Convert the text to lowercase for case-insensitive matching\n    text = text.lower()\n    \n    # Split the text into words\n    words = text.split()\n    \n    # Count positive and negative words\n    positive_count = sum(1 for word in words if word in positive_words)\n    negative_count = sum(1 for word in words if word in negative_words)\n    \n    # Determine the sentiment based on the counts\n    if positive_count > negative_count:\n        return \"positive\"\n    elif negative_count > positive_count:\n        return \"negative\"\n    else:\n        return \"neutral\"\n\n", "test": "def check(candidate):\n    assert candidate(\"\") == 'neutral'\n    assert candidate(\"This experience was awful and horrible.\") == 'negative'\n    assert candidate(\"I feel happy and wonderful today!\") == 'positive'\n    assert candidate(\"GOOD BAD GOOD BAD GOOD BAD GOOD\") == 'positive'\n    assert candidate(\"I'm feeling rather neutral about this whole situation.\") == 'neutral'\n    assert candidate(\"The movie was terrible and disappointing. What a waste of time.\") == 'negative'\n    assert candidate(\"HAPPY HAPPY SAD SAD ANGRY ANGRY\") == 'negative'\n    assert candidate(\"The product is neither good nor bad.\") == 'positive'\n    assert candidate(\"Not great, not terrible, just average.\") == 'neutral'\n    assert candidate(\"Excellent service and fantastic results!\") == 'positive'\n", "language": "python"}
{"task_id": "cc7b20df-2b1f-4215-8848-a4fa73f0b280-5451913322178929498", "prompt": "Complete the specified function so it can be executed as-is in a single code block. Do not add any code outside the function's scope. Use only the libraries that are imported in the problem description. If necessary, define additional functions or classes, but do so only within the given function. Output your solution as one cohesive code block.\n\n```python\nfrom typing import List, Tuple\n\ndef optimize_delivery_route(packages: List[Tuple[int, int, int]], max_weight: int, max_volume: int) -> List[int]:\n    \"\"\"\n    A delivery company wants to optimize their route by selecting the most valuable packages.\n    Each package is represented by a tuple (value, weight, volume).\n    The delivery truck has a maximum weight and volume capacity.\n    Implement an algorithm to select packages that maximize the total value while respecting the weight and volume constraints.\n    Return a list of indices representing the selected packages.\n\n\n    [EXAMPLES]\n    \n    assert candidate([(1, 1, 1), (2, 2, 2), (3, 3, 3), (4, 4, 4), (5, 5, 5)], 10, 10) == [0, 1, 2, 3]\n    assert candidate([(100, 1, 1), (1, 100, 1), (1, 1, 100)], 50, 50) == [0]\n\n    [/EXAMPLES]\n    \"\"\"\n```\n", "entry_point": "optimize_delivery_route", "solution": "from typing import List, Tuple\n\ndef optimize_delivery_route(packages: List[Tuple[int, int, int]], max_weight: int, max_volume: int) -> List[int]:\n    \"\"\"\n    A delivery company wants to optimize their route by selecting the most valuable packages.\n    Each package is represented by a tuple (value, weight, volume).\n    The delivery truck has a maximum weight and volume capacity.\n    Implement an algorithm to select packages that maximize the total value while respecting the weight and volume constraints.\n    Return a list of indices representing the selected packages.\n\n\n    [EXAMPLES]\n    \n    assert candidate([(1, 1, 1), (2, 2, 2), (3, 3, 3), (4, 4, 4), (5, 5, 5)], 10, 10) == [0, 1, 2, 3]\n    assert candidate([(100, 1, 1), (1, 100, 1), (1, 1, 100)], 50, 50) == [0]\n\n    [/EXAMPLES]\n    \"\"\"\n    n = len(packages)\n    \n    # Create a 3D DP table\n    dp = [[[0 for _ in range(max_volume + 1)] for _ in range(max_weight + 1)] for _ in range(n + 1)]\n    \n    # Fill the DP table\n    for i in range(1, n + 1):\n        value, weight, volume = packages[i-1]\n        for w in range(max_weight + 1):\n            for v in range(max_volume + 1):\n                if weight <= w and volume <= v:\n                    dp[i][w][v] = max(dp[i-1][w][v], dp[i-1][w-weight][v-volume] + value)\n                else:\n                    dp[i][w][v] = dp[i-1][w][v]\n    \n    # Backtrack to find the selected packages\n    selected = []\n    w, v = max_weight, max_volume\n    for i in range(n, 0, -1):\n        if dp[i][w][v] != dp[i-1][w][v]:\n            selected.append(i-1)\n            value, weight, volume = packages[i-1]\n            w -= weight\n            v -= volume\n    \n    # Reverse the list to get the correct order\n    selected.reverse()\n    \n    return selected\n\n", "test": "def check(candidate):\n    assert candidate([], 10, 10) == []\n    assert candidate([(50, 10, 5), (40, 8, 4), (30, 6, 3), (20, 4, 2), (10, 2, 1)], 25, 15) == [0, 1, 2]\n    assert candidate([(i, i, i) for i in range(1, 6)], 10, 10) == [0, 1, 2, 3]\n    assert candidate([(1, 1, 1)] * 5 + [(10, 5, 5)], 10, 10) == [0, 1, 2, 3, 4, 5]\n    assert candidate([(5, 2, 1), (10, 4, 2), (15, 6, 3), (20, 8, 4), (25, 10, 5)], 20, 10) == [0, 1, 2, 3]\n    assert candidate([(1, 1, 1), (2, 2, 2), (3, 3, 3), (4, 4, 4), (5, 5, 5)], 10, 10) == [0, 1, 2, 3]\n    assert candidate([(10, 1, 5), (20, 2, 4), (30, 3, 3), (40, 4, 2), (50, 5, 1)], 15, 15) == [0, 1, 2, 3, 4]\n    assert candidate([(100, 1, 1), (1, 100, 1), (1, 1, 100)], 50, 50) == [0]\n    assert candidate([(5, 1, 1), (4, 1, 1), (3, 1, 1), (2, 1, 1), (1, 1, 1)], 3, 3) == [0, 1, 2]\n    assert candidate([(100, 1, 10), (100, 10, 1), (50, 5, 5)], 11, 11) == [0, 1]\n", "language": "python"}
{"task_id": "73b1b7e5-90fd-4966-b3db-dea364eb75ef966545523452688979", "prompt": "Within a code block, implement the function as specified in the docstring. Adhere to the guidelines provided in the documentation. Any supplementary functions or classes should be defined solely within the scope of the given function.\n\n```python\ndef analyze_text_sentiment(text: str) -> dict:\n    \"\"\"\n    Analyze the sentiment of a given text using a simple lexicon-based approach.\n\n    This function takes a text input and performs sentiment analysis by counting\n    the occurrences of positive and negative words from a predefined lexicon.\n    It then calculates a sentiment score and determines the overall sentiment\n    (positive, negative, or neutral) based on this score.\n\n    Args:\n        text (str): The input text to analyze.\n\n    Returns:\n        dict: A dictionary containing the sentiment analysis results, including\n              the sentiment score, sentiment label, and word counts.\n\n\n    [EXAMPLES]\n    \n    assert candidate(\"Short.\") == {'score': 0, 'sentiment': 'neutral', 'positive_words': 0, 'negative_words': 0}\n    assert candidate(\"good bad good bad good bad\") == {'score': 0, 'sentiment': 'neutral', 'positive_words': 3, 'negative_words': 3}\n\n    [/EXAMPLES]\n    \"\"\"\n```\n", "entry_point": "analyze_text_sentiment", "solution": "def analyze_text_sentiment(text: str) -> dict:\n    \"\"\"\n    Analyze the sentiment of a given text using a simple lexicon-based approach.\n\n    This function takes a text input and performs sentiment analysis by counting\n    the occurrences of positive and negative words from a predefined lexicon.\n    It then calculates a sentiment score and determines the overall sentiment\n    (positive, negative, or neutral) based on this score.\n\n    Args:\n        text (str): The input text to analyze.\n\n    Returns:\n        dict: A dictionary containing the sentiment analysis results, including\n              the sentiment score, sentiment label, and word counts.\n\n\n    [EXAMPLES]\n    \n    assert candidate(\"Short.\") == {'score': 0, 'sentiment': 'neutral', 'positive_words': 0, 'negative_words': 0}\n    assert candidate(\"good bad good bad good bad\") == {'score': 0, 'sentiment': 'neutral', 'positive_words': 3, 'negative_words': 3}\n\n    [/EXAMPLES]\n    \"\"\"\n    # Define simple lexicons for positive and negative words\n    positive_words = set(['good', 'great', 'excellent', 'amazing', 'wonderful', 'fantastic', 'love', 'like', 'happy', 'best'])\n    negative_words = set(['bad', 'terrible', 'awful', 'horrible', 'poor', 'worst', 'hate', 'dislike', 'disappointed', 'unfortunate'])\n\n    # Convert text to lowercase and split into words\n    words = text.lower().split()\n\n    # Count occurrences of positive and negative words\n    positive_count = sum(1 for word in words if word in positive_words)\n    negative_count = sum(1 for word in words if word in negative_words)\n\n    # Calculate sentiment score\n    sentiment_score = positive_count - negative_count\n\n    # Determine sentiment label\n    if sentiment_score > 0:\n        sentiment = 'positive'\n    elif sentiment_score < 0:\n        sentiment = 'negative'\n    else:\n        sentiment = 'neutral'\n\n    # Prepare and return the result\n    return {\n        'score': sentiment_score,\n        'sentiment': sentiment,\n        'positive_words': positive_count,\n        'negative_words': negative_count\n    }\n\n", "test": "def check(candidate):\n    assert candidate(\"Extremely long text \" + \"with minimal sentiment \" * 100) == {'score': 0, 'sentiment': 'neutral', 'positive_words': 0, 'negative_words': 0}\n    assert candidate(\"Neutral statement without sentiment.\") == {'score': 0, 'sentiment': 'neutral', 'positive_words': 0, 'negative_words': 0}\n    assert candidate(\"Short.\") == {'score': 0, 'sentiment': 'neutral', 'positive_words': 0, 'negative_words': 0}\n    assert candidate(\"good bad good bad good bad\") == {'score': 0, 'sentiment': 'neutral', 'positive_words': 3, 'negative_words': 3}\n    assert candidate(\"This is a terrible experience. I'm very disappointed.\") == {'score': -1, 'sentiment': 'negative', 'positive_words': 0, 'negative_words': 1}\n    assert candidate(\"a\" * 1000) == {'score': 0, 'sentiment': 'neutral', 'positive_words': 0, 'negative_words': 0}\n    assert candidate(\"lowercase text with sentiment: awful experience\") == {'score': -1, 'sentiment': 'negative', 'positive_words': 0, 'negative_words': 1}\n    assert candidate(\"Repetitive word: love love love love love\") == {'score': 5, 'sentiment': 'positive', 'positive_words': 5, 'negative_words': 0}\n    assert candidate(\"Numbers123 don't 456 affect 789 sentiment.\") == {'score': 0, 'sentiment': 'neutral', 'positive_words': 0, 'negative_words': 0}\n    assert candidate(\"UPPERCASE TEXT WITH SENTIMENT: GREAT PRODUCT!\") == {'score': 1, 'sentiment': 'positive', 'positive_words': 1, 'negative_words': 0}\n", "language": "python"}
{"task_id": "6d170f66-47c6-4c2f-a805-fdd0067a77755624722970808385555", "prompt": "Compose the entire code solution in a single, uninterrupted block.\n\n```python\nfrom collections import defaultdict\nfrom typing import List\n\ndef anagram_groups(words: List[str]) -> List[List[str]]:\n    \"\"\"\n    In a linguistic study, researchers want to group words that are anagrams of each other.\n    This function takes a list of words and returns groups of anagrams.\n\n\n    [EXAMPLES]\n    \n    assert candidate([]) == []\n    assert candidate([\"apple\", \"banana\", \"cherry\", \"date\"]) == [['apple'], ['banana'], ['cherry'], ['date']]\n\n    [/EXAMPLES]\n    \"\"\"\n```\n", "entry_point": "anagram_groups", "solution": "from collections import defaultdict\nfrom typing import List\n\ndef anagram_groups(words: List[str]) -> List[List[str]]:\n    \"\"\"\n    In a linguistic study, researchers want to group words that are anagrams of each other.\n    This function takes a list of words and returns groups of anagrams.\n\n\n    [EXAMPLES]\n    \n    assert candidate([]) == []\n    assert candidate([\"apple\", \"banana\", \"cherry\", \"date\"]) == [['apple'], ['banana'], ['cherry'], ['date']]\n\n    [/EXAMPLES]\n    \"\"\"\n    def sort_string(s: str) -> str:\n        return ''.join(sorted(s))\n    \n    anagram_dict = defaultdict(list)\n    \n    for word in words:\n        sorted_word = sort_string(word)\n        anagram_dict[sorted_word].append(word)\n    \n    return list(anagram_dict.values())\n\n", "test": "def check(candidate):\n    assert candidate([\"race\", \"care\", \"acre\", \"listen\", \"silent\"]) == [['race', 'care', 'acre'], ['listen', 'silent']]\n    assert candidate([\"anagram\", \"nagaram\", \"not\", \"ton\"]) == [['anagram', 'nagaram'], ['not', 'ton']]\n    assert candidate([\"abc\", \"cab\", \"bca\", \"bac\", \"acb\"]) == [['abc', 'cab', 'bca', 'bac', 'acb']]\n    assert candidate([\"cat\", \"dog\", \"act\", \"god\"]) == [['cat', 'act'], ['dog', 'god']]\n    assert candidate([\"z\" * 100, \"z\" * 100]) == [['zzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzz', 'zzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzz']]\n    assert candidate([\"aaaaaa\", \"aaaaa\"]) == [['aaaaaa'], ['aaaaa']]\n    assert candidate([\"listen\", \"silent\", \"enlist\"]) == [['listen', 'silent', 'enlist']]\n    assert candidate([]) == []\n    assert candidate([\"apple\", \"banana\", \"cherry\", \"date\"]) == [['apple'], ['banana'], ['cherry'], ['date']]\n    assert candidate([\"abc\", \"def\", \"ghi\", \"jkl\"]) == [['abc'], ['def'], ['ghi'], ['jkl']]\n", "language": "python"}
{"task_id": "fa3dc738-ea39-46fb-b814-117f1cdc251b-8058409771405057478", "prompt": "Your objective is to fill in the details of the specified function, ensuring it's self-contained and executable within one code block. Refrain from including any code external to the function. Stick to using only the libraries mentioned in the problem setup. Any additional functions or classes should be nested within the main function. Present your solution as a single code block.\n\n```python\nfrom typing import List, Tuple\n\ndef optimize_study_schedule(subjects: List[str], difficulties: List[int], available_time: int) -> Tuple[List[str], int]:\n    \"\"\"You are a student preparing for exams and want to optimize your study schedule. You have a list of subjects\n    and their corresponding difficulties (measured in study hours). You also have a limited amount of available\n    study time. Your goal is to maximize the number of subjects you can fully study within the available time.\n\n    Write a function that takes three parameters:\n    1. A list of subject names\n    2. A list of corresponding difficulties (in hours)\n    3. The total available study time (in hours)\n\n    The function should return a tuple containing:\n    1. A list of subjects that can be fully studied within the available time\n    2. The total difficulty (in hours) of the selected subjects\n\n    If multiple combinations of subjects are possible, choose the one with the highest total difficulty.\n\n\n    [EXAMPLES]\n    \n    assert candidate([\"A\", \"B\", \"C\", \"D\", \"E\"], [100, 200, 300, 400, 500], 1000) == (['A', 'B', 'C', 'D'], 1000)\n    assert candidate([\"Calculus\", \"Algebra\", \"Geometry\", \"Trigonometry\"], [5, 3, 4, 2], 8) == (['Calculus', 'Algebra'], 8)\n\n    [/EXAMPLES]\n    \"\"\"\n```\n", "entry_point": "optimize_study_schedule", "solution": "from typing import List, Tuple\n\ndef optimize_study_schedule(subjects: List[str], difficulties: List[int], available_time: int) -> Tuple[List[str], int]:\n    \"\"\"You are a student preparing for exams and want to optimize your study schedule. You have a list of subjects\n    and their corresponding difficulties (measured in study hours). You also have a limited amount of available\n    study time. Your goal is to maximize the number of subjects you can fully study within the available time.\n\n    Write a function that takes three parameters:\n    1. A list of subject names\n    2. A list of corresponding difficulties (in hours)\n    3. The total available study time (in hours)\n\n    The function should return a tuple containing:\n    1. A list of subjects that can be fully studied within the available time\n    2. The total difficulty (in hours) of the selected subjects\n\n    If multiple combinations of subjects are possible, choose the one with the highest total difficulty.\n\n\n    [EXAMPLES]\n    \n    assert candidate([\"A\", \"B\", \"C\", \"D\", \"E\"], [100, 200, 300, 400, 500], 1000) == (['A', 'B', 'C', 'D'], 1000)\n    assert candidate([\"Calculus\", \"Algebra\", \"Geometry\", \"Trigonometry\"], [5, 3, 4, 2], 8) == (['Calculus', 'Algebra'], 8)\n\n    [/EXAMPLES]\n    \"\"\"\n    n = len(subjects)\n    \n    # Create a 2D table for dynamic programming\n    dp = [[0] * (available_time + 1) for _ in range(n + 1)]\n    \n    # Fill the dp table\n    for i in range(1, n + 1):\n        for j in range(available_time + 1):\n            if difficulties[i-1] <= j:\n                dp[i][j] = max(dp[i-1][j], dp[i-1][j-difficulties[i-1]] + difficulties[i-1])\n            else:\n                dp[i][j] = dp[i-1][j]\n    \n    # Backtrack to find the selected subjects\n    selected_subjects = []\n    total_difficulty = dp[n][available_time]\n    j = available_time\n    \n    for i in range(n, 0, -1):\n        if dp[i][j] != dp[i-1][j]:\n            selected_subjects.append(subjects[i-1])\n            j -= difficulties[i-1]\n    \n    # Reverse the list to get the correct order\n    selected_subjects.reverse()\n    \n    return (selected_subjects, total_difficulty)\n\n", "test": "def check(candidate):\n    assert candidate([\"Subject\"], [0], 5) == ([], 0)\n    assert candidate([\"Math\", \"Physics\", \"Chemistry\", \"Biology\"], [4, 3, 5, 2], 10) == (['Physics', 'Chemistry', 'Biology'], 10)\n    assert candidate([], [], 10) == ([], 0)\n    assert candidate([\"X\", \"Y\", \"Z\"], [10, 20, 30], 50) == (['Y', 'Z'], 50)\n    assert candidate([\"A\", \"B\", \"C\", \"D\", \"E\"], [100, 200, 300, 400, 500], 1000) == (['A', 'B', 'C', 'D'], 1000)\n    assert candidate([\"Physics\", \"Chemistry\", \"Biology\", \"Math\", \"History\"], [8, 6, 7, 5, 4], 15) == (['Physics', 'Biology'], 15)\n    assert candidate([\"A\", \"B\", \"C\", \"D\", \"E\", \"F\", \"G\", \"H\", \"I\", \"J\"], [1, 1, 1, 1, 1, 1, 1, 1, 1, 1], 5) == (['A', 'B', 'C', 'D', 'E'], 5)\n    assert candidate([\"Calculus\", \"Algebra\", \"Geometry\", \"Trigonometry\"], [5, 3, 4, 2], 8) == (['Calculus', 'Algebra'], 8)\n    assert candidate([\"P\", \"Q\", \"R\", \"S\", \"T\"], [5, 5, 5, 5, 5], 20) == (['P', 'Q', 'R', 'S'], 20)\n    assert candidate([\"Subject1\", \"Subject2\", \"Subject3\", \"Subject4\", \"Subject5\"], [3, 2, 4, 1, 5], 7) == (['Subject1', 'Subject3'], 7)\n", "language": "python"}
{"task_id": "88e68f1e-f024-4997-82bb-541910055db6-2637674510097755646", "prompt": "Implement the specified function to ensure it can be executed as a standalone code block. Refrain from including any code outside the function's scope. Utilize only the libraries that are imported in the problem statement. Any additional functions or classes should be defined within the given function. Provide your response as a single, cohesive code block.\n\n```python\nfrom typing import List, Tuple\n\ndef optimize_warehouse_layout(items: List[Tuple[str, int, int]]) -> List[str]:\n    \"\"\"\n    Optimize the layout of a warehouse based on item popularity and size.\n\n    This function takes a list of items, where each item is represented by a tuple\n    containing the item name, its popularity score, and its size. The function then\n    determines the optimal arrangement of items in the warehouse to minimize\n    retrieval time and maximize space efficiency.\n\n    The optimization algorithm uses a combination of sorting and list manipulation\n    to achieve the desired layout.\n\n    Args:\n    items (List[Tuple[str, int, int]]): A list of tuples, each containing\n        (item_name, popularity_score, size).\n\n    Returns:\n    List[str]: A list of item names in their optimal arrangement.\n\n\n    [EXAMPLES]\n    \n    assert candidate([('Tennis Ball', 9, 1), ('Basketball', 7, 5), ('Soccer Ball', 8, 3), ('Baseball', 6, 1)]) == ['Tennis Ball', 'Baseball', 'Soccer Ball', 'Basketball']\n    assert candidate([('Sock', 8, 1), ('T-shirt', 12, 2), ('Jeans', 10, 4), ('Sweater', 6, 3), ('Coat', 4, 5)]) == ['Sock', 'T-shirt', 'Jeans', 'Sweater', 'Coat']\n\n    [/EXAMPLES]\n    \"\"\"\n```\n", "entry_point": "optimize_warehouse_layout", "solution": "from typing import List, Tuple\n\ndef optimize_warehouse_layout(items: List[Tuple[str, int, int]]) -> List[str]:\n    \"\"\"\n    Optimize the layout of a warehouse based on item popularity and size.\n\n    This function takes a list of items, where each item is represented by a tuple\n    containing the item name, its popularity score, and its size. The function then\n    determines the optimal arrangement of items in the warehouse to minimize\n    retrieval time and maximize space efficiency.\n\n    The optimization algorithm uses a combination of sorting and list manipulation\n    to achieve the desired layout.\n\n    Args:\n    items (List[Tuple[str, int, int]]): A list of tuples, each containing\n        (item_name, popularity_score, size).\n\n    Returns:\n    List[str]: A list of item names in their optimal arrangement.\n\n\n    [EXAMPLES]\n    \n    assert candidate([('Tennis Ball', 9, 1), ('Basketball', 7, 5), ('Soccer Ball', 8, 3), ('Baseball', 6, 1)]) == ['Tennis Ball', 'Baseball', 'Soccer Ball', 'Basketball']\n    assert candidate([('Sock', 8, 1), ('T-shirt', 12, 2), ('Jeans', 10, 4), ('Sweater', 6, 3), ('Coat', 4, 5)]) == ['Sock', 'T-shirt', 'Jeans', 'Sweater', 'Coat']\n\n    [/EXAMPLES]\n    \"\"\"\n    def calculate_priority(item: Tuple[str, int, int]) -> float:\n        \"\"\"Calculate priority score for an item based on popularity and size.\"\"\"\n        _, popularity, size = item\n        return popularity / size\n\n    # Sort items based on priority score (descending order)\n    sorted_items = sorted(items, key=calculate_priority, reverse=True)\n\n    # Extract item names from sorted list\n    optimized_layout = [item[0] for item in sorted_items]\n\n    return optimized_layout\n\n", "test": "def check(candidate):\n    assert candidate([('Sock', 8, 1), ('T-shirt', 12, 2), ('Jeans', 10, 4), ('Sweater', 6, 3), ('Coat', 4, 5)]) == ['Sock', 'T-shirt', 'Jeans', 'Sweater', 'Coat']\n    assert candidate([('Book', 10, 2), ('Laptop', 8, 5), ('Pen', 15, 1), ('Chair', 5, 8)]) == ['Pen', 'Book', 'Laptop', 'Chair']\n    assert candidate([('Spoon', 5, 1), ('Fork', 5, 1), ('Knife', 5, 1), ('Plate', 8, 3), ('Bowl', 7, 2)]) == ['Spoon', 'Fork', 'Knife', 'Bowl', 'Plate']\n    assert candidate([('A', 1, 10), ('B', 2, 9), ('C', 3, 8), ('D', 4, 7), ('E', 5, 6)]) == ['E', 'D', 'C', 'B', 'A']\n    assert candidate([('Item1', 5, 5), ('Item2', 5, 5), ('Item3', 5, 5)]) == ['Item1', 'Item2', 'Item3']\n    assert candidate([('A', 10, 10), ('B', 10, 5), ('C', 5, 10), ('D', 5, 5)]) == ['B', 'A', 'D', 'C']\n    assert candidate([('Tennis Ball', 9, 1), ('Basketball', 7, 5), ('Soccer Ball', 8, 3), ('Baseball', 6, 1)]) == ['Tennis Ball', 'Baseball', 'Soccer Ball', 'Basketball']\n    assert candidate([('A', 1, 1), ('B', 2, 2), ('C', 3, 3)]) == ['A', 'B', 'C']\n    assert candidate([('Item', 100, 100) for _ in range(10)]) == ['Item', 'Item', 'Item', 'Item', 'Item', 'Item', 'Item', 'Item', 'Item', 'Item']\n    assert candidate([('Bread', 20, 3), ('Milk', 18, 4), ('Eggs', 15, 2), ('Cheese', 12, 2), ('Butter', 10, 1)]) == ['Butter', 'Eggs', 'Bread', 'Cheese', 'Milk']\n", "language": "python"}
{"task_id": "dffa502b-e979-464e-9bac-e10ba0554f781059698016092209904", "prompt": "Implement the specified function so it can be run as a standalone code block. Refrain from including any code outside the function's scope. Utilize exclusively the libraries that are imported in the problem statement. If additional functions or classes are needed, define them within the given function. Provide your solution as a single, cohesive code block.\n\n```python\nfrom typing import List, Tuple\n\ndef optimize_assembly_line(n: int, a: List[List[int]], t: List[List[int]], e: List[int], x: List[int]) -> Tuple[int, List[int]]:\n    \"\"\"\n    You are managing an assembly line with two parallel tracks. There are n stations on each track.\n    The time taken at each station is given in the 2D list 'a', where a[i][j] is the time taken at station j on track i.\n    The time taken to switch from one track to another is given in the 2D list 't', where t[i][j] is the time\n    taken to switch from track i at station j to the other track at station j+1.\n    'e[i]' is the entry time for track i, and 'x[i]' is the exit time from track i.\n\n    Your task is to find the minimum time to complete the assembly process and the optimal path through the stations.\n\n    Use dynamic programming and backtracking to solve this problem.\n\n\n    [EXAMPLES]\n    \n    assert candidate(4, [[1,10,1,10], [10,1,10,1]], [[5,5,5], [5,5,5]], [0, 0], [0, 0]) == (18, [2, 2, 2, 1, 1])\n    assert candidate(3, [[10,20,30], [30,20,10]], [[5,5], [5,5]], [5, 5], [5, 5]) == (55, [2, 1, 1, 1])\n\n    [/EXAMPLES]\n    \"\"\"\n```\n", "entry_point": "optimize_assembly_line", "solution": "from typing import List, Tuple\n\ndef optimize_assembly_line(n: int, a: List[List[int]], t: List[List[int]], e: List[int], x: List[int]) -> Tuple[int, List[int]]:\n    \"\"\"\n    You are managing an assembly line with two parallel tracks. There are n stations on each track.\n    The time taken at each station is given in the 2D list 'a', where a[i][j] is the time taken at station j on track i.\n    The time taken to switch from one track to another is given in the 2D list 't', where t[i][j] is the time\n    taken to switch from track i at station j to the other track at station j+1.\n    'e[i]' is the entry time for track i, and 'x[i]' is the exit time from track i.\n\n    Your task is to find the minimum time to complete the assembly process and the optimal path through the stations.\n\n    Use dynamic programming and backtracking to solve this problem.\n\n\n    [EXAMPLES]\n    \n    assert candidate(4, [[1,10,1,10], [10,1,10,1]], [[5,5,5], [5,5,5]], [0, 0], [0, 0]) == (18, [2, 2, 2, 1, 1])\n    assert candidate(3, [[10,20,30], [30,20,10]], [[5,5], [5,5]], [5, 5], [5, 5]) == (55, [2, 1, 1, 1])\n\n    [/EXAMPLES]\n    \"\"\"\n    def backtrack(i, j):\n        if j == 0:\n            return [i + 1]\n        if i == 0:\n            if dp[i][j] == dp[i][j-1] + a[i][j-1]:\n                return [i + 1] + backtrack(i, j-1)\n            else:\n                return [i + 1] + backtrack(1-i, j-1)\n        else:\n            if dp[i][j] == dp[i][j-1] + a[i][j-1]:\n                return [i + 1] + backtrack(i, j-1)\n            else:\n                return [i + 1] + backtrack(1-i, j-1)\n\n    # Initialize dp table\n    dp = [[float('inf')] * (n + 1) for _ in range(2)]\n    \n    # Base cases\n    dp[0][0] = e[0]\n    dp[1][0] = e[1]\n    \n    # Fill dp table\n    for j in range(1, n + 1):\n        for i in range(2):\n            if j == n:\n                dp[i][j] = min(dp[i][j-1] + a[i][j-1] + x[i],\n                               dp[1-i][j-1] + t[1-i][j-2] + a[i][j-1] + x[i])\n            else:\n                dp[i][j] = min(dp[i][j-1] + a[i][j-1],\n                               dp[1-i][j-1] + t[1-i][j-2] + a[i][j-1])\n    \n    # Find minimum time\n    min_time = min(dp[0][n], dp[1][n])\n    \n    # Backtrack to find the optimal path\n    optimal_path = backtrack(0 if dp[0][n] < dp[1][n] else 1, n)\n    \n    return min_time, optimal_path\n\n\n", "test": "def check(candidate):\n    assert candidate(4, [[1,10,1,10], [10,1,10,1]], [[5,5,5], [5,5,5]], [0, 0], [0, 0]) == (18, [2, 2, 2, 1, 1])\n    assert candidate(3, [[10,10,10], [20,20,20]], [[5,5], [5,5]], [1, 2], [3, 4]) == (34, [1, 2, 1, 1])\n    assert candidate(2, [[1, 2], [3, 4]], [[5], [6]], [0, 0], [0, 0]) == (3, [1, 1, 1])\n    assert candidate(3, [[5,5,5], [5,5,5]], [[1,1], [1,1]], [1, 1], [1, 1]) == (17, [2, 1, 1, 1])\n    assert candidate(3, [[100,200,300], [300,200,100]], [[50,50], [50,50]], [25, 25], [25, 25]) == (500, [2, 1, 1, 1])\n    assert candidate(5, [[1,2,3,4,5], [5,4,3,2,1]], [[1,2,3,4], [4,3,2,1]], [0, 0], [0, 0]) == (11, [2, 2, 2, 1, 1, 1])\n    assert candidate(2, [[1000,1000], [1,1]], [[500], [500]], [100, 1], [100, 1]) == (4, [2, 1, 1])\n    assert candidate(3, [[10,20,30], [30,20,10]], [[5,5], [5,5]], [5, 5], [5, 5]) == (55, [2, 1, 1, 1])\n", "language": "python"}
{"task_id": "849d4366-6e69-4b89-9c0d-8671acf4ed3f8591391875798477632", "prompt": "Following the instructions in the doc string, complete the function's implementation. Present the function in its entirety within a single, continuous code block.\n\n```python\ndef calculate_compound_interest(principal: float, rate: float, time: int, compounds_per_year: int) -> float:\n    \"\"\"\n    In a financial planning scenario, this function calculates the final amount after applying\n    compound interest to a principal amount. It takes into account the interest rate, time period,\n    and the number of times interest is compounded per year.\n\n    Args:\n    principal (float): The initial investment amount.\n    rate (float): The annual interest rate (as a decimal).\n    time (int): The number of years the amount is invested.\n    compounds_per_year (int): The number of times interest is compounded per year.\n\n    Returns:\n    float: The final amount after applying compound interest.\n\n\n    [EXAMPLES]\n    \n    assert candidate(400.0, 0.12, 4, 365) == 646.3787681004471\n    assert candidate(15000.0, 0.025, 12, 24) == 20244.720824191045\n\n    [/EXAMPLES]\n    \"\"\"\n```\n", "entry_point": "calculate_compound_interest", "solution": "def calculate_compound_interest(principal: float, rate: float, time: int, compounds_per_year: int) -> float:\n    \"\"\"\n    In a financial planning scenario, this function calculates the final amount after applying\n    compound interest to a principal amount. It takes into account the interest rate, time period,\n    and the number of times interest is compounded per year.\n\n    Args:\n    principal (float): The initial investment amount.\n    rate (float): The annual interest rate (as a decimal).\n    time (int): The number of years the amount is invested.\n    compounds_per_year (int): The number of times interest is compounded per year.\n\n    Returns:\n    float: The final amount after applying compound interest.\n\n\n    [EXAMPLES]\n    \n    assert candidate(400.0, 0.12, 4, 365) == 646.3787681004471\n    assert candidate(15000.0, 0.025, 12, 24) == 20244.720824191045\n\n    [/EXAMPLES]\n    \"\"\"\n    # Calculate the final amount using the compound interest formula\n    final_amount = principal * (1 + rate / compounds_per_year) ** (compounds_per_year * time)\n    \n    return final_amount\n\n", "test": "def check(candidate):\n    assert candidate(400.0, 0.12, 4, 365) == 646.3787681004471\n    assert candidate(2000.0, 0.08, 5, 24) == 2981.665364836524\n    assert candidate(750.0, 0.09, 8, 6) == 1532.608716984735\n    assert candidate(5000.0, 0.08, 10, 4) == 11040.198318074268\n    assert candidate(2500.0, 0.06, 7, 2) == 3781.4743121377796\n    assert candidate(500.0, 0.07, 3, 365) == 616.8266104122087\n    assert candidate(1000.0, 0.05, 5, 12) == 1283.3586785035118\n    assert candidate(100000000.0, 0.01, 100, 365) == 271824459.2660437\n    assert candidate(100000.0, 0.04, 15, 52) == 182169.85754122367\n    assert candidate(15000.0, 0.025, 12, 24) == 20244.720824191045\n", "language": "python"}
{"task_id": "ad19aa57-4044-493f-bb58-746ac5e9fab81052417952980482424", "prompt": "Implement the rest of the function to match the description in the documentation string. Provide the complete function in one code block. Leave the function name and parameters as they are.\n\n```python\nimport heapq\nfrom collections import defaultdict\nfrom typing import List\n\ndef network_latency_simulator(nodes: int, connections: List[tuple], messages: List[tuple]) -> List[int]:\n    \"\"\"\n    In a distributed computing system, multiple nodes are connected in a network.\n    Each connection between nodes has an associated latency. This function simulates\n    the transmission of messages through the network and calculates the total\n    latency for each message.\n\n    The network is represented as an undirected graph where nodes are numbered\n    from 0 to n-1. Connections between nodes are given as (node1, node2, latency)\n    tuples. Messages are represented as (source, destination) tuples.\n\n    The function should find the path with the minimum total latency for each\n    message and return the list of these minimum latencies.\n\n    Parameters:\n    nodes (int): The number of nodes in the network.\n    connections (List[tuple]): A list of (node1, node2, latency) tuples representing\n                               the connections between nodes and their latencies.\n    messages (List[tuple]): A list of (source, destination) tuples representing\n                            the messages to be sent through the network.\n\n    Returns:\n    List[int]: A list of integers representing the minimum latency for each message.\n\n\n    [EXAMPLES]\n    \n    assert candidate(5, [(0,1,1), (1,2,2), (2,3,3), (3,4,4), (0,4,20)], [(0,4)]) == [10]\n    assert candidate(5, [(0,1,1), (1,2,2), (2,3,3), (3,4,4)], [(0,4), (4,0)]) == [10, 10]\n\n    [/EXAMPLES]\n    \"\"\"\n```\n", "entry_point": "network_latency_simulator", "solution": "import heapq\nfrom collections import defaultdict\nfrom typing import List\n\ndef network_latency_simulator(nodes: int, connections: List[tuple], messages: List[tuple]) -> List[int]:\n    \"\"\"\n    In a distributed computing system, multiple nodes are connected in a network.\n    Each connection between nodes has an associated latency. This function simulates\n    the transmission of messages through the network and calculates the total\n    latency for each message.\n\n    The network is represented as an undirected graph where nodes are numbered\n    from 0 to n-1. Connections between nodes are given as (node1, node2, latency)\n    tuples. Messages are represented as (source, destination) tuples.\n\n    The function should find the path with the minimum total latency for each\n    message and return the list of these minimum latencies.\n\n    Parameters:\n    nodes (int): The number of nodes in the network.\n    connections (List[tuple]): A list of (node1, node2, latency) tuples representing\n                               the connections between nodes and their latencies.\n    messages (List[tuple]): A list of (source, destination) tuples representing\n                            the messages to be sent through the network.\n\n    Returns:\n    List[int]: A list of integers representing the minimum latency for each message.\n\n\n    [EXAMPLES]\n    \n    assert candidate(5, [(0,1,1), (1,2,2), (2,3,3), (3,4,4), (0,4,20)], [(0,4)]) == [10]\n    assert candidate(5, [(0,1,1), (1,2,2), (2,3,3), (3,4,4)], [(0,4), (4,0)]) == [10, 10]\n\n    [/EXAMPLES]\n    \"\"\"\n    import heapq\n    from collections import defaultdict\n\n    # Build the graph\n    graph = defaultdict(list)\n    for node1, node2, latency in connections:\n        graph[node1].append((node2, latency))\n        graph[node2].append((node1, latency))\n\n    def dijkstra(start, end):\n        distances = {node: float('inf') for node in range(nodes)}\n        distances[start] = 0\n        pq = [(0, start)]\n\n        while pq:\n            current_distance, current_node = heapq.heappop(pq)\n\n            if current_node == end:\n                return current_distance\n\n            if current_distance > distances[current_node]:\n                continue\n\n            for neighbor, weight in graph[current_node]:\n                distance = current_distance + weight\n                if distance < distances[neighbor]:\n                    distances[neighbor] = distance\n                    heapq.heappush(pq, (distance, neighbor))\n\n        return float('inf')  # If no path is found\n\n    # Calculate minimum latency for each message\n    result = []\n    for source, destination in messages:\n        min_latency = dijkstra(source, destination)\n        result.append(min_latency)\n\n    return result\n\n", "test": "def check(candidate):\n    assert candidate(7, [(0,1,1), (1,2,2), (2,3,3), (3,4,4), (4,5,5), (5,6,6)], [(0,6), (6,0)]) == [21, 21]\n    assert candidate(5, [(0,1,1), (1,2,2), (2,3,3), (3,4,4)], [(0,4), (4,0)]) == [10, 10]\n    assert candidate(8, [(i,i+1,1) for i in range(7)], [(0,7), (7,0)]) == [7, 7]\n    assert candidate(10, [(i,j,1) for i in range(10) for j in range(i+1,10)], [(i,9-i) for i in range(10)]) == [1, 1, 1, 1, 1, 1, 1, 1, 1, 1]\n    assert candidate(5, [(0,1,1), (1,2,2), (2,3,3), (3,4,4), (0,4,20)], [(0,4)]) == [10]\n    assert candidate(6, [(i,j,abs(i-j)) for i in range(6) for j in range(i+1,6)], [(0,5), (5,0)]) == [5, 5]\n    assert candidate(3, [(0,1,1), (1,2,1), (0,2,3)], [(0,2)]) == [2]\n    assert candidate(9, [(i,i+1,i+1) for i in range(8)], [(0,8), (8,0)]) == [36, 36]\n    assert candidate(2, [(0,1,1000000)], [(0,1), (1,0)]) == [1000000, 1000000]\n    assert candidate(1, [], []) == []\n", "language": "python"}
{"task_id": "251f7ae8-3a8c-48be-902b-eef67022cc414682739430884258417", "prompt": "You are required to finish a specified function that can be run as-is within a code segment. Refrain from including any code outside of the function. Utilize only the libraries that are imported in the given problem. Any additional functions or classes should be defined exclusively within the provided function.\n\n```python\nfrom typing import List\n\ndef optimize_study_schedule(subjects: List[str], difficulties: List[int], available_time: int) -> List[str]:\n    \"\"\"\n    Optimizes a study schedule based on subject difficulties and available time.\n\n    This function takes a list of subjects, their corresponding difficulties,\n    and the total available study time. It returns an optimized list of subjects\n    to study that maximizes the number of subjects covered while considering\n    their difficulties within the available time.\n\n    Args:\n        subjects (List[str]): A list of subject names.\n        difficulties (List[int]): A list of difficulty levels corresponding to each subject.\n        available_time (int): The total available study time in minutes.\n\n    Returns:\n        List[str]: An optimized list of subjects to study.\n\n\n    [EXAMPLES]\n    \n    assert candidate(['World History', 'Ancient Civilizations', 'Modern Art'], [3, 4, 2], 6) == ['Modern Art', 'World History']\n    assert candidate(['Physics', 'Chemistry', 'Biology'], [5, 4, 3], 10) == ['Biology', 'Chemistry']\n\n    [/EXAMPLES]\n    \"\"\"\n```\n", "entry_point": "optimize_study_schedule", "solution": "from typing import List\n\ndef optimize_study_schedule(subjects: List[str], difficulties: List[int], available_time: int) -> List[str]:\n    \"\"\"\n    Optimizes a study schedule based on subject difficulties and available time.\n\n    This function takes a list of subjects, their corresponding difficulties,\n    and the total available study time. It returns an optimized list of subjects\n    to study that maximizes the number of subjects covered while considering\n    their difficulties within the available time.\n\n    Args:\n        subjects (List[str]): A list of subject names.\n        difficulties (List[int]): A list of difficulty levels corresponding to each subject.\n        available_time (int): The total available study time in minutes.\n\n    Returns:\n        List[str]: An optimized list of subjects to study.\n\n\n    [EXAMPLES]\n    \n    assert candidate(['World History', 'Ancient Civilizations', 'Modern Art'], [3, 4, 2], 6) == ['Modern Art', 'World History']\n    assert candidate(['Physics', 'Chemistry', 'Biology'], [5, 4, 3], 10) == ['Biology', 'Chemistry']\n\n    [/EXAMPLES]\n    \"\"\"\n    # Create a list of tuples containing (subject, difficulty)\n    subject_difficulty_pairs = list(zip(subjects, difficulties))\n    \n    # Sort the pairs based on difficulty (ascending order)\n    subject_difficulty_pairs.sort(key=lambda x: x[1])\n    \n    optimized_schedule = []\n    remaining_time = available_time\n    \n    # Iterate through the sorted pairs\n    for subject, difficulty in subject_difficulty_pairs:\n        # If we can accommodate the subject in the remaining time\n        if difficulty <= remaining_time:\n            optimized_schedule.append(subject)\n            remaining_time -= difficulty\n        \n        # If we've used up all the available time, break the loop\n        if remaining_time <= 0:\n            break\n    \n    return optimized_schedule\n\n", "test": "def check(candidate):\n    assert candidate(['Literature', 'Philosophy', 'Psychology'], [2, 3, 2], 7) == ['Literature', 'Psychology', 'Philosophy']\n    assert candidate(['Math', 'English', 'Science'], [2, 1, 3], 5) == ['English', 'Math']\n    assert candidate(['Anatomy', 'Physiology', 'Microbiology', 'Biochemistry'], [4, 4, 3, 5], 12) == ['Microbiology', 'Anatomy', 'Physiology']\n    assert candidate(['Web Development', 'Mobile App Development', 'Database Management'], [3, 4, 3], 9) == ['Web Development', 'Database Management']\n    assert candidate(['Computer Science', 'Statistics', 'Calculus', 'Linear Algebra'], [4, 3, 5, 4], 15) == ['Statistics', 'Computer Science', 'Linear Algebra']\n    assert candidate(['Nutrition', 'Exercise Science', 'Public Health'], [2, 3, 3], 7) == ['Nutrition', 'Exercise Science']\n    assert candidate(['Physics', 'Chemistry', 'Biology'], [5, 4, 3], 10) == ['Biology', 'Chemistry']\n    assert candidate(['Algebra', 'Geometry', 'Trigonometry'], [3, 3, 4], 7) == ['Algebra', 'Geometry']\n    assert candidate(['World History', 'Ancient Civilizations', 'Modern Art'], [3, 4, 2], 6) == ['Modern Art', 'World History']\n    assert candidate(['French', 'Spanish', 'German', 'Italian', 'Chinese'], [2, 2, 3, 2, 4], 10) == ['French', 'Spanish', 'Italian', 'German']\n", "language": "python"}
{"task_id": "21c55e71-8714-43a2-96d9-c9b2e3ab621e8079606284894256138", "prompt": "Complete the designated function to ensure it is fully operational when run in a code block. Do not add any code outside of the function's scope. Limit yourself to using only the libraries that are mentioned as imported in the problem. If you need to create additional functions or classes, make sure to define them inside the given function.\n\n```python\ndef encrypt_message(message: str, key: str) -> str:\n    \"\"\"\n    A spy needs to encrypt a secret message before transmission. This function implements\n    a simple polyalphabetic substitution cipher using a provided key.\n\n    The encryption process works as follows:\n    1. The key is repeated to match the length of the message\n    2. Each character in the message is shifted by the corresponding character in the key\n    3. The shift wraps around the alphabet (A-Z only, case-insensitive)\n    4. Non-alphabetic characters are left unchanged\n\n    Parameters:\n    message (str): The secret message to be encrypted\n    key (str): The encryption key\n\n    Returns:\n    str: The encrypted message\n\n\n    [EXAMPLES]\n    \n    assert candidate(\"\", \"EMPTY\") == ''\n    assert candidate(\"Python is awesome!\", \"PROGRAMMING\") == 'Ephnfn ua glvgude!'\n\n    [/EXAMPLES]\n    \"\"\"\n```\n", "entry_point": "encrypt_message", "solution": "def encrypt_message(message: str, key: str) -> str:\n    \"\"\"\n    A spy needs to encrypt a secret message before transmission. This function implements\n    a simple polyalphabetic substitution cipher using a provided key.\n\n    The encryption process works as follows:\n    1. The key is repeated to match the length of the message\n    2. Each character in the message is shifted by the corresponding character in the key\n    3. The shift wraps around the alphabet (A-Z only, case-insensitive)\n    4. Non-alphabetic characters are left unchanged\n\n    Parameters:\n    message (str): The secret message to be encrypted\n    key (str): The encryption key\n\n    Returns:\n    str: The encrypted message\n\n\n    [EXAMPLES]\n    \n    assert candidate(\"\", \"EMPTY\") == ''\n    assert candidate(\"Python is awesome!\", \"PROGRAMMING\") == 'Ephnfn ua glvgude!'\n\n    [/EXAMPLES]\n    \"\"\"\n    def shift_char(char: str, shift: str) -> str:\n        if not char.isalpha():\n            return char\n        \n        base = 'A' if char.isupper() else 'a'\n        return chr((ord(char) - ord(base) + ord(shift.upper()) - ord('A')) % 26 + ord(base))\n\n    # Repeat the key to match the length of the message\n    repeated_key = (key * (len(message) // len(key) + 1))[:len(message)]\n    \n    # Encrypt each character in the message\n    encrypted_message = ''.join(shift_char(m, k) for m, k in zip(message, repeated_key))\n    \n    return encrypted_message\n\n", "test": "def check(candidate):\n    assert candidate(\"1234567890!@#$%^&*()\", \"SECURE\") == '1234567890!@#$%^&*()'\n    assert candidate(\"Python is awesome!\", \"PROGRAMMING\") == 'Ephnfn ua glvgude!'\n    assert candidate(\"\u00c4\u00d6\u00dc\u00e4\u00f6\u00fc\u00df\", \"UMLAUT\") == 'VFKbnsq'\n    assert candidate(\"HELLO WORLD\", \"SECRET\") == 'ZINCS OSTCH'\n    assert candidate(\"Meet me at midnight\", \"SHADOW\") == 'Elew iw aw iaknludl'\n    assert candidate(\"UPPER lower MiXeD\", \"MiX\") == 'GXMQZ xwtqz YqUqL'\n    assert candidate(\"The quick brown fox jumps over the lazy dog\", \"CIPHER\") == 'Vpt ulkkz fiqec jfz ybqgu dcii bwl cchn hfi'\n    assert candidate(\"\", \"EMPTY\") == ''\n    assert candidate(\"AAAAA\", \"ZZZZZ\") == 'ZZZZZ'\n    assert candidate(\"ZZZZZ\", \"AAAAA\") == 'ZZZZZ'\n", "language": "python"}
{"task_id": "00d9facc-dbed-4a04-82d3-879962ef5a49-3810255618939218437", "prompt": "Your assignment is to craft a comprehensive function that can be executed on its own as a single code unit. Refrain from adding code outside the function's scope. Use exclusively the libraries that are imported in the problem setup. Should you require additional functions or classes, incorporate them within the primary function.\n\n```python\nimport math\nfrom typing import List, Tuple\n\ndef ecosystem_stability(species: List[str], interactions: List[Tuple[str, str, float]]) -> float:\n    \"\"\"\n    Analyzes the stability of an ecosystem based on species interactions.\n    \n    This function takes a list of species and their pairwise interactions, then\n    calculates a stability index for the ecosystem. The stability index is based\n    on the number and strength of interactions between species.\n    \n    Parameters:\n    species (List[str]): A list of species names in the ecosystem.\n    interactions (List[Tuple[str, str, float]]): A list of tuples representing\n                                                 interactions between species.\n                                                 Each tuple contains (species1,\n                                                 species2, interaction_strength).\n    \n    Returns:\n    float: A stability index for the ecosystem (higher values indicate more stability).\n    \n\n    [EXAMPLES]\n    \n    assert candidate([\"Bacteria\", \"Virus\", \"White Blood Cell\"], [(\"Bacteria\", \"Virus\", 0.2), (\"Virus\", \"White Blood Cell\", -0.9), (\"White Blood Cell\", \"Bacteria\", -0.8)]) == 0.68\n    assert candidate([\"Fox\", \"Rabbit\", \"Carrot\", \"Grass\"], [(\"Fox\", \"Rabbit\", -0.7), (\"Rabbit\", \"Carrot\", -0.5), (\"Rabbit\", \"Grass\", -0.4), (\"Carrot\", \"Fox\", 0.1)]) == 0.58\n\n    [/EXAMPLES]\n    \"\"\"\n```\n", "entry_point": "ecosystem_stability", "solution": "import math\nfrom typing import List, Tuple\n\ndef ecosystem_stability(species: List[str], interactions: List[Tuple[str, str, float]]) -> float:\n    \"\"\"\n    Analyzes the stability of an ecosystem based on species interactions.\n    \n    This function takes a list of species and their pairwise interactions, then\n    calculates a stability index for the ecosystem. The stability index is based\n    on the number and strength of interactions between species.\n    \n    Parameters:\n    species (List[str]): A list of species names in the ecosystem.\n    interactions (List[Tuple[str, str, float]]): A list of tuples representing\n                                                 interactions between species.\n                                                 Each tuple contains (species1,\n                                                 species2, interaction_strength).\n    \n    Returns:\n    float: A stability index for the ecosystem (higher values indicate more stability).\n    \n\n    [EXAMPLES]\n    \n    assert candidate([\"Bacteria\", \"Virus\", \"White Blood Cell\"], [(\"Bacteria\", \"Virus\", 0.2), (\"Virus\", \"White Blood Cell\", -0.9), (\"White Blood Cell\", \"Bacteria\", -0.8)]) == 0.68\n    assert candidate([\"Fox\", \"Rabbit\", \"Carrot\", \"Grass\"], [(\"Fox\", \"Rabbit\", -0.7), (\"Rabbit\", \"Carrot\", -0.5), (\"Rabbit\", \"Grass\", -0.4), (\"Carrot\", \"Fox\", 0.1)]) == 0.58\n\n    [/EXAMPLES]\n    \"\"\"\n    def calculate_connectivity():\n        total_possible = len(species) * (len(species) - 1) / 2\n        return len(interactions) / total_possible if total_possible > 0 else 0\n\n    def calculate_interaction_strength():\n        return sum(abs(strength) for _, _, strength in interactions) / len(interactions) if interactions else 0\n\n    def calculate_balance():\n        positive = sum(1 for _, _, strength in interactions if strength > 0)\n        negative = sum(1 for _, _, strength in interactions if strength < 0)\n        total = len(interactions)\n        return 1 - abs(positive - negative) / total if total > 0 else 0\n\n    connectivity = calculate_connectivity()\n    interaction_strength = calculate_interaction_strength()\n    balance = calculate_balance()\n\n    stability_index = (connectivity + (1 - interaction_strength) + balance) / 3\n    return round(stability_index, 2)\n\n", "test": "def check(candidate):\n    assert candidate([\"A\", \"B\", \"C\", \"D\", \"E\"], [(\"A\", \"B\", 0.1), (\"B\", \"C\", 0.2), (\"C\", \"D\", 0.3), (\"D\", \"E\", 0.4), (\"E\", \"A\", 0.5)]) == 0.4\n    assert candidate([\"A\", \"B\", \"C\", \"D\"], [(\"A\", \"B\", 0.1), (\"B\", \"C\", 0.2), (\"C\", \"D\", 0.3), (\"D\", \"A\", 0.4)]) == 0.47\n    assert candidate([\"Bacteria\", \"Virus\", \"White Blood Cell\"], [(\"Bacteria\", \"Virus\", 0.2), (\"Virus\", \"White Blood Cell\", -0.9), (\"White Blood Cell\", \"Bacteria\", -0.8)]) == 0.68\n    assert candidate([\"Oak\", \"Squirrel\", \"Hawk\"], [(\"Oak\", \"Squirrel\", 0.6), (\"Squirrel\", \"Hawk\", -0.8), (\"Hawk\", \"Oak\", 0.0)]) == 0.84\n    assert candidate([\"Fox\", \"Rabbit\", \"Carrot\", \"Grass\"], [(\"Fox\", \"Rabbit\", -0.7), (\"Rabbit\", \"Carrot\", -0.5), (\"Rabbit\", \"Grass\", -0.4), (\"Carrot\", \"Fox\", 0.1)]) == 0.58\n    assert candidate([\"Predator\", \"Prey\"], [(\"Predator\", \"Prey\", -1.0)]) == 0.33\n", "language": "python"}
{"task_id": "2c780a61-441b-4910-b22f-aa91ba3cd8f0-441066194864972192", "prompt": "Following the docstring's directions, finalize the function in one cohesive code block. Any necessary auxiliary functions or classes must be incorporated within the main function's scope.\n\n```python\nfrom typing import List\n\ndef solve_maze(maze: List[List[int]], start: tuple, end: tuple) -> List[tuple]:\n    \"\"\"\n    A young adventurer finds herself in a mysterious labyrinth filled with ancient puzzles.\n    Help her navigate through the maze using depth-first search to find the treasure at the end.\n\n    The maze is represented as a 2D list where 0 represents open paths and 1 represents walls.\n    The function should return the path from start to end as a list of coordinates (tuples).\n    If no path exists, return an empty list.\n\n\n    [EXAMPLES]\n    \n    assert candidate([[0,1,1],[0,0,1],[1,0,0]], (0,0), (2,2)) == [(0, 0), (1, 0), (1, 1), (2, 1), (2, 2)]\n    assert candidate([[0,0,0],[1,1,0],[1,1,0]], (0,0), (2,2)) == [(0, 0), (0, 1), (0, 2), (1, 2), (2, 2)]\n\n    [/EXAMPLES]\n    \"\"\"\n```\n", "entry_point": "solve_maze", "solution": "from typing import List\n\ndef solve_maze(maze: List[List[int]], start: tuple, end: tuple) -> List[tuple]:\n    \"\"\"\n    A young adventurer finds herself in a mysterious labyrinth filled with ancient puzzles.\n    Help her navigate through the maze using depth-first search to find the treasure at the end.\n\n    The maze is represented as a 2D list where 0 represents open paths and 1 represents walls.\n    The function should return the path from start to end as a list of coordinates (tuples).\n    If no path exists, return an empty list.\n\n\n    [EXAMPLES]\n    \n    assert candidate([[0,1,1],[0,0,1],[1,0,0]], (0,0), (2,2)) == [(0, 0), (1, 0), (1, 1), (2, 1), (2, 2)]\n    assert candidate([[0,0,0],[1,1,0],[1,1,0]], (0,0), (2,2)) == [(0, 0), (0, 1), (0, 2), (1, 2), (2, 2)]\n\n    [/EXAMPLES]\n    \"\"\"\n    def dfs(x: int, y: int, path: List[tuple]) -> List[tuple]:\n        if (x, y) == end:\n            return path\n        \n        for dx, dy in [(0, 1), (1, 0), (0, -1), (-1, 0)]:  # right, down, left, up\n            nx, ny = x + dx, y + dy\n            if (0 <= nx < len(maze) and 0 <= ny < len(maze[0]) and \n                maze[nx][ny] == 0 and (nx, ny) not in path):\n                result = dfs(nx, ny, path + [(nx, ny)])\n                if result:\n                    return result\n        \n        return []\n\n    return dfs(start[0], start[1], [start])\n\n", "test": "def check(candidate):\n    assert candidate([[0,0,0,0,0],[1,1,1,1,0],[0,0,0,0,0]], (0,0), (2,4)) == [(0, 0), (0, 1), (0, 2), (0, 3), (0, 4), (1, 4), (2, 4)]\n    assert candidate([[0,0,0],[1,1,0],[1,1,0]], (0,0), (2,2)) == [(0, 0), (0, 1), (0, 2), (1, 2), (2, 2)]\n    assert candidate([[0,1,1],[0,0,1],[1,0,0]], (0,0), (2,2)) == [(0, 0), (1, 0), (1, 1), (2, 1), (2, 2)]\n    assert candidate([[0,0,0,0],[1,1,1,0],[0,0,0,0],[0,1,1,0]], (0,0), (3,3)) == [(0, 0), (0, 1), (0, 2), (0, 3), (1, 3), (2, 3), (3, 3)]\n    assert candidate([[0,1,0],[0,1,0],[0,1,0]], (0,0), (2,2)) == []\n    assert candidate([[0]], (0,0), (0,0)) == [(0, 0)]\n    assert candidate([[0,1],[0,0]], (0,0), (1,1)) == [(0, 0), (1, 0), (1, 1)]\n    assert candidate([[0,0,0],[1,1,0],[0,0,0]], (0,0), (2,2)) == [(0, 0), (0, 1), (0, 2), (1, 2), (2, 2)]\n    assert candidate([[0,0],[0,0]], (0,0), (1,1)) == [(0, 0), (0, 1), (1, 1)]\n    assert candidate([[0,0,1,0,0],[0,0,1,0,0],[0,0,1,0,0],[0,0,0,0,0]], (0,0), (3,4)) == [(0, 0), (0, 1), (1, 1), (2, 1), (3, 1), (3, 2), (3, 3), (3, 4)]\n", "language": "python"}
{"task_id": "9949de18-192f-4ed7-bdf2-273b7b8d78eb-5198379943166241650", "prompt": "Focus on developing the given function to be fully executable within a single code block. Avoid writing any code external to the function. Limit yourself to using only the libraries specified in the problem setup. Should you require additional functions or classes, define them inside the main function you're working on.\n\n```python\nfrom collections import defaultdict\nfrom typing import List, Tuple\n\ndef wildlife_migration(populations: List[int], connections: List[Tuple[int, int]]) -> int:\n    \"\"\"\n    In a wildlife reserve, researchers are studying animal migration patterns between different areas.\n    Each area is represented by a node, and the population of animals in each area is given.\n    Connections between areas are represented by edges.\n\n    The researchers want to find the minimum number of animals that need to be moved to ensure\n    that each connected pair of areas has the same animal population.\n\n    Parameters:\n    populations (List[int]): A list of integers representing the animal population in each area.\n    connections (List[Tuple[int, int]]): A list of tuples representing connections between areas.\n\n    Returns:\n    int: The minimum number of animals that need to be moved.\n\n\n    [EXAMPLES]\n    \n    assert candidate([1, 2, 3], [(0, 1), (1, 2)]) == 1\n    assert candidate([1, 3, 5, 7, 9, 11], [(0, 1), (1, 2), (2, 3), (3, 4), (4, 5)]) == 9\n\n    [/EXAMPLES]\n    \"\"\"\n```\n", "entry_point": "wildlife_migration", "solution": "from collections import defaultdict\nfrom typing import List, Tuple\n\ndef wildlife_migration(populations: List[int], connections: List[Tuple[int, int]]) -> int:\n    \"\"\"\n    In a wildlife reserve, researchers are studying animal migration patterns between different areas.\n    Each area is represented by a node, and the population of animals in each area is given.\n    Connections between areas are represented by edges.\n\n    The researchers want to find the minimum number of animals that need to be moved to ensure\n    that each connected pair of areas has the same animal population.\n\n    Parameters:\n    populations (List[int]): A list of integers representing the animal population in each area.\n    connections (List[Tuple[int, int]]): A list of tuples representing connections between areas.\n\n    Returns:\n    int: The minimum number of animals that need to be moved.\n\n\n    [EXAMPLES]\n    \n    assert candidate([1, 2, 3], [(0, 1), (1, 2)]) == 1\n    assert candidate([1, 3, 5, 7, 9, 11], [(0, 1), (1, 2), (2, 3), (3, 4), (4, 5)]) == 9\n\n    [/EXAMPLES]\n    \"\"\"\n    def find(x):\n        if parent[x] != x:\n            parent[x] = find(parent[x])\n        return parent[x]\n\n    def union(x, y):\n        px, py = find(x), find(y)\n        if px != py:\n            if rank[px] < rank[py]:\n                px, py = py, px\n            parent[py] = px\n            if rank[px] == rank[py]:\n                rank[px] += 1\n\n    n = len(populations)\n    parent = list(range(n))\n    rank = [0] * n\n\n    # Union connected areas\n    for a, b in connections:\n        union(a, b)\n\n    # Group areas by their parent\n    groups = defaultdict(list)\n    for i in range(n):\n        groups[find(i)].append(i)\n\n    total_moves = 0\n\n    # Calculate moves for each group\n    for group in groups.values():\n        total_pop = sum(populations[i] for i in group)\n        target_pop = total_pop // len(group)\n        moves = sum(abs(populations[i] - target_pop) for i in group) // 2\n        total_moves += moves\n\n    return total_moves\n\n", "test": "def check(candidate):\n    assert candidate([100, 200, 300, 400, 500], [(0, 1), (1, 2), (2, 3), (3, 4)]) == 300\n    assert candidate([3, 3, 3, 3, 3], [(0, 1), (1, 2), (2, 3), (3, 4)]) == 0\n    assert candidate([5, 5, 5, 5, 5], [(0, 1), (1, 2), (2, 3), (3, 4)]) == 0\n    assert candidate([7, 8, 9, 10, 11], [(0, 1), (1, 2), (2, 3), (3, 4)]) == 3\n    assert candidate([1, 3, 5, 7, 9, 11], [(0, 1), (1, 2), (2, 3), (3, 4), (4, 5)]) == 9\n    assert candidate([100, 200, 300, 400], [(0, 1), (1, 2), (2, 3)]) == 200\n    assert candidate([1, 2, 3, 4, 5, 6], [(0, 1), (1, 2), (2, 3), (3, 4), (4, 5)]) == 4\n    assert candidate([1, 2, 3], [(0, 1), (1, 2)]) == 1\n    assert candidate([1000, 2000, 3000], [(0, 1), (1, 2)]) == 1000\n    assert candidate([5, 10, 15, 20, 25], [(0, 1), (1, 2), (2, 3), (3, 4)]) == 15\n", "language": "python"}
{"task_id": "ceda2949-98e2-4e68-b5a7-63814c9cf8832226058430167972988", "prompt": "Complete the implementation of the function based on the provided documentation string. Present the entire function within a single code block.\n\n```python\nfrom typing import List\n\ndef encrypt_message(message: str, key: int) -> str:\n    \"\"\"\n    As a secret agent, you need to encrypt messages before sending them to your handler.\n    This function implements a simple substitution cipher that shifts each letter in the\n    message by a specified key value.\n\n    The function should preserve the case of the original message and ignore non-alphabetic\n    characters. The key represents the number of positions each letter should be shifted in\n    the alphabet. If the shift goes beyond 'Z' or 'z', it should wrap around to the beginning\n    of the alphabet.\n\n\n    [EXAMPLES]\n    \n    assert candidate(\"A\", 26) == 'A'\n    assert candidate(\"AaBbCcDdEeFfGgHhIiJjKkLlMmNnOoPpQqRrSsTtUuVvWwXxYyZz\", 13) == 'NnOoPpQqRrSsTtUuVvWwXxYyZzAaBbCcDdEeFfGgHhIiJjKkLlMm'\n\n    [/EXAMPLES]\n    \"\"\"\n```\n", "entry_point": "encrypt_message", "solution": "from typing import List\n\ndef encrypt_message(message: str, key: int) -> str:\n    \"\"\"\n    As a secret agent, you need to encrypt messages before sending them to your handler.\n    This function implements a simple substitution cipher that shifts each letter in the\n    message by a specified key value.\n\n    The function should preserve the case of the original message and ignore non-alphabetic\n    characters. The key represents the number of positions each letter should be shifted in\n    the alphabet. If the shift goes beyond 'Z' or 'z', it should wrap around to the beginning\n    of the alphabet.\n\n\n    [EXAMPLES]\n    \n    assert candidate(\"A\", 26) == 'A'\n    assert candidate(\"AaBbCcDdEeFfGgHhIiJjKkLlMmNnOoPpQqRrSsTtUuVvWwXxYyZz\", 13) == 'NnOoPpQqRrSsTtUuVvWwXxYyZzAaBbCcDdEeFfGgHhIiJjKkLlMm'\n\n    [/EXAMPLES]\n    \"\"\"\n    def shift_char(char: str, shift: int) -> str:\n        if not char.isalpha():\n            return char\n        \n        ascii_offset = ord('A') if char.isupper() else ord('a')\n        shifted = (ord(char) - ascii_offset + shift) % 26\n        return chr(shifted + ascii_offset)\n    \n    return ''.join(shift_char(char, key) for char in message)\n\n", "test": "def check(candidate):\n    assert candidate(\"Z\" * 1000 + \"z\" * 1000, 1) == 'AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa'\n    assert candidate(\"Encrypt me!\", -1) == 'Dmbqxos ld!'\n    assert candidate(\"12345!@#$%\", 5) == '12345!@#$%'\n    assert candidate(\"A\", 26) == 'A'\n    assert candidate(\"This is a long message with multiple words and punctuation marks!\", 7) == 'Aopz pz h svun tlzzhnl dpao tbsapwsl dvykz huk wbujabhapvu thyrz!'\n    assert candidate(\"Hello, World!\", 1) == 'Ifmmp, Xpsme!'\n    assert candidate(\"ZzYyXxWwVvUuTtSsRrQq\", 2) == 'BbAaZzYyXxWwVvUuTtSs'\n    assert candidate(\"HELLO world 123\", 26) == 'HELLO world 123'\n    assert candidate(\"AaBbCcDdEeFfGgHhIiJjKkLlMmNnOoPpQqRrSsTtUuVvWwXxYyZz\", 13) == 'NnOoPpQqRrSsTtUuVvWwXxYyZzAaBbCcDdEeFfGgHhIiJjKkLlMm'\n    assert candidate(\"Test with negative key\", -26) == 'Test with negative key'\n", "language": "python"}
{"task_id": "a727f0bb-f16b-457a-a477-b50b5a9dc5996550834564643661905", "prompt": "Complete the function's body according to the specifications outlined in the doc string. Present the full function in one cohesive code block.\n\n```python\ndef decrypt_alien_message(encrypted_text: str) -> str:\n    \"\"\"\n    An astronomer has intercepted a coded message from an alien civilization.\n    The message is a string of lowercase letters, but it's encrypted using a special rule:\n    each letter in the original message has been replaced by the letter that appears\n    two positions later in the alphabet (wrapping around from 'z' back to 'a').\n\n    This function takes the encrypted message as input and returns the decrypted message.\n    If a character in the input is not a lowercase letter, it should remain unchanged.\n\n\n    [EXAMPLES]\n    \n    assert candidate(\"z a\") == 'x y'\n    assert candidate(\"z\") == 'x'\n\n    [/EXAMPLES]\n    \"\"\"\n```\n", "entry_point": "decrypt_alien_message", "solution": "def decrypt_alien_message(encrypted_text: str) -> str:\n    \"\"\"\n    An astronomer has intercepted a coded message from an alien civilization.\n    The message is a string of lowercase letters, but it's encrypted using a special rule:\n    each letter in the original message has been replaced by the letter that appears\n    two positions later in the alphabet (wrapping around from 'z' back to 'a').\n\n    This function takes the encrypted message as input and returns the decrypted message.\n    If a character in the input is not a lowercase letter, it should remain unchanged.\n\n\n    [EXAMPLES]\n    \n    assert candidate(\"z a\") == 'x y'\n    assert candidate(\"z\") == 'x'\n\n    [/EXAMPLES]\n    \"\"\"\n    def shift_letter(char):\n        if char.islower():\n            # Calculate the shifted ASCII value\n            shifted = ord(char) - 2\n            # Wrap around if necessary\n            if shifted < ord('a'):\n                shifted += 26\n            return chr(shifted)\n        return char\n\n    return ''.join(map(shift_letter, encrypted_text))\n\n", "test": "def check(candidate):\n    assert candidate(\"AaBbCcDdEeFfGgHhIiJjKkLlMmNnOoPpQqRrSsTtUuVvWwXxYyZz\") == 'AyBzCaDbEcFdGeHfIgJhKiLjMkNlOmPnQoRpSqTrUsVtWuXvYwZx'\n    assert candidate(\"z9y8x7w6v5u4t3s2r1q0\") == 'x9w8v7u6t5s4r3q2p1o0'\n    assert candidate(\"jgnnq\") == 'hello'\n    assert candidate(\"z a\") == 'x y'\n    assert candidate(\"vjg swkem dtqyp hqz lworu qxgt vjg ncba fqi\") == 'the quick brown fox jumps over the lazy dog'\n    assert candidate(\"z\") == 'x'\n    assert candidate(\"jgnnq yqtnf\") == 'hello world'\n    assert candidate(\"vjku ku c vguv\") == 'this is a test'\n    assert candidate(\"a\") == 'y'\n    assert candidate(\"zzzzzyyyyywwwwwvvvvv\") == 'xxxxxwwwwwuuuuuttttt'\n", "language": "python"}
{"task_id": "e84ec5ca-68e6-4e82-ac31-61534b6d30a51150528094317380608", "prompt": "Round out the given code skeleton by inserting the required parts, confining all additions to a single, complete code block.\n\n```python\nfrom typing import List\n\ndef pizza_slices(orders: List[int], total_slices: int) -> List[int]:\n    \"\"\"\n    A pizza shop owner wants to fulfill customer orders efficiently. Given a list of orders\n    (number of slices per order) and the total number of slices available, determine which\n    orders can be completely fulfilled.\n\n    This function takes a list of order sizes and the total number of slices, and returns\n    a list of indices of the orders that can be fulfilled completely.\n\n\n    [EXAMPLES]\n    \n    assert candidate([1, 2, 3, 4], 10) == [0, 1, 2, 3]\n    assert candidate([3, 3, 3], 9) == [0, 1, 2]\n\n    [/EXAMPLES]\n    \"\"\"\n```\n", "entry_point": "pizza_slices", "solution": "from typing import List\n\ndef pizza_slices(orders: List[int], total_slices: int) -> List[int]:\n    \"\"\"\n    A pizza shop owner wants to fulfill customer orders efficiently. Given a list of orders\n    (number of slices per order) and the total number of slices available, determine which\n    orders can be completely fulfilled.\n\n    This function takes a list of order sizes and the total number of slices, and returns\n    a list of indices of the orders that can be fulfilled completely.\n\n\n    [EXAMPLES]\n    \n    assert candidate([1, 2, 3, 4], 10) == [0, 1, 2, 3]\n    assert candidate([3, 3, 3], 9) == [0, 1, 2]\n\n    [/EXAMPLES]\n    \"\"\"\n    fulfilled_orders = []\n    remaining_slices = total_slices\n\n    for index, order in enumerate(orders):\n        if order <= remaining_slices:\n            fulfilled_orders.append(index)\n            remaining_slices -= order\n        \n        if remaining_slices == 0:\n            break\n\n    return fulfilled_orders\n\n", "test": "def check(candidate):\n    assert candidate([1, 1, 1, 1, 1], 3) == [0, 1, 2]\n    assert candidate([10, 9, 8, 7, 6], 20) == [0, 1]\n    assert candidate([100], 99) == []\n    assert candidate([3, 3, 3], 9) == [0, 1, 2]\n    assert candidate([1, 2, 3, 4], 10) == [0, 1, 2, 3]\n    assert candidate([], 5) == []\n    assert candidate([8, 6, 4, 2], 12) == [0, 2]\n    assert candidate([7, 7, 7, 7], 21) == [0, 1, 2]\n", "language": "python"}
{"task_id": "25da2024-e6ae-444a-a600-65e6c206441b-1349348907298029998", "prompt": "The code will be enclosed in a single block, with all supplementary functions or classes defined inside the provided function. No external declarations will be made.\n\n```python\nfrom typing import List\n\ndef calculate_moving_average(prices: List[float], window: int) -> List[float]:\n    \"\"\"\n    In the world of finance and stock market analysis, this function calculates the\n    moving average of a given list of stock prices. The moving average is computed\n    over a specified window size.\n\n    The function takes a list of stock prices and a window size as input. It returns\n    a list of moving averages, where each average is calculated over the specified\n    number of preceding values. The result list will be shorter than the input list\n    by (window - 1) elements.\n\n\n    [EXAMPLES]\n    \n    assert candidate([1.23456, 2.34567, 3.45678, 4.56789, 5.67890], 5) == [3.45676]\n    assert candidate([100.5, 200.5, 300.5, 400.5, 500.5], 5) == [300.5]\n\n    [/EXAMPLES]\n    \"\"\"\n```\n", "entry_point": "calculate_moving_average", "solution": "from typing import List\n\ndef calculate_moving_average(prices: List[float], window: int) -> List[float]:\n    \"\"\"\n    In the world of finance and stock market analysis, this function calculates the\n    moving average of a given list of stock prices. The moving average is computed\n    over a specified window size.\n\n    The function takes a list of stock prices and a window size as input. It returns\n    a list of moving averages, where each average is calculated over the specified\n    number of preceding values. The result list will be shorter than the input list\n    by (window - 1) elements.\n\n\n    [EXAMPLES]\n    \n    assert candidate([1.23456, 2.34567, 3.45678, 4.56789, 5.67890], 5) == [3.45676]\n    assert candidate([100.5, 200.5, 300.5, 400.5, 500.5], 5) == [300.5]\n\n    [/EXAMPLES]\n    \"\"\"\n    if window <= 0 or window > len(prices):\n        return []\n\n    result = []\n    for i in range(len(prices) - window + 1):\n        window_sum = sum(prices[i:i+window])\n        average = window_sum / window\n        result.append(average)\n\n    return result\n\n", "test": "def check(candidate):\n    assert candidate([1.23456, 2.34567, 3.45678, 4.56789, 5.67890], 5) == [3.45676]\n    assert candidate([1.0, 2.0], 2) == [1.5]\n    assert candidate([1.0, 2.0, 3.0, 4.0, 5.0], 2) == [1.5, 2.5, 3.5, 4.5]\n    assert candidate([100.0, 101.0, 102.0, 103.0, 104.0], 4) == [101.5, 102.5]\n    assert candidate([10.0, 20.0, 30.0, 40.0, 50.0], 4) == [25.0, 35.0]\n    assert candidate([0.0, 0.0, 0.0, 0.0, 0.0], 4) == [0.0, 0.0]\n    assert candidate([1.0], 1) == [1.0]\n    assert candidate([0.1, 0.01, 0.001, 0.0001, 0.00001], 3) == [0.037, 0.0036999999999999997, 0.00037000000000000005]\n    assert candidate([100.5, 200.5, 300.5, 400.5, 500.5], 5) == [300.5]\n    assert candidate([10.5, 11.5, 12.5, 13.5, 14.5], 3) == [11.5, 12.5, 13.5]\n", "language": "python"}
{"task_id": "c63cd23d-8dc8-4d91-9dac-31a9ac4419cd-3196217938204075179", "prompt": "Please complete the function based on the provided documentation string. Include the entire function in a single code block. Don't forget to account for edge cases in your implementation.\n\n```python\nfrom typing import List\n\ndef analyze_stock_trends(prices: List[int], window: int) -> List[str]:\n    \"\"\"\n    A financial analyst wants to study stock price trends over a specific period. Given a list of daily stock prices and a window size,\n    determine if the stock is in an upward trend, downward trend, or stable for each window period.\n\n    The function takes two parameters:\n    - prices: A list of integers representing daily stock prices\n    - window: An integer representing the number of days to consider for each trend analysis\n\n    The function should return a list of strings where each string is either \"UP\", \"DOWN\", or \"STABLE\" representing the trend\n    for each window period. A trend is considered:\n    - \"UP\" if the price at the end of the window is higher than the price at the start\n    - \"DOWN\" if the price at the end of the window is lower than the price at the start\n    - \"STABLE\" if the price at the end of the window is the same as the price at the start\n\n\n    [EXAMPLES]\n    \n    assert candidate([15, 14, 13, 12, 11, 10, 9, 8], 3) == ['DOWN', 'DOWN', 'DOWN', 'DOWN', 'DOWN', 'DOWN']\n    assert candidate([1, 3, 5, 7, 9, 11, 13, 15], 4) == ['UP', 'UP', 'UP', 'UP', 'UP']\n\n    [/EXAMPLES]\n    \"\"\"\n```\n", "entry_point": "analyze_stock_trends", "solution": "from typing import List\n\ndef analyze_stock_trends(prices: List[int], window: int) -> List[str]:\n    \"\"\"\n    A financial analyst wants to study stock price trends over a specific period. Given a list of daily stock prices and a window size,\n    determine if the stock is in an upward trend, downward trend, or stable for each window period.\n\n    The function takes two parameters:\n    - prices: A list of integers representing daily stock prices\n    - window: An integer representing the number of days to consider for each trend analysis\n\n    The function should return a list of strings where each string is either \"UP\", \"DOWN\", or \"STABLE\" representing the trend\n    for each window period. A trend is considered:\n    - \"UP\" if the price at the end of the window is higher than the price at the start\n    - \"DOWN\" if the price at the end of the window is lower than the price at the start\n    - \"STABLE\" if the price at the end of the window is the same as the price at the start\n\n\n    [EXAMPLES]\n    \n    assert candidate([15, 14, 13, 12, 11, 10, 9, 8], 3) == ['DOWN', 'DOWN', 'DOWN', 'DOWN', 'DOWN', 'DOWN']\n    assert candidate([1, 3, 5, 7, 9, 11, 13, 15], 4) == ['UP', 'UP', 'UP', 'UP', 'UP']\n\n    [/EXAMPLES]\n    \"\"\"\n    def determine_trend(start_price: int, end_price: int) -> str:\n        if end_price > start_price:\n            return \"UP\"\n        elif end_price < start_price:\n            return \"DOWN\"\n        else:\n            return \"STABLE\"\n\n    trends = []\n    for i in range(len(prices) - window + 1):\n        start_price = prices[i]\n        end_price = prices[i + window - 1]\n        trends.append(determine_trend(start_price, end_price))\n\n    return trends\n\n", "test": "def check(candidate):\n    assert candidate([100, 100, 100, 100, 100], 3) == ['STABLE', 'STABLE', 'STABLE']\n    assert candidate([1, 2], 2) == ['UP']\n    assert candidate([100, 102, 98, 105, 108, 109], 3) == ['DOWN', 'UP', 'UP', 'UP']\n    assert candidate([100, 90, 80, 70, 80, 90, 100], 3) == ['DOWN', 'DOWN', 'STABLE', 'UP', 'UP']\n    assert candidate([10, 20, 30, 40, 50], 1) == ['STABLE', 'STABLE', 'STABLE', 'STABLE', 'STABLE']\n    assert candidate([15, 14, 13, 12, 11, 10, 9, 8], 3) == ['DOWN', 'DOWN', 'DOWN', 'DOWN', 'DOWN', 'DOWN']\n    assert candidate([3, 3, 3, 2, 2, 2, 1, 1, 1], 3) == ['STABLE', 'DOWN', 'DOWN', 'STABLE', 'DOWN', 'DOWN', 'STABLE']\n    assert candidate([1, 2, 3, 4, 5, 6, 7, 8, 9, 10], 10) == ['UP']\n    assert candidate([10000, 1000, 100, 10, 1], 2) == ['DOWN', 'DOWN', 'DOWN', 'DOWN']\n    assert candidate([1, 3, 5, 7, 9, 11, 13, 15], 4) == ['UP', 'UP', 'UP', 'UP', 'UP']\n", "language": "python"}
{"task_id": "47600a01-c1a0-400a-ac86-c1837c292f3f-288654201820026709", "prompt": "As a coding assistant, your role is to finalize an existing function so that it can be executed within a code block without modifications. Refrain from providing any code outside the function's scope. Utilize only the libraries that are specified in the problem statement. If additional functions or classes are necessary, define them exclusively within the given function.\n\n```python\ndef calculate_rocket_fuel(distance: float, payload_mass: float) -> float:\n    \"\"\"\n    Calculate the amount of rocket fuel needed for a space mission based on the distance to be traveled\n    and the mass of the payload. The function uses a simplified model of rocket propulsion and fuel consumption.\n\n    Args:\n    distance (float): The distance to be traveled in kilometers.\n    payload_mass (float): The mass of the payload in kilograms.\n\n    Returns:\n    float: The amount of fuel needed in liters.\n\n\n    [EXAMPLES]\n    \n    assert candidate(1.61803398875, 1.41421356237) == 0.1619178111555633\n    assert candidate(1e12, 1e12) == 5.00000001e+19\n\n    [/EXAMPLES]\n    \"\"\"\n```\n", "entry_point": "calculate_rocket_fuel", "solution": "def calculate_rocket_fuel(distance: float, payload_mass: float) -> float:\n    \"\"\"\n    Calculate the amount of rocket fuel needed for a space mission based on the distance to be traveled\n    and the mass of the payload. The function uses a simplified model of rocket propulsion and fuel consumption.\n\n    Args:\n    distance (float): The distance to be traveled in kilometers.\n    payload_mass (float): The mass of the payload in kilograms.\n\n    Returns:\n    float: The amount of fuel needed in liters.\n\n\n    [EXAMPLES]\n    \n    assert candidate(1.61803398875, 1.41421356237) == 0.1619178111555633\n    assert candidate(1e12, 1e12) == 5.00000001e+19\n\n    [/EXAMPLES]\n    \"\"\"\n    # Constants\n    BASE_FUEL_CONSUMPTION = 0.1  # liters per kilometer\n    PAYLOAD_FUEL_FACTOR = 0.05  # additional fuel per kg of payload per 1000 km\n\n    # Calculate base fuel needed for the distance\n    base_fuel = distance * BASE_FUEL_CONSUMPTION\n\n    # Calculate additional fuel needed for the payload\n    payload_fuel = (distance / 1000) * payload_mass * PAYLOAD_FUEL_FACTOR\n\n    # Total fuel needed\n    total_fuel = base_fuel + payload_fuel\n\n    return total_fuel\n\n", "test": "def check(candidate):\n    assert candidate(1e6, 1e6) == 50100000.0\n    assert candidate(1e12, 1e12) == 5.00000001e+19\n    assert candidate(1.61803398875, 1.41421356237) == 0.1619178111555633\n    assert candidate(10000, 10000) == 6000.0\n    assert candidate(1e9, 1e9) == 50000100000000.0\n    assert candidate(0.01, 0.01) == 0.001000005\n    assert candidate(3.14159, 2.71828) == 0.31458598606326005\n    assert candidate(1, 1) == 0.10005\n", "language": "python"}
{"task_id": "fee138c3-5d1b-4769-b668-c56f0e3c374d6023295148508313578", "prompt": "Implement the rest of the function according to the given doc string specifications. Place the full function in one code block, and make certain to consider and handle edge cases in your implementation.\n\n```python\ndef calculate_investment_growth(initial: float, monthly: float, rate: float, years: int) -> float:\n    \"\"\"\n    As a financial advisor, you need to calculate the future value of an investment\n    for your client. The investment has an initial lump sum, monthly contributions,\n    and compounds annually at a fixed interest rate.\n\n    Parameters:\n    initial: The initial lump sum investment\n    monthly: The monthly contribution\n    rate: The annual interest rate (as a decimal, e.g., 0.05 for 5%)\n    years: The number of years for the investment to grow\n\n    Return the final value of the investment rounded to 2 decimal places.\n\n\n    [EXAMPLES]\n    \n    assert candidate(1000, 50, 0.10, 40) == 337370.34\n    assert candidate(60000, 600, 0.075, 14) == 345998.87\n\n    [/EXAMPLES]\n    \"\"\"\n```\n", "entry_point": "calculate_investment_growth", "solution": "def calculate_investment_growth(initial: float, monthly: float, rate: float, years: int) -> float:\n    \"\"\"\n    As a financial advisor, you need to calculate the future value of an investment\n    for your client. The investment has an initial lump sum, monthly contributions,\n    and compounds annually at a fixed interest rate.\n\n    Parameters:\n    initial: The initial lump sum investment\n    monthly: The monthly contribution\n    rate: The annual interest rate (as a decimal, e.g., 0.05 for 5%)\n    years: The number of years for the investment to grow\n\n    Return the final value of the investment rounded to 2 decimal places.\n\n\n    [EXAMPLES]\n    \n    assert candidate(1000, 50, 0.10, 40) == 337370.34\n    assert candidate(60000, 600, 0.075, 14) == 345998.87\n\n    [/EXAMPLES]\n    \"\"\"\n    total = initial\n    annual_contribution = monthly * 12\n\n    for _ in range(years):\n        total += annual_contribution\n        total *= (1 + rate)\n\n    return round(total, 2)\n\n", "test": "def check(candidate):\n    assert candidate(60000, 600, 0.075, 14) == 345998.87\n    assert candidate(1000, 50, 0.10, 40) == 337370.34\n    assert candidate(15000, 150, 0.045, 18) == 83641.59\n    assert candidate(2000, 25, 0.11, 50) == 924830.45\n    assert candidate(90000, 900, 0.025, 9) == 222594.19\n", "language": "python"}
{"task_id": "d0ac1925-341c-436b-b8cc-791721181f99-3016353855831073107", "prompt": "Let's fill in the function body to match the specifications outlined in the docstring. I'll write the complete function, including the docstring, in one cohesive code block.\n\n```python\ndef calculate_biodiversity_index(species_counts: str) -> float:\n    \"\"\"\n    An ecologist is studying the biodiversity of a forest ecosystem. They have collected data on the number of individuals\n    of each species present in a given area. The biodiversity index is calculated using a special formula that takes into\n    account both the number of species and their relative abundances.\n\n    This function takes a string representing the counts of different species, separated by commas, and returns the\n    biodiversity index rounded to four decimal places.\n\n    The calculation involves string parsing, mathematical operations, and handling of floating-point numbers.\n\n\n    [EXAMPLES]\n    \n    assert candidate(\"2,4,8,16,32,64\") == 1.3045\n    assert candidate(\"10,20,15,5\") == 1.2799\n\n    [/EXAMPLES]\n    \"\"\"\n```\n", "entry_point": "calculate_biodiversity_index", "solution": "def calculate_biodiversity_index(species_counts: str) -> float:\n    \"\"\"\n    An ecologist is studying the biodiversity of a forest ecosystem. They have collected data on the number of individuals\n    of each species present in a given area. The biodiversity index is calculated using a special formula that takes into\n    account both the number of species and their relative abundances.\n\n    This function takes a string representing the counts of different species, separated by commas, and returns the\n    biodiversity index rounded to four decimal places.\n\n    The calculation involves string parsing, mathematical operations, and handling of floating-point numbers.\n\n\n    [EXAMPLES]\n    \n    assert candidate(\"2,4,8,16,32,64\") == 1.3045\n    assert candidate(\"10,20,15,5\") == 1.2799\n\n    [/EXAMPLES]\n    \"\"\"\n    import math\n\n    # Parse the input string into a list of integers\n    counts = [int(count) for count in species_counts.split(',')]\n    \n    # Calculate the total number of individuals\n    total = sum(counts)\n    \n    # Calculate the Shannon diversity index\n    shannon_index = 0\n    for count in counts:\n        if count > 0:  # Avoid log(0)\n            proportion = count / total\n            shannon_index -= proportion * math.log(proportion)\n    \n    # Return the result rounded to 4 decimal places\n    return round(shannon_index, 4)\n\n", "test": "def check(candidate):\n    assert candidate(\"1,2,3,4,5,6,7,8,9,10\") == 2.1513\n    assert candidate(\"1,1,1,1,1,1,1,1,1,100\") == 0.4664\n    assert candidate(\"1,10,100,1000\") == 0.3602\n    assert candidate(\"10,20,15,5\") == 1.2799\n    assert candidate(\"100,50,25,12,6,3\") == 1.2962\n    assert candidate(\"50,40,30,20,10\") == 1.4898\n    assert candidate(\"500,400,300,200,100\") == 1.4898\n    assert candidate(\"2,4,8,16,32,64\") == 1.3045\n    assert candidate(\"1000,100,10,1\") == 0.3602\n    assert candidate(\"1000,1,1,1,1\") == 0.0315\n", "language": "python"}
{"task_id": "41cf729e-3641-449a-8c5c-d35699b7090f2716572101927673047", "prompt": "Construct the function within a code block, following the directions outlined in the docstring. Complete the function according to the instructions provided in the docstring. Ensure that any supplementary functions or classes are declared exclusively inside the given function.\n\n```python\ndef calculate_compound_interest(principal: float, rate: float, time: int, compounds: int) -> float:\n    \"\"\"\n    A financial advisor needs to calculate the compound interest for their clients' investments.\n    This function computes the final amount after applying compound interest.\n\n    Parameters:\n    principal (float): The initial investment amount.\n    rate (float): The annual interest rate (as a decimal).\n    time (int): The time period in years.\n    compounds (int): The number of times interest is compounded per year.\n\n    Returns:\n    float: The final amount after applying compound interest, rounded to two decimal places.\n\n\n    [EXAMPLES]\n    \n    assert candidate(300, 0.12, 3, 365) == 429.97\n    assert candidate(750, 0.08, 4, 6) == 1030.66\n\n    [/EXAMPLES]\n    \"\"\"\n```\n", "entry_point": "calculate_compound_interest", "solution": "def calculate_compound_interest(principal: float, rate: float, time: int, compounds: int) -> float:\n    \"\"\"\n    A financial advisor needs to calculate the compound interest for their clients' investments.\n    This function computes the final amount after applying compound interest.\n\n    Parameters:\n    principal (float): The initial investment amount.\n    rate (float): The annual interest rate (as a decimal).\n    time (int): The time period in years.\n    compounds (int): The number of times interest is compounded per year.\n\n    Returns:\n    float: The final amount after applying compound interest, rounded to two decimal places.\n\n\n    [EXAMPLES]\n    \n    assert candidate(300, 0.12, 3, 365) == 429.97\n    assert candidate(750, 0.08, 4, 6) == 1030.66\n\n    [/EXAMPLES]\n    \"\"\"\n    # Calculate the compound interest using the formula:\n    # A = P * (1 + r/n)^(n*t)\n    # Where:\n    # A = final amount\n    # P = principal balance\n    # r = annual interest rate\n    # n = number of times interest is compounded per year\n    # t = number of years\n\n    final_amount = principal * (1 + rate / compounds) ** (compounds * time)\n    \n    # Round the result to two decimal places\n    return round(final_amount, 2)\n\n", "test": "def check(candidate):\n    assert candidate(999999.99, 0.0001, 50, 365) == 1005012.51\n    assert candidate(1000, 0.05, 5, 12) == 1283.36\n    assert candidate(750, 0.08, 4, 6) == 1030.66\n    assert candidate(3000, 0.045, 8, 24) == 4298.54\n    assert candidate(300, 0.12, 3, 365) == 429.97\n    assert candidate(5000, 0.07, 10, 4) == 10007.99\n    assert candidate(7500, 0.04, 9, 2) == 10711.85\n    assert candidate(500, 0.1, 2, 365) == 610.68\n    assert candidate(15000, 0.055, 11, 6) == 27393.18\n    assert candidate(200, 0.15, 1, 52) == 232.32\n", "language": "python"}
{"task_id": "56330b1c-bef1-44bd-8af3-665ded11676c169630115976354034", "prompt": "You are required to finish a predefined function that is executable as-is in one code block. Do not add any code external to the function. Limit yourself to using only the libraries that are imported in the problem description. If you need to create helper functions or classes, nest them within the main function. Present your solution as a single code block.\n\n```python\ndef compress_data(data: str) -> str:\n    \"\"\"\n    A data scientist needs to compress a string of data before transmission.\n    Implement a run-length encoding algorithm that replaces consecutive repeated characters with the character followed by the count.\n\n    If a character is not repeated, it should not be followed by a count.\n    The compressed string should not be longer than the original string.\n\n\n    [EXAMPLES]\n    \n    assert candidate(\"ABCDEFGHIJKLMNOPQRSTUVWXYZ\") == 'ABCDEFGHIJKLMNOPQRSTUVWXYZ'\n    assert candidate(\"A\" * 100) == 'A100'\n\n    [/EXAMPLES]\n    \"\"\"\n```\n", "entry_point": "compress_data", "solution": "def compress_data(data: str) -> str:\n    \"\"\"\n    A data scientist needs to compress a string of data before transmission.\n    Implement a run-length encoding algorithm that replaces consecutive repeated characters with the character followed by the count.\n\n    If a character is not repeated, it should not be followed by a count.\n    The compressed string should not be longer than the original string.\n\n\n    [EXAMPLES]\n    \n    assert candidate(\"ABCDEFGHIJKLMNOPQRSTUVWXYZ\") == 'ABCDEFGHIJKLMNOPQRSTUVWXYZ'\n    assert candidate(\"A\" * 100) == 'A100'\n\n    [/EXAMPLES]\n    \"\"\"\n    if not data:\n        return \"\"\n\n    compressed = []\n    count = 1\n    for i in range(1, len(data)):\n        if data[i] == data[i-1]:\n            count += 1\n        else:\n            compressed.append(data[i-1])\n            if count > 1:\n                compressed.append(str(count))\n            count = 1\n\n    compressed.append(data[-1])\n    if count > 1:\n        compressed.append(str(count))\n\n    compressed_str = ''.join(compressed)\n    return compressed_str if len(compressed_str) < len(data) else data\n\n", "test": "def check(candidate):\n    assert candidate(\"ABCDEFGHIJKLMNOPQRSTUVWXYZ\") == 'ABCDEFGHIJKLMNOPQRSTUVWXYZ'\n    assert candidate(\"A\" * 100) == 'A100'\n    assert candidate(\"WWWWWWWWWWWWBWWWWWWWWWWWWBBBWWWWWWWWWWWWWWWWWWB\") == 'W12BW12B3W18B'\n    assert candidate(\"AABAA\") == 'AABAA'\n    assert candidate(\"AAABBBCCCDDD\") == 'A3B3C3D3'\n    assert candidate(\"A\" * 50 + \"B\" * 50) == 'A50B50'\n    assert candidate(\"ABABABABABAB\") == 'ABABABABABAB'\n    assert candidate(\"ABC\" * 33 + \"A\") == 'ABCABCABCABCABCABCABCABCABCABCABCABCABCABCABCABCABCABCABCABCABCABCABCABCABCABCABCABCABCABCABCABCABCA'\n    assert candidate(\"AAAAA\") == 'A5'\n    assert candidate(\"XYZ\" * 10) == 'XYZXYZXYZXYZXYZXYZXYZXYZXYZXYZ'\n", "language": "python"}
{"task_id": "e694aa33-6948-4143-9cfd-f971a4d748b04698872139271140086", "prompt": "Within a code block, adhere to the guidelines provided in the doc string to finalize the function. Implement any supplementary functions or classes exclusively within the confines of the specified function.\n\n```python\nfrom typing import List\n\ndef calculate_stock_span(prices: List[int]) -> List[int]:\n    \"\"\"\n    In stock market analysis, the span of a stock's price on a given day is defined as\n    the maximum number of consecutive days (starting from that day and going backward)\n    for which the stock price was less than or equal to the price on that given day.\n\n    Given a list of daily stock prices, calculate the span of the stock's price for each day.\n\n    Use a stack-based approach to solve this problem efficiently.\n\n\n    [EXAMPLES]\n    \n    assert candidate([10, 9, 8, 7, 6, 5, 4, 3, 2, 1]) == [1, 1, 1, 1, 1, 1, 1, 1, 1, 1]\n    assert candidate([5, 3, 2, 4, 7, 1]) == [1, 1, 1, 3, 5, 1]\n\n    [/EXAMPLES]\n    \"\"\"\n```\n", "entry_point": "calculate_stock_span", "solution": "from typing import List\n\ndef calculate_stock_span(prices: List[int]) -> List[int]:\n    \"\"\"\n    In stock market analysis, the span of a stock's price on a given day is defined as\n    the maximum number of consecutive days (starting from that day and going backward)\n    for which the stock price was less than or equal to the price on that given day.\n\n    Given a list of daily stock prices, calculate the span of the stock's price for each day.\n\n    Use a stack-based approach to solve this problem efficiently.\n\n\n    [EXAMPLES]\n    \n    assert candidate([10, 9, 8, 7, 6, 5, 4, 3, 2, 1]) == [1, 1, 1, 1, 1, 1, 1, 1, 1, 1]\n    assert candidate([5, 3, 2, 4, 7, 1]) == [1, 1, 1, 3, 5, 1]\n\n    [/EXAMPLES]\n    \"\"\"\n    n = len(prices)\n    spans = [1] * n  # Initialize all spans to 1\n    stack = []  # Stack to store indices\n\n    for i in range(n):\n        # Pop elements from stack while stack is not empty and \n        # price at top of stack is less than or equal to current price\n        while stack and prices[stack[-1]] <= prices[i]:\n            stack.pop()\n        \n        # If stack is not empty, calculate span\n        if stack:\n            spans[i] = i - stack[-1]\n        else:\n            spans[i] = i + 1\n        \n        # Push current index to stack\n        stack.append(i)\n\n    return spans\n\n", "test": "def check(candidate):\n    assert candidate([3, 3, 3, 3, 3, 3, 3]) == [1, 2, 3, 4, 5, 6, 7]\n    assert candidate([50, 60, 70, 80, 90, 100]) == [1, 2, 3, 4, 5, 6]\n    assert candidate([100, 60, 70, 65, 80, 85]) == [1, 1, 2, 1, 4, 5]\n    assert candidate([10, 9, 8, 7, 6, 5, 4, 3, 2, 1]) == [1, 1, 1, 1, 1, 1, 1, 1, 1, 1]\n    assert candidate([1, 5, 2, 3, 4, 6]) == [1, 2, 1, 2, 3, 6]\n    assert candidate([100, 80, 60, 70, 60, 75, 85, 90]) == [1, 1, 1, 2, 1, 4, 6, 7]\n    assert candidate([1, 2, 3, 4, 5, 4, 3, 2, 1]) == [1, 2, 3, 4, 5, 1, 1, 1, 1]\n    assert candidate([10, 20, 30, 40, 30, 20, 10]) == [1, 2, 3, 4, 1, 1, 1]\n    assert candidate([5, 3, 2, 4, 7, 1]) == [1, 1, 1, 3, 5, 1]\n    assert candidate([100, 80, 60, 70, 60, 75, 85]) == [1, 1, 1, 2, 1, 4, 6]\n", "language": "python"}
{"task_id": "a59cc0be-7e8a-4363-b257-1714f09020d61084800017462022656", "prompt": "Execute the function according to the specifications in the docstring. Ensure all code is contained within one block. If extra functions or classes are needed, define them within the main function's scope.\n\n```python\nfrom typing import List, Tuple\n\ndef morse_code_translator(message: str, mode: str) -> str:\n    \"\"\"\n    As a radio operator in a historical reenactment society, you need to translate messages between Morse code and English text.\n    This function takes a message and a mode ('encode' or 'decode') as input, and returns the translated message.\n\n    For encoding, the function should convert English text to Morse code.\n    For decoding, it should convert Morse code to English text.\n\n    Use a space to separate Morse code characters and a forward slash (/) to separate words in Morse code.\n    Ignore any characters that are not in the Morse code dictionary.\n\n\n    [EXAMPLES]\n    \n    assert candidate(\"-- --- .-. ... . / -.-. --- -.. .\", \"decode\") == 'MORSE CODE'\n    assert candidate(\"MORSE CODE\", \"encode\") == '-- --- .-. ... . / -.-. --- -.. .'\n\n    [/EXAMPLES]\n    \"\"\"\n```\n", "entry_point": "morse_code_translator", "solution": "from typing import List, Tuple\n\ndef morse_code_translator(message: str, mode: str) -> str:\n    \"\"\"\n    As a radio operator in a historical reenactment society, you need to translate messages between Morse code and English text.\n    This function takes a message and a mode ('encode' or 'decode') as input, and returns the translated message.\n\n    For encoding, the function should convert English text to Morse code.\n    For decoding, it should convert Morse code to English text.\n\n    Use a space to separate Morse code characters and a forward slash (/) to separate words in Morse code.\n    Ignore any characters that are not in the Morse code dictionary.\n\n\n    [EXAMPLES]\n    \n    assert candidate(\"-- --- .-. ... . / -.-. --- -.. .\", \"decode\") == 'MORSE CODE'\n    assert candidate(\"MORSE CODE\", \"encode\") == '-- --- .-. ... . / -.-. --- -.. .'\n\n    [/EXAMPLES]\n    \"\"\"\n    morse_code_dict = {\n        'A': '.-', 'B': '-...', 'C': '-.-.', 'D': '-..', 'E': '.', 'F': '..-.',\n        'G': '--.', 'H': '....', 'I': '..', 'J': '.---', 'K': '-.-', 'L': '.-..',\n        'M': '--', 'N': '-.', 'O': '---', 'P': '.--.', 'Q': '--.-', 'R': '.-.',\n        'S': '...', 'T': '-', 'U': '..-', 'V': '...-', 'W': '.--', 'X': '-..-',\n        'Y': '-.--', 'Z': '--..', '0': '-----', '1': '.----', '2': '..---',\n        '3': '...--', '4': '....-', '5': '.....', '6': '-....', '7': '--...',\n        '8': '---..', '9': '----.'\n    }\n    \n    def encode(text: str) -> str:\n        words = text.upper().split()\n        encoded_words = []\n        for word in words:\n            encoded_word = ' '.join(morse_code_dict.get(char, '') for char in word if char in morse_code_dict)\n            if encoded_word:\n                encoded_words.append(encoded_word)\n        return ' / '.join(encoded_words)\n    \n    def decode(morse: str) -> str:\n        reverse_dict = {v: k for k, v in morse_code_dict.items()}\n        words = morse.split(' / ')\n        decoded_words = []\n        for word in words:\n            chars = word.split()\n            decoded_word = ''.join(reverse_dict.get(char, '') for char in chars)\n            if decoded_word:\n                decoded_words.append(decoded_word)\n        return ' '.join(decoded_words)\n    \n    if mode.lower() == 'encode':\n        return encode(message)\n    elif mode.lower() == 'decode':\n        return decode(message)\n    else:\n        raise ValueError(\"Mode must be either 'encode' or 'decode'\")\n\n", "test": "def check(candidate):\n    assert candidate(\"UPPER lower\", \"encode\") == '..- .--. .--. . .-. / .-.. --- .-- . .-.'\n    assert candidate(\"  MULTIPLE   SPACES  \", \"encode\") == '-- ..- .-.. - .. .--. .-.. . / ... .--. .- -.-. . ...'\n    assert candidate(\"- .... . / --.- ..- .. -.-. -.- / -... .-. --- .-- -. / ..-. --- -..- / .--- ..- -- .--. ... / --- ...- . .-. / - .... . / .-.. .- --.. -.-- / -.. --- --.\", \"decode\") == 'THE QUICK BROWN FOX JUMPS OVER THE LAZY DOG'\n    assert candidate(\"MORSE CODE\", \"encode\") == '-- --- .-. ... . / -.-. --- -.. .'\n    assert candidate(\"HELLO WORLD\", \"encode\") == '.... . .-.. .-.. --- / .-- --- .-. .-.. -..'\n    assert candidate(\"SOS\", \"encode\") == '... --- ...'\n    assert candidate(\"-- --- .-. ... . / -.-. --- -.. .\", \"decode\") == 'MORSE CODE'\n    assert candidate(\"\", \"encode\") == ''\n    assert candidate(\".... . .-.. .-.. --- / .-- --- .-. .-.. -..\", \"decode\") == 'HELLO WORLD'\n    assert candidate(\"... --- ...\", \"decode\") == 'SOS'\n", "language": "python"}
{"task_id": "13c23dd7-261f-4cff-8f7c-fb2d33815b71-3977386784945734697", "prompt": "Abide by the specifications laid out in the docstring to complete the function in a single, self-contained code block. Any auxiliary functions or classes should be established exclusively within the given function's scope.\n\n```python\nfrom typing import List\n\ndef calculate_tournament_points(matches: List[List[int]]) -> int:\n    \"\"\"\n    In a chess tournament, players earn points based on their game outcomes.\n    This function calculates the total points earned by a player in the tournament.\n\n    The input is a list of lists, where each inner list represents a match result:\n    [1] for a win, [0] for a draw, and [-1] for a loss.\n    A win is worth 3 points, a draw is worth 1 point, and a loss is worth 0 points.\n\n\n    [EXAMPLES]\n    \n    assert candidate([[1], [1], [0], [0], [-1], [-1]]) == 8\n    assert candidate([[1]] * 5 + [[-1]] * 5) == 15\n\n    [/EXAMPLES]\n    \"\"\"\n```\n", "entry_point": "calculate_tournament_points", "solution": "from typing import List\n\ndef calculate_tournament_points(matches: List[List[int]]) -> int:\n    \"\"\"\n    In a chess tournament, players earn points based on their game outcomes.\n    This function calculates the total points earned by a player in the tournament.\n\n    The input is a list of lists, where each inner list represents a match result:\n    [1] for a win, [0] for a draw, and [-1] for a loss.\n    A win is worth 3 points, a draw is worth 1 point, and a loss is worth 0 points.\n\n\n    [EXAMPLES]\n    \n    assert candidate([[1], [1], [0], [0], [-1], [-1]]) == 8\n    assert candidate([[1]] * 5 + [[-1]] * 5) == 15\n\n    [/EXAMPLES]\n    \"\"\"\n    def match_points(result):\n        if result[0] == 1:\n            return 3\n        elif result[0] == 0:\n            return 1\n        else:\n            return 0\n\n    total_points = sum(match_points(match) for match in matches)\n    return total_points\n\n", "test": "def check(candidate):\n    assert candidate([[1], [1], [-1], [-1], [0]]) == 7\n    assert candidate([[1]] * 5 + [[-1]] * 5) == 15\n    assert candidate([[1], [-1], [0], [1], [-1], [0]]) == 8\n    assert candidate([[1], [-1]] * 50) == 150\n    assert candidate([[1], [1], [1], [1], [1]]) == 15\n    assert candidate([[0], [1], [-1]] * 3) == 12\n    assert candidate([[1], [1], [0], [0], [-1], [-1]]) == 8\n    assert candidate([[-1], [-1], [-1], [-1], [-1]]) == 0\n    assert candidate([[1], [1], [1], [0], [0], [-1], [-1], [-1]]) == 11\n    assert candidate([[1], [0], [1], [-1], [1]]) == 10\n", "language": "python"}
{"task_id": "2c7be5c2-072d-4611-9f92-10f8eebf20778628049384295598403", "prompt": "Your mission is to finalize a designated function that can be executed as-is in a code block. Refrain from adding code outside the function's boundaries. Limit yourself to using only the libraries imported in the problem statement. Should you need to define additional functions or classes, do so exclusively within the given function.\n\n```python\ndef binary_tree_serializer(tree: dict) -> str:\n    \"\"\"\n    You are tasked with creating a serialization method for binary trees. Each node in the tree contains a single-digit integer value and references to its left and right children. Your function should convert the tree into a string representation.\n\n    The serialization should be done in a depth-first manner, where:\n    - A node's value is added to the string.\n    - If a node has a left child, add 'L' before serializing the left subtree.\n    - If a node has a right child, add 'R' before serializing the right subtree.\n    - If a node doesn't have a left or right child, add 'X' for that direction.\n\n\n    [EXAMPLES]\n    \n    assert candidate({'val': 4, 'left': {'val': 2, 'left': {'val': 1, 'left': None, 'right': None}, 'right': {'val': 3, 'left': None, 'right': None}}, 'right': {'val': 6, 'left': {'val': 5, 'left': None, 'right': None}, 'right': {'val': 7, 'left': None, 'right': None}}}) == '4L2L1XXR3XXR6L5XXR7XX'\n    assert candidate({'val': 5, 'left': {'val': 3, 'left': None, 'right': None}, 'right': {'val': 7, 'left': None, 'right': None}}) == '5L3XXR7XX'\n\n    [/EXAMPLES]\n    \"\"\"\n```\n", "entry_point": "binary_tree_serializer", "solution": "def binary_tree_serializer(tree: dict) -> str:\n    \"\"\"\n    You are tasked with creating a serialization method for binary trees. Each node in the tree contains a single-digit integer value and references to its left and right children. Your function should convert the tree into a string representation.\n\n    The serialization should be done in a depth-first manner, where:\n    - A node's value is added to the string.\n    - If a node has a left child, add 'L' before serializing the left subtree.\n    - If a node has a right child, add 'R' before serializing the right subtree.\n    - If a node doesn't have a left or right child, add 'X' for that direction.\n\n\n    [EXAMPLES]\n    \n    assert candidate({'val': 4, 'left': {'val': 2, 'left': {'val': 1, 'left': None, 'right': None}, 'right': {'val': 3, 'left': None, 'right': None}}, 'right': {'val': 6, 'left': {'val': 5, 'left': None, 'right': None}, 'right': {'val': 7, 'left': None, 'right': None}}}) == '4L2L1XXR3XXR6L5XXR7XX'\n    assert candidate({'val': 5, 'left': {'val': 3, 'left': None, 'right': None}, 'right': {'val': 7, 'left': None, 'right': None}}) == '5L3XXR7XX'\n\n    [/EXAMPLES]\n    \"\"\"\n    def serialize_node(node):\n        if node is None:\n            return \"X\"\n        \n        result = str(node['val'])\n        \n        if node['left'] is not None:\n            result += \"L\" + serialize_node(node['left'])\n        else:\n            result += \"X\"\n        \n        if node['right'] is not None:\n            result += \"R\" + serialize_node(node['right'])\n        else:\n            result += \"X\"\n        \n        return result\n    \n    return serialize_node(tree)\n\n", "test": "def check(candidate):\n    assert candidate({'val': 8, 'left': {'val': 8, 'left': {'val': 8, 'left': None, 'right': None}, 'right': {'val': 8, 'left': None, 'right': None}}, 'right': {'val': 8, 'left': {'val': 8, 'left': None, 'right': None}, 'right': {'val': 8, 'left': None, 'right': None}}}) == '8L8L8XXR8XXR8L8XXR8XX'\n    assert candidate({'val': 1, 'left': {'val': 2, 'left': None, 'right': None}, 'right': {'val': 3, 'left': {'val': 4, 'left': None, 'right': None}, 'right': {'val': 5, 'left': None, 'right': None}}}) == '1L2XXR3L4XXR5XX'\n    assert candidate({'val': 7, 'left': {'val': 3, 'left': {'val': 1, 'left': None, 'right': None}, 'right': {'val': 5, 'left': None, 'right': None}}, 'right': {'val': 9, 'left': {'val': 8, 'left': None, 'right': None}, 'right': None}}) == '7L3L1XXR5XXR9L8XXX'\n    assert candidate({'val': 1, 'left': None, 'right': None}) == '1XX'\n    assert candidate({'val': 4, 'left': {'val': 2, 'left': {'val': 1, 'left': None, 'right': None}, 'right': {'val': 3, 'left': None, 'right': None}}, 'right': {'val': 6, 'left': {'val': 5, 'left': None, 'right': None}, 'right': {'val': 7, 'left': None, 'right': None}}}) == '4L2L1XXR3XXR6L5XXR7XX'\n    assert candidate({'val': 1, 'left': None, 'right': {'val': 2, 'left': None, 'right': {'val': 3, 'left': None, 'right': {'val': 4, 'left': None, 'right': {'val': 5, 'left': None, 'right': None}}}}}) == '1XR2XR3XR4XR5XX'\n    assert candidate({'val': 2, 'left': {'val': 1, 'left': None, 'right': None}, 'right': None}) == '2L1XXX'\n    assert candidate({'val': 5, 'left': {'val': 3, 'left': {'val': 2, 'left': None, 'right': None}, 'right': {'val': 4, 'left': None, 'right': None}}, 'right': {'val': 7, 'left': {'val': 6, 'left': None, 'right': None}, 'right': {'val': 8, 'left': None, 'right': None}}}) == '5L3L2XXR4XXR7L6XXR8XX'\n    assert candidate({'val': 5, 'left': {'val': 3, 'left': None, 'right': None}, 'right': {'val': 7, 'left': None, 'right': None}}) == '5L3XXR7XX'\n    assert candidate({'val': 0, 'left': {'val': 0, 'left': None, 'right': None}, 'right': {'val': 0, 'left': None, 'right': None}}) == '0L0XXR0XX'\n", "language": "python"}
{"task_id": "814282bc-d11f-41c1-9799-3b0abe19e4b63251020735204237432", "prompt": "Your primary duty as a coding assistant is to finalize a given function that can be executed directly in a code block. Avoid presenting code outside the function's boundaries. Employ only the libraries that are explicitly imported in the problem. Any supplementary functions or classes must be defined internally within the given function.\n\n```python\ndef encrypt_message(message: str, key: str) -> str:\n    \"\"\"\n    A secret agent needs to encrypt a message using a special cipher. The cipher works by shifting each letter\n    in the message by the corresponding letter in the repeating key. Shifting is done based on letter position\n    in the alphabet (A=0, B=1, ..., Z=25). The result wraps around the alphabet.\n\n    Parameters:\n    message (str): The message to be encrypted (uppercase letters only).\n    key (str): The encryption key (uppercase letters only).\n\n    Returns:\n    str: The encrypted message.\n\n\n    [EXAMPLES]\n    \n    assert candidate(\"TESTING\", \"TEST\") == 'MIKMBRY'\n    assert candidate(\"ABCDEFGHIJKLMNOPQRSTUVWXYZ\", \"KEY\") == 'KFANIDQLGTOJWRMZUPCXSFAVID'\n\n    [/EXAMPLES]\n    \"\"\"\n```\n", "entry_point": "encrypt_message", "solution": "def encrypt_message(message: str, key: str) -> str:\n    \"\"\"\n    A secret agent needs to encrypt a message using a special cipher. The cipher works by shifting each letter\n    in the message by the corresponding letter in the repeating key. Shifting is done based on letter position\n    in the alphabet (A=0, B=1, ..., Z=25). The result wraps around the alphabet.\n\n    Parameters:\n    message (str): The message to be encrypted (uppercase letters only).\n    key (str): The encryption key (uppercase letters only).\n\n    Returns:\n    str: The encrypted message.\n\n\n    [EXAMPLES]\n    \n    assert candidate(\"TESTING\", \"TEST\") == 'MIKMBRY'\n    assert candidate(\"ABCDEFGHIJKLMNOPQRSTUVWXYZ\", \"KEY\") == 'KFANIDQLGTOJWRMZUPCXSFAVID'\n\n    [/EXAMPLES]\n    \"\"\"\n    def letter_to_number(letter):\n        return ord(letter) - ord('A')\n\n    def number_to_letter(number):\n        return chr((number % 26) + ord('A'))\n\n    encrypted = []\n    key_length = len(key)\n    \n    for i, char in enumerate(message):\n        message_num = letter_to_number(char)\n        key_num = letter_to_number(key[i % key_length])\n        encrypted_num = (message_num + key_num) % 26\n        encrypted.append(number_to_letter(encrypted_num))\n    \n    return ''.join(encrypted)\n\n", "test": "def check(candidate):\n    assert candidate(\"ABCDEFGHIJKLMNOPQRSTUVWXYZ\", \"KEY\") == 'KFANIDQLGTOJWRMZUPCXSFAVID'\n    assert candidate(\"EDGECASE\", \"Z\") == 'DCFDBZRD'\n    assert candidate(\"SINGLECHARACTER\", \"S\") == 'KAFYDWUZSJSULWJ'\n    assert candidate(\"TESTING\", \"TEST\") == 'MIKMBRY'\n    assert candidate(\"X\", \"LONGKEY\") == 'I'\n    assert candidate(\"AAAAA\", \"BBBBB\") == 'BBBBB'\n    assert candidate(\"AEIOU\", \"AEIOU\") == 'AIQCO'\n    assert candidate(\"ABCDE\", \"VWXYZ\") == 'VXZBD'\n    assert candidate(\"LOOOONGMESSAGE\", \"A\") == 'LOOOONGMESSAGE'\n    assert candidate(\"THISISATEST\", \"CIPHER\") == 'VPXZMJCBTZX'\n", "language": "python"}
{"task_id": "52eb0ced-faca-489e-bb3f-7f62ab4260133398949538290173531", "prompt": "For the sake of clarity, please submit the entire code as a single, self-contained code block.\n\n```python\nfrom typing import List\n\ndef space_colony(resources: List[int], colonists: int) -> int:\n    \"\"\"\n    In a future space colonization mission, you are tasked with distributing essential resources among colonists.\n    Each colonist requires exactly one unit of each resource type to survive. The resources are stored in separate\n    containers, represented by the list 'resources', where each element denotes the quantity of a specific resource.\n    Your goal is to determine the maximum number of complete resource sets that can be distributed, ensuring no\n    colonist receives an incomplete set.\n\n    Parameters:\n    resources (List[int]): A list of integers representing the quantity of each resource type available.\n    colonists (int): The total number of colonists in the space colony.\n\n    Returns:\n    int: The maximum number of complete resource sets that can be distributed.\n\n\n    [EXAMPLES]\n    \n    assert candidate([100000, 1, 100000], 2) == 1\n    assert candidate([1, 1, 1, 1, 1, 1, 1, 1, 1, 1], 10) == 1\n\n    [/EXAMPLES]\n    \"\"\"\n```\n", "entry_point": "space_colony", "solution": "from typing import List\n\ndef space_colony(resources: List[int], colonists: int) -> int:\n    \"\"\"\n    In a future space colonization mission, you are tasked with distributing essential resources among colonists.\n    Each colonist requires exactly one unit of each resource type to survive. The resources are stored in separate\n    containers, represented by the list 'resources', where each element denotes the quantity of a specific resource.\n    Your goal is to determine the maximum number of complete resource sets that can be distributed, ensuring no\n    colonist receives an incomplete set.\n\n    Parameters:\n    resources (List[int]): A list of integers representing the quantity of each resource type available.\n    colonists (int): The total number of colonists in the space colony.\n\n    Returns:\n    int: The maximum number of complete resource sets that can be distributed.\n\n\n    [EXAMPLES]\n    \n    assert candidate([100000, 1, 100000], 2) == 1\n    assert candidate([1, 1, 1, 1, 1, 1, 1, 1, 1, 1], 10) == 1\n\n    [/EXAMPLES]\n    \"\"\"\n    if not resources:\n        return 0\n    \n    # Find the minimum quantity among all resources\n    min_resource = min(resources)\n    \n    # The maximum number of complete sets is the minimum of:\n    # 1. The minimum quantity among all resources\n    # 2. The number of colonists\n    max_sets = min(min_resource, colonists)\n    \n    return max_sets\n\n", "test": "def check(candidate):\n    assert candidate([100000, 1, 100000], 2) == 1\n    assert candidate([10, 8, 6, 4, 2], 5) == 2\n    assert candidate([1, 1, 1], 1) == 1\n    assert candidate([], 0) == 0\n    assert candidate([5, 3, 7, 2], 4) == 2\n    assert candidate([1, 2, 3, 4, 5, 6, 7, 8, 9, 10], 5) == 1\n    assert candidate([0, 0, 0], 5) == 0\n    assert candidate([1000000, 1000000, 1000000], 1000000) == 1000000\n    assert candidate([1, 1, 1, 1, 1, 1, 1, 1, 1, 1], 10) == 1\n    assert candidate([1, 2, 3, 4, 5], 3) == 1\n", "language": "python"}
{"task_id": "8d607ff2-94f1-4fdd-a0ba-e7d9803b72062119630207261594067", "prompt": "Complete the function's code according to the specifications in the documentation string. Present the full function in one cohesive code block.\n\n```python\nfrom typing import List\n\ndef merge_sorted_arrays(arr1: List[int], arr2: List[int]) -> List[int]:\n    \"\"\"\n    Merge two sorted arrays into a single sorted array without using any built-in sorting functions.\n\n    This function takes two sorted arrays as input and returns a new array that contains all elements from both input arrays in sorted order. The function should maintain the time complexity of O(n + m), where n and m are the lengths of arr1 and arr2 respectively.\n\n\n    [EXAMPLES]\n    \n    assert candidate([2, 4, 6], [1, 3, 5]) == [1, 2, 3, 4, 5, 6]\n    assert candidate([-5, -3, -1], [-4, -2, 0]) == [-5, -4, -3, -2, -1, 0]\n\n    [/EXAMPLES]\n    \"\"\"\n```\n", "entry_point": "merge_sorted_arrays", "solution": "from typing import List\n\ndef merge_sorted_arrays(arr1: List[int], arr2: List[int]) -> List[int]:\n    \"\"\"\n    Merge two sorted arrays into a single sorted array without using any built-in sorting functions.\n\n    This function takes two sorted arrays as input and returns a new array that contains all elements from both input arrays in sorted order. The function should maintain the time complexity of O(n + m), where n and m are the lengths of arr1 and arr2 respectively.\n\n\n    [EXAMPLES]\n    \n    assert candidate([2, 4, 6], [1, 3, 5]) == [1, 2, 3, 4, 5, 6]\n    assert candidate([-5, -3, -1], [-4, -2, 0]) == [-5, -4, -3, -2, -1, 0]\n\n    [/EXAMPLES]\n    \"\"\"\n    result = []\n    i, j = 0, 0\n    \n    while i < len(arr1) and j < len(arr2):\n        if arr1[i] <= arr2[j]:\n            result.append(arr1[i])\n            i += 1\n        else:\n            result.append(arr2[j])\n            j += 1\n    \n    # Append remaining elements from arr1, if any\n    while i < len(arr1):\n        result.append(arr1[i])\n        i += 1\n    \n    # Append remaining elements from arr2, if any\n    while j < len(arr2):\n        result.append(arr2[j])\n        j += 1\n    \n    return result\n\n", "test": "def check(candidate):\n    assert candidate([2, 4, 6], [1, 3, 5]) == [1, 2, 3, 4, 5, 6]\n    assert candidate([-5, -3, -1], [-4, -2, 0]) == [-5, -4, -3, -2, -1, 0]\n    assert candidate([1, 1, 2, 2], [1, 2, 3, 3]) == [1, 1, 1, 2, 2, 2, 3, 3]\n    assert candidate([-3, -1, 0, 2], [-2, 1, 3]) == [-3, -2, -1, 0, 1, 2, 3]\n    assert candidate([1], []) == [1]\n    assert candidate([-10, -5, 0, 5, 10], [-7, -2, 3, 8]) == [-10, -7, -5, -2, 0, 3, 5, 8, 10]\n    assert candidate([4, 5, 6], [1, 2, 3]) == [1, 2, 3, 4, 5, 6]\n    assert candidate([-1000000, 0, 1000000], [-999999, 999999]) == [-1000000, -999999, 0, 999999, 1000000]\n    assert candidate([], [1, 2, 3, 4, 5]) == [1, 2, 3, 4, 5]\n    assert candidate([1, 2, 3, 4, 5], []) == [1, 2, 3, 4, 5]\n", "language": "python"}
{"task_id": "0a1aba37-7a99-4c1d-895e-e175042a81cf6450812327236168223", "prompt": "Within a code block, implement the function as specified in the docstring. Any supplementary functions or classes should be defined exclusively within the provided function's scope. Adhere strictly to the guidelines outlined in the docstring.\n\n```python\ndef decode_morse_code(message: str) -> str:\n    \"\"\"\n    In a historical communications project, we need to decode messages written in Morse code.\n    This function takes a string of Morse code as input, where words are separated by three spaces\n    and letters within a word are separated by a single space. It returns the decoded message in\n    uppercase English letters.\n\n    The function uses dictionary operations and string methods to perform the decoding.\n\n\n    [EXAMPLES]\n    \n    assert candidate(\"-----   .----   ..---   ...--   ....-   .....   -....   --...   ---..   ----.\") == '0 1 2 3 4 5 6 7 8 9'\n    assert candidate(\"- . ... -   -.-. .- ... .   ..-. --- .-.   -- --- .-. ... .   -.-. --- -.. .   -.. . -.-. --- -.. . .-.\") == 'TEST CASE FOR MORSE CODE DECODER'\n\n    [/EXAMPLES]\n    \"\"\"\n```\n", "entry_point": "decode_morse_code", "solution": "def decode_morse_code(message: str) -> str:\n    \"\"\"\n    In a historical communications project, we need to decode messages written in Morse code.\n    This function takes a string of Morse code as input, where words are separated by three spaces\n    and letters within a word are separated by a single space. It returns the decoded message in\n    uppercase English letters.\n\n    The function uses dictionary operations and string methods to perform the decoding.\n\n\n    [EXAMPLES]\n    \n    assert candidate(\"-----   .----   ..---   ...--   ....-   .....   -....   --...   ---..   ----.\") == '0 1 2 3 4 5 6 7 8 9'\n    assert candidate(\"- . ... -   -.-. .- ... .   ..-. --- .-.   -- --- .-. ... .   -.-. --- -.. .   -.. . -.-. --- -.. . .-.\") == 'TEST CASE FOR MORSE CODE DECODER'\n\n    [/EXAMPLES]\n    \"\"\"\n    # Morse code dictionary\n    morse_code_dict = {\n        '.-': 'A', '-...': 'B', '-.-.': 'C', '-..': 'D', '.': 'E', '..-.': 'F',\n        '--.': 'G', '....': 'H', '..': 'I', '.---': 'J', '-.-': 'K', '.-..': 'L',\n        '--': 'M', '-.': 'N', '---': 'O', '.--.': 'P', '--.-': 'Q', '.-.': 'R',\n        '...': 'S', '-': 'T', '..-': 'U', '...-': 'V', '.--': 'W', '-..-': 'X',\n        '-.--': 'Y', '--..': 'Z', '-----': '0', '.----': '1', '..---': '2',\n        '...--': '3', '....-': '4', '.....': '5', '-....': '6', '--...': '7',\n        '---..': '8', '----.': '9'\n    }\n\n    # Split the message into words\n    words = message.split('   ')\n    \n    # Decode each word\n    decoded_words = []\n    for word in words:\n        # Split the word into letters\n        letters = word.split()\n        # Decode each letter\n        decoded_word = ''.join(morse_code_dict.get(letter, '') for letter in letters)\n        decoded_words.append(decoded_word)\n    \n    # Join the decoded words with spaces\n    decoded_message = ' '.join(decoded_words)\n    \n    return decoded_message\n\n", "test": "def check(candidate):\n    assert candidate(\".-\") == 'A'\n    assert candidate(\"-\") == 'T'\n    assert candidate(\"-----   .----   ..---   ...--   ....-   .....   -....   --...   ---..   ----.\") == '0 1 2 3 4 5 6 7 8 9'\n    assert candidate(\"\") == ''\n    assert candidate(\"-...\") == 'B'\n    assert candidate(\"...   ---   ...\") == 'S O S'\n    assert candidate(\"- .... .   --.- ..- .. -.-. -.-   -... .-. --- .-- -.   ..-. --- -..-\") == 'THE QUICK BROWN FOX'\n    assert candidate(\"- . ... -   -.-. .- ... .   ..-. --- .-.   -- --- .-. ... .   -.-. --- -.. .   -.. . -.-. --- -.. . .-.\") == 'TEST CASE FOR MORSE CODE DECODER'\n    assert candidate(\".- -... -.-. -.. . ..-. --. .... .. .--- -.- .-.. -- -. --- .--. --.- .-. ... - ..- ...- .-- -..- -.-- --..\") == 'ABCDEFGHIJKLMNOPQRSTUVWXYZ'\n    assert candidate(\"... --- ...\") == 'SOS'\n", "language": "python"}
{"task_id": "a9bb124a-fd95-4a87-aedc-25192d5d34d3-6401693841715573955", "prompt": "Implement the remaining part of the function as described in the documentation string. Include the full function in a single code block.\n\n```python\nfrom typing import List\n\ndef encrypt_message(message: str, key: List[int]) -> str:\n    \"\"\"\n    In a secret society, members communicate using a special encryption method. Each letter in their message is shifted\n    by a corresponding number in a repeating key sequence. The shift wraps around the alphabet (26 letters, A-Z).\n\n    This function takes a message (uppercase letters only) and a key (list of integers) as input, and returns the\n    encrypted message using the described method.\n\n    Args:\n    message (str): The message to be encrypted (uppercase letters only)\n    key (List[int]): The repeating key sequence used for shifting letters\n\n    Returns:\n    str: The encrypted message\n\n\n    [EXAMPLES]\n    \n    assert candidate(\"ABCDEFGHIJKLMNOPQRSTUVWXYZ\", [1]) == 'BCDEFGHIJKLMNOPQRSTUVWXYZA'\n    assert candidate(\"LONGERKEY\", [1, 2, 3, 4, 5]) == 'MQQKJSMHC'\n\n    [/EXAMPLES]\n    \"\"\"\n```\n", "entry_point": "encrypt_message", "solution": "from typing import List\n\ndef encrypt_message(message: str, key: List[int]) -> str:\n    \"\"\"\n    In a secret society, members communicate using a special encryption method. Each letter in their message is shifted\n    by a corresponding number in a repeating key sequence. The shift wraps around the alphabet (26 letters, A-Z).\n\n    This function takes a message (uppercase letters only) and a key (list of integers) as input, and returns the\n    encrypted message using the described method.\n\n    Args:\n    message (str): The message to be encrypted (uppercase letters only)\n    key (List[int]): The repeating key sequence used for shifting letters\n\n    Returns:\n    str: The encrypted message\n\n\n    [EXAMPLES]\n    \n    assert candidate(\"ABCDEFGHIJKLMNOPQRSTUVWXYZ\", [1]) == 'BCDEFGHIJKLMNOPQRSTUVWXYZA'\n    assert candidate(\"LONGERKEY\", [1, 2, 3, 4, 5]) == 'MQQKJSMHC'\n\n    [/EXAMPLES]\n    \"\"\"\n    def shift_letter(letter: str, shift: int) -> str:\n        if not letter.isalpha():\n            return letter\n        return chr((ord(letter) - 65 + shift) % 26 + 65)\n\n    encrypted = []\n    key_length = len(key)\n    \n    for i, char in enumerate(message):\n        shift = key[i % key_length]\n        encrypted.append(shift_letter(char, shift))\n    \n    return ''.join(encrypted)\n\n", "test": "def check(candidate):\n    assert candidate(\"ZZZZZ\", [26, 26, 26, 26, 26]) == 'ZZZZZ'\n    assert candidate(\"ABCDEFGHIJKLMNOPQRSTUVWXYZ\", [1]) == 'BCDEFGHIJKLMNOPQRSTUVWXYZA'\n    assert candidate(\"NOCRYPT\", [-1, -2, -3]) == 'MMZQWMS'\n    assert candidate(\"BBB\", [26, 26, 26]) == 'BBB'\n    assert candidate(\"WRAPAROUND\", [25, 26, 27]) == 'VRBOASNUOC'\n    assert candidate(\"CCC\", [27, 28, 29]) == 'DEF'\n    assert candidate(\"TEST\", [100]) == 'PAOP'\n    assert candidate(\"MIXEDSHIFT\", [5, -3, 7, 0]) == 'RFEEIPOIKQ'\n    assert candidate(\"ZEROMESSAGE\", [0, 0, 0, 0, 0]) == 'ZEROMESSAGE'\n    assert candidate(\"LONGERKEY\", [1, 2, 3, 4, 5]) == 'MQQKJSMHC'\n", "language": "python"}
{"task_id": "31aa3604-4bbe-4eab-b716-5982962d93e71513851850762896853", "prompt": "Implement the function as specified in the doc string, enclosing it within a code block. Any necessary auxiliary functions or classes should be defined exclusively within the scope of the provided function.\n\n```python\nfrom collections import deque\nfrom typing import List, Tuple\n\ndef maze_solver(maze: List[List[int]], start: Tuple[int, int], end: Tuple[int, int]) -> List[Tuple[int, int]]:\n    \"\"\"\n    Find the shortest path through a maze from start to end using breadth-first search.\n    \n    The function takes a 2D list representing the maze (0 for open paths, 1 for walls),\n    a start coordinate tuple, and an end coordinate tuple. It returns a list of coordinate\n    tuples representing the shortest path from start to end, or an empty list if no path exists.\n    \n    The maze is navigated using only up, down, left, and right movements. Diagonal movements\n    are not allowed. The returned path should include both the start and end coordinates.\n\n\n    [EXAMPLES]\n    \n    assert candidate([[0,0,1,0],[0,0,1,0],[0,0,1,0],[0,0,0,0]], (0,0), (3,3)) == [(0, 0), (0, 1), (1, 1), (2, 1), (3, 1), (3, 2), (3, 3)]\n    assert candidate([[0,0,0,0,0],[1,1,1,1,0],[0,0,0,1,0],[0,1,0,1,0],[0,1,0,0,0]], (0,0), (4,4)) == [(0, 0), (0, 1), (0, 2), (0, 3), (0, 4), (1, 4), (2, 4), (3, 4), (4, 4)]\n\n    [/EXAMPLES]\n    \"\"\"\n```\n", "entry_point": "maze_solver", "solution": "from collections import deque\nfrom typing import List, Tuple\n\ndef maze_solver(maze: List[List[int]], start: Tuple[int, int], end: Tuple[int, int]) -> List[Tuple[int, int]]:\n    \"\"\"\n    Find the shortest path through a maze from start to end using breadth-first search.\n    \n    The function takes a 2D list representing the maze (0 for open paths, 1 for walls),\n    a start coordinate tuple, and an end coordinate tuple. It returns a list of coordinate\n    tuples representing the shortest path from start to end, or an empty list if no path exists.\n    \n    The maze is navigated using only up, down, left, and right movements. Diagonal movements\n    are not allowed. The returned path should include both the start and end coordinates.\n\n\n    [EXAMPLES]\n    \n    assert candidate([[0,0,1,0],[0,0,1,0],[0,0,1,0],[0,0,0,0]], (0,0), (3,3)) == [(0, 0), (0, 1), (1, 1), (2, 1), (3, 1), (3, 2), (3, 3)]\n    assert candidate([[0,0,0,0,0],[1,1,1,1,0],[0,0,0,1,0],[0,1,0,1,0],[0,1,0,0,0]], (0,0), (4,4)) == [(0, 0), (0, 1), (0, 2), (0, 3), (0, 4), (1, 4), (2, 4), (3, 4), (4, 4)]\n\n    [/EXAMPLES]\n    \"\"\"\n    def is_valid(x: int, y: int) -> bool:\n        return 0 <= x < len(maze) and 0 <= y < len(maze[0]) and maze[x][y] == 0\n\n    def get_neighbors(x: int, y: int) -> List[Tuple[int, int]]:\n        directions = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n        return [(x + dx, y + dy) for dx, dy in directions if is_valid(x + dx, y + dy)]\n\n    queue = deque([(start, [start])])\n    visited = set([start])\n\n    while queue:\n        (x, y), path = queue.popleft()\n\n        if (x, y) == end:\n            return path\n\n        for nx, ny in get_neighbors(x, y):\n            if (nx, ny) not in visited:\n                visited.add((nx, ny))\n                queue.append(((nx, ny), path + [(nx, ny)]))\n\n    return []\n\n", "test": "def check(candidate):\n    assert candidate([[0,1,0],[0,1,0],[0,1,0]], (0,0), (2,2)) == []\n    assert candidate([[0,0,0,0,0],[1,1,1,1,0],[0,0,0,1,0],[0,1,0,1,0],[0,1,0,0,0]], (0,0), (4,4)) == [(0, 0), (0, 1), (0, 2), (0, 3), (0, 4), (1, 4), (2, 4), (3, 4), (4, 4)]\n    assert candidate([[0,0,1,0],[0,0,1,0],[0,0,1,0],[0,0,0,0]], (0,0), (3,3)) == [(0, 0), (0, 1), (1, 1), (2, 1), (3, 1), (3, 2), (3, 3)]\n    assert candidate([[0,0,0],[0,1,0],[0,0,0]], (0,0), (1,1)) == []\n    assert candidate([[0,0,0],[0,1,0],[0,0,0]], (1,0), (1,2)) == [(1, 0), (2, 0), (2, 1), (2, 2), (1, 2)]\n    assert candidate([[0,0,0,0,0],[0,1,1,1,0],[0,1,0,1,0],[0,1,0,1,0],[0,0,0,0,0]], (0,0), (4,4)) == [(0, 0), (0, 1), (0, 2), (0, 3), (0, 4), (1, 4), (2, 4), (3, 4), (4, 4)]\n    assert candidate([[0,0,0],[0,1,0],[0,0,0]], (0,0), (2,2)) == [(0, 0), (0, 1), (0, 2), (1, 2), (2, 2)]\n    assert candidate([[0,0,0],[1,1,1],[0,0,0]], (0,0), (2,2)) == []\n    assert candidate([[0,0],[0,0]], (0,0), (1,1)) == [(0, 0), (0, 1), (1, 1)]\n    assert candidate([[0,0,0],[1,1,0],[0,0,0]], (2,0), (0,2)) == [(2, 0), (2, 1), (2, 2), (1, 2), (0, 2)]\n", "language": "python"}
{"task_id": "3c2ec3ec-a328-49e5-a5ae-5ed033d004a0-3227483839967112409", "prompt": "Finalize the incomplete code by adding the necessary elements, all within a single block of code.\n\n```python\nfrom typing import List\n\ndef treasure_hunt(map_size: int, traps: List[List[int]], treasure: List[int]) -> int:\n    \"\"\"\n    An adventurer is on a treasure hunt in a mysterious island. The island is represented as a square grid of size 'map_size'.\n    There are several traps on the island, represented by their coordinates in the 'traps' list.\n    The treasure is located at the coordinates given in the 'treasure' list.\n    The adventurer starts at position (0, 0) and can move only right or down.\n    Calculate the number of unique safe paths from the starting point to the treasure.\n\n\n    [EXAMPLES]\n    \n    assert candidate(5, [[1,1],[2,2],[3,3]], [4,4]) == 10\n    assert candidate(2, [[0,1],[1,0]], [1,1]) == 0\n\n    [/EXAMPLES]\n    \"\"\"\n```\n", "entry_point": "treasure_hunt", "solution": "from typing import List\n\ndef treasure_hunt(map_size: int, traps: List[List[int]], treasure: List[int]) -> int:\n    \"\"\"\n    An adventurer is on a treasure hunt in a mysterious island. The island is represented as a square grid of size 'map_size'.\n    There are several traps on the island, represented by their coordinates in the 'traps' list.\n    The treasure is located at the coordinates given in the 'treasure' list.\n    The adventurer starts at position (0, 0) and can move only right or down.\n    Calculate the number of unique safe paths from the starting point to the treasure.\n\n\n    [EXAMPLES]\n    \n    assert candidate(5, [[1,1],[2,2],[3,3]], [4,4]) == 10\n    assert candidate(2, [[0,1],[1,0]], [1,1]) == 0\n\n    [/EXAMPLES]\n    \"\"\"\n    # Create a set of trap coordinates for faster lookup\n    trap_set = set(map(tuple, traps))\n    \n    # Create a 2D grid to store the number of paths to each cell\n    grid = [[0] * map_size for _ in range(map_size)]\n    \n    # Initialize the starting point\n    grid[0][0] = 1 if (0, 0) not in trap_set else 0\n    \n    # Fill the first row\n    for j in range(1, map_size):\n        if (0, j) not in trap_set:\n            grid[0][j] = grid[0][j-1]\n    \n    # Fill the first column\n    for i in range(1, map_size):\n        if (i, 0) not in trap_set:\n            grid[i][0] = grid[i-1][0]\n    \n    # Fill the rest of the grid\n    for i in range(1, map_size):\n        for j in range(1, map_size):\n            if (i, j) not in trap_set:\n                grid[i][j] = grid[i-1][j] + grid[i][j-1]\n    \n    # Return the number of paths to the treasure\n    return grid[treasure[0]][treasure[1]]\n\n", "test": "def check(candidate):\n    assert candidate(5, [[1,1],[2,2],[3,3]], [3,4]) == 5\n    assert candidate(5, [[1,1],[2,2],[3,3],[4,4]], [4,4]) == 0\n    assert candidate(3, [[0,1],[1,0]], [2,2]) == 0\n    assert candidate(5, [[0,1],[1,0],[2,2],[3,3],[4,4]], [4,4]) == 0\n    assert candidate(3, [[1,1]], [1,2]) == 1\n    assert candidate(2, [[0,1],[1,0]], [1,1]) == 0\n    assert candidate(5, [[0,1],[1,0],[2,2],[3,3]], [4,4]) == 0\n    assert candidate(2, [], [1,1]) == 2\n    assert candidate(4, [[1,1],[1,2],[2,1]], [3,3]) == 2\n    assert candidate(5, [[1,1],[2,2],[3,3]], [4,4]) == 10\n", "language": "python"}
{"task_id": "7500d734-06e1-448d-b134-6eab300e47d86581153517285710048", "prompt": "Using the doc string as a guide, complete the remainder of the function. Enclose the entire function in a single code block and be sure to address any potential edge scenarios.\n\n```python\nfrom typing import List\n\ndef decrypt_ancient_scroll(encrypted_text: str, codex: List[str]) -> str:\n    \"\"\"\n    As an archaeologist, you've discovered an ancient scroll with encrypted text. You also found a codex\n    that seems to hold the key to decrypting the scroll. Your task is to create a function that can\n    decrypt the scroll's message using the codex.\n\n    The encrypted text is a string of lowercase letters and spaces. The codex is a list of strings where\n    each string represents a decryption rule. Each rule is in the format \"X:Y\", where X is the encrypted\n    character and Y is the decrypted character.\n\n    The function should return the decrypted message as a string.\n\n\n    [EXAMPLES]\n    \n    assert candidate(\"vvvvv\", [\"v:x\"]) == 'xxxxx'\n    assert candidate(\"zyxwvutsrqponmlkjihgfedcba\", [\"a:z\", \"b:y\", \"c:x\", \"d:w\", \"e:v\", \"f:u\", \"g:t\", \"h:s\", \"i:r\", \"j:q\", \"k:p\", \"l:o\", \"m:n\", \"n:m\", \"o:l\", \"p:k\", \"q:j\", \"r:i\", \"s:h\", \"t:g\", \"u:f\", \"v:e\", \"w:d\", \"x:c\", \"y:b\", \"z:a\"]) == 'abcdefghijklmnopqrstuvwxyz'\n\n    [/EXAMPLES]\n    \"\"\"\n```\n", "entry_point": "decrypt_ancient_scroll", "solution": "from typing import List\n\ndef decrypt_ancient_scroll(encrypted_text: str, codex: List[str]) -> str:\n    \"\"\"\n    As an archaeologist, you've discovered an ancient scroll with encrypted text. You also found a codex\n    that seems to hold the key to decrypting the scroll. Your task is to create a function that can\n    decrypt the scroll's message using the codex.\n\n    The encrypted text is a string of lowercase letters and spaces. The codex is a list of strings where\n    each string represents a decryption rule. Each rule is in the format \"X:Y\", where X is the encrypted\n    character and Y is the decrypted character.\n\n    The function should return the decrypted message as a string.\n\n\n    [EXAMPLES]\n    \n    assert candidate(\"vvvvv\", [\"v:x\"]) == 'xxxxx'\n    assert candidate(\"zyxwvutsrqponmlkjihgfedcba\", [\"a:z\", \"b:y\", \"c:x\", \"d:w\", \"e:v\", \"f:u\", \"g:t\", \"h:s\", \"i:r\", \"j:q\", \"k:p\", \"l:o\", \"m:n\", \"n:m\", \"o:l\", \"p:k\", \"q:j\", \"r:i\", \"s:h\", \"t:g\", \"u:f\", \"v:e\", \"w:d\", \"x:c\", \"y:b\", \"z:a\"]) == 'abcdefghijklmnopqrstuvwxyz'\n\n    [/EXAMPLES]\n    \"\"\"\n    # Create a dictionary to store the decryption rules\n    decryption_dict = {}\n    \n    # Parse the codex and populate the decryption dictionary\n    for rule in codex:\n        encrypted, decrypted = rule.split(':')\n        decryption_dict[encrypted] = decrypted\n    \n    # Decrypt the text\n    decrypted_text = \"\"\n    for char in encrypted_text:\n        if char in decryption_dict:\n            decrypted_text += decryption_dict[char]\n        else:\n            # If the character is not in the codex (e.g., space), keep it as is\n            decrypted_text += char\n    \n    return decrypted_text\n\n", "test": "def check(candidate):\n    assert candidate(\"the quick brown fox jumps over the lazy dog\", [\"a:z\", \"b:y\", \"c:x\", \"d:w\", \"e:v\", \"f:u\", \"g:t\", \"h:s\", \"i:r\", \"j:q\", \"k:p\", \"l:o\", \"m:n\", \"n:m\", \"o:l\", \"p:k\", \"q:j\", \"r:i\", \"s:h\", \"t:g\", \"u:f\", \"v:e\", \"w:d\", \"x:c\", \"y:b\", \"z:a\"]) == 'gsv jfrxp yildm ulc qfnkh levi gsv ozab wlt'\n    assert candidate(\"abc\", [\"a:z\", \"b:y\", \"c:x\"]) == 'zyx'\n    assert candidate(\"xyz\", [\"x:a\", \"y:b\", \"z:c\"]) == 'abc'\n    assert candidate(\"a1b2c3\", [\"a:1\", \"b:2\", \"c:3\", \"1:a\", \"2:b\", \"3:c\"]) == '1a2b3c'\n    assert candidate(\"abc def ghi\", [\"a:1\", \"b:2\", \"c:3\", \"d:4\", \"e:5\", \"f:6\", \"g:7\", \"h:8\", \"i:9\"]) == '123 456 789'\n    assert candidate(\"zyxwvutsrqponmlkjihgfedcba\", [\"a:z\", \"b:y\", \"c:x\", \"d:w\", \"e:v\", \"f:u\", \"g:t\", \"h:s\", \"i:r\", \"j:q\", \"k:p\", \"l:o\", \"m:n\", \"n:m\", \"o:l\", \"p:k\", \"q:j\", \"r:i\", \"s:h\", \"t:g\", \"u:f\", \"v:e\", \"w:d\", \"x:c\", \"y:b\", \"z:a\"]) == 'abcdefghijklmnopqrstuvwxyz'\n    assert candidate(\"abcdefghijklmnopqrstuvwxyz\", [\"a:1\", \"b:2\", \"c:3\", \"d:4\", \"e:5\", \"f:6\", \"g:7\", \"h:8\", \"i:9\", \"j:10\", \"k:11\", \"l:12\", \"m:13\", \"n:14\", \"o:15\", \"p:16\", \"q:17\", \"r:18\", \"s:19\", \"t:20\", \"u:21\", \"v:22\", \"w:23\", \"x:24\", \"y:25\", \"z:26\"]) == '1234567891011121314151617181920212223242526'\n    assert candidate(\"vvvvv\", [\"v:x\"]) == 'xxxxx'\n    assert candidate(\"\", []) == ''\n    assert candidate(\"aabbccddee\", [\"a:1\", \"b:2\", \"c:3\", \"d:4\", \"e:5\"]) == '1122334455'\n", "language": "python"}
{"task_id": "a34c111c-0ae0-46e1-99fd-7ac0b46ff7a22470097725353803975", "prompt": "Following the docstring's directions, finish the function implementation within a single code block. Include any required auxiliary functions or classes within the main function. Stick closely to the docstring's instructions throughout.\n\n```python\ndef compress_genome_sequence(sequence: str) -> str:\n    \"\"\"\n    A bioinformatics researcher wants to compress long DNA sequences to save\n    storage space. The compression algorithm works as follows:\n    1. Consecutive repeated nucleotides are replaced with the count followed\n       by the nucleotide.\n    2. Single nucleotides are left as is.\n    3. The compression should be case-insensitive, but preserve the original case.\n\n    This function takes a DNA sequence as input and returns the compressed sequence.\n    Valid nucleotides are A, C, G, and T (case-insensitive).\n\n\n    [EXAMPLES]\n    \n    assert candidate(\"AAAcccGGGttt\") == '3A3c3G3t'\n    assert candidate(\"AAAACCCCGGGGTTTT\") == '4A4C4G4T'\n\n    [/EXAMPLES]\n    \"\"\"\n```\n", "entry_point": "compress_genome_sequence", "solution": "def compress_genome_sequence(sequence: str) -> str:\n    \"\"\"\n    A bioinformatics researcher wants to compress long DNA sequences to save\n    storage space. The compression algorithm works as follows:\n    1. Consecutive repeated nucleotides are replaced with the count followed\n       by the nucleotide.\n    2. Single nucleotides are left as is.\n    3. The compression should be case-insensitive, but preserve the original case.\n\n    This function takes a DNA sequence as input and returns the compressed sequence.\n    Valid nucleotides are A, C, G, and T (case-insensitive).\n\n\n    [EXAMPLES]\n    \n    assert candidate(\"AAAcccGGGttt\") == '3A3c3G3t'\n    assert candidate(\"AAAACCCCGGGGTTTT\") == '4A4C4G4T'\n\n    [/EXAMPLES]\n    \"\"\"\n    if not sequence:\n        return \"\"\n\n    compressed = []\n    count = 1\n    prev_char = sequence[0]\n\n    for char in sequence[1:]:\n        if char.upper() == prev_char.upper():\n            count += 1\n        else:\n            if count > 1:\n                compressed.append(f\"{count}{prev_char}\")\n            else:\n                compressed.append(prev_char)\n            count = 1\n            prev_char = char\n\n    # Handle the last group of nucleotides\n    if count > 1:\n        compressed.append(f\"{count}{prev_char}\")\n    else:\n        compressed.append(prev_char)\n\n    return \"\".join(compressed)\n\n", "test": "def check(candidate):\n    assert candidate(\"AAAcccGGGttt\") == '3A3c3G3t'\n    assert candidate(\"TTTTTTTTTTTTTTTTt\") == '17T'\n    assert candidate(\"A\") == 'A'\n    assert candidate(\"ACGTacgt\") == 'ACGTacgt'\n    assert candidate(\"ATGC\") == 'ATGC'\n    assert candidate(\"AAAAACCCCCAATGGG\") == '5A5C2AT3G'\n    assert candidate(\"aaaa\") == '4a'\n    assert candidate(\"AAAACCCCGGGGTTTT\") == '4A4C4G4T'\n    assert candidate(\"ATGCATGCatgcatgc\") == 'ATGCATGCatgcatgc'\n    assert candidate(\"ACGTACGTACGT\") == 'ACGTACGTACGT'\n", "language": "python"}
{"task_id": "9a234a30-2244-4b45-a66b-a16734cd384d1144387435250856697", "prompt": "I'm working on this piece of code and need help completing it. Can you fill in the blanks while keeping everything in one code block?\n\n```python\nfrom typing import List\n\ndef decode_alien_message(encoded: str, dictionary: List[str]) -> int:\n    \"\"\"An alien civilization has sent an encoded message to Earth. Scientists have partially decrypted it and\n    need your help to determine the number of possible original messages.\n\n    The encoded message is a string 'encoded' consisting of lowercase English letters.\n    The 'dictionary' is a list of valid alien words that could have been used to create the message.\n\n    Your task is to calculate and return the number of possible ways to decode the entire encoded message\n    using words from the dictionary. Each word from the dictionary can be used multiple times.\n\n    If the encoded message cannot be fully decoded using the given dictionary, return 0.\n\n    Use dynamic programming to solve this problem efficiently.\n\n\n    [EXAMPLES]\n    \n    assert candidate(\"xyzxyz\", [\"x\", \"y\", \"z\", \"xy\", \"yz\"]) == 9\n    assert candidate(\"abababab\", [\"ab\", \"ba\"]) == 1\n\n    [/EXAMPLES]\n    \"\"\"\n```\n", "entry_point": "decode_alien_message", "solution": "from typing import List\n\ndef decode_alien_message(encoded: str, dictionary: List[str]) -> int:\n    \"\"\"An alien civilization has sent an encoded message to Earth. Scientists have partially decrypted it and\n    need your help to determine the number of possible original messages.\n\n    The encoded message is a string 'encoded' consisting of lowercase English letters.\n    The 'dictionary' is a list of valid alien words that could have been used to create the message.\n\n    Your task is to calculate and return the number of possible ways to decode the entire encoded message\n    using words from the dictionary. Each word from the dictionary can be used multiple times.\n\n    If the encoded message cannot be fully decoded using the given dictionary, return 0.\n\n    Use dynamic programming to solve this problem efficiently.\n\n\n    [EXAMPLES]\n    \n    assert candidate(\"xyzxyz\", [\"x\", \"y\", \"z\", \"xy\", \"yz\"]) == 9\n    assert candidate(\"abababab\", [\"ab\", \"ba\"]) == 1\n\n    [/EXAMPLES]\n    \"\"\"\n    n = len(encoded)\n    dp = [0] * (n + 1)\n    dp[0] = 1  # Empty string can be decoded in one way\n\n    for i in range(1, n + 1):\n        for word in dictionary:\n            if i >= len(word) and encoded[i - len(word):i] == word:\n                dp[i] += dp[i - len(word)]\n\n    return dp[n]\n\n", "test": "def check(candidate):\n    assert candidate(\"abababab\", [\"ab\", \"ba\"]) == 1\n    assert candidate(\"xyzxyz\", [\"x\", \"y\", \"z\", \"xy\", \"yz\"]) == 9\n    assert candidate(\"abcd\", [\"ab\", \"cd\"]) == 1\n    assert candidate(\"codecodecode\", [\"co\", \"cod\", \"code\", \"de\"]) == 8\n    assert candidate(\"aaaa\", [\"a\", \"aa\", \"aaa\"]) == 7\n    assert candidate(\"abcde\", [\"ab\", \"cd\", \"e\"]) == 1\n    assert candidate(\"abc\" * 33 + \"a\", [\"a\", \"b\", \"c\", \"ab\", \"bc\", \"abc\"]) == 73786976294838206464\n    assert candidate(\"aaa\", [\"a\", \"aa\"]) == 3\n    assert candidate(\"a\" * 100, [\"a\"]) == 1\n    assert candidate(\"ab\", [\"a\", \"b\"]) == 1\n", "language": "python"}
{"task_id": "16706cb7-e992-4d78-9f56-a0b00c7831bf-7211471960183960878", "prompt": "Please complete the function based on the provided documentation string. Present the entire function within a single code block.\n\n```python\nfrom typing import List\nfrom collections import deque\n\ndef maze_escape(maze: List[List[int]], start: List[int], end: List[int]) -> int:\n    \"\"\"\n    In a virtual reality game, players must navigate through a complex maze filled with traps and obstacles.\n    The maze is represented as a 2D grid where 0 represents a safe path and 1 represents a trap.\n    Players start at a given position and must reach the exit while avoiding traps.\n    This function calculates the minimum number of moves required to escape the maze.\n\n    Args:\n    maze (List[List[int]]): A 2D list representing the maze layout\n    start (List[int]): Starting coordinates [row, col]\n    end (List[int]): Exit coordinates [row, col]\n\n    Returns:\n    int: Minimum number of moves to escape the maze, or -1 if impossible\n\n\n    [EXAMPLES]\n    \n    assert candidate([[0, 0, 1], [0, 1, 0], [1, 0, 0]], [0, 0], [2, 2]) == -1\n    assert candidate([[1, 1, 1], [1, 0, 1], [1, 1, 1]], [1, 1], [1, 1]) == 0\n\n    [/EXAMPLES]\n    \"\"\"\n```\n", "entry_point": "maze_escape", "solution": "from typing import List\nfrom collections import deque\n\ndef maze_escape(maze: List[List[int]], start: List[int], end: List[int]) -> int:\n    \"\"\"\n    In a virtual reality game, players must navigate through a complex maze filled with traps and obstacles.\n    The maze is represented as a 2D grid where 0 represents a safe path and 1 represents a trap.\n    Players start at a given position and must reach the exit while avoiding traps.\n    This function calculates the minimum number of moves required to escape the maze.\n\n    Args:\n    maze (List[List[int]]): A 2D list representing the maze layout\n    start (List[int]): Starting coordinates [row, col]\n    end (List[int]): Exit coordinates [row, col]\n\n    Returns:\n    int: Minimum number of moves to escape the maze, or -1 if impossible\n\n\n    [EXAMPLES]\n    \n    assert candidate([[0, 0, 1], [0, 1, 0], [1, 0, 0]], [0, 0], [2, 2]) == -1\n    assert candidate([[1, 1, 1], [1, 0, 1], [1, 1, 1]], [1, 1], [1, 1]) == 0\n\n    [/EXAMPLES]\n    \"\"\"\n    rows, cols = len(maze), len(maze[0])\n    \n    # Define possible moves: up, down, left, right\n    directions = [(-1, 0), (1, 0), (0, -1), (0, 1)]\n    \n    # Initialize queue for BFS\n    queue = deque([(start[0], start[1], 0)])  # (row, col, moves)\n    \n    # Initialize visited set\n    visited = set([(start[0], start[1])])\n    \n    while queue:\n        row, col, moves = queue.popleft()\n        \n        # Check if we've reached the exit\n        if [row, col] == end:\n            return moves\n        \n        # Explore all possible directions\n        for dr, dc in directions:\n            new_row, new_col = row + dr, col + dc\n            \n            # Check if the new position is valid and not visited\n            if (0 <= new_row < rows and 0 <= new_col < cols and\n                maze[new_row][new_col] == 0 and\n                (new_row, new_col) not in visited):\n                \n                queue.append((new_row, new_col, moves + 1))\n                visited.add((new_row, new_col))\n    \n    # If we've explored all possible paths and haven't reached the exit\n    return -1\n\n", "test": "def check(candidate):\n    assert candidate([[0, 0, 0, 0], [0, 1, 1, 0], [0, 0, 1, 0], [1, 0, 0, 0]], [0, 0], [3, 3]) == 6\n    assert candidate([[0, 0, 0], [0, 0, 0], [0, 0, 0]], [0, 0], [2, 2]) == 4\n    assert candidate([[0, 0, 0, 0, 0], [1, 1, 1, 1, 0], [0, 0, 0, 1, 0], [1, 1, 0, 1, 0], [0, 0, 0, 1, 0]], [0, 0], [4, 0]) == -1\n    assert candidate([[0, 1, 0, 0], [0, 0, 0, 1], [1, 1, 0, 0], [0, 0, 1, 0]], [0, 0], [3, 3]) == 6\n    assert candidate([[0, 0, 1], [0, 1, 0], [1, 0, 0]], [0, 0], [2, 2]) == -1\n    assert candidate([[0, 1], [1, 0]], [0, 0], [1, 1]) == -1\n    assert candidate([[0, 0], [0, 0]], [0, 0], [1, 1]) == 2\n    assert candidate([[0, 0, 0], [0, 1, 0], [0, 0, 0]], [0, 0], [1, 1]) == -1\n    assert candidate([[1, 1, 1], [1, 0, 1], [1, 1, 1]], [1, 1], [1, 1]) == 0\n    assert candidate([[0]], [0, 0], [0, 0]) == 0\n", "language": "python"}
{"task_id": "5e8f81cb-74a2-4dd8-9345-4475aa24f0a72894419624941868564", "prompt": "Finish coding the function to match the description in the docstring. Present the complete function in one cohesive code block, maintaining the original function name and argument structure.\n\n```python\nfrom typing import List, Tuple\nimport math\n\ndef optimize_solar_panel_placement(roof_dimensions: Tuple[float, float], panel_dimensions: Tuple[float, float]) -> List[Tuple[float, float]]:\n    \"\"\"\n    Determine the optimal placement of solar panels on a rectangular roof.\n\n    This function calculates the best arrangement of solar panels on a given roof\n    to maximize energy production. It considers the roof's dimensions and the size\n    of each solar panel to find the most efficient layout.\n\n    Args:\n        roof_dimensions (Tuple[float, float]): The length and width of the roof in meters.\n        panel_dimensions (Tuple[float, float]): The length and width of each solar panel in meters.\n\n    Returns:\n        List[Tuple[float, float]]: A list of (x, y) coordinates for the top-left corner of each panel.\n\n\n    [EXAMPLES]\n    \n    assert candidate((25.0, 18.0), (2.8, 2.1)) == [(0.0, 0.0), (2.8, 0.0), (5.6, 0.0), (8.399999999999999, 0.0), (11.2, 0.0), (14.0, 0.0), (16.799999999999997, 0.0), (19.599999999999998, 0.0), (0.0, 2.1), (2.8, 2.1), (5.6, 2.1), (8.399999999999999, 2.1), (11.2, 2.1), (14.0, 2.1), (16.799999999999997, 2.1), (19.599999999999998, 2.1), (0.0, 4.2), (2.8, 4.2), (5.6, 4.2), (8.399999999999999, 4.2), (11.2, 4.2), (14.0, 4.2), (16.799999999999997, 4.2), (19.599999999999998, 4.2), (0.0, 6.300000000000001), (2.8, 6.300000000000001), (5.6, 6.300000000000001), (8.399999999999999, 6.300000000000001), (11.2, 6.300000000000001), (14.0, 6.300000000000001), (16.799999999999997, 6.300000000000001), (19.599999999999998, 6.300000000000001), (0.0, 8.4), (2.8, 8.4), (5.6, 8.4), (8.399999999999999, 8.4), (11.2, 8.4), (14.0, 8.4), (16.799999999999997, 8.4), (19.599999999999998, 8.4), (0.0, 10.5), (2.8, 10.5), (5.6, 10.5), (8.399999999999999, 10.5), (11.2, 10.5), (14.0, 10.5), (16.799999999999997, 10.5), (19.599999999999998, 10.5), (0.0, 12.600000000000001), (2.8, 12.600000000000001), (5.6, 12.600000000000001), (8.399999999999999, 12.600000000000001), (11.2, 12.600000000000001), (14.0, 12.600000000000001), (16.799999999999997, 12.600000000000001), (19.599999999999998, 12.600000000000001), (0.0, 14.700000000000001), (2.8, 14.700000000000001), (5.6, 14.700000000000001), (8.399999999999999, 14.700000000000001), (11.2, 14.700000000000001), (14.0, 14.700000000000001), (16.799999999999997, 14.700000000000001), (19.599999999999998, 14.700000000000001)]\n    assert candidate((2.5, 1.8), (0.6, 0.4)) == [(0.0, 0.0), (0.6, 0.0), (1.2, 0.0), (1.7999999999999998, 0.0), (0.0, 0.4), (0.6, 0.4), (1.2, 0.4), (1.7999999999999998, 0.4), (0.0, 0.8), (0.6, 0.8), (1.2, 0.8), (1.7999999999999998, 0.8), (0.0, 1.2000000000000002), (0.6, 1.2000000000000002), (1.2, 1.2000000000000002), (1.7999999999999998, 1.2000000000000002)]\n\n    [/EXAMPLES]\n    \"\"\"\n```\n", "entry_point": "optimize_solar_panel_placement", "solution": "from typing import List, Tuple\nimport math\n\ndef optimize_solar_panel_placement(roof_dimensions: Tuple[float, float], panel_dimensions: Tuple[float, float]) -> List[Tuple[float, float]]:\n    \"\"\"\n    Determine the optimal placement of solar panels on a rectangular roof.\n\n    This function calculates the best arrangement of solar panels on a given roof\n    to maximize energy production. It considers the roof's dimensions and the size\n    of each solar panel to find the most efficient layout.\n\n    Args:\n        roof_dimensions (Tuple[float, float]): The length and width of the roof in meters.\n        panel_dimensions (Tuple[float, float]): The length and width of each solar panel in meters.\n\n    Returns:\n        List[Tuple[float, float]]: A list of (x, y) coordinates for the top-left corner of each panel.\n\n\n    [EXAMPLES]\n    \n    assert candidate((25.0, 18.0), (2.8, 2.1)) == [(0.0, 0.0), (2.8, 0.0), (5.6, 0.0), (8.399999999999999, 0.0), (11.2, 0.0), (14.0, 0.0), (16.799999999999997, 0.0), (19.599999999999998, 0.0), (0.0, 2.1), (2.8, 2.1), (5.6, 2.1), (8.399999999999999, 2.1), (11.2, 2.1), (14.0, 2.1), (16.799999999999997, 2.1), (19.599999999999998, 2.1), (0.0, 4.2), (2.8, 4.2), (5.6, 4.2), (8.399999999999999, 4.2), (11.2, 4.2), (14.0, 4.2), (16.799999999999997, 4.2), (19.599999999999998, 4.2), (0.0, 6.300000000000001), (2.8, 6.300000000000001), (5.6, 6.300000000000001), (8.399999999999999, 6.300000000000001), (11.2, 6.300000000000001), (14.0, 6.300000000000001), (16.799999999999997, 6.300000000000001), (19.599999999999998, 6.300000000000001), (0.0, 8.4), (2.8, 8.4), (5.6, 8.4), (8.399999999999999, 8.4), (11.2, 8.4), (14.0, 8.4), (16.799999999999997, 8.4), (19.599999999999998, 8.4), (0.0, 10.5), (2.8, 10.5), (5.6, 10.5), (8.399999999999999, 10.5), (11.2, 10.5), (14.0, 10.5), (16.799999999999997, 10.5), (19.599999999999998, 10.5), (0.0, 12.600000000000001), (2.8, 12.600000000000001), (5.6, 12.600000000000001), (8.399999999999999, 12.600000000000001), (11.2, 12.600000000000001), (14.0, 12.600000000000001), (16.799999999999997, 12.600000000000001), (19.599999999999998, 12.600000000000001), (0.0, 14.700000000000001), (2.8, 14.700000000000001), (5.6, 14.700000000000001), (8.399999999999999, 14.700000000000001), (11.2, 14.700000000000001), (14.0, 14.700000000000001), (16.799999999999997, 14.700000000000001), (19.599999999999998, 14.700000000000001)]\n    assert candidate((2.5, 1.8), (0.6, 0.4)) == [(0.0, 0.0), (0.6, 0.0), (1.2, 0.0), (1.7999999999999998, 0.0), (0.0, 0.4), (0.6, 0.4), (1.2, 0.4), (1.7999999999999998, 0.4), (0.0, 0.8), (0.6, 0.8), (1.2, 0.8), (1.7999999999999998, 0.8), (0.0, 1.2000000000000002), (0.6, 1.2000000000000002), (1.2, 1.2000000000000002), (1.7999999999999998, 1.2000000000000002)]\n\n    [/EXAMPLES]\n    \"\"\"\n    roof_length, roof_width = roof_dimensions\n    panel_length, panel_width = panel_dimensions\n    \n    # Calculate the number of panels that can fit in each direction\n    panels_x = int(roof_length // panel_length)\n    panels_y = int(roof_width // panel_width)\n    \n    # Generate the coordinates for each panel\n    panel_positions = []\n    for y in range(panels_y):\n        for x in range(panels_x):\n            x_pos = x * panel_length\n            y_pos = y * panel_width\n            panel_positions.append((x_pos, y_pos))\n    \n    return panel_positions\n\n", "test": "def check(candidate):\n    assert candidate((2.5, 1.8), (0.6, 0.4)) == [(0.0, 0.0), (0.6, 0.0), (1.2, 0.0), (1.7999999999999998, 0.0), (0.0, 0.4), (0.6, 0.4), (1.2, 0.4), (1.7999999999999998, 0.4), (0.0, 0.8), (0.6, 0.8), (1.2, 0.8), (1.7999999999999998, 0.8), (0.0, 1.2000000000000002), (0.6, 1.2000000000000002), (1.2, 1.2000000000000002), (1.7999999999999998, 1.2000000000000002)]\n    assert candidate((25.0, 18.0), (2.8, 2.1)) == [(0.0, 0.0), (2.8, 0.0), (5.6, 0.0), (8.399999999999999, 0.0), (11.2, 0.0), (14.0, 0.0), (16.799999999999997, 0.0), (19.599999999999998, 0.0), (0.0, 2.1), (2.8, 2.1), (5.6, 2.1), (8.399999999999999, 2.1), (11.2, 2.1), (14.0, 2.1), (16.799999999999997, 2.1), (19.599999999999998, 2.1), (0.0, 4.2), (2.8, 4.2), (5.6, 4.2), (8.399999999999999, 4.2), (11.2, 4.2), (14.0, 4.2), (16.799999999999997, 4.2), (19.599999999999998, 4.2), (0.0, 6.300000000000001), (2.8, 6.300000000000001), (5.6, 6.300000000000001), (8.399999999999999, 6.300000000000001), (11.2, 6.300000000000001), (14.0, 6.300000000000001), (16.799999999999997, 6.300000000000001), (19.599999999999998, 6.300000000000001), (0.0, 8.4), (2.8, 8.4), (5.6, 8.4), (8.399999999999999, 8.4), (11.2, 8.4), (14.0, 8.4), (16.799999999999997, 8.4), (19.599999999999998, 8.4), (0.0, 10.5), (2.8, 10.5), (5.6, 10.5), (8.399999999999999, 10.5), (11.2, 10.5), (14.0, 10.5), (16.799999999999997, 10.5), (19.599999999999998, 10.5), (0.0, 12.600000000000001), (2.8, 12.600000000000001), (5.6, 12.600000000000001), (8.399999999999999, 12.600000000000001), (11.2, 12.600000000000001), (14.0, 12.600000000000001), (16.799999999999997, 12.600000000000001), (19.599999999999998, 12.600000000000001), (0.0, 14.700000000000001), (2.8, 14.700000000000001), (5.6, 14.700000000000001), (8.399999999999999, 14.700000000000001), (11.2, 14.700000000000001), (14.0, 14.700000000000001), (16.799999999999997, 14.700000000000001), (19.599999999999998, 14.700000000000001)]\n    assert candidate((50.0, 40.0), (4.5, 3.5)) == [(0.0, 0.0), (4.5, 0.0), (9.0, 0.0), (13.5, 0.0), (18.0, 0.0), (22.5, 0.0), (27.0, 0.0), (31.5, 0.0), (36.0, 0.0), (40.5, 0.0), (45.0, 0.0), (0.0, 3.5), (4.5, 3.5), (9.0, 3.5), (13.5, 3.5), (18.0, 3.5), (22.5, 3.5), (27.0, 3.5), (31.5, 3.5), (36.0, 3.5), (40.5, 3.5), (45.0, 3.5), (0.0, 7.0), (4.5, 7.0), (9.0, 7.0), (13.5, 7.0), (18.0, 7.0), (22.5, 7.0), (27.0, 7.0), (31.5, 7.0), (36.0, 7.0), (40.5, 7.0), (45.0, 7.0), (0.0, 10.5), (4.5, 10.5), (9.0, 10.5), (13.5, 10.5), (18.0, 10.5), (22.5, 10.5), (27.0, 10.5), (31.5, 10.5), (36.0, 10.5), (40.5, 10.5), (45.0, 10.5), (0.0, 14.0), (4.5, 14.0), (9.0, 14.0), (13.5, 14.0), (18.0, 14.0), (22.5, 14.0), (27.0, 14.0), (31.5, 14.0), (36.0, 14.0), (40.5, 14.0), (45.0, 14.0), (0.0, 17.5), (4.5, 17.5), (9.0, 17.5), (13.5, 17.5), (18.0, 17.5), (22.5, 17.5), (27.0, 17.5), (31.5, 17.5), (36.0, 17.5), (40.5, 17.5), (45.0, 17.5), (0.0, 21.0), (4.5, 21.0), (9.0, 21.0), (13.5, 21.0), (18.0, 21.0), (22.5, 21.0), (27.0, 21.0), (31.5, 21.0), (36.0, 21.0), (40.5, 21.0), (45.0, 21.0), (0.0, 24.5), (4.5, 24.5), (9.0, 24.5), (13.5, 24.5), (18.0, 24.5), (22.5, 24.5), (27.0, 24.5), (31.5, 24.5), (36.0, 24.5), (40.5, 24.5), (45.0, 24.5), (0.0, 28.0), (4.5, 28.0), (9.0, 28.0), (13.5, 28.0), (18.0, 28.0), (22.5, 28.0), (27.0, 28.0), (31.5, 28.0), (36.0, 28.0), (40.5, 28.0), (45.0, 28.0), (0.0, 31.5), (4.5, 31.5), (9.0, 31.5), (13.5, 31.5), (18.0, 31.5), (22.5, 31.5), (27.0, 31.5), (31.5, 31.5), (36.0, 31.5), (40.5, 31.5), (45.0, 31.5), (0.0, 35.0), (4.5, 35.0), (9.0, 35.0), (13.5, 35.0), (18.0, 35.0), (22.5, 35.0), (27.0, 35.0), (31.5, 35.0), (36.0, 35.0), (40.5, 35.0), (45.0, 35.0)]\n    assert candidate((18.2, 13.5), (2.3, 1.7)) == [(0.0, 0.0), (2.3, 0.0), (4.6, 0.0), (6.8999999999999995, 0.0), (9.2, 0.0), (11.5, 0.0), (13.799999999999999, 0.0), (0.0, 1.7), (2.3, 1.7), (4.6, 1.7), (6.8999999999999995, 1.7), (9.2, 1.7), (11.5, 1.7), (13.799999999999999, 1.7), (0.0, 3.4), (2.3, 3.4), (4.6, 3.4), (6.8999999999999995, 3.4), (9.2, 3.4), (11.5, 3.4), (13.799999999999999, 3.4), (0.0, 5.1), (2.3, 5.1), (4.6, 5.1), (6.8999999999999995, 5.1), (9.2, 5.1), (11.5, 5.1), (13.799999999999999, 5.1), (0.0, 6.8), (2.3, 6.8), (4.6, 6.8), (6.8999999999999995, 6.8), (9.2, 6.8), (11.5, 6.8), (13.799999999999999, 6.8), (0.0, 8.5), (2.3, 8.5), (4.6, 8.5), (6.8999999999999995, 8.5), (9.2, 8.5), (11.5, 8.5), (13.799999999999999, 8.5), (0.0, 10.2), (2.3, 10.2), (4.6, 10.2), (6.8999999999999995, 10.2), (9.2, 10.2), (11.5, 10.2), (13.799999999999999, 10.2)]\n    assert candidate((22.7, 16.9), (2.7, 2.0)) == [(0.0, 0.0), (2.7, 0.0), (5.4, 0.0), (8.100000000000001, 0.0), (10.8, 0.0), (13.5, 0.0), (16.200000000000003, 0.0), (18.900000000000002, 0.0), (0.0, 2.0), (2.7, 2.0), (5.4, 2.0), (8.100000000000001, 2.0), (10.8, 2.0), (13.5, 2.0), (16.200000000000003, 2.0), (18.900000000000002, 2.0), (0.0, 4.0), (2.7, 4.0), (5.4, 4.0), (8.100000000000001, 4.0), (10.8, 4.0), (13.5, 4.0), (16.200000000000003, 4.0), (18.900000000000002, 4.0), (0.0, 6.0), (2.7, 6.0), (5.4, 6.0), (8.100000000000001, 6.0), (10.8, 6.0), (13.5, 6.0), (16.200000000000003, 6.0), (18.900000000000002, 6.0), (0.0, 8.0), (2.7, 8.0), (5.4, 8.0), (8.100000000000001, 8.0), (10.8, 8.0), (13.5, 8.0), (16.200000000000003, 8.0), (18.900000000000002, 8.0), (0.0, 10.0), (2.7, 10.0), (5.4, 10.0), (8.100000000000001, 10.0), (10.8, 10.0), (13.5, 10.0), (16.200000000000003, 10.0), (18.900000000000002, 10.0), (0.0, 12.0), (2.7, 12.0), (5.4, 12.0), (8.100000000000001, 12.0), (10.8, 12.0), (13.5, 12.0), (16.200000000000003, 12.0), (18.900000000000002, 12.0), (0.0, 14.0), (2.7, 14.0), (5.4, 14.0), (8.100000000000001, 14.0), (10.8, 14.0), (13.5, 14.0), (16.200000000000003, 14.0), (18.900000000000002, 14.0)]\n    assert candidate((100.0, 50.0), (5.0, 3.0)) == [(0.0, 0.0), (5.0, 0.0), (10.0, 0.0), (15.0, 0.0), (20.0, 0.0), (25.0, 0.0), (30.0, 0.0), (35.0, 0.0), (40.0, 0.0), (45.0, 0.0), (50.0, 0.0), (55.0, 0.0), (60.0, 0.0), (65.0, 0.0), (70.0, 0.0), (75.0, 0.0), (80.0, 0.0), (85.0, 0.0), (90.0, 0.0), (95.0, 0.0), (0.0, 3.0), (5.0, 3.0), (10.0, 3.0), (15.0, 3.0), (20.0, 3.0), (25.0, 3.0), (30.0, 3.0), (35.0, 3.0), (40.0, 3.0), (45.0, 3.0), (50.0, 3.0), (55.0, 3.0), (60.0, 3.0), (65.0, 3.0), (70.0, 3.0), (75.0, 3.0), (80.0, 3.0), (85.0, 3.0), (90.0, 3.0), (95.0, 3.0), (0.0, 6.0), (5.0, 6.0), (10.0, 6.0), (15.0, 6.0), (20.0, 6.0), (25.0, 6.0), (30.0, 6.0), (35.0, 6.0), (40.0, 6.0), (45.0, 6.0), (50.0, 6.0), (55.0, 6.0), (60.0, 6.0), (65.0, 6.0), (70.0, 6.0), (75.0, 6.0), (80.0, 6.0), (85.0, 6.0), (90.0, 6.0), (95.0, 6.0), (0.0, 9.0), (5.0, 9.0), (10.0, 9.0), (15.0, 9.0), (20.0, 9.0), (25.0, 9.0), (30.0, 9.0), (35.0, 9.0), (40.0, 9.0), (45.0, 9.0), (50.0, 9.0), (55.0, 9.0), (60.0, 9.0), (65.0, 9.0), (70.0, 9.0), (75.0, 9.0), (80.0, 9.0), (85.0, 9.0), (90.0, 9.0), (95.0, 9.0), (0.0, 12.0), (5.0, 12.0), (10.0, 12.0), (15.0, 12.0), (20.0, 12.0), (25.0, 12.0), (30.0, 12.0), (35.0, 12.0), (40.0, 12.0), (45.0, 12.0), (50.0, 12.0), (55.0, 12.0), (60.0, 12.0), (65.0, 12.0), (70.0, 12.0), (75.0, 12.0), (80.0, 12.0), (85.0, 12.0), (90.0, 12.0), (95.0, 12.0), (0.0, 15.0), (5.0, 15.0), (10.0, 15.0), (15.0, 15.0), (20.0, 15.0), (25.0, 15.0), (30.0, 15.0), (35.0, 15.0), (40.0, 15.0), (45.0, 15.0), (50.0, 15.0), (55.0, 15.0), (60.0, 15.0), (65.0, 15.0), (70.0, 15.0), (75.0, 15.0), (80.0, 15.0), (85.0, 15.0), (90.0, 15.0), (95.0, 15.0), (0.0, 18.0), (5.0, 18.0), (10.0, 18.0), (15.0, 18.0), (20.0, 18.0), (25.0, 18.0), (30.0, 18.0), (35.0, 18.0), (40.0, 18.0), (45.0, 18.0), (50.0, 18.0), (55.0, 18.0), (60.0, 18.0), (65.0, 18.0), (70.0, 18.0), (75.0, 18.0), (80.0, 18.0), (85.0, 18.0), (90.0, 18.0), (95.0, 18.0), (0.0, 21.0), (5.0, 21.0), (10.0, 21.0), (15.0, 21.0), (20.0, 21.0), (25.0, 21.0), (30.0, 21.0), (35.0, 21.0), (40.0, 21.0), (45.0, 21.0), (50.0, 21.0), (55.0, 21.0), (60.0, 21.0), (65.0, 21.0), (70.0, 21.0), (75.0, 21.0), (80.0, 21.0), (85.0, 21.0), (90.0, 21.0), (95.0, 21.0), (0.0, 24.0), (5.0, 24.0), (10.0, 24.0), (15.0, 24.0), (20.0, 24.0), (25.0, 24.0), (30.0, 24.0), (35.0, 24.0), (40.0, 24.0), (45.0, 24.0), (50.0, 24.0), (55.0, 24.0), (60.0, 24.0), (65.0, 24.0), (70.0, 24.0), (75.0, 24.0), (80.0, 24.0), (85.0, 24.0), (90.0, 24.0), (95.0, 24.0), (0.0, 27.0), (5.0, 27.0), (10.0, 27.0), (15.0, 27.0), (20.0, 27.0), (25.0, 27.0), (30.0, 27.0), (35.0, 27.0), (40.0, 27.0), (45.0, 27.0), (50.0, 27.0), (55.0, 27.0), (60.0, 27.0), (65.0, 27.0), (70.0, 27.0), (75.0, 27.0), (80.0, 27.0), (85.0, 27.0), (90.0, 27.0), (95.0, 27.0), (0.0, 30.0), (5.0, 30.0), (10.0, 30.0), (15.0, 30.0), (20.0, 30.0), (25.0, 30.0), (30.0, 30.0), (35.0, 30.0), (40.0, 30.0), (45.0, 30.0), (50.0, 30.0), (55.0, 30.0), (60.0, 30.0), (65.0, 30.0), (70.0, 30.0), (75.0, 30.0), (80.0, 30.0), (85.0, 30.0), (90.0, 30.0), (95.0, 30.0), (0.0, 33.0), (5.0, 33.0), (10.0, 33.0), (15.0, 33.0), (20.0, 33.0), (25.0, 33.0), (30.0, 33.0), (35.0, 33.0), (40.0, 33.0), (45.0, 33.0), (50.0, 33.0), (55.0, 33.0), (60.0, 33.0), (65.0, 33.0), (70.0, 33.0), (75.0, 33.0), (80.0, 33.0), (85.0, 33.0), (90.0, 33.0), (95.0, 33.0), (0.0, 36.0), (5.0, 36.0), (10.0, 36.0), (15.0, 36.0), (20.0, 36.0), (25.0, 36.0), (30.0, 36.0), (35.0, 36.0), (40.0, 36.0), (45.0, 36.0), (50.0, 36.0), (55.0, 36.0), (60.0, 36.0), (65.0, 36.0), (70.0, 36.0), (75.0, 36.0), (80.0, 36.0), (85.0, 36.0), (90.0, 36.0), (95.0, 36.0), (0.0, 39.0), (5.0, 39.0), (10.0, 39.0), (15.0, 39.0), (20.0, 39.0), (25.0, 39.0), (30.0, 39.0), (35.0, 39.0), (40.0, 39.0), (45.0, 39.0), (50.0, 39.0), (55.0, 39.0), (60.0, 39.0), (65.0, 39.0), (70.0, 39.0), (75.0, 39.0), (80.0, 39.0), (85.0, 39.0), (90.0, 39.0), (95.0, 39.0), (0.0, 42.0), (5.0, 42.0), (10.0, 42.0), (15.0, 42.0), (20.0, 42.0), (25.0, 42.0), (30.0, 42.0), (35.0, 42.0), (40.0, 42.0), (45.0, 42.0), (50.0, 42.0), (55.0, 42.0), (60.0, 42.0), (65.0, 42.0), (70.0, 42.0), (75.0, 42.0), (80.0, 42.0), (85.0, 42.0), (90.0, 42.0), (95.0, 42.0), (0.0, 45.0), (5.0, 45.0), (10.0, 45.0), (15.0, 45.0), (20.0, 45.0), (25.0, 45.0), (30.0, 45.0), (35.0, 45.0), (40.0, 45.0), (45.0, 45.0), (50.0, 45.0), (55.0, 45.0), (60.0, 45.0), (65.0, 45.0), (70.0, 45.0), (75.0, 45.0), (80.0, 45.0), (85.0, 45.0), (90.0, 45.0), (95.0, 45.0)]\n    assert candidate((12.3, 9.7), (1.8, 1.3)) == [(0.0, 0.0), (1.8, 0.0), (3.6, 0.0), (5.4, 0.0), (7.2, 0.0), (9.0, 0.0), (0.0, 1.3), (1.8, 1.3), (3.6, 1.3), (5.4, 1.3), (7.2, 1.3), (9.0, 1.3), (0.0, 2.6), (1.8, 2.6), (3.6, 2.6), (5.4, 2.6), (7.2, 2.6), (9.0, 2.6), (0.0, 3.9000000000000004), (1.8, 3.9000000000000004), (3.6, 3.9000000000000004), (5.4, 3.9000000000000004), (7.2, 3.9000000000000004), (9.0, 3.9000000000000004), (0.0, 5.2), (1.8, 5.2), (3.6, 5.2), (5.4, 5.2), (7.2, 5.2), (9.0, 5.2), (0.0, 6.5), (1.8, 6.5), (3.6, 6.5), (5.4, 6.5), (7.2, 6.5), (9.0, 6.5), (0.0, 7.800000000000001), (1.8, 7.800000000000001), (3.6, 7.800000000000001), (5.4, 7.800000000000001), (7.2, 7.800000000000001), (9.0, 7.800000000000001)]\n    assert candidate((14.1, 10.3), (2.1, 1.5)) == [(0.0, 0.0), (2.1, 0.0), (4.2, 0.0), (6.300000000000001, 0.0), (8.4, 0.0), (10.5, 0.0), (0.0, 1.5), (2.1, 1.5), (4.2, 1.5), (6.300000000000001, 1.5), (8.4, 1.5), (10.5, 1.5), (0.0, 3.0), (2.1, 3.0), (4.2, 3.0), (6.300000000000001, 3.0), (8.4, 3.0), (10.5, 3.0), (0.0, 4.5), (2.1, 4.5), (4.2, 4.5), (6.300000000000001, 4.5), (8.4, 4.5), (10.5, 4.5), (0.0, 6.0), (2.1, 6.0), (4.2, 6.0), (6.300000000000001, 6.0), (8.4, 6.0), (10.5, 6.0), (0.0, 7.5), (2.1, 7.5), (4.2, 7.5), (6.300000000000001, 7.5), (8.4, 7.5), (10.5, 7.5)]\n    assert candidate((7.5, 4.8), (1.2, 0.9)) == [(0.0, 0.0), (1.2, 0.0), (2.4, 0.0), (3.5999999999999996, 0.0), (4.8, 0.0), (6.0, 0.0), (0.0, 0.9), (1.2, 0.9), (2.4, 0.9), (3.5999999999999996, 0.9), (4.8, 0.9), (6.0, 0.9), (0.0, 1.8), (1.2, 1.8), (2.4, 1.8), (3.5999999999999996, 1.8), (4.8, 1.8), (6.0, 1.8), (0.0, 2.7), (1.2, 2.7), (2.4, 2.7), (3.5999999999999996, 2.7), (4.8, 2.7), (6.0, 2.7), (0.0, 3.6), (1.2, 3.6), (2.4, 3.6), (3.5999999999999996, 3.6), (4.8, 3.6), (6.0, 3.6)]\n    assert candidate((1.0, 1.0), (0.5, 0.5)) == [(0.0, 0.0), (0.5, 0.0), (0.0, 0.5), (0.5, 0.5)]\n", "language": "python"}
{"task_id": "24136ba0-c6b9-47a3-aa80-f404c3d1a461-6826616659811539997", "prompt": "Present the finalized code as a single, self-contained block without any separations or divisions.\n\n```python\nfrom typing import List\n\ndef terrain_navigator(elevation_map: List[List[int]], water_level: int) -> List[List[str]]:\n    \"\"\"\n    You are developing a terrain analysis system for a strategy game. Given a 2D elevation map\n    and a water level, your task is to create a visual representation of the terrain, showing\n    land, water, and mountains.\n\n    The elevation_map is a 2D list where each cell represents the height of that location.\n    The water_level determines which cells are underwater.\n\n    Your function should return a new 2D list of the same dimensions as the input, where:\n    - Cells with elevation less than water_level are represented as '~' (water)\n    - Cells with elevation equal to water_level are represented as '_' (shore)\n    - Cells with elevation greater than water_level but less than water_level + 3 are represented as '.' (land)\n    - Cells with elevation greater than or equal to water_level + 3 are represented as '^' (mountain)\n\n\n    [EXAMPLES]\n    \n    assert candidate([[1, 2], [3, 4]], 2) == [['~', '_'], ['.', '.']]\n    assert candidate([[1]], 0) == [['.']]\n\n    [/EXAMPLES]\n    \"\"\"\n```\n", "entry_point": "terrain_navigator", "solution": "from typing import List\n\ndef terrain_navigator(elevation_map: List[List[int]], water_level: int) -> List[List[str]]:\n    \"\"\"\n    You are developing a terrain analysis system for a strategy game. Given a 2D elevation map\n    and a water level, your task is to create a visual representation of the terrain, showing\n    land, water, and mountains.\n\n    The elevation_map is a 2D list where each cell represents the height of that location.\n    The water_level determines which cells are underwater.\n\n    Your function should return a new 2D list of the same dimensions as the input, where:\n    - Cells with elevation less than water_level are represented as '~' (water)\n    - Cells with elevation equal to water_level are represented as '_' (shore)\n    - Cells with elevation greater than water_level but less than water_level + 3 are represented as '.' (land)\n    - Cells with elevation greater than or equal to water_level + 3 are represented as '^' (mountain)\n\n\n    [EXAMPLES]\n    \n    assert candidate([[1, 2], [3, 4]], 2) == [['~', '_'], ['.', '.']]\n    assert candidate([[1]], 0) == [['.']]\n\n    [/EXAMPLES]\n    \"\"\"\n    def get_terrain_symbol(elevation: int) -> str:\n        if elevation < water_level:\n            return '~'  # water\n        elif elevation == water_level:\n            return '_'  # shore\n        elif elevation < water_level + 3:\n            return '.'  # land\n        else:\n            return '^'  # mountain\n\n    rows = len(elevation_map)\n    cols = len(elevation_map[0]) if rows > 0 else 0\n\n    terrain_map = []\n    for i in range(rows):\n        terrain_row = []\n        for j in range(cols):\n            terrain_row.append(get_terrain_symbol(elevation_map[i][j]))\n        terrain_map.append(terrain_row)\n\n    return terrain_map\n\n", "test": "def check(candidate):\n    assert candidate([[1]], 0) == [['.']]\n    assert candidate([[1, 2, 3], [4, 5, 6], [7, 8, 9]], 4) == [['~', '~', '~'], ['_', '.', '.'], ['^', '^', '^']]\n    assert candidate([[1, 2], [3, 4]], 2) == [['~', '_'], ['.', '.']]\n    assert candidate([[0, 0, 0], [0, 0, 0], [0, 0, 0]], 1) == [['~', '~', '~'], ['~', '~', '~'], ['~', '~', '~']]\n    assert candidate([[10, 10, 10], [10, 10, 10], [10, 10, 10]], 5) == [['^', '^', '^'], ['^', '^', '^'], ['^', '^', '^']]\n    assert candidate([[100, 200, 300], [400, 500, 600]], 250) == [['~', '~', '^'], ['^', '^', '^']]\n    assert candidate([[9, 8, 7], [6, 5, 4], [3, 2, 1]], 5) == [['^', '^', '.'], ['.', '_', '~'], ['~', '~', '~']]\n    assert candidate([[5, 5, 5], [5, 6, 5], [5, 5, 5]], 5) == [['_', '_', '_'], ['_', '.', '_'], ['_', '_', '_']]\n    assert candidate([[5]], 5) == [['_']]\n    assert candidate([[1, 2, 3, 4], [5, 6, 7, 8], [9, 10, 11, 12], [13, 14, 15, 16]], 7) == [['~', '~', '~', '~'], ['~', '~', '_', '.'], ['.', '^', '^', '^'], ['^', '^', '^', '^']]\n", "language": "python"}
{"task_id": "56f1ad91-c5d2-4a35-9646-361b12f6106e1072585218851024710", "prompt": "Kindly finish coding the function, adhering to the specifications outlined in the doc string. Present the entire function in a unified code block. Refrain from altering the function's name or its argument structure.\n\n```python\nfrom typing import List\n\ndef decrypt_alien_message(encrypted_message: List[int], key: int) -> str:\n    \"\"\"You've intercepted an encrypted alien message. The message is a list of integers, and you know the decryption key.\n    Your task is to decrypt the message by applying the following algorithm:\n    1. For each integer in the list, subtract the key.\n    2. Take the absolute value of the result.\n    3. Convert the resulting number to its corresponding ASCII character.\n    4. Concatenate all characters to form the decrypted message.\n\n\n    [EXAMPLES]\n    \n    assert candidate([90, 89, 88, 87, 86], 25) == 'A@?>='\n    assert candidate([65, 66, 67, 68, 69], 0) == 'ABCDE'\n\n    [/EXAMPLES]\n    \"\"\"\n```\n", "entry_point": "decrypt_alien_message", "solution": "from typing import List\n\ndef decrypt_alien_message(encrypted_message: List[int], key: int) -> str:\n    \"\"\"You've intercepted an encrypted alien message. The message is a list of integers, and you know the decryption key.\n    Your task is to decrypt the message by applying the following algorithm:\n    1. For each integer in the list, subtract the key.\n    2. Take the absolute value of the result.\n    3. Convert the resulting number to its corresponding ASCII character.\n    4. Concatenate all characters to form the decrypted message.\n\n\n    [EXAMPLES]\n    \n    assert candidate([90, 89, 88, 87, 86], 25) == 'A@?>='\n    assert candidate([65, 66, 67, 68, 69], 0) == 'ABCDE'\n\n    [/EXAMPLES]\n    \"\"\"\n    def decrypt_char(num: int) -> str:\n        decrypted_num = abs(num - key)\n        return chr(decrypted_num)\n    \n    decrypted_chars = [decrypt_char(num) for num in encrypted_message]\n    return ''.join(decrypted_chars)\n\n", "test": "def check(candidate):\n    assert candidate([32], 32) == '\\x00'\n    assert candidate([90, 89, 88, 87, 86], 1) == 'YXWVU'\n    assert candidate([255, 254, 253, 252, 251], 128) == '\\x7f~}|{'\n    assert candidate([122, 121, 120, 119, 118], 122) == '\\x00\\x01\\x02\\x03\\x04'\n    assert candidate([33, 34, 35, 36, 37], -5) == \"&'()*\"\n    assert candidate([90, 89, 88, 87, 86], 25) == 'A@?>='\n    assert candidate([128, 129, 130, 131, 132], 128) == '\\x00\\x01\\x02\\x03\\x04'\n    assert candidate([65], 0) == 'A'\n    assert candidate([32, 32, 32, 32, 32], 32) == '\\x00\\x00\\x00\\x00\\x00'\n    assert candidate([65, 66, 67, 68, 69], 0) == 'ABCDE'\n", "language": "python"}
{"task_id": "3836291c-347b-41c9-9cac-6e906c374333-7879560697199092104", "prompt": "Ensure the entire code is contained within a single, uninterrupted code section.\n\n```python\nfrom collections import Counter\nfrom typing import List\n\ndef analyze_network_traffic(log_entries: List[str]) -> dict:\n    \"\"\"\n    A network administrator wants to analyze server log files to identify potential security threats.\n    The logs contain entries of IP addresses accessing the server.\n\n    This function takes a list of log entries (IP addresses) and returns a dictionary with\n    statistics about the traffic, including the top 3 most frequent IP addresses and their access counts.\n\n    The implementation requires utilizing concepts of hash tables and sorting algorithms.\n\n    :param log_entries: A list of strings, each representing an IP address from the log\n    :return: A dictionary containing traffic statistics\n\n\n    [EXAMPLES]\n    \n    assert candidate(['172.16.' + str(i) + '.1' for i in range(256)]) == {'total_requests': 256, 'unique_ips': 256, 'top_3_ips': [('172.16.0.1', 1), ('172.16.1.1', 1), ('172.16.2.1', 1)]}\n    assert candidate(['192.168.1.1', '10.0.0.1'] * 500) == {'total_requests': 1000, 'unique_ips': 2, 'top_3_ips': [('192.168.1.1', 500), ('10.0.0.1', 500)]}\n\n    [/EXAMPLES]\n    \"\"\"\n```\n", "entry_point": "analyze_network_traffic", "solution": "from collections import Counter\nfrom typing import List\n\ndef analyze_network_traffic(log_entries: List[str]) -> dict:\n    \"\"\"\n    A network administrator wants to analyze server log files to identify potential security threats.\n    The logs contain entries of IP addresses accessing the server.\n\n    This function takes a list of log entries (IP addresses) and returns a dictionary with\n    statistics about the traffic, including the top 3 most frequent IP addresses and their access counts.\n\n    The implementation requires utilizing concepts of hash tables and sorting algorithms.\n\n    :param log_entries: A list of strings, each representing an IP address from the log\n    :return: A dictionary containing traffic statistics\n\n\n    [EXAMPLES]\n    \n    assert candidate(['172.16.' + str(i) + '.1' for i in range(256)]) == {'total_requests': 256, 'unique_ips': 256, 'top_3_ips': [('172.16.0.1', 1), ('172.16.1.1', 1), ('172.16.2.1', 1)]}\n    assert candidate(['192.168.1.1', '10.0.0.1'] * 500) == {'total_requests': 1000, 'unique_ips': 2, 'top_3_ips': [('192.168.1.1', 500), ('10.0.0.1', 500)]}\n\n    [/EXAMPLES]\n    \"\"\"\n    # Use Counter to count occurrences of each IP address (hash table)\n    ip_counts = Counter(log_entries)\n    \n    # Get total number of requests\n    total_requests = len(log_entries)\n    \n    # Get number of unique IPs\n    unique_ips = len(ip_counts)\n    \n    # Get top 3 most frequent IP addresses\n    # Counter's most_common method uses a sorting algorithm internally\n    top_3_ips = ip_counts.most_common(3)\n    \n    # Prepare the result dictionary\n    result = {\n        'total_requests': total_requests,\n        'unique_ips': unique_ips,\n        'top_3_ips': top_3_ips\n    }\n    \n    return result\n\n", "test": "def check(candidate):\n    assert candidate(['192.168.1.1', '10.0.0.1', '192.168.1.1', '172.16.0.1', '10.0.0.1', '192.168.1.1']) == {'total_requests': 6, 'unique_ips': 3, 'top_3_ips': [('192.168.1.1', 3), ('10.0.0.1', 2), ('172.16.0.1', 1)]}\n    assert candidate(['fe80::1'] * 500 + ['::1'] * 300 + ['::ffff:192.0.2.128'] * 200) == {'total_requests': 1000, 'unique_ips': 3, 'top_3_ips': [('fe80::1', 500), ('::1', 300), ('::ffff:192.0.2.128', 200)]}\n    assert candidate(['8.8.8.8', '8.8.4.4'] * 100 + ['1.1.1.1'] * 50) == {'total_requests': 250, 'unique_ips': 3, 'top_3_ips': [('8.8.8.8', 100), ('8.8.4.4', 100), ('1.1.1.1', 50)]}\n    assert candidate(['192.168.1.1', '10.0.0.1'] * 500) == {'total_requests': 1000, 'unique_ips': 2, 'top_3_ips': [('192.168.1.1', 500), ('10.0.0.1', 500)]}\n    assert candidate(['192.168.0.' + str(i) for i in range(1, 101)]) == {'total_requests': 100, 'unique_ips': 100, 'top_3_ips': [('192.168.0.1', 1), ('192.168.0.2', 1), ('192.168.0.3', 1)]}\n    assert candidate(['192.168.1.1', '192.168.1.2', '192.168.1.3'] * 333 + ['192.168.1.4']) == {'total_requests': 1000, 'unique_ips': 4, 'top_3_ips': [('192.168.1.1', 333), ('192.168.1.2', 333), ('192.168.1.3', 333)]}\n    assert candidate(['192.168.0.1', '192.168.0.2'] * 250 + ['192.168.0.3'] * 500) == {'total_requests': 1000, 'unique_ips': 3, 'top_3_ips': [('192.168.0.3', 500), ('192.168.0.1', 250), ('192.168.0.2', 250)]}\n    assert candidate(['10.0.0.1'] * 1000) == {'total_requests': 1000, 'unique_ips': 1, 'top_3_ips': [('10.0.0.1', 1000)]}\n    assert candidate(['172.16.' + str(i) + '.1' for i in range(256)]) == {'total_requests': 256, 'unique_ips': 256, 'top_3_ips': [('172.16.0.1', 1), ('172.16.1.1', 1), ('172.16.2.1', 1)]}\n    assert candidate(['10.0.0.1', '10.0.0.2', '10.0.0.3', '10.0.0.4'] * 25) == {'total_requests': 100, 'unique_ips': 4, 'top_3_ips': [('10.0.0.1', 25), ('10.0.0.2', 25), ('10.0.0.3', 25)]}\n", "language": "python"}
{"task_id": "1720ea85-0b51-45c6-b49e-71a6ba0afdb8-6238402790119853527", "prompt": "Your objective is to fill in the provided function, ensuring it's self-contained and executable within one code block. Refrain from adding code external to the function. Restrict your use of libraries to those already imported in the problem. Any supplementary functions or classes should be defined inside the main function.\n\n```python\nfrom typing import List\n\ndef plant_growth_simulation(initial_heights: List[float], growth_rates: List[float], days: int) -> List[float]:\n    \"\"\"\n    Simulate the growth of plants in a greenhouse over a specified number of days.\n\n    This function takes the initial heights of plants, their daily growth rates,\n    and the number of days to simulate. It then calculates and returns the final\n    heights of the plants after the specified period.\n\n    Args:\n    initial_heights (List[float]): A list of initial plant heights in centimeters.\n    growth_rates (List[float]): A list of daily growth rates in centimeters for each plant.\n    days (int): The number of days to simulate plant growth.\n\n    Returns:\n    List[float]: The final heights of the plants after the simulation period.\n\n\n    [EXAMPLES]\n    \n    assert candidate([5.0, 8.0], [1.0, 0.8], 5) == [10.0, 12.0]\n    assert candidate([0.0, 0.0, 0.0], [1.0, 2.0, 3.0], 10) == [10.0, 20.0, 30.0]\n\n    [/EXAMPLES]\n    \"\"\"\n```\n", "entry_point": "plant_growth_simulation", "solution": "from typing import List\n\ndef plant_growth_simulation(initial_heights: List[float], growth_rates: List[float], days: int) -> List[float]:\n    \"\"\"\n    Simulate the growth of plants in a greenhouse over a specified number of days.\n\n    This function takes the initial heights of plants, their daily growth rates,\n    and the number of days to simulate. It then calculates and returns the final\n    heights of the plants after the specified period.\n\n    Args:\n    initial_heights (List[float]): A list of initial plant heights in centimeters.\n    growth_rates (List[float]): A list of daily growth rates in centimeters for each plant.\n    days (int): The number of days to simulate plant growth.\n\n    Returns:\n    List[float]: The final heights of the plants after the simulation period.\n\n\n    [EXAMPLES]\n    \n    assert candidate([5.0, 8.0], [1.0, 0.8], 5) == [10.0, 12.0]\n    assert candidate([0.0, 0.0, 0.0], [1.0, 2.0, 3.0], 10) == [10.0, 20.0, 30.0]\n\n    [/EXAMPLES]\n    \"\"\"\n    # Ensure that the input lists have the same length\n    if len(initial_heights) != len(growth_rates):\n        raise ValueError(\"The number of initial heights must match the number of growth rates.\")\n\n    # Initialize the final heights list with the initial heights\n    final_heights = initial_heights.copy()\n\n    # Simulate growth for each plant over the specified number of days\n    for i in range(len(final_heights)):\n        final_heights[i] += growth_rates[i] * days\n\n    # Round the final heights to one decimal place\n    final_heights = [round(height, 1) for height in final_heights]\n\n    return final_heights\n\n", "test": "def check(candidate):\n    assert candidate([100.0, 150.0], [2.0, 1.5], 15) == [130.0, 172.5]\n    assert candidate([5.5, 7.7, 9.9], [0.55, 0.77, 0.99], 9) == [10.4, 14.6, 18.8]\n    assert candidate([100.0, 200.0, 300.0, 400.0], [0.1, 0.2, 0.3, 0.4], 50) == [105.0, 210.0, 315.0, 420.0]\n    assert candidate([25.0, 50.0, 75.0, 100.0], [0.25, 0.5, 0.75, 1.0], 40) == [35.0, 70.0, 105.0, 140.0]\n    assert candidate([0.001, 0.01, 0.1, 1.0, 10.0], [0.001, 0.01, 0.1, 1.0, 10.0], 5) == [0.0, 0.1, 0.6, 6.0, 60.0]\n    assert candidate([1000.0], [10.0], 1) == [1010.0]\n    assert candidate([0.1, 0.2, 0.3], [0.01, 0.02, 0.03], 1000) == [10.1, 20.2, 30.3]\n    assert candidate([0.0, 0.0, 0.0], [1.0, 2.0, 3.0], 10) == [10.0, 20.0, 30.0]\n    assert candidate([5.0, 8.0], [1.0, 0.8], 5) == [10.0, 12.0]\n    assert candidate([10.0, 15.0, 12.5], [0.5, 0.3, 0.7], 7) == [13.5, 17.1, 17.4]\n", "language": "python"}
{"task_id": "0497b276-6b49-4479-adfb-8dfca51f8fbd-3266032184973707583", "prompt": "Based on the information provided in the documentation string, finalize the function's code. Ensure the function is written as a single, uninterrupted code block, and maintain the existing function name and input parameters.\n\n```python\nfrom itertools import permutations\nfrom typing import List\n\ndef decode_ancient_script(symbols: List[str], values: List[int], equation: str) -> bool:\n    \"\"\"You are an archaeologist who has discovered an ancient mathematical equation written in an unknown script. Each symbol in the script represents a digit from 0 to 9, but you don't know which symbol corresponds to which digit. You have, however, managed to decipher some information about the values of these symbols.\n\n    Your task is to determine if there exists a valid assignment of digits to symbols that makes the equation true.\n\n    Parameters:\n    - symbols: A list of unique characters representing the symbols in the script.\n    - values: A list of unique integers (0-9) that the symbols can represent.\n    - equation: A string representing the equation, using the symbols and the operators '+' and '='.\n\n    Return True if there exists a valid assignment of digits to symbols that makes the equation true, and False otherwise.\n\n    Note: Each symbol must be assigned a unique digit, and leading zeros are not allowed in numbers.\n\n\n    [EXAMPLES]\n    \n    assert candidate(['U', 'V', 'W'], [1, 2, 3], 'U+V=W') == True\n    assert candidate(['X', 'Y', 'Z'], [0, 1, 2], 'XY+Z=YX') == False\n\n    [/EXAMPLES]\n    \"\"\"\n```\n", "entry_point": "decode_ancient_script", "solution": "from itertools import permutations\nfrom typing import List\n\ndef decode_ancient_script(symbols: List[str], values: List[int], equation: str) -> bool:\n    \"\"\"You are an archaeologist who has discovered an ancient mathematical equation written in an unknown script. Each symbol in the script represents a digit from 0 to 9, but you don't know which symbol corresponds to which digit. You have, however, managed to decipher some information about the values of these symbols.\n\n    Your task is to determine if there exists a valid assignment of digits to symbols that makes the equation true.\n\n    Parameters:\n    - symbols: A list of unique characters representing the symbols in the script.\n    - values: A list of unique integers (0-9) that the symbols can represent.\n    - equation: A string representing the equation, using the symbols and the operators '+' and '='.\n\n    Return True if there exists a valid assignment of digits to symbols that makes the equation true, and False otherwise.\n\n    Note: Each symbol must be assigned a unique digit, and leading zeros are not allowed in numbers.\n\n\n    [EXAMPLES]\n    \n    assert candidate(['U', 'V', 'W'], [1, 2, 3], 'U+V=W') == True\n    assert candidate(['X', 'Y', 'Z'], [0, 1, 2], 'XY+Z=YX') == False\n\n    [/EXAMPLES]\n    \"\"\"\n    def evaluate(assignment):\n        translation = str.maketrans(''.join(symbols), ''.join(map(str, assignment)))\n        left, right = equation.translate(translation).split('=')\n        left_parts = left.split('+')\n        \n        # Check for leading zeros\n        if any(part.startswith('0') and len(part) > 1 for part in left_parts + [right]):\n            return False\n        \n        return sum(int(part) for part in left_parts) == int(right)\n\n    def is_valid_assignment(assignment):\n        return len(set(assignment)) == len(assignment)\n\n    for perm in permutations(values, len(symbols)):\n        if is_valid_assignment(perm) and evaluate(perm):\n            return True\n\n    return False\n\n", "test": "def check(candidate):\n    assert candidate(['A', 'B', 'C', 'D'], [1, 2, 3, 4], 'AB+CD=DC') == False\n    assert candidate(['Y', 'Z'], [0, 9], 'Y+Z=Z') == True\n    assert candidate(['X', 'Y', 'Z'], [0, 1, 2], 'XY+Z=YX') == False\n    assert candidate(['P', 'Q', 'R'], [2, 3, 5], 'P+Q=R') == True\n    assert candidate(['Q', 'R', 'S', 'T'], [2, 4, 6, 8], 'QR+S=T') == False\n    assert candidate(['A', 'B'], [0, 1], 'A+A=B') == False\n    assert candidate(['K', 'L', 'M', 'N', 'O'], [1, 3, 5, 7, 9], 'KL+MN=O') == False\n    assert candidate(['F', 'G', 'H', 'I', 'J'], [2, 4, 6, 8, 0], 'FG+HI=J') == False\n    assert candidate(['U', 'V', 'W'], [1, 2, 3], 'U+V=W') == True\n    assert candidate(['J', 'K', 'L'], [3, 4, 7], 'JK+J=L') == False\n", "language": "python"}
{"task_id": "b22e9f2a-63af-4846-8ee8-c5a1708961461784594963399827233", "prompt": "Fulfill the following program fragment entirely within one contiguous code section.\n\n```python\nfrom typing import List\n\ndef max_profit_stock(prices: List[int]) -> int:\n    \"\"\"\n    A time traveler wants to maximize profits in the stock market. Given a list of stock prices\n    where the i-th element represents the price on the i-th day, calculate the maximum profit\n    that can be obtained by buying and selling stocks. Multiple transactions are allowed, but\n    you must sell before buying again.\n\n    This function uses dynamic programming to efficiently calculate the maximum profit.\n\n\n    [EXAMPLES]\n    \n    assert candidate([1, 1, 1, 1, 1]) == 0\n    assert candidate([1] + [0] * 998 + [1]) == 1\n\n    [/EXAMPLES]\n    \"\"\"\n```\n", "entry_point": "max_profit_stock", "solution": "from typing import List\n\ndef max_profit_stock(prices: List[int]) -> int:\n    \"\"\"\n    A time traveler wants to maximize profits in the stock market. Given a list of stock prices\n    where the i-th element represents the price on the i-th day, calculate the maximum profit\n    that can be obtained by buying and selling stocks. Multiple transactions are allowed, but\n    you must sell before buying again.\n\n    This function uses dynamic programming to efficiently calculate the maximum profit.\n\n\n    [EXAMPLES]\n    \n    assert candidate([1, 1, 1, 1, 1]) == 0\n    assert candidate([1] + [0] * 998 + [1]) == 1\n\n    [/EXAMPLES]\n    \"\"\"\n    if not prices:\n        return 0\n\n    n = len(prices)\n    # Initialize dp array to store maximum profit at each day\n    dp = [0] * n\n\n    for i in range(1, n):\n        # Calculate profit from previous day to current day\n        profit = prices[i] - prices[i-1]\n        \n        # If profit is positive, add it to the maximum profit so far\n        if profit > 0:\n            dp[i] = dp[i-1] + profit\n        else:\n            # If no profit can be made, carry forward the previous day's profit\n            dp[i] = dp[i-1]\n\n    # Return the maximum profit achievable\n    return dp[-1]\n\n", "test": "def check(candidate):\n    assert candidate([1] + [0] * 998 + [1]) == 1\n    assert candidate([1, 1, 1, 1, 1]) == 0\n    assert candidate([2, 1, 2, 0, 1]) == 2\n    assert candidate([1000 - i for i in range(1000)]) == 0\n    assert candidate([]) == 0\n    assert candidate([7, 1, 5, 3, 6, 4]) == 7\n    assert candidate([10, 1, 10, 1, 10, 1]) == 18\n    assert candidate([1, 2] * 50) == 50\n    assert candidate([5, 4, 3, 2, 1, 2, 3, 4, 5]) == 4\n    assert candidate([0, 100, 0, 100, 0, 100]) == 300\n", "language": "python"}
{"task_id": "39cd13e4-ad82-43a0-9251-3a596fd4a1658602889066894750888", "prompt": "Complete the function according to the specifications in the docstring. Provide the entire function in a single code block. Take care to include logic for handling edge cases in your implementation.\n\n```python\nimport math\nfrom typing import List, Tuple\n\ndef optimize_solar_panel_layout(roof_dimensions: Tuple[float, float], panel_dimensions: Tuple[float, float]) -> List[Tuple[float, float]]:\n    \"\"\"\n    Determine the optimal layout of solar panels on a rectangular roof.\n\n    This function takes the dimensions of a rectangular roof and the\n    dimensions of solar panels as input. It then calculates the best\n    arrangement of panels to maximize coverage while maintaining proper\n    spacing and alignment.\n\n    The function considers factors such as panel orientation, spacing\n    for maintenance access, and edge clearances. It uses both the roof\n    and panel dimensions to determine the layout.\n\n    Args:\n    roof_dimensions (Tuple[float, float]): The length and width of the roof in meters.\n    panel_dimensions (Tuple[float, float]): The length and width of each solar panel in meters.\n\n    Returns:\n    List[Tuple[float, float]]: A list of (x, y) coordinates representing the top-left corner\n                               of each solar panel in the optimal layout.\n\n\n    [EXAMPLES]\n    \n    assert candidate((9.5, 7.5), (1.6, 1.0)) == [(0.5, 0.5), (2.0, 0.5), (3.5, 0.5), (5.0, 0.5), (0.5, 2.6), (2.0, 2.6), (3.5, 2.6), (5.0, 2.6), (0.5, 4.7), (2.0, 4.7), (3.5, 4.7), (5.0, 4.7), (0.5, 6.8), (2.0, 6.8), (3.5, 6.8), (5.0, 6.8)]\n    assert candidate((7.0, 5.5), (1.4, 0.9)) == [(0.5, 0.5), (1.9, 0.5), (3.3, 0.5), (0.5, 2.4), (1.9, 2.4), (3.3, 2.4), (0.5, 4.3), (1.9, 4.3), (3.3, 4.3)]\n\n    [/EXAMPLES]\n    \"\"\"\n```\n", "entry_point": "optimize_solar_panel_layout", "solution": "import math\nfrom typing import List, Tuple\n\ndef optimize_solar_panel_layout(roof_dimensions: Tuple[float, float], panel_dimensions: Tuple[float, float]) -> List[Tuple[float, float]]:\n    \"\"\"\n    Determine the optimal layout of solar panels on a rectangular roof.\n\n    This function takes the dimensions of a rectangular roof and the\n    dimensions of solar panels as input. It then calculates the best\n    arrangement of panels to maximize coverage while maintaining proper\n    spacing and alignment.\n\n    The function considers factors such as panel orientation, spacing\n    for maintenance access, and edge clearances. It uses both the roof\n    and panel dimensions to determine the layout.\n\n    Args:\n    roof_dimensions (Tuple[float, float]): The length and width of the roof in meters.\n    panel_dimensions (Tuple[float, float]): The length and width of each solar panel in meters.\n\n    Returns:\n    List[Tuple[float, float]]: A list of (x, y) coordinates representing the top-left corner\n                               of each solar panel in the optimal layout.\n\n\n    [EXAMPLES]\n    \n    assert candidate((9.5, 7.5), (1.6, 1.0)) == [(0.5, 0.5), (2.0, 0.5), (3.5, 0.5), (5.0, 0.5), (0.5, 2.6), (2.0, 2.6), (3.5, 2.6), (5.0, 2.6), (0.5, 4.7), (2.0, 4.7), (3.5, 4.7), (5.0, 4.7), (0.5, 6.8), (2.0, 6.8), (3.5, 6.8), (5.0, 6.8)]\n    assert candidate((7.0, 5.5), (1.4, 0.9)) == [(0.5, 0.5), (1.9, 0.5), (3.3, 0.5), (0.5, 2.4), (1.9, 2.4), (3.3, 2.4), (0.5, 4.3), (1.9, 4.3), (3.3, 4.3)]\n\n    [/EXAMPLES]\n    \"\"\"\n    def calculate_layout(roof_length, roof_width, panel_length, panel_width, spacing):\n        panels_per_row = math.floor((roof_width - 2 * spacing) / (panel_width + spacing))\n        rows = math.floor((roof_length - 2 * spacing) / (panel_length + spacing))\n        \n        layout = []\n        for row in range(rows):\n            for col in range(panels_per_row):\n                x = spacing + col * (panel_width + spacing)\n                y = spacing + row * (panel_length + spacing)\n                layout.append((round(x, 1), round(y, 1)))\n        \n        return layout, len(layout)\n\n    roof_length, roof_width = roof_dimensions\n    panel_length, panel_width = panel_dimensions\n    \n    # Try both orientations of the panels\n    layout1, count1 = calculate_layout(roof_length, roof_width, panel_length, panel_width, 0.5)\n    layout2, count2 = calculate_layout(roof_length, roof_width, panel_width, panel_length, 0.5)\n    \n    # Return the layout with more panels\n    if count1 >= count2:\n        return layout1\n    else:\n        return layout2\n\n", "test": "def check(candidate):\n    assert candidate((30.0, 20.0), (2.2, 1.4)) == [(0.5, 0.5), (3.2, 0.5), (5.9, 0.5), (8.6, 0.5), (11.3, 0.5), (14.0, 0.5), (16.7, 0.5), (0.5, 2.4), (3.2, 2.4), (5.9, 2.4), (8.6, 2.4), (11.3, 2.4), (14.0, 2.4), (16.7, 2.4), (0.5, 4.3), (3.2, 4.3), (5.9, 4.3), (8.6, 4.3), (11.3, 4.3), (14.0, 4.3), (16.7, 4.3), (0.5, 6.2), (3.2, 6.2), (5.9, 6.2), (8.6, 6.2), (11.3, 6.2), (14.0, 6.2), (16.7, 6.2), (0.5, 8.1), (3.2, 8.1), (5.9, 8.1), (8.6, 8.1), (11.3, 8.1), (14.0, 8.1), (16.7, 8.1), (0.5, 10.0), (3.2, 10.0), (5.9, 10.0), (8.6, 10.0), (11.3, 10.0), (14.0, 10.0), (16.7, 10.0), (0.5, 11.9), (3.2, 11.9), (5.9, 11.9), (8.6, 11.9), (11.3, 11.9), (14.0, 11.9), (16.7, 11.9), (0.5, 13.8), (3.2, 13.8), (5.9, 13.8), (8.6, 13.8), (11.3, 13.8), (14.0, 13.8), (16.7, 13.8), (0.5, 15.7), (3.2, 15.7), (5.9, 15.7), (8.6, 15.7), (11.3, 15.7), (14.0, 15.7), (16.7, 15.7), (0.5, 17.6), (3.2, 17.6), (5.9, 17.6), (8.6, 17.6), (11.3, 17.6), (14.0, 17.6), (16.7, 17.6), (0.5, 19.5), (3.2, 19.5), (5.9, 19.5), (8.6, 19.5), (11.3, 19.5), (14.0, 19.5), (16.7, 19.5), (0.5, 21.4), (3.2, 21.4), (5.9, 21.4), (8.6, 21.4), (11.3, 21.4), (14.0, 21.4), (16.7, 21.4), (0.5, 23.3), (3.2, 23.3), (5.9, 23.3), (8.6, 23.3), (11.3, 23.3), (14.0, 23.3), (16.7, 23.3), (0.5, 25.2), (3.2, 25.2), (5.9, 25.2), (8.6, 25.2), (11.3, 25.2), (14.0, 25.2), (16.7, 25.2), (0.5, 27.1), (3.2, 27.1), (5.9, 27.1), (8.6, 27.1), (11.3, 27.1), (14.0, 27.1), (16.7, 27.1)]\n    assert candidate((18.5, 12.5), (1.9, 1.1)) == [(0.5, 0.5), (2.1, 0.5), (3.7, 0.5), (5.3, 0.5), (6.9, 0.5), (8.5, 0.5), (10.1, 0.5), (0.5, 2.9), (2.1, 2.9), (3.7, 2.9), (5.3, 2.9), (6.9, 2.9), (8.5, 2.9), (10.1, 2.9), (0.5, 5.3), (2.1, 5.3), (3.7, 5.3), (5.3, 5.3), (6.9, 5.3), (8.5, 5.3), (10.1, 5.3), (0.5, 7.7), (2.1, 7.7), (3.7, 7.7), (5.3, 7.7), (6.9, 7.7), (8.5, 7.7), (10.1, 7.7), (0.5, 10.1), (2.1, 10.1), (3.7, 10.1), (5.3, 10.1), (6.9, 10.1), (8.5, 10.1), (10.1, 10.1), (0.5, 12.5), (2.1, 12.5), (3.7, 12.5), (5.3, 12.5), (6.9, 12.5), (8.5, 12.5), (10.1, 12.5), (0.5, 14.9), (2.1, 14.9), (3.7, 14.9), (5.3, 14.9), (6.9, 14.9), (8.5, 14.9), (10.1, 14.9)]\n    assert candidate((20.0, 15.0), (1.8, 1.1)) == [(0.5, 0.5), (2.8, 0.5), (5.1, 0.5), (7.4, 0.5), (9.7, 0.5), (12.0, 0.5), (0.5, 2.1), (2.8, 2.1), (5.1, 2.1), (7.4, 2.1), (9.7, 2.1), (12.0, 2.1), (0.5, 3.7), (2.8, 3.7), (5.1, 3.7), (7.4, 3.7), (9.7, 3.7), (12.0, 3.7), (0.5, 5.3), (2.8, 5.3), (5.1, 5.3), (7.4, 5.3), (9.7, 5.3), (12.0, 5.3), (0.5, 6.9), (2.8, 6.9), (5.1, 6.9), (7.4, 6.9), (9.7, 6.9), (12.0, 6.9), (0.5, 8.5), (2.8, 8.5), (5.1, 8.5), (7.4, 8.5), (9.7, 8.5), (12.0, 8.5), (0.5, 10.1), (2.8, 10.1), (5.1, 10.1), (7.4, 10.1), (9.7, 10.1), (12.0, 10.1), (0.5, 11.7), (2.8, 11.7), (5.1, 11.7), (7.4, 11.7), (9.7, 11.7), (12.0, 11.7), (0.5, 13.3), (2.8, 13.3), (5.1, 13.3), (7.4, 13.3), (9.7, 13.3), (12.0, 13.3), (0.5, 14.9), (2.8, 14.9), (5.1, 14.9), (7.4, 14.9), (9.7, 14.9), (12.0, 14.9), (0.5, 16.5), (2.8, 16.5), (5.1, 16.5), (7.4, 16.5), (9.7, 16.5), (12.0, 16.5)]\n    assert candidate((9.5, 7.5), (1.6, 1.0)) == [(0.5, 0.5), (2.0, 0.5), (3.5, 0.5), (5.0, 0.5), (0.5, 2.6), (2.0, 2.6), (3.5, 2.6), (5.0, 2.6), (0.5, 4.7), (2.0, 4.7), (3.5, 4.7), (5.0, 4.7), (0.5, 6.8), (2.0, 6.8), (3.5, 6.8), (5.0, 6.8)]\n    assert candidate((40.0, 30.0), (2.5, 1.6)) == [(0.5, 0.5), (2.6, 0.5), (4.7, 0.5), (6.8, 0.5), (8.9, 0.5), (11.0, 0.5), (13.1, 0.5), (15.2, 0.5), (17.3, 0.5), (19.4, 0.5), (21.5, 0.5), (23.6, 0.5), (25.7, 0.5), (0.5, 3.5), (2.6, 3.5), (4.7, 3.5), (6.8, 3.5), (8.9, 3.5), (11.0, 3.5), (13.1, 3.5), (15.2, 3.5), (17.3, 3.5), (19.4, 3.5), (21.5, 3.5), (23.6, 3.5), (25.7, 3.5), (0.5, 6.5), (2.6, 6.5), (4.7, 6.5), (6.8, 6.5), (8.9, 6.5), (11.0, 6.5), (13.1, 6.5), (15.2, 6.5), (17.3, 6.5), (19.4, 6.5), (21.5, 6.5), (23.6, 6.5), (25.7, 6.5), (0.5, 9.5), (2.6, 9.5), (4.7, 9.5), (6.8, 9.5), (8.9, 9.5), (11.0, 9.5), (13.1, 9.5), (15.2, 9.5), (17.3, 9.5), (19.4, 9.5), (21.5, 9.5), (23.6, 9.5), (25.7, 9.5), (0.5, 12.5), (2.6, 12.5), (4.7, 12.5), (6.8, 12.5), (8.9, 12.5), (11.0, 12.5), (13.1, 12.5), (15.2, 12.5), (17.3, 12.5), (19.4, 12.5), (21.5, 12.5), (23.6, 12.5), (25.7, 12.5), (0.5, 15.5), (2.6, 15.5), (4.7, 15.5), (6.8, 15.5), (8.9, 15.5), (11.0, 15.5), (13.1, 15.5), (15.2, 15.5), (17.3, 15.5), (19.4, 15.5), (21.5, 15.5), (23.6, 15.5), (25.7, 15.5), (0.5, 18.5), (2.6, 18.5), (4.7, 18.5), (6.8, 18.5), (8.9, 18.5), (11.0, 18.5), (13.1, 18.5), (15.2, 18.5), (17.3, 18.5), (19.4, 18.5), (21.5, 18.5), (23.6, 18.5), (25.7, 18.5), (0.5, 21.5), (2.6, 21.5), (4.7, 21.5), (6.8, 21.5), (8.9, 21.5), (11.0, 21.5), (13.1, 21.5), (15.2, 21.5), (17.3, 21.5), (19.4, 21.5), (21.5, 21.5), (23.6, 21.5), (25.7, 21.5), (0.5, 24.5), (2.6, 24.5), (4.7, 24.5), (6.8, 24.5), (8.9, 24.5), (11.0, 24.5), (13.1, 24.5), (15.2, 24.5), (17.3, 24.5), (19.4, 24.5), (21.5, 24.5), (23.6, 24.5), (25.7, 24.5), (0.5, 27.5), (2.6, 27.5), (4.7, 27.5), (6.8, 27.5), (8.9, 27.5), (11.0, 27.5), (13.1, 27.5), (15.2, 27.5), (17.3, 27.5), (19.4, 27.5), (21.5, 27.5), (23.6, 27.5), (25.7, 27.5), (0.5, 30.5), (2.6, 30.5), (4.7, 30.5), (6.8, 30.5), (8.9, 30.5), (11.0, 30.5), (13.1, 30.5), (15.2, 30.5), (17.3, 30.5), (19.4, 30.5), (21.5, 30.5), (23.6, 30.5), (25.7, 30.5), (0.5, 33.5), (2.6, 33.5), (4.7, 33.5), (6.8, 33.5), (8.9, 33.5), (11.0, 33.5), (13.1, 33.5), (15.2, 33.5), (17.3, 33.5), (19.4, 33.5), (21.5, 33.5), (23.6, 33.5), (25.7, 33.5), (0.5, 36.5), (2.6, 36.5), (4.7, 36.5), (6.8, 36.5), (8.9, 36.5), (11.0, 36.5), (13.1, 36.5), (15.2, 36.5), (17.3, 36.5), (19.4, 36.5), (21.5, 36.5), (23.6, 36.5), (25.7, 36.5)]\n    assert candidate((7.0, 5.5), (1.4, 0.9)) == [(0.5, 0.5), (1.9, 0.5), (3.3, 0.5), (0.5, 2.4), (1.9, 2.4), (3.3, 2.4), (0.5, 4.3), (1.9, 4.3), (3.3, 4.3)]\n    assert candidate((8.5, 6.5), (1.5, 0.9)) == [(0.5, 0.5), (2.5, 0.5), (0.5, 1.9), (2.5, 1.9), (0.5, 3.3), (2.5, 3.3), (0.5, 4.7), (2.5, 4.7), (0.5, 6.1), (2.5, 6.1)]\n", "language": "python"}
{"task_id": "4ec88a32-b945-4a55-ba0d-03bd4c2a22cd8636842187451411840", "prompt": "Using the doc string as a guide, fill in the rest of the function. Incorporate the entire function into a single code block, and don't forget to handle any edge cases that may arise.\n\n```python\nfrom typing import List, Tuple\n\ndef space_station_maintenance(parts: List[int], repairs: List[Tuple[int, int]]) -> List[int]:\n    \"\"\"\n    The International Space Station needs maintenance, and you're in charge of optimizing the repair schedule.\n    Each part of the station has a unique identifier and a 'wear level'. The crew can perform repairs, which\n    decrease the wear level of a range of parts.\n\n    Given a list of current wear levels for each part and a list of repair operations, calculate the final\n    wear levels after all repairs are completed. Use both list manipulation and integer operations to solve this.\n\n    :param parts: A list of integers representing the current wear level of each part (0-100).\n    :param repairs: A list of tuples, where each tuple contains two integers (start, end) representing\n                    the range of parts to be repaired in each operation. Each repair reduces the wear\n                    level of affected parts by 10, with a minimum of 0.\n    :return: A list of integers representing the final wear levels of all parts after repairs.\n\n\n    [EXAMPLES]\n    \n    assert candidate([10, 10, 10, 10, 10], [(0, 4), (0, 4), (0, 4), (0, 4), (0, 4)]) == [0, 0, 0, 0, 0]\n    assert candidate([], []) == []\n\n    [/EXAMPLES]\n    \"\"\"\n```\n", "entry_point": "space_station_maintenance", "solution": "from typing import List, Tuple\n\ndef space_station_maintenance(parts: List[int], repairs: List[Tuple[int, int]]) -> List[int]:\n    \"\"\"\n    The International Space Station needs maintenance, and you're in charge of optimizing the repair schedule.\n    Each part of the station has a unique identifier and a 'wear level'. The crew can perform repairs, which\n    decrease the wear level of a range of parts.\n\n    Given a list of current wear levels for each part and a list of repair operations, calculate the final\n    wear levels after all repairs are completed. Use both list manipulation and integer operations to solve this.\n\n    :param parts: A list of integers representing the current wear level of each part (0-100).\n    :param repairs: A list of tuples, where each tuple contains two integers (start, end) representing\n                    the range of parts to be repaired in each operation. Each repair reduces the wear\n                    level of affected parts by 10, with a minimum of 0.\n    :return: A list of integers representing the final wear levels of all parts after repairs.\n\n\n    [EXAMPLES]\n    \n    assert candidate([10, 10, 10, 10, 10], [(0, 4), (0, 4), (0, 4), (0, 4), (0, 4)]) == [0, 0, 0, 0, 0]\n    assert candidate([], []) == []\n\n    [/EXAMPLES]\n    \"\"\"\n    def apply_repair(start: int, end: int) -> None:\n        for i in range(start, end + 1):\n            parts[i] = max(0, parts[i] - 10)\n\n    for repair in repairs:\n        start, end = repair\n        apply_repair(start, end)\n\n    return parts\n\n", "test": "def check(candidate):\n    assert candidate([30, 40, 50, 60, 70, 80], [(0, 2), (3, 5), (1, 4)]) == [20, 20, 30, 40, 50, 70]\n    assert candidate([], []) == []\n    assert candidate([1], [(0, 0)]) == [0]\n    assert candidate([15, 25, 35, 45, 55, 65, 75, 85, 95], [(0, 8), (2, 6), (4, 4)]) == [5, 15, 15, 25, 25, 45, 55, 75, 85]\n    assert candidate([1, 2, 3, 4, 5, 6, 7, 8, 9, 10], [(0, 9)]) == [0, 0, 0, 0, 0, 0, 0, 0, 0, 0]\n    assert candidate([10, 10, 10, 10, 10], [(0, 4), (0, 4), (0, 4), (0, 4), (0, 4)]) == [0, 0, 0, 0, 0]\n    assert candidate([100, 90, 80, 70, 60, 50, 40, 30, 20, 10], [(0, 9), (2, 7), (4, 5)]) == [90, 80, 60, 50, 30, 20, 20, 10, 10, 0]\n    assert candidate([50], []) == [50]\n    assert candidate([100, 0, 100, 0, 100], [(0, 4), (0, 2), (2, 4)]) == [80, 0, 70, 0, 80]\n    assert candidate([99, 88, 77, 66, 55], [(0, 4), (1, 3)]) == [89, 68, 57, 46, 45]\n", "language": "python"}
{"task_id": "8d607ff2-94f1-4fdd-a0ba-e7d9803b72065628753613996985255", "prompt": "Implement the function within a code block, following the docstring's directives explicitly. Any auxiliary functions or classes must be declared exclusively inside the given function. Adhere to the instructions provided in the docstring without deviation.\n\n```python\ndef roman_to_integer(s: str) -> int:\n    \"\"\"\n    Convert a Roman numeral to an integer.\n\n    This function takes a string representing a Roman numeral as input and returns the corresponding integer value. The function should handle Roman numerals from 1 to 3999 (I to MMMCMXCIX). Assume that the input is always valid and in uppercase.\n\n    Roman numerals are represented by seven different symbols: I, V, X, L, C, D and M.\n\n\n    [EXAMPLES]\n    \n    assert candidate(\"MMMCMXCIX\") == 3999\n    assert candidate(\"V\") == 5\n\n    [/EXAMPLES]\n    \"\"\"\n```\n", "entry_point": "roman_to_integer", "solution": "def roman_to_integer(s: str) -> int:\n    \"\"\"\n    Convert a Roman numeral to an integer.\n\n    This function takes a string representing a Roman numeral as input and returns the corresponding integer value. The function should handle Roman numerals from 1 to 3999 (I to MMMCMXCIX). Assume that the input is always valid and in uppercase.\n\n    Roman numerals are represented by seven different symbols: I, V, X, L, C, D and M.\n\n\n    [EXAMPLES]\n    \n    assert candidate(\"MMMCMXCIX\") == 3999\n    assert candidate(\"V\") == 5\n\n    [/EXAMPLES]\n    \"\"\"\n    roman_values = {\n        'I': 1,\n        'V': 5,\n        'X': 10,\n        'L': 50,\n        'C': 100,\n        'D': 500,\n        'M': 1000\n    }\n    \n    result = 0\n    prev_value = 0\n    \n    for char in reversed(s):\n        current_value = roman_values[char]\n        if current_value >= prev_value:\n            result += current_value\n        else:\n            result -= current_value\n        prev_value = current_value\n    \n    return result\n\n", "test": "def check(candidate):\n    assert candidate(\"XCIX\") == 99\n    assert candidate(\"V\") == 5\n    assert candidate(\"CMXCIX\") == 999\n    assert candidate(\"I\") == 1\n    assert candidate(\"MMMCMXCIX\") == 3999\n    assert candidate(\"X\") == 10\n    assert candidate(\"M\") == 1000\n    assert candidate(\"D\") == 500\n    assert candidate(\"CDXCIX\") == 499\n    assert candidate(\"IV\") == 4\n", "language": "python"}
{"task_id": "92bcacdc-3bd8-43ff-b1c0-5b480c553c462004538249751609692", "prompt": "I'd be glad to help you finish the code. Could you share the full code segment in one uninterrupted block?\n\n```python\ndef chess_knight_moves(start: str, end: str) -> int:\n    \"\"\"\n    Calculate the minimum number of moves a knight needs to reach a target square on a chessboard.\n\n    A chess engine developer wants to optimize the knight's movement calculation. This function\n    takes two chess square notations (e.g., \"e4\", \"b7\") as input, representing the starting and\n    ending positions of the knight. It returns the minimum number of moves required for the knight\n    to reach the target square.\n\n\n    [EXAMPLES]\n    \n    assert candidate(\"h1\", \"a8\") == 6\n    assert candidate(\"a1\", \"h8\") == 6\n\n    [/EXAMPLES]\n    \"\"\"\n```\n", "entry_point": "chess_knight_moves", "solution": "def chess_knight_moves(start: str, end: str) -> int:\n    \"\"\"\n    Calculate the minimum number of moves a knight needs to reach a target square on a chessboard.\n\n    A chess engine developer wants to optimize the knight's movement calculation. This function\n    takes two chess square notations (e.g., \"e4\", \"b7\") as input, representing the starting and\n    ending positions of the knight. It returns the minimum number of moves required for the knight\n    to reach the target square.\n\n\n    [EXAMPLES]\n    \n    assert candidate(\"h1\", \"a8\") == 6\n    assert candidate(\"a1\", \"h8\") == 6\n\n    [/EXAMPLES]\n    \"\"\"\n    from collections import deque\n\n    def get_coordinates(square):\n        file, rank = square\n        return (ord(file) - ord('a'), int(rank) - 1)\n\n    def get_valid_moves(x, y):\n        moves = [\n            (x+2, y+1), (x+2, y-1), (x-2, y+1), (x-2, y-1),\n            (x+1, y+2), (x+1, y-2), (x-1, y+2), (x-1, y-2)\n        ]\n        return [(nx, ny) for nx, ny in moves if 0 <= nx < 8 and 0 <= ny < 8]\n\n    start_x, start_y = get_coordinates(start)\n    end_x, end_y = get_coordinates(end)\n\n    queue = deque([(start_x, start_y, 0)])\n    visited = set()\n\n    while queue:\n        x, y, moves = queue.popleft()\n\n        if (x, y) == (end_x, end_y):\n            return moves\n\n        if (x, y) not in visited:\n            visited.add((x, y))\n            for nx, ny in get_valid_moves(x, y):\n                queue.append((nx, ny, moves + 1))\n\n    return -1  # This should never happen for a valid chessboard\n\n", "test": "def check(candidate):\n    assert candidate(\"b2\", \"c4\") == 1\n    assert candidate(\"e6\", \"c2\") == 2\n    assert candidate(\"h1\", \"a8\") == 6\n    assert candidate(\"a4\", \"h5\") == 4\n    assert candidate(\"c3\", \"f7\") == 3\n    assert candidate(\"d5\", \"f6\") == 1\n    assert candidate(\"g7\", \"b2\") == 4\n    assert candidate(\"a1\", \"h8\") == 6\n    assert candidate(\"b5\", \"g8\") == 4\n    assert candidate(\"b8\", \"g3\") == 4\n", "language": "python"}
{"task_id": "51eb3b81-bc4d-4a10-a16e-4f3ea37c85d7-4682517174849397285", "prompt": "Complete the specified function to make it independently runnable in a single code segment. Do not include any code outside of the function's boundaries. Restrict yourself to the libraries that are pre-imported in the problem. If necessary, create additional functions or classes, but only within the confines of the given function.\n\n```python\nfrom itertools import permutations\nfrom typing import List\nimport re\nimport string\nimport itertools\n\ndef decrypt_ancient_scroll(ciphertext: str, known_words: List[str]) -> str:\n    \"\"\"\n    An archaeologist has discovered an ancient scroll with encrypted text. The encryption\n    method is a simple substitution cipher, where each letter is replaced by another letter\n    consistently throughout the text. Given the encrypted text and a list of known words\n    that should appear in the decrypted text, create a function to decrypt the scroll.\n\n    :param ciphertext: The encrypted text from the ancient scroll.\n    :param known_words: A list of words known to appear in the decrypted text.\n    :return: The decrypted text, or \"Unable to decrypt\" if decryption is not possible.\n\n\n    [EXAMPLES]\n    \n    assert candidate(\"KHOOR ZRUOG, WKLV LV D WHVW PHVVDJH\", [\"HELLO\", \"WORLD\", \"TEST\", \"MESSAGE\"]) == 'Unable to decrypt'\n    assert candidate(\"ABCDEFGHIJKLMNOPQRSTUVWXYZ\", [\"HELLO\", \"WORLD\"]) == 'Unable to decrypt'\n\n    [/EXAMPLES]\n    \"\"\"\n```\n", "entry_point": "decrypt_ancient_scroll", "solution": "from itertools import permutations\nfrom typing import List\nimport re\nimport string\nimport itertools\n\ndef decrypt_ancient_scroll(ciphertext: str, known_words: List[str]) -> str:\n    \"\"\"\n    An archaeologist has discovered an ancient scroll with encrypted text. The encryption\n    method is a simple substitution cipher, where each letter is replaced by another letter\n    consistently throughout the text. Given the encrypted text and a list of known words\n    that should appear in the decrypted text, create a function to decrypt the scroll.\n\n    :param ciphertext: The encrypted text from the ancient scroll.\n    :param known_words: A list of words known to appear in the decrypted text.\n    :return: The decrypted text, or \"Unable to decrypt\" if decryption is not possible.\n\n\n    [EXAMPLES]\n    \n    assert candidate(\"KHOOR ZRUOG, WKLV LV D WHVW PHVVDJH\", [\"HELLO\", \"WORLD\", \"TEST\", \"MESSAGE\"]) == 'Unable to decrypt'\n    assert candidate(\"ABCDEFGHIJKLMNOPQRSTUVWXYZ\", [\"HELLO\", \"WORLD\"]) == 'Unable to decrypt'\n\n    [/EXAMPLES]\n    \"\"\"\n    def create_cipher_map(cipher_perm, plain_perm):\n        return dict(zip(cipher_perm, plain_perm))\n    \n    def apply_cipher(text, cipher_map):\n        return ''.join(cipher_map.get(c, c) for c in text)\n    \n    def is_valid_decryption(decrypted, known_words):\n        return all(word in decrypted for word in known_words)\n\n    cipher_chars = set(ciphertext) - set(string.punctuation + ' ')\n    plain_chars = set(''.join(known_words))\n\n    if len(cipher_chars) != len(plain_chars):\n        return \"Unable to decrypt\"\n\n    for cipher_perm in permutations(cipher_chars):\n        for plain_perm in permutations(plain_chars):\n            cipher_map = create_cipher_map(cipher_perm, plain_perm)\n            decrypted = apply_cipher(ciphertext, cipher_map)\n            \n            if is_valid_decryption(decrypted, known_words):\n                return decrypted\n\n    return \"Unable to decrypt\"\n\n", "test": "def check(candidate):\n    assert candidate(\"A\", [\"A\"]) == 'A'\n    assert candidate(\"AAAAAA\", [\"B\"]) == 'BBBBBB'\n    assert candidate(\"ABC DEFG HIJ KLMNO PQRS\", [\"THE\", \"QUICK\", \"BROWN\", \"FOX\"]) == 'Unable to decrypt'\n    assert candidate(\"QWERTYUIOP\", [\"ASDFGHJKL\"]) == 'Unable to decrypt'\n    assert candidate(\"ABC 123 !@#\", [\"XYZ\"]) == 'Unable to decrypt'\n    assert candidate(\"ABCDEFGHIJKLMNOPQRSTUVWXYZ\", [\"HELLO\", \"WORLD\"]) == 'Unable to decrypt'\n    assert candidate(\"ABC DEF GHI\", [\"ABC\", \"DEF\", \"GHI\"]) == 'ABC DEF GHI'\n    assert candidate(\"AAABBBCCC\", [\"AAA\", \"BBB\", \"CCC\"]) == 'AAABBBCCC'\n    assert candidate(\"XYZ\", [\"ABC\"]) == 'ABC'\n    assert candidate(\"KHOOR ZRUOG, WKLV LV D WHVW PHVVDJH\", [\"HELLO\", \"WORLD\", \"TEST\", \"MESSAGE\"]) == 'Unable to decrypt'\n", "language": "python"}
{"task_id": "0089e6b0-9f4a-446a-ba1c-997dba637ef67476378370179937077", "prompt": "Implement the remaining part of the function to fulfill the requirements stated in the docstring. Preserve the original function name and arguments, and enclose the entire function in a single code block.\n\n```python\nfrom typing import List\n\ndef optimize_delivery_route(packages: List[tuple], fuel_capacity: int) -> List[int]:\n    \"\"\"\n    A delivery company wants to optimize its route for package delivery. Given a list of tuples\n    representing packages (weight, value) and the fuel capacity of the delivery vehicle,\n    determine the optimal selection of packages to maximize the total value while staying\n    within the fuel capacity.\n\n    Assume that 1 unit of fuel is consumed per unit of package weight.\n    Return a list of indices representing the selected packages.\n\n\n    [EXAMPLES]\n    \n    assert candidate([(1, 5), (2, 10), (3, 15)], 5) == [1, 2]\n    assert candidate([(10, 100), (5, 50), (3, 30)], 10) == [0]\n\n    [/EXAMPLES]\n    \"\"\"\n```\n", "entry_point": "optimize_delivery_route", "solution": "from typing import List\n\ndef optimize_delivery_route(packages: List[tuple], fuel_capacity: int) -> List[int]:\n    \"\"\"\n    A delivery company wants to optimize its route for package delivery. Given a list of tuples\n    representing packages (weight, value) and the fuel capacity of the delivery vehicle,\n    determine the optimal selection of packages to maximize the total value while staying\n    within the fuel capacity.\n\n    Assume that 1 unit of fuel is consumed per unit of package weight.\n    Return a list of indices representing the selected packages.\n\n\n    [EXAMPLES]\n    \n    assert candidate([(1, 5), (2, 10), (3, 15)], 5) == [1, 2]\n    assert candidate([(10, 100), (5, 50), (3, 30)], 10) == [0]\n\n    [/EXAMPLES]\n    \"\"\"\n    n = len(packages)\n    \n    # Create a 2D table for dynamic programming\n    dp = [[0 for _ in range(fuel_capacity + 1)] for _ in range(n + 1)]\n    \n    # Fill the dp table\n    for i in range(1, n + 1):\n        for w in range(fuel_capacity + 1):\n            weight, value = packages[i-1]\n            if weight <= w:\n                dp[i][w] = max(dp[i-1][w], dp[i-1][w-weight] + value)\n            else:\n                dp[i][w] = dp[i-1][w]\n    \n    # Backtrack to find the selected packages\n    selected_packages = []\n    w = fuel_capacity\n    for i in range(n, 0, -1):\n        if dp[i][w] != dp[i-1][w]:\n            selected_packages.append(i-1)\n            w -= packages[i-1][0]\n    \n    # Reverse the list to get packages in original order\n    selected_packages.reverse()\n    \n    return selected_packages\n\n", "test": "def check(candidate):\n    assert candidate([(1, 10), (2, 20), (3, 30), (4, 40), (5, 50)], 15) == [0, 1, 2, 3, 4]\n    assert candidate([(100, 1000), (200, 2000), (300, 3000)], 500) == [1, 2]\n    assert candidate([(10, 10), (9, 9), (8, 8), (7, 7), (6, 6)], 20) == [0, 1]\n    assert candidate([(1, 5), (2, 10), (3, 15)], 5) == [1, 2]\n    assert candidate([(2, 10), (3, 5), (5, 15), (7, 7), (1, 6)], 10) == [0, 2, 4]\n    assert candidate([(1, 1), (2, 2), (3, 3), (4, 4), (5, 5)], 10) == [0, 1, 2, 3]\n    assert candidate([(5, 5), (4, 4), (3, 3), (2, 2), (1, 1)], 15) == [0, 1, 2, 3, 4]\n    assert candidate([(5, 5), (5, 6), (5, 7), (5, 8), (5, 9)], 20) == [1, 2, 3, 4]\n    assert candidate([(1, 10), (2, 20), (3, 30)], 0) == []\n    assert candidate([(10, 100), (5, 50), (3, 30)], 10) == [0]\n", "language": "python"}
{"task_id": "04720bec-e9d2-49a8-ae72-17618779203c-5507015758025067339", "prompt": "Please adhere to the guidelines provided within the doc string to finalize the function within a single code block. Any supplementary functions or classes should be defined exclusively within the given function.\n\n```python\ndef calculate_orbital_period(mass: float, radius: float) -> float:\n    \"\"\"Calculate the orbital period of a satellite around a celestial body.\n\n    This function determines the time it takes for a satellite to complete one orbit\n    around a celestial body, given the mass of the body and the orbital radius of the satellite.\n    The calculation uses Kepler's Third Law of Planetary Motion and assumes a circular orbit.\n\n    Args:\n        mass (float): The mass of the celestial body in kilograms.\n        radius (float): The orbital radius of the satellite in meters.\n\n    Returns:\n        float: The orbital period in seconds, rounded to two decimal places.\n\n    Note:\n        This function uses the gravitational constant G = 6.67430 x 10^-11 m^3 kg^-1 s^-2.\n\n\n    [EXAMPLES]\n    \n    assert candidate(6.42e23, 3.39e6) == 5991.13\n    assert candidate(1.00e-10, 1.00e-3) == 2432075.24\n\n    [/EXAMPLES]\n    \"\"\"\n```\n", "entry_point": "calculate_orbital_period", "solution": "def calculate_orbital_period(mass: float, radius: float) -> float:\n    \"\"\"Calculate the orbital period of a satellite around a celestial body.\n\n    This function determines the time it takes for a satellite to complete one orbit\n    around a celestial body, given the mass of the body and the orbital radius of the satellite.\n    The calculation uses Kepler's Third Law of Planetary Motion and assumes a circular orbit.\n\n    Args:\n        mass (float): The mass of the celestial body in kilograms.\n        radius (float): The orbital radius of the satellite in meters.\n\n    Returns:\n        float: The orbital period in seconds, rounded to two decimal places.\n\n    Note:\n        This function uses the gravitational constant G = 6.67430 x 10^-11 m^3 kg^-1 s^-2.\n\n\n    [EXAMPLES]\n    \n    assert candidate(6.42e23, 3.39e6) == 5991.13\n    assert candidate(1.00e-10, 1.00e-3) == 2432075.24\n\n    [/EXAMPLES]\n    \"\"\"\n    import math\n\n    # Gravitational constant\n    G = 6.67430e-11  # m^3 kg^-1 s^-2\n\n    # Calculate the orbital period using Kepler's Third Law\n    # T^2 = (4 * pi^2 * r^3) / (G * M)\n    # Where T is the orbital period, r is the orbital radius, G is the gravitational constant, and M is the mass of the celestial body\n\n    T_squared = (4 * math.pi**2 * radius**3) / (G * mass)\n    T = math.sqrt(T_squared)\n\n    # Round the result to two decimal places\n    return round(T, 2)\n\n", "test": "def check(candidate):\n    assert candidate(3.30e23, 2.44e6) == 5102.76\n    assert candidate(1.00e10, 1.00e3) == 243207.52\n    assert candidate(9.99e99, 9.99e49) == 7.683206304769853e+30\n    assert candidate(6.42e23, 3.39e6) == 5991.13\n    assert candidate(1.23e45, 4.56e23) == 6.752610734401236e+18\n    assert candidate(1.90e27, 4.22e8) == 152956.83\n    assert candidate(1.02e26, 2.71e8) == 339727.62\n    assert candidate(4.87e24, 6.05e6) == 5186.16\n    assert candidate(1.00e50, 1.00e25) == 2.432075240844699e+18\n    assert candidate(1.00e-10, 1.00e-3) == 2432075.24\n", "language": "python"}
{"task_id": "f82dd733-2b28-4a81-b09c-d1360ae12766-316946806512437096", "prompt": "Using the guidelines in the docstring, develop the function as instructed. Include any supporting functions or classes within the scope of the main function. Submit your entire solution enclosed in a single code block.\n\n```python\nfrom typing import List\n\ndef climate_zones(temperatures: List[float], threshold: float) -> List[str]:\n    \"\"\"\n    As a climatologist, you're analyzing temperature data from various locations\n    to classify them into climate zones.\n\n    This function takes a list of average annual temperatures (in Celsius) for\n    different locations and a temperature threshold. It should classify each\n    location as either \"Warm\" if its temperature is above the threshold, or\n    \"Cool\" if it's below or equal to the threshold.\n\n    Return a list of classifications corresponding to each input temperature.\n\n    Use list comprehension to implement this function.\n\n\n    [EXAMPLES]\n    \n    assert candidate([0.0], 0.0) == ['Cool']\n    assert candidate([50.0, 60.0, 70.0, 80.0, 90.0], 75.0) == ['Cool', 'Cool', 'Cool', 'Warm', 'Warm']\n\n    [/EXAMPLES]\n    \"\"\"\n```\n", "entry_point": "climate_zones", "solution": "from typing import List\n\ndef climate_zones(temperatures: List[float], threshold: float) -> List[str]:\n    \"\"\"\n    As a climatologist, you're analyzing temperature data from various locations\n    to classify them into climate zones.\n\n    This function takes a list of average annual temperatures (in Celsius) for\n    different locations and a temperature threshold. It should classify each\n    location as either \"Warm\" if its temperature is above the threshold, or\n    \"Cool\" if it's below or equal to the threshold.\n\n    Return a list of classifications corresponding to each input temperature.\n\n    Use list comprehension to implement this function.\n\n\n    [EXAMPLES]\n    \n    assert candidate([0.0], 0.0) == ['Cool']\n    assert candidate([50.0, 60.0, 70.0, 80.0, 90.0], 75.0) == ['Cool', 'Cool', 'Cool', 'Warm', 'Warm']\n\n    [/EXAMPLES]\n    \"\"\"\n    return ['Warm' if temp > threshold else 'Cool' for temp in temperatures]\n\n", "test": "def check(candidate):\n    assert candidate([], 20.0) == []\n    assert candidate([9.9, 10.0, 10.1, 10.2, 10.3], 10.0) == ['Cool', 'Cool', 'Warm', 'Warm', 'Warm']\n    assert candidate([100.0, 99.9, 100.1, 99.8, 100.2], 100.0) == ['Cool', 'Cool', 'Warm', 'Cool', 'Warm']\n    assert candidate([-0.0001, -0.0002, -0.0003, -0.0004, -0.0005], -0.0003) == ['Warm', 'Warm', 'Cool', 'Cool', 'Cool']\n    assert candidate([50.0, 60.0, 70.0, 80.0, 90.0], 75.0) == ['Cool', 'Cool', 'Cool', 'Warm', 'Warm']\n    assert candidate([22.2, 22.2, 22.2, 22.2, 22.2], 22.2) == ['Cool', 'Cool', 'Cool', 'Cool', 'Cool']\n    assert candidate([0.0], 0.0) == ['Cool']\n    assert candidate([-50.0, -40.0, -30.0, -20.0, -10.0], -25.0) == ['Cool', 'Cool', 'Cool', 'Warm', 'Warm']\n", "language": "python"}
{"task_id": "6ed49866-f1b9-4378-ba33-e85646e4b066-4924080226648078021", "prompt": "Within a code block, implement the function as specified in the docstring. Adhere to the guidelines provided in the docstring to finish the function. Any additional functions or classes should be defined solely within the given function.\n\n```python\nimport re\nfrom typing import List\n\ndef extract_emails(text: str) -> List[str]:\n    \"\"\"\n    A data analyst needs to extract all valid email addresses from a given text.\n\n    This function takes a string as input and returns a list of all unique,\n    valid email addresses found within the text. The function should handle\n    various email formats and domain names.\n\n\n    [EXAMPLES]\n    \n    assert candidate(\"Email with numbers: user123@example456.com\") == ['user123@example456.com']\n    assert candidate(\"No emails in this text.\") == []\n\n    [/EXAMPLES]\n    \"\"\"\n```\n", "entry_point": "extract_emails", "solution": "import re\nfrom typing import List\n\ndef extract_emails(text: str) -> List[str]:\n    \"\"\"\n    A data analyst needs to extract all valid email addresses from a given text.\n\n    This function takes a string as input and returns a list of all unique,\n    valid email addresses found within the text. The function should handle\n    various email formats and domain names.\n\n\n    [EXAMPLES]\n    \n    assert candidate(\"Email with numbers: user123@example456.com\") == ['user123@example456.com']\n    assert candidate(\"No emails in this text.\") == []\n\n    [/EXAMPLES]\n    \"\"\"\n    # Regular expression pattern for matching email addresses\n    email_pattern = r'\\b[A-Za-z0-9._%+-]+@[A-Za-z0-9.-]+\\.[A-Z|a-z]{2,}\\b'\n    \n    # Find all matches in the text\n    matches = re.findall(email_pattern, text)\n    \n    # Remove duplicates by converting to a set and back to a list\n    unique_emails = list(set(matches))\n    \n    return unique_emails\n\n", "test": "def check(candidate):\n    assert candidate(\"Email with hyphen: my-email@example-domain.com\") == ['my-email@example-domain.com']\n    assert candidate(\"Unicode in domain: user@m\u0430ilinator.com\") == []\n    assert candidate(\"Short domain: a@b.c\") == []\n    assert candidate(\"Invalid emails: not@an@email.com, missing@tld., @missinguser.com\") == ['an@email.com']\n    assert candidate(\"Multiple emails: first@test.com, second@example.org\") == ['second@example.org', 'first@test.com']\n    assert candidate(\"Quoted local part: \\\"user.name\\\"@example.com\") == []\n    assert candidate(\"Email with subdomain: user@sub.domain.com\") == ['user@sub.domain.com']\n    assert candidate(\"Adjacent emails: first@test.comsecond@example.com\") == ['first@test.comsecond']\n    assert candidate(\"Email with numbers: user123@example456.com\") == ['user123@example456.com']\n    assert candidate(\"No emails in this text.\") == []\n", "language": "python"}
{"task_id": "e91007e1-5712-497e-8581-b9f0534206fe-8023979285746947626", "prompt": "Please complete the given code fragment and enclose the entire solution within a single code block.\n\n```python\nfrom typing import List, Tuple\nimport re\n\ndef parse_molecular_formula(formula: str) -> List[Tuple[str, int]]:\n    \"\"\"\n    You are a chemist working on a complex organic compound. Given a molecular formula as a string, your task is to parse it and return a list of tuples, where each tuple contains an element symbol and its count in the molecule.\n\n    The formula follows these rules:\n    1. Element symbols always start with an uppercase letter, optionally followed by a lowercase letter.\n    2. Element counts are positive integers. If no count is specified, it's assumed to be 1.\n    3. Parentheses may be used to group elements, and can be nested.\n    4. The count after a closing parenthesis multiplies all elements inside that group.\n\n    Implement a solution using a stack and regular expressions to handle nested structures and element parsing.\n\n    :param formula: A string representing the molecular formula\n    :return: A list of tuples, each containing an element symbol and its count\n\n\n    [EXAMPLES]\n    \n    assert candidate(\"(CH3)3N\") == [('C', 3), ('H', 9), ('N', 1)]\n    assert candidate(\"K2Cr2O7\") == [('K', 2), ('Cr', 2), ('O', 7)]\n\n    [/EXAMPLES]\n    \"\"\"\n```\n", "entry_point": "parse_molecular_formula", "solution": "from typing import List, Tuple\nimport re\n\ndef parse_molecular_formula(formula: str) -> List[Tuple[str, int]]:\n    \"\"\"\n    You are a chemist working on a complex organic compound. Given a molecular formula as a string, your task is to parse it and return a list of tuples, where each tuple contains an element symbol and its count in the molecule.\n\n    The formula follows these rules:\n    1. Element symbols always start with an uppercase letter, optionally followed by a lowercase letter.\n    2. Element counts are positive integers. If no count is specified, it's assumed to be 1.\n    3. Parentheses may be used to group elements, and can be nested.\n    4. The count after a closing parenthesis multiplies all elements inside that group.\n\n    Implement a solution using a stack and regular expressions to handle nested structures and element parsing.\n\n    :param formula: A string representing the molecular formula\n    :return: A list of tuples, each containing an element symbol and its count\n\n\n    [EXAMPLES]\n    \n    assert candidate(\"(CH3)3N\") == [('C', 3), ('H', 9), ('N', 1)]\n    assert candidate(\"K2Cr2O7\") == [('K', 2), ('Cr', 2), ('O', 7)]\n\n    [/EXAMPLES]\n    \"\"\"\n    def parse_element(element: str) -> Tuple[str, int]:\n        match = re.match(r'([A-Z][a-z]?)(\\d*)', element)\n        if match:\n            symbol, count = match.groups()\n            return symbol, int(count) if count else 1\n        return '', 0\n\n    def merge_counts(counts: dict) -> List[Tuple[str, int]]:\n        return [(element, count) for element, count in counts.items() if count > 0]\n\n    stack = [{}]\n    i = 0\n    while i < len(formula):\n        if formula[i] == '(' or formula[i] == '[':\n            stack.append({})\n            i += 1\n        elif formula[i] == ')' or formula[i] == ']':\n            top = stack.pop()\n            i += 1\n            m = re.match(r'\\d+', formula[i:])\n            if m:\n                multiplier = int(m.group())\n                i += len(m.group())\n            else:\n                multiplier = 1\n            for element, count in top.items():\n                stack[-1][element] = stack[-1].get(element, 0) + count * multiplier\n        else:\n            m = re.match(r'([A-Z][a-z]?)(\\d*)', formula[i:])\n            if m:\n                element, count = parse_element(m.group())\n                stack[-1][element] = stack[-1].get(element, 0) + count\n                i += len(m.group())\n            else:\n                i += 1\n\n    return merge_counts(stack[0])\n\n", "test": "def check(candidate):\n    assert candidate(\"CH3COOH\") == [('C', 2), ('H', 4), ('O', 2)]\n    assert candidate(\"C12H22O11\") == [('C', 12), ('H', 22), ('O', 11)]\n    assert candidate(\"Cu(NO3)2\") == [('Cu', 1), ('N', 2), ('O', 6)]\n    assert candidate(\"H2O\") == [('H', 2), ('O', 1)]\n    assert candidate(\"K4[ON(SO3)2]2\") == [('K', 4), ('O', 14), ('N', 2), ('S', 4)]\n    assert candidate(\"(NH4)2SO4\") == [('N', 2), ('H', 8), ('S', 1), ('O', 4)]\n    assert candidate(\"(CH3)3N\") == [('C', 3), ('H', 9), ('N', 1)]\n    assert candidate(\"K2Cr2O7\") == [('K', 2), ('Cr', 2), ('O', 7)]\n    assert candidate(\"Ca(OH)2\") == [('Ca', 1), ('O', 2), ('H', 2)]\n    assert candidate(\"NaCl\") == [('Na', 1), ('Cl', 1)]\n", "language": "python"}
{"task_id": "2c555cce-1956-40ec-8f45-4fad40cf4a663768436395272218162", "prompt": "Please complete the function implementation based on the provided documentation string. Ensure the entire function is contained within a single code block. Don't forget to handle any potential edge cases in your solution.\n\n```python\ndef encode_morse(message: str) -> str:\n    \"\"\"As a communications specialist, you need to encode messages into Morse code.\n    Write a function that takes a string message and returns its Morse code representation.\n\n    The function should handle letters (A-Z, case-insensitive) and digits (0-9).\n    Use a dot (.) for a short signal, a dash (-) for a long signal, and a space ( ) between letters.\n    Use three spaces between words.\n\n    Ignore any characters that are not letters or digits.\n\n\n    [EXAMPLES]\n    \n    assert candidate(\"0\") == '-----'\n    assert candidate(\"EndOfMessage.\") == '. -. -.. --- ..-. -- . ... ... .- --. .'\n\n    [/EXAMPLES]\n    \"\"\"\n```\n", "entry_point": "encode_morse", "solution": "def encode_morse(message: str) -> str:\n    \"\"\"As a communications specialist, you need to encode messages into Morse code.\n    Write a function that takes a string message and returns its Morse code representation.\n\n    The function should handle letters (A-Z, case-insensitive) and digits (0-9).\n    Use a dot (.) for a short signal, a dash (-) for a long signal, and a space ( ) between letters.\n    Use three spaces between words.\n\n    Ignore any characters that are not letters or digits.\n\n\n    [EXAMPLES]\n    \n    assert candidate(\"0\") == '-----'\n    assert candidate(\"EndOfMessage.\") == '. -. -.. --- ..-. -- . ... ... .- --. .'\n\n    [/EXAMPLES]\n    \"\"\"\n    def morse_code_dict():\n        return {\n            'A': '.-', 'B': '-...', 'C': '-.-.', 'D': '-..', 'E': '.', 'F': '..-.',\n            'G': '--.', 'H': '....', 'I': '..', 'J': '.---', 'K': '-.-', 'L': '.-..',\n            'M': '--', 'N': '-.', 'O': '---', 'P': '.--.', 'Q': '--.-', 'R': '.-.',\n            'S': '...', 'T': '-', 'U': '..-', 'V': '...-', 'W': '.--', 'X': '-..-',\n            'Y': '-.--', 'Z': '--..', '0': '-----', '1': '.----', '2': '..---',\n            '3': '...--', '4': '....-', '5': '.....', '6': '-....', '7': '--...',\n            '8': '---..', '9': '----.'\n        }\n\n    morse_dict = morse_code_dict()\n    encoded_words = []\n\n    for word in message.upper().split():\n        encoded_word = []\n        for char in word:\n            if char in morse_dict:\n                encoded_word.append(morse_dict[char])\n        if encoded_word:\n            encoded_words.append(' '.join(encoded_word))\n\n    return '   '.join(encoded_words)\n\n", "test": "def check(candidate):\n    assert candidate(\"   EXTRA   SPACES   \") == '. -..- - .-. .-   ... .--. .- -.-. . ...'\n    assert candidate(\"Z\") == '--..'\n    assert candidate(\"0\") == '-----'\n    assert candidate(\"EndOfMessage.\") == '. -. -.. --- ..-. -- . ... ... .- --. .'\n    assert candidate(\"The longest word in English is pneumonoultramicroscopicsilicovolcanoconiosis\") == '- .... .   .-.. --- -. --. . ... -   .-- --- .-. -..   .. -.   . -. --. .-.. .. ... ....   .. ...   .--. -. . ..- -- --- -. --- ..- .-.. - .-. .- -- .. -.-. .-. --- ... -.-. --- .--. .. -.-. ... .. .-.. .. -.-. --- ...- --- .-.. -.-. .- -. --- -.-. --- -. .. --- ... .. ...'\n    assert candidate(\"A\") == '.-'\n    assert candidate(\"The quick brown fox jumps over 13 lazy dogs.\") == '- .... .   --.- ..- .. -.-. -.-   -... .-. --- .-- -.   ..-. --- -..-   .--- ..- -- .--. ...   --- ...- . .-.   .---- ...--   .-.. .- --.. -.--   -.. --- --. ...'\n    assert candidate(\"123 456 789\") == '.---- ..--- ...--   ....- ..... -....   --... ---.. ----.'\n    assert candidate(\"a1b2c3 d4e5f6\") == '.- .---- -... ..--- -.-. ...--   -.. ....- . ..... ..-. -....'\n    assert candidate(\"a b c\") == '.-   -...   -.-.'\n", "language": "python"}
{"task_id": "32f390d6-3cb9-49ea-8e67-4211ecc51b03-8271953743091123891", "prompt": "Please complete the function implementation based on the provided doc string. Include the entire function in a single code block, ensuring that you account for any potential edge cases.\n\n```python\nfrom typing import List\n\ndef find_minimum_platforms(arrival: List[float], departure: List[float]) -> int:\n    \"\"\"\n    A railway station manager needs to determine the minimum number of platforms\n    required for the station so that no train has to wait. Given two lists\n    representing the arrival and departure times of trains (in 24-hour format),\n    return the minimum number of platforms needed to accommodate all trains.\n\n\n    [EXAMPLES]\n    \n    assert candidate([12.00, 12.00, 12.00], [12.01, 12.02, 12.03]) == 3\n    assert candidate([0.00, 23.59], [0.01, 23.58]) == 1\n\n    [/EXAMPLES]\n    \"\"\"\n```\n", "entry_point": "find_minimum_platforms", "solution": "from typing import List\n\ndef find_minimum_platforms(arrival: List[float], departure: List[float]) -> int:\n    \"\"\"\n    A railway station manager needs to determine the minimum number of platforms\n    required for the station so that no train has to wait. Given two lists\n    representing the arrival and departure times of trains (in 24-hour format),\n    return the minimum number of platforms needed to accommodate all trains.\n\n\n    [EXAMPLES]\n    \n    assert candidate([12.00, 12.00, 12.00], [12.01, 12.02, 12.03]) == 3\n    assert candidate([0.00, 23.59], [0.01, 23.58]) == 1\n\n    [/EXAMPLES]\n    \"\"\"\n    # Sort both arrival and departure times\n    arrival.sort()\n    departure.sort()\n    \n    n = len(arrival)\n    platforms_needed = 1\n    result = 1\n    i = 1\n    j = 0\n    \n    while i < n and j < n:\n        if arrival[i] < departure[j]:\n            platforms_needed += 1\n            i += 1\n        elif arrival[i] >= departure[j]:\n            platforms_needed -= 1\n            j += 1\n        \n        if platforms_needed > result:\n            result = platforms_needed\n    \n    return result\n\n", "test": "def check(candidate):\n    assert candidate([0.00, 23.59], [23.58, 23.59]) == 1\n    assert candidate([9.00, 11.00, 13.00, 15.00], [10.00, 12.00, 14.00, 16.00]) == 1\n    assert candidate([9.00, 9.00, 9.00, 9.00, 9.00], [17.00, 17.00, 17.00, 17.00, 17.00]) == 5\n    assert candidate([0.00, 23.59], [0.01, 23.58]) == 1\n    assert candidate([12.00, 12.00, 12.00], [12.01, 12.02, 12.03]) == 3\n    assert candidate([8.00, 8.15, 8.30, 8.45], [8.10, 8.25, 8.40, 8.55]) == 1\n    assert candidate([9.00], [10.00]) == 1\n    assert candidate([0.00, 4.00, 8.00, 12.00, 16.00, 20.00], [3.59, 7.59, 11.59, 15.59, 19.59, 23.59]) == 1\n    assert candidate([9.00, 10.00, 11.00], [9.30, 10.30, 11.30]) == 1\n    assert candidate([0.00, 12.00], [11.59, 23.59]) == 1\n", "language": "python"}
{"task_id": "ad19aa57-4044-493f-bb58-746ac5e9fab86425405501026049276", "prompt": "Supply the missing elements to complete the code, keeping everything consolidated in a single block.\n\n```python\nfrom typing import List\n\ndef calculate_water_flow(landscape: List[int]) -> int:\n    \"\"\"\n    You're an environmental scientist studying water flow in a hilly terrain.\n    The landscape is represented as a list of integers, where each integer represents the height of a hill.\n\n    When it rains, water accumulates between the hills. Your task is to calculate\n    the total amount of water that can be trapped after a heavy rainfall.\n\n    This function utilizes concepts of two-pointer technique and array manipulation\n    to efficiently compute the trapped water volume.\n\n\n    [EXAMPLES]\n    \n    assert candidate([3, 0, 3]) == 3\n    assert candidate([0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10]) == 0\n\n    [/EXAMPLES]\n    \"\"\"\n```\n", "entry_point": "calculate_water_flow", "solution": "from typing import List\n\ndef calculate_water_flow(landscape: List[int]) -> int:\n    \"\"\"\n    You're an environmental scientist studying water flow in a hilly terrain.\n    The landscape is represented as a list of integers, where each integer represents the height of a hill.\n\n    When it rains, water accumulates between the hills. Your task is to calculate\n    the total amount of water that can be trapped after a heavy rainfall.\n\n    This function utilizes concepts of two-pointer technique and array manipulation\n    to efficiently compute the trapped water volume.\n\n\n    [EXAMPLES]\n    \n    assert candidate([3, 0, 3]) == 3\n    assert candidate([0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10]) == 0\n\n    [/EXAMPLES]\n    \"\"\"\n    if not landscape:\n        return 0\n\n    left, right = 0, len(landscape) - 1\n    left_max, right_max = 0, 0\n    total_water = 0\n\n    while left < right:\n        if landscape[left] < landscape[right]:\n            if landscape[left] >= left_max:\n                left_max = landscape[left]\n            else:\n                total_water += left_max - landscape[left]\n            left += 1\n        else:\n            if landscape[right] >= right_max:\n                right_max = landscape[right]\n            else:\n                total_water += right_max - landscape[right]\n            right -= 1\n\n    return total_water\n\n", "test": "def check(candidate):\n    assert candidate([10, 9, 8, 7, 6, 5, 4, 3, 2, 1, 0]) == 0\n    assert candidate([100, 0, 100]) == 100\n    assert candidate([]) == 0\n    assert candidate([1, 1, 1, 1]) == 0\n    assert candidate([0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10]) == 0\n    assert candidate([3, 0, 3]) == 3\n    assert candidate([1, 8, 6, 2, 5, 4, 8, 3, 7]) == 19\n    assert candidate([1]) == 0\n    assert candidate([0, 0, 0, 0, 5, 0, 0, 0, 0]) == 0\n    assert candidate([5, 5, 5, 5, 5]) == 0\n", "language": "python"}
{"task_id": "fb1fe97e-bde4-474e-8109-2bc55997175c5382616857752750763", "prompt": "Implement the function as described by its documentation. Wrap the full function, including the doc string and your implementation, in one code block.\n\n```python\nfrom typing import List, Tuple\nfrom typing import List\n\ndef analyze_stock_trends(prices: List[float]) -> Tuple[float, float, int]:\n    \"\"\"\n    Analyze stock price trends to identify the best buying and selling opportunities.\n\n    This function takes a list of daily stock prices and returns a tuple containing\n    the maximum profit possible, the best day to buy, and the best day to sell.\n    It utilizes list slicing and max() function to determine the optimal strategy.\n\n\n    [EXAMPLES]\n    \n    assert candidate([50.0, 25.0, 12.5, 6.25, 3.125]) == (0.0, 0, 0)\n    assert candidate([100.0]) == (0.0, 0, 0)\n\n    [/EXAMPLES]\n    \"\"\"\n```\n", "entry_point": "analyze_stock_trends", "solution": "from typing import List, Tuple\nfrom typing import List\n\ndef analyze_stock_trends(prices: List[float]) -> Tuple[float, float, int]:\n    \"\"\"\n    Analyze stock price trends to identify the best buying and selling opportunities.\n\n    This function takes a list of daily stock prices and returns a tuple containing\n    the maximum profit possible, the best day to buy, and the best day to sell.\n    It utilizes list slicing and max() function to determine the optimal strategy.\n\n\n    [EXAMPLES]\n    \n    assert candidate([50.0, 25.0, 12.5, 6.25, 3.125]) == (0.0, 0, 0)\n    assert candidate([100.0]) == (0.0, 0, 0)\n\n    [/EXAMPLES]\n    \"\"\"\n    if len(prices) < 2:\n        return (0.0, 0, 0)\n\n    max_profit = 0.0\n    buy_day = 0\n    sell_day = 0\n\n    for i in range(len(prices)):\n        future_prices = prices[i+1:]\n        if future_prices:\n            max_future_price = max(future_prices)\n            potential_profit = max_future_price - prices[i]\n            if potential_profit > max_profit:\n                max_profit = potential_profit\n                buy_day = i\n                sell_day = prices.index(max_future_price, i+1)\n\n    return (max_profit, buy_day, sell_day)\n\n", "test": "def check(candidate):\n    assert candidate([0.5, 1.0, 1.5, 1.0, 0.5, 1.0, 1.5, 2.0]) == (1.5, 0, 7)\n    assert candidate([1.0, 2.0, 1.5, 3.0, 2.5, 4.0, 3.5]) == (3.0, 0, 5)\n    assert candidate([100.0]) == (0.0, 0, 0)\n    assert candidate([50.0, 25.0, 12.5, 6.25, 3.125]) == (0.0, 0, 0)\n", "language": "python"}
{"task_id": "2119782d-ce6e-4455-b8bf-eaec417adb5c712452185668129746", "prompt": "Let me complete this function according to the documentation. The full implementation will be in a single code block.\n\n```python\nfrom typing import List\nimport re\nfrom typing import List, Tuple\n\ndef parse_log_file(log_file: str, pattern: str) -> List[Tuple[str, int]]:\n    \"\"\"\n    As a system administrator, you need to analyze a log file to extract specific information.\n    \n    Your task is to parse the log file and extract entries that match a given regular expression pattern.\n    For each matching entry, you should return the timestamp and the line number where it occurred.\n    \n    Parameters:\n    - log_file: A string containing the entire contents of the log file\n    - pattern: A string representing the regular expression pattern to match\n    \n    Return a list of tuples, where each tuple contains (timestamp, line_number).\n    The timestamp should be extracted from the log entry, and the line number is the line where the match occurred.\n    \n    Assume that each log entry starts with a timestamp in the format \"YYYY-MM-DD HH:MM:SS\".\n    \n\n    [EXAMPLES]\n    \n    assert candidate(\"2023-06-02 02:00:00 WARNING Unusual activity\\n2023-06-02 02:01:00 ERROR Security breach\", r\"Unusual.*|Security.*\") == [('2023-06-02 02:00:00', 1), ('2023-06-02 02:01:00', 2)]\n    assert candidate(\"\", r\".*\") == []\n\n    [/EXAMPLES]\n    \"\"\"\n```\n", "entry_point": "parse_log_file", "solution": "from typing import List\nimport re\nfrom typing import List, Tuple\n\ndef parse_log_file(log_file: str, pattern: str) -> List[Tuple[str, int]]:\n    \"\"\"\n    As a system administrator, you need to analyze a log file to extract specific information.\n    \n    Your task is to parse the log file and extract entries that match a given regular expression pattern.\n    For each matching entry, you should return the timestamp and the line number where it occurred.\n    \n    Parameters:\n    - log_file: A string containing the entire contents of the log file\n    - pattern: A string representing the regular expression pattern to match\n    \n    Return a list of tuples, where each tuple contains (timestamp, line_number).\n    The timestamp should be extracted from the log entry, and the line number is the line where the match occurred.\n    \n    Assume that each log entry starts with a timestamp in the format \"YYYY-MM-DD HH:MM:SS\".\n    \n\n    [EXAMPLES]\n    \n    assert candidate(\"2023-06-02 02:00:00 WARNING Unusual activity\\n2023-06-02 02:01:00 ERROR Security breach\", r\"Unusual.*|Security.*\") == [('2023-06-02 02:00:00', 1), ('2023-06-02 02:01:00', 2)]\n    assert candidate(\"\", r\".*\") == []\n\n    [/EXAMPLES]\n    \"\"\"\n    result = []\n    lines = log_file.split('\\n')\n    \n    for line_number, line in enumerate(lines, 1):\n        if re.search(pattern, line):\n            timestamp_match = re.match(r'^(\\d{4}-\\d{2}-\\d{2} \\d{2}:\\d{2}:\\d{2})', line)\n            if timestamp_match:\n                timestamp = timestamp_match.group(1)\n                result.append((timestamp, line_number))\n    \n    return result\n\n", "test": "def check(candidate):\n    assert candidate(\"2023-06-02 00:00:00 INFO Midnight log\\n2023-06-02 00:01:00 INFO Early morning log\", r\".*log\") == [('2023-06-02 00:00:00', 1), ('2023-06-02 00:01:00', 2)]\n    assert candidate(\"2023-06-02 12:00:00 INFO GET /api/users\\n2023-06-02 12:30:00 INFO POST /api/users\", r\"(GET|POST) /api/.*\") == [('2023-06-02 12:00:00', 1), ('2023-06-02 12:30:00', 2)]\n    assert candidate(\"2023-06-02 04:00:00 INFO Backup started\\n2023-06-02 04:30:00 INFO Backup completed\", r\"Backup.*\") == [('2023-06-02 04:00:00', 1), ('2023-06-02 04:30:00', 2)]\n    assert candidate(\"2023-06-02 08:00:00 INFO User 'alice' logged in\\n2023-06-02 08:30:00 INFO User 'bob' logged in\", r\"User '([a-z]+)' logged in\") == [('2023-06-02 08:00:00', 1), ('2023-06-02 08:30:00', 2)]\n    assert candidate(\"2023-06-02 02:00:00 WARNING Unusual activity\\n2023-06-02 02:01:00 ERROR Security breach\", r\"Unusual.*|Security.*\") == [('2023-06-02 02:00:00', 1), ('2023-06-02 02:01:00', 2)]\n    assert candidate(\"2023-06-02 10:00:00 ERROR 404: Page not found\\n2023-06-02 10:30:00 ERROR 500: Internal server error\", r\"\\d{3}: .*\") == [('2023-06-02 10:00:00', 1), ('2023-06-02 10:30:00', 2)]\n    assert candidate(\"2023-06-01 12:00:00 ERROR Critical failure\\n2023-06-01 12:01:00 ERROR System crash\", r\"ERROR.*\") == [('2023-06-01 12:00:00', 1), ('2023-06-01 12:01:00', 2)]\n    assert candidate(\"2023-06-01 09:00:00 DEBUG Starting application\\n2023-06-01 09:01:30 INFO User 'admin' accessed dashboard\\n2023-06-01 09:02:15 WARNING High CPU usage detected\\n2023-06-01 09:03:00 INFO User 'guest' logged in\", r\"User '.*' (accessed|logged)\") == [('2023-06-01 09:01:30', 2), ('2023-06-01 09:03:00', 4)]\n    assert candidate(\"\", r\".*\") == []\n    assert candidate(\"2023-06-01 18:00:00 INFO User login\\n2023-06-01 18:01:00 INFO User logout\\n2023-06-01 18:02:00 INFO System shutdown\", r\"INFO.*\") == [('2023-06-01 18:00:00', 1), ('2023-06-01 18:01:00', 2), ('2023-06-01 18:02:00', 3)]\n", "language": "python"}
{"task_id": "56330b1c-bef1-44bd-8af3-665ded11676c-523620315489244390", "prompt": "I'll give you a function to complete that's ready for execution. Please only provide code within this function, no external code. Any extra functions or classes should be defined inside this main function. Stick with the imported libraries only, and return just one code block.\n\n```python\nimport math\n\ndef wind_chill(temperature: float, wind_speed: float) -> float:\n    \"\"\"\n    As a meteorologist, you need to calculate the wind chill factor. This function takes the air\n    temperature (in Celsius) and wind speed (in km/h) and returns the wind chill temperature.\n\n    The wind chill formula used is:\n    WC = 13.12 + 0.6215 * T - 11.37 * (V^0.16) + 0.3965 * T * (V^0.16)\n    \n    Where:\n    WC = Wind Chill Index (\u00b0C)\n    T = Air Temperature (\u00b0C)\n    V = Wind Speed (km/h)\n\n    The function should return the wind chill rounded to one decimal place.\n\n\n    [EXAMPLES]\n    \n    assert candidate(-8.3, 45) == -19.0\n    assert candidate(0, 10) == -3.3\n\n    [/EXAMPLES]\n    \"\"\"\n```\n", "entry_point": "wind_chill", "solution": "import math\n\ndef wind_chill(temperature: float, wind_speed: float) -> float:\n    \"\"\"\n    As a meteorologist, you need to calculate the wind chill factor. This function takes the air\n    temperature (in Celsius) and wind speed (in km/h) and returns the wind chill temperature.\n\n    The wind chill formula used is:\n    WC = 13.12 + 0.6215 * T - 11.37 * (V^0.16) + 0.3965 * T * (V^0.16)\n    \n    Where:\n    WC = Wind Chill Index (\u00b0C)\n    T = Air Temperature (\u00b0C)\n    V = Wind Speed (km/h)\n\n    The function should return the wind chill rounded to one decimal place.\n\n\n    [EXAMPLES]\n    \n    assert candidate(-8.3, 45) == -19.0\n    assert candidate(0, 10) == -3.3\n\n    [/EXAMPLES]\n    \"\"\"\n    wind_chill = (\n        13.12 +\n        0.6215 * temperature -\n        11.37 * (wind_speed ** 0.16) +\n        0.3965 * temperature * (wind_speed ** 0.16)\n    )\n    \n    return round(wind_chill, 1)\n\n", "test": "def check(candidate):\n    assert candidate(0, 10) == -3.3\n    assert candidate(6.7, 9.5) == 4.8\n    assert candidate(3, 18) == -1.2\n    assert candidate(7, 8) == 5.5\n    assert candidate(-18.2, 55.5) == -33.5\n    assert candidate(2, 15) == -2.0\n    assert candidate(-20, 50) == -35.4\n    assert candidate(-12, 35) == -22.8\n    assert candidate(-8.3, 45) == -19.0\n    assert candidate(-10, 30) == -19.5\n", "language": "python"}
{"task_id": "e7b1039b-255d-4375-9d07-5189031b56bd-7830001088573931468", "prompt": "I'll complete the requested function in a way that it's immediately executable. The solution will be contained in a single code block, using only the libraries specified in the problem. Any additional functionality will be defined inside the main function. My response will consist of just the function implementation in one code block.\n\n```python\nfrom typing import List\n\ndef space_mission(crew_skills: List[str], mission_requirements: List[str]) -> int:\n    \"\"\"\n    In preparation for a crucial space mission, you need to determine the number of additional\n    crew members required to cover all the mission's skill requirements.\n\n    Given a list of skills possessed by the current crew and a list of skills required for the\n    mission, calculate how many more crew members with unique skills are needed.\n\n    Each crew member and each mission requirement represents one unique skill.\n\n\n    [EXAMPLES]\n    \n    assert candidate(['computer_science', 'physics'], ['astronomy', 'biology', 'geology']) == 3\n    assert candidate(['a', 'a', 'a'], ['b']) == 1\n\n    [/EXAMPLES]\n    \"\"\"\n```\n", "entry_point": "space_mission", "solution": "from typing import List\n\ndef space_mission(crew_skills: List[str], mission_requirements: List[str]) -> int:\n    \"\"\"\n    In preparation for a crucial space mission, you need to determine the number of additional\n    crew members required to cover all the mission's skill requirements.\n\n    Given a list of skills possessed by the current crew and a list of skills required for the\n    mission, calculate how many more crew members with unique skills are needed.\n\n    Each crew member and each mission requirement represents one unique skill.\n\n\n    [EXAMPLES]\n    \n    assert candidate(['computer_science', 'physics'], ['astronomy', 'biology', 'geology']) == 3\n    assert candidate(['a', 'a', 'a'], ['b']) == 1\n\n    [/EXAMPLES]\n    \"\"\"\n    # Convert lists to sets for efficient operations\n    crew_skill_set = set(crew_skills)\n    mission_requirement_set = set(mission_requirements)\n    \n    # Find the skills that are required but not present in the crew\n    missing_skills = mission_requirement_set - crew_skill_set\n    \n    # Return the number of missing skills, which is equivalent to the number of additional crew members needed\n    return len(missing_skills)\n\n", "test": "def check(candidate):\n    assert candidate(['a', 'b', 'c'], ['a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j']) == 7\n    assert candidate(['a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j'], ['k']) == 1\n    assert candidate(['piloting', 'engineering', 'navigation'], ['piloting', 'medicine', 'botany', 'engineering']) == 2\n    assert candidate(['computer_science', 'physics'], ['astronomy', 'biology', 'geology']) == 3\n    assert candidate(['a', 'b', 'c'], ['d', 'e', 'f']) == 3\n    assert candidate(['a', 'b', 'c'], ['a', 'b', 'c']) == 0\n    assert candidate(['piloting', 'engineering', 'navigation'], []) == 0\n    assert candidate(['a'], ['a' for _ in range(1000)]) == 0\n    assert candidate(['a'], ['a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j']) == 9\n    assert candidate(['a', 'a', 'a'], ['b']) == 1\n", "language": "python"}
{"task_id": "36b510d4-1922-4418-907b-ad7f09a0e2f8-3117281505462679520", "prompt": "I'll write the complete function implementation according to the documentation string. The solution will be in one code block and will handle all possible edge cases.\n\n```python\nfrom typing import List\n\ndef analyze_dna_sequence(sequence: str, window_size: int) -> List[float]:\n    \"\"\"\n    Analyzes a DNA sequence by calculating the GC content within sliding windows.\n\n    This function takes a DNA sequence and a window size as input, then calculates\n    the GC content (percentage of G and C nucleotides) for each window along the\n    sequence. It utilizes string manipulation and list comprehension to efficiently\n    process the sequence.\n\n    Args:\n        sequence (str): A string representing the DNA sequence (A, T, G, C).\n        window_size (int): The size of the sliding window for GC content calculation.\n\n    Returns:\n        List[float]: A list of GC content percentages for each window.\n\n\n    [EXAMPLES]\n    \n    assert candidate(\"ATCGATCGATCG\", 12) == [50.0]\n    assert candidate(\"GC\", 2) == [100.0]\n\n    [/EXAMPLES]\n    \"\"\"\n```\n", "entry_point": "analyze_dna_sequence", "solution": "from typing import List\n\ndef analyze_dna_sequence(sequence: str, window_size: int) -> List[float]:\n    \"\"\"\n    Analyzes a DNA sequence by calculating the GC content within sliding windows.\n\n    This function takes a DNA sequence and a window size as input, then calculates\n    the GC content (percentage of G and C nucleotides) for each window along the\n    sequence. It utilizes string manipulation and list comprehension to efficiently\n    process the sequence.\n\n    Args:\n        sequence (str): A string representing the DNA sequence (A, T, G, C).\n        window_size (int): The size of the sliding window for GC content calculation.\n\n    Returns:\n        List[float]: A list of GC content percentages for each window.\n\n\n    [EXAMPLES]\n    \n    assert candidate(\"ATCGATCGATCG\", 12) == [50.0]\n    assert candidate(\"GC\", 2) == [100.0]\n\n    [/EXAMPLES]\n    \"\"\"\n    def calculate_gc_content(window: str) -> float:\n        gc_count = window.count('G') + window.count('C')\n        return round((gc_count / len(window)) * 100, 2)\n\n    if window_size > len(sequence):\n        raise ValueError(\"Window size cannot be larger than the sequence length.\")\n\n    gc_contents = [calculate_gc_content(sequence[i:i+window_size]) \n                   for i in range(len(sequence) - window_size + 1)]\n    \n    return gc_contents\n\n", "test": "def check(candidate):\n    assert candidate(\"GCGCGC\", 3) == [100.0, 100.0, 100.0, 100.0]\n    assert candidate(\"GCTA\" * 2500, 5000) == [50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0]\n    assert candidate(\"ATATATATATAT\", 4) == [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0]\n    assert candidate(\"ATCGATCGATCG\", 12) == [50.0]\n    assert candidate(\"ATGCATGCATGC\", 6) == [33.33, 50.0, 66.67, 50.0, 33.33, 50.0, 66.67]\n    assert candidate(\"ATCGATCGATCG\", 1) == [0.0, 0.0, 100.0, 100.0, 0.0, 0.0, 100.0, 100.0, 0.0, 0.0, 100.0, 100.0]\n    assert candidate(\"CCCCCCCCCCCC\", 12) == [100.0]\n    assert candidate(\"GC\", 2) == [100.0]\n    assert candidate(\"ATCGATCGATCGATCG\", 8) == [50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0]\n    assert candidate(\"AAATTTCCCGGG\", 3) == [0.0, 0.0, 0.0, 0.0, 33.33, 66.67, 100.0, 100.0, 100.0, 100.0]\n", "language": "python"}
{"task_id": "8063ff5e-c5a6-4d76-b115-4661862609b7-938544246706398878", "prompt": "I'll implement the requested function in a self-contained manner. My response will be just one code block with the complete function implementation, including any necessary helper functions or classes defined inside the main function. I'll only use the libraries that were imported in the problem statement.\n\n```python\ndef calculate_asteroid_trajectory(initial_position: tuple, velocity: tuple, time: float) -> tuple:\n    \"\"\"\n    An astronomer is tracking the path of an asteroid in a 3D space. This function calculates \n    the final position of the asteroid given its initial position, velocity, and elapsed time.\n\n    Parameters:\n    initial_position (tuple): A tuple of three floats (x, y, z) representing the initial position.\n    velocity (tuple): A tuple of three floats (vx, vy, vz) representing the velocity in each direction.\n    time (float): The elapsed time in seconds.\n\n    Returns:\n    tuple: A tuple of three floats representing the final position of the asteroid.\n\n\n    [EXAMPLES]\n    \n    assert candidate((1000, -2000, 3000), (-50, 100, -150), 30) == (-500, 1000, -1500)\n    assert candidate((0, 0, 0), (299792458, 0, 0), 1) == (299792458, 0, 0)\n\n    [/EXAMPLES]\n    \"\"\"\n```\n", "entry_point": "calculate_asteroid_trajectory", "solution": "def calculate_asteroid_trajectory(initial_position: tuple, velocity: tuple, time: float) -> tuple:\n    \"\"\"\n    An astronomer is tracking the path of an asteroid in a 3D space. This function calculates \n    the final position of the asteroid given its initial position, velocity, and elapsed time.\n\n    Parameters:\n    initial_position (tuple): A tuple of three floats (x, y, z) representing the initial position.\n    velocity (tuple): A tuple of three floats (vx, vy, vz) representing the velocity in each direction.\n    time (float): The elapsed time in seconds.\n\n    Returns:\n    tuple: A tuple of three floats representing the final position of the asteroid.\n\n\n    [EXAMPLES]\n    \n    assert candidate((1000, -2000, 3000), (-50, 100, -150), 30) == (-500, 1000, -1500)\n    assert candidate((0, 0, 0), (299792458, 0, 0), 1) == (299792458, 0, 0)\n\n    [/EXAMPLES]\n    \"\"\"\n    # Unpack the initial position and velocity tuples\n    x0, y0, z0 = initial_position\n    vx, vy, vz = velocity\n    \n    # Calculate the displacement in each direction\n    dx = vx * time\n    dy = vy * time\n    dz = vz * time\n    \n    # Calculate the final position by adding the displacement to the initial position\n    final_x = x0 + dx\n    final_y = y0 + dy\n    final_z = z0 + dz\n    \n    # Return the final position as a tuple of floats\n    return (float(final_x), float(final_y), float(final_z))\n\n", "test": "def check(candidate):\n    assert candidate((123.456, 789.012, 345.678), (-1.234, 5.678, -9.012), 7.89) == (113.71974, 833.81142, 274.57331999999997)\n    assert candidate((10, 20, 30), (-1, -2, -3), 5) == (5, 10, 15)\n    assert candidate((1e-9, 1e-9, 1e-9), (1e9, 1e9, 1e9), 1e-9) == (1.000000001, 1.000000001, 1.000000001)\n    assert candidate((0, 0, 0), (299792458, 0, 0), 1) == (299792458.0, 0.0, 0.0)\n    assert candidate((1000, -2000, 3000), (-50, 100, -150), 30) == (-500, 1000, -1500)\n    assert candidate((100, 100, 100), (0, 0, 9.8), 10) == (100.0, 100.0, 198.0)\n    assert candidate((0, 0, 0), (299792458, 0, 0), 1) == (299792458, 0, 0)\n    assert candidate((-100, 200, -300), (10, -20, 30), 2.5) == (-75.0, 150.0, -225.0)\n    assert candidate((1, 1, 1), (1, 0, -1), 5.5) == (6.5, 1.0, -4.5)\n    assert candidate((3.14159, 2.71828, 1.41421), (1.61803, 0.57721, 2.50618), 15) == (27.41204, 11.37643, 39.00691)\n", "language": "python"}
{"task_id": "9c6b6b12-3e5c-4bae-b04e-6180d77d089d-2570234223460692009", "prompt": "Using the docstring as a guide, I'll code the full function implementation within a single code block, ensuring robust handling of edge cases.\n\n```python\nfrom typing import List\nfrom typing import List, Tuple\n\ndef decode_alien_message(signal: str, codebook: List[Tuple[str, str]]) -> str:\n    \"\"\"\n    An astronomer has intercepted a strange signal believed to be from an alien civilization. The signal\n    is encoded using an unknown substitution cipher. Given the encoded signal and a partial codebook of\n    known symbol translations, attempt to decode the message.\n\n    Parameters:\n    signal (str): The encoded alien signal\n    codebook (List[Tuple[str, str]]): List of known symbol translations (alien symbol, earth symbol)\n\n    Returns:\n    str: The decoded message, with untranslatable symbols represented by '?'\n\n\n    [EXAMPLES]\n    \n    assert candidate(\"11111\", [('1', 'A')]) == 'AAAAA'\n    assert candidate(\"\", []) == ''\n\n    [/EXAMPLES]\n    \"\"\"\n```\n", "entry_point": "decode_alien_message", "solution": "from typing import List\nfrom typing import List, Tuple\n\ndef decode_alien_message(signal: str, codebook: List[Tuple[str, str]]) -> str:\n    \"\"\"\n    An astronomer has intercepted a strange signal believed to be from an alien civilization. The signal\n    is encoded using an unknown substitution cipher. Given the encoded signal and a partial codebook of\n    known symbol translations, attempt to decode the message.\n\n    Parameters:\n    signal (str): The encoded alien signal\n    codebook (List[Tuple[str, str]]): List of known symbol translations (alien symbol, earth symbol)\n\n    Returns:\n    str: The decoded message, with untranslatable symbols represented by '?'\n\n\n    [EXAMPLES]\n    \n    assert candidate(\"11111\", [('1', 'A')]) == 'AAAAA'\n    assert candidate(\"\", []) == ''\n\n    [/EXAMPLES]\n    \"\"\"\n    # Create a dictionary from the codebook for efficient lookup\n    translation_dict = dict(codebook)\n    \n    # Initialize an empty list to store the decoded message\n    decoded_message = []\n    \n    # Iterate through each symbol in the signal\n    for symbol in signal:\n        # If the symbol is in the translation dictionary, add its translation\n        # Otherwise, add a question mark\n        decoded_message.append(translation_dict.get(symbol, '?'))\n    \n    # Join the decoded symbols into a single string and return\n    return ''.join(decoded_message)\n\n", "test": "def check(candidate):\n    assert candidate(\"123\", [('1', 'O'), ('2', 'N'), ('3', 'E')]) == 'ONE'\n    assert candidate(\"ABCDE\", [('A', 'E'), ('B', 'D'), ('C', 'C'), ('D', 'B'), ('E', 'A')]) == 'EDCBA'\n    assert candidate(\"11111\", [('1', 'A')]) == 'AAAAA'\n    assert candidate(\"AEIOU\", [('A', '1'), ('E', '2'), ('I', '3'), ('O', '4'), ('U', '5')]) == '12345'\n    assert candidate(\"!@#$%\", [('!', '!'), ('@', '@'), ('#', '#'), ('$', '$'), ('%', '%')]) == '!@#$%'\n    assert candidate(\"\", []) == ''\n    assert candidate(\"HELLO\", [('H', 'A'), ('E', 'B'), ('L', 'C'), ('O', 'D')]) == 'ABCCD'\n    assert candidate(\"ABCDEFG\", [('A', '1'), ('C', '2'), ('E', '3'), ('G', '4')]) == '1?2?3?4'\n    assert candidate(\"ABC\", [('A', 'X'), ('B', 'Y'), ('C', 'Z')]) == 'XYZ'\n    assert candidate(\"!@#$%\", [('!', 'H'), ('@', 'E'), ('#', 'L'), ('$', 'L'), ('%', 'O')]) == 'HELLO'\n", "language": "python"}
{"task_id": "476b85c1-f1df-4dd0-b4ab-e29c32cbc9f92356323418757113687", "prompt": "Implement the function exactly as described, making sure it works when run in a single code block. Don't add any code outside the function body. Only utilize the libraries that are imported in the problem statement. If you need additional helper functions or classes, define them inside the main function.\n\n```python\ndef analyze_dna_sequence(sequence: str) -> dict:\n    \"\"\"\n    A bioinformatics researcher needs to analyze DNA sequences for various properties.\n    This function takes a DNA sequence and returns a dictionary containing information\n    about its nucleotide composition and potential palindromic regions.\n\n    Args:\n    sequence (str): A string representing a DNA sequence (containing A, T, C, G).\n\n    Returns:\n    dict: A dictionary containing the analysis results.\n\n\n    [EXAMPLES]\n    \n    assert candidate(\"T\") == {'A': 0, 'T': 1, 'C': 0, 'G': 0, 'gc_content': 0.0, 'palindrome': True}\n    assert candidate(\"CGCGCGCGCGCGCGCG\") == {'A': 0, 'T': 0, 'C': 8, 'G': 8, 'gc_content': 1.0, 'palindrome': False}\n\n    [/EXAMPLES]\n    \"\"\"\n```\n", "entry_point": "analyze_dna_sequence", "solution": "def analyze_dna_sequence(sequence: str) -> dict:\n    \"\"\"\n    A bioinformatics researcher needs to analyze DNA sequences for various properties.\n    This function takes a DNA sequence and returns a dictionary containing information\n    about its nucleotide composition and potential palindromic regions.\n\n    Args:\n    sequence (str): A string representing a DNA sequence (containing A, T, C, G).\n\n    Returns:\n    dict: A dictionary containing the analysis results.\n\n\n    [EXAMPLES]\n    \n    assert candidate(\"T\") == {'A': 0, 'T': 1, 'C': 0, 'G': 0, 'gc_content': 0.0, 'palindrome': True}\n    assert candidate(\"CGCGCGCGCGCGCGCG\") == {'A': 0, 'T': 0, 'C': 8, 'G': 8, 'gc_content': 1.0, 'palindrome': False}\n\n    [/EXAMPLES]\n    \"\"\"\n    def is_palindrome(s):\n        return s == s[::-1]\n\n    # Convert sequence to uppercase to handle both upper and lower case input\n    sequence = sequence.upper()\n    \n    # Count nucleotides\n    nucleotide_counts = {'A': 0, 'T': 0, 'C': 0, 'G': 0}\n    for nucleotide in sequence:\n        if nucleotide in nucleotide_counts:\n            nucleotide_counts[nucleotide] += 1\n    \n    # Calculate GC content\n    total_nucleotides = sum(nucleotide_counts.values())\n    gc_content = (nucleotide_counts['G'] + nucleotide_counts['C']) / total_nucleotides if total_nucleotides > 0 else 0\n    \n    # Check if the sequence is palindromic\n    palindrome = is_palindrome(sequence)\n    \n    # Prepare the result dictionary\n    result = {\n        'A': nucleotide_counts['A'],\n        'T': nucleotide_counts['T'],\n        'C': nucleotide_counts['C'],\n        'G': nucleotide_counts['G'],\n        'gc_content': gc_content,\n        'palindrome': palindrome\n    }\n    \n    return result\n\n", "test": "def check(candidate):\n    assert candidate(\"A\") == {'A': 1, 'T': 0, 'C': 0, 'G': 0, 'gc_content': 0.0, 'palindrome': True}\n    assert candidate(\"ATCGCGCGAT\") == {'A': 2, 'T': 2, 'C': 3, 'G': 3, 'gc_content': 0.6, 'palindrome': False}\n    assert candidate(\"C\") == {'A': 0, 'T': 0, 'C': 1, 'G': 0, 'gc_content': 1.0, 'palindrome': True}\n    assert candidate(\"T\") == {'A': 0, 'T': 1, 'C': 0, 'G': 0, 'gc_content': 0.0, 'palindrome': True}\n    assert candidate(\"ATATATATATATATAT\") == {'A': 8, 'T': 8, 'C': 0, 'G': 0, 'gc_content': 0.0, 'palindrome': False}\n    assert candidate(\"ATCG\") == {'A': 1, 'T': 1, 'C': 1, 'G': 1, 'gc_content': 0.5, 'palindrome': False}\n    assert candidate(\"CG\") == {'A': 0, 'T': 0, 'C': 1, 'G': 1, 'gc_content': 1.0, 'palindrome': False}\n    assert candidate(\"CGCGCGCGCGCGCGCG\") == {'A': 0, 'T': 0, 'C': 8, 'G': 8, 'gc_content': 1.0, 'palindrome': False}\n    assert candidate(\"G\") == {'A': 0, 'T': 0, 'C': 0, 'G': 1, 'gc_content': 1.0, 'palindrome': True}\n    assert candidate(\"AAAAAAAAAAAAAAA\") == {'A': 15, 'T': 0, 'C': 0, 'G': 0, 'gc_content': 0.0, 'palindrome': True}\n", "language": "python"}
{"task_id": "626f9086-7179-41ab-bc76-997b008af622690342287269625024", "prompt": "Code the function implementation that satisfies the documented requirements. Provide your solution in a single, uninterrupted code block without altering the function signature.\n\n```python\nfrom typing import List\n\ndef optimize_package_delivery(packages: List[int], truck_capacity: int) -> int:\n    \"\"\"You are managing a package delivery service and need to optimize the number of trips\n    required to deliver all packages. You have a single truck with a fixed capacity, and each\n    package has a specific weight.\n\n    Your task is to write a function that determines the minimum number of trips required to\n    deliver all packages. The truck can carry multiple packages in each trip, as long as the\n    total weight doesn't exceed its capacity.\n\n    The function should take a list of package weights and the truck's capacity as input, and\n    return the minimum number of trips required.\n\n    Note: The order of package delivery doesn't matter, and you can't split a package between trips.\n\n\n    [EXAMPLES]\n    \n    assert candidate([1, 1, 1, 1, 1, 1, 1, 1, 1, 1], 2) == 5\n    assert candidate([1, 2, 3, 4, 5, 6, 7, 8, 9, 10], 55) == 1\n\n    [/EXAMPLES]\n    \"\"\"\n```\n", "entry_point": "optimize_package_delivery", "solution": "from typing import List\n\ndef optimize_package_delivery(packages: List[int], truck_capacity: int) -> int:\n    \"\"\"You are managing a package delivery service and need to optimize the number of trips\n    required to deliver all packages. You have a single truck with a fixed capacity, and each\n    package has a specific weight.\n\n    Your task is to write a function that determines the minimum number of trips required to\n    deliver all packages. The truck can carry multiple packages in each trip, as long as the\n    total weight doesn't exceed its capacity.\n\n    The function should take a list of package weights and the truck's capacity as input, and\n    return the minimum number of trips required.\n\n    Note: The order of package delivery doesn't matter, and you can't split a package between trips.\n\n\n    [EXAMPLES]\n    \n    assert candidate([1, 1, 1, 1, 1, 1, 1, 1, 1, 1], 2) == 5\n    assert candidate([1, 2, 3, 4, 5, 6, 7, 8, 9, 10], 55) == 1\n\n    [/EXAMPLES]\n    \"\"\"\n    # Sort packages in descending order\n    packages.sort(reverse=True)\n    \n    trips = 0\n    left, right = 0, len(packages) - 1\n    \n    while left <= right:\n        trips += 1\n        current_load = packages[left]\n        \n        if left == right:\n            break\n        \n        # Try to fit smaller packages with the current large package\n        while left < right and current_load + packages[right] <= truck_capacity:\n            current_load += packages[right]\n            right -= 1\n        \n        left += 1\n    \n    return trips\n\n", "test": "def check(candidate):\n    assert candidate([1, 2, 3, 4, 5, 6, 7, 8, 9, 10], 55) == 1\n    assert candidate([5, 10, 15, 20, 25], 50) == 2\n    assert candidate([1, 1, 1, 1, 1], 5) == 1\n    assert candidate([5, 5, 5, 5, 5], 10) == 3\n    assert candidate([1, 1, 1, 1, 1, 1, 1, 1, 1, 1], 2) == 5\n    assert candidate([1, 2, 3, 4, 5], 5) == 3\n    assert candidate([2, 3, 4, 3, 1], 7) == 2\n    assert candidate([1], 1) == 1\n    assert candidate([10, 20, 30, 40, 50], 100) == 2\n    assert candidate([999, 999, 999], 1000) == 3\n", "language": "python"}
{"task_id": "e739c480-b15e-44fe-9096-563a6b76bef47161934282549753806", "prompt": "Write the implementation for this function that satisfies its doc string. Present the entire solution as one cohesive code block.\n\n```python\ndef calculate_shipping_cost(weight: float, distance: float, fragile: bool) -> float:\n    \"\"\"\n    Calculate the shipping cost for a package based on its weight, distance, and fragility.\n\n    This function determines the shipping cost for a package using a complex formula that\n    takes into account the package's weight in kilograms, the shipping distance in kilometers,\n    and whether the package contains fragile items. The base rate is $10, with additional\n    charges applied for weight, distance, and fragility.\n\n    Args:\n    weight (float): The weight of the package in kilograms.\n    distance (float): The shipping distance in kilometers.\n    fragile (bool): Whether the package contains fragile items.\n\n    Returns:\n    float: The calculated shipping cost in dollars.\n\n\n    [EXAMPLES]\n    \n    assert candidate(3.14, 314.15, False) == 44.55\n    assert candidate(10.0, 500.0, False) == 70.0\n\n    [/EXAMPLES]\n    \"\"\"\n```\n", "entry_point": "calculate_shipping_cost", "solution": "def calculate_shipping_cost(weight: float, distance: float, fragile: bool) -> float:\n    \"\"\"\n    Calculate the shipping cost for a package based on its weight, distance, and fragility.\n\n    This function determines the shipping cost for a package using a complex formula that\n    takes into account the package's weight in kilograms, the shipping distance in kilometers,\n    and whether the package contains fragile items. The base rate is $10, with additional\n    charges applied for weight, distance, and fragility.\n\n    Args:\n    weight (float): The weight of the package in kilograms.\n    distance (float): The shipping distance in kilometers.\n    fragile (bool): Whether the package contains fragile items.\n\n    Returns:\n    float: The calculated shipping cost in dollars.\n\n\n    [EXAMPLES]\n    \n    assert candidate(3.14, 314.15, False) == 44.55\n    assert candidate(10.0, 500.0, False) == 70.0\n\n    [/EXAMPLES]\n    \"\"\"\n    # Base rate\n    base_rate = 10.0\n\n    # Weight charge (1$ per kg)\n    weight_charge = weight * 1.0\n\n    # Distance charge (0.1$ per km)\n    distance_charge = distance * 0.1\n\n    # Fragility charge (20% of base rate if fragile)\n    fragility_charge = base_rate * 0.2 if fragile else 0.0\n\n    # Calculate total cost\n    total_cost = base_rate + weight_charge + distance_charge + fragility_charge\n\n    # Round to 2 decimal places\n    return round(total_cost, 2)\n\n", "test": "def check(candidate):\n    assert candidate(9.99, 999.99, True) == 121.99\n    assert candidate(7.8, 325.6, True) == 52.36\n    assert candidate(5.0, 100.0, False) == 25.0\n    assert candidate(10.0, 500.0, False) == 70.0\n    assert candidate(42.0, 42.0, False) == 56.2\n    assert candidate(50.0, 200.0, False) == 80.0\n    assert candidate(0.1, 10.0, False) == 11.1\n    assert candidate(0.001, 0.001, False) == 10.0\n    assert candidate(3.14, 314.15, False) == 44.55\n", "language": "python"}
{"task_id": "955e55b8-c27e-46fc-974b-14450c6643a22758380363010120898", "prompt": "You're a coding assistant responsible for completing given functions so they're executable as is within a code block. Keep your solution within the function provided. Only use libraries that have been imported in the problem statement. If you need to define additional functions or classes, place them inside the main function.\n\n```python\nfrom typing import List\n\ndef water_conservation_plan(daily_usage: List[int], target: int) -> List[int]:\n    \"\"\"\n    A city planner wants to implement a water conservation plan. Given a list of daily water usage\n    for each household in liters, and a target reduction percentage, calculate the new daily usage\n    limits for each household to meet the conservation goal.\n\n    This function uses list comprehension and lambda functions to calculate the new usage limits.\n    \n    :param daily_usage: List of integers representing daily water usage for each household\n    :param target: Integer representing the target reduction percentage (0-100)\n    :return: List of integers representing new daily usage limits for each household\n\n\n    [EXAMPLES]\n    \n    assert candidate([50, 75, 100, 125, 150], 25) == [37, 56, 75, 93, 112]\n    assert candidate([10000, 20000, 30000, 40000, 50000], 75) == [2500, 5000, 7500, 10000, 12500]\n\n    [/EXAMPLES]\n    \"\"\"\n```\n", "entry_point": "water_conservation_plan", "solution": "from typing import List\n\ndef water_conservation_plan(daily_usage: List[int], target: int) -> List[int]:\n    \"\"\"\n    A city planner wants to implement a water conservation plan. Given a list of daily water usage\n    for each household in liters, and a target reduction percentage, calculate the new daily usage\n    limits for each household to meet the conservation goal.\n\n    This function uses list comprehension and lambda functions to calculate the new usage limits.\n    \n    :param daily_usage: List of integers representing daily water usage for each household\n    :param target: Integer representing the target reduction percentage (0-100)\n    :return: List of integers representing new daily usage limits for each household\n\n\n    [EXAMPLES]\n    \n    assert candidate([50, 75, 100, 125, 150], 25) == [37, 56, 75, 93, 112]\n    assert candidate([10000, 20000, 30000, 40000, 50000], 75) == [2500, 5000, 7500, 10000, 12500]\n\n    [/EXAMPLES]\n    \"\"\"\n    # Lambda function to calculate the reduced usage\n    calculate_reduced_usage = lambda usage, reduction: int(usage * (1 - reduction / 100))\n    \n    # List comprehension to apply the calculation to each household\n    return [calculate_reduced_usage(usage, target) for usage in daily_usage]\n\n", "test": "def check(candidate):\n    assert candidate([50, 75, 100, 125, 150], 25) == [37, 56, 75, 93, 112]\n    assert candidate([9999, 8888, 7777, 6666, 5555], 5) == [9499, 8443, 7388, 6332, 5277]\n    assert candidate([500, 750, 1000, 1250, 1500], 30) == [350, 525, 700, 875, 1050]\n    assert candidate([0, 0, 0, 0, 0], 50) == [0, 0, 0, 0, 0]\n    assert candidate([100000, 200000, 300000, 400000, 500000], 80) == [19999, 39999, 59999, 79999, 99999]\n    assert candidate([100, 100, 100, 100, 100], 20) == [80, 80, 80, 80, 80]\n    assert candidate([55, 65, 75, 85, 95], 40) == [33, 39, 45, 51, 57]\n    assert candidate([10000, 20000, 30000, 40000, 50000], 75) == [2500, 5000, 7500, 10000, 12500]\n    assert candidate([1, 2, 3, 4, 5], 0) == [1, 2, 3, 4, 5]\n    assert candidate([100, 200, 300, 400, 500], 10) == [90, 180, 270, 360, 450]\n", "language": "python"}
{"task_id": "43768b8b-c297-466d-bc4e-93175b7d2971-1574587229523520520", "prompt": "I'll complete your function as requested. Just let me know which function needs implementation, and I'll provide a working solution in a single code block. Any auxiliary functions or classes will be defined inside the main function, and I'll only use the libraries that are already imported.\n\n```python\nfrom typing import List\n\ndef find_treasure_spots(map_grid: List[List[int]]) -> List[tuple]:\n    \"\"\"\n    You are an archaeologist with an ancient map divided into a grid. Each cell in the grid\n    contains a number representing the altitude of that location. A treasure is buried at every\n    point where the altitude is lower than all of its adjacent cells (including diagonals).\n    Given the map as a 2D list of integers, return the coordinates of all treasure spots.\n\n\n    [EXAMPLES]\n    \n    assert candidate([[1,1],[1,1],[1,1]]) == []\n    assert candidate([[1,2,3,2,1],[3,4,5,4,3],[5,6,7,6,5],[3,4,5,4,3],[1,2,3,2,1]]) == [(0, 0), (0, 4), (4, 0), (4, 4)]\n\n    [/EXAMPLES]\n    \"\"\"\n```\n", "entry_point": "find_treasure_spots", "solution": "from typing import List\n\ndef find_treasure_spots(map_grid: List[List[int]]) -> List[tuple]:\n    \"\"\"\n    You are an archaeologist with an ancient map divided into a grid. Each cell in the grid\n    contains a number representing the altitude of that location. A treasure is buried at every\n    point where the altitude is lower than all of its adjacent cells (including diagonals).\n    Given the map as a 2D list of integers, return the coordinates of all treasure spots.\n\n\n    [EXAMPLES]\n    \n    assert candidate([[1,1],[1,1],[1,1]]) == []\n    assert candidate([[1,2,3,2,1],[3,4,5,4,3],[5,6,7,6,5],[3,4,5,4,3],[1,2,3,2,1]]) == [(0, 0), (0, 4), (4, 0), (4, 4)]\n\n    [/EXAMPLES]\n    \"\"\"\n    def is_treasure_spot(row, col):\n        height = map_grid[row][col]\n        for dr in [-1, 0, 1]:\n            for dc in [-1, 0, 1]:\n                if dr == 0 and dc == 0:\n                    continue\n                r, c = row + dr, col + dc\n                if 0 <= r < rows and 0 <= c < cols:\n                    if map_grid[r][c] <= height:\n                        return False\n        return True\n\n    rows = len(map_grid)\n    cols = len(map_grid[0])\n    treasure_spots = []\n\n    for row in range(rows):\n        for col in range(cols):\n            if is_treasure_spot(row, col):\n                treasure_spots.append((row, col))\n\n    return treasure_spots\n\n", "test": "def check(candidate):\n    assert candidate([[10,9,8,7,6],[9,8,7,6,5],[8,7,6,5,4],[7,6,5,4,3],[6,5,4,3,2]]) == [(4, 4)]\n    assert candidate([[1,2,3],[4,5,6],[7,8,9]]) == [(0, 0)]\n    assert candidate([[1,2,1,2],[2,1,2,1],[1,2,1,2],[2,1,2,1]]) == []\n    assert candidate([[9,9,9,9],[9,1,1,9],[9,1,1,9],[9,9,9,9]]) == []\n    assert candidate([[5,5,5],[5,1,5],[5,5,5]]) == [(1, 1)]\n    assert candidate([[1,1],[1,1]]) == []\n    assert candidate([[1,2,3,4,5],[2,3,4,5,1],[3,4,5,1,2],[4,5,1,2,3],[5,1,2,3,4]]) == [(0, 0)]\n    assert candidate([[100]]) == [(0, 0)]\n    assert candidate([[1,1],[1,1],[1,1]]) == []\n    assert candidate([[1,2,3,2,1],[3,4,5,4,3],[5,6,7,6,5],[3,4,5,4,3],[1,2,3,2,1]]) == [(0, 0), (0, 4), (4, 0), (4, 4)]\n", "language": "python"}
{"task_id": "2f012d35-2f61-48d7-8b23-addafba10d08665437065955074687", "prompt": "Let me finish coding this function as specified by the docstring. I'll provide the complete implementation in one code block without altering the function name or parameters.\n\n```python\nfrom typing import List\n\ndef optimize_network_traffic(routers: List[int]) -> List[int]:\n    \"\"\"\n    In a large-scale computer network, we need to optimize the traffic flow\n    between routers. Each router has a unique identifier represented as an integer.\n    The goal is to find the pair of routers that, when connected, would maximize\n    the network throughput and minimize interference.\n\n    This function uses bit manipulation to find the optimal router pair.\n\n    Args:\n    routers (List[int]): A list of router identifiers.\n\n    Returns:\n    List[int]: A list containing two values - the maximum AND value and the\n               maximum OR value of the optimal router pair.\n\n\n    [EXAMPLES]\n    \n    assert candidate([1, 2, 3, 4]) == [2, 7]\n    assert candidate([1024, 2048, 4096, 8192]) == [0, 12288]\n\n    [/EXAMPLES]\n    \"\"\"\n```\n", "entry_point": "optimize_network_traffic", "solution": "from typing import List\n\ndef optimize_network_traffic(routers: List[int]) -> List[int]:\n    \"\"\"\n    In a large-scale computer network, we need to optimize the traffic flow\n    between routers. Each router has a unique identifier represented as an integer.\n    The goal is to find the pair of routers that, when connected, would maximize\n    the network throughput and minimize interference.\n\n    This function uses bit manipulation to find the optimal router pair.\n\n    Args:\n    routers (List[int]): A list of router identifiers.\n\n    Returns:\n    List[int]: A list containing two values - the maximum AND value and the\n               maximum OR value of the optimal router pair.\n\n\n    [EXAMPLES]\n    \n    assert candidate([1, 2, 3, 4]) == [2, 7]\n    assert candidate([1024, 2048, 4096, 8192]) == [0, 12288]\n\n    [/EXAMPLES]\n    \"\"\"\n    if len(routers) < 2:\n        return [0, 0]  # Not enough routers to form a pair\n\n    max_and = 0\n    max_or = 0\n\n    for i in range(len(routers)):\n        for j in range(i + 1, len(routers)):\n            # Calculate AND and OR values for the current pair\n            current_and = routers[i] & routers[j]\n            current_or = routers[i] | routers[j]\n\n            # Update max_and if current_and is greater\n            if current_and > max_and:\n                max_and = current_and\n\n            # Update max_or if current_or is greater\n            if current_or > max_or:\n                max_or = current_or\n\n    return [max_and, max_or]\n\n", "test": "def check(candidate):\n    assert candidate([5, 10, 15, 20, 25]) == [16, 31]\n    assert candidate([2, 4, 6, 8, 10]) == [8, 14]\n    assert candidate([31, 63, 127, 255]) == [127, 255]\n    assert candidate([1, 2, 3, 4]) == [2, 7]\n    assert candidate([0, 1, 2, 3]) == [2, 3]\n    assert candidate([1024, 2048, 4096, 8192]) == [0, 12288]\n    assert candidate([1, 2, 4, 8, 16, 32, 64, 128]) == [0, 192]\n    assert candidate([10, 20, 30, 40, 50]) == [32, 62]\n    assert candidate([7, 14, 21, 28, 35]) == [20, 63]\n    assert candidate([100, 200, 300, 400]) == [256, 500]\n", "language": "python"}
{"task_id": "32cbe86e-4aae-465a-9a30-f17d6db3cb6d858416147990901792", "prompt": "I'll implement the function as described in the docstring. Please provide the full code in one block.\n\n```python\nfrom typing import List\n\ndef decode_alien_message(message: str, dictionary: List[str]) -> str:\n    \"\"\"\n    An alien civilization has sent a coded message to Earth. The message consists of a string\n    of characters without spaces. A dictionary of valid alien words is provided. The task is to\n    decode the message by breaking it into valid words from the dictionary.\n\n    This function takes the coded message and the dictionary of valid words as input. It returns\n    the decoded message with spaces between words. If the message cannot be fully decoded using\n    the given dictionary, return \"Unable to decode\".\n\n    Args:\n    message (str): The coded alien message without spaces\n    dictionary (List[str]): List of valid alien words\n\n    Returns:\n    str: Decoded message with spaces or \"Unable to decode\" if not possible\n\n\n    [EXAMPLES]\n    \n    assert candidate(\"zyxwvutsrqponmlkjihgfedcba\", [\"zyxw\", \"vuts\", \"rqpo\", \"nmlk\", \"jihg\", \"fedc\", \"ba\"]) == 'zyxw vuts rqpo nmlk jihg fedc ba'\n    assert candidate(\"aabbccddee\", [\"aa\", \"bb\", \"cc\", \"dd\", \"ee\"]) == 'aa bb cc dd ee'\n\n    [/EXAMPLES]\n    \"\"\"\n```\n", "entry_point": "decode_alien_message", "solution": "from typing import List\n\ndef decode_alien_message(message: str, dictionary: List[str]) -> str:\n    \"\"\"\n    An alien civilization has sent a coded message to Earth. The message consists of a string\n    of characters without spaces. A dictionary of valid alien words is provided. The task is to\n    decode the message by breaking it into valid words from the dictionary.\n\n    This function takes the coded message and the dictionary of valid words as input. It returns\n    the decoded message with spaces between words. If the message cannot be fully decoded using\n    the given dictionary, return \"Unable to decode\".\n\n    Args:\n    message (str): The coded alien message without spaces\n    dictionary (List[str]): List of valid alien words\n\n    Returns:\n    str: Decoded message with spaces or \"Unable to decode\" if not possible\n\n\n    [EXAMPLES]\n    \n    assert candidate(\"zyxwvutsrqponmlkjihgfedcba\", [\"zyxw\", \"vuts\", \"rqpo\", \"nmlk\", \"jihg\", \"fedc\", \"ba\"]) == 'zyxw vuts rqpo nmlk jihg fedc ba'\n    assert candidate(\"aabbccddee\", [\"aa\", \"bb\", \"cc\", \"dd\", \"ee\"]) == 'aa bb cc dd ee'\n\n    [/EXAMPLES]\n    \"\"\"\n    def can_decode(start: int, memo: dict) -> bool:\n        if start == len(message):\n            return True\n        \n        if start in memo:\n            return memo[start]\n        \n        for word in dictionary:\n            if message.startswith(word, start):\n                if can_decode(start + len(word), memo):\n                    memo[start] = True\n                    return True\n        \n        memo[start] = False\n        return False\n\n    def backtrack(start: int, memo: dict) -> List[str]:\n        if start == len(message):\n            return []\n        \n        for word in dictionary:\n            if message.startswith(word, start) and can_decode(start + len(word), memo):\n                return [word] + backtrack(start + len(word), memo)\n        \n        return []  # This line should never be reached if can_decode returns True\n\n    memo = {}\n    if can_decode(0, memo):\n        decoded_words = backtrack(0, memo)\n        return \" \".join(decoded_words)\n    else:\n        return \"Unable to decode\"\n\n", "test": "def check(candidate):\n    assert candidate(\"abcdefg\", [\"abc\", \"def\", \"g\", \"abcdef\"]) == 'abc def g'\n    assert candidate(\"helloworldhowrareyou\", [\"hello\", \"world\", \"how\", \"are\", \"you\"]) == 'Unable to decode'\n    assert candidate(\"abcabcabc\", [\"abc\"]) == 'abc abc abc'\n    assert candidate(\"helloworld\", [\"hell\", \"world\"]) == 'Unable to decode'\n    assert candidate(\"aaaaabbbbbcccccddddd\", [\"a\", \"b\", \"c\", \"d\", \"aa\", \"bb\", \"cc\", \"dd\"]) == 'a a a a a b b b b b c c c c c d d d d d'\n    assert candidate(\"onetwothreefourfivesixseveneightnineten\", [\"one\", \"two\", \"three\", \"four\", \"five\", \"six\", \"seven\", \"eight\", \"nine\", \"ten\"]) == 'one two three four five six seven eight nine ten'\n    assert candidate(\"a\", [\"a\"]) == 'a'\n    assert candidate(\"zyxwvutsrqponmlkjihgfedcba\", [\"zyxw\", \"vuts\", \"rqpo\", \"nmlk\", \"jihg\", \"fedc\", \"ba\"]) == 'zyxw vuts rqpo nmlk jihg fedc ba'\n    assert candidate(\"aabbccddee\", [\"aa\", \"bb\", \"cc\", \"dd\", \"ee\"]) == 'aa bb cc dd ee'\n    assert candidate(\"catdogfish\", [\"cat\", \"dog\", \"fish\", \"catdog\"]) == 'cat dog fish'\n", "language": "python"}
{"task_id": "2f539e24-ad06-4108-9317-494f12dbc41b-7299243769216631444", "prompt": "Complete the provided function so it can run independently in one code block. Include all code inside the function, with nothing outside. Only use libraries that are already imported in the problem. Define any extra functions or classes only within the main function.\n\n```python\nfrom typing import List\nimport itertools\n\ndef calculate_max_profit(prices: List[int], k: int) -> int:\n    \"\"\"A stock trader wants to maximize profits by making at most k transactions.\n    Given a list of stock prices for consecutive days and the maximum number of\n    transactions allowed, calculate the maximum profit that can be obtained.\n\n    A transaction consists of buying a stock on one day and selling it on a later day.\n    Multiple transactions can't overlap, meaning you must sell before buying again.\n\n    Use dynamic programming to solve this problem efficiently.\n\n\n    [EXAMPLES]\n    \n    assert candidate([10,9,8,7,6,5,4,3,2,1], 5) == 0\n    assert candidate([], 5) == 0\n\n    [/EXAMPLES]\n    \"\"\"\n```\n", "entry_point": "calculate_max_profit", "solution": "from typing import List\nimport itertools\n\ndef calculate_max_profit(prices: List[int], k: int) -> int:\n    \"\"\"A stock trader wants to maximize profits by making at most k transactions.\n    Given a list of stock prices for consecutive days and the maximum number of\n    transactions allowed, calculate the maximum profit that can be obtained.\n\n    A transaction consists of buying a stock on one day and selling it on a later day.\n    Multiple transactions can't overlap, meaning you must sell before buying again.\n\n    Use dynamic programming to solve this problem efficiently.\n\n\n    [EXAMPLES]\n    \n    assert candidate([10,9,8,7,6,5,4,3,2,1], 5) == 0\n    assert candidate([], 5) == 0\n\n    [/EXAMPLES]\n    \"\"\"\n    if not prices or k == 0:\n        return 0\n\n    n = len(prices)\n    \n    # If k is large enough, we can make as many transactions as we want\n    if k >= n // 2:\n        return sum(max(0, prices[i] - prices[i-1]) for i in range(1, n))\n\n    # Initialize the dp table\n    dp = [[0] * n for _ in range(k + 1)]\n\n    for i in range(1, k + 1):\n        max_diff = -float('inf')\n        for j in range(1, n):\n            max_diff = max(max_diff, dp[i-1][j-1] - prices[j-1])\n            dp[i][j] = max(dp[i][j-1], prices[j] + max_diff)\n\n    return dp[k][n-1]\n\n", "test": "def check(candidate):\n    assert candidate([10,22,5,75,65,80], 2) == 87\n    assert candidate([3,3,5,0,0,3,1,4], 0) == 0\n    assert candidate([3,3,5,0,0,3,1,4], 3) == 8\n    assert candidate([1,2,3,4,5,6,7,8,9,10], 5) == 9\n    assert candidate([3,2,6,5,0,3], 2) == 7\n    assert candidate([5,4,3,2,1], 1) == 0\n    assert candidate([10,9,8,7,6,5,4,3,2,1], 5) == 0\n    assert candidate([0,0,0,0,5], 1) == 5\n    assert candidate([], 5) == 0\n    assert candidate([1,2,3,4,5,4,3,2,1], 2) == 4\n", "language": "python"}
{"task_id": "efe61509-75a7-4c4c-bde8-316a3e36f5416305948355905465356", "prompt": "Working as your coding assistant, I'll complete the provided function to make it fully executable in a code block. I'll restrict myself to using only the libraries mentioned in the problem. When I need additional functionality, I'll define any supporting functions or classes entirely inside the given function.\n\n```python\nfrom typing import List\nimport heapq\n\ndef network_latency(connections: List[List[int]], n: int, source: int) -> List[int]:\n    \"\"\"In a large-scale distributed system, you need to calculate the minimum latency from a source node\n    to all other nodes in the network. The network consists of n nodes, labeled from 0 to n-1.\n\n    This function takes a list of connections where connections[i] = [from_i, to_i, latency_i] represents\n    a unidirectional connection from node from_i to node to_i with a latency of latency_i milliseconds.\n    It also takes the total number of nodes n and the source node. The function returns a list of size n\n    where the i-th element represents the minimum latency from the source to node i, or -1 if unreachable.\n\n\n    [EXAMPLES]\n    \n    assert candidate([[0,1,5], [1,2,5], [0,3,2], [3,1,2], [1,4,1], [4,2,1]], 5, 0) == [0, 4, 6, 2, 5]\n    assert candidate([], 1, 0) == [0]\n\n    [/EXAMPLES]\n    \"\"\"\n```\n", "entry_point": "network_latency", "solution": "from typing import List\nimport heapq\n\ndef network_latency(connections: List[List[int]], n: int, source: int) -> List[int]:\n    \"\"\"In a large-scale distributed system, you need to calculate the minimum latency from a source node\n    to all other nodes in the network. The network consists of n nodes, labeled from 0 to n-1.\n\n    This function takes a list of connections where connections[i] = [from_i, to_i, latency_i] represents\n    a unidirectional connection from node from_i to node to_i with a latency of latency_i milliseconds.\n    It also takes the total number of nodes n and the source node. The function returns a list of size n\n    where the i-th element represents the minimum latency from the source to node i, or -1 if unreachable.\n\n\n    [EXAMPLES]\n    \n    assert candidate([[0,1,5], [1,2,5], [0,3,2], [3,1,2], [1,4,1], [4,2,1]], 5, 0) == [0, 4, 6, 2, 5]\n    assert candidate([], 1, 0) == [0]\n\n    [/EXAMPLES]\n    \"\"\"\n    def build_graph(connections):\n        graph = {}\n        for from_node, to_node, latency in connections:\n            if from_node not in graph:\n                graph[from_node] = []\n            graph[from_node].append((to_node, latency))\n        return graph\n\n    def dijkstra(graph, source, n):\n        latencies = [-1] * n\n        latencies[source] = 0\n        pq = [(0, source)]\n        \n        while pq:\n            current_latency, current_node = heapq.heappop(pq)\n            \n            if current_latency > latencies[current_node]:\n                continue\n            \n            if current_node in graph:\n                for neighbor, edge_latency in graph[current_node]:\n                    new_latency = current_latency + edge_latency\n                    if latencies[neighbor] == -1 or new_latency < latencies[neighbor]:\n                        latencies[neighbor] = new_latency\n                        heapq.heappush(pq, (new_latency, neighbor))\n        \n        return latencies\n\n    graph = build_graph(connections)\n    return dijkstra(graph, source, n)\n\n", "test": "def check(candidate):\n    assert candidate([[0,1,100], [1,2,100], [0,2,500]], 3, 0) == [0, 100, 200]\n    assert candidate([[0,1,1], [1,2,2], [2,3,3], [3,4,4]], 5, 4) == [-1, -1, -1, -1, 0]\n    assert candidate([[0,1,1], [1,0,2]], 2, 0) == [0, 1]\n    assert candidate([[0,1,1], [1,2,1], [2,3,1], [3,4,1], [4,0,1]], 5, 3) == [2, 3, 4, 0, 1]\n    assert candidate([[0,1,1], [1,2,1], [2,3,1], [3,4,1], [4,5,1]], 6, 5) == [-1, -1, -1, -1, -1, 0]\n    assert candidate([[0,1,1], [1,2,1], [2,3,1], [3,0,1]], 4, 1) == [3, 0, 1, 2]\n    assert candidate([[0,1,5], [1,2,5], [0,3,2], [3,1,2], [1,4,1], [4,2,1]], 5, 0) == [0, 4, 6, 2, 5]\n    assert candidate([], 1, 0) == [0]\n    assert candidate([[0,1,10000]], 2, 1) == [-1, 0]\n    assert candidate([[0,1,1], [1,2,1], [0,2,3]], 3, 1) == [-1, 0, 1]\n", "language": "python"}
{"task_id": "8294ebf0-26f7-4070-8ebe-4a18c702fd41-5697893816096727627", "prompt": "Please complete the requested function so it can be executed as-is in a single code block. Don't include any code outside the function definition. Stick to the libraries that are imported in the problem. If you need helper functions or classes, define them inside the main function.\n\n```python\nimport random\nfrom typing import List\n\ndef treasure_hunt(map_size: int, traps: List[tuple], treasure: tuple) -> int:\n    \"\"\"\n    You're an adventurer in a digital realm, navigating a square grid map to find hidden treasure.\n    The map is represented by a grid of size 'map_size' x 'map_size'.\n    Your starting position is always at (0, 0), and you can only move right or down.\n    There are traps at certain coordinates, represented by the 'traps' list of tuples.\n    The treasure is located at coordinates given by the 'treasure' tuple.\n    Your task is to find the number of unique paths to the treasure while avoiding all traps.\n\n    Parameters:\n    map_size (int): The size of the square grid map\n    traps (List[tuple]): List of coordinate tuples where traps are located\n    treasure (tuple): Coordinate tuple where the treasure is located\n\n    Returns:\n    int: The number of unique paths to the treasure avoiding all traps\n\n\n    [EXAMPLES]\n    \n    assert candidate(4, [(1, 2), (2, 1), (3, 3)], (3, 2)) == 1\n    assert candidate(4, [(0, 1), (1, 0), (2, 3), (3, 2)], (3, 3)) == 0\n\n    [/EXAMPLES]\n    \"\"\"\n```\n", "entry_point": "treasure_hunt", "solution": "import random\nfrom typing import List\n\ndef treasure_hunt(map_size: int, traps: List[tuple], treasure: tuple) -> int:\n    \"\"\"\n    You're an adventurer in a digital realm, navigating a square grid map to find hidden treasure.\n    The map is represented by a grid of size 'map_size' x 'map_size'.\n    Your starting position is always at (0, 0), and you can only move right or down.\n    There are traps at certain coordinates, represented by the 'traps' list of tuples.\n    The treasure is located at coordinates given by the 'treasure' tuple.\n    Your task is to find the number of unique paths to the treasure while avoiding all traps.\n\n    Parameters:\n    map_size (int): The size of the square grid map\n    traps (List[tuple]): List of coordinate tuples where traps are located\n    treasure (tuple): Coordinate tuple where the treasure is located\n\n    Returns:\n    int: The number of unique paths to the treasure avoiding all traps\n\n\n    [EXAMPLES]\n    \n    assert candidate(4, [(1, 2), (2, 1), (3, 3)], (3, 2)) == 1\n    assert candidate(4, [(0, 1), (1, 0), (2, 3), (3, 2)], (3, 3)) == 0\n\n    [/EXAMPLES]\n    \"\"\"\n    def is_safe(x, y):\n        return (x, y) not in traps and 0 <= x < map_size and 0 <= y < map_size\n\n    def count_paths(x, y):\n        if (x, y) == treasure:\n            return 1\n        if not is_safe(x, y):\n            return 0\n        \n        # Memoization: check if we've already computed this subproblem\n        if (x, y) in memo:\n            return memo[(x, y)]\n        \n        # Recursively explore right and down paths\n        paths = count_paths(x+1, y) + count_paths(x, y+1)\n        \n        # Store the result in memo before returning\n        memo[(x, y)] = paths\n        return paths\n\n    # Initialize memoization dictionary\n    memo = {}\n\n    return count_paths(0, 0)\n\n", "test": "def check(candidate):\n    assert candidate(3, [(0, 1), (1, 0), (1, 1), (1, 2), (2, 1)], (2, 2)) == 0\n    assert candidate(4, [(0, 1), (1, 0), (2, 3), (3, 2)], (3, 3)) == 0\n    assert candidate(2, [], (1, 1)) == 2\n    assert candidate(3, [(1, 1)], (2, 2)) == 2\n    assert candidate(4, [(1, 1), (2, 2)], (3, 3)) == 4\n    assert candidate(4, [(1, 2), (2, 1), (3, 3)], (3, 2)) == 1\n    assert candidate(4, [(1, 1), (1, 2), (1, 3), (2, 1), (3, 1)], (3, 3)) == 0\n    assert candidate(5, [(0, 1), (1, 0), (2, 2), (3, 3)], (4, 4)) == 0\n    assert candidate(7, [(1, 1), (2, 2), (3, 3), (4, 4), (5, 5), (6, 6)], (6, 6)) == 84\n    assert candidate(5, [], (4, 4)) == 70\n", "language": "python"}
{"task_id": "849d4366-6e69-4b89-9c0d-8671acf4ed3f7636764109481239954", "prompt": "I'll implement the requested function following these guidelines: using only imported libraries, defining any auxiliary functions or classes within the main function scope, and providing just one self-contained code block that can be executed as-is. Here's the implementation:\n\n```python\ndef generate_fibonacci_sequence(n: int) -> list:\n    \"\"\"\n    In a study of natural growth patterns, this function generates a Fibonacci sequence\n    of a specified length. Each number in the sequence is the sum of the two preceding ones,\n    starting from 0 and 1.\n\n    Args:\n    n (int): The desired length of the Fibonacci sequence.\n\n    Returns:\n    list: A list containing the Fibonacci sequence of length n.\n\n\n    [EXAMPLES]\n    \n    assert candidate(40) == [0, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, 144, 233, 377, 610, 987, 1597, 2584, 4181, 6765, 10946, 17711, 28657, 46368, 75025, 121393, 196418, 317811, 514229, 832040, 1346269, 2178309, 3524578, 5702887, 9227465, 14930352, 24157817, 39088169, 63245986]\n    assert candidate(100) == [0, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, 144, 233, 377, 610, 987, 1597, 2584, 4181, 6765, 10946, 17711, 28657, 46368, 75025, 121393, 196418, 317811, 514229, 832040, 1346269, 2178309, 3524578, 5702887, 9227465, 14930352, 24157817, 39088169, 63245986, 102334155, 165580141, 267914296, 433494437, 701408733, 1134903170, 1836311903, 2971215073, 4807526976, 7778742049, 12586269025, 20365011074, 32951280099, 53316291173, 86267571272, 139583862445, 225851433717, 365435296162, 591286729879, 956722026041, 1548008755920, 2504730781961, 4052739537881, 6557470319842, 10610209857723, 17167680177565, 27777890035288, 44945570212853, 72723460248141, 117669030460994, 190392490709135, 308061521170129, 498454011879264, 806515533049393, 1304969544928657, 2111485077978050, 3416454622906707, 5527939700884757, 8944394323791464, 14472334024676221, 23416728348467685, 37889062373143906, 61305790721611591, 99194853094755497, 160500643816367088, 259695496911122585, 420196140727489673, 679891637638612258, 1100087778366101931, 1779979416004714189, 2880067194370816120, 4660046610375530309, 7540113804746346429, 12200160415121876738, 19740274219868223167, 31940434634990099905, 51680708854858323072, 83621143489848422977, 135301852344706746049, 218922995834555169026]\n\n    [/EXAMPLES]\n    \"\"\"\n```\n", "entry_point": "generate_fibonacci_sequence", "solution": "def generate_fibonacci_sequence(n: int) -> list:\n    \"\"\"\n    In a study of natural growth patterns, this function generates a Fibonacci sequence\n    of a specified length. Each number in the sequence is the sum of the two preceding ones,\n    starting from 0 and 1.\n\n    Args:\n    n (int): The desired length of the Fibonacci sequence.\n\n    Returns:\n    list: A list containing the Fibonacci sequence of length n.\n\n\n    [EXAMPLES]\n    \n    assert candidate(40) == [0, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, 144, 233, 377, 610, 987, 1597, 2584, 4181, 6765, 10946, 17711, 28657, 46368, 75025, 121393, 196418, 317811, 514229, 832040, 1346269, 2178309, 3524578, 5702887, 9227465, 14930352, 24157817, 39088169, 63245986]\n    assert candidate(100) == [0, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, 144, 233, 377, 610, 987, 1597, 2584, 4181, 6765, 10946, 17711, 28657, 46368, 75025, 121393, 196418, 317811, 514229, 832040, 1346269, 2178309, 3524578, 5702887, 9227465, 14930352, 24157817, 39088169, 63245986, 102334155, 165580141, 267914296, 433494437, 701408733, 1134903170, 1836311903, 2971215073, 4807526976, 7778742049, 12586269025, 20365011074, 32951280099, 53316291173, 86267571272, 139583862445, 225851433717, 365435296162, 591286729879, 956722026041, 1548008755920, 2504730781961, 4052739537881, 6557470319842, 10610209857723, 17167680177565, 27777890035288, 44945570212853, 72723460248141, 117669030460994, 190392490709135, 308061521170129, 498454011879264, 806515533049393, 1304969544928657, 2111485077978050, 3416454622906707, 5527939700884757, 8944394323791464, 14472334024676221, 23416728348467685, 37889062373143906, 61305790721611591, 99194853094755497, 160500643816367088, 259695496911122585, 420196140727489673, 679891637638612258, 1100087778366101931, 1779979416004714189, 2880067194370816120, 4660046610375530309, 7540113804746346429, 12200160415121876738, 19740274219868223167, 31940434634990099905, 51680708854858323072, 83621143489848422977, 135301852344706746049, 218922995834555169026]\n\n    [/EXAMPLES]\n    \"\"\"\n    if n <= 0:\n        return []\n    elif n == 1:\n        return [0]\n    elif n == 2:\n        return [0, 1]\n    \n    fibonacci = [0, 1]\n    for i in range(2, n):\n        next_number = fibonacci[i-1] + fibonacci[i-2]\n        fibonacci.append(next_number)\n    \n    return fibonacci\n\n", "test": "def check(candidate):\n    assert candidate(75) == [0, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, 144, 233, 377, 610, 987, 1597, 2584, 4181, 6765, 10946, 17711, 28657, 46368, 75025, 121393, 196418, 317811, 514229, 832040, 1346269, 2178309, 3524578, 5702887, 9227465, 14930352, 24157817, 39088169, 63245986, 102334155, 165580141, 267914296, 433494437, 701408733, 1134903170, 1836311903, 2971215073, 4807526976, 7778742049, 12586269025, 20365011074, 32951280099, 53316291173, 86267571272, 139583862445, 225851433717, 365435296162, 591286729879, 956722026041, 1548008755920, 2504730781961, 4052739537881, 6557470319842, 10610209857723, 17167680177565, 27777890035288, 44945570212853, 72723460248141, 117669030460994, 190392490709135, 308061521170129, 498454011879264, 806515533049393, 1304969544928657]\n    assert candidate(100) == [0, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, 144, 233, 377, 610, 987, 1597, 2584, 4181, 6765, 10946, 17711, 28657, 46368, 75025, 121393, 196418, 317811, 514229, 832040, 1346269, 2178309, 3524578, 5702887, 9227465, 14930352, 24157817, 39088169, 63245986, 102334155, 165580141, 267914296, 433494437, 701408733, 1134903170, 1836311903, 2971215073, 4807526976, 7778742049, 12586269025, 20365011074, 32951280099, 53316291173, 86267571272, 139583862445, 225851433717, 365435296162, 591286729879, 956722026041, 1548008755920, 2504730781961, 4052739537881, 6557470319842, 10610209857723, 17167680177565, 27777890035288, 44945570212853, 72723460248141, 117669030460994, 190392490709135, 308061521170129, 498454011879264, 806515533049393, 1304969544928657, 2111485077978050, 3416454622906707, 5527939700884757, 8944394323791464, 14472334024676221, 23416728348467685, 37889062373143906, 61305790721611591, 99194853094755497, 160500643816367088, 259695496911122585, 420196140727489673, 679891637638612258, 1100087778366101931, 1779979416004714189, 2880067194370816120, 4660046610375530309, 7540113804746346429, 12200160415121876738, 19740274219868223167, 31940434634990099905, 51680708854858323072, 83621143489848422977, 135301852344706746049, 218922995834555169026]\n    assert candidate(-5) == []\n    assert candidate(3) == [0, 1, 1]\n    assert candidate(1000) == [0, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, 144, 233, 377, 610, 987, 1597, 2584, 4181, 6765, 10946, 17711, 28657, 46368, 75025, 121393, 196418, 317811, 514229, 832040, 1346269, 2178309, 3524578, 5702887, 9227465, 14930352, 24157817, 39088169, 63245986, 102334155, 165580141, 267914296, 433494437, 701408733, 1134903170, 1836311903, 2971215073, 4807526976, 7778742049, 12586269025, 20365011074, 32951280099, 53316291173, 86267571272, 139583862445, 225851433717, 365435296162, 591286729879, 956722026041, 1548008755920, 2504730781961, 4052739537881, 6557470319842, 10610209857723, 17167680177565, 27777890035288, 44945570212853, 72723460248141, 117669030460994, 190392490709135, 308061521170129, 498454011879264, 806515533049393, 1304969544928657, 2111485077978050, 3416454622906707, 5527939700884757, 8944394323791464, 14472334024676221, 23416728348467685, 37889062373143906, 61305790721611591, 99194853094755497, 160500643816367088, 259695496911122585, 420196140727489673, 679891637638612258, 1100087778366101931, 1779979416004714189, 2880067194370816120, 4660046610375530309, 7540113804746346429, 12200160415121876738, 19740274219868223167, 31940434634990099905, 51680708854858323072, 83621143489848422977, 135301852344706746049, 218922995834555169026, 354224848179261915075, 573147844013817084101, 927372692193078999176, 1500520536206896083277, 2427893228399975082453, 3928413764606871165730, 6356306993006846248183, 10284720757613717413913, 16641027750620563662096, 26925748508234281076009, 43566776258854844738105, 70492524767089125814114, 114059301025943970552219, 184551825793033096366333, 298611126818977066918552, 483162952612010163284885, 781774079430987230203437, 1264937032042997393488322, 2046711111473984623691759, 3311648143516982017180081, 5358359254990966640871840, 8670007398507948658051921, 14028366653498915298923761, 22698374052006863956975682, 36726740705505779255899443, 59425114757512643212875125, 96151855463018422468774568, 155576970220531065681649693, 251728825683549488150424261, 407305795904080553832073954, 659034621587630041982498215, 1066340417491710595814572169, 1725375039079340637797070384, 2791715456571051233611642553, 4517090495650391871408712937, 7308805952221443105020355490, 11825896447871834976429068427, 19134702400093278081449423917, 30960598847965113057878492344, 50095301248058391139327916261, 81055900096023504197206408605, 131151201344081895336534324866, 212207101440105399533740733471, 343358302784187294870275058337, 555565404224292694404015791808, 898923707008479989274290850145, 1454489111232772683678306641953, 2353412818241252672952597492098, 3807901929474025356630904134051, 6161314747715278029583501626149, 9969216677189303386214405760200, 16130531424904581415797907386349, 26099748102093884802012313146549, 42230279526998466217810220532898, 68330027629092351019822533679447, 110560307156090817237632754212345, 178890334785183168257455287891792, 289450641941273985495088042104137, 468340976726457153752543329995929, 757791618667731139247631372100066, 1226132595394188293000174702095995, 1983924214061919432247806074196061, 3210056809456107725247980776292056, 5193981023518027157495786850488117, 8404037832974134882743767626780173, 13598018856492162040239554477268290, 22002056689466296922983322104048463, 35600075545958458963222876581316753, 57602132235424755886206198685365216, 93202207781383214849429075266681969, 150804340016807970735635273952047185, 244006547798191185585064349218729154, 394810887814999156320699623170776339, 638817435613190341905763972389505493, 1033628323428189498226463595560281832, 1672445759041379840132227567949787325, 2706074082469569338358691163510069157, 4378519841510949178490918731459856482, 7084593923980518516849609894969925639, 11463113765491467695340528626429782121, 18547707689471986212190138521399707760, 30010821454963453907530667147829489881, 48558529144435440119720805669229197641, 78569350599398894027251472817058687522, 127127879743834334146972278486287885163, 205697230343233228174223751303346572685, 332825110087067562321196029789634457848, 538522340430300790495419781092981030533, 871347450517368352816615810882615488381, 1409869790947669143312035591975596518914, 2281217241465037496128651402858212007295, 3691087032412706639440686994833808526209, 5972304273877744135569338397692020533504, 9663391306290450775010025392525829059713, 15635695580168194910579363790217849593217, 25299086886458645685589389182743678652930, 40934782466626840596168752972961528246147, 66233869353085486281758142155705206899077, 107168651819712326877926895128666735145224, 173402521172797813159685037284371942044301, 280571172992510140037611932413038677189525, 453973694165307953197296969697410619233826, 734544867157818093234908902110449296423351, 1188518561323126046432205871807859915657177, 1923063428480944139667114773918309212080528, 3111581989804070186099320645726169127737705, 5034645418285014325766435419644478339818233, 8146227408089084511865756065370647467555938, 13180872826374098837632191485015125807374171, 21327100234463183349497947550385773274930109, 34507973060837282187130139035400899082304280, 55835073295300465536628086585786672357234389, 90343046356137747723758225621187571439538669, 146178119651438213260386312206974243796773058, 236521166007575960984144537828161815236311727, 382699285659014174244530850035136059033084785, 619220451666590135228675387863297874269396512, 1001919737325604309473206237898433933302481297, 1621140188992194444701881625761731807571877809, 2623059926317798754175087863660165740874359106, 4244200115309993198876969489421897548446236915, 6867260041627791953052057353082063289320596021, 11111460156937785151929026842503960837766832936, 17978720198565577104981084195586024127087428957, 29090180355503362256910111038089984964854261893, 47068900554068939361891195233676009091941690850, 76159080909572301618801306271765994056795952743, 123227981463641240980692501505442003148737643593, 199387062373213542599493807777207997205533596336, 322615043836854783580186309282650000354271239929, 522002106210068326179680117059857997559804836265, 844617150046923109759866426342507997914076076194, 1366619256256991435939546543402365995473880912459, 2211236406303914545699412969744873993387956988653, 3577855662560905981638959513147239988861837901112, 5789092068864820527338372482892113982249794889765, 9366947731425726508977331996039353971111632790877, 15156039800290547036315704478931467953361427680642, 24522987531716273545293036474970821924473060471519, 39679027332006820581608740953902289877834488152161, 64202014863723094126901777428873111802307548623680, 103881042195729914708510518382775401680142036775841, 168083057059453008835412295811648513482449585399521, 271964099255182923543922814194423915162591622175362, 440047156314635932379335110006072428645041207574883, 712011255569818855923257924200496343807632829750245, 1152058411884454788302593034206568772452674037325128, 1864069667454273644225850958407065116260306867075373, 3016128079338728432528443992613633888712980904400501, 4880197746793002076754294951020699004973287771475874, 7896325826131730509282738943634332893686268675876375, 12776523572924732586037033894655031898659556447352249, 20672849399056463095319772838289364792345825123228624, 33449372971981195681356806732944396691005381570580873, 54122222371037658776676579571233761483351206693809497, 87571595343018854458033386304178158174356588264390370, 141693817714056513234709965875411919657707794958199867, 229265413057075367692743352179590077832064383222590237, 370959230771131880927453318055001997489772178180790104, 600224643828207248620196670234592075321836561403380341, 971183874599339129547649988289594072811608739584170445, 1571408518427546378167846658524186148133445300987550786, 2542592393026885507715496646813780220945054040571721231, 4114000911454431885883343305337966369078499341559272017, 6656593304481317393598839952151746590023553382130993248, 10770594215935749279482183257489712959102052723690265265, 17427187520417066673081023209641459549125606105821258513, 28197781736352815952563206467131172508227658829511523778, 45624969256769882625644229676772632057353264935332782291, 73822750993122698578207436143903804565580923764844306069, 119447720249892581203851665820676436622934188700177088360, 193270471243015279782059101964580241188515112465021394429, 312718191492907860985910767785256677811449301165198482789, 505988662735923140767969869749836918999964413630219877218, 818706854228831001753880637535093596811413714795418360007, 1324695516964754142521850507284930515811378128425638237225, 2143402371193585144275731144820024112622791843221056597232, 3468097888158339286797581652104954628434169971646694834457, 5611500259351924431073312796924978741056961814867751431689, 9079598147510263717870894449029933369491131786514446266146, 14691098406862188148944207245954912110548093601382197697835, 23770696554372451866815101694984845480039225387896643963981, 38461794961234640015759308940939757590587318989278841661816, 62232491515607091882574410635924603070626544377175485625797, 100694286476841731898333719576864360661213863366454327287613, 162926777992448823780908130212788963731840407743629812913410, 263621064469290555679241849789653324393054271110084140201023, 426547842461739379460149980002442288124894678853713953114433, 690168906931029935139391829792095612517948949963798093315456, 1116716749392769314599541809794537900642843628817512046429889, 1806885656323799249738933639586633513160792578781310139745345, 2923602405716568564338475449381171413803636207598822186175234, 4730488062040367814077409088967804926964428786380132325920579, 7654090467756936378415884538348976340768064993978954512095813, 12384578529797304192493293627316781267732493780359086838016392, 20038668997554240570909178165665757608500558774338041350112205, 32423247527351544763402471792982538876233052554697128188128597, 52461916524905785334311649958648296484733611329035169538240802, 84885164052257330097714121751630835360966663883732297726369399, 137347080577163115432025771710279131845700275212767467264610201, 222232244629420445529739893461909967206666939096499764990979600, 359579325206583560961765665172189099052367214309267232255589801, 581811569836004006491505558634099066259034153405766997246569401, 941390895042587567453271223806288165311401367715034229502159202, 1523202464878591573944776782440387231570435521120801226748728603, 2464593359921179141398048006246675396881836888835835456250887805, 3987795824799770715342824788687062628452272409956636682999616408, 6452389184720949856740872794933738025334109298792472139250504213, 10440185009520720572083697583620800653786381708749108822250120621, 16892574194241670428824570378554538679120491007541580961500624834, 27332759203762391000908267962175339332906872716290689783750745455, 44225333398004061429732838340729878012027363723832270745251370289, 71558092601766452430641106302905217344934236440122960529002115744, 115783425999770513860373944643635095356961600163955231274253486033, 187341518601536966291015050946540312701895836604078191803255601777, 303124944601307480151388995590175408058857436768033423077509087810, 490466463202844446442404046536715720760753273372111614880764689587, 793591407804151926593793042126891128819610710140145037958273777397, 1284057871006996373036197088663606849580363983512256652839038466984, 2077649278811148299629990130790497978399974693652401690797312244381, 3361707149818144672666187219454104827980338677164658343636350711365, 5439356428629292972296177350244602806380313370817060034433662955746, 8801063578447437644962364569698707634360652047981718378070013667111, 14240420007076730617258541919943310440740965418798778412503676622857, 23041483585524168262220906489642018075101617466780496790573690289968, 37281903592600898879479448409585328515842582885579275203077366912825, 60323387178125067141700354899227346590944200352359771993651057202793, 97605290770725966021179803308812675106786783237939047196728424115618, 157928677948851033162880158208040021697730983590298819190379481318411, 255533968719576999184059961516852696804517766828237866387107905434029, 413462646668428032346940119724892718502248750418536685577487386752440, 668996615388005031531000081241745415306766517246774551964595292186469, 1082459262056433063877940200966638133809015267665311237542082678938909, 1751455877444438095408940282208383549115781784912085789506677971125378, 2833915139500871159286880483175021682924797052577397027048760650064287, 4585371016945309254695820765383405232040578837489482816555438621189665, 7419286156446180413982701248558426914965375890066879843604199271253952, 12004657173391489668678522013941832147005954727556362660159637892443617, 19423943329837670082661223262500259061971330617623242503763837163697569, 31428600503229159751339745276442091208977285345179605163923475056141186, 50852543833066829834000968538942350270948615962802847667687312219838755, 82281144336295989585340713815384441479925901307982452831610787275979941, 133133688169362819419341682354326791750874517270785300499298099495818696, 215414832505658809004682396169711233230800418578767753330908886771798637, 348548520675021628424024078524038024981674935849553053830206986267617333, 563963353180680437428706474693749258212475354428320807161115873039415970, 912511873855702065852730553217787283194150290277873860991322859307033303, 1476475227036382503281437027911536541406625644706194668152438732346449273, 2388987100892084569134167581129323824600775934984068529143761591653482576, 3865462327928467072415604609040860366007401579690263197296200323999931849, 6254449428820551641549772190170184190608177514674331726439961915653414425, 10119911756749018713965376799211044556615579094364594923736162239653346274, 16374361185569570355515148989381228747223756609038926650176124155306760699, 26494272942318589069480525788592273303839335703403521573912286394960106973, 42868634127888159424995674777973502051063092312442448224088410550266867672, 69362907070206748494476200566565775354902428015845969798000696945226974645, 112231541198094907919471875344539277405965520328288418022089107495493842317, 181594448268301656413948075911105052760867948344134387820089804440720816962, 293825989466396564333419951255644330166833468672422805842178911936214659279, 475420437734698220747368027166749382927701417016557193662268716376935476241, 769246427201094785080787978422393713094534885688979999504447628313150135520, 1244666864935793005828156005589143096022236302705537193166716344690085611761, 2013913292136887790908943984011536809116771188394517192671163973003235747281, 3258580157072680796737099989600679905139007491100054385837880317693321359042, 5272493449209568587646043973612216714255778679494571578509044290696557106323, 8531073606282249384383143963212896619394786170594625964346924608389878465365, 13803567055491817972029187936825113333650564850089197542855968899086435571688, 22334640661774067356412331900038009953045351020683823507202893507476314037053, 36138207717265885328441519836863123286695915870773021050058862406562749608741, 58472848379039952684853851736901133239741266891456844557261755914039063645794, 94611056096305838013295371573764256526437182762229865607320618320601813254535, 153083904475345790698149223310665389766178449653686710164582374234640876900329, 247694960571651628711444594884429646292615632415916575771902992555242690154864, 400778865046997419409593818195095036058794082069603285936485366789883567055193, 648473825618649048121038413079524682351409714485519861708388359345126257210057, 1049252690665646467530632231274619718410203796555123147644873726135009824265250, 1697726516284295515651670644354144400761613511040643009353262085480136081475307, 2746979206949941983182302875628764119171817307595766156998135811615145905740557, 4444705723234237498833973519982908519933430818636409166351397897095281987215864, 7191684930184179482016276395611672639105248126232175323349533708710427892956421, 11636390653418416980850249915594581159038678944868584489700931605805709880172285, 18828075583602596462866526311206253798143927071100759813050465314516137773128706, 30464466237021013443716776226800834957182606015969344302751396920321847653300991, 49292541820623609906583302538007088755326533087070104115801862234837985426429697, 79757008057644623350300078764807923712509139103039448418553259155159833079730688, 129049549878268233256883381302815012467835672190109552534355121389997818506160385, 208806557935912856607183460067622936180344811293149000952908380545157651585891073, 337856107814181089864066841370437948648180483483258553487263501935155470092051458, 546662665750093946471250301438060884828525294776407554440171882480313121677942531, 884518773564275036335317142808498833476705778259666107927435384415468591769993989, 1431181439314368982806567444246559718305231073036073662367607266895781713447936520, 2315700212878644019141884587055058551781936851295739770295042651311250305217930509, 3746881652193013001948452031301618270087167924331813432662649918207032018665867029, 6062581865071657021090336618356676821869104775627553202957692569518282323883797538, 9809463517264670023038788649658295091956272699959366635620342487725314342549664567, 15872045382336327044129125268014971913825377475586919838578035057243596666433462105, 25681508899600997067167913917673267005781650175546286474198377544968911008983126672, 41553554281937324111297039185688238919607027651133206312776412602212507675416588777, 67235063181538321178464953103361505925388677826679492786974790147181418684399715449, 108788617463475645289761992289049744844995705477812699099751202749393926359816304226, 176023680645013966468226945392411250770384383304492191886725992896575345044216019675, 284812298108489611757988937681460995615380088782304890986477195645969271404032323901, 460835978753503578226215883073872246385764472086797082873203188542544616448248343576, 745648276861993189984204820755333242001144560869101973859680384188513887852280667477, 1206484255615496768210420703829205488386909032955899056732883572731058504300529011053, 1952132532477489958194625524584538730388053593825001030592563956919572392152809678530, 3158616788092986726405046228413744218774962626780900087325447529650630896453338689583, 5110749320570476684599671752998282949163016220605901117918011486570203288606148368113, 8269366108663463411004717981412027167937978847386801205243459016220834185059487057696, 13380115429233940095604389734410310117100995067992702323161470502791037473665635425809, 21649481537897403506609107715822337285038973915379503528404929519011871658725122483505, 35029596967131343602213497450232647402139968983372205851566400021802909132390757909314, 56679078505028747108822605166054984687178942898751709379971329540814780791115880392819, 91708675472160090711036102616287632089318911882123915231537729562617689923506638302133, 148387753977188837819858707782342616776497854780875624611509059103432470714622518694952, 240096429449348928530894810398630248865816766662999539843046788666050160638129156997085, 388484183426537766350753518180972865642314621443875164454555847769482631352751675692037, 628580612875886694881648328579603114508131388106874704297602636435532791990880832689122, 1017064796302424461232401846760575980150446009550749868752158484205015423343632508381159, 1645645409178311156114050175340179094658577397657624573049761120640548215334513341070281, 2662710205480735617346452022100755074809023407208374441801919604845563638678145849451440, 4308355614659046773460502197440934169467600804865999014851680725486111854012659190521721, 6971065820139782390806954219541689244276624212074373456653600330331675492690805039973161, 11279421434798829164267456416982623413744225016940372471505281055817787346703464230494882, 18250487254938611555074410636524312658020849229014745928158881386149462839394269270468043, 29529908689737440719341867053506936071765074245955118399664162441967250186097733500962925, 47780395944676052274416277690031248729785923474969864327823043828116713025492002771430968, 77310304634413492993758144743538184801550997720924982727487206270083963211589736272393893, 125090700579089545268174422433569433531336921195894847055310250098200676237081739043824861, 202401005213503038261932567177107618332887918916819829782797456368284639448671475316218754, 327491705792592583530106989610677051864224840112714676838107706466485315685753214360043615, 529892711006095621792039556787784670197112759029534506620905162834769955134424689676262369, 857384416798688205322146546398461722061337599142249183459012869301255270820177904036305984, 1387277127804783827114186103186246392258450358171783690079918032136025225954602593712568353, 2244661544603472032436332649584708114319787957314032873538930901437280496774780497748874337, 3631938672408255859550518752770954506578238315485816563618848933573305722729383091461442690, 5876600217011727891986851402355662620898026272799849437157779835010586219504163589210317027, 9508538889419983751537370155126617127476264588285666000776628768583891942233546680671759717, 15385139106431711643524221557482279748374290861085515437934408603594478161737710269882076744, 24893677995851695395061591712608896875850555449371181438711037372178370103971256950553836461, 40278817102283407038585813270091176624224846310456696876645445975772848265708967220435913205, 65172495098135102433647404982700073500075401759827878315356483347951218369680224170989749666, 105451312200418509472233218252791250124300248070284575192001929323724066635389191391425662871, 170623807298553611905880623235491323624375649830112453507358412671675285005069415562415412537, 276075119498972121378113841488282573748675897900397028699360341995399351640458606953841075408, 446698926797525733283994464723773897373051547730509482206718754667074636645528022516256487945, 722774046296497854662108306212056471121727445630906510906079096662473988285986629470097563353, 1169472973094023587946102770935830368494778993361415993112797851329548624931514651986354051298, 1892247019390521442608211077147886839616506438992322504018876947992022613217501281456451614651, 3061719992484545030554313848083717208111285432353738497131674799321571238149015933442805665949, 4953967011875066473162524925231604047727791871346061001150551747313593851366517214899257280600, 8015687004359611503716838773315321255839077303699799498282226546635165089515533148342062946549, 12969654016234677976879363698546925303566869175045860499432778293948758940882050363241320227149, 20985341020594289480596202471862246559405946478745659997715004840583924030397583511583383173698, 33954995036828967457475566170409171862972815653791520497147783134532682971279633874824703400847, 54940336057423256938071768642271418422378762132537180494862787975116607001677217386408086574545, 88895331094252224395547334812680590285351577786328700992010571109649289972956851261232789975392, 143835667151675481333619103454952008707730339918865881486873359084765896974634068647640876549937, 232730998245927705729166438267632598993081917705194582478883930194415186947590919908873666525329, 376566665397603187062785541722584607700812257624060463965757289279181083922224988556514543075266, 609297663643530892791951979990217206693894175329255046444641219473596270869815908465388209600595, 985864329041134079854737521712801814394706432953315510410398508752777354792040897021902752675861, 1595161992684664972646689501703019021088600608282570556855039728226373625661856805487290962276456, 2581026321725799052501427023415820835483307041235886067265438236979150980453897702509193714952317, 4176188314410464025148116525118839856571907649518456624120477965205524606115754507996484677228773, 6757214636136263077649543548534660692055214690754342691385916202184675586569652210505678392181090, 10933402950546727102797660073653500548627122340272799315506394167390200192685406718502163069409863, 17690617586682990180447203622188161240682337031027142006892310369574875779255058929007841461590953, 28624020537229717283244863695841661789309459371299941322398704536965075971940465647510004531000816, 46314638123912707463692067318029823029991796402327083329291014906539951751195524576517845992591769, 74938658661142424746936931013871484819301255773627024651689719443505027723135990224027850523592585, 121253296785055132210628998331901307849293052175954107980980734350044979474331514800545696516184354, 196191955446197556957565929345772792668594307949581132632670453793550007197467505024573547039776939, 317445252231252689168194927677674100517887360125535240613651188143594986671799019825119243555961293, 513637207677450246125760857023446893186481668075116373246321641937144993869266524849692790595738232, 831082459908702935293955784701120993704369028200651613859972830080739980541065544674812034151699525, 1344719667586153181419716641724567886890850696275767987106294472017884974410332069524504824747437757, 2175802127494856116713672426425688880595219724476419600966267302098624954951397614199316858899137282, 3520521795081009298133389068150256767486070420752187588072561774116509929361729683723821683646575039, 5696323922575865414847061494575945648081290145228607189038829076215134884313127297923138542545712321, 9216845717656874712980450562726202415567360565980794777111390850331644813674856981646960226192287360, 14913169640232740127827512057302148063648650711209401966150219926546779697987984279570098768737999681, 24130015357889614840807962620028350479216011277190196743261610776878424511662841261217058994930287041, 39043184998122354968635474677330498542864661988399598709411830703425204209650825540787157763668286722, 63173200356011969809443437297358849022080673265589795452673441480303628721313666802004216758598573763, 102216385354134324778078911974689347564945335253989394162085272183728832930964492342791374522266860485, 165389585710146294587522349272048196587026008519579189614758713664032461652278159144795591280865434248, 267605971064280619365601261246737544151971343773568583776843985847761294583242651487586965803132294733, 432995556774426913953123610518785740738997352293147773391602699511793756235520810632382557083997728981, 700601527838707533318724871765523284890968696066716357168446685359555050818763462119969522887130023714, 1133597084613134447271848482284309025629966048359864130560049384871348807054284272752352079971127752695, 1834198612451841980590573354049832310520934744426580487728496070230903857873047734872321602858257776409, 2967795697064976427862421836334141336150900792786444618288545455102252664927332007624673682829385529104, 4801994309516818408452995190383973646671835537213025106017041525333156522800379742496995285687643305513, 7769790006581794836315417026718114982822736329999469724305586980435409187727711750121668968517028834617, 12571784316098613244768412217102088629494571867212494830322628505768565710528091492618664254204672140130, 20341574322680408081083829243820203612317308197211964554628215486203974898255803242740333222721700974747, 32913358638779021325852241460922292241811880064424459384950843991972540608783894735358997476926373114877, 53254932961459429406936070704742495854129188261636423939579059478176515507039697978099330699648074089624, 86168291600238450732788312165664788095941068326060883324529903470149056115823592713458328176574447204501, 139423224561697880139724382870407283950070256587697307264108962948325571622863290691557658876222521294125, 225591516161936330872512695036072072046011324913758190588638866418474627738686883405015987052796968498626, 365014740723634211012237077906479355996081581501455497852747829366800199361550174096573645929019489792751, 590606256885570541884749772942551428042092906415213688441386695785274827100237057501589632981816458291377, 955620997609204752896986850849030784038174487916669186294134525152075026461787231598163278910835948084128, 1546227254494775294781736623791582212080267394331882874735521220937349853562024289099752911892652406375505, 2501848252103980047678723474640612996118441882248552061029655746089424880023811520697916190803488354459633, 4048075506598755342460460098432195208198709276580434935765176967026774733585835809797669102696140760835138, 6549923758702735390139183573072808204317151158828986996794832713116199613609647330495585293499629115294771, 10597999265301490732599643671505003412515860435409421932560009680142974347195483140293254396195769876129909, 17147923024004226122738827244577811616833011594238408929354842393259173960805130470788839689695398991424680, 27745922289305716855338470916082815029348872029647830861914852073402148308000613611082094085891168867554589, 44893845313309942978077298160660626646181883623886239791269694466661322268805744081870933775586567858979269, 72639767602615659833415769076743441675530755653534070653184546540063470576806357692953027861477736726533858, 117533612915925602811493067237404068321712639277420310444454241006724792845612101774823961637064304585513127, 190173380518541262644908836314147509997243394930954381097638787546788263422418459467776989498542041312046985, 307706993434466865456401903551551578318956034208374691542093028553513056268030561242600951135606345897560112, 497880373953008128101310739865699088316199429139329072639731816100301319690449020710377940634148387209607097, 805587367387474993557712643417250666635155463347703764181824844653814375958479581952978891769754733107167209, 1303467741340483121659023383282949754951354892487032836821556660754115695648928602663356832403903120316774306, 2109055108727958115216736026700200421586510355834736601003381505407930071607408184616335724173657853423941515, 3412522850068441236875759409983150176537865248321769437824938166162045767256336787279692556577560973740715821, 5521577958796399352092495436683350598124375604156506038828319671569975838863744971896028280751218827164657336, 8934100808864840588968254846666500774662240852478275476653257837732021606120081759175720837328779800905373157, 14455678767661239941060750283349851372786616456634781515481577509301997444983826731071749118079998628070030493, 23389779576526080530029005130016352147448857309113056992134835347034019051103908490247469955408778428975403650, 37845458344187320471089755413366203520235473765747838507616412856336016496087735221319219073488777057045434143, 61235237920713401001118760543382555667684331074860895499751248203370035547191643711566689028897555486020837793, 99080696264900721472208515956748759187919804840608734007367661059706052043279378932885908102386332543066271936, 160315934185614122473327276500131314855604135915469629507118909263076087590471022644452597131283888029087109729, 259396630450514843945535792456880074043523940756078363514486570322782139633750401577338505233670220572153381665, 419712564636128966418863068957011388899128076671547993021605479585858227224221424221791102364954108601240491394, 679109195086643810364398861413891462942652017427626356536092049908640366857971825799129607598624329173393873059, 1098821759722772776783261930370902851841780094099174349557697529494498594082193250020920709963578437774634364453, 1777930954809416587147660791784794314784432111526800706093789579403138960940165075820050317562202766948028237512, 2876752714532189363930922722155697166626212205625975055651487108897637555022358325840971027525781204722662601965, 4654683669341605951078583513940491481410644317152775761745276688300776515962523401661021345087983971670690839477, 7531436383873795315009506236096188648036856522778750817396763797198414070984881727501992372613765176393353441442, 12186120053215401266088089750036680129447500839931526579142040485499190586947405129163013717701749148064044280919, 19717556437089196581097595986132868777484357362710277396538804282697604657932286856665006090315514324457397722361, 31903676490304597847185685736169548906931858202641803975680844768196795244879691985828019808017263472521442003280, 51621232927393794428283281722302417684416215565352081372219649050894399902811978842493025898332777796978839725641, 83524909417698392275468967458471966591348073767993885347900493819091195147691670828321045706350041269500281728921, 135146142345092186703752249180774384275764289333345966720120142869985595050503649670814071604682819066479121454562, 218671051762790578979221216639246350867112363101339852068020636689076790198195320499135117311032860335979403183483, 353817194107882765682973465820020735142876652434685818788140779559062385248698970169949188915715679402458524638045, 572488245870673344662194682459267086009989015536025670856161416248139175446894290669084306226748539738437927821528, 926305439978556110345168148279287821152865667970711489644302195807201560695593260839033495142464219140896452459573, 1498793685849229455007362830738554907162854683506737160500463612055340736142487551508117801369212758879334380281101, 2425099125827785565352530979017842728315720351477448650144765807862542296838080812347151296511676978020230832740674, 3923892811677015020359893809756397635478575034984185810645229419917883032980568363855269097880889736899565213021775, 6348991937504800585712424788774240363794295386461634460789995227780425329818649176202420394392566714919796045762449, 10272884749181815606072318598530637999272870421445820271435224647698308362799217540057689492273456451819361258784224, 16621876686686616191784743387304878363067165807907454732225219875478733692617866716260109886666023166739157304546673, 26894761435868431797857061985835516362340036229353275003660444523177042055417084256317799378939479618558518563330897, 43516638122555047989641805373140394725407202037260729735885664398655775748034950972577909265605502785297675867877570, 70411399558423479787498867358975911087747238266614004739546108921832817803452035228895708644544982403856194431208467, 113928037680978527777140672732116305813154440303874734475431773320488593551486986201473617910150485189153870299086037, 184339437239402007564639540091092216900901678570488739214977882242321411354939021430369326554695467593010064730294504, 298267474920380535341780212823208522714056118874363473690409655562810004906426007631842944464845952782163935029380541, 482606912159782542906419752914300739614957797444852212905387537805131416261365029062212271019541420375173999759675045, 780874387080163078248199965737509262329013916319215686595797193367941421167791036694055215484387373157337934789055586, 1263481299239945621154619718651810001943971713764067899501184731173072837429156065756267486503928793532511934548730631, 2044355686320108699402819684389319264272985630083283586096981924541014258596947102450322701988316166689849869337786217, 3307836985560054320557439403041129266216957343847351485598166655714087096026103168206590188492244960222361803886516848, 5352192671880163019960259087430448530489942973930635071695148580255101354623050270656912890480561126912211673224303065, 8660029657440217340517698490471577796706900317777986557293315235969188450649153438863503078972806087134573477110819913, 14012222329320380360477957577902026327196843291708621628988463816224289805272203709520415969453367214046785150335122978, 22672251986760597700995656068373604123903743609486608186281779052193478255921357148383919048426173301181358627445942891, 36684474316080978061473613646275630451100586901195229815270242868417768061193560857904335017879540515228143777781065869, 59356726302841575762469269714649234575004330510681838001552021920611246317114918006288254066305713816409502405227008760, 96041200618922553823942883360924865026104917411877067816822264789029014378308478864192589084185254331637646183008074629, 155397926921764129586412153075574099601109247922558905818374286709640260695423396870480843150490968148047148588235083389, 251439127540686683410355036436498964627214165334435973635196551498669275073731875734673432234676222479684794771243158018, 406837054462450812996767189512073064228323413256994879453570838208309535769155272605154275385167190627731943359478241407, 658276182003137496407122225948572028855537578591430853088767389706978810842887148339827707619843413107416738130721399425, 1065113236465588309403889415460645093083860991848425732542338227915288346612042420944981983005010603735148681490199640832, 1723389418468725805811011641409217121939398570439856585631105617622267157454929569284809690624854016842565419620921040257, 2788502654934314115214901056869862215023259562288282318173443845537555504066971990229791673629864620577714101111120681089, 4511892073403039921025912698279079336962658132728138903804549463159822661521901559514601364254718637420279520732041721346, 7300394728337354036240813755148941551985917695016421221977993308697378165588873549744393037884583257997993621843162402435, 11812286801740393957266726453428020888948575827744560125782542771857200827110775109258994402139301895418273142575204123781, 19112681530077747993507540208576962440934493522760981347760536080554578992699648659003387440023885153416266764418366526216, 30924968331818141950774266662004983329883069350505541473543078852411779819810423768262381842163187048834539906993570649997, 50037649861895889944281806870581945770817562873266522821303614932966358812510072427265769282187072202250806671411937176213, 80962618193714031895056073532586929100700632223772064294846693785378138632320496195528151124350259251085346578405507826210, 131000268055609921839337880403168874871518195097038587116150308718344497444830568622793920406537331453336153249817445002423, 211962886249323953734393953935755803972218827320810651410997002503722636077151064818322071530887590704421499828222952828633, 342963154304933875573731834338924678843737022417849238527147311222067133521981633441115991937424922157757653078040397831056, 554926040554257829308125788274680482815955849738659889938144313725789769599132698259438063468312512862179152906263350659689, 897889194859191704881857622613605161659692872156509128465291624947856903121114331700554055405737435019936805984303748490745, 1452815235413449534189983410888285644475648721895169018403435938673646672720247029959992118874049947882115958890567099150434, 2350704430272641239071841033501890806135341594051678146868727563621503575841361361660546174279787382902052764874870847641179, 3803519665686090773261824444390176450610990315946847165272163502295150248561608391620538293153837330784168723765437946791613, 6154224095958732012333665477892067256746331909998525312140891065916653824402969753281084467433624713686221488640308794432792, 9957743761644822785595489922282243707357322225945372477413054568211804072964578144901622760587462044470390212405746741224405, 16111967857603554797929155400174310964103654135943897789553945634128457897367547898182707228021086758156611701046055535657197, 26069711619248377583524645322456554671460976361889270266967000202340261970332126043084329988608548802627001913451802276881602, 42181679476851932381453800722630865635564630497833168056520945836468719867699673941267037216629635560783613614497857812538799, 68251391096100309964978446045087420307025606859722438323487946038808981838031799984351367205238184363410615527949660089420401, 110433070572952242346432246767718285942590237357555606380008891875277701705731473925618404421867819924194229142447517901959200, 178684461669052552311410692812805706249615844217278044703496837914086683543763273909969771627106004287604844670397177991379601, 289117532242004794657842939580523992192206081574833651083505729789364385249494747835588176048973824211799073812844695893338801, 467801993911057346969253632393329698441821925792111695787002567703451068793258021745557947676079828499403918483241873884718402, 756919526153062141627096571973853690634028007366945346870508297492815454042752769581146123725053652711202992296086569778057203, 1224721520064119488596350204367183389075849933159057042657510865196266522836010791326704071401133481210606910779328443662775605, 1981641046217181630223446776341037079709877940526002389528019162689081976878763560907850195126187133921809903075415013440832808, 3206362566281301118819796980708220468785727873685059432185530027885348499714774352234554266527320615132416813854743457103608413, 5188003612498482749043243757049257548495605814211061821713549190574430476593537913142404461653507749054226716930158470544441221, 8394366178779783867863040737757478017281333687896121253899079218459778976308312265376958728180828364186643530784901927648049634, 13582369791278266616906284494806735565776939502107183075612628409034209452901850178519363189834336113240870247715060398192490855, 21976735970058050484769325232564213583058273190003304329511707627493988429210162443896321918015164477427513778499962325840540489, 35559105761336317101675609727370949148835212692110487405124336036528197882112012622415685107849500590668384026215022724033031344, 57535841731394367586444934959935162731893485882113791734636043664022186311322175066312007025864665068095897804714985049873571833, 93094947492730684688120544687306111880728698574224279139760379700550384193434187688727692133714165658764281830930007773906603177, 150630789224125052274565479647241274612622184456338070874396423364572570504756362755039699159578830726860179635644992823780175010, 243725736716855736962686024334547386493350883030562350014156803065122954698190550443767391293292996385624461466575000597686778187, 394356525940980789237251503981788661105973067486900420888553226429695525202946913198807090452871827112484641102219993421466953197, 638082262657836526199937528316336047599323950517462770902710029494818479901137463642574481746164823498109102568794994019153731384, 1032438788598817315437189032298124708705297018004363191791263255924514005104084376841381572199036650610593743671014987440620684581, 1670521051256653841637126560614460756304620968521825962693973285419332485005221840483956053945201474108702846239809981459774415965, 2702959839855471157074315592912585465009917986526189154485236541343846490109306217325337626144238124719296589910824968900395100546, 4373480891112124998711442153527046221314538955048015117179209826763178975114528057809293680089439598827999436150634950360169516511, 7076440730967596155785757746439631686324456941574204271664446368107025465223834275134631306233677723547296026061459919260564617057, 11449921622079721154497199899966677907638995896622219388843656194870204440338362332943924986323117322375295462212094869620734133568, 18526362353047317310282957646406309593963452838196423660508102562977229905562196608078556292556795045922591488273554788881298750625, 29976283975127038464780157546372987501602448734818643049351758757847434345900558941022481278879912368297886950485649658502032884193, 48502646328174355775063115192779297095565901573015066709859861320824664251462755549101037571436707414220478438759204447383331634818, 78478930303301394239843272739152284597168350307833709759211620078672098597363314490123518850316619782518365389244854105885364519011, 126981576631475750014906387931931581692734251880848776469071481399496762848826070039224556421753327196738843828004058553268696153829, 205460506934777144254749660671083866289902602188682486228283101478168861446189384529348075272069946979257209217248912659154060672840, 332442083566252894269656048603015447982636854069531262697354582877665624295015454568572631693823274175996053045252971212422756826669, 537902590501030038524405709274099314272539456258213748925637684355834485741204839097920706965893221155253262262501883871576817499509, 870344674067282932794061757877114762255176310327745011622992267233500110036220293666493338659716495331249315307754855083999574326178, 1408247264568312971318467467151214076527715766585958760548629951589334595777425132764414045625609716486502577570256738955576391825687, 2278591938635595904112529225028328838782892076913703772171622218822834705813645426430907384285326211817751892878011594039575966151865, 3686839203203908875430996692179542915310607843499662532720252170412169301591070559195321429910935928304254470448268332995152357977552, 5965431141839504779543525917207871754093499920413366304891874389235004007404715985626228814196262140122006363326279927034728324129417, 9652270345043413654974522609387414669404107763913028837612126559647173308995786544821550244107198068426260833774548260029880682106969, 15617701486882918434518048526595286423497607684326395142504000948882177316400502530447779058303460208548267197100828187064609006236386, 25269971831926332089492571135982701092901715448239423980116127508529350625396289075269329302410658276974528030875376447094489688343355, 40887673318809250524010619662577987516399323132565819122620128457411527941796791605717108360714118485522795227976204634159098694579741, 66157645150735582613503190798560688609301038580805243102736255965940878567193080680986437663124776762497323258851581081253588382923096, 107045318469544833137513810461138676125700361713371062225356384423352406508989872286703546023838895248020118486827785715412687077502837, 173202963620280415751017001259699364735001400294176305328092640389293285076182952967689983686963672010517441745679366796666275460425933, 280248282089825248888530811720838040860701762007547367553449024812645691585172825254393529710802567258537560232507152512078962537928770, 453451245710105664639547812980537405595703162301723672881541665201938976661355778222083513397766239269055001978186519308745237998354703, 733699527799930913528078624701375446456404924309271040434990690014584668246528603476477043108568806527592562210693671820824200536283473, 1187150773510036578167626437681912852052108086610994713316532355216523644907884381698560556506335045796647564188880191129569438534638176, 1920850301309967491695705062383288298508513010920265753751523045231108313154412985175037599614903852324240126399573862950393639070921649, 3108001074820004069863331500065201150560621097531260467068055400447631958062297366873598156121238898120887690588454054079963077605559825, 5028851376129971561559036562448489449069134108451526220819578445678740271216710352048635755736142750445127816988027917030356716676481474, 8136852450949975631422368062513690599629755205982786687887633846126372229279007718922233911857381648566015507576481971110319794282041299, 13165703827079947192981404624962180048698889314434312908707212291805112500495718070970869667593524399011143324564509888140676510958522773, 21302556278029922824403772687475870648328644520417099596594846137931484729774725789893103579450906047577158832140991859250996305240564072, 34468260105109870017385177312438050697027533834851412505302058429736597230270443860863973247044430446588302156705501747391672816199086845, 55770816383139792841788949999913921345356178355268512101896904567668081960045169650757076826495336494165460988846493606642669121439650917, 90239076488249662859174127312351972042383712190119924607198962997404679190315613511621050073539766940753763145551995354034341937638737762, 146009892871389455700963077312265893387739890545388436709095867565072761150360783162378126900035103434919224134398488960677011059078388679, 236248969359639118560137204624617865430123602735508361316294830562477440340676396673999176973574870375672987279950484314711352996717126441, 382258862231028574261100281936883758817863493280896798025390698127550201491037179836377303873609973810592211414348973275388364055795515120, 618507831590667692821237486561501624247987096016405159341685528690027641831713576510376480847184844186265198694299457590099717052512641561, 1000766693821696267082337768498385383065850589297301957367076226817577843322750756346753784720794817996857410108648430865488081108308156681, 1619274525412363959903575255059887007313837685313707116708761755507605485154464332857130265567979662183122608802947888455587798160820798242, 2620041219234060226985913023558272390379688274611009074075837982325183328477215089203884050288774480179980018911596319321075879269128954923, 4239315744646424186889488278618159397693525959924716190784599737832788813631679422061014315856754142363102627714544207776663677429949753165, 6859356963880484413875401302176431788073214234535725264860437720157972142108894511264898366145528622543082646626140527097739556699078708088, 11098672708526908600764889580794591185766740194460441455645037457990760955740573933325912682002282764906185274340684734874403234129028461253, 17958029672407393014640290882971022973839954428996166720505475178148733097849468444590811048147811387449267920966825261972142790828107169341, 29056702380934301615405180463765614159606694623456608176150512636139494053590042377916723730150094152355453195307509996846546024957135630594, 47014732053341694630045471346736637133446649052452774896655987814288227151439510822507534778297905539804721116274335258818688815785242799935, 76071434434275996245450651810502251293053343675909383072806500450427721205029553200424258508447999692160174311581845255665234840742378430529, 123086166487617690875496123157238888426499992728362157969462488264715948356469064022931793286745905231964895427856180514483923656527621230464, 199157600921893687120946774967741139719553336404271541042268988715143669561498617223356051795193904924125069739438025770149158497269999660993, 322243767409511377996442898124980028146053329132633699011731476979859617917967681246287845081939810156089965167294206284633082153797620891457, 521401368331405065117389673092721167865606665536905240054000465695003287479466298469643896877133715080215034906732232054782240651067620552450, 843645135740916443113832571217701196011659994669538939065731942674862905397433979715931741959073525236305000074026438339415322804865241443907, 1365046504072321508231222244310422363877266660206444179119732408369866192876900278185575638836207240316520034980758670394197563455932861996357, 2208691639813237951345054815528123559888926654875983118185464351044729098274334257901507380795280765552825035054785108733612886260798103440264, 3573738143885559459576277059838545923766193315082427297305196759414595291151234536087083019631488005869345070035543779127810449716730965436621, 5782429783698797410921331875366669483655119969958410415490661110459324389425568793988590400426768771422170105090328887861423335977529068876885, 9356167927584356870497608935205215407421313285040837712795857869873919680576803330075673420058256777291515175125872666989233785694260034313506, 15138597711283154281418940810571884891076433254999248128286518980333244070002372124064263820485025548713685280216201554850657121671789103190391, 24494765638867511151916549745777100298497746540040085841082376850207163750579175454139937240543282326005200455342074221839890907366049137503897, 39633363350150665433335490556348985189574179795039333969368895830540407820581547578204201061028307874718885735558275776690548029037838240694288, 64128128989018176585252040302126085488071926335079419810451272680747571571160723032344138301571590200724086190900349998530438936403887378198185, 103761492339168842018587530858475070677646106130118753779820168511287979391742270610548339362599898075442971926458625775220986965441725618892473, 167889621328187018603839571160601156165718032465198173590271441192035550962902993642892477664171488276167058117358975773751425901845612997090658, 271651113667355860622427102019076226843364138595316927370091609703323530354645264253440817026771386351610030043817601548972412867287338615983131, 439540734995542879226266673179677383009082171060515100960363050895359081317548257896333294690942874627777088161176577322723838769132951613073789, 711191848662898739848693775198753609852446309655832028330454660598682611672193522149774111717714260979387118204994178871696251636420290229056920, 1150732583658441619074960448378430992861528480716347129290817711494041692989741780046107406408657135607164206366170756194420090405553241842130709, 1861924432321340358923654223577184602713974790372179157621272372092724304661935302195881518126371396586551324571164935066116342041973532071187629, 3012657015979781977998614671955615595575503271088526286912090083586765997651677082241988924535028532193715530937335691260536432447526773913318338, 4874581448301122336922268895532800198289478061460705444533362455679490302313612384437870442661399928780266855508500626326652774489500305984505967, 7887238464280904314920883567488415793864981332549231731445452539266256299965289466679859367196428460973982386445836317587189206937027079897824305, 12761819912582026651843152463021215992154459394009937175978814994945746602278901851117729809857828389754249241954336943913841981426527385882330272, 20649058376862930966764036030509631786019440726559168907424267534212002902244191317797589177054256850728231628400173261501031188363554465780154577, 33410878289444957618607188493530847778173900120569106083403082529157749504523093168915318986912085240482480870354510205414873169790081851662484849, 54059936666307888585371224524040479564193340847128274990827350063369752406767284486712908163966342091210712498754683466915904358153636317442639426, 87470814955752846203978413017571327342367240967697381074230432592527501911290377655628227150878427331693193369109193672330777527943718169105124275, 141530751622060734789349637541611806906560581814825656065057782655897254318057662142341135314844769422903905867863877139246681886097354486547763701, 229001566577813580993328050559183134248927822782523037139288215248424756229348039797969362465723196754597099236973070811577459414041072655652887976, 370532318199874315782677688100794941155488404597348693204345997904322010547405701940310497780567966177501005104836947950824141300138427142200651677, 599533884777687896776005738659978075404416227379871730343634213152746766776753741738279860246291162932098104341810018762401600714179499797853539653, 970066202977562212558683426760773016559904631977220423547980211057068777324159443678590358026859129109599109446646966713225742014317926940054191330, 1569600087755250109334689165420751091964320859357092153891614424209815544100913185416870218273150292041697213788456985475627342728497426737907730983, 2539666290732812321893372592181524108524225491334312577439594635266884321425072629095460576300009421151296323235103952188853084742815353677961922313, 4109266378488062431228061757602275200488546350691404731331209059476699865525985814512330794573159713192993537023560937664480427471312780415869653296, 6648932669220874753121434349783799309012771842025717308770803694743584186951058443607791370873169134344289860258664889853333512214128134093831575609, 10758199047708937184349496107386074509501318192717122040102012754220284052477044258120122165446328847537283397282225827517813939685440914509701228905, 17407131716929811937470930457169873818514090034742839348872816448963868239428102701727913536319497981881573257540890717371147451899569048603532804514, 28165330764638749121820426564555948328015408227459961388974829203184152291905146959848035701765826829418856654823116544888961391585009963113234033419, 45572462481568561059291357021725822146529498262202800737847645652148020531333249661575949238085324811300429912364007262260108843484579011716766837933, 73737793246207310181111783586281770474544906489662762126822474855332172823238396621423984939851151640719286567187123807149070235069588974830000871352, 119310255727775871240403140608007592621074404751865562864670120507480193354571646282999934177936476452019716479551131069409179078554167986546767709285, 193048048973983181421514924194289363095619311241528324991492595362812366177810042904423919117787628092739003046738254876558249313623756961376768580637, 312358304701759052661918064802296955716693715993393887856162715870292559532381689187423853295724104544758719526289385945967428392177924947923536289922, 505406353675742234083432988996586318812313027234922212847655311233104925710191732091847772413511732637497722573027640822525677705801681909300304870559, 817764658377501286745351053798883274529006743228316100703818027103397485242573421279271625709235837182256442099317026768493106097979606857223841160481, 1323171012053243520828784042795469593341319770463238313551473338336502410952765153371119398122747569819754164672344667591018783803781288766524146031040, 2140935670430744807574135096594352867870326513691554414255291365439899896195338574650391023831983407002010606771661694359511889901760895623747987191521, 3464106682483988328402919139389822461211646284154792727806764703776402307148103728021510421954730976821764771444006361950530673705542184390272133222561, 5605042352914733135977054235984175329081972797846347142062056069216302203343442302671901445786714383823775378215668056310042563607303080014020120414082, 9069149035398721464379973375373997790293619082001139869868820772992704510491546030693411867741445360645540149659674418260573237312845264404292253636643, 14674191388313454600357027611358173119375591879847487011930876842209006713834988333365313313528159744469315527875342474570615800920148344418312374050725, 23743340423712176064737000986732170909669210961848626881799697615201711224326534364058725181269605105114855677535016892831189038232993608822604627687368, 38417531812025630665094028598090344029044802841696113893730574457410717938161522697424038494797764849584171205410359367401804839153141953240917001738093, 62160872235737806729831029584822514938714013803544740775530272072612429162488057061482763676067369954699026882945376260232993877386135562063521629425461, 100578404047763437394925058182912858967758816645240854669260846530023147100649579758906802170865134804283198088355735627634798716539277515304438631163554, 162739276283501244124756087767735373906472830448785595444791118602635576263137636820389565846932504758982224971301111887867792593925413077367960260589015, 263317680331264681519681145950648232874231647094026450114051965132658723363787216579296368017797639563265423059656847515502591310464690592672398891752569, 426056956614765925644437233718383606780704477542812045558843083735294299626924853399685933864730144322247648030957959403370383904390103670040359152341584, 689374636946030607164118379669031839654936124636838495672895048867953022990712069978982301882527783885513071090614806918872975214854794262712758044094153, 1115431593560796532808555613387415446435640602179650541231738132603247322617636923378668235747257928207760719121572766322243359119244897932753117196435737, 1804806230506827139972673993056447286090576726816489036904633181471200345608348993357650537629785712093273790212187573241116334334099692195465875240529890, 2920237824067623672781229606443862732526217328996139578136371314074447668225985916736318773377043640301034509333760339563359693453344590128218992436965627, 4725044054574450812753903599500310018616794055812628615041004495545648013834334910093969311006829352394308299545947912804476027787444282323684867677495517, 7645281878642074485535133205944172751143011384808768193177375809620095682060320826830288084383872992695342808879708252367835721240788872451903860114461144, 12370325933216525298289036805444482769759805440621396808218380305165743695894655736924257395390702345089651108425656165172311749028233154775588727791956661, 20015607811858599783824170011388655520902816825430165001395756114785839377954976563754545479774575337784993917305364417540147470269022027227492587906417805, 32385933745075125082113206816833138290662622266051561809614136419951583073849632300678802875165277682874645025731020582712459219297255182003081315698374466, 52401541556933724865937376828221793811565439091481726811009892534737422451804608864433348354939853020659638943036385000252606689566277209230573903604792271, 84787475302008849948050583645054932102228061357533288620624028954689005525654241165112151230105130703534283968767405582965065908863532391233655219303166737, 137189016858942574813987960473276725913793500449015015431633921489426427977458850029545499585044983724193922911803790583217672598429809600464229122907959008, 221976492160951424762038544118331658016021561806548304052257950444115433503113091194657650815150114427728206880571196166182738507293341991697884342211125745, 359165509019893999576026504591608383929815062255563319483891871933541861480571941224203150400195098151922129792374986749400411105723151592162113465119084753, 581142001180845424338065048709940041945836624062111623536149822377657294983685032418860801215345212579650336672946182915583149613016493583859997807330210498, 940307510200739423914091553301548425875651686317674943020041694311199156464256973643063951615540310731572466465321169664983560718739645176022111272449295251, 1521449511381584848252156602011488467821488310379786566556191516688856451447942006061924752830885523311222803138267352580566710331756138759882109079779505749, 2461757021582324272166248155313036893697139996697461509576233211000055607912198979704988704446425834042795269603588522245550271050495783935904220352228801000, 3983206532963909120418404757324525361518628307077248076132424727688912059360140985766913457277311357354018072741855874826116981382251922695786329432008306749, 6444963554546233392584652912637562255215768303774709585708657938688967667272339965471902161723737191396813342345444397071667252432747706631690549784237107749, 10428170087510142513003057669962087616734396610851957661841082666377879726632480951238815619001048548750831415087300271897784233814999629327476879216245414498, 16873133642056375905587710582599649871950164914626667247549740605066847393904820916710717780724785740147644757432744668969451486247747335959167429000482522247, 27301303729566518418590768252561737488684561525478624909390823271444727120537301867949533399725834288898476172520044940867235720062746965286644308216727936745, 44174437371622894324178478835161387360634726440105292156940563876511574514442122784660251180450620029046120929952789609836687206310494301245811737217210458992, 71475741101189412742769247087723124849319287965583917066331387147956301634979424652609784580176454317944597102472834550703922926373241266532456045433938395737, 115650178472812307066947725922884512209954014405689209223271951024467876149421547437270035760627074346990718032425624160540610132683735567778267782651148854729, 187125919574001719809716973010607637059273302371273126289603338172424177784400972089879820340803528664935315134898458711244533059056976834310723828085087250466, 302776098046814026876664698933492149269227316776962335512875289196892053933822519527149856101430603011926033167324082871785143191740712402088991610736236105195, 489902017620815746686381671944099786328500619148235461802478627369316231718223491617029676442234131676861348302222541583029676250797689236399715438821323355661, 792678115667629773563046370877591935597727935925197797315353916566208285652046011144179532543664734688787381469546624454814819442538401638488707049557559460856, 1282580133288445520249428042821691721926228555073433259117832543935524517370269502761209208985898866365648729771769166037844495693336090874888422488378882816517, 2075258248956075293812474413699283657523956490998631056433186460501732803022315513905388741529563601054436111241315790492659315135874492513377129537936442277373, 3357838382244520814061902456520975379450185046072064315551019004437257320392585016666597950515462467420084841013084956530503810829210583388265552026315325093890, 5433096631200596107874376870220259036974141537070695371984205464938990123414900530571986692045026068474520952254400747023163125965085075901642681564251767371263, 8790935013445116921936279326741234416424326583142759687535224469376247443807485547238584642560488535894605793267485703553666936794295659289908233590567092465153, 14224031644645713029810656196961493453398468120213455059519429934315237567222386077810571334605514604369126745521886450576830062759380735191550915154818859836416, 23014966658090829951746935523702727869822794703356214747054654403691485011029871625049155977166003140263732538789372154130496999553676394481459148745385952301569, 37238998302736542981557591720664221323221262823569669806574084338006722578252257702859727311771517744632859284311258604707327062313057129673010063900204812137985, 60253964960827372933304527244366949193044057526925884553628738741698207589282129327908883288937520884896591823100630758837824061866733524154469212645590764439554, 97492963263563915914862118965031170516265320350495554360202823079704930167534387030768610600709038629529451107411889363545151124179790653827479276545795576577539, 157746928224391288848166646209398119709309377877421438913831561821403137756816516358677493889646559514426042930512520122382975186046524177981948489191386341017093, 255239891487955204763028765174429290225574698227916993274034384901108067924350903389446104490355598143955494037924409485928126310226314831809427765737181917594632, 412986819712346493611195411383827409934884076105338432187865946722511205681167419748123598380002157658381536968436929608311101496272839009791376254928568258611725, 668226711200301698374224176558256700160458774333255425461900331623619273605518323137569702870357755802337031006361339094239227806499153841600804020665750176206357, 1081213530912648191985419587942084110095342850438593857649766278346130479286685742885693301250359913460718567974798268702550329302771992851392180275594318434818082, 1749440242112949890359643764500340810255801624771849283111666609969749752892204066023263004120717669263055598981159607796789557109271146692992984296260068611024439, 2830653773025598082345063352442424920351144475210443140761432888315880232178889808908956305371077582723774166955957876499339886412043139544385164571854387045842521, 4580094015138547972704707116942765730606946099982292423873099498285629985071093874932219309491795251986829765937117484296129443521314286237378148868114455656866960, 7410747788164146055049770469385190650958090575192735564634532386601510217249983683841175614862872834710603932893075360795469329933357425781763313439968842702709481, 11990841803302694027754477586327956381565036675175027988507631884887140202321077558773394924354668086697433698830192845091598773454671712019141462308083298359576441, 19401589591466840082804248055713147032523127250367763553142164271488650419571061242614570539217540921408037631723268205887068103388029137800904775748052141062285922, 31392431394769534110558725642041103414088163925542791541649796156375790621892138801387965463572209008105471330553461050978666876842700849820046238056135439421862363, 50794020986236374193362973697754250446611291175910555094791960427864441041463200044002536002789749929513508962276729256865734980230729987620951013804187580484148285, 82186452381005908303921699339795353860699455101453346636441756584240231663355338845390501466361958937618980292830190307844401857073430837440997251860323019906010648, 132980473367242282497284673037549604307310746277363901731233717012104672704818538889393037469151708867132489255106919564710136837304160825061948265664510600390158933, 215166925748248190801206372377344958168010201378817248367675473596344904368173877734783538935513667804751469547937109872554538694377591662502945517524833620296169581, 348147399115490473298491045414894562475320947656181150098909190608449577072992416624176576404665376671883958803044029437264675531681752487564893783189344220686328514, 563314324863738664099697417792239520643331149034998398466584664204794481441166294358960115340179044476635428350981139309819214226059344150067839300714177840982498095, 911461723979229137398188463207134083118652096691179548565493854813244058514158710983136691744844421148519387154025168747083889757741096637632733083903522061668826609, 1474776048842967801497885880999373603761983245726177947032078519018038539955325005342096807085023465625154815505006308056903103983800440787700572384617699902651324704, 2386237772822196938896074344206507686880635342417357495597572373831282598469483716325233498829867886773674202659031476803986993741541537425333305468521221964320151313, 3861013821665164740393960225205881290642618588143535442629650892849321138424808721667330305914891352398829018164037784860890097725341978213033877853138921866971476017, 6247251594487361679290034569412388977523253930560892938227223266680603736894292437992563804744759239172503220823069261664877091466883515638367183321660143831291627330, 10108265416152526419683994794618270268165872518704428380856874159529924875319101159659894110659650591571332238987107046525767189192225493851401061174799065698263103347, 16355517010639888098974029364030659245689126449265321319084097426210528612213393597652457915404409830743835459810176308190644280659109009489768244496459209529554730677, 26463782426792414518658024158648929513854998967969749699940971585740453487532494757312352026064060422315167698797283354716411469851334503341169305671258275227817834024, 42819299437432302617632053522679588759544125417235071019025069011950982099745888354964809941468470253059003158607459662907055750510443512830937550167717484757372564701, 69283081864224717136290077681328518273399124385204820718966040597691435587278383112277161967532530675374170857404743017623467220361778016172106855838975759985190398725, 112102381301657019753922131204008107032943249802439891737991109609642417687024271467241971909001000928433174016012202680530522970872221529003044406006693244742562963426, 181385463165881736890212208885336625306342374187644712456957150207333853274302654579519133876533531603807344873416945698153990191233999545175151261845669004727753362151, 293487844467538756644134340089344732339285623990084604194948259816976270961326926046761105785534532532240518889429148378684513162106221074178195667852362249470316325577, 474873307633420493534346548974681357645627998177729316651905410024310124235629580626280239662068064136047863762846094076838503353340220619353346929698031254198069687728, 768361152100959250178480889064026089984913622167813920846853669841286395196956506673041345447602596668288382652275242455523016515446441693531542597550393503668386013305, 1243234459734379743712827438038707447630541620345543237498759079865596519432586087299321585109670660804336246415121336532361519868786662312884889527248424757866455701033, 2011595611835338993891308327102733537615455242513357158345612749706882914629542593972362930557273257472624629067396578987884536384233104006416432124798818261534841714338, 3254830071569718737604135765141440985245996862858900395844371829572479434062128681271684515666943918276960875482517915520246056253019766319301321652047243019401297415371, 5266425683405057731495444092244174522861452105372257554189984579279362348691671275244047446224217175749585504549914494508130592637252870325717753776846061280936139129709, 8521255754974776469099579857385615508107448968231157950034356408851841782753799956515731961891161094026546380032432410028376648890272636645019075428893304300337436545080, 13787681438379834200595023949629790030968901073603415504224340988131204131445471231759779408115378269776131884582346904536507241527525506970736829205739365581273575674789, 22308937193354610669694603807015405539076350041834573454258697396983045914199271188275511370006539363802678264614779314564883890417798143615755904634632669881611012219869, 36096618631734444870289627756645195570045251115437988958483038385114250045644742420035290778121917633578810149197126219101391131945323650586492733840372035462884587894658, 58405555825089055539984231563660601109121601157272562412741735782097295959844013608310802148128456997381488413811905533666275022363121794202248638475004705344495600114527, 94502174456823500410273859320305796679166852272710551371224774167211546005488756028346092926250374630960298563009031752767666154308445444788741372315376740807380188009185, 152907730281912555950258090883966397788288453429983113783966509949308841965332769636656895074378831628341786976820937286433941176671567238990990010790381446151875788123712, 247409904738736056360531950204272194467455305702693665155191284116520387970821525665002988000629206259302085539829969039201607330980012683779731383105758186959255976132897, 400317635020648612310790041088238592255743759132676778939157794065829229936154295301659883075008037887643872516650906325635548507651579922770721393896139633111131764256609, 647727539759384668671321991292510786723199064835370444094349078182349617906975820966662871075637244146945958056480875364837155838631592606550452777001897820070387740389506, 1048045174780033280982112032380749378978942823968047223033506872248178847843130116268322754150645282034589830573131781690472704346283172529321174170898037453181519504646115, 1695772714539417949653434023673260165702141888803417667127855950430528465750105937234985625226282526181535788629612657055309860184914765135871626947899935273251907245035621, 2743817889319451230635546056054009544681084712771464890161362822678707313593236053503308379376927808216125619202744438745782564531197937665192801118797972726433426749681736, 4439590603858869180288980079727269710383226601574882557289218773109235779343341990738294004603210334397661407832357095801092424716112702801064428066697907999685333994717357, 7183408493178320410924526135781279255064311314346347447450581595787943092936578044241602383980138142613787027035101534546874989247310640466257229185495880726118760744399093, 11622999097037189591213506215508548965447537915921230004739800368897178872279920034979896388583348477011448434867458630347967413963423343267321657252193788725804094739116450, 18806407590215510002138032351289828220511849230267577452190381964685121965216498079221498772563486619625235461902560164894842403210733983733578886437689669451922855483515543, 30429406687252699593351538566798377185959387146188807456930182333582300837496418114201395161146835096636683896770018795242809817174157327000900543689883458177726950222631993, 49235814277468209595489570918088205406471236376456384909120564298267422802712916193422893933710321716261919358672578960137652220384891310734479430127573127629649805706147536, 79665220964720909188841109484886582592430623522645192366050746631849723640209334307624289094857156812898603255442597755380462037559048637735379973817456585807376755928779529, 128901035242189118784330680402974787998901859899101577275171310930117146442922250501047183028567478529160522614115176715518114257943939948469859403945029713437026561634927065, 208566256206910027973171789887861370591332483421746769641222057561966870083131584808671472123424635342059125869557774470898576295502988586205239377762486299244403317563706594, 337467291449099146757502470290836158590234343320848346916393368492084016526053835309718655151992113871219648483672951186416690553446928534675098781707516012681429879198633659, 546033547656009174730674260178697529181566826742595116557615426054050886609185420118390127275416749213278774353230725657315266848949917120880338159470002311925833196762340253, 883500839105108321488176730469533687771801170063443463474008794546134903135239255428108782427408863084498422836903676843731957402396845655555436941177518324607263075960973912, 1429534386761117496218850990648231216953367996806038580031624220600185789744424675546498909702825612297777197190134402501047224251346762776435775100647520636533096272723314165, 2313035225866225817707027721117764904725169166869482043505633015146320692879663930974607692130234475382275620027038079344779181653743608431991212041825038961140359348684288077, 3742569612627343313925878711765996121678537163675520623537257235746506482624088606521106601833060087680052817217172481845826405905090371208426987142472559597673455621407602242, 6055604838493569131632906432883761026403706330545002667042890250892827175503752537495714293963294563062328437244210561190605587558833979640418199184297598558813814970091890319, 9798174451120912445558785144649757148082243494220523290580147486639333658127841144016820895796354650742381254461383043036431993463924350848845186326770158156487270591499492561, 15853779289614481577191691577533518174485949824765525957623037737532160833631593681512535189759649213804709691705593604227037581022758330489263385511067756715301085561591382880, 25651953740735394022750476722183275322568193318986049248203185224171494491759434825529356085556003864547090946166976647263469574486682681338108571837837914871788356153090875441, 41505733030349875599942168299716793497054143143751575205826222961703655325391028507041891275315653078351800637872570251490507155509441011827371957348905671587089441714682258321, 67157686771085269622692645021900068819622336462737624454029408185875149817150463332571247360871656942898891584039546898753976729996123693165480529186743586458877797867773133762, 108663419801435145222634813321616862316676479606489199659855631147578805142541491839613138636187310021250692221912117150244483885505564704992852486535649258045967239582455392083, 175821106572520414845327458343516931136298816069226824113885039333453954959691955172184385997058966964149583805951664048998460615501688398158333015722392844504845037450228525845, 284484526373955560067962271665133793452975295675716023773740670481032760102233447011797524633246276985400276027863781199242944501007253103151185502258042102550812277032683917928, 460305632946475974913289730008650724589274111744942847887625709814486715061925402183981910630305243949549859833815445248241405116508941501309518517980434947055657314482912443773, 744790159320431534981252001673784518042249407420658871661366380295519475164158849195779435263551520934950135861679226447484349617516194604460704020238477049606469591515596361701, 1205095792266907509894541731682435242631523519165601719548992090110006190226084251379761345893856764884499995695494671695725754734025136105770222538218911996662126905998508805474, 1949885951587339044875793733356219760673772926586260591210358470405525665390243100575540781157408285819450131557173898143210104351541330710230926558457389046268596497514105167175, 3154981743854246554770335465038655003305296445751862310759350560515531855616327351955302127051265050703950127252668569838935859085566466816001149096676301042930723403512613972649, 5104867695441585599646129198394874763979069372338122901969709030921057521006570452530842908208673336523400258809842467982145963437107797526232075655133690089199319901026719139824, 8259849439295832154416464663433529767284365818089985212729059591436589376622897804486145035259938387227350386062511037821081822522674264342233224751809991132130043304539333112473, 13364717134737417754062593861828404531263435190428108114698768622357646897629468257016987943468611723750750644872353505803227785959782061868465300406943681221329363205566052252297, 21624566574033249908479058525261934298547801008518093327427828213794236274252366061503132978728550110978101030934864543624309608482456326210698525158753672353459406510105385364770, 34989283708770667662541652387090338829811236198946201442126596836151883171881834318520120922197161834728851675807218049427537394442238388079163825565697353574788769715671437617067, 56613850282803917571020710912352273128359037207464294769554425049946119446134200380023253900925711945706952706742082593051847002924694714289862350724451025928248176225776822981837, 91603133991574585233562363299442611958170273406410496211681021886098002618016034698543374823122873780435804382549300642479384397366933102369026176290148379503036945941448260598904, 148216984274378502804583074211794885086529310613874790981235446936044122064150235078566628724048585726142757089291383235531231400291627816658888527014599405431285122167225083580741, 239820118265953088038145437511237497044699584020285287192916468822142124682166269777110003547171459506578561471840683878010615797658560919027914703304747784934322068108673344179645, 388037102540331590842728511723032382131228894634160078174151915758186246746316504855676632271220045232721318561132067113541847197950188735686803230319347190365607190275898427760386, 627857220806284678880873949234269879175928478654445365367068384580328371428482774632786635818391504739299880032972750991552462995608749654714717933624094975299929258384571771940031, 1015894323346616269723602460957302261307157373288605443541220300338514618174799279488463268089611549972021198594104818105094310193558938390401521163943442165665536448660470199700417, 1643751544152900948604476410191572140483085851943050808908288684918842989603282054121249903908003054711321078627077569096646773189167688045116239097567537140965465707045041971640448, 2659645867499517218328078871148874401790243225231656252449508985257357607778081333609713171997614604683342277221182387201741083382726626435517760261510979306631002155705512171340865, 4303397411652418166932555281340446542273329077174707061357797670176200597381363387730963075905617659394663355848259956298387856571894314480633999359078516447596467862750554142981313, 6963043279151935385260634152489320944063572302406363313807306655433558205159444721340676247903232264078005633069442343500128939954620940916151759620589495754227470018456066314322178, 11266440690804353552193189433829767486336901379581070375165104325609758802540808109071639323808849923472668988917702299798516796526515255396785758979668012201823937881206620457303491, 18229483969956288937453823586319088430400473681987433688972410981043317007700252830412315571712082187550674621987144643298645736481136196312937518600257507956051407899662686771625669, 29495924660760642489647013020148855916737375061568504064137515306653075810241060939483954895520932111023343610904846943097162533007651451709723277579925520157875345780869307228929160, 47725408630716931427100836606467944347137848743555937753109926287696392817941313769896270467233014298574018232891991586395808269488787648022660796180183028113926753680531994000554829, 77221333291477573916747849626616800263875223805124441817247441594349468628182374709380225362753946409597361843796838529492970802496439099732384073760108548271802099461401301229483989, 124946741922194505343848686233084744611013072548680379570357367882045861446123688479276495829986960708171380076688830115888779071985226747755044869940291576385728853141933295230038818, 202168075213672079260596535859701544874888296353804821387604809476395330074306063188656721192740907117768741920485668645381749874481665847487428943700400124657530952603334596459522807, 327114817135866584604445222092786289485901368902485200957962177358441191520429751667933217022727867825940121997174498761270528946466892595242473813640691701043259805745267891689561625, 529282892349538663865041757952487834360789665256290022345566986834836521594735814856589938215468774943708863917660167406652278820948558442729902757341091825700790758348602488149084432, 856397709485405248469486980045274123846691034158775223303529164193277713115165566524523155238196642769648985914834666167922807767415451037972376570981783526744050564093870379838646057, 1385680601834943912334528737997761958207480699415065245649096151028114234709901381381113093453665417713357849832494833574575086588364009480702279328322875352444841322442472867987730489, 2242078311320349160804015718043036082054171733573840468952625315221391947825066947905636248691862060483006835747329499742497894355779460518674655899304658879188891886536343247826376546, 3627758913155293073138544456040798040261652432988905714601721466249506182534968329286749342145527478196364685579824333317072980944143469999376935227627534231633733208978816115814107035, 5869837224475642233942560174083834122315824166562746183554346781470898130360035277192385590837389538679371521327153833059570875299922930518051591126932193110822625095515159363640483581, 9497596137630935307081104630124632162577476599551651898156068247720404312895003606479134932982917016875736206906978166376643856244066400517428526354559727342456358304493975479454590616, 15367433362106577541023664804208466284893300766114398081710415029191302443255038883671520523820306555555107728234131999436214731543989331035480117481491920453278983400009134843095074197, 24865029499737512848104769434333098447470777365666049979866483276911706756150042490150655456803223572430843935141110165812858587788055731552908643836051647795735341704503110322549664813, 40232462861844090389128434238541564732364078131780448061576898306103009199405081373822175980623530127985951663375242165249073319332045062588388761317543568249014325104512245165644739010, 65097492361581603237233203672874663179834855497446498041443381583014715955555123863972831437426753700416795598516352331061931907120100794141297405153595216044749666809015355488194403823, 105329955223425693626361637911416227912198933629226946103020279889117725154960205237795007418050283828402747261891594496311005226452145856729686166471138784293763991913527600653839142833, 170427447585007296863594841584290891092033789126673444144463661472132441110515329101767838855477037528819542860407946827372937133572246650870983571624734000338513658722542956142033546656, 275757402808432990489956479495707119004232722755900390247483941361250166265475534339562846273527321357222290122299541323683942360024392507600669738095872784632277650636070556795872689489, 446184850393440287353551321079998010096266511882573834391947602833382607375990863441330685129004358886041832982707488151056879493596639158471653309720606784970791309358613512937906236145, 721942253201873277843507800575705129100499234638474224639431544194632773641466397780893531402531680243264123105007029474740821853621031666072323047816479569603068959994684069733778925634, 1168127103595313565197059121655703139196765746521048059031379147028015381017457261222224216531536039129305956087714517625797701347217670824543976357537086354573860269353297582671685161779, 1890069356797186843040566922231408268297264981159522283670810691222648154658923659003117747934067719372570079192721547100538523200838702490616299405353565924176929229347981652405464087413, 3058196460392500408237626043887111407494030727680570342702189838250663535676380920225341964465603758501876035280436064726336224548056373315160275762890652278750789498701279235077149249192, 4948265817189687251278192966118519675791295708840092626373000529473311690335304579228459712399671477874446114473157611826874747748895075805776575168244218202927718728049260887482613336605, 8006462277582187659515819010005631083285326436520662969075190367723975226011685499453801676865275236376322149753593676553210972296951449120936850931134870481678508226750540122559762585797, 12954728094771874910794011976124150759076622145360755595448190897197286916346990078682261389264946714250768264226751288380085720045846524926713426099379088684606226954799801010042375922402, 20961190372354062570309830986129781842361948581881418564523381264921262142358675578136063066130221950627090413980344964933296692342797974047650277030513959166284735181550341132602138508199, 33915918467125937481103842962253932601438570727242174159971572162118549058705665656818324455395168664877858678207096253313382412388644498974363703129893047850890962136350142142644514430601, 54877108839480000051413673948383714443800519309123592724494953427039811201064341234954387521525390615504949092187441218246679104731442473022013980160407007017175697317900483275246652938800, 88793027306605937532517516910637647045239090036365766884466525589158360259770006891772711976920559280382807770394537471560061517120086971996377683290300054868066659454250625417891167369401, 143670136146085937583931190859021361489039609345489359608961479016198171460834348126727099498445949895887756862581978689806740621851529445018391663450707061885242356772151108693137820308201, 232463163452691875116448707769659008534278699381855126493428004605356531720604355018499811475366509176270564632976516161366802138971616417014769346741007116753309016226401734111028987677602, 376133299598777812700379898628680370023318308727344486102389483621554703181438703145226910973812459072158321495558494851173542760823145862033161010191714178638551372998552842804166807985803, 608596463051469687816828606398339378557597008109199612595817488226911234902043058163726722449178968248428886128535011012540344899794762279047930356932721295391860389224954576915195795663405, 984729762650247500517208505027019748580915316836544098698206971848465938083481761308953633422991427320587207624093505863713887660617908141081091367124435474030411762223507419719362603649208, 1593326225701717188334037111425359127138512324945743711294024460075377172985524819472680355872170395569016093752628516876254232560412670420129021724057156769422272151448461996634558399312613, 2578055988351964688851245616452378875719427641782287809992231431923843111069006580781633989295161822889603301376722022739968120221030578561210113091181592243452683913671969416353921002961821, 4171382214053681877185282727877738002857939966728031521286255891999220284054531400254314345167332218458619395129350539616222352781443248981339134815238749012874956065120431412988479402274434, 6749438202405646566036528344330116878577367608510319331278487323923063395123537981035948334462494041348222696506072562356190473002473827542549247906420341256327639978792400829342400405236255, 10920820416459328443221811072207854881435307575238350852564743215922283679178069381290262679629826259806842091635423101972412825783917076523888382721659090269202596043912832242330879807510689, 17670258618864975009258339416537971760012675183748670183843230539845347074301607362326211014092320301155064788141495664328603298786390904066437630628079431525530236022705233071673280212746944, 28591079035324303452480150488745826641447982758987021036407973755767630753479676743616473693722146560961906879776918766301016124570307980590326013349738521794732832066618065314004160020257633, 46261337654189278461738489905283798401460657942735691220251204295612977827781284105942684707814466862116971667918414430629619423356698884656763643977817953320263068089323298385677440233004577, 74852416689513581914218640394029625042908640701722712256659178051380608581260960849559158401536613423078878547695333196930635547927006865247089657327556475114995900155941363699681600253262210, 121113754343702860375957130299313423444369298644458403476910382346993586409042244955501843109351080285195850215613747627560254971283705749903853301305374428435258968245264662085359040486266787, 195966171033216442290175770693343048487277939346181115733569560398374194990303205805061001510887693708274728763309080824490890519210712615150942958632930903550254868401206025785040640739528997, 317079925376919302666132900992656471931647237990639519210479942745367781399345450760562844620238773993470578978922828452051145490494418365054796259938305331985513836646470687870399681225795784, 513046096410135744956308671685999520418925177336820634944049503143741976389648656565623846131126467701745307742231909276542036009705130980205739218571236235535768705047676713655440321965324781, 830126021787055047622441572678655992350572415327460154154529445889109757788994107326186690751365241695215886721154737728593181500199549345260535478509541567521282541694147401525840003191120565, 1343172118197190792578750244364655512769497592664280789098578949032851734178642763891810536882491709396961194463386647005135217509904680325466274697080777803057051246741824115181280325156445346, 2173298139984245840201191817043311505120070007991740943253108394921961491967636871217997227633856951092177081184541384733728399010104229670726810175590319370578333788435971516707120328347565911, 3516470258181436632779942061407967017889567600656021732351687343954813226146279635109807764516348660489138275647928031738863616520008909996193084872671097173635385035177795631888400653504011257, 5689768398165682472981133878451278523009637608647762675604795738876774718113916506327804992150205611581315356832469416472592015530113139666919895048261416544213718823613767148595520981851577168, 9206238656347119105761075939859245540899205209303784407956483082831587944260196141437612756666554272070453632480397448211455632050122049663112979920932513717849103858791562780483921635355588425, 14896007054512801578742209818310524063908842817951547083561278821708362662374112647765417748816759883651768989312866864684047647580235189330032874969193930262062822682405329929079442617207165593, 24102245710859920684503285758169769604808048027255331491517761904539950606634308789203030505483314155722222621793264312895503279630357238993145854890126443979911926541196892709563364252562754018, 38998252765372722263245495576480293668716890845206878575079040726248313269008421436968448254300074039373991611106131177579550927210592428323178729859320374241974749223602222638642806869769919611, 63100498476232642947748781334650063273524938872462210066596802630788263875642730226171478759783388195096214232899395490475054206840949667316324584749446818221886675764799115348206171122332673629, 102098751241605365210994276911130356942241829717669088641675843357036577144651151663139927014083462234470205844005526668054605134051542095639503314608767192463861424988401337986848977992102593240, 165199249717838008158743058245780420215766768590131298708272645987824841020293881889311405773866850429566420076904922158529659340892491762955827899358214010685748100753200453335055149114435266869, 267298000959443373369737335156910777158008598307800387349948489344861418164945033552451332787950312664036625920910448826584264474944033858595331213966981203149609525741601791321904127106537860109, 432497250677281381528480393402691197373775366897931686058221135332686259185238915441762738561817163093603045997815370985113923815836525621551159113325195213835357626494802244656959276220973126978, 699795251636724754898217728559601974531783965205732073408169624677547677350183948994214071349767475757639671918725819811698188290780559480146490327292176416984967152236404035978863403327510987087, 1132292502314006136426698121962293171905559332103663759466390760010233936535422864435976809911584638851242717916541190796812112106617085101697649440617371630820324778731206280635822679548484114065, 1832087753950730891324915850521895146437343297309395832874560384687781613885606813430190881261352114608882389835267010608510300397397644581844139767909548047805291930967610316614686082875995101152, 2964380256264737027751613972484188318342902629413059592340951144698015550421029677866167691172936753460125107751808201405322412504014729683541789208526919678625616709698816597250508762424479215217, 4796468010215467919076529823006083464780245926722455425215511529385797164306636491296358572434288868069007497587075212013832712901412374265385928976436467726430908640666426913865194845300474316369, 7760848266480204946828143795490271783123148556135515017556462674083812714727666169162526263607225621529132605338883413419155125405427103948927718184963387405056525350365243511115703607724953531586, 12557316276695672865904673618496355247903394482857970442771974203469609879034302660458884836041514489598140102925958625432987838306839478214313647161399855131487433991031670424980898453025427847955, 20318164543175877812732817413986627031026543038993485460328436877553422593761968829621411099648740111127272708264842038852142963712266582163241365346363242536543959341396913936096602060750381379541, 32875480819871550678637491032482982278929937521851455903100411081023032472796271490080295935690254600725412811190800664285130802019106060377555012507763097668031393332428584361077500513775809227496, 53193645363047428491370308446469609309956480560844941363428847958576455066558240319701707035338994711852685519455642703137273765731372642540796377854126340204575352673825498297174102574526190607037, 86069126182918979170007799478952591588886418082696397266529259039599487539354511809782002971029249312578098330646443367422404567750478702918351390361889437872606746006254082658251603088301999834533, 139262771545966407661378107925422200898842898643541338629958106998175942605912752129483710006368244024430783850102086070559678333481851345459147768216015778077182098680079580955425705662828190441570, 225331897728885386831385907404374792487729316726237735896487366037775430145267263939265712977397493337008882180748529437982082901232330048377499158577905215949788844686333663613677308751130190276103, 364594669274851794492764015329796993386572215369779074526445473035951372751180016068749422983765737361439666030850615508541761234714181393836646926793920994026970943366413244569103014413958380717673, 589926567003737181324149922734171785874301532096016810422932839073726802896447280008015135961163230698448548211599144946523844135946511442214146085371826209976759788052746908182780323165088570993776, 954521236278588975816913938063968779260873747465795884949378312109678175647627296076764558944928968059888214242449760455065605370660692836050793012165747204003730731419160152751883337579046951711449, 1544447803282326157141063860798140565135175279561812695372311151183404978544074576084779694906092198758336762454048905401589449506607204278264939097537573413980490519471907060934663660744135522705225, 2498969039560915132957977798862109344396049027027608580321689463293083154191701872161544253851021166818224976696498665856655054877267897114315732109703320617984221250891067213686546998323182474416674, 4043416842843241290099041659660249909531224306589421275694000614476488132735776448246323948757113365576561739150547571258244504383875101392580671207240894031964711770362974274621210659067317997121899, 6542385882404156423057019458522359253927273333617029856015690077769571286927478320407868202608134532394786715847046237114899559261142998506896403316944214649948933021254041488307757657390500471538573, 10585802725247397713156061118182609163458497640206451131709690692246059419663254768654192151365247897971348454997593808373144063645018099899477074524185108681913644791617015762928968316457818468660472, 17128188607651554136213080576704968417385770973823480987725380770015630706590733089062060353973382430366135170844640045488043622906161098406373477841129323331862577812871057251236725973848318940199045, 27713991332898951849369141694887577580844268614029932119435071462261690126253987857716252505338630328337483625842233853861187686551179198305850552365314432013776222604488073014165694290306137408859517, 44842179940550505985582222271592545998230039587853413107160452232277320832844720946778312859312012758703618796686873899349231309457340296712224030206443755345638800417359130265402420264154456349058562, 72556171273449457834951363966480123579074308201883345226595523694539010959098708804494565364650643087041102422529107753210418996008519495018074582571758187359415023021847203279568114554460593757918079, 117398351213999963820533586238072669577304347789736758333755975926816331791943429751272878223962655845744721219215981652559650305465859791730298612778201942705053823439206333544970534818615050106976641, 189954522487449421655484950204552793156378655991620103560351499621355342751042138555767443588613298932785823641745089405770069301474379286748373195349960130064468846461053536824538649373075643864894720, 307352873701449385476018536442625462733683003781356861894107475548171674542985568307040321812575954778530544860961071058329719606940239078478671808128162072769522669900259870369509184191690693971871361, 497307396188898807131503486647178255890061659772976965454458975169527017294027706862807765401189253711316368502706160464099788908414618365227045003478122202833991516361313407194047833564766337836766081, 804660269890348192607522023089803718623744663554333827348566450717698691837013275169848087213765208489846913363667231522429508515354857443705716811606284275603514186261573277563557017756457031808637442, 1301967666079246999739025509736981974513806323327310792803025425887225709131040982032655852614954462201163281866373391986529297423769475808932761815084406478437505702622886684757604851321223369645403523, 2106627935969595192346547532826785693137550986881644620151591876604924400968054257202503939828719670691010195230040623508958805939124333252638478626690690754041019888884459962321161869077680401454040965, 3408595602048842192085573042563767667651357310208955412954617302492150110099095239235159792443674132892173477096414015495488103362893809061571240441775097232478525591507346647078766720398903771099444488, 5515223538018437384432120575390553360788908297090600033106209179097074511067149496437663732272393803583183672326454639004446909302018142314209719068465787986519545480391806609399928589476584172553485453, 8923819140067279576517693617954321028440265607299555446060826481589224621166244735672823524716067936475357149422868654499935012664911951375780959510240885218998071071899153256478695309875487943652929941, 14439042678085716960949814193344874389229173904390155479167035660686299132233394232110487256988461740058540821749323293504381921966930093689990678578706673205517616552290959865878623899352072116206415394, 23362861818152996537467507811299195417669439511689710925227862142275523753399638967783310781704529676533897971172191948004316934631842045065771638088947558424515687624190113122357319209227560059859345335, 37801904496238713498417322004644069806898613416079866404394897802961822885633033199893798038692991416592438792921515241508698856598772138755762316667654231630033304176481072988235943108579632176065760729, 61164766314391710035884829815943265224568052927769577329622759945237346639032672167677108820397521093126336764093707189513015791230614183821533954756601790054548991800671186110593262317807192235925106064, 98966670810630423534302151820587335031466666343849443734017657748199169524665705367570906859090512509718775557015222431021714647829386322577296271424256021684582295977152259098829205426386824411990866793, 160131437125022133570186981636530600256034719271619021063640417693436516163698377535248015679488033602845112321108929620534730439060000506398830226180857811739131287777823445209422467744194016647915972857, 259098107935652557104489133457117935287501385615468464797658075441635685688364082902818922538578546112563887878124152051556445086889386828976126497605113833423713583754975704308251673170580841059906839650, 419229545060674690674676115093648535543536104887087485861298493135072201852062460438066938218066579715409000199233081672091175525949387335374956723785971645162844871532799149517674140914774857707822812507, 678327652996327247779165248550766470831037490502555950658956568576707887540426543340885860756645125827972888077357233723647620612838774164351083221391085478586558455287774853825925814085355698767729652157, 1097557198057001938453841363644415006374573595389643436520255061711780089392489003778952798974711705543381888276590315395738796138788161499726039945177057123749403326820574003343599955000130556475552464664, 1775884851053329186233006612195181477205611085892199387179211630288487976932915547119838659731356831371354776353947549119386416751626935664077123166568142602335961782108348857169525769085486255243282116821, 2873442049110331124686847975839596483580184681281842823699466692000268066325404550898791458706068536914736664630537864515125212890415097163803163111745199726085365108928922860513125724085616811718834581485, 4649326900163660310919854588034777960785795767174042210878678322288756043258320098018630118437425368286091440984485413634511629642042032827880286278313342328421326891037271717682651493171103066962116698306, 7522768949273991435606702563874374444365980448455885034578145014289024109583724648917421577143493905200828105615023278149636842532457129991683449390058542054506691999966194578195777217256719878680951279791, 12172095849437651746526557151909152405151776215629927245456823336577780152842044746936051695580919273486919546599508691784148472174499162819563735668371884382928018891003466295878428710427822945643067978097, 19694864798711643182133259715783526849517756664085812280034968350866804262425769395853473272724413178687747652214531969933785314706956292811247185058430426437434710890969660874074205927684542824324019257888, 31866960648149294928659816867692679254669532879715739525491791687444584415267814142789524968305332452174667198814040661717933786881455455630810920726802310820362729781973127169952634638112365769967087235985, 51561825446860938110793076583476206104187289543801551805526760038311388677693583538642998241029745630862414851028572631651719101588411748442058105785232737257797440672942788044026840565796908594291106493873, 83428786095010233039452893451168885358856822423517291331018551725755973092961397681432523209335078083037082049842613293369652888469867204072869026512035048078160170454915915213979475203909274364258193729858, 134990611541871171150245970034645091463044111967318843136545311764067361770654981220075521450364823713899496900871185925021371990058278952514927132297267785335957611127858703258006315769706182958549300223731, 218419397636881404189698863485813976821900934390836134467563863489823334863616378901508044659699901796936578950713799218391024878528146156587796158809302833414117781582774618471985790973615457322807493953589, 353410009178752575339944833520459068284945046358154977604109175253890696634271360121583566110064725510836075851584985143412396868586425109102723291106570618750075392710633321729992106743321640281356794177320, 571829406815633979529643697006273045106845980748991112071673038743714031497887739023091610769764627307772654802298784361803421747114571265690519449915873452164193174293407940201977897716937097604164288130909, 925239415994386554869588530526732113391791027107146089675782213997604728132159099144675176879829352818608730653883769505215818615700996374793242741022444070914268567004041261931970004460258737885521082308229, 1497068822810020534399232227533005158498637007856137201747455252741318759630046838167766787649593980126381385456182553867019240362815567640483762190938317523078461741297449202133947902177195835489685370439138, 2422308238804407089268820758059737271890428034963283291423237466738923487762205937312441964529423332944990116110066323372235058978516564015277004931960761593992730308301490464065917906637454573375206452747367, 3919377061614427623668052985592742430389065042819420493170692719480242247392252775480208752179017313071371501566248877239254299341332131655760767122899079117071192049598939666199865808814650408864891823186505, 6341685300418834712936873743652479702279493077782703784593930186219165735154458712792650716708440646016361617676315200611489358319848695671037772054859840711063922357900430130265783715452104982240098275933872, 10261062362033262336604926729245222132668558120602124277764622905699407982546711488272859468887457959087733119242564077850743657661180827326798539177758919828135114407499369796465649524266755391104990099120377, 16602747662452097049541800472897701834948051198384828062358553091918573717701170201065510185595898605104094736918879278462233015981029522997836311232618760539199036765399799926731433239718860373345088375054249, 26863810024485359386146727202142923967616609318986952340123175997617981700247881689338369654483356564191827856161443356312976673642210350324634850410377680367334151172899169723197082763985615764450078474174626]\n    assert candidate(8) == [0, 1, 1, 2, 3, 5, 8, 13]\n    assert candidate(40) == [0, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, 144, 233, 377, 610, 987, 1597, 2584, 4181, 6765, 10946, 17711, 28657, 46368, 75025, 121393, 196418, 317811, 514229, 832040, 1346269, 2178309, 3524578, 5702887, 9227465, 14930352, 24157817, 39088169, 63245986]\n    assert candidate(2) == [0, 1]\n    assert candidate(20) == [0, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, 144, 233, 377, 610, 987, 1597, 2584, 4181]\n    assert candidate(15) == [0, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, 144, 233, 377]\n", "language": "python"}
{"task_id": "a548a4ea-458f-465a-b996-ace9c8081ef3-6125913340568953867", "prompt": "Using the doc string as your guide, complete the function. Submit your implementation as one unified code block. Include comprehensive edge case handling in your solution.\n\n```python\nfrom typing import List, Tuple\nfrom collections import deque\n\ndef find_safe_path(grid: List[List[int]]) -> List[Tuple[int, int]]:\n    \"\"\"In a treacherous mountain range, you need to find a safe path from the bottom-left corner to the top-right corner\n    of a grid. Each cell in the grid represents an altitude, and you can only move to adjacent cells (up, down, left, right)\n    if the absolute difference in altitude is not more than 1 unit. Your task is to find a safe path, if one exists.\n\n    Parameters:\n    grid (List[List[int]]): A 2D list of integers representing the altitude of each cell in the mountain range.\n\n    Returns:\n    List[Tuple[int, int]]: A list of (row, column) coordinates representing the safe path from bottom-left to top-right.\n                           If no safe path exists, return an empty list.\n\n\n    [EXAMPLES]\n    \n    assert candidate([[1, 2, 3, 4], [2, 3, 4, 5], [3, 4, 5, 6]]) == [(2, 0), (2, 1), (2, 2), (2, 3), (1, 3), (0, 3)]\n    assert candidate([[0, 0, 0], [1, 1, 1], [2, 2, 2], [3, 3, 3], [4, 4, 4]]) == [(4, 0), (4, 1), (4, 2), (3, 2), (2, 2), (1, 2), (0, 2)]\n\n    [/EXAMPLES]\n    \"\"\"\n```\n", "entry_point": "find_safe_path", "solution": "from typing import List, Tuple\nfrom collections import deque\n\ndef find_safe_path(grid: List[List[int]]) -> List[Tuple[int, int]]:\n    \"\"\"In a treacherous mountain range, you need to find a safe path from the bottom-left corner to the top-right corner\n    of a grid. Each cell in the grid represents an altitude, and you can only move to adjacent cells (up, down, left, right)\n    if the absolute difference in altitude is not more than 1 unit. Your task is to find a safe path, if one exists.\n\n    Parameters:\n    grid (List[List[int]]): A 2D list of integers representing the altitude of each cell in the mountain range.\n\n    Returns:\n    List[Tuple[int, int]]: A list of (row, column) coordinates representing the safe path from bottom-left to top-right.\n                           If no safe path exists, return an empty list.\n\n\n    [EXAMPLES]\n    \n    assert candidate([[1, 2, 3, 4], [2, 3, 4, 5], [3, 4, 5, 6]]) == [(2, 0), (2, 1), (2, 2), (2, 3), (1, 3), (0, 3)]\n    assert candidate([[0, 0, 0], [1, 1, 1], [2, 2, 2], [3, 3, 3], [4, 4, 4]]) == [(4, 0), (4, 1), (4, 2), (3, 2), (2, 2), (1, 2), (0, 2)]\n\n    [/EXAMPLES]\n    \"\"\"\n    if not grid or not grid[0]:\n        return []\n\n    rows, cols = len(grid), len(grid[0])\n    start = (rows - 1, 0)\n    end = (0, cols - 1)\n\n    def get_neighbors(row, col):\n        directions = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n        for dr, dc in directions:\n            new_row, new_col = row + dr, col + dc\n            if 0 <= new_row < rows and 0 <= new_col < cols:\n                if abs(grid[new_row][new_col] - grid[row][col]) <= 1:\n                    yield new_row, new_col\n\n    queue = deque([(start, [start])])\n    visited = set([start])\n\n    while queue:\n        (row, col), path = queue.popleft()\n\n        if (row, col) == end:\n            return path\n\n        for next_row, next_col in get_neighbors(row, col):\n            if (next_row, next_col) not in visited:\n                visited.add((next_row, next_col))\n                new_path = path + [(next_row, next_col)]\n                queue.append(((next_row, next_col), new_path))\n\n    return []\n\n", "test": "def check(candidate):\n    assert candidate([[1, 2, 3], [3, 2, 1], [1, 2, 3]]) == [(2, 0), (2, 1), (1, 1), (0, 1), (0, 2)]\n    assert candidate([[1, 2, 3, 4], [4, 3, 2, 1], [1, 2, 3, 4], [4, 3, 2, 1]]) == [(3, 0), (3, 1), (3, 2), (2, 2), (1, 2), (0, 2), (0, 3)]\n    assert candidate([[1, 2, 3, 4], [5, 6, 7, 8], [9, 10, 11, 12]]) == []\n    assert candidate([[1, 2, 1], [2, 1, 2], [1, 2, 1]]) == [(2, 0), (2, 1), (2, 2), (1, 2), (0, 2)]\n    assert candidate([[1, 2, 3, 4], [2, 3, 4, 5], [3, 4, 5, 6]]) == [(2, 0), (2, 1), (2, 2), (2, 3), (1, 3), (0, 3)]\n    assert candidate([[1, 1, 1], [1, 1, 1], [1, 1, 1]]) == [(2, 0), (2, 1), (2, 2), (1, 2), (0, 2)]\n    assert candidate([[1, 2, 3], [2, 3, 4], [3, 4, 5], [4, 5, 6]]) == [(3, 0), (3, 1), (3, 2), (2, 2), (1, 2), (0, 2)]\n    assert candidate([[0, 0, 0], [1, 1, 1], [2, 2, 2], [3, 3, 3], [4, 4, 4]]) == [(4, 0), (4, 1), (4, 2), (3, 2), (2, 2), (1, 2), (0, 2)]\n    assert candidate([[1, 2, 3, 4, 5], [5, 4, 3, 2, 1], [1, 2, 3, 4, 5], [5, 4, 3, 2, 1]]) == [(3, 0), (3, 1), (3, 2), (2, 2), (1, 2), (0, 2), (0, 3), (0, 4)]\n    assert candidate([[1, 2], [3, 4]]) == []\n", "language": "python"}
{"task_id": "f9138a15-9175-4629-90e0-bfafc16f41486570395088594622828", "prompt": "I'll complete the specified function in a single executable code block. My response will contain only the implementation of the requested function, with any necessary helper functions or classes defined within it. I'll use exclusively the libraries mentioned in the problem statement. The code will be presented in one cohesive block, ready for execution without modification.\n\n```python\nfrom typing import List\n\ndef generate_fibonacci_sequence(n: int) -> List[int]:\n    \"\"\"\n    As a mathematician studying number sequences, you want to generate the Fibonacci sequence up to a\n    specified number of terms.\n\n    This function takes an integer n as input and returns a list containing the first n terms of the\n    Fibonacci sequence.\n\n\n    [EXAMPLES]\n    \n    assert candidate(3) == [0, 1, 1]\n    assert candidate(250) == [0, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, 144, 233, 377, 610, 987, 1597, 2584, 4181, 6765, 10946, 17711, 28657, 46368, 75025, 121393, 196418, 317811, 514229, 832040, 1346269, 2178309, 3524578, 5702887, 9227465, 14930352, 24157817, 39088169, 63245986, 102334155, 165580141, 267914296, 433494437, 701408733, 1134903170, 1836311903, 2971215073, 4807526976, 7778742049, 12586269025, 20365011074, 32951280099, 53316291173, 86267571272, 139583862445, 225851433717, 365435296162, 591286729879, 956722026041, 1548008755920, 2504730781961, 4052739537881, 6557470319842, 10610209857723, 17167680177565, 27777890035288, 44945570212853, 72723460248141, 117669030460994, 190392490709135, 308061521170129, 498454011879264, 806515533049393, 1304969544928657, 2111485077978050, 3416454622906707, 5527939700884757, 8944394323791464, 14472334024676221, 23416728348467685, 37889062373143906, 61305790721611591, 99194853094755497, 160500643816367088, 259695496911122585, 420196140727489673, 679891637638612258, 1100087778366101931, 1779979416004714189, 2880067194370816120, 4660046610375530309, 7540113804746346429, 12200160415121876738, 19740274219868223167, 31940434634990099905, 51680708854858323072, 83621143489848422977, 135301852344706746049, 218922995834555169026, 354224848179261915075, 573147844013817084101, 927372692193078999176, 1500520536206896083277, 2427893228399975082453, 3928413764606871165730, 6356306993006846248183, 10284720757613717413913, 16641027750620563662096, 26925748508234281076009, 43566776258854844738105, 70492524767089125814114, 114059301025943970552219, 184551825793033096366333, 298611126818977066918552, 483162952612010163284885, 781774079430987230203437, 1264937032042997393488322, 2046711111473984623691759, 3311648143516982017180081, 5358359254990966640871840, 8670007398507948658051921, 14028366653498915298923761, 22698374052006863956975682, 36726740705505779255899443, 59425114757512643212875125, 96151855463018422468774568, 155576970220531065681649693, 251728825683549488150424261, 407305795904080553832073954, 659034621587630041982498215, 1066340417491710595814572169, 1725375039079340637797070384, 2791715456571051233611642553, 4517090495650391871408712937, 7308805952221443105020355490, 11825896447871834976429068427, 19134702400093278081449423917, 30960598847965113057878492344, 50095301248058391139327916261, 81055900096023504197206408605, 131151201344081895336534324866, 212207101440105399533740733471, 343358302784187294870275058337, 555565404224292694404015791808, 898923707008479989274290850145, 1454489111232772683678306641953, 2353412818241252672952597492098, 3807901929474025356630904134051, 6161314747715278029583501626149, 9969216677189303386214405760200, 16130531424904581415797907386349, 26099748102093884802012313146549, 42230279526998466217810220532898, 68330027629092351019822533679447, 110560307156090817237632754212345, 178890334785183168257455287891792, 289450641941273985495088042104137, 468340976726457153752543329995929, 757791618667731139247631372100066, 1226132595394188293000174702095995, 1983924214061919432247806074196061, 3210056809456107725247980776292056, 5193981023518027157495786850488117, 8404037832974134882743767626780173, 13598018856492162040239554477268290, 22002056689466296922983322104048463, 35600075545958458963222876581316753, 57602132235424755886206198685365216, 93202207781383214849429075266681969, 150804340016807970735635273952047185, 244006547798191185585064349218729154, 394810887814999156320699623170776339, 638817435613190341905763972389505493, 1033628323428189498226463595560281832, 1672445759041379840132227567949787325, 2706074082469569338358691163510069157, 4378519841510949178490918731459856482, 7084593923980518516849609894969925639, 11463113765491467695340528626429782121, 18547707689471986212190138521399707760, 30010821454963453907530667147829489881, 48558529144435440119720805669229197641, 78569350599398894027251472817058687522, 127127879743834334146972278486287885163, 205697230343233228174223751303346572685, 332825110087067562321196029789634457848, 538522340430300790495419781092981030533, 871347450517368352816615810882615488381, 1409869790947669143312035591975596518914, 2281217241465037496128651402858212007295, 3691087032412706639440686994833808526209, 5972304273877744135569338397692020533504, 9663391306290450775010025392525829059713, 15635695580168194910579363790217849593217, 25299086886458645685589389182743678652930, 40934782466626840596168752972961528246147, 66233869353085486281758142155705206899077, 107168651819712326877926895128666735145224, 173402521172797813159685037284371942044301, 280571172992510140037611932413038677189525, 453973694165307953197296969697410619233826, 734544867157818093234908902110449296423351, 1188518561323126046432205871807859915657177, 1923063428480944139667114773918309212080528, 3111581989804070186099320645726169127737705, 5034645418285014325766435419644478339818233, 8146227408089084511865756065370647467555938, 13180872826374098837632191485015125807374171, 21327100234463183349497947550385773274930109, 34507973060837282187130139035400899082304280, 55835073295300465536628086585786672357234389, 90343046356137747723758225621187571439538669, 146178119651438213260386312206974243796773058, 236521166007575960984144537828161815236311727, 382699285659014174244530850035136059033084785, 619220451666590135228675387863297874269396512, 1001919737325604309473206237898433933302481297, 1621140188992194444701881625761731807571877809, 2623059926317798754175087863660165740874359106, 4244200115309993198876969489421897548446236915, 6867260041627791953052057353082063289320596021, 11111460156937785151929026842503960837766832936, 17978720198565577104981084195586024127087428957, 29090180355503362256910111038089984964854261893, 47068900554068939361891195233676009091941690850, 76159080909572301618801306271765994056795952743, 123227981463641240980692501505442003148737643593, 199387062373213542599493807777207997205533596336, 322615043836854783580186309282650000354271239929, 522002106210068326179680117059857997559804836265, 844617150046923109759866426342507997914076076194, 1366619256256991435939546543402365995473880912459, 2211236406303914545699412969744873993387956988653, 3577855662560905981638959513147239988861837901112, 5789092068864820527338372482892113982249794889765, 9366947731425726508977331996039353971111632790877, 15156039800290547036315704478931467953361427680642, 24522987531716273545293036474970821924473060471519, 39679027332006820581608740953902289877834488152161, 64202014863723094126901777428873111802307548623680, 103881042195729914708510518382775401680142036775841, 168083057059453008835412295811648513482449585399521, 271964099255182923543922814194423915162591622175362, 440047156314635932379335110006072428645041207574883, 712011255569818855923257924200496343807632829750245, 1152058411884454788302593034206568772452674037325128, 1864069667454273644225850958407065116260306867075373, 3016128079338728432528443992613633888712980904400501, 4880197746793002076754294951020699004973287771475874]\n\n    [/EXAMPLES]\n    \"\"\"\n```\n", "entry_point": "generate_fibonacci_sequence", "solution": "from typing import List\n\ndef generate_fibonacci_sequence(n: int) -> List[int]:\n    \"\"\"\n    As a mathematician studying number sequences, you want to generate the Fibonacci sequence up to a\n    specified number of terms.\n\n    This function takes an integer n as input and returns a list containing the first n terms of the\n    Fibonacci sequence.\n\n\n    [EXAMPLES]\n    \n    assert candidate(3) == [0, 1, 1]\n    assert candidate(250) == [0, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, 144, 233, 377, 610, 987, 1597, 2584, 4181, 6765, 10946, 17711, 28657, 46368, 75025, 121393, 196418, 317811, 514229, 832040, 1346269, 2178309, 3524578, 5702887, 9227465, 14930352, 24157817, 39088169, 63245986, 102334155, 165580141, 267914296, 433494437, 701408733, 1134903170, 1836311903, 2971215073, 4807526976, 7778742049, 12586269025, 20365011074, 32951280099, 53316291173, 86267571272, 139583862445, 225851433717, 365435296162, 591286729879, 956722026041, 1548008755920, 2504730781961, 4052739537881, 6557470319842, 10610209857723, 17167680177565, 27777890035288, 44945570212853, 72723460248141, 117669030460994, 190392490709135, 308061521170129, 498454011879264, 806515533049393, 1304969544928657, 2111485077978050, 3416454622906707, 5527939700884757, 8944394323791464, 14472334024676221, 23416728348467685, 37889062373143906, 61305790721611591, 99194853094755497, 160500643816367088, 259695496911122585, 420196140727489673, 679891637638612258, 1100087778366101931, 1779979416004714189, 2880067194370816120, 4660046610375530309, 7540113804746346429, 12200160415121876738, 19740274219868223167, 31940434634990099905, 51680708854858323072, 83621143489848422977, 135301852344706746049, 218922995834555169026, 354224848179261915075, 573147844013817084101, 927372692193078999176, 1500520536206896083277, 2427893228399975082453, 3928413764606871165730, 6356306993006846248183, 10284720757613717413913, 16641027750620563662096, 26925748508234281076009, 43566776258854844738105, 70492524767089125814114, 114059301025943970552219, 184551825793033096366333, 298611126818977066918552, 483162952612010163284885, 781774079430987230203437, 1264937032042997393488322, 2046711111473984623691759, 3311648143516982017180081, 5358359254990966640871840, 8670007398507948658051921, 14028366653498915298923761, 22698374052006863956975682, 36726740705505779255899443, 59425114757512643212875125, 96151855463018422468774568, 155576970220531065681649693, 251728825683549488150424261, 407305795904080553832073954, 659034621587630041982498215, 1066340417491710595814572169, 1725375039079340637797070384, 2791715456571051233611642553, 4517090495650391871408712937, 7308805952221443105020355490, 11825896447871834976429068427, 19134702400093278081449423917, 30960598847965113057878492344, 50095301248058391139327916261, 81055900096023504197206408605, 131151201344081895336534324866, 212207101440105399533740733471, 343358302784187294870275058337, 555565404224292694404015791808, 898923707008479989274290850145, 1454489111232772683678306641953, 2353412818241252672952597492098, 3807901929474025356630904134051, 6161314747715278029583501626149, 9969216677189303386214405760200, 16130531424904581415797907386349, 26099748102093884802012313146549, 42230279526998466217810220532898, 68330027629092351019822533679447, 110560307156090817237632754212345, 178890334785183168257455287891792, 289450641941273985495088042104137, 468340976726457153752543329995929, 757791618667731139247631372100066, 1226132595394188293000174702095995, 1983924214061919432247806074196061, 3210056809456107725247980776292056, 5193981023518027157495786850488117, 8404037832974134882743767626780173, 13598018856492162040239554477268290, 22002056689466296922983322104048463, 35600075545958458963222876581316753, 57602132235424755886206198685365216, 93202207781383214849429075266681969, 150804340016807970735635273952047185, 244006547798191185585064349218729154, 394810887814999156320699623170776339, 638817435613190341905763972389505493, 1033628323428189498226463595560281832, 1672445759041379840132227567949787325, 2706074082469569338358691163510069157, 4378519841510949178490918731459856482, 7084593923980518516849609894969925639, 11463113765491467695340528626429782121, 18547707689471986212190138521399707760, 30010821454963453907530667147829489881, 48558529144435440119720805669229197641, 78569350599398894027251472817058687522, 127127879743834334146972278486287885163, 205697230343233228174223751303346572685, 332825110087067562321196029789634457848, 538522340430300790495419781092981030533, 871347450517368352816615810882615488381, 1409869790947669143312035591975596518914, 2281217241465037496128651402858212007295, 3691087032412706639440686994833808526209, 5972304273877744135569338397692020533504, 9663391306290450775010025392525829059713, 15635695580168194910579363790217849593217, 25299086886458645685589389182743678652930, 40934782466626840596168752972961528246147, 66233869353085486281758142155705206899077, 107168651819712326877926895128666735145224, 173402521172797813159685037284371942044301, 280571172992510140037611932413038677189525, 453973694165307953197296969697410619233826, 734544867157818093234908902110449296423351, 1188518561323126046432205871807859915657177, 1923063428480944139667114773918309212080528, 3111581989804070186099320645726169127737705, 5034645418285014325766435419644478339818233, 8146227408089084511865756065370647467555938, 13180872826374098837632191485015125807374171, 21327100234463183349497947550385773274930109, 34507973060837282187130139035400899082304280, 55835073295300465536628086585786672357234389, 90343046356137747723758225621187571439538669, 146178119651438213260386312206974243796773058, 236521166007575960984144537828161815236311727, 382699285659014174244530850035136059033084785, 619220451666590135228675387863297874269396512, 1001919737325604309473206237898433933302481297, 1621140188992194444701881625761731807571877809, 2623059926317798754175087863660165740874359106, 4244200115309993198876969489421897548446236915, 6867260041627791953052057353082063289320596021, 11111460156937785151929026842503960837766832936, 17978720198565577104981084195586024127087428957, 29090180355503362256910111038089984964854261893, 47068900554068939361891195233676009091941690850, 76159080909572301618801306271765994056795952743, 123227981463641240980692501505442003148737643593, 199387062373213542599493807777207997205533596336, 322615043836854783580186309282650000354271239929, 522002106210068326179680117059857997559804836265, 844617150046923109759866426342507997914076076194, 1366619256256991435939546543402365995473880912459, 2211236406303914545699412969744873993387956988653, 3577855662560905981638959513147239988861837901112, 5789092068864820527338372482892113982249794889765, 9366947731425726508977331996039353971111632790877, 15156039800290547036315704478931467953361427680642, 24522987531716273545293036474970821924473060471519, 39679027332006820581608740953902289877834488152161, 64202014863723094126901777428873111802307548623680, 103881042195729914708510518382775401680142036775841, 168083057059453008835412295811648513482449585399521, 271964099255182923543922814194423915162591622175362, 440047156314635932379335110006072428645041207574883, 712011255569818855923257924200496343807632829750245, 1152058411884454788302593034206568772452674037325128, 1864069667454273644225850958407065116260306867075373, 3016128079338728432528443992613633888712980904400501, 4880197746793002076754294951020699004973287771475874]\n\n    [/EXAMPLES]\n    \"\"\"\n    if n <= 0:\n        return []\n    elif n == 1:\n        return [0]\n    elif n == 2:\n        return [0, 1]\n    \n    fibonacci = [0, 1]\n    for _ in range(2, n):\n        next_num = fibonacci[-1] + fibonacci[-2]\n        fibonacci.append(next_num)\n    \n    return fibonacci\n\n", "test": "def check(candidate):\n    assert candidate(15) == [0, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, 144, 233, 377]\n    assert candidate(200) == [0, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, 144, 233, 377, 610, 987, 1597, 2584, 4181, 6765, 10946, 17711, 28657, 46368, 75025, 121393, 196418, 317811, 514229, 832040, 1346269, 2178309, 3524578, 5702887, 9227465, 14930352, 24157817, 39088169, 63245986, 102334155, 165580141, 267914296, 433494437, 701408733, 1134903170, 1836311903, 2971215073, 4807526976, 7778742049, 12586269025, 20365011074, 32951280099, 53316291173, 86267571272, 139583862445, 225851433717, 365435296162, 591286729879, 956722026041, 1548008755920, 2504730781961, 4052739537881, 6557470319842, 10610209857723, 17167680177565, 27777890035288, 44945570212853, 72723460248141, 117669030460994, 190392490709135, 308061521170129, 498454011879264, 806515533049393, 1304969544928657, 2111485077978050, 3416454622906707, 5527939700884757, 8944394323791464, 14472334024676221, 23416728348467685, 37889062373143906, 61305790721611591, 99194853094755497, 160500643816367088, 259695496911122585, 420196140727489673, 679891637638612258, 1100087778366101931, 1779979416004714189, 2880067194370816120, 4660046610375530309, 7540113804746346429, 12200160415121876738, 19740274219868223167, 31940434634990099905, 51680708854858323072, 83621143489848422977, 135301852344706746049, 218922995834555169026, 354224848179261915075, 573147844013817084101, 927372692193078999176, 1500520536206896083277, 2427893228399975082453, 3928413764606871165730, 6356306993006846248183, 10284720757613717413913, 16641027750620563662096, 26925748508234281076009, 43566776258854844738105, 70492524767089125814114, 114059301025943970552219, 184551825793033096366333, 298611126818977066918552, 483162952612010163284885, 781774079430987230203437, 1264937032042997393488322, 2046711111473984623691759, 3311648143516982017180081, 5358359254990966640871840, 8670007398507948658051921, 14028366653498915298923761, 22698374052006863956975682, 36726740705505779255899443, 59425114757512643212875125, 96151855463018422468774568, 155576970220531065681649693, 251728825683549488150424261, 407305795904080553832073954, 659034621587630041982498215, 1066340417491710595814572169, 1725375039079340637797070384, 2791715456571051233611642553, 4517090495650391871408712937, 7308805952221443105020355490, 11825896447871834976429068427, 19134702400093278081449423917, 30960598847965113057878492344, 50095301248058391139327916261, 81055900096023504197206408605, 131151201344081895336534324866, 212207101440105399533740733471, 343358302784187294870275058337, 555565404224292694404015791808, 898923707008479989274290850145, 1454489111232772683678306641953, 2353412818241252672952597492098, 3807901929474025356630904134051, 6161314747715278029583501626149, 9969216677189303386214405760200, 16130531424904581415797907386349, 26099748102093884802012313146549, 42230279526998466217810220532898, 68330027629092351019822533679447, 110560307156090817237632754212345, 178890334785183168257455287891792, 289450641941273985495088042104137, 468340976726457153752543329995929, 757791618667731139247631372100066, 1226132595394188293000174702095995, 1983924214061919432247806074196061, 3210056809456107725247980776292056, 5193981023518027157495786850488117, 8404037832974134882743767626780173, 13598018856492162040239554477268290, 22002056689466296922983322104048463, 35600075545958458963222876581316753, 57602132235424755886206198685365216, 93202207781383214849429075266681969, 150804340016807970735635273952047185, 244006547798191185585064349218729154, 394810887814999156320699623170776339, 638817435613190341905763972389505493, 1033628323428189498226463595560281832, 1672445759041379840132227567949787325, 2706074082469569338358691163510069157, 4378519841510949178490918731459856482, 7084593923980518516849609894969925639, 11463113765491467695340528626429782121, 18547707689471986212190138521399707760, 30010821454963453907530667147829489881, 48558529144435440119720805669229197641, 78569350599398894027251472817058687522, 127127879743834334146972278486287885163, 205697230343233228174223751303346572685, 332825110087067562321196029789634457848, 538522340430300790495419781092981030533, 871347450517368352816615810882615488381, 1409869790947669143312035591975596518914, 2281217241465037496128651402858212007295, 3691087032412706639440686994833808526209, 5972304273877744135569338397692020533504, 9663391306290450775010025392525829059713, 15635695580168194910579363790217849593217, 25299086886458645685589389182743678652930, 40934782466626840596168752972961528246147, 66233869353085486281758142155705206899077, 107168651819712326877926895128666735145224, 173402521172797813159685037284371942044301]\n    assert candidate(40) == [0, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, 144, 233, 377, 610, 987, 1597, 2584, 4181, 6765, 10946, 17711, 28657, 46368, 75025, 121393, 196418, 317811, 514229, 832040, 1346269, 2178309, 3524578, 5702887, 9227465, 14930352, 24157817, 39088169, 63245986]\n    assert candidate(45) == [0, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, 144, 233, 377, 610, 987, 1597, 2584, 4181, 6765, 10946, 17711, 28657, 46368, 75025, 121393, 196418, 317811, 514229, 832040, 1346269, 2178309, 3524578, 5702887, 9227465, 14930352, 24157817, 39088169, 63245986, 102334155, 165580141, 267914296, 433494437, 701408733]\n    assert candidate(50) == [0, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, 144, 233, 377, 610, 987, 1597, 2584, 4181, 6765, 10946, 17711, 28657, 46368, 75025, 121393, 196418, 317811, 514229, 832040, 1346269, 2178309, 3524578, 5702887, 9227465, 14930352, 24157817, 39088169, 63245986, 102334155, 165580141, 267914296, 433494437, 701408733, 1134903170, 1836311903, 2971215073, 4807526976, 7778742049]\n    assert candidate(8) == [0, 1, 1, 2, 3, 5, 8, 13]\n    assert candidate(0) == []\n    assert candidate(3) == [0, 1, 1]\n    assert candidate(10) == [0, 1, 1, 2, 3, 5, 8, 13, 21, 34]\n    assert candidate(250) == [0, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, 144, 233, 377, 610, 987, 1597, 2584, 4181, 6765, 10946, 17711, 28657, 46368, 75025, 121393, 196418, 317811, 514229, 832040, 1346269, 2178309, 3524578, 5702887, 9227465, 14930352, 24157817, 39088169, 63245986, 102334155, 165580141, 267914296, 433494437, 701408733, 1134903170, 1836311903, 2971215073, 4807526976, 7778742049, 12586269025, 20365011074, 32951280099, 53316291173, 86267571272, 139583862445, 225851433717, 365435296162, 591286729879, 956722026041, 1548008755920, 2504730781961, 4052739537881, 6557470319842, 10610209857723, 17167680177565, 27777890035288, 44945570212853, 72723460248141, 117669030460994, 190392490709135, 308061521170129, 498454011879264, 806515533049393, 1304969544928657, 2111485077978050, 3416454622906707, 5527939700884757, 8944394323791464, 14472334024676221, 23416728348467685, 37889062373143906, 61305790721611591, 99194853094755497, 160500643816367088, 259695496911122585, 420196140727489673, 679891637638612258, 1100087778366101931, 1779979416004714189, 2880067194370816120, 4660046610375530309, 7540113804746346429, 12200160415121876738, 19740274219868223167, 31940434634990099905, 51680708854858323072, 83621143489848422977, 135301852344706746049, 218922995834555169026, 354224848179261915075, 573147844013817084101, 927372692193078999176, 1500520536206896083277, 2427893228399975082453, 3928413764606871165730, 6356306993006846248183, 10284720757613717413913, 16641027750620563662096, 26925748508234281076009, 43566776258854844738105, 70492524767089125814114, 114059301025943970552219, 184551825793033096366333, 298611126818977066918552, 483162952612010163284885, 781774079430987230203437, 1264937032042997393488322, 2046711111473984623691759, 3311648143516982017180081, 5358359254990966640871840, 8670007398507948658051921, 14028366653498915298923761, 22698374052006863956975682, 36726740705505779255899443, 59425114757512643212875125, 96151855463018422468774568, 155576970220531065681649693, 251728825683549488150424261, 407305795904080553832073954, 659034621587630041982498215, 1066340417491710595814572169, 1725375039079340637797070384, 2791715456571051233611642553, 4517090495650391871408712937, 7308805952221443105020355490, 11825896447871834976429068427, 19134702400093278081449423917, 30960598847965113057878492344, 50095301248058391139327916261, 81055900096023504197206408605, 131151201344081895336534324866, 212207101440105399533740733471, 343358302784187294870275058337, 555565404224292694404015791808, 898923707008479989274290850145, 1454489111232772683678306641953, 2353412818241252672952597492098, 3807901929474025356630904134051, 6161314747715278029583501626149, 9969216677189303386214405760200, 16130531424904581415797907386349, 26099748102093884802012313146549, 42230279526998466217810220532898, 68330027629092351019822533679447, 110560307156090817237632754212345, 178890334785183168257455287891792, 289450641941273985495088042104137, 468340976726457153752543329995929, 757791618667731139247631372100066, 1226132595394188293000174702095995, 1983924214061919432247806074196061, 3210056809456107725247980776292056, 5193981023518027157495786850488117, 8404037832974134882743767626780173, 13598018856492162040239554477268290, 22002056689466296922983322104048463, 35600075545958458963222876581316753, 57602132235424755886206198685365216, 93202207781383214849429075266681969, 150804340016807970735635273952047185, 244006547798191185585064349218729154, 394810887814999156320699623170776339, 638817435613190341905763972389505493, 1033628323428189498226463595560281832, 1672445759041379840132227567949787325, 2706074082469569338358691163510069157, 4378519841510949178490918731459856482, 7084593923980518516849609894969925639, 11463113765491467695340528626429782121, 18547707689471986212190138521399707760, 30010821454963453907530667147829489881, 48558529144435440119720805669229197641, 78569350599398894027251472817058687522, 127127879743834334146972278486287885163, 205697230343233228174223751303346572685, 332825110087067562321196029789634457848, 538522340430300790495419781092981030533, 871347450517368352816615810882615488381, 1409869790947669143312035591975596518914, 2281217241465037496128651402858212007295, 3691087032412706639440686994833808526209, 5972304273877744135569338397692020533504, 9663391306290450775010025392525829059713, 15635695580168194910579363790217849593217, 25299086886458645685589389182743678652930, 40934782466626840596168752972961528246147, 66233869353085486281758142155705206899077, 107168651819712326877926895128666735145224, 173402521172797813159685037284371942044301, 280571172992510140037611932413038677189525, 453973694165307953197296969697410619233826, 734544867157818093234908902110449296423351, 1188518561323126046432205871807859915657177, 1923063428480944139667114773918309212080528, 3111581989804070186099320645726169127737705, 5034645418285014325766435419644478339818233, 8146227408089084511865756065370647467555938, 13180872826374098837632191485015125807374171, 21327100234463183349497947550385773274930109, 34507973060837282187130139035400899082304280, 55835073295300465536628086585786672357234389, 90343046356137747723758225621187571439538669, 146178119651438213260386312206974243796773058, 236521166007575960984144537828161815236311727, 382699285659014174244530850035136059033084785, 619220451666590135228675387863297874269396512, 1001919737325604309473206237898433933302481297, 1621140188992194444701881625761731807571877809, 2623059926317798754175087863660165740874359106, 4244200115309993198876969489421897548446236915, 6867260041627791953052057353082063289320596021, 11111460156937785151929026842503960837766832936, 17978720198565577104981084195586024127087428957, 29090180355503362256910111038089984964854261893, 47068900554068939361891195233676009091941690850, 76159080909572301618801306271765994056795952743, 123227981463641240980692501505442003148737643593, 199387062373213542599493807777207997205533596336, 322615043836854783580186309282650000354271239929, 522002106210068326179680117059857997559804836265, 844617150046923109759866426342507997914076076194, 1366619256256991435939546543402365995473880912459, 2211236406303914545699412969744873993387956988653, 3577855662560905981638959513147239988861837901112, 5789092068864820527338372482892113982249794889765, 9366947731425726508977331996039353971111632790877, 15156039800290547036315704478931467953361427680642, 24522987531716273545293036474970821924473060471519, 39679027332006820581608740953902289877834488152161, 64202014863723094126901777428873111802307548623680, 103881042195729914708510518382775401680142036775841, 168083057059453008835412295811648513482449585399521, 271964099255182923543922814194423915162591622175362, 440047156314635932379335110006072428645041207574883, 712011255569818855923257924200496343807632829750245, 1152058411884454788302593034206568772452674037325128, 1864069667454273644225850958407065116260306867075373, 3016128079338728432528443992613633888712980904400501, 4880197746793002076754294951020699004973287771475874]\n", "language": "python"}
{"task_id": "b8675b36-e868-40c8-9f6a-67825c8908c8-7898420433155209890", "prompt": "I'll write the complete function implementation according to the documentation string. The code will be presented in a single block with careful consideration of edge cases.\n\n```python\ndef parse_molecule(formula: str) -> dict:\n    \"\"\"\n    Parse a chemical formula and return a dictionary of its constituents.\n\n    This function takes a string representing a chemical formula and\n    returns a dictionary where the keys are the elements and the values\n    are their respective counts in the molecule. The function handles\n    parentheses and numeric subscripts.\n\n\n    [EXAMPLES]\n    \n    assert candidate('Mg(HCO3)2') == {'H': 2, 'C': 2, 'O': 6, 'Mg': 1}\n    assert candidate('Mg(HCO3)2') == {'Mg': 1, 'H': 2, 'C': 2, 'O': 6}\n\n    [/EXAMPLES]\n    \"\"\"\n```\n", "entry_point": "parse_molecule", "solution": "def parse_molecule(formula: str) -> dict:\n    \"\"\"\n    Parse a chemical formula and return a dictionary of its constituents.\n\n    This function takes a string representing a chemical formula and\n    returns a dictionary where the keys are the elements and the values\n    are their respective counts in the molecule. The function handles\n    parentheses and numeric subscripts.\n\n\n    [EXAMPLES]\n    \n    assert candidate('Mg(HCO3)2') == {'H': 2, 'C': 2, 'O': 6, 'Mg': 1}\n    assert candidate('Mg(HCO3)2') == {'Mg': 1, 'H': 2, 'C': 2, 'O': 6}\n\n    [/EXAMPLES]\n    \"\"\"\n    def parse_subformula(subformula):\n        result = {}\n        element = ''\n        count = ''\n        i = 0\n        while i < len(subformula):\n            char = subformula[i]\n            if char.isupper():\n                if element:\n                    result[element] = result.get(element, 0) + (int(count) if count else 1)\n                element = char\n                count = ''\n            elif char.islower():\n                element += char\n            elif char.isdigit():\n                count += char\n            elif char == '(':\n                nested_count = 1\n                j = i + 1\n                while nested_count > 0:\n                    if subformula[j] == '(':\n                        nested_count += 1\n                    elif subformula[j] == ')':\n                        nested_count -= 1\n                    j += 1\n                sub_result = parse_subformula(subformula[i+1:j-1])\n                sub_count = ''\n                while j < len(subformula) and subformula[j].isdigit():\n                    sub_count += subformula[j]\n                    j += 1\n                sub_count = int(sub_count) if sub_count else 1\n                for k, v in sub_result.items():\n                    result[k] = result.get(k, 0) + v * sub_count\n                i = j - 1\n            i += 1\n        if element:\n            result[element] = result.get(element, 0) + (int(count) if count else 1)\n        return result\n\n    return parse_subformula(formula)\n\n", "test": "def check(candidate):\n    assert candidate('Na2CO3\u00b710H2O') == {'Na': 2, 'C': 1, 'O': 311, 'H': 2}\n    assert candidate('Ca(OH)2') == {'O': 2, 'H': 2, 'Ca': 1}\n    assert candidate('H2SO4') == {'H': 2, 'S': 1, 'O': 4}\n    assert candidate('C12H22O11') == {'C': 12, 'H': 22, 'O': 11}\n    assert candidate('Mg(HCO3)2') == {'Mg': 1, 'H': 2, 'C': 2, 'O': 6}\n    assert candidate('Mg(HCO3)2') == {'H': 2, 'C': 2, 'O': 6, 'Mg': 1}\n    assert candidate('Al2(SO4)3') == {'Al': 2, 'S': 3, 'O': 12}\n    assert candidate('KMnO4') == {'K': 1, 'Mn': 1, 'O': 4}\n    assert candidate('(C6H10O5)n') == {'C': 6, 'H': 10, 'O': 5, 'n': 1}\n    assert candidate('K4[Fe(CN)6]') == {'K': 4, 'C': 6, 'N': 6, 'Fe': 1}\n", "language": "python"}
{"task_id": "3836291c-347b-41c9-9cac-6e906c374333-7460361368632579545", "prompt": "Please complete the function as provided in the problem. The function should be fully executable within a single code block. Do not include any code outside the function. Only use libraries that are imported in the problem statement. If you need to define additional helper functions or classes, place them inside the given function. Your response should consist of exactly one code block.\n\n```python\nfrom typing import List\n\ndef analyze_stock_trends(prices: List[int]) -> int:\n    \"\"\"\n    A financial analyst wants to identify the longest streak of consecutive days where the stock price\n    was higher than the previous day.\n\n    This function takes a list of daily stock prices and returns the length of the longest streak\n    of consecutive price increases.\n\n    The implementation requires utilizing concepts of dynamic programming and sequence analysis.\n\n    :param prices: A list of integers representing daily stock prices\n    :return: The length of the longest streak of consecutive price increases\n\n\n    [EXAMPLES]\n    \n    assert candidate([1, 2, 3, 2, 3, 4, 5, 4, 5, 6]) == 4\n    assert candidate([50, 45, 40, 35, 30, 25, 20, 15, 10, 5]) == 1\n\n    [/EXAMPLES]\n    \"\"\"\n```\n", "entry_point": "analyze_stock_trends", "solution": "from typing import List\n\ndef analyze_stock_trends(prices: List[int]) -> int:\n    \"\"\"\n    A financial analyst wants to identify the longest streak of consecutive days where the stock price\n    was higher than the previous day.\n\n    This function takes a list of daily stock prices and returns the length of the longest streak\n    of consecutive price increases.\n\n    The implementation requires utilizing concepts of dynamic programming and sequence analysis.\n\n    :param prices: A list of integers representing daily stock prices\n    :return: The length of the longest streak of consecutive price increases\n\n\n    [EXAMPLES]\n    \n    assert candidate([1, 2, 3, 2, 3, 4, 5, 4, 5, 6]) == 4\n    assert candidate([50, 45, 40, 35, 30, 25, 20, 15, 10, 5]) == 1\n\n    [/EXAMPLES]\n    \"\"\"\n    if not prices:\n        return 0\n\n    n = len(prices)\n    dp = [1] * n  # Initialize dynamic programming array\n    max_streak = 1  # Initialize the maximum streak\n\n    for i in range(1, n):\n        if prices[i] > prices[i-1]:\n            dp[i] = dp[i-1] + 1\n            max_streak = max(max_streak, dp[i])\n\n    return max_streak\n\n", "test": "def check(candidate):\n    assert candidate([1, 3, 5, 7, 9, 11, 13, 15]) == 8\n    assert candidate([100, 99, 98, 97, 96, 95, 94, 93, 92, 91]) == 1\n    assert candidate([1, 3, 2, 4, 5, 6]) == 4\n    assert candidate([1, 2, 1, 2, 1, 2, 1, 2, 1, 2]) == 2\n    assert candidate([1, 2, 3, 4, 5]) == 5\n    assert candidate([1, 2, 3, 4, 3, 2, 1, 2, 3, 4, 5]) == 5\n    assert candidate([50, 45, 40, 35, 30, 25, 20, 15, 10, 5]) == 1\n    assert candidate([5, 10, 15, 20, 25, 30, 35, 40, 45, 50]) == 10\n    assert candidate([]) == 0\n    assert candidate([1, 2, 3, 2, 3, 4, 5, 4, 5, 6]) == 4\n", "language": "python"}
{"task_id": "24b18d7a-2946-4c05-b179-cef2abcf4ea6-3817830287793924129", "prompt": "Provide a working implementation of the specified function that can run as a standalone code block. Ensure all code remains inside the function body. Restrict yourself to using only the libraries that are imported in the original problem. Define any supporting functions or classes within the scope of the main function.\n\n```python\nfrom typing import List\n\ndef earthquake_impact(magnitudes: List[float], population: List[int]) -> int:\n    \"\"\"\n    A seismologist is studying the potential impact of earthquakes on different cities.\n    Given a list of earthquake magnitudes and a list of city populations (in the same order),\n    calculate the total number of people potentially affected by earthquakes above magnitude 5.0.\n    Assume that an earthquake affects the entire population of a city if its magnitude is > 5.0.\n\n\n    [EXAMPLES]\n    \n    assert candidate([5.5, 5.5, 5.5, 5.5, 5.5], [1, 10, 100, 1000, 10000]) == 11111\n    assert candidate([5.1, 5.1, 5.1, 5.1, 5.1], [0, 0, 0, 0, 0]) == 0\n\n    [/EXAMPLES]\n    \"\"\"\n```\n", "entry_point": "earthquake_impact", "solution": "from typing import List\n\ndef earthquake_impact(magnitudes: List[float], population: List[int]) -> int:\n    \"\"\"\n    A seismologist is studying the potential impact of earthquakes on different cities.\n    Given a list of earthquake magnitudes and a list of city populations (in the same order),\n    calculate the total number of people potentially affected by earthquakes above magnitude 5.0.\n    Assume that an earthquake affects the entire population of a city if its magnitude is > 5.0.\n\n\n    [EXAMPLES]\n    \n    assert candidate([5.5, 5.5, 5.5, 5.5, 5.5], [1, 10, 100, 1000, 10000]) == 11111\n    assert candidate([5.1, 5.1, 5.1, 5.1, 5.1], [0, 0, 0, 0, 0]) == 0\n\n    [/EXAMPLES]\n    \"\"\"\n    def is_significant(magnitude: float) -> bool:\n        return magnitude > 5.0\n\n    affected_population = sum(\n        pop for mag, pop in zip(magnitudes, population) if is_significant(mag)\n    )\n\n    return affected_population\n\n", "test": "def check(candidate):\n    assert candidate([5.0], [1000000]) == 0\n    assert candidate([4.9, 4.9, 4.9, 4.9, 4.9], [1000000, 1000000, 1000000, 1000000, 1000000]) == 0\n    assert candidate([5.5, 5.5, 5.5, 5.5, 5.5], [1, 10, 100, 1000, 10000]) == 11111\n    assert candidate([5.0, 5.0, 5.0, 5.0, 5.0], [1, 10, 100, 1000, 10000]) == 0\n    assert candidate([5.1, 4.9, 5.1, 4.9, 5.1], [1, 1000000, 1, 1000000, 1]) == 3\n    assert candidate([5.1, 5.1, 5.1, 5.1, 5.1], [0, 0, 0, 0, 0]) == 0\n    assert candidate([4.9, 5.1, 4.9, 5.1, 4.9], [1000000, 1, 1000000, 1, 1000000]) == 2\n    assert candidate([4.9, 5.0, 5.1, 5.2, 5.3], [100000, 200000, 300000, 400000, 500000]) == 1200000\n    assert candidate([4.9, 4.9, 4.9, 4.9, 5.1], [1000000, 1000000, 1000000, 1000000, 1]) == 1\n    assert candidate([4.9, 5.0, 5.1], [1000000, 1000000, 1000000]) == 1000000\n", "language": "python"}
{"task_id": "fee138c3-5d1b-4769-b668-c56f0e3c374d3007803414839274490", "prompt": "You are a coding assistant. Your responsibility is to complete provided functions in executable code blocks. Make sure the completed function can be directly executed. Only utilize libraries that are imported in the problem. Any additional functions or classes should be defined within the given function, not outside it.\n\n```python\ndef encrypt_message(message: str, shift: int) -> str:\n    \"\"\"\n    As a secret agent, you need to encrypt messages before sending them.\n    This function implements a simple Caesar cipher to encrypt a given message\n    by shifting each letter by a specified number of positions in the alphabet.\n\n    Parameters:\n    message (str): The message to be encrypted\n    shift (int): The number of positions to shift each letter\n\n    Returns:\n    str: The encrypted message\n\n\n    [EXAMPLES]\n    \n    assert candidate(\"Large Shift\", 1000) == 'Xmdsq Eturf'\n    assert candidate(\"Mixed Case 123\", 8) == 'Uqfml Kiam 123'\n\n    [/EXAMPLES]\n    \"\"\"\n```\n", "entry_point": "encrypt_message", "solution": "def encrypt_message(message: str, shift: int) -> str:\n    \"\"\"\n    As a secret agent, you need to encrypt messages before sending them.\n    This function implements a simple Caesar cipher to encrypt a given message\n    by shifting each letter by a specified number of positions in the alphabet.\n\n    Parameters:\n    message (str): The message to be encrypted\n    shift (int): The number of positions to shift each letter\n\n    Returns:\n    str: The encrypted message\n\n\n    [EXAMPLES]\n    \n    assert candidate(\"Large Shift\", 1000) == 'Xmdsq Eturf'\n    assert candidate(\"Mixed Case 123\", 8) == 'Uqfml Kiam 123'\n\n    [/EXAMPLES]\n    \"\"\"\n    encrypted_message = \"\"\n    for char in message:\n        if char.isalpha():\n            # Determine the ASCII offset based on whether the character is uppercase or lowercase\n            ascii_offset = 65 if char.isupper() else 97\n            # Apply the shift and wrap around the alphabet using modulo\n            shifted_char = chr((ord(char) - ascii_offset + shift) % 26 + ascii_offset)\n            encrypted_message += shifted_char\n        else:\n            # Non-alphabetic characters remain unchanged\n            encrypted_message += char\n    return encrypted_message\n\n", "test": "def check(candidate):\n    assert candidate(\"Test 123!\", 4) == 'Xiwx 123!'\n    assert candidate(\"Caesar Cipher\", 13) == 'Pnrfne Pvcure'\n    assert candidate(\"Large Shift\", 1000) == 'Xmdsq Eturf'\n    assert candidate(\"The quick brown fox jumps over the lazy dog\", 15) == 'Iwt fjxrz qgdlc udm yjbeh dktg iwt apon sdv'\n    assert candidate(\"SECRET MISSION\", 7) == 'ZLJYLA TPZZPVU'\n    assert candidate(\"ABCDEFGHIJKLMNOPQRSTUVWXYZ\", 26) == 'ABCDEFGHIJKLMNOPQRSTUVWXYZ'\n    assert candidate(\"Negative Shift\", -10) == 'Duwqjylu Ixyvj'\n    assert candidate(\"XYZ\", 2) == 'ZAB'\n    assert candidate(\"Mixed Case 123\", 8) == 'Uqfml Kiam 123'\n    assert candidate(\"ABC\", 1) == 'BCD'\n", "language": "python"}
{"task_id": "93df1e71-fa1a-406b-b4a2-a1f098a9965f3375037479807101918", "prompt": "My response will contain a single code block with a complete implementation of the requested function. I'll ensure the function is executable as provided, with no code appearing outside the function definition. I'll only use libraries that are already imported in the problem, and any additional helper functions or classes will be defined within the main function.\n\n```python\nfrom typing import List\nfrom typing import List, Tuple\n\ndef analyze_dna_sequences(sequences: List[str]) -> List[Tuple[str, float]]:\n    \"\"\"\n    Analyze a list of DNA sequences and calculate their GC content.\n\n    In molecular biology, the GC content of a DNA sequence is an important characteristic.\n    This function takes a list of DNA sequences and calculates the GC content (percentage of\n    Guanine and Cytosine bases) for each sequence.\n\n    The function uses string methods and list comprehension to perform the analysis.\n\n    Args:\n    sequences (List[str]): A list of DNA sequences (strings containing only A, T, G, and C).\n\n    Returns:\n    List[Tuple[str, float]]: A list of tuples, each containing a DNA sequence and its GC content percentage.\n\n\n    [EXAMPLES]\n    \n    assert candidate([\"AAAACCCCGGGGTTTT\"]) == [('AAAACCCCGGGGTTTT', 50.0)]\n    assert candidate([\"ACGT\", \"ACGT\", \"ACGT\", \"ACGT\", \"ACGT\"]) == [('ACGT', 50.0), ('ACGT', 50.0), ('ACGT', 50.0), ('ACGT', 50.0), ('ACGT', 50.0)]\n\n    [/EXAMPLES]\n    \"\"\"\n```\n", "entry_point": "analyze_dna_sequences", "solution": "from typing import List\nfrom typing import List, Tuple\n\ndef analyze_dna_sequences(sequences: List[str]) -> List[Tuple[str, float]]:\n    \"\"\"\n    Analyze a list of DNA sequences and calculate their GC content.\n\n    In molecular biology, the GC content of a DNA sequence is an important characteristic.\n    This function takes a list of DNA sequences and calculates the GC content (percentage of\n    Guanine and Cytosine bases) for each sequence.\n\n    The function uses string methods and list comprehension to perform the analysis.\n\n    Args:\n    sequences (List[str]): A list of DNA sequences (strings containing only A, T, G, and C).\n\n    Returns:\n    List[Tuple[str, float]]: A list of tuples, each containing a DNA sequence and its GC content percentage.\n\n\n    [EXAMPLES]\n    \n    assert candidate([\"AAAACCCCGGGGTTTT\"]) == [('AAAACCCCGGGGTTTT', 50.0)]\n    assert candidate([\"ACGT\", \"ACGT\", \"ACGT\", \"ACGT\", \"ACGT\"]) == [('ACGT', 50.0), ('ACGT', 50.0), ('ACGT', 50.0), ('ACGT', 50.0), ('ACGT', 50.0)]\n\n    [/EXAMPLES]\n    \"\"\"\n    def calculate_gc_content(sequence):\n        \"\"\"Calculate the GC content of a single DNA sequence.\"\"\"\n        gc_count = sequence.count('G') + sequence.count('C')\n        total_bases = len(sequence)\n        return (gc_count / total_bases) * 100 if total_bases > 0 else 0.0\n\n    return [(sequence, calculate_gc_content(sequence)) for sequence in sequences]\n\n", "test": "def check(candidate):\n    assert candidate([\"A\" * 1000 + \"C\" * 1000]) == [('AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC', 50.0)]\n    assert candidate([\"AAACCCGGGTTTT\", \"GGGCCCAAATTT\", \"TTTAAACCCGGG\"]) == [('AAACCCGGGTTTT', 46.15384615384615), ('GGGCCCAAATTT', 50.0), ('TTTAAACCCGGG', 50.0)]\n    assert candidate([\"ACGT\", \"ACGT\", \"ACGT\", \"ACGT\", \"ACGT\"]) == [('ACGT', 50.0), ('ACGT', 50.0), ('ACGT', 50.0), ('ACGT', 50.0), ('ACGT', 50.0)]\n    assert candidate([\"AAAACCCCGGGGTTTT\"]) == [('AAAACCCCGGGGTTTT', 50.0)]\n    assert candidate([\"ACGT\" * 25]) == [('ACGTACGTACGTACGTACGTACGTACGTACGTACGTACGTACGTACGTACGTACGTACGTACGTACGTACGTACGTACGTACGTACGTACGTACGTACGT', 50.0)]\n    assert candidate([]) == []\n    assert candidate([\"GGGGCCCCAAAATTTT\", \"CCCCAAAAGGGGTTTT\", \"AAAATTTTCCCCGGGG\"]) == [('GGGGCCCCAAAATTTT', 50.0), ('CCCCAAAAGGGGTTTT', 50.0), ('AAAATTTTCCCCGGGG', 50.0)]\n    assert candidate([\"ATGC\", \"GCGC\", \"ATAT\"]) == [('ATGC', 50.0), ('GCGC', 100.0), ('ATAT', 0.0)]\n    assert candidate([\"A\" * 100, \"C\" * 100, \"G\" * 100, \"T\" * 100]) == [('AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA', 0.0), ('CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC', 100.0), ('GGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGG', 100.0), ('TTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTT', 0.0)]\n    assert candidate([\"ACGTACGTACGTACGT\", \"TGCATGCATGCATGCA\"]) == [('ACGTACGTACGTACGT', 50.0), ('TGCATGCATGCATGCA', 50.0)]\n", "language": "python"}
{"task_id": "705137a2-b7f6-4b0a-b5f5-1109e9ecaf83-9222492061941187243", "prompt": "Please finish implementing this function based on the documentation string provided. Maintain the existing function name and parameters, and write your solution in a single code block.\n\n```python\nfrom typing import List\nfrom collections import deque\n\ndef optimize_network_latency(nodes: int, connections: List[List[int]]) -> List[int]:\n    \"\"\"\n    As a network engineer, you're tasked with optimizing the latency in a distributed system.\n    The system consists of multiple nodes, and you need to find the minimum number of hops\n    required to reach each node from a central server (node 0).\n\n    The function takes two parameters:\n    1. nodes: An integer representing the total number of nodes in the system (0 to nodes-1)\n    2. connections: A list of lists, where each inner list [a, b] represents a bidirectional\n                    connection between node a and node b\n\n    Your task is to implement a breadth-first search algorithm to find the shortest path\n    from node 0 to every other node. Return a list where the i-th element represents the\n    minimum number of hops required to reach node i from node 0. If a node is unreachable,\n    its value in the result should be -1.\n\n\n    [EXAMPLES]\n    \n    assert candidate(3, [[0,1], [1,2]]) == [0, 1, 2]\n    assert candidate(1, []) == [0]\n\n    [/EXAMPLES]\n    \"\"\"\n```\n", "entry_point": "optimize_network_latency", "solution": "from typing import List\nfrom collections import deque\n\ndef optimize_network_latency(nodes: int, connections: List[List[int]]) -> List[int]:\n    \"\"\"\n    As a network engineer, you're tasked with optimizing the latency in a distributed system.\n    The system consists of multiple nodes, and you need to find the minimum number of hops\n    required to reach each node from a central server (node 0).\n\n    The function takes two parameters:\n    1. nodes: An integer representing the total number of nodes in the system (0 to nodes-1)\n    2. connections: A list of lists, where each inner list [a, b] represents a bidirectional\n                    connection between node a and node b\n\n    Your task is to implement a breadth-first search algorithm to find the shortest path\n    from node 0 to every other node. Return a list where the i-th element represents the\n    minimum number of hops required to reach node i from node 0. If a node is unreachable,\n    its value in the result should be -1.\n\n\n    [EXAMPLES]\n    \n    assert candidate(3, [[0,1], [1,2]]) == [0, 1, 2]\n    assert candidate(1, []) == [0]\n\n    [/EXAMPLES]\n    \"\"\"\n    # Create an adjacency list to represent the graph\n    graph = [[] for _ in range(nodes)]\n    for a, b in connections:\n        graph[a].append(b)\n        graph[b].append(a)\n    \n    # Initialize the result list with -1 (unreachable) for all nodes\n    result = [-1] * nodes\n    \n    # Use a queue for BFS\n    queue = deque([(0, 0)])  # (node, hops)\n    \n    # Perform BFS\n    while queue:\n        node, hops = queue.popleft()\n        \n        # If this node has not been visited yet\n        if result[node] == -1:\n            result[node] = hops\n            \n            # Add all unvisited neighbors to the queue\n            for neighbor in graph[node]:\n                if result[neighbor] == -1:\n                    queue.append((neighbor, hops + 1))\n    \n    return result\n\n", "test": "def check(candidate):\n    assert candidate(1, []) == [0]\n    assert candidate(8, [[0,1], [1,2], [2,3], [3,4], [4,5], [5,6], [6,7]]) == [0, 1, 2, 3, 4, 5, 6, 7]\n    assert candidate(5, [[0,1], [1,2], [2,3], [3,4], [4,0]]) == [0, 1, 2, 2, 1]\n    assert candidate(6, [[0,1], [1,2], [2,3], [3,4], [4,5]]) == [0, 1, 2, 3, 4, 5]\n    assert candidate(10, [[0,1], [1,2], [2,3], [3,4], [4,5], [5,6], [6,7], [7,8], [8,9]]) == [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]\n    assert candidate(4, [[0,1], [1,2], [2,3]]) == [0, 1, 2, 3]\n    assert candidate(3, [[0,1], [1,2]]) == [0, 1, 2]\n    assert candidate(2, [[0,1]]) == [0, 1]\n    assert candidate(6, [[0,1], [1,2], [2,3], [3,4], [4,5], [5,1]]) == [0, 1, 2, 3, 3, 2]\n    assert candidate(5, [[0,1], [0,2], [0,3], [0,4]]) == [0, 1, 1, 1, 1]\n", "language": "python"}
{"task_id": "955e55b8-c27e-46fc-974b-14450c6643a24732458242410938328", "prompt": "I'll complete this function according to the documentation string. The entire implementation will be in one code block.\n\n```python\nfrom typing import List\n\ndef analyze_stock_trends(prices: List[int], window_size: int) -> List[str]:\n    \"\"\"\n    A stock market analyst wants to identify trends in stock prices over a given period.\n    Given a list of daily closing prices and a window size, determine if the stock is in\n    an uptrend, downtrend, or no trend for each window of consecutive days.\n\n    This function uses sliding window technique and generator expressions.\n\n    :param prices: List of integers representing daily closing prices of a stock\n    :param window_size: Integer representing the number of days to consider for each trend analysis\n    :return: List of strings indicating the trend for each window ('Uptrend', 'Downtrend', or 'No trend')\n\n\n    [EXAMPLES]\n    \n    assert candidate([1, 2, 3, 4, 5, 4, 3, 2, 1], 3) == ['Uptrend', 'Uptrend', 'Uptrend', 'No trend', 'Downtrend', 'Downtrend', 'Downtrend']\n    assert candidate([1, 2, 3, 2, 1], 2) == ['Uptrend', 'Uptrend', 'Downtrend', 'Downtrend']\n\n    [/EXAMPLES]\n    \"\"\"\n```\n", "entry_point": "analyze_stock_trends", "solution": "from typing import List\n\ndef analyze_stock_trends(prices: List[int], window_size: int) -> List[str]:\n    \"\"\"\n    A stock market analyst wants to identify trends in stock prices over a given period.\n    Given a list of daily closing prices and a window size, determine if the stock is in\n    an uptrend, downtrend, or no trend for each window of consecutive days.\n\n    This function uses sliding window technique and generator expressions.\n\n    :param prices: List of integers representing daily closing prices of a stock\n    :param window_size: Integer representing the number of days to consider for each trend analysis\n    :return: List of strings indicating the trend for each window ('Uptrend', 'Downtrend', or 'No trend')\n\n\n    [EXAMPLES]\n    \n    assert candidate([1, 2, 3, 4, 5, 4, 3, 2, 1], 3) == ['Uptrend', 'Uptrend', 'Uptrend', 'No trend', 'Downtrend', 'Downtrend', 'Downtrend']\n    assert candidate([1, 2, 3, 2, 1], 2) == ['Uptrend', 'Uptrend', 'Downtrend', 'Downtrend']\n\n    [/EXAMPLES]\n    \"\"\"\n    def analyze_window(window):\n        first, last = window[0], window[-1]\n        if last > first:\n            return 'Uptrend'\n        elif last < first:\n            return 'Downtrend'\n        else:\n            return 'No trend'\n\n    if len(prices) < window_size:\n        return []\n\n    windows = (prices[i:i+window_size] for i in range(len(prices) - window_size + 1))\n    return [analyze_window(window) for window in windows]\n\n", "test": "def check(candidate):\n    assert candidate([1, 2, 3, 4, 5, 4, 3, 2, 1], 3) == ['Uptrend', 'Uptrend', 'Uptrend', 'No trend', 'Downtrend', 'Downtrend', 'Downtrend']\n    assert candidate([1], 1) == ['No trend']\n    assert candidate([100, 90, 80, 90, 100], 3) == ['Downtrend', 'No trend', 'Uptrend']\n    assert candidate([1000, 900, 950, 1100, 1050, 1025], 4) == ['Uptrend', 'Uptrend', 'Uptrend']\n    assert candidate([5, 4, 3, 2, 1], 5) == ['Downtrend']\n    assert candidate([50, 60, 70, 80, 90, 100], 6) == ['Uptrend']\n    assert candidate([10, 10, 10, 20, 20, 20, 30, 30, 30], 3) == ['No trend', 'Uptrend', 'Uptrend', 'No trend', 'Uptrend', 'Uptrend', 'No trend']\n    assert candidate([1, 2, 3, 2, 1], 2) == ['Uptrend', 'Uptrend', 'Downtrend', 'Downtrend']\n    assert candidate([50, 50, 50, 50, 50], 3) == ['No trend', 'No trend', 'No trend']\n    assert candidate([1, 3, 2, 4, 3, 5], 4) == ['Uptrend', 'No trend', 'Uptrend']\n", "language": "python"}
{"task_id": "5e3e9306-93b0-4be0-a795-a63daffa9cf48935853091956669007", "prompt": "As your coding assistant, I'll provide complete, runnable function implementations that use only the libraries imported in the problem. Any helper functions or classes will be defined within the scope of the main function to ensure the code works as provided.\n\n```python\nfrom typing import List\n\ndef encrypt_message(message: str, key: List[int]) -> str:\n    \"\"\"\n    As a cryptography enthusiast, you've developed a unique encryption method for secure communication.\n    This function encrypts a given message using a cyclic key of integers.\n\n    The encryption process involves shifting each character in the message by the corresponding value in the key,\n    cycling through the key as needed. The function utilizes concepts of string manipulation and modular arithmetic.\n\n    Args:\n    message (str): The message to be encrypted.\n    key (List[int]): A list of integers representing the encryption key.\n\n    Returns:\n    str: The encrypted message.\n\n\n    [EXAMPLES]\n    \n    assert candidate(\"SYMBOLS!@#\", [5, 10, 15]) == 'XIBGYAX!@#'\n    assert candidate(\"EDGECASE\", [-1, 0, 1]) == 'DDHDCBRE'\n\n    [/EXAMPLES]\n    \"\"\"\n```\n", "entry_point": "encrypt_message", "solution": "from typing import List\n\ndef encrypt_message(message: str, key: List[int]) -> str:\n    \"\"\"\n    As a cryptography enthusiast, you've developed a unique encryption method for secure communication.\n    This function encrypts a given message using a cyclic key of integers.\n\n    The encryption process involves shifting each character in the message by the corresponding value in the key,\n    cycling through the key as needed. The function utilizes concepts of string manipulation and modular arithmetic.\n\n    Args:\n    message (str): The message to be encrypted.\n    key (List[int]): A list of integers representing the encryption key.\n\n    Returns:\n    str: The encrypted message.\n\n\n    [EXAMPLES]\n    \n    assert candidate(\"SYMBOLS!@#\", [5, 10, 15]) == 'XIBGYAX!@#'\n    assert candidate(\"EDGECASE\", [-1, 0, 1]) == 'DDHDCBRE'\n\n    [/EXAMPLES]\n    \"\"\"\n    def shift_char(char: str, shift: int) -> str:\n        if not char.isalpha():\n            return char\n        \n        # Determine the base (A for uppercase, a for lowercase)\n        base = 'A' if char.isupper() else 'a'\n        \n        # Apply the shift\n        shifted = ord(char) - ord(base)\n        shifted = (shifted + shift) % 26\n        \n        return chr(shifted + ord(base))\n\n    encrypted = []\n    key_length = len(key)\n    \n    for i, char in enumerate(message):\n        shift = key[i % key_length]\n        encrypted.append(shift_char(char, shift))\n    \n    return ''.join(encrypted)\n\n", "test": "def check(candidate):\n    assert candidate(\"ABC\", [26, 26, 26]) == 'ABC'\n    assert candidate(\"XYZ\", [1, 2, 3]) == 'YAC'\n    assert candidate(\"SYMBOLS!@#\", [5, 10, 15]) == 'XIBGYAX!@#'\n    assert candidate(\"REPEATINGKEY\", [1, 2, 3]) == 'SGSFCWJPJLGB'\n    assert candidate(\"EDGECASE\", [-1, 0, 1]) == 'DDHDCBRE'\n    assert candidate(\"UNICODE\u00b7\u0421\u0418\u041c\u0412\u041e\u041b\u042b\", [1, 2, 3]) == 'VPLDQGF\u00b7HWBSCAR'\n    assert candidate(\"\", [1, 2, 3]) == ''\n    assert candidate(\"VERYLONGMESSAGEFORLARGERKEYTEST\", [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]) == 'WGUCQUUOVOTUDKJLVZUKSIHVPKFBNCU'\n    assert candidate(\"abcdefghijklmnopqrstuvwxyz\", [1]) == 'bcdefghijklmnopqrstuvwxyza'\n    assert candidate(\"MIXED123CASE\", [1, 2, 3, 4]) == 'NKAIE123DCVI'\n", "language": "python"}
{"task_id": "35fd468d-e87b-45a4-9164-cfb338d37fab-289782141945978196", "prompt": "I'll write the implementation for this function following the docstring instructions. The function name and arguments will stay exactly as defined.\n\n```python\nfrom typing import List\n\ndef calculate_lemonade_profit(ingredients: List[float], prices: List[float], sales: int) -> float:\n    \"\"\"\n    A young entrepreneur wants to calculate the profit from their lemonade stand.\n    Given a list of ingredient amounts (in liters), their respective prices per liter,\n    and the number of cups sold, calculate the total profit.\n\n    Each cup of lemonade requires 0.25L of each ingredient.\n    The selling price of each cup is $2.50.\n\n\n    [EXAMPLES]\n    \n    assert candidate([5.5, 5.5, 5.5], [1.1, 1.1, 1.1], 70) == 156.85\n    assert candidate([1.0, 2.0, 3.0], [3.0, 2.0, 1.0], 15) == 27.5\n\n    [/EXAMPLES]\n    \"\"\"\n```\n", "entry_point": "calculate_lemonade_profit", "solution": "from typing import List\n\ndef calculate_lemonade_profit(ingredients: List[float], prices: List[float], sales: int) -> float:\n    \"\"\"\n    A young entrepreneur wants to calculate the profit from their lemonade stand.\n    Given a list of ingredient amounts (in liters), their respective prices per liter,\n    and the number of cups sold, calculate the total profit.\n\n    Each cup of lemonade requires 0.25L of each ingredient.\n    The selling price of each cup is $2.50.\n\n\n    [EXAMPLES]\n    \n    assert candidate([5.5, 5.5, 5.5], [1.1, 1.1, 1.1], 70) == 156.85\n    assert candidate([1.0, 2.0, 3.0], [3.0, 2.0, 1.0], 15) == 27.5\n\n    [/EXAMPLES]\n    \"\"\"\n    # Calculate the total cost of ingredients used\n    total_cost = 0\n    for amount, price in zip(ingredients, prices):\n        liters_used = min(amount, sales * 0.25)\n        total_cost += liters_used * price\n\n    # Calculate the total revenue\n    selling_price = 2.50\n    total_revenue = sales * selling_price\n\n    # Calculate the profit\n    profit = total_revenue - total_cost\n\n    return round(profit, 2)\n\n", "test": "def check(candidate):\n    assert candidate([1.5, 1.5, 1.5], [3.0, 3.0, 3.0], 20) == 36.5\n    assert candidate([6.0, 6.0, 6.0], [0.9, 0.9, 0.9], 80) == 183.8\n    assert candidate([10.0, 10.0, 10.0], [0.1, 0.1, 0.1], 200) == 497.0\n    assert candidate([3.5, 3.5, 3.5], [1.8, 1.8, 1.8], 40) == 81.1\n    assert candidate([10.0, 5.0, 2.0], [2.0, 1.0, 3.0], 100) == 219.0\n    assert candidate([8.0, 8.0, 8.0], [0.5, 0.75, 1.0], 90) == 207.0\n    assert candidate([4.0, 4.0, 4.0], [1.2, 1.2, 1.2], 60) == 135.6\n    assert candidate([5.5, 5.5, 5.5], [1.1, 1.1, 1.1], 70) == 156.85\n    assert candidate([1.0, 2.0, 3.0], [3.0, 2.0, 1.0], 15) == 27.5\n    assert candidate([9.0, 9.0, 9.0], [0.6, 0.6, 0.6], 110) == 258.8\n", "language": "python"}
{"task_id": "ec5f62f6-bd67-4508-aea6-c488530d5b6d-3319827394240242868", "prompt": "Fill in the function with code that can be executed without any changes. Use only the imported libraries mentioned in the problem. Define any additional functions or classes inside the given function to keep everything self-contained.\n\n```python\nfrom typing import List, Tuple\n\ndef analyze_earthquake_data(magnitudes: List[float], locations: List[Tuple[float, float]]) -> Tuple[float, Tuple[float, float]]:\n    \"\"\"\n    A seismologist wants to analyze earthquake data from multiple seismic stations.\n    This function takes a list of earthquake magnitudes and their corresponding\n    locations (latitude, longitude) and returns the highest magnitude earthquake\n    along with its location.\n\n    The function utilizes list comprehension and tuple unpacking to process the data.\n\n\n    [EXAMPLES]\n    \n    assert candidate([2.5], [(37.7749, -122.4194)]) == (2.5, (37.7749, -122.4194))\n    assert candidate([6.5, 5.8, 7.2, 6.9, 5.5], [(35.6895, 139.6917), (37.7749, -122.4194), (-33.8688, 151.2093), (40.7128, -74.0060), (51.5074, -0.1278)]) == (7.2, (-33.8688, 151.2093))\n\n    [/EXAMPLES]\n    \"\"\"\n```\n", "entry_point": "analyze_earthquake_data", "solution": "from typing import List, Tuple\n\ndef analyze_earthquake_data(magnitudes: List[float], locations: List[Tuple[float, float]]) -> Tuple[float, Tuple[float, float]]:\n    \"\"\"\n    A seismologist wants to analyze earthquake data from multiple seismic stations.\n    This function takes a list of earthquake magnitudes and their corresponding\n    locations (latitude, longitude) and returns the highest magnitude earthquake\n    along with its location.\n\n    The function utilizes list comprehension and tuple unpacking to process the data.\n\n\n    [EXAMPLES]\n    \n    assert candidate([2.5], [(37.7749, -122.4194)]) == (2.5, (37.7749, -122.4194))\n    assert candidate([6.5, 5.8, 7.2, 6.9, 5.5], [(35.6895, 139.6917), (37.7749, -122.4194), (-33.8688, 151.2093), (40.7128, -74.0060), (51.5074, -0.1278)]) == (7.2, (-33.8688, 151.2093))\n\n    [/EXAMPLES]\n    \"\"\"\n    # Use list comprehension to create a list of tuples (magnitude, location)\n    earthquake_data = [(mag, loc) for mag, loc in zip(magnitudes, locations)]\n    \n    # Find the earthquake with the highest magnitude using max() function\n    # The key function extracts the magnitude (first element of each tuple)\n    highest_magnitude_earthquake = max(earthquake_data, key=lambda x: x[0])\n    \n    # Unpack the result tuple\n    magnitude, location = highest_magnitude_earthquake\n    \n    # Return the highest magnitude and its corresponding location\n    return magnitude, location\n\n", "test": "def check(candidate):\n    assert candidate([8.0, 7.5, 7.8, 7.9, 8.1], [(36.2048, 138.2529), (-18.1416, 178.4419), (-9.7893, -75.9089), (61.2181, -149.9003), (-33.9249, 151.2312)]) == (8.1, (-33.9249, 151.2312))\n    assert candidate([3.0, 2.8, 3.2, 2.9, 3.1], [(19.4326, -99.1332), (25.2048, 55.2708), (1.3521, 103.8198), (-22.9068, -43.1729), (31.2304, 121.4737)]) == (3.2, (1.3521, 103.8198))\n    assert candidate([1.1, 2.2, 3.3, 4.4, 5.5], [(10.1, 20.2), (30.3, 40.4), (50.5, 60.6), (70.7, 80.8), (90.9, 100.0)]) == (5.5, (90.9, 100.0))\n    assert candidate([6.5, 5.8, 7.2, 6.9, 5.5], [(35.6895, 139.6917), (37.7749, -122.4194), (-33.8688, 151.2093), (40.7128, -74.0060), (51.5074, -0.1278)]) == (7.2, (-33.8688, 151.2093))\n    assert candidate([2.5], [(37.7749, -122.4194)]) == (2.5, (37.7749, -122.4194))\n    assert candidate([1.0, 2.0, 3.0, 4.0, 5.0], [(10.0, 20.0), (30.0, 40.0), (50.0, 60.0), (70.0, 80.0), (90.0, 100.0)]) == (5.0, (90.0, 100.0))\n    assert candidate([3.5] * 10, [(i, i) for i in range(10)]) == (3.5, (0, 0))\n    assert candidate([4.2, 3.9, 4.5, 4.1, 4.3], [(48.8566, 2.3522), (55.7558, 37.6173), (41.9028, 12.4964), (52.5200, 13.4050), (45.4642, 9.1900)]) == (4.5, (41.9028, 12.4964))\n    assert candidate([7.0] * 5, [(i * 10.0, i * -10.0) for i in range(5)]) == (7.0, (0.0, -0.0))\n    assert candidate([0.0, 10.0], [(-90.0, -180.0), (90.0, 180.0)]) == (10.0, (90.0, 180.0))\n", "language": "python"}
{"task_id": "6bcda4b4-41f1-4723-a7ea-673a10324502-5110913745147690938", "prompt": "Working as your coding assistant, I'll provide complete implementations for functions that can be executed immediately. I'll restrict myself to the libraries already imported and will nest any additional functions or classes within the main function.\n\n```python\nfrom typing import List, Tuple\nfrom collections import deque\n\ndef treasure_hunt(map_size: Tuple[int, int], obstacles: List[Tuple[int, int]], treasure: Tuple[int, int]) -> List[str]:\n    \"\"\"\n    Navigate through a treacherous island to find hidden treasure while avoiding obstacles.\n\n    Given the dimensions of the island, the positions of obstacles, and the location of the treasure,\n    return the shortest path to reach the treasure using cardinal directions (N, S, E, W).\n\n    If no path exists, return an empty list.\n\n\n    [EXAMPLES]\n    \n    assert candidate((6, 6), [(2, 2), (2, 3), (3, 2), (3, 3)], (5, 5)) == ['E', 'E', 'E', 'E', 'E', 'S', 'S', 'S', 'S', 'S']\n    assert candidate((4, 4), [(0, 1), (1, 0), (2, 1), (1, 2)], (3, 3)) == []\n\n    [/EXAMPLES]\n    \"\"\"\n```\n", "entry_point": "treasure_hunt", "solution": "from typing import List, Tuple\nfrom collections import deque\n\ndef treasure_hunt(map_size: Tuple[int, int], obstacles: List[Tuple[int, int]], treasure: Tuple[int, int]) -> List[str]:\n    \"\"\"\n    Navigate through a treacherous island to find hidden treasure while avoiding obstacles.\n\n    Given the dimensions of the island, the positions of obstacles, and the location of the treasure,\n    return the shortest path to reach the treasure using cardinal directions (N, S, E, W).\n\n    If no path exists, return an empty list.\n\n\n    [EXAMPLES]\n    \n    assert candidate((6, 6), [(2, 2), (2, 3), (3, 2), (3, 3)], (5, 5)) == ['E', 'E', 'E', 'E', 'E', 'S', 'S', 'S', 'S', 'S']\n    assert candidate((4, 4), [(0, 1), (1, 0), (2, 1), (1, 2)], (3, 3)) == []\n\n    [/EXAMPLES]\n    \"\"\"\n    def is_valid(x, y):\n        return 0 <= x < map_size[0] and 0 <= y < map_size[1] and (x, y) not in obstacles\n\n    directions = [('E', 1, 0), ('W', -1, 0), ('S', 0, 1), ('N', 0, -1)]\n    start = (0, 0)\n    queue = deque([(start, [])])\n    visited = set([start])\n\n    while queue:\n        (x, y), path = queue.popleft()\n\n        if (x, y) == treasure:\n            return path\n\n        for direction, dx, dy in directions:\n            new_x, new_y = x + dx, y + dy\n            if is_valid(new_x, new_y) and (new_x, new_y) not in visited:\n                new_path = path + [direction]\n                queue.append(((new_x, new_y), new_path))\n                visited.add((new_x, new_y))\n\n    return []\n\n", "test": "def check(candidate):\n    assert candidate((4, 4), [(0, 1), (1, 0), (2, 1), (1, 2)], (3, 3)) == []\n    assert candidate((2, 2), [(0, 1), (1, 0)], (1, 1)) == []\n    assert candidate((7, 7), [(1, 1), (2, 2), (3, 3), (4, 4), (5, 5)], (6, 6)) == ['E', 'E', 'E', 'E', 'E', 'E', 'S', 'S', 'S', 'S', 'S', 'S']\n    assert candidate((6, 6), [(2, 2), (2, 3), (3, 2), (3, 3)], (5, 5)) == ['E', 'E', 'E', 'E', 'E', 'S', 'S', 'S', 'S', 'S']\n    assert candidate((5, 5), [(1, 1), (2, 2), (3, 3)], (4, 4)) == ['E', 'E', 'E', 'E', 'S', 'S', 'S', 'S']\n    assert candidate((6, 6), [(0, 0), (1, 1), (2, 2), (3, 3), (4, 4), (5, 5)], (5, 0)) == ['E', 'E', 'E', 'E', 'E']\n    assert candidate((3, 3), [(0, 1), (1, 0), (1, 2), (2, 1)], (1, 1)) == []\n    assert candidate((100, 100), [], (99, 99)) == ['E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S']\n    assert candidate((3, 4), [(0, 1), (1, 1), (2, 1)], (2, 3)) == []\n    assert candidate((10, 10), [(5, 5)], (9, 9)) == ['E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S']\n", "language": "python"}
{"task_id": "5cdd056f-8268-495c-b80c-c20dae9b7dbf-256676748035763831", "prompt": "Following the specifications in the docstring, please write the remaining function code. Provide the complete solution in one code block, and ensure comprehensive handling of edge cases.\n\n```python\ndef encode_message(message: str) -> str:\n    \"\"\"\n    A group of friends wants to create a secret code for their messages.\n    They decide to use a simple substitution cipher where each letter is\n    replaced by the letter that comes three positions after it in the alphabet.\n    The cipher wraps around, so 'X' becomes 'A', 'Y' becomes 'B', and 'Z' becomes 'C'.\n    Spaces and punctuation remain unchanged.\n\n    This function takes a message and returns its encoded version using the described cipher.\n\n    Parameters:\n    message (str): The message to be encoded\n\n    Returns:\n    str: The encoded message\n\n\n    [EXAMPLES]\n    \n    assert candidate(\"Python Programming Language\") == 'Sbwkrq Surjudpplqj Odqjxdjh'\n    assert candidate(\"ThisIsAVeryLongStringWithoutAnySpacesOrPunctuationToTestTheFunctionWithALargeInputToEnsureItCanHandleLongStringsEfficiently\") == 'WklvLvDYhubOrqjVwulqjZlwkrxwDqbVsdfhvRuSxqfwxdwlrqWrWhvwWkhIxqfwlrqZlwkDOdujhLqsxwWrHqvxuhLwFdqKdqgohOrqjVwulqjvHiilflhqwob'\n\n    [/EXAMPLES]\n    \"\"\"\n```\n", "entry_point": "encode_message", "solution": "def encode_message(message: str) -> str:\n    \"\"\"\n    A group of friends wants to create a secret code for their messages.\n    They decide to use a simple substitution cipher where each letter is\n    replaced by the letter that comes three positions after it in the alphabet.\n    The cipher wraps around, so 'X' becomes 'A', 'Y' becomes 'B', and 'Z' becomes 'C'.\n    Spaces and punctuation remain unchanged.\n\n    This function takes a message and returns its encoded version using the described cipher.\n\n    Parameters:\n    message (str): The message to be encoded\n\n    Returns:\n    str: The encoded message\n\n\n    [EXAMPLES]\n    \n    assert candidate(\"Python Programming Language\") == 'Sbwkrq Surjudpplqj Odqjxdjh'\n    assert candidate(\"ThisIsAVeryLongStringWithoutAnySpacesOrPunctuationToTestTheFunctionWithALargeInputToEnsureItCanHandleLongStringsEfficiently\") == 'WklvLvDYhubOrqjVwulqjZlwkrxwDqbVsdfhvRuSxqfwxdwlrqWrWhvwWkhIxqfwlrqZlwkDOdujhLqsxwWrHqvxuhLwFdqKdqgohOrqjVwulqjvHiilflhqwob'\n\n    [/EXAMPLES]\n    \"\"\"\n    def shift_letter(char: str) -> str:\n        if char.isalpha():\n            # Get the ASCII value of the character\n            ascii_value = ord(char)\n            # Determine the base ASCII value (65 for uppercase, 97 for lowercase)\n            base = 65 if char.isupper() else 97\n            # Apply the shift and wrap around if necessary\n            shifted = (ascii_value - base + 3) % 26 + base\n            return chr(shifted)\n        else:\n            return char\n\n    return ''.join(shift_letter(char) for char in message)\n\n", "test": "def check(candidate):\n    assert candidate(\"UPPER lower MIXED CaSe\") == 'XSSHU orzhu PLAHG FdVh'\n    assert candidate(\"ZZZ\") == 'CCC'\n    assert candidate(\"1234567890\") == '1234567890'\n    assert candidate(\"Very\\nLong\\nMessage\\nWith\\nMultiple\\nLines\") == 'Yhub\\nOrqj\\nPhvvdjh\\nZlwk\\nPxowlsoh\\nOlqhv'\n    assert candidate(\"!@#$%^&*()_+-=[]{}|;:,.<>?\") == '!@#$%^&*()_+-=[]{}|;:,.<>?'\n    assert candidate(\"AAA BBB CCC\") == 'DDD EEE FFF'\n    assert candidate(\"ThisIsAVeryLongStringWithoutAnySpacesOrPunctuationToTestTheFunctionWithALargeInputToEnsureItCanHandleLongStringsEfficiently\") == 'WklvLvDYhubOrqjVwulqjZlwkrxwDqbVsdfhvRuSxqfwxdwlrqWrWhvwWkhIxqfwlrqZlwkDOdujhLqsxwWrHqvxuhLwFdqKdqgohOrqjVwulqjvHiilflhqwob'\n    assert candidate(\"Python Programming Language\") == 'Sbwkrq Surjudpplqj Odqjxdjh'\n    assert candidate(\"Short\") == 'Vkruw'\n    assert candidate(\"\") == ''\n", "language": "python"}
{"task_id": "c1647fc3-cc2a-4442-a4ea-74ba1a4381624326502453850469306", "prompt": "You are a coding assistant. Your role is to finish a provided function that should be executable as-is within a code block. Don't include code outside the function scope. Utilize only the libraries that are imported in the problem. Any additional functions or classes should be defined solely within the given function.\n\n```python\nimport itertools\nfrom typing import List\n\ndef generate_encryption_keys(alphabet: str, key_length: int) -> List[str]:\n    \"\"\"\n    A cryptography enthusiast wants to generate all possible encryption keys of a given length\n    using a custom alphabet. This function creates a list of all possible keys by utilizing\n    the concepts of combinatorics and list comprehension.\n\n    Args:\n    alphabet (str): A string containing all the characters to be used in the key generation.\n    key_length (int): The desired length of each encryption key.\n\n    Returns:\n    List[str]: A list of all possible encryption keys of the specified length.\n\n\n    [EXAMPLES]\n    \n    assert candidate(\".-\", 6) == ['......', '.....-', '....-.', '....--', '...-..', '...-.-', '...--.', '...---', '..-...', '..-..-', '..-.-.', '..-.--', '..--..', '..--.-', '..---.', '..----', '.-....', '.-...-', '.-..-.', '.-..--', '.-.-..', '.-.-.-', '.-.--.', '.-.---', '.--...', '.--..-', '.--.-.', '.--.--', '.---..', '.---.-', '.----.', '.-----', '-.....', '-....-', '-...-.', '-...--', '-..-..', '-..-.-', '-..--.', '-..---', '-.-...', '-.-..-', '-.-.-.', '-.-.--', '-.--..', '-.--.-', '-.---.', '-.----', '--....', '--...-', '--..-.', '--..--', '--.-..', '--.-.-', '--.--.', '--.---', '---...', '---..-', '---.-.', '---.--', '----..', '----.-', '-----.', '------']\n    assert candidate(\"A\", 5) == ['AAAAA']\n\n    [/EXAMPLES]\n    \"\"\"\n```\n", "entry_point": "generate_encryption_keys", "solution": "import itertools\nfrom typing import List\n\ndef generate_encryption_keys(alphabet: str, key_length: int) -> List[str]:\n    \"\"\"\n    A cryptography enthusiast wants to generate all possible encryption keys of a given length\n    using a custom alphabet. This function creates a list of all possible keys by utilizing\n    the concepts of combinatorics and list comprehension.\n\n    Args:\n    alphabet (str): A string containing all the characters to be used in the key generation.\n    key_length (int): The desired length of each encryption key.\n\n    Returns:\n    List[str]: A list of all possible encryption keys of the specified length.\n\n\n    [EXAMPLES]\n    \n    assert candidate(\".-\", 6) == ['......', '.....-', '....-.', '....--', '...-..', '...-.-', '...--.', '...---', '..-...', '..-..-', '..-.-.', '..-.--', '..--..', '..--.-', '..---.', '..----', '.-....', '.-...-', '.-..-.', '.-..--', '.-.-..', '.-.-.-', '.-.--.', '.-.---', '.--...', '.--..-', '.--.-.', '.--.--', '.---..', '.---.-', '.----.', '.-----', '-.....', '-....-', '-...-.', '-...--', '-..-..', '-..-.-', '-..--.', '-..---', '-.-...', '-.-..-', '-.-.-.', '-.-.--', '-.--..', '-.--.-', '-.---.', '-.----', '--....', '--...-', '--..-.', '--..--', '--.-..', '--.-.-', '--.--.', '--.---', '---...', '---..-', '---.-.', '---.--', '----..', '----.-', '-----.', '------']\n    assert candidate(\"A\", 5) == ['AAAAA']\n\n    [/EXAMPLES]\n    \"\"\"\n    # Use itertools.product to generate all possible combinations\n    combinations = itertools.product(alphabet, repeat=key_length)\n    \n    # Convert each combination tuple to a string and create a list\n    encryption_keys = [''.join(combo) for combo in combinations]\n    \n    return encryption_keys\n\n", "test": "def check(candidate):\n    assert candidate(\"aeiou\", 4) == ['aaaa', 'aaae', 'aaai', 'aaao', 'aaau', 'aaea', 'aaee', 'aaei', 'aaeo', 'aaeu', 'aaia', 'aaie', 'aaii', 'aaio', 'aaiu', 'aaoa', 'aaoe', 'aaoi', 'aaoo', 'aaou', 'aaua', 'aaue', 'aaui', 'aauo', 'aauu', 'aeaa', 'aeae', 'aeai', 'aeao', 'aeau', 'aeea', 'aeee', 'aeei', 'aeeo', 'aeeu', 'aeia', 'aeie', 'aeii', 'aeio', 'aeiu', 'aeoa', 'aeoe', 'aeoi', 'aeoo', 'aeou', 'aeua', 'aeue', 'aeui', 'aeuo', 'aeuu', 'aiaa', 'aiae', 'aiai', 'aiao', 'aiau', 'aiea', 'aiee', 'aiei', 'aieo', 'aieu', 'aiia', 'aiie', 'aiii', 'aiio', 'aiiu', 'aioa', 'aioe', 'aioi', 'aioo', 'aiou', 'aiua', 'aiue', 'aiui', 'aiuo', 'aiuu', 'aoaa', 'aoae', 'aoai', 'aoao', 'aoau', 'aoea', 'aoee', 'aoei', 'aoeo', 'aoeu', 'aoia', 'aoie', 'aoii', 'aoio', 'aoiu', 'aooa', 'aooe', 'aooi', 'aooo', 'aoou', 'aoua', 'aoue', 'aoui', 'aouo', 'aouu', 'auaa', 'auae', 'auai', 'auao', 'auau', 'auea', 'auee', 'auei', 'aueo', 'aueu', 'auia', 'auie', 'auii', 'auio', 'auiu', 'auoa', 'auoe', 'auoi', 'auoo', 'auou', 'auua', 'auue', 'auui', 'auuo', 'auuu', 'eaaa', 'eaae', 'eaai', 'eaao', 'eaau', 'eaea', 'eaee', 'eaei', 'eaeo', 'eaeu', 'eaia', 'eaie', 'eaii', 'eaio', 'eaiu', 'eaoa', 'eaoe', 'eaoi', 'eaoo', 'eaou', 'eaua', 'eaue', 'eaui', 'eauo', 'eauu', 'eeaa', 'eeae', 'eeai', 'eeao', 'eeau', 'eeea', 'eeee', 'eeei', 'eeeo', 'eeeu', 'eeia', 'eeie', 'eeii', 'eeio', 'eeiu', 'eeoa', 'eeoe', 'eeoi', 'eeoo', 'eeou', 'eeua', 'eeue', 'eeui', 'eeuo', 'eeuu', 'eiaa', 'eiae', 'eiai', 'eiao', 'eiau', 'eiea', 'eiee', 'eiei', 'eieo', 'eieu', 'eiia', 'eiie', 'eiii', 'eiio', 'eiiu', 'eioa', 'eioe', 'eioi', 'eioo', 'eiou', 'eiua', 'eiue', 'eiui', 'eiuo', 'eiuu', 'eoaa', 'eoae', 'eoai', 'eoao', 'eoau', 'eoea', 'eoee', 'eoei', 'eoeo', 'eoeu', 'eoia', 'eoie', 'eoii', 'eoio', 'eoiu', 'eooa', 'eooe', 'eooi', 'eooo', 'eoou', 'eoua', 'eoue', 'eoui', 'eouo', 'eouu', 'euaa', 'euae', 'euai', 'euao', 'euau', 'euea', 'euee', 'euei', 'eueo', 'eueu', 'euia', 'euie', 'euii', 'euio', 'euiu', 'euoa', 'euoe', 'euoi', 'euoo', 'euou', 'euua', 'euue', 'euui', 'euuo', 'euuu', 'iaaa', 'iaae', 'iaai', 'iaao', 'iaau', 'iaea', 'iaee', 'iaei', 'iaeo', 'iaeu', 'iaia', 'iaie', 'iaii', 'iaio', 'iaiu', 'iaoa', 'iaoe', 'iaoi', 'iaoo', 'iaou', 'iaua', 'iaue', 'iaui', 'iauo', 'iauu', 'ieaa', 'ieae', 'ieai', 'ieao', 'ieau', 'ieea', 'ieee', 'ieei', 'ieeo', 'ieeu', 'ieia', 'ieie', 'ieii', 'ieio', 'ieiu', 'ieoa', 'ieoe', 'ieoi', 'ieoo', 'ieou', 'ieua', 'ieue', 'ieui', 'ieuo', 'ieuu', 'iiaa', 'iiae', 'iiai', 'iiao', 'iiau', 'iiea', 'iiee', 'iiei', 'iieo', 'iieu', 'iiia', 'iiie', 'iiii', 'iiio', 'iiiu', 'iioa', 'iioe', 'iioi', 'iioo', 'iiou', 'iiua', 'iiue', 'iiui', 'iiuo', 'iiuu', 'ioaa', 'ioae', 'ioai', 'ioao', 'ioau', 'ioea', 'ioee', 'ioei', 'ioeo', 'ioeu', 'ioia', 'ioie', 'ioii', 'ioio', 'ioiu', 'iooa', 'iooe', 'iooi', 'iooo', 'ioou', 'ioua', 'ioue', 'ioui', 'iouo', 'iouu', 'iuaa', 'iuae', 'iuai', 'iuao', 'iuau', 'iuea', 'iuee', 'iuei', 'iueo', 'iueu', 'iuia', 'iuie', 'iuii', 'iuio', 'iuiu', 'iuoa', 'iuoe', 'iuoi', 'iuoo', 'iuou', 'iuua', 'iuue', 'iuui', 'iuuo', 'iuuu', 'oaaa', 'oaae', 'oaai', 'oaao', 'oaau', 'oaea', 'oaee', 'oaei', 'oaeo', 'oaeu', 'oaia', 'oaie', 'oaii', 'oaio', 'oaiu', 'oaoa', 'oaoe', 'oaoi', 'oaoo', 'oaou', 'oaua', 'oaue', 'oaui', 'oauo', 'oauu', 'oeaa', 'oeae', 'oeai', 'oeao', 'oeau', 'oeea', 'oeee', 'oeei', 'oeeo', 'oeeu', 'oeia', 'oeie', 'oeii', 'oeio', 'oeiu', 'oeoa', 'oeoe', 'oeoi', 'oeoo', 'oeou', 'oeua', 'oeue', 'oeui', 'oeuo', 'oeuu', 'oiaa', 'oiae', 'oiai', 'oiao', 'oiau', 'oiea', 'oiee', 'oiei', 'oieo', 'oieu', 'oiia', 'oiie', 'oiii', 'oiio', 'oiiu', 'oioa', 'oioe', 'oioi', 'oioo', 'oiou', 'oiua', 'oiue', 'oiui', 'oiuo', 'oiuu', 'ooaa', 'ooae', 'ooai', 'ooao', 'ooau', 'ooea', 'ooee', 'ooei', 'ooeo', 'ooeu', 'ooia', 'ooie', 'ooii', 'ooio', 'ooiu', 'oooa', 'oooe', 'oooi', 'oooo', 'ooou', 'ooua', 'ooue', 'ooui', 'oouo', 'oouu', 'ouaa', 'ouae', 'ouai', 'ouao', 'ouau', 'ouea', 'ouee', 'ouei', 'oueo', 'oueu', 'ouia', 'ouie', 'ouii', 'ouio', 'ouiu', 'ouoa', 'ouoe', 'ouoi', 'ouoo', 'ouou', 'ouua', 'ouue', 'ouui', 'ouuo', 'ouuu', 'uaaa', 'uaae', 'uaai', 'uaao', 'uaau', 'uaea', 'uaee', 'uaei', 'uaeo', 'uaeu', 'uaia', 'uaie', 'uaii', 'uaio', 'uaiu', 'uaoa', 'uaoe', 'uaoi', 'uaoo', 'uaou', 'uaua', 'uaue', 'uaui', 'uauo', 'uauu', 'ueaa', 'ueae', 'ueai', 'ueao', 'ueau', 'ueea', 'ueee', 'ueei', 'ueeo', 'ueeu', 'ueia', 'ueie', 'ueii', 'ueio', 'ueiu', 'ueoa', 'ueoe', 'ueoi', 'ueoo', 'ueou', 'ueua', 'ueue', 'ueui', 'ueuo', 'ueuu', 'uiaa', 'uiae', 'uiai', 'uiao', 'uiau', 'uiea', 'uiee', 'uiei', 'uieo', 'uieu', 'uiia', 'uiie', 'uiii', 'uiio', 'uiiu', 'uioa', 'uioe', 'uioi', 'uioo', 'uiou', 'uiua', 'uiue', 'uiui', 'uiuo', 'uiuu', 'uoaa', 'uoae', 'uoai', 'uoao', 'uoau', 'uoea', 'uoee', 'uoei', 'uoeo', 'uoeu', 'uoia', 'uoie', 'uoii', 'uoio', 'uoiu', 'uooa', 'uooe', 'uooi', 'uooo', 'uoou', 'uoua', 'uoue', 'uoui', 'uouo', 'uouu', 'uuaa', 'uuae', 'uuai', 'uuao', 'uuau', 'uuea', 'uuee', 'uuei', 'uueo', 'uueu', 'uuia', 'uuie', 'uuii', 'uuio', 'uuiu', 'uuoa', 'uuoe', 'uuoi', 'uuoo', 'uuou', 'uuua', 'uuue', 'uuui', 'uuuo', 'uuuu']\n    assert candidate(\"XYZ\", 2) == ['XX', 'XY', 'XZ', 'YX', 'YY', 'YZ', 'ZX', 'ZY', 'ZZ']\n    assert candidate(\"!@#$%\", 3) == ['!!!', '!!@', '!!#', '!!$', '!!%', '!@!', '!@@', '!@#', '!@$', '!@%', '!#!', '!#@', '!##', '!#$', '!#%', '!$!', '!$@', '!$#', '!$$', '!$%', '!%!', '!%@', '!%#', '!%$', '!%%', '@!!', '@!@', '@!#', '@!$', '@!%', '@@!', '@@@', '@@#', '@@$', '@@%', '@#!', '@#@', '@##', '@#$', '@#%', '@$!', '@$@', '@$#', '@$$', '@$%', '@%!', '@%@', '@%#', '@%$', '@%%', '#!!', '#!@', '#!#', '#!$', '#!%', '#@!', '#@@', '#@#', '#@$', '#@%', '##!', '##@', '###', '##$', '##%', '#$!', '#$@', '#$#', '#$$', '#$%', '#%!', '#%@', '#%#', '#%$', '#%%', '$!!', '$!@', '$!#', '$!$', '$!%', '$@!', '$@@', '$@#', '$@$', '$@%', '$#!', '$#@', '$##', '$#$', '$#%', '$$!', '$$@', '$$#', '$$$', '$$%', '$%!', '$%@', '$%#', '$%$', '$%%', '%!!', '%!@', '%!#', '%!$', '%!%', '%@!', '%@@', '%@#', '%@$', '%@%', '%#!', '%#@', '%##', '%#$', '%#%', '%$!', '%$@', '%$#', '%$$', '%$%', '%%!', '%%@', '%%#', '%%$', '%%%']\n    assert candidate(\"\", 0) == ['']\n    assert candidate(\"     \", 3) == ['   ', '   ', '   ', '   ', '   ', '   ', '   ', '   ', '   ', '   ', '   ', '   ', '   ', '   ', '   ', '   ', '   ', '   ', '   ', '   ', '   ', '   ', '   ', '   ', '   ', '   ', '   ', '   ', '   ', '   ', '   ', '   ', '   ', '   ', '   ', '   ', '   ', '   ', '   ', '   ', '   ', '   ', '   ', '   ', '   ', '   ', '   ', '   ', '   ', '   ', '   ', '   ', '   ', '   ', '   ', '   ', '   ', '   ', '   ', '   ', '   ', '   ', '   ', '   ', '   ', '   ', '   ', '   ', '   ', '   ', '   ', '   ', '   ', '   ', '   ', '   ', '   ', '   ', '   ', '   ', '   ', '   ', '   ', '   ', '   ', '   ', '   ', '   ', '   ', '   ', '   ', '   ', '   ', '   ', '   ', '   ', '   ', '   ', '   ', '   ', '   ', '   ', '   ', '   ', '   ', '   ', '   ', '   ', '   ', '   ', '   ', '   ', '   ', '   ', '   ', '   ', '   ', '   ', '   ', '   ', '   ', '   ', '   ', '   ', '   ']\n    assert candidate(\"A\", 5) == ['AAAAA']\n    assert candidate(\"\u03b1\u03b2\u03b3\u03b4\u03b5\", 2) == ['\u03b1\u03b1', '\u03b1\u03b2', '\u03b1\u03b3', '\u03b1\u03b4', '\u03b1\u03b5', '\u03b2\u03b1', '\u03b2\u03b2', '\u03b2\u03b3', '\u03b2\u03b4', '\u03b2\u03b5', '\u03b3\u03b1', '\u03b3\u03b2', '\u03b3\u03b3', '\u03b3\u03b4', '\u03b3\u03b5', '\u03b4\u03b1', '\u03b4\u03b2', '\u03b4\u03b3', '\u03b4\u03b4', '\u03b4\u03b5', '\u03b5\u03b1', '\u03b5\u03b2', '\u03b5\u03b3', '\u03b5\u03b4', '\u03b5\u03b5']\n    assert candidate(\".-\", 6) == ['......', '.....-', '....-.', '....--', '...-..', '...-.-', '...--.', '...---', '..-...', '..-..-', '..-.-.', '..-.--', '..--..', '..--.-', '..---.', '..----', '.-....', '.-...-', '.-..-.', '.-..--', '.-.-..', '.-.-.-', '.-.--.', '.-.---', '.--...', '.--..-', '.--.-.', '.--.--', '.---..', '.---.-', '.----.', '.-----', '-.....', '-....-', '-...-.', '-...--', '-..-..', '-..-.-', '-..--.', '-..---', '-.-...', '-.-..-', '-.-.-.', '-.-.--', '-.--..', '-.--.-', '-.---.', '-.----', '--....', '--...-', '--..-.', '--..--', '--.-..', '--.-.-', '--.--.', '--.---', '---...', '---..-', '---.-.', '---.--', '----..', '----.-', '-----.', '------']\n    assert candidate(\"abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789\", 1) == ['a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm', 'n', 'o', 'p', 'q', 'r', 's', 't', 'u', 'v', 'w', 'x', 'y', 'z', 'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z', '0', '1', '2', '3', '4', '5', '6', '7', '8', '9']\n    assert candidate(\"AB CD\", 2) == ['AA', 'AB', 'A ', 'AC', 'AD', 'BA', 'BB', 'B ', 'BC', 'BD', ' A', ' B', '  ', ' C', ' D', 'CA', 'CB', 'C ', 'CC', 'CD', 'DA', 'DB', 'D ', 'DC', 'DD']\n", "language": "python"}
{"task_id": "698d7d10-a6bc-4c47-a2d0-bf95c24232507687022765181055526", "prompt": "Implement the function as specified so it can be executed directly. Any additional functions or classes must be defined inside the main function. Use only libraries that are already imported. The entire solution should be contained within one code block representing the complete function.\n\n```python\ndef calculate_erosion(landscape: str, years: int) -> str:\n    \"\"\"\n    In a geological simulation, we model coastal erosion over time. The landscape is represented\n    by a string where 'L' represents land and 'W' represents water. Each year, any land directly\n    adjacent to water erodes, turning into water.\n\n    This function takes the initial landscape and the number of years to simulate, then returns\n    the final landscape after erosion.\n\n\n    [EXAMPLES]\n    \n    assert candidate(\"WWWWWWWWWW\", 10) == 'WWWWWWWWWW'\n    assert candidate(\"LLWWLLWLL\", 2) == 'WWWWWWWWW'\n\n    [/EXAMPLES]\n    \"\"\"\n```\n", "entry_point": "calculate_erosion", "solution": "def calculate_erosion(landscape: str, years: int) -> str:\n    \"\"\"\n    In a geological simulation, we model coastal erosion over time. The landscape is represented\n    by a string where 'L' represents land and 'W' represents water. Each year, any land directly\n    adjacent to water erodes, turning into water.\n\n    This function takes the initial landscape and the number of years to simulate, then returns\n    the final landscape after erosion.\n\n\n    [EXAMPLES]\n    \n    assert candidate(\"WWWWWWWWWW\", 10) == 'WWWWWWWWWW'\n    assert candidate(\"LLWWLLWLL\", 2) == 'WWWWWWWWW'\n\n    [/EXAMPLES]\n    \"\"\"\n    def erode_once(current_landscape: str) -> str:\n        new_landscape = list(current_landscape)\n        for i in range(len(current_landscape)):\n            if current_landscape[i] == 'L':\n                if (i > 0 and current_landscape[i-1] == 'W') or (i < len(current_landscape) - 1 and current_landscape[i+1] == 'W'):\n                    new_landscape[i] = 'W'\n        return ''.join(new_landscape)\n\n    current = landscape\n    for _ in range(years):\n        current = erode_once(current)\n    return current\n\n", "test": "def check(candidate):\n    assert candidate(\"LWWWWWWWWWL\", 1) == 'WWWWWWWWWWW'\n    assert candidate(\"WWWWLWWWW\", 1) == 'WWWWWWWWW'\n    assert candidate(\"WWWWWWWWWW\", 10) == 'WWWWWWWWWW'\n    assert candidate(\"LLWWLLWLL\", 2) == 'WWWWWWWWW'\n    assert candidate(\"LW\", 1) == 'WW'\n    assert candidate(\"LLWWLLWWLL\", 3) == 'WWWWWWWWWW'\n    assert candidate(\"LLLLLWLLLLL\", 5) == 'WWWWWWWWWWW'\n    assert candidate(\"LWLWLWLW\", 2) == 'WWWWWWWW'\n    assert candidate(\"W\", 1) == 'W'\n    assert candidate(\"LLLWWLLLWWL\", 3) == 'WWWWWWWWWWW'\n", "language": "python"}
{"task_id": "fe7ebc35-9544-44ff-81db-e366cd5ac167-3584279354124026469", "prompt": "Let me complete that code block for you.\n\n```python\nfrom typing import List\n\ndef analyze_dna_sequences(sequences: List[str], motif: str) -> List[int]:\n    \"\"\"\n    Analyze a list of DNA sequences to find occurrences of a specific motif.\n\n    In genetic research, identifying certain DNA motifs can be crucial for understanding gene regulation.\n    This function takes a list of DNA sequences and a motif, then returns the count of motif occurrences\n    in each sequence.\n\n    :param sequences: A list of DNA sequences (strings containing A, T, C, G)\n    :param motif: The DNA motif to search for\n    :return: A list of integers representing the count of motif occurrences in each sequence\n\n\n    [EXAMPLES]\n    \n    assert candidate(['AAAA', 'TTTT', 'GGGG', 'CCCC'], 'AAAAA') == [0, 0, 0, 0]\n    assert candidate(['A' * 10000, 'T' * 10000, 'C' * 10000, 'G' * 10000], 'AAAA') == [9997, 0, 0, 0]\n\n    [/EXAMPLES]\n    \"\"\"\n```\n", "entry_point": "analyze_dna_sequences", "solution": "from typing import List\n\ndef analyze_dna_sequences(sequences: List[str], motif: str) -> List[int]:\n    \"\"\"\n    Analyze a list of DNA sequences to find occurrences of a specific motif.\n\n    In genetic research, identifying certain DNA motifs can be crucial for understanding gene regulation.\n    This function takes a list of DNA sequences and a motif, then returns the count of motif occurrences\n    in each sequence.\n\n    :param sequences: A list of DNA sequences (strings containing A, T, C, G)\n    :param motif: The DNA motif to search for\n    :return: A list of integers representing the count of motif occurrences in each sequence\n\n\n    [EXAMPLES]\n    \n    assert candidate(['AAAA', 'TTTT', 'GGGG', 'CCCC'], 'AAAAA') == [0, 0, 0, 0]\n    assert candidate(['A' * 10000, 'T' * 10000, 'C' * 10000, 'G' * 10000], 'AAAA') == [9997, 0, 0, 0]\n\n    [/EXAMPLES]\n    \"\"\"\n    def count_motif(sequence: str, motif: str) -> int:\n        count = 0\n        motif_length = len(motif)\n        for i in range(len(sequence) - motif_length + 1):\n            if sequence[i:i+motif_length] == motif:\n                count += 1\n        return count\n\n    return [count_motif(sequence, motif) for sequence in sequences]\n\n", "test": "def check(candidate):\n    assert candidate([], 'ATC') == []\n    assert candidate(['ATATATATATA', 'CGCGCGCGCGC'], 'ATA') == [5, 0]\n    assert candidate(['A' * 10000, 'T' * 10000, 'C' * 10000, 'G' * 10000], 'AAAA') == [9997, 0, 0, 0]\n    assert candidate(['ATCG', 'GATC', 'CTAG', 'TAGC'], 'AT') == [1, 1, 0, 0]\n    assert candidate(['ATCGATCGATCG'], 'ATCGATCG') == [2]\n    assert candidate(['atcgatcg', 'ATCGATCG'], 'ATC') == [0, 2]\n    assert candidate(['ATCG', 'GATC', 'CTAG', 'TAGC'], '') == [5, 5, 5, 5]\n    assert candidate(['ATCGATCGATCG'], 'X') == [0]\n    assert candidate(['AAAA', 'TTTT', 'GGGG', 'CCCC'], 'AAAAA') == [0, 0, 0, 0]\n    assert candidate(['GGGGGG', 'AAAAAA', 'TTTTTT', 'CCCCCC'], 'GG') == [5, 0, 0, 0]\n", "language": "python"}
{"task_id": "f7ca2193-2fbf-45a5-aa87-ab97f3a5b6d0-1264986889222710224", "prompt": "I'll deliver a complete function in one code block that can be executed without additional code. The implementation will use only the imported libraries specified in the problem, and all helper functions or classes will be defined inside the main function.\n\n```python\nfrom typing import List, Tuple\nimport math\n\ndef quantum_entanglement_score(particles: List[Tuple[float, float, float]]) -> float:\n    \"\"\"\n    Compute the quantum entanglement score for a system of particles based on their spin states.\n\n    This function takes a list of tuples representing the spin states of particles in three dimensions (x, y, z).\n    It returns a single float value representing the overall entanglement score of the system.\n\n\n    [EXAMPLES]\n    \n    assert candidate([(1.0, 0.0, 0.0), (0.0, 1.0, 0.0), (0.0, 0.0, 1.0)]) == 1.0\n    assert candidate([(0.5, 0.5, 0.5), (-0.5, -0.5, -0.5), (0.5, -0.5, 0.5), (-0.5, 0.5, -0.5)]) == 0.4444444444444443\n\n    [/EXAMPLES]\n    \"\"\"\n```\n", "entry_point": "quantum_entanglement_score", "solution": "from typing import List, Tuple\nimport math\n\ndef quantum_entanglement_score(particles: List[Tuple[float, float, float]]) -> float:\n    \"\"\"\n    Compute the quantum entanglement score for a system of particles based on their spin states.\n\n    This function takes a list of tuples representing the spin states of particles in three dimensions (x, y, z).\n    It returns a single float value representing the overall entanglement score of the system.\n\n\n    [EXAMPLES]\n    \n    assert candidate([(1.0, 0.0, 0.0), (0.0, 1.0, 0.0), (0.0, 0.0, 1.0)]) == 1.0\n    assert candidate([(0.5, 0.5, 0.5), (-0.5, -0.5, -0.5), (0.5, -0.5, 0.5), (-0.5, 0.5, -0.5)]) == 0.4444444444444443\n\n    [/EXAMPLES]\n    \"\"\"\n    def dot_product(v1, v2):\n        return sum(a * b for a, b in zip(v1, v2))\n\n    def magnitude(v):\n        return math.sqrt(sum(x * x for x in v))\n\n    def normalize(v):\n        mag = magnitude(v)\n        return tuple(x / mag for x in v) if mag != 0 else v\n\n    n = len(particles)\n    if n < 2:\n        return 0.0\n\n    # Normalize all particle vectors\n    normalized_particles = [normalize(p) for p in particles]\n\n    # Calculate the sum of dot products\n    total_dot_product = 0\n    for i in range(n):\n        for j in range(i + 1, n):\n            total_dot_product += abs(dot_product(normalized_particles[i], normalized_particles[j]))\n\n    # Calculate the maximum possible sum of dot products\n    max_dot_product = (n * (n - 1)) / 2\n\n    # Calculate the entanglement score\n    entanglement_score = 1 - (total_dot_product / max_dot_product)\n\n    return entanglement_score\n\n", "test": "def check(candidate):\n    assert candidate([(1.0, 1.0, 1.0), (-1.0, -1.0, -1.0)]) == -2.220446049250313e-16\n    assert candidate([(1.0, 0.0, 0.0), (0.0, 1.0, 0.0), (0.0, 0.0, 1.0)]) == 1.0\n    assert candidate([(0.5, 0.5, 0.5), (-0.5, -0.5, -0.5), (0.5, -0.5, 0.5), (-0.5, 0.5, -0.5)]) == 0.4444444444444443\n    assert candidate([(1.0, 0.0, 0.0), (0.0, 1.0, 0.0), (1.0, 1.0, 0.0)]) == 0.5285954792089684\n    assert candidate([(0.1, 0.1, 0.1)] * 1000) == 0.0\n    assert candidate([(0.707, 0.707, 0.0), (-0.707, 0.707, 0.0)]) == 1.0\n    assert candidate([(0.5, -0.5, 0.0), (-0.5, 0.5, 0.0), (0.0, 0.0, 1.0)]) == 0.6666666666666667\n    assert candidate([(0.0, 0.0, 0.0)]) == 0.0\n    assert candidate([(0.0, 0.0, 1.0)] * 100) == 0.0\n    assert candidate([(0.1, 0.2, 0.3), (0.4, 0.5, 0.6), (0.7, 0.8, 0.9)]) == 0.022588438516842224\n", "language": "python"}
{"task_id": "8dceb608-e916-4864-9351-507421ec14c1-6087413233163272123", "prompt": "I'll implement the requested function in a single, executable code block. Any helper functions or classes needed will be defined within the main function. I'll only use libraries that are already imported, and my entire solution will be contained in one code block.\n\n```python\ndef molecule_balance(equation: str) -> bool:\n    \"\"\"\n    A chemist needs to verify if a chemical equation is balanced. In a balanced equation,\n    the number of atoms of each element should be equal on both sides of the equation.\n\n    Given a chemical equation as a string, determine if it is balanced. Assume that the\n    equation is well-formed and contains only uppercase letters for elements, numbers for\n    quantities, and '+' and '->' symbols.\n\n    :param equation: A string representing the chemical equation\n    :return: True if the equation is balanced, False otherwise\n\n\n    [EXAMPLES]\n    \n    assert candidate(\"KClO3 -> KCl + O2\") == False\n    assert candidate(\"CH4 + 2O2 -> CO2 + 2H2O\") == True\n\n    [/EXAMPLES]\n    \"\"\"\n```\n", "entry_point": "molecule_balance", "solution": "def molecule_balance(equation: str) -> bool:\n    \"\"\"\n    A chemist needs to verify if a chemical equation is balanced. In a balanced equation,\n    the number of atoms of each element should be equal on both sides of the equation.\n\n    Given a chemical equation as a string, determine if it is balanced. Assume that the\n    equation is well-formed and contains only uppercase letters for elements, numbers for\n    quantities, and '+' and '->' symbols.\n\n    :param equation: A string representing the chemical equation\n    :return: True if the equation is balanced, False otherwise\n\n\n    [EXAMPLES]\n    \n    assert candidate(\"KClO3 -> KCl + O2\") == False\n    assert candidate(\"CH4 + 2O2 -> CO2 + 2H2O\") == True\n\n    [/EXAMPLES]\n    \"\"\"\n    def parse_molecule(molecule):\n        atoms = {}\n        current_element = ''\n        current_count = ''\n        \n        for char in molecule:\n            if char.isupper():\n                if current_element:\n                    atoms[current_element] = atoms.get(current_element, 0) + (int(current_count) if current_count else 1)\n                current_element = char\n                current_count = ''\n            elif char.islower():\n                current_element += char\n            elif char.isdigit():\n                current_count += char\n        \n        if current_element:\n            atoms[current_element] = atoms.get(current_element, 0) + (int(current_count) if current_count else 1)\n        \n        return atoms\n\n    def parse_side(side):\n        molecules = side.split('+')\n        side_atoms = {}\n        for molecule in molecules:\n            molecule = molecule.strip()\n            count = 1\n            if molecule[0].isdigit():\n                count_str = ''\n                for char in molecule:\n                    if char.isdigit():\n                        count_str += char\n                    else:\n                        break\n                count = int(count_str)\n                molecule = molecule[len(count_str):]\n            \n            atoms = parse_molecule(molecule)\n            for element, amount in atoms.items():\n                side_atoms[element] = side_atoms.get(element, 0) + amount * count\n        \n        return side_atoms\n\n    # Split the equation into left and right sides\n    left, right = equation.split('->')\n    \n    # Parse both sides of the equation\n    left_atoms = parse_side(left)\n    right_atoms = parse_side(right)\n    \n    # Compare the atom counts on both sides\n    return left_atoms == right_atoms\n\n", "test": "def check(candidate):\n    assert candidate(\"C + O2 -> CO2\") == True\n    assert candidate(\"2KClO3 -> 2KCl + 3O2\") == True\n    assert candidate(\"2Fe + 3Cl2 -> 2FeCl3\") == True\n    assert candidate(\"2C2H6 + 7O2 -> 4CO2 + 6H2O\") == True\n    assert candidate(\"Fe + Cl2 -> FeCl2\") == True\n    assert candidate(\"Zn + 2HCl -> ZnCl2 + H2\") == True\n    assert candidate(\"CaCO3 -> CaO + CO2\") == True\n    assert candidate(\"KClO3 -> KCl + O2\") == False\n    assert candidate(\"CH4 + 2O2 -> CO2 + 2H2O\") == True\n    assert candidate(\"4NH3 + 5O2 -> 4NO + 6H2O\") == True\n", "language": "python"}
{"task_id": "77484f3f-5114-4e1d-a1dd-4ea0374033c34947630735031910285", "prompt": "Your function needs completion while ensuring it's self-contained and executable. Keep all additional code inside the function itself, and only use libraries that were already imported in the problem.\n\n```python\nfrom typing import List, Dict, Tuple\nfrom collections import defaultdict\nfrom typing import List, Dict\n\ndef analyze_social_network(connections: List[Tuple[str, str]], interests: Dict[str, List[str]]) -> Dict[str, List[str]]:\n    \"\"\"\n    A social media platform wants to analyze user connections and suggest new friends based on shared interests.\n    Your task is to create a function that processes user connections and their interests to generate friend suggestions.\n\n    The function takes two parameters:\n    1. connections: A list of tuples representing existing connections between users.\n    2. interests: A dictionary where keys are usernames and values are lists of their interests.\n\n    The function should return a dictionary where keys are usernames and values are lists of suggested friends.\n\n    Rules:\n    1. Suggest friends who are not already connected to the user.\n    2. Suggestions should be based on the number of shared interests (more shared interests = higher priority).\n    3. If two potential suggestions have the same number of shared interests, sort alphabetically by username.\n    4. Each user should have at most 3 friend suggestions.\n    5. Do not suggest users who have no shared interests.\n\n\n    [EXAMPLES]\n    \n    assert candidate([(\"A\", \"B\"), (\"B\", \"C\"), (\"C\", \"D\"), (\"D\", \"E\"), (\"E\", \"A\")], {\"A\": [\"1\"], \"B\": [\"2\"], \"C\": [\"3\"], \"D\": [\"4\"], \"E\": [\"5\"], \"F\": [\"1\", \"2\", \"3\", \"4\", \"5\"]}) == {'A': ['F'], 'B': ['F'], 'C': ['F'], 'D': ['F'], 'E': ['F'], 'F': ['A', 'B', 'C']}\n    assert candidate([(\"1\", \"2\"), (\"3\", \"4\"), (\"5\", \"6\")], {\"1\": [\"x\"], \"2\": [\"y\"], \"3\": [\"z\"], \"4\": [\"w\"], \"5\": [\"v\"], \"6\": [\"u\"], \"7\": [\"x\", \"y\", \"z\", \"w\", \"v\", \"u\"]}) == {'1': ['7'], '2': ['7'], '3': ['7'], '4': ['7'], '5': ['7'], '6': ['7'], '7': ['1', '2', '3']}\n\n    [/EXAMPLES]\n    \"\"\"\n```\n", "entry_point": "analyze_social_network", "solution": "from typing import List, Dict, Tuple\nfrom collections import defaultdict\nfrom typing import List, Dict\n\ndef analyze_social_network(connections: List[Tuple[str, str]], interests: Dict[str, List[str]]) -> Dict[str, List[str]]:\n    \"\"\"\n    A social media platform wants to analyze user connections and suggest new friends based on shared interests.\n    Your task is to create a function that processes user connections and their interests to generate friend suggestions.\n\n    The function takes two parameters:\n    1. connections: A list of tuples representing existing connections between users.\n    2. interests: A dictionary where keys are usernames and values are lists of their interests.\n\n    The function should return a dictionary where keys are usernames and values are lists of suggested friends.\n\n    Rules:\n    1. Suggest friends who are not already connected to the user.\n    2. Suggestions should be based on the number of shared interests (more shared interests = higher priority).\n    3. If two potential suggestions have the same number of shared interests, sort alphabetically by username.\n    4. Each user should have at most 3 friend suggestions.\n    5. Do not suggest users who have no shared interests.\n\n\n    [EXAMPLES]\n    \n    assert candidate([(\"A\", \"B\"), (\"B\", \"C\"), (\"C\", \"D\"), (\"D\", \"E\"), (\"E\", \"A\")], {\"A\": [\"1\"], \"B\": [\"2\"], \"C\": [\"3\"], \"D\": [\"4\"], \"E\": [\"5\"], \"F\": [\"1\", \"2\", \"3\", \"4\", \"5\"]}) == {'A': ['F'], 'B': ['F'], 'C': ['F'], 'D': ['F'], 'E': ['F'], 'F': ['A', 'B', 'C']}\n    assert candidate([(\"1\", \"2\"), (\"3\", \"4\"), (\"5\", \"6\")], {\"1\": [\"x\"], \"2\": [\"y\"], \"3\": [\"z\"], \"4\": [\"w\"], \"5\": [\"v\"], \"6\": [\"u\"], \"7\": [\"x\", \"y\", \"z\", \"w\", \"v\", \"u\"]}) == {'1': ['7'], '2': ['7'], '3': ['7'], '4': ['7'], '5': ['7'], '6': ['7'], '7': ['1', '2', '3']}\n\n    [/EXAMPLES]\n    \"\"\"\n    def get_shared_interests(user1, user2):\n        return len(set(interests[user1]) & set(interests[user2]))\n\n    # Create a set of connections for each user\n    user_connections = defaultdict(set)\n    for user1, user2 in connections:\n        user_connections[user1].add(user2)\n        user_connections[user2].add(user1)\n\n    # Generate suggestions for each user\n    suggestions = {}\n    for user in interests:\n        potential_friends = []\n        for other_user in interests:\n            if other_user != user and other_user not in user_connections[user]:\n                shared = get_shared_interests(user, other_user)\n                if shared > 0:\n                    potential_friends.append((-shared, other_user))\n        \n        # Sort potential friends by shared interests (descending) and then by username\n        potential_friends.sort()\n        suggestions[user] = [friend for _, friend in potential_friends[:3]]\n\n    return suggestions\n\n", "test": "def check(candidate):\n    assert candidate([(\"A\", \"B\"), (\"B\", \"C\"), (\"C\", \"D\"), (\"D\", \"E\")], {\"A\": [\"1\", \"2\", \"3\"], \"B\": [\"2\", \"3\", \"4\"], \"C\": [\"3\", \"4\", \"5\"], \"D\": [\"4\", \"5\", \"6\"], \"E\": [\"5\", \"6\", \"1\"]}) == {'A': ['C', 'E'], 'B': ['D'], 'C': ['A', 'E'], 'D': ['B'], 'E': ['A', 'C']}\n    assert candidate([], {\"A\": [\"1\", \"2\"], \"B\": [\"2\", \"3\"], \"C\": [\"1\", \"3\"]}) == {'A': ['B', 'C'], 'B': ['A', 'C'], 'C': ['A', 'B']}\n    assert candidate([(\"A\", \"B\"), (\"B\", \"C\"), (\"C\", \"D\"), (\"D\", \"E\"), (\"E\", \"A\")], {\"A\": [\"1\"], \"B\": [\"2\"], \"C\": [\"3\"], \"D\": [\"4\"], \"E\": [\"5\"], \"F\": [\"1\", \"2\", \"3\", \"4\", \"5\"]}) == {'A': ['F'], 'B': ['F'], 'C': ['F'], 'D': ['F'], 'E': ['F'], 'F': ['A', 'B', 'C']}\n    assert candidate([(\"X\", \"Y\")], {\"X\": [\"a\", \"b\", \"c\"], \"Y\": [\"d\", \"e\", \"f\"], \"Z\": [\"a\", \"d\"]}) == {'X': ['Z'], 'Y': ['Z'], 'Z': ['X', 'Y']}\n    assert candidate([(\"Alpha\", \"Beta\"), (\"Gamma\", \"Delta\")], {\"Alpha\": [\"1\", \"2\", \"3\"], \"Beta\": [\"2\", \"3\", \"4\"], \"Gamma\": [\"3\", \"4\", \"5\"], \"Delta\": [\"4\", \"5\", \"1\"], \"Epsilon\": [\"5\", \"1\", \"2\"]}) == {'Alpha': ['Epsilon', 'Delta', 'Gamma'], 'Beta': ['Gamma', 'Delta', 'Epsilon'], 'Gamma': ['Beta', 'Alpha', 'Epsilon'], 'Delta': ['Epsilon', 'Alpha', 'Beta'], 'Epsilon': ['Alpha', 'Delta', 'Beta']}\n    assert candidate([(\"A\", \"B\"), (\"C\", \"D\"), (\"E\", \"F\")], {\"A\": [\"1\", \"2\"], \"B\": [\"2\", \"3\"], \"C\": [\"3\", \"4\"], \"D\": [\"4\", \"5\"], \"E\": [\"5\", \"6\"], \"F\": [\"6\", \"1\"], \"G\": [\"1\", \"3\", \"5\"]}) == {'A': ['F', 'G'], 'B': ['C', 'G'], 'C': ['B', 'G'], 'D': ['E', 'G'], 'E': ['D', 'G'], 'F': ['A', 'G'], 'G': ['A', 'B', 'C']}\n    assert candidate([(\"A\", \"B\"), (\"B\", \"C\"), (\"C\", \"D\"), (\"D\", \"E\"), (\"E\", \"F\")], {\"A\": [\"1\", \"2\"], \"B\": [\"2\", \"3\"], \"C\": [\"3\", \"4\"], \"D\": [\"4\", \"5\"], \"E\": [\"5\", \"6\"], \"F\": [\"6\", \"1\"], \"G\": [\"1\", \"3\", \"5\"], \"H\": [\"2\", \"4\", \"6\"]}) == {'A': ['F', 'G', 'H'], 'B': ['G', 'H'], 'C': ['G', 'H'], 'D': ['G', 'H'], 'E': ['G', 'H'], 'F': ['A', 'G', 'H'], 'G': ['A', 'B', 'C'], 'H': ['A', 'B', 'C']}\n    assert candidate([(\"A\", \"B\"), (\"C\", \"D\")], {\"A\": [\"x\", \"y\"], \"B\": [\"y\", \"z\"], \"C\": [\"z\", \"w\"], \"D\": [\"w\", \"x\"], \"E\": [\"x\", \"y\", \"z\", \"w\"]}) == {'A': ['E', 'D'], 'B': ['E', 'C'], 'C': ['E', 'B'], 'D': ['E', 'A'], 'E': ['A', 'B', 'C']}\n    assert candidate([(\"X\", \"Y\"), (\"Y\", \"Z\")], {\"X\": [\"a\", \"b\", \"c\"], \"Y\": [\"b\", \"c\", \"d\"], \"Z\": [\"c\", \"d\", \"e\"], \"W\": [\"a\", \"c\", \"e\"]}) == {'X': ['W', 'Z'], 'Y': ['W'], 'Z': ['W', 'X'], 'W': ['X', 'Z', 'Y']}\n    assert candidate([(\"1\", \"2\"), (\"3\", \"4\"), (\"5\", \"6\")], {\"1\": [\"x\"], \"2\": [\"y\"], \"3\": [\"z\"], \"4\": [\"w\"], \"5\": [\"v\"], \"6\": [\"u\"], \"7\": [\"x\", \"y\", \"z\", \"w\", \"v\", \"u\"]}) == {'1': ['7'], '2': ['7'], '3': ['7'], '4': ['7'], '5': ['7'], '6': ['7'], '7': ['1', '2', '3']}\n", "language": "python"}
{"task_id": "6c799ed7-ad8c-428e-8151-8b49fdd32ae6-3123613977196411267", "prompt": "Complete the function code that meets the requirements in the docstring. Don't modify the function name or parameter list. Provide the entire implementation in one code block.\n\n```python\nfrom typing import List, Tuple\n\ndef optimize_study_schedule(subjects: List[Tuple[str, int, float]]) -> List[str]:\n    \"\"\"\n    A student needs to create an optimal study schedule for their upcoming exams.\n    Each subject is represented by a tuple containing the subject name, difficulty level (1-10),\n    and the number of hours until the exam.\n\n    The function should return a list of subject names in the order they should be studied,\n    based on the following criteria:\n    1. Subjects with exams happening sooner should be prioritized\n    2. If two subjects have exams at the same time, the more difficult subject should be studied first\n    3. If both time and difficulty are the same, maintain the original order\n\n\n    [EXAMPLES]\n    \n    assert candidate([(\"Literature\", 6, 0.25), (\"Grammar\", 5, 0.5), (\"Poetry\", 7, 0.75), (\"Essay Writing\", 8, 1.0)]) == ['Literature', 'Grammar', 'Poetry', 'Essay Writing']\n    assert candidate([(\"Ancient History\", 6, 36.0), (\"Medieval History\", 6, 24.0), (\"Modern History\", 6, 12.0)]) == ['Modern History', 'Medieval History', 'Ancient History']\n\n    [/EXAMPLES]\n    \"\"\"\n```\n", "entry_point": "optimize_study_schedule", "solution": "from typing import List, Tuple\n\ndef optimize_study_schedule(subjects: List[Tuple[str, int, float]]) -> List[str]:\n    \"\"\"\n    A student needs to create an optimal study schedule for their upcoming exams.\n    Each subject is represented by a tuple containing the subject name, difficulty level (1-10),\n    and the number of hours until the exam.\n\n    The function should return a list of subject names in the order they should be studied,\n    based on the following criteria:\n    1. Subjects with exams happening sooner should be prioritized\n    2. If two subjects have exams at the same time, the more difficult subject should be studied first\n    3. If both time and difficulty are the same, maintain the original order\n\n\n    [EXAMPLES]\n    \n    assert candidate([(\"Literature\", 6, 0.25), (\"Grammar\", 5, 0.5), (\"Poetry\", 7, 0.75), (\"Essay Writing\", 8, 1.0)]) == ['Literature', 'Grammar', 'Poetry', 'Essay Writing']\n    assert candidate([(\"Ancient History\", 6, 36.0), (\"Medieval History\", 6, 24.0), (\"Modern History\", 6, 12.0)]) == ['Modern History', 'Medieval History', 'Ancient History']\n\n    [/EXAMPLES]\n    \"\"\"\n    def sort_key(subject):\n        name, difficulty, hours = subject\n        return (hours, -difficulty, subjects.index(subject))\n\n    sorted_subjects = sorted(subjects, key=sort_key)\n    return [subject[0] for subject in sorted_subjects]\n\n", "test": "def check(candidate):\n    assert candidate([(\"Ancient History\", 6, 36.0), (\"Medieval History\", 6, 24.0), (\"Modern History\", 6, 12.0)]) == ['Modern History', 'Medieval History', 'Ancient History']\n    assert candidate([(\"Anatomy\", 8, 18.5), (\"Physiology\", 9, 18.5), (\"Biochemistry\", 10, 18.5)]) == ['Biochemistry', 'Physiology', 'Anatomy']\n    assert candidate([(\"Astronomy\", 7, 168.0), (\"Geology\", 6, 336.0), (\"Meteorology\", 5, 504.0)]) == ['Astronomy', 'Geology', 'Meteorology']\n    assert candidate([(\"History\", 5, 120.0), (\"Geography\", 4, 96.0), (\"Civics\", 3, 72.0), (\"Economics\", 6, 48.0)]) == ['Economics', 'Civics', 'Geography', 'History']\n    assert candidate([(\"Math\", 8, 48.5), (\"History\", 6, 24.0), (\"Physics\", 9, 72.0), (\"Literature\", 5, 24.0)]) == ['History', 'Literature', 'Math', 'Physics']\n    assert candidate([(\"Literature\", 6, 0.25), (\"Grammar\", 5, 0.5), (\"Poetry\", 7, 0.75), (\"Essay Writing\", 8, 1.0)]) == ['Literature', 'Grammar', 'Poetry', 'Essay Writing']\n    assert candidate([(\"English Literature\", 5, 120.0), (\"American Literature\", 5, 120.0), (\"World Literature\", 6, 120.0)]) == ['World Literature', 'English Literature', 'American Literature']\n    assert candidate([(\"Art\", 2, 1.5), (\"Music\", 3, 1.5), (\"Dance\", 4, 1.5)]) == ['Dance', 'Music', 'Art']\n    assert candidate([(\"Spanish\", 5, 12.0), (\"French\", 5, 24.0), (\"German\", 5, 36.0), (\"Italian\", 5, 48.0)]) == ['Spanish', 'French', 'German', 'Italian']\n    assert candidate([(\"Java\", 7, 48.0), (\"Python\", 6, 48.0), (\"C++\", 8, 48.0), (\"JavaScript\", 5, 48.0)]) == ['C++', 'Java', 'Python', 'JavaScript']\n", "language": "python"}
{"task_id": "431b7fa6-c753-4dce-96a5-9e894531bf21-1548756309457188581", "prompt": "Based on the function's docstring, I'll provide the complete implementation in a single code block. My solution will include proper handling of edge cases.\n\n```python\nfrom typing import List\n\ndef optimize_battery_usage(devices: List[int], max_power: int) -> int:\n    \"\"\"\n    A smart home system needs to optimize battery usage for various devices.\n    Each device has a power consumption value, and we need to maximize the\n    number of devices that can be powered simultaneously without exceeding\n    the maximum power capacity of the battery.\n\n    Args:\n    devices (List[int]): A list of power consumption values for each device.\n    max_power (int): The maximum power capacity of the battery.\n\n    Returns:\n    int: The maximum number of devices that can be powered simultaneously.\n\n\n    [EXAMPLES]\n    \n    assert candidate([], 100) == 0\n    assert candidate([3, 3, 3, 3, 3], 12) == 4\n\n    [/EXAMPLES]\n    \"\"\"\n```\n", "entry_point": "optimize_battery_usage", "solution": "from typing import List\n\ndef optimize_battery_usage(devices: List[int], max_power: int) -> int:\n    \"\"\"\n    A smart home system needs to optimize battery usage for various devices.\n    Each device has a power consumption value, and we need to maximize the\n    number of devices that can be powered simultaneously without exceeding\n    the maximum power capacity of the battery.\n\n    Args:\n    devices (List[int]): A list of power consumption values for each device.\n    max_power (int): The maximum power capacity of the battery.\n\n    Returns:\n    int: The maximum number of devices that can be powered simultaneously.\n\n\n    [EXAMPLES]\n    \n    assert candidate([], 100) == 0\n    assert candidate([3, 3, 3, 3, 3], 12) == 4\n\n    [/EXAMPLES]\n    \"\"\"\n    # Sort the devices by power consumption in ascending order\n    sorted_devices = sorted(devices)\n    \n    # Initialize variables\n    total_power = 0\n    device_count = 0\n    \n    # Iterate through the sorted devices\n    for device_power in sorted_devices:\n        # Check if adding this device exceeds the max_power\n        if total_power + device_power <= max_power:\n            # If not, add the device\n            total_power += device_power\n            device_count += 1\n        else:\n            # If adding the device exceeds max_power, stop the loop\n            break\n    \n    return device_count\n\n", "test": "def check(candidate):\n    assert candidate([3, 3, 3, 3, 3], 12) == 4\n    assert candidate([], 100) == 0\n    assert candidate([1, 1, 1, 1, 1, 1, 1, 1, 1, 1], 9) == 9\n    assert candidate([50, 50, 50, 50], 200) == 4\n    assert candidate([1, 1, 1, 1, 1], 5) == 5\n    assert candidate([1, 10, 100, 1000], 1110) == 3\n    assert candidate([1], 1) == 1\n    assert candidate([1, 2, 3, 4, 5], 10) == 4\n    assert candidate([5, 4, 3, 2, 1], 10) == 4\n    assert candidate([7, 14, 21, 28, 35], 70) == 4\n", "language": "python"}
{"task_id": "068521a7-1b27-469b-ba4c-452f6d51b61d-7226623324387266295", "prompt": "Complete the implementation of this function based on the documentation provided. Please provide the code as a single block.\n\n```python\nfrom typing import List, Tuple\n\ndef space_station_stability(modules: List[Tuple[int, int, int]]) -> float:\n    \"\"\"A space station is composed of interconnected modules, each with its own mass and connection strength.\n    We need to calculate the overall stability of the space station based on these modules.\n    \n    Each module is represented by a tuple (mass, left_connection, right_connection).\n    The stability of a module is calculated as: (left_connection + right_connection) / mass\n    The overall stability of the space station is the average stability of all modules.\n    \n    Given a list of modules, return the overall stability of the space station rounded to 2 decimal places.\n    \n\n    [EXAMPLES]\n    \n    assert candidate([(i, i//2, i//2) for i in range(1, 11)]) == 0.82\n    assert candidate([(50, 20, 30), (60, 25, 35), (70, 30, 40), (80, 35, 45)]) == 1.0\n\n    [/EXAMPLES]\n    \"\"\"\n```\n", "entry_point": "space_station_stability", "solution": "from typing import List, Tuple\n\ndef space_station_stability(modules: List[Tuple[int, int, int]]) -> float:\n    \"\"\"A space station is composed of interconnected modules, each with its own mass and connection strength.\n    We need to calculate the overall stability of the space station based on these modules.\n    \n    Each module is represented by a tuple (mass, left_connection, right_connection).\n    The stability of a module is calculated as: (left_connection + right_connection) / mass\n    The overall stability of the space station is the average stability of all modules.\n    \n    Given a list of modules, return the overall stability of the space station rounded to 2 decimal places.\n    \n\n    [EXAMPLES]\n    \n    assert candidate([(i, i//2, i//2) for i in range(1, 11)]) == 0.82\n    assert candidate([(50, 20, 30), (60, 25, 35), (70, 30, 40), (80, 35, 45)]) == 1.0\n\n    [/EXAMPLES]\n    \"\"\"\n    def calculate_module_stability(module: Tuple[int, int, int]) -> float:\n        mass, left_connection, right_connection = module\n        return (left_connection + right_connection) / mass\n\n    total_stability = sum(calculate_module_stability(module) for module in modules)\n    average_stability = total_stability / len(modules)\n    \n    return round(average_stability, 2)\n\n", "test": "def check(candidate):\n    assert candidate([(i, i//2, i//2) for i in range(1, 11)]) == 0.82\n    assert candidate([(1, 0, 1), (2, 1, 1), (3, 1, 2)]) == 1.0\n    assert candidate([(100, 0, 100), (100, 100, 0)]) == 1.0\n    assert candidate([(5, 1, 4), (10, 2, 8), (15, 3, 12)]) == 1.0\n    assert candidate([(200, 100, 150), (150, 80, 120), (180, 90, 110), (120, 70, 100)]) == 1.28\n    assert candidate([(50, 20, 30), (60, 25, 35), (70, 30, 40), (80, 35, 45)]) == 1.0\n    assert candidate([(1, 1, 1)] * 10) == 2.0\n    assert candidate([(1000, 999, 1), (1000, 1, 999)]) == 1.0\n    assert candidate([(1000, 500, 500)]) == 1.0\n    assert candidate([(1, 1, 1), (2, 2, 2), (3, 3, 3), (4, 4, 4), (5, 5, 5)]) == 2.0\n", "language": "python"}
{"task_id": "1b6bd4f5-b739-4eb7-a0cc-13051827eff31523385517562699934", "prompt": "My role is to assist with coding tasks. When you share a function that needs completion, I'll provide a solution that can be executed immediately from a code block. I'll work with the libraries already imported and nest any helper functions inside your main function.\n\n```python\nfrom typing import List\n\ndef analyze_book_chapters(word_counts: List[int], k: int) -> List[int]:\n    \"\"\"\n    An author is analyzing the structure of their book. Each chapter's word count is given in a list.\n    The author wants to find the k most consistent consecutive chapters, where consistency is measured\n    by the difference between the maximum and minimum word counts in the sequence.\n\n    Args:\n    word_counts (List[int]): A list of integers representing the word count of each chapter.\n    k (int): The number of consecutive chapters to consider.\n\n    Returns:\n    List[int]: The starting indices of all sequences of k chapters with the smallest difference\n               between maximum and minimum word counts, sorted in ascending order.\n\n\n    [EXAMPLES]\n    \n    assert candidate([3, 4, 5, 8, 7, 6, 5], 3) == [0, 3, 4]\n    assert candidate([1, 10, 100, 1000, 10000], 2) == [0]\n\n    [/EXAMPLES]\n    \"\"\"\n```\n", "entry_point": "analyze_book_chapters", "solution": "from typing import List\n\ndef analyze_book_chapters(word_counts: List[int], k: int) -> List[int]:\n    \"\"\"\n    An author is analyzing the structure of their book. Each chapter's word count is given in a list.\n    The author wants to find the k most consistent consecutive chapters, where consistency is measured\n    by the difference between the maximum and minimum word counts in the sequence.\n\n    Args:\n    word_counts (List[int]): A list of integers representing the word count of each chapter.\n    k (int): The number of consecutive chapters to consider.\n\n    Returns:\n    List[int]: The starting indices of all sequences of k chapters with the smallest difference\n               between maximum and minimum word counts, sorted in ascending order.\n\n\n    [EXAMPLES]\n    \n    assert candidate([3, 4, 5, 8, 7, 6, 5], 3) == [0, 3, 4]\n    assert candidate([1, 10, 100, 1000, 10000], 2) == [0]\n\n    [/EXAMPLES]\n    \"\"\"\n    if len(word_counts) < k:\n        return []\n\n    def get_difference(start: int) -> int:\n        sequence = word_counts[start:start+k]\n        return max(sequence) - min(sequence)\n\n    min_difference = float('inf')\n    result = []\n\n    for i in range(len(word_counts) - k + 1):\n        current_difference = get_difference(i)\n        \n        if current_difference < min_difference:\n            min_difference = current_difference\n            result = [i]\n        elif current_difference == min_difference:\n            result.append(i)\n\n    return result\n\n", "test": "def check(candidate):\n    assert candidate([1, 10, 100, 1000, 10000], 2) == [0]\n    assert candidate([1, 2, 3, 4, 5, 4, 3, 2, 1], 4) == [2, 3]\n    assert candidate([1, 5, 3, 2, 4], 4) == [1]\n    assert candidate([7, 6, 5, 4, 3, 2, 1], 5) == [0, 1, 2]\n    assert candidate([100, 200, 300, 400, 500], 1) == [0, 1, 2, 3, 4]\n    assert candidate([1, 1, 1, 2, 2, 2, 3, 3, 3], 3) == [0, 3, 6]\n    assert candidate([3, 4, 5, 8, 7, 6, 5], 3) == [0, 3, 4]\n    assert candidate([1, 2], 2) == [0]\n    assert candidate([5, 4, 3, 2, 1, 2, 3, 4, 5], 3) == [3]\n    assert candidate([100, 99, 98, 97, 96, 95, 94, 93, 92, 91], 6) == [0, 1, 2, 3, 4]\n", "language": "python"}
{"task_id": "73aaec6f-035f-4786-90fb-43122c87c61a4920156256699737047", "prompt": "Based on the provided documentation, I'll finish implementing the function. My solution will be in a single code block and will address potential edge cases.\n\n```python\nimport re\nfrom typing import List\n\ndef parse_chemical_formula(formula: str) -> List[tuple]:\n    \"\"\"A chemistry student is developing a program to analyze chemical formulas. The program needs to parse a chemical formula and return a list of its constituent elements along with their quantities.\n\n    The function should take a chemical formula as a string and return a list of tuples, where each tuple contains an element symbol and its quantity in the formula.\n\n    Rules for parsing:\n    1. Element symbols are one or two letters, with the first always capitalized.\n    2. If no number follows an element, assume the quantity is 1.\n    3. Numbers can be multiple digits.\n    4. Parentheses can be used for grouping, with a number after the closing parenthesis multiplying the entire group.\n    5. Nested parentheses are not allowed.\n\n    Return the list of (element, quantity) tuples sorted alphabetically by element.\n\n\n    [EXAMPLES]\n    \n    assert candidate(\"NaHCO3\") == [('C', 1), ('H', 1), ('Na', 1), ('O', 3)]\n    assert candidate(\"H2SO4\") == [('H', 2), ('O', 4), ('S', 1)]\n\n    [/EXAMPLES]\n    \"\"\"\n```\n", "entry_point": "parse_chemical_formula", "solution": "import re\nfrom typing import List\n\ndef parse_chemical_formula(formula: str) -> List[tuple]:\n    \"\"\"A chemistry student is developing a program to analyze chemical formulas. The program needs to parse a chemical formula and return a list of its constituent elements along with their quantities.\n\n    The function should take a chemical formula as a string and return a list of tuples, where each tuple contains an element symbol and its quantity in the formula.\n\n    Rules for parsing:\n    1. Element symbols are one or two letters, with the first always capitalized.\n    2. If no number follows an element, assume the quantity is 1.\n    3. Numbers can be multiple digits.\n    4. Parentheses can be used for grouping, with a number after the closing parenthesis multiplying the entire group.\n    5. Nested parentheses are not allowed.\n\n    Return the list of (element, quantity) tuples sorted alphabetically by element.\n\n\n    [EXAMPLES]\n    \n    assert candidate(\"NaHCO3\") == [('C', 1), ('H', 1), ('Na', 1), ('O', 3)]\n    assert candidate(\"H2SO4\") == [('H', 2), ('O', 4), ('S', 1)]\n\n    [/EXAMPLES]\n    \"\"\"\n    def parse_group(group: str) -> dict:\n        elements = {}\n        matches = re.finditer(r'([A-Z][a-z]?)(\\d*)', group)\n        for match in matches:\n            element, count = match.groups()\n            count = int(count) if count else 1\n            elements[element] = elements.get(element, 0) + count\n        return elements\n\n    def merge_dicts(d1: dict, d2: dict, multiplier: int = 1) -> dict:\n        for k, v in d2.items():\n            d1[k] = d1.get(k, 0) + v * multiplier\n        return d1\n\n    result = {}\n    pattern = r'([A-Z][a-z]?)(\\d*)|\\(([^()]+)\\)(\\d*)'\n    matches = re.finditer(pattern, formula)\n\n    for match in matches:\n        element, count, group, group_count = match.groups()\n        if element:\n            count = int(count) if count else 1\n            result[element] = result.get(element, 0) + count\n        elif group:\n            group_count = int(group_count) if group_count else 1\n            group_elements = parse_group(group)\n            result = merge_dicts(result, group_elements, group_count)\n\n    return sorted([(element, count) for element, count in result.items()])\n\n", "test": "def check(candidate):\n    assert candidate(\"Zn(OH)2\") == [('H', 2), ('O', 2), ('Zn', 1)]\n    assert candidate(\"H2SO4\") == [('H', 2), ('O', 4), ('S', 1)]\n    assert candidate(\"NaHCO3\") == [('C', 1), ('H', 1), ('Na', 1), ('O', 3)]\n    assert candidate(\"Na2CO3\") == [('C', 1), ('Na', 2), ('O', 3)]\n    assert candidate(\"CaCO3\") == [('C', 1), ('Ca', 1), ('O', 3)]\n    assert candidate(\"Mg(OH)2\") == [('H', 2), ('Mg', 1), ('O', 2)]\n    assert candidate(\"Cu(CH3COO)2\") == [('C', 4), ('Cu', 1), ('H', 6), ('O', 4)]\n    assert candidate(\"Ca(NO3)2\") == [('Ca', 1), ('N', 2), ('O', 6)]\n    assert candidate(\"(NH4)2SO4\") == [('H', 8), ('N', 2), ('O', 4), ('S', 1)]\n    assert candidate(\"KMnO4\") == [('K', 1), ('Mn', 1), ('O', 4)]\n", "language": "python"}
{"task_id": "cc7b20df-2b1f-4215-8848-a4fa73f0b2808719974167723636099", "prompt": "Following the docstring guidance, please write the complete function in a single code block. Be sure to handle all edge cases in your implementation.\n\n```python\ndef encode_message(message: str, key: int) -> str:\n    \"\"\"\n    A secret agent needs to encode messages using a custom algorithm.\n    The algorithm works as follows:\n    1. Convert each character to its ASCII value.\n    2. Add the key to the ASCII value.\n    3. Take the result modulo 95 and add 32 to ensure printable characters.\n    4. Convert the resulting number back to a character.\n    Implement this encoding algorithm and return the encoded message.\n    Assume the input message contains only printable ASCII characters (32-126).\n\n\n    [EXAMPLES]\n    \n    assert candidate(\"Hello, World!\", 42) == 'r077:VJ\":=7/K'\n    assert candidate(\"Edge case with key 0\", 0) == 'Edge case with key 0'\n\n    [/EXAMPLES]\n    \"\"\"\n```\n", "entry_point": "encode_message", "solution": "def encode_message(message: str, key: int) -> str:\n    \"\"\"\n    A secret agent needs to encode messages using a custom algorithm.\n    The algorithm works as follows:\n    1. Convert each character to its ASCII value.\n    2. Add the key to the ASCII value.\n    3. Take the result modulo 95 and add 32 to ensure printable characters.\n    4. Convert the resulting number back to a character.\n    Implement this encoding algorithm and return the encoded message.\n    Assume the input message contains only printable ASCII characters (32-126).\n\n\n    [EXAMPLES]\n    \n    assert candidate(\"Hello, World!\", 42) == 'r077:VJ\":=7/K'\n    assert candidate(\"Edge case with key 0\", 0) == 'Edge case with key 0'\n\n    [/EXAMPLES]\n    \"\"\"\n    encoded_message = \"\"\n    for char in message:\n        # Step 1: Convert character to ASCII value\n        ascii_value = ord(char)\n        \n        # Step 2: Add the key to the ASCII value\n        shifted_value = ascii_value + key\n        \n        # Step 3: Take the result modulo 95 and add 32\n        encoded_value = ((shifted_value - 32) % 95) + 32\n        \n        # Step 4: Convert the resulting number back to a character\n        encoded_char = chr(encoded_value)\n        \n        encoded_message += encoded_char\n    \n    return encoded_message\n\n", "test": "def check(candidate):\n    assert candidate(\"!@#$%^&*()\", 30) == '?^ABC|DHFG'\n    assert candidate(\"All printable ASCII chars\", 50) == 's??RCE<AG45?8Rs&u{{R6;4EF'\n    assert candidate(\" \", 10) == '*'\n    assert candidate(\"Mixed 123 !@# Case\", 15) == '\\\\x(ts/@AB/0O2/Rp#t'\n    assert candidate(\"Hello, World!\", 42) == 'r077:VJ\":=7/K'\n    assert candidate(\"Repeated characters: aaabbbccc\", 7) == \"Ylwlh{lk'johyhj{lyzA'hhhiiijjj\"\n    assert candidate(\"Edge case with key 0\", 0) == 'Edge case with key 0'\n    assert candidate(\"ABCDEFGHIJKLMNOPQRSTUVWXYZ\", 2) == 'CDEFGHIJKLMNOPQRSTUVWXYZ[\\\\'\n    assert candidate(\"Max printable ASCII: ~}\", 94) == 'L`w~oqhms`akd~@RBHH9~}|'\n    assert candidate(\"AbCdEfG\", 95) == 'AbCdEfG'\n", "language": "python"}
{"task_id": "9949de18-192f-4ed7-bdf2-273b7b8d78eb-8511176979646180029", "prompt": "Please complete the function implementation based on the provided documentation string. Place the entire function code in a single code block.\n\n```python\ndef calculate_delivery_time(distance: float, traffic_level: str, weather_condition: str) -> int:\n    \"\"\"\n    A food delivery service wants to estimate the delivery time for their orders based on various factors.\n    This function calculates the estimated delivery time in minutes given the distance, traffic level, and weather condition.\n\n    Parameters:\n    - distance: A float representing the distance to the delivery location in kilometers\n    - traffic_level: A string indicating the current traffic level ('light', 'moderate', or 'heavy')\n    - weather_condition: A string describing the weather ('clear', 'rainy', or 'snowy')\n\n    Returns:\n    An integer representing the estimated delivery time in minutes.\n\n\n    [EXAMPLES]\n    \n    assert candidate(3.5, 'heavy', 'rainy') == 23\n    assert candidate(6.8, 'moderate', 'clear') == 27\n\n    [/EXAMPLES]\n    \"\"\"\n```\n", "entry_point": "calculate_delivery_time", "solution": "def calculate_delivery_time(distance: float, traffic_level: str, weather_condition: str) -> int:\n    \"\"\"\n    A food delivery service wants to estimate the delivery time for their orders based on various factors.\n    This function calculates the estimated delivery time in minutes given the distance, traffic level, and weather condition.\n\n    Parameters:\n    - distance: A float representing the distance to the delivery location in kilometers\n    - traffic_level: A string indicating the current traffic level ('light', 'moderate', or 'heavy')\n    - weather_condition: A string describing the weather ('clear', 'rainy', or 'snowy')\n\n    Returns:\n    An integer representing the estimated delivery time in minutes.\n\n\n    [EXAMPLES]\n    \n    assert candidate(3.5, 'heavy', 'rainy') == 23\n    assert candidate(6.8, 'moderate', 'clear') == 27\n\n    [/EXAMPLES]\n    \"\"\"\n    # Base speed in km/h\n    base_speed = 30\n\n    # Adjust speed based on traffic level\n    traffic_factors = {'light': 1.0, 'moderate': 0.8, 'heavy': 0.6}\n    traffic_factor = traffic_factors.get(traffic_level.lower(), 0.8)  # Default to moderate if invalid input\n\n    # Adjust speed based on weather condition\n    weather_factors = {'clear': 1.0, 'rainy': 0.9, 'snowy': 0.7}\n    weather_factor = weather_factors.get(weather_condition.lower(), 1.0)  # Default to clear if invalid input\n\n    # Calculate adjusted speed\n    adjusted_speed = base_speed * traffic_factor * weather_factor\n\n    # Calculate time in hours\n    time_hours = distance / adjusted_speed\n\n    # Convert time to minutes and round up to the nearest integer\n    time_minutes = int(time_hours * 60 + 0.5)\n\n    # Add a fixed 10-minute preparation time\n    total_time = time_minutes + 10\n\n    return total_time\n\n", "test": "def check(candidate):\n    assert candidate(4.2, 'light', 'rainy') == 19\n    assert candidate(0.5, 'light', 'rainy') == 11\n    assert candidate(9.9, 'heavy', 'clear') == 43\n    assert candidate(7.5, 'moderate', 'snowy') == 37\n    assert candidate(18.3, 'light', 'rainy') == 51\n    assert candidate(3.5, 'heavy', 'rainy') == 23\n    assert candidate(0.0, 'light', 'clear') == 10\n    assert candidate(20.0, 'heavy', 'rainy') == 84\n    assert candidate(6.8, 'moderate', 'clear') == 27\n    assert candidate(15.0, 'light', 'clear') == 40\n", "language": "python"}
{"task_id": "705137a2-b7f6-4b0a-b5f5-1109e9ecaf83-5796553944475093615", "prompt": "I'll implement the requested function in one comprehensive code block that can be executed as is. I'll only use libraries that are already imported in the problem statement and will nest any supporting functions or classes within the main function.\n\n```python\ndef encrypt_message(message: str, key: str) -> str:\n    \"\"\"\n    As a cryptography enthusiast, you've developed a new encryption algorithm based on the Vigen\u00e8re cipher\n    with an additional twist. Your algorithm uses a keyword to shift the letters of the message, but also\n    incorporates the position of each letter in the message.\n\n    The function takes two parameters:\n    1. message: A string containing uppercase letters only (A-Z)\n    2. key: A string containing uppercase letters only (A-Z)\n\n    The encryption process works as follows:\n    1. Repeat the key to match the length of the message\n    2. For each letter in the message:\n       a. Calculate the shift value as: (ord(key_letter) - 65 + position) % 26\n       b. Shift the message letter by this value\n       c. If the shift goes beyond 'Z', wrap around to 'A'\n\n    Return the encrypted message as a string.\n\n\n    [EXAMPLES]\n    \n    assert candidate(\"ABCDE\", \"VWXYZ\") == 'VYBEH'\n    assert candidate(\"ALLTHESAMECHARACTER\", \"XXXXXXXXXXXXXXXXXXXXXXX\") == 'XJKTIGVERKJPJBLOGSG'\n\n    [/EXAMPLES]\n    \"\"\"\n```\n", "entry_point": "encrypt_message", "solution": "def encrypt_message(message: str, key: str) -> str:\n    \"\"\"\n    As a cryptography enthusiast, you've developed a new encryption algorithm based on the Vigen\u00e8re cipher\n    with an additional twist. Your algorithm uses a keyword to shift the letters of the message, but also\n    incorporates the position of each letter in the message.\n\n    The function takes two parameters:\n    1. message: A string containing uppercase letters only (A-Z)\n    2. key: A string containing uppercase letters only (A-Z)\n\n    The encryption process works as follows:\n    1. Repeat the key to match the length of the message\n    2. For each letter in the message:\n       a. Calculate the shift value as: (ord(key_letter) - 65 + position) % 26\n       b. Shift the message letter by this value\n       c. If the shift goes beyond 'Z', wrap around to 'A'\n\n    Return the encrypted message as a string.\n\n\n    [EXAMPLES]\n    \n    assert candidate(\"ABCDE\", \"VWXYZ\") == 'VYBEH'\n    assert candidate(\"ALLTHESAMECHARACTER\", \"XXXXXXXXXXXXXXXXXXXXXXX\") == 'XJKTIGVERKJPJBLOGSG'\n\n    [/EXAMPLES]\n    \"\"\"\n    def shift_letter(letter: str, shift: int) -> str:\n        \"\"\"Shifts a letter by the given amount, wrapping around if necessary.\"\"\"\n        return chr((ord(letter) - 65 + shift) % 26 + 65)\n\n    # Repeat the key to match the length of the message\n    extended_key = (key * (len(message) // len(key) + 1))[:len(message)]\n\n    encrypted = \"\"\n    for position, (message_char, key_char) in enumerate(zip(message, extended_key)):\n        # Calculate the shift value\n        shift = (ord(key_char) - 65 + position) % 26\n        # Shift the message letter and add to the encrypted message\n        encrypted += shift_letter(message_char, shift)\n\n    return encrypted\n\n", "test": "def check(candidate):\n    assert candidate(\"REPEATINGKEY\", \"AAA\") == 'RFRHEYOUOTOJ'\n    assert candidate(\"ALLTHESAMECHARACTER\", \"XXXXXXXXXXXXXXXXXXXXXXX\") == 'XJKTIGVERKJPJBLOGSG'\n    assert candidate(\"NOMESSAGE\", \"NOKEY\") == 'ADYLUKUXQ'\n    assert candidate(\"SECRETMESSAGE\", \"TOPSECRET\") == 'LTTMMAJPTUYGI'\n    assert candidate(\"UPPERCASELETTERSONLY\", \"MIXEDCASE\") == 'GYOLYJGRQGWBJUHHWIPZ'\n    assert candidate(\"SINGLECHARACTER\", \"S\") == 'KBHBHBAGASCFXJX'\n    assert candidate(\"ZZZZZ\", \"YYYYY\") == 'XYZAB'\n    assert candidate(\"ABCDE\", \"VWXYZ\") == 'VYBEH'\n    assert candidate(\"AVERYLONGMESSAGETHATGOESONONANDONFOREVER\", \"TINYKEYWORD\") == 'TETSMUSQCMRWMASDNWOARMTXZKYSAMVKWFENMQUC'\n    assert candidate(\"LONGESTMESSAGEEVERWRITTENINTHISEXAMPLE\", \"SHORT\") == 'DWDABPGHDUUSGILCBWFDUVDSEZUIAEOQRYNQCD'\n", "language": "python"}
{"task_id": "5d28778b-d236-4de4-ba02-6ffade064a53-3595328864831218781", "prompt": "I serve as a coding assistant. My role is to provide completed functions in executable code blocks. I'll only use libraries that are already imported in the problem and will ensure that any auxiliary functions or classes are defined within the main function. The code I deliver will be ready to run as is.\n\n```python\nfrom typing import List\n\ndef find_longest_increasing_subsequence(nums: List[int]) -> List[int]:\n    \"\"\"\n    In a geological survey of mountain ranges, scientists want to identify the longest\n    chain of increasing peak heights. Given a list of mountain peak heights, find the\n    longest strictly increasing subsequence of heights. Return the subsequence as a list.\n\n\n    [EXAMPLES]\n    \n    assert candidate([3, 10, 2, 1, 20]) == [3, 10, 20]\n    assert candidate([1]) == [1]\n\n    [/EXAMPLES]\n    \"\"\"\n```\n", "entry_point": "find_longest_increasing_subsequence", "solution": "from typing import List\n\ndef find_longest_increasing_subsequence(nums: List[int]) -> List[int]:\n    \"\"\"\n    In a geological survey of mountain ranges, scientists want to identify the longest\n    chain of increasing peak heights. Given a list of mountain peak heights, find the\n    longest strictly increasing subsequence of heights. Return the subsequence as a list.\n\n\n    [EXAMPLES]\n    \n    assert candidate([3, 10, 2, 1, 20]) == [3, 10, 20]\n    assert candidate([1]) == [1]\n\n    [/EXAMPLES]\n    \"\"\"\n    if not nums:\n        return []\n\n    n = len(nums)\n    # dp[i] stores the length of the longest increasing subsequence ending at index i\n    dp = [1] * n\n    # prev[i] stores the index of the previous element in the longest increasing subsequence\n    prev = [-1] * n\n\n    # Find the length of the longest increasing subsequence\n    for i in range(1, n):\n        for j in range(i):\n            if nums[i] > nums[j] and dp[i] < dp[j] + 1:\n                dp[i] = dp[j] + 1\n                prev[i] = j\n\n    # Find the index of the last element in the longest increasing subsequence\n    max_length = max(dp)\n    end_index = dp.index(max_length)\n\n    # Reconstruct the longest increasing subsequence\n    result = []\n    while end_index != -1:\n        result.append(nums[end_index])\n        end_index = prev[end_index]\n\n    return result[::-1]  # Reverse the list to get the correct order\n\n", "test": "def check(candidate):\n    assert candidate([3, 10, 2, 1, 20]) == [3, 10, 20]\n    assert candidate([-1, 0, 1, -2, -1, 0, 1, 2]) == [-2, -1, 0, 1, 2]\n    assert candidate([]) == []\n    assert candidate([4, 3, 2, 1]) == [4]\n    assert candidate([1, 2]) == [1, 2]\n    assert candidate([5, 4, 3, 2, 1]) == [5]\n    assert candidate([1, 2, 3, 2, 3, 4, 3, 4, 5, 4, 5, 6]) == [1, 2, 3, 4, 5, 6]\n    assert candidate([1]) == [1]\n    assert candidate([1, 1, 1, 1]) == [1]\n    assert candidate([0, 1, 0, 3, 2, 3]) == [0, 1, 2, 3]\n", "language": "python"}
{"task_id": "dd88af44-9e10-4a14-9fff-c80b14b6c100-9012870484126453097", "prompt": "Complete this function implementation according to the specifications in the docstring. Present your solution as one unified code block, preserving the original function name and parameter list.\n\n```python\nfrom typing import List, Tuple\n\ndef eco_friendly_route(grid: List[List[int]]) -> List[Tuple[int, int]]:\n    \"\"\"\n    In a futuristic eco-city, autonomous vehicles navigate through a grid-based\n    layout. Each cell in the grid represents a block, and the value in the cell\n    indicates the amount of green energy available for the vehicle to harvest.\n\n    Find the most eco-friendly route from the top-left corner to the bottom-right\n    corner of the city grid, maximizing the total green energy collected.\n\n    The function takes one parameter:\n    - grid: A 2D list representing the city layout and available green energy\n\n    Return a list of tuples representing the coordinates of the chosen path.\n\n\n    [EXAMPLES]\n    \n    assert candidate([[9, 9, 9], [9, 1, 9], [9, 9, 9]]) == [(0, 0), (1, 0), (2, 0), (2, 1), (2, 2)]\n    assert candidate([[0, 1, 0], [1, 0, 1], [0, 1, 0]]) == [(0, 0), (1, 0), (2, 0), (2, 1), (2, 2)]\n\n    [/EXAMPLES]\n    \"\"\"\n```\n", "entry_point": "eco_friendly_route", "solution": "from typing import List, Tuple\n\ndef eco_friendly_route(grid: List[List[int]]) -> List[Tuple[int, int]]:\n    \"\"\"\n    In a futuristic eco-city, autonomous vehicles navigate through a grid-based\n    layout. Each cell in the grid represents a block, and the value in the cell\n    indicates the amount of green energy available for the vehicle to harvest.\n\n    Find the most eco-friendly route from the top-left corner to the bottom-right\n    corner of the city grid, maximizing the total green energy collected.\n\n    The function takes one parameter:\n    - grid: A 2D list representing the city layout and available green energy\n\n    Return a list of tuples representing the coordinates of the chosen path.\n\n\n    [EXAMPLES]\n    \n    assert candidate([[9, 9, 9], [9, 1, 9], [9, 9, 9]]) == [(0, 0), (1, 0), (2, 0), (2, 1), (2, 2)]\n    assert candidate([[0, 1, 0], [1, 0, 1], [0, 1, 0]]) == [(0, 0), (1, 0), (2, 0), (2, 1), (2, 2)]\n\n    [/EXAMPLES]\n    \"\"\"\n    if not grid or not grid[0]:\n        return []\n\n    rows, cols = len(grid), len(grid[0])\n    \n    # Create a dp table to store maximum energy at each cell\n    dp = [[0] * cols for _ in range(rows)]\n    \n    # Create a table to store the previous cell for backtracking\n    prev = [[None] * cols for _ in range(rows)]\n    \n    # Initialize the first cell\n    dp[0][0] = grid[0][0]\n    \n    # Fill the first row\n    for j in range(1, cols):\n        dp[0][j] = dp[0][j-1] + grid[0][j]\n        prev[0][j] = (0, j-1)\n    \n    # Fill the first column\n    for i in range(1, rows):\n        dp[i][0] = dp[i-1][0] + grid[i][0]\n        prev[i][0] = (i-1, 0)\n    \n    # Fill the rest of the dp table\n    for i in range(1, rows):\n        for j in range(1, cols):\n            if dp[i-1][j] > dp[i][j-1]:\n                dp[i][j] = dp[i-1][j] + grid[i][j]\n                prev[i][j] = (i-1, j)\n            else:\n                dp[i][j] = dp[i][j-1] + grid[i][j]\n                prev[i][j] = (i, j-1)\n    \n    # Backtrack to find the path\n    path = []\n    i, j = rows-1, cols-1\n    while i >= 0 and j >= 0:\n        path.append((i, j))\n        if prev[i][j] is None:\n            break\n        i, j = prev[i][j]\n    \n    # Reverse the path to get from start to end\n    return list(reversed(path))\n\n", "test": "def check(candidate):\n    assert candidate([[9, 9, 9], [9, 1, 9], [9, 9, 9]]) == [(0, 0), (1, 0), (2, 0), (2, 1), (2, 2)]\n    assert candidate([[5, 4, 3], [2, 1, 0], [0, 0, 0]]) == [(0, 0), (0, 1), (0, 2), (1, 2), (2, 2)]\n    assert candidate([[1, 2, 3, 4], [5, 6, 7, 8], [9, 10, 11, 12]]) == [(0, 0), (1, 0), (2, 0), (2, 1), (2, 2), (2, 3)]\n    assert candidate([[1, 1, 1], [1, 9, 1], [1, 1, 1]]) == [(0, 0), (1, 0), (1, 1), (2, 1), (2, 2)]\n    assert candidate([[1, 1, 1], [1, 2, 1], [1, 1, 1]]) == [(0, 0), (1, 0), (1, 1), (2, 1), (2, 2)]\n    assert candidate([[1, 2, 3], [4, 5, 6], [7, 8, 9]]) == [(0, 0), (1, 0), (2, 0), (2, 1), (2, 2)]\n    assert candidate([[0, 1, 0], [1, 0, 1], [0, 1, 0]]) == [(0, 0), (1, 0), (2, 0), (2, 1), (2, 2)]\n    assert candidate([[1, 2, 3, 4, 5], [6, 7, 8, 9, 10]]) == [(0, 0), (1, 0), (1, 1), (1, 2), (1, 3), (1, 4)]\n    assert candidate([[0, 0, 0], [0, 0, 0], [0, 0, 0]]) == [(0, 0), (1, 0), (2, 0), (2, 1), (2, 2)]\n    assert candidate([[1, 1], [1, 1]]) == [(0, 0), (1, 0), (1, 1)]\n", "language": "python"}
{"task_id": "cc000b57-2e6d-4c10-af01-2e906c746cf7622311325852573919", "prompt": "Please complete the specified function so it can be run as-is in a single code block. Only use libraries that are imported in the problem statement. Any additional helper functions or classes should be defined inside the main function. Provide exactly one code block in your solution with no code outside of it.\n\n```python\nfrom typing import List, Tuple\n\ndef space_station_reconfig(n: int, modules: List[Tuple[int, int]]) -> int:\n    \"\"\"\n    In a futuristic space station, you are tasked with reconfiguring the modular living quarters.\n    Each module has a unique size and power requirement. The station's power grid can only support\n    a specific total power draw, and you need to maximize the total size of the living space while\n    staying within the power constraints.\n\n    This function uses dynamic programming to solve the 0/1 knapsack problem, determining the\n    optimal configuration of modules to install.\n\n    Parameters:\n    n (int): The maximum power draw the station can support\n    modules (List[Tuple[int, int]]): A list of tuples, where each tuple contains (size, power_draw) for a module\n\n    Returns:\n    int: The maximum total size of modules that can be installed without exceeding the power limit\n\n\n    [EXAMPLES]\n    \n    assert candidate(20, [(8, 4), (10, 5), (15, 8), (4, 2), (7, 3), (9, 4)]) == 41\n    assert candidate(1000, [(100, 50), (200, 100), (300, 150), (400, 200), (500, 250)]) == 1500\n\n    [/EXAMPLES]\n    \"\"\"\n```\n", "entry_point": "space_station_reconfig", "solution": "from typing import List, Tuple\n\ndef space_station_reconfig(n: int, modules: List[Tuple[int, int]]) -> int:\n    \"\"\"\n    In a futuristic space station, you are tasked with reconfiguring the modular living quarters.\n    Each module has a unique size and power requirement. The station's power grid can only support\n    a specific total power draw, and you need to maximize the total size of the living space while\n    staying within the power constraints.\n\n    This function uses dynamic programming to solve the 0/1 knapsack problem, determining the\n    optimal configuration of modules to install.\n\n    Parameters:\n    n (int): The maximum power draw the station can support\n    modules (List[Tuple[int, int]]): A list of tuples, where each tuple contains (size, power_draw) for a module\n\n    Returns:\n    int: The maximum total size of modules that can be installed without exceeding the power limit\n\n\n    [EXAMPLES]\n    \n    assert candidate(20, [(8, 4), (10, 5), (15, 8), (4, 2), (7, 3), (9, 4)]) == 41\n    assert candidate(1000, [(100, 50), (200, 100), (300, 150), (400, 200), (500, 250)]) == 1500\n\n    [/EXAMPLES]\n    \"\"\"\n    # Create a 2D table for dynamic programming\n    dp = [[0 for _ in range(n + 1)] for _ in range(len(modules) + 1)]\n    \n    # Fill the dp table\n    for i in range(1, len(modules) + 1):\n        for j in range(1, n + 1):\n            size, power = modules[i-1]\n            if power <= j:\n                dp[i][j] = max(dp[i-1][j], dp[i-1][j-power] + size)\n            else:\n                dp[i][j] = dp[i-1][j]\n    \n    # Return the maximum size that can be achieved\n    return dp[len(modules)][n]\n\n", "test": "def check(candidate):\n    assert candidate(1000, [(100, 50), (200, 100), (300, 150), (400, 200), (500, 250)]) == 1500\n    assert candidate(15, [(10, 5), (15, 8), (7, 4), (12, 6), (5, 2)]) == 30\n    assert candidate(100, [(50, 30), (60, 40), (70, 50), (80, 60), (90, 70)]) == 140\n    assert candidate(50, [(10, 8), (15, 12), (20, 15), (25, 20), (30, 25), (35, 30)]) == 60\n    assert candidate(20, [(8, 4), (10, 5), (15, 8), (4, 2), (7, 3), (9, 4)]) == 41\n    assert candidate(1, [(1, 1)]) == 1\n    assert candidate(30, [(15, 10), (25, 20), (35, 30)]) == 40\n    assert candidate(10, [(5, 3), (3, 2), (8, 5), (4, 1)]) == 17\n    assert candidate(5, [(3, 2), (4, 3), (5, 4)]) == 7\n    assert candidate(75, [(12, 6), (18, 9), (24, 12), (30, 15), (36, 18), (42, 21), (48, 24)]) == 150\n", "language": "python"}
{"task_id": "f9138a15-9175-4629-90e0-bfafc16f41488123988686772340424", "prompt": "I'll finish implementing this function as specified in the documentation. The complete solution will be in one code block, with consideration for edge cases.\n\n```python\nfrom typing import List\n\ndef analyze_stock_trends(prices: List[float], window_size: int) -> List[str]:\n    \"\"\"\n    Analyze stock price trends and categorize them based on moving averages.\n\n    This function takes a list of daily stock prices and a window size for calculating\n    moving averages. It then categorizes each day's trend as 'Bullish', 'Bearish', or 'Neutral'\n    based on the relationship between the current price and its moving average.\n\n    Args:\n    prices (List[float]): A list of daily stock prices.\n    window_size (int): The number of days to use for calculating the moving average.\n\n    Returns:\n    List[str]: A list of trend categories ('Bullish', 'Bearish', or 'Neutral') for each day.\n\n\n    [EXAMPLES]\n    \n    assert candidate([500, 502, 498, 503, 505, 501, 499], 3) == ['Neutral', 'Neutral', 'Bearish', 'Bullish', 'Bullish', 'Bearish', 'Bearish']\n    assert candidate([75.5, 76.0, 75.8, 76.2, 76.5, 76.3, 76.7, 76.9], 3) == ['Neutral', 'Neutral', 'Bullish', 'Bullish', 'Bullish', 'Bearish', 'Bullish', 'Bullish']\n\n    [/EXAMPLES]\n    \"\"\"\n```\n", "entry_point": "analyze_stock_trends", "solution": "from typing import List\n\ndef analyze_stock_trends(prices: List[float], window_size: int) -> List[str]:\n    \"\"\"\n    Analyze stock price trends and categorize them based on moving averages.\n\n    This function takes a list of daily stock prices and a window size for calculating\n    moving averages. It then categorizes each day's trend as 'Bullish', 'Bearish', or 'Neutral'\n    based on the relationship between the current price and its moving average.\n\n    Args:\n    prices (List[float]): A list of daily stock prices.\n    window_size (int): The number of days to use for calculating the moving average.\n\n    Returns:\n    List[str]: A list of trend categories ('Bullish', 'Bearish', or 'Neutral') for each day.\n\n\n    [EXAMPLES]\n    \n    assert candidate([500, 502, 498, 503, 505, 501, 499], 3) == ['Neutral', 'Neutral', 'Bearish', 'Bullish', 'Bullish', 'Bearish', 'Bearish']\n    assert candidate([75.5, 76.0, 75.8, 76.2, 76.5, 76.3, 76.7, 76.9], 3) == ['Neutral', 'Neutral', 'Bullish', 'Bullish', 'Bullish', 'Bearish', 'Bullish', 'Bullish']\n\n    [/EXAMPLES]\n    \"\"\"\n    def calculate_moving_average(index: int) -> float:\n        \"\"\"Calculate the moving average for a given index.\"\"\"\n        if index < window_size - 1:\n            return sum(prices[:index + 1]) / (index + 1)\n        return sum(prices[index - window_size + 1 : index + 1]) / window_size\n\n    trends = []\n\n    for i in range(len(prices)):\n        if i < window_size - 1:\n            trends.append('Neutral')\n        else:\n            moving_avg = calculate_moving_average(i)\n            current_price = prices[i]\n\n            if current_price > moving_avg:\n                trends.append('Bullish')\n            elif current_price < moving_avg:\n                trends.append('Bearish')\n            else:\n                trends.append('Neutral')\n\n    return trends\n\n", "test": "def check(candidate):\n    assert candidate([200, 195, 190, 185, 180, 175, 170], 3) == ['Neutral', 'Neutral', 'Bearish', 'Bearish', 'Bearish', 'Bearish', 'Bearish']\n    assert candidate([500, 502, 498, 503, 505, 501, 499], 3) == ['Neutral', 'Neutral', 'Bearish', 'Bullish', 'Bullish', 'Bearish', 'Bearish']\n    assert candidate([0.1, 0.2, 0.3, 0.4, 0.5, 0.4, 0.3, 0.2, 0.1], 3) == ['Neutral', 'Neutral', 'Bullish', 'Bullish', 'Bullish', 'Bearish', 'Bearish', 'Bearish', 'Bearish']\n    assert candidate([75.5, 76.0, 75.8, 76.2, 76.5, 76.3, 76.7, 76.9], 3) == ['Neutral', 'Neutral', 'Bullish', 'Bullish', 'Bullish', 'Bearish', 'Bullish', 'Bullish']\n    assert candidate([1000, 1000, 1000, 1000, 1001, 999, 1000], 4) == ['Neutral', 'Neutral', 'Neutral', 'Neutral', 'Bullish', 'Bearish', 'Neutral']\n    assert candidate([1.5, 1.6, 1.7, 1.8, 1.9, 2.0], 2) == ['Neutral', 'Bullish', 'Bullish', 'Bullish', 'Bullish', 'Bullish']\n    assert candidate([10, 20, 30, 40, 50, 60, 70, 80, 90, 100], 5) == ['Neutral', 'Neutral', 'Neutral', 'Neutral', 'Bullish', 'Bullish', 'Bullish', 'Bullish', 'Bullish', 'Bullish']\n    assert candidate([50.0, 51.0, 49.5, 52.0, 53.5, 52.8, 54.0, 53.2], 4) == ['Neutral', 'Neutral', 'Neutral', 'Bullish', 'Bullish', 'Bullish', 'Bullish', 'Bearish']\n    assert candidate([25.5, 26.0, 26.5, 26.2, 26.8, 27.1, 27.0, 26.9], 3) == ['Neutral', 'Neutral', 'Bullish', 'Bearish', 'Bullish', 'Bullish', 'Bullish', 'Bearish']\n    assert candidate([100, 100, 100, 100, 100], 2) == ['Neutral', 'Neutral', 'Neutral', 'Neutral', 'Neutral']\n", "language": "python"}
{"task_id": "9afebcfb-78b9-4241-bc78-1bb3487a294b5713484474643210739", "prompt": "Your solution should be a complete, self-contained function in a single code block. Include necessary imports within the function itself. Any helper functions or classes should be nested inside the main function. Provide exactly one code block with no additional code outside of it.\n\n```python\ndef count_treasure_paths(n: int, m: int) -> int:\n    \"\"\"\n    You're an adventurer in a rectangular cave system with n rows and m columns. \n    You start at the top-left corner (0,0) and want to reach the treasure at the \n    bottom-right corner (n-1, m-1). You can only move right or down.\n\n    Calculate the number of unique paths to reach the treasure.\n\n\n    [EXAMPLES]\n    \n    assert candidate(3, 2) == 3\n    assert candidate(1, 5) == 1\n\n    [/EXAMPLES]\n    \"\"\"\n```\n", "entry_point": "count_treasure_paths", "solution": "def count_treasure_paths(n: int, m: int) -> int:\n    \"\"\"\n    You're an adventurer in a rectangular cave system with n rows and m columns. \n    You start at the top-left corner (0,0) and want to reach the treasure at the \n    bottom-right corner (n-1, m-1). You can only move right or down.\n\n    Calculate the number of unique paths to reach the treasure.\n\n\n    [EXAMPLES]\n    \n    assert candidate(3, 2) == 3\n    assert candidate(1, 5) == 1\n\n    [/EXAMPLES]\n    \"\"\"\n    # Create a 2D list to store the number of paths for each cell\n    dp = [[1 for _ in range(m)] for _ in range(n)]\n\n    # Fill the dp table\n    for i in range(1, n):\n        for j in range(1, m):\n            # Number of paths to current cell is sum of paths from above and left\n            dp[i][j] = dp[i-1][j] + dp[i][j-1]\n\n    # Return the number of paths to the bottom-right corner\n    return dp[n-1][m-1]\n\n", "test": "def check(candidate):\n    assert candidate(100, 1) == 1\n    assert candidate(1, 100) == 1\n    assert candidate(20, 20) == 35345263800\n    assert candidate(2, 2) == 2\n    assert candidate(4, 4) == 20\n    assert candidate(1, 5) == 1\n    assert candidate(3, 2) == 3\n    assert candidate(3, 4) == 10\n    assert candidate(2, 3) == 3\n    assert candidate(25, 25) == 32247603683100\n", "language": "python"}
{"task_id": "cb346da7-f700-47f0-9aa4-135296671b48-4771974721467651144", "prompt": "Based on the documentation provided, please complete the function in a single code block. Be sure to account for any possible edge cases in your implementation.\n\n```python\nfrom typing import List\n\ndef optimize_garden(plants: List[int], max_water: int) -> int:\n    \"\"\"\n    A botanist is designing a garden with various plants. Each plant requires a specific amount of water daily.\n    The botanist wants to maximize the number of plants in the garden while staying within the daily water limit.\n\n    This function takes a list of water requirements for different plants and the maximum amount of water\n    available daily. It returns the maximum number of plants that can be included in the garden.\n\n    Args:\n    plants (List[int]): A list of integers representing the water requirements for each plant.\n    max_water (int): The maximum amount of water available daily.\n\n    Returns:\n    int: The maximum number of plants that can be included in the garden.\n\n\n    [EXAMPLES]\n    \n    assert candidate([2, 2, 2, 2, 2], 8) == 4\n    assert candidate([1], 1) == 1\n\n    [/EXAMPLES]\n    \"\"\"\n```\n", "entry_point": "optimize_garden", "solution": "from typing import List\n\ndef optimize_garden(plants: List[int], max_water: int) -> int:\n    \"\"\"\n    A botanist is designing a garden with various plants. Each plant requires a specific amount of water daily.\n    The botanist wants to maximize the number of plants in the garden while staying within the daily water limit.\n\n    This function takes a list of water requirements for different plants and the maximum amount of water\n    available daily. It returns the maximum number of plants that can be included in the garden.\n\n    Args:\n    plants (List[int]): A list of integers representing the water requirements for each plant.\n    max_water (int): The maximum amount of water available daily.\n\n    Returns:\n    int: The maximum number of plants that can be included in the garden.\n\n\n    [EXAMPLES]\n    \n    assert candidate([2, 2, 2, 2, 2], 8) == 4\n    assert candidate([1], 1) == 1\n\n    [/EXAMPLES]\n    \"\"\"\n    # Sort the plants by their water requirements in ascending order\n    sorted_plants = sorted(plants)\n    \n    total_water = 0\n    plant_count = 0\n    \n    # Iterate through the sorted plants\n    for water_req in sorted_plants:\n        # If adding this plant doesn't exceed the max_water limit\n        if total_water + water_req <= max_water:\n            total_water += water_req\n            plant_count += 1\n        else:\n            # We can't add any more plants without exceeding the limit\n            break\n    \n    return plant_count\n\n", "test": "def check(candidate):\n    assert candidate([1, 1, 1, 1, 100], 4) == 4\n    assert candidate([1, 10, 100, 1000, 10000], 1111) == 4\n    assert candidate([10, 10, 10, 10, 10], 50) == 5\n    assert candidate([1, 2, 3, 4, 5], 15) == 5\n    assert candidate([2, 2, 2, 2, 2], 8) == 4\n    assert candidate([1, 3, 5, 7, 9], 25) == 5\n    assert candidate([1], 1) == 1\n    assert candidate([1, 2, 3, 4, 5], 10) == 4\n    assert candidate([], 10) == 0\n    assert candidate([1, 2, 3, 4, 5], 5) == 2\n", "language": "python"}
{"task_id": "0911de5e-17c3-4eeb-baad-92aff5e23f36247169691038140751", "prompt": "I'll write the implementation for the function following the specifications in the docstring. The function name and arguments will remain unchanged, and I'll provide the complete code in one code block.\n\n```python\nfrom typing import List\n\ndef optimize_delivery_route(packages: List[List[int]], fuel: int) -> int:\n    \"\"\"\n    A delivery company wants to optimize their route to deliver as many packages as possible with\n    a limited amount of fuel. Each package has a weight and a fuel requirement for delivery. The\n    function should return the maximum number of packages that can be delivered given the\n    available fuel.\n\n    Args:\n    packages (List[List[int]]): A list of lists where each inner list contains two integers -\n                                the weight of the package and the fuel required to deliver it.\n    fuel (int): The total amount of fuel available.\n\n    Returns:\n    int: The maximum number of packages that can be delivered.\n\n\n    [EXAMPLES]\n    \n    assert candidate([[1, 1], [1, 2], [1, 3], [1, 4], [1, 5]], 10) == 4\n    assert candidate([[5, 5], [5, 5], [5, 5], [5, 5], [5, 5]], 24) == 4\n\n    [/EXAMPLES]\n    \"\"\"\n```\n", "entry_point": "optimize_delivery_route", "solution": "from typing import List\n\ndef optimize_delivery_route(packages: List[List[int]], fuel: int) -> int:\n    \"\"\"\n    A delivery company wants to optimize their route to deliver as many packages as possible with\n    a limited amount of fuel. Each package has a weight and a fuel requirement for delivery. The\n    function should return the maximum number of packages that can be delivered given the\n    available fuel.\n\n    Args:\n    packages (List[List[int]]): A list of lists where each inner list contains two integers -\n                                the weight of the package and the fuel required to deliver it.\n    fuel (int): The total amount of fuel available.\n\n    Returns:\n    int: The maximum number of packages that can be delivered.\n\n\n    [EXAMPLES]\n    \n    assert candidate([[1, 1], [1, 2], [1, 3], [1, 4], [1, 5]], 10) == 4\n    assert candidate([[5, 5], [5, 5], [5, 5], [5, 5], [5, 5]], 24) == 4\n\n    [/EXAMPLES]\n    \"\"\"\n    def knapsack(items, capacity):\n        n = len(items)\n        dp = [[0 for _ in range(capacity + 1)] for _ in range(n + 1)]\n\n        for i in range(1, n + 1):\n            for w in range(capacity + 1):\n                if items[i-1][1] <= w:\n                    dp[i][w] = max(dp[i-1][w], dp[i-1][w-items[i-1][1]] + 1)\n                else:\n                    dp[i][w] = dp[i-1][w]\n\n        return dp[n][capacity]\n\n    # Sort packages by fuel requirement (ascending)\n    sorted_packages = sorted(packages, key=lambda x: x[1])\n\n    return knapsack(sorted_packages, fuel)\n\n", "test": "def check(candidate):\n    assert candidate([[1, 2]], 1) == 0\n    assert candidate([[1, 1], [2, 2], [3, 3], [4, 4], [5, 5]], 10) == 4\n    assert candidate([[10, 1], [20, 2], [30, 3], [40, 4], [50, 5]], 15) == 5\n    assert candidate([[10, 5], [2, 2], [3, 3], [4, 4]], 10) == 3\n    assert candidate([[100, 100]], 99) == 0\n    assert candidate([[10, 1], [9, 2], [8, 3], [7, 4], [6, 5]], 15) == 5\n    assert candidate([[5, 5], [5, 5], [5, 5], [5, 5], [5, 5]], 24) == 4\n    assert candidate([[1, 1], [1, 2], [1, 3], [1, 4], [1, 5]], 10) == 4\n    assert candidate([[1, 1], [1, 1], [1, 1], [1, 1], [1, 1]], 5) == 5\n    assert candidate([[100, 100]], 100) == 1\n", "language": "python"}
{"task_id": "ca260438-53f7-40ff-983e-73945da2104d7409651252988474655", "prompt": "You are a coding assistant. Your job is to complete provided functions in a way they're ready to run in a code block. Stick to the imported libraries only and don't provide any code outside the function. If you need additional helper functions or classes, define them within the main function.\n\n```python\nimport functools\nfrom typing import List, Tuple\n\ndef calculate_ecosystem_stability(species: List[Tuple[str, int, List[str]]]) -> float:\n    \"\"\"\n    As an ecologist, I need to calculate the stability index of an ecosystem based on species interactions.\n    \n    Given a list of tuples representing species (name, population, list of species it interacts with),\n    calculate the ecosystem stability index.\n    \n    The stability index is calculated as follows:\n    1. Start with a base stability of 1.0\n    2. For each species, calculate its contribution: (population * number of interactions) / 100\n    3. Add the contribution to the stability index if the number of interactions is odd\n    4. Subtract the contribution from the stability index if the number of interactions is even\n    5. If a species interacts with itself, double its contribution (positive or negative)\n    \n    Use functools.reduce to calculate the final stability index.\n    Round the result to 3 decimal places.\n    \n\n    [EXAMPLES]\n    \n    assert candidate([]) == 1.0\n    assert candidate([(\"Wolf\", 50, [\"Deer\", \"Rabbit\", \"Wolf\"]), (\"Deer\", 200, [\"Grass\", \"Tree\"]), (\"Rabbit\", 500, [\"Grass\", \"Carrot\"]), (\"Grass\", 10000, [\"Sun\", \"Soil\"])]) == -210.0\n\n    [/EXAMPLES]\n    \"\"\"\n```\n", "entry_point": "calculate_ecosystem_stability", "solution": "import functools\nfrom typing import List, Tuple\n\ndef calculate_ecosystem_stability(species: List[Tuple[str, int, List[str]]]) -> float:\n    \"\"\"\n    As an ecologist, I need to calculate the stability index of an ecosystem based on species interactions.\n    \n    Given a list of tuples representing species (name, population, list of species it interacts with),\n    calculate the ecosystem stability index.\n    \n    The stability index is calculated as follows:\n    1. Start with a base stability of 1.0\n    2. For each species, calculate its contribution: (population * number of interactions) / 100\n    3. Add the contribution to the stability index if the number of interactions is odd\n    4. Subtract the contribution from the stability index if the number of interactions is even\n    5. If a species interacts with itself, double its contribution (positive or negative)\n    \n    Use functools.reduce to calculate the final stability index.\n    Round the result to 3 decimal places.\n    \n\n    [EXAMPLES]\n    \n    assert candidate([]) == 1.0\n    assert candidate([(\"Wolf\", 50, [\"Deer\", \"Rabbit\", \"Wolf\"]), (\"Deer\", 200, [\"Grass\", \"Tree\"]), (\"Rabbit\", 500, [\"Grass\", \"Carrot\"]), (\"Grass\", 10000, [\"Sun\", \"Soil\"])]) == -210.0\n\n    [/EXAMPLES]\n    \"\"\"\n    def species_contribution(stability: float, species_info: Tuple[str, int, List[str]]) -> float:\n        name, population, interactions = species_info\n        num_interactions = len(interactions)\n        contribution = (population * num_interactions) / 100\n        \n        if name in interactions:  # Species interacts with itself\n            contribution *= 2\n        \n        if num_interactions % 2 == 1:  # Odd number of interactions\n            stability += contribution\n        else:  # Even number of interactions\n            stability -= contribution\n        \n        return stability\n    \n    initial_stability = 1.0\n    final_stability = functools.reduce(species_contribution, species, initial_stability)\n    return round(final_stability, 3)\n\n", "test": "def check(candidate):\n    assert candidate([(\"Wolf\", 50, [\"Deer\", \"Rabbit\", \"Wolf\"]), (\"Deer\", 200, [\"Grass\", \"Tree\"]), (\"Rabbit\", 500, [\"Grass\", \"Carrot\"]), (\"Grass\", 10000, [\"Sun\", \"Soil\"])]) == -210.0\n    assert candidate([(\"Ant\", 10000, [\"Leaf\", \"Aphid\"]), (\"Leaf\", 5000, [\"Sun\", \"Water\"]), (\"Aphid\", 1000, [\"Leaf\", \"Ant\"])]) == -319.0\n    assert candidate([(\"Bee\", 1000, [\"Flower\"]), (\"Flower\", 500, [\"Sun\", \"Water\", \"Bee\"])]) == 26.0\n    assert candidate([(\"Lion\", 50, [\"Gazelle\", \"Hyena\"])]) == 0.0\n    assert candidate([]) == 1.0\n    assert candidate([(\"Human\", 1, [\"Human\"])]) == 1.02\n    assert candidate([(\"Cactus\", 100, [\"Sun\", \"Water\"]), (\"Scorpion\", 50, [\"Insect\", \"Lizard\"]), (\"Lizard\", 200, [\"Insect\", \"Scorpion\"]), (\"Insect\", 1000, [\"Cactus\"])]) == 4.0\n    assert candidate([(\"Hyena\", 80, [\"Lion\", \"Gazelle\", \"Carrion\"])]) == 3.4\n    assert candidate([(\"Gazelle\", 200, [\"Grass\"])]) == 3.0\n    assert candidate([(\"Oak\", 10, [\"Sun\", \"Water\", \"Soil\", \"Squirrel\"]), (\"Squirrel\", 100, [\"Oak\", \"Acorn\"])]) == -1.4\n", "language": "python"}
{"task_id": "0f4b8069-9caa-49af-a33a-a270dbc8d716-3132125561250129445", "prompt": "Following the docstring requirements, I'll complete the function implementation without altering the function name or parameters. The full code will be presented in one code block.\n\n```python\nfrom typing import List\nimport re\n\ndef analyze_password_strength(password: str) -> List[str]:\n    \"\"\"\n    Evaluates the strength of a given password based on various criteria.\n    This function is designed for a cybersecurity firm developing a password policy enforcement tool.\n\n    Parameters:\n    password (str): The password to be analyzed.\n\n    Returns:\n    List[str]: A list of strengths and weaknesses identified in the password.\n\n\n    [EXAMPLES]\n    \n    assert candidate(\"abcABC123!@#\") == ['Length is at least 8 characters', 'Contains uppercase letters', 'Contains lowercase letters', 'Contains numbers', 'Contains special characters', 'No consecutive repeating characters', 'Weak: Contains common patterns']\n    assert candidate(\"Password123\") == ['Length is at least 8 characters', 'Contains uppercase letters', 'Contains lowercase letters', 'Contains numbers', 'Weak: No special characters', 'Weak: Contains consecutive repeating characters', 'Weak: Contains common patterns']\n\n    [/EXAMPLES]\n    \"\"\"\n```\n", "entry_point": "analyze_password_strength", "solution": "from typing import List\nimport re\n\ndef analyze_password_strength(password: str) -> List[str]:\n    \"\"\"\n    Evaluates the strength of a given password based on various criteria.\n    This function is designed for a cybersecurity firm developing a password policy enforcement tool.\n\n    Parameters:\n    password (str): The password to be analyzed.\n\n    Returns:\n    List[str]: A list of strengths and weaknesses identified in the password.\n\n\n    [EXAMPLES]\n    \n    assert candidate(\"abcABC123!@#\") == ['Length is at least 8 characters', 'Contains uppercase letters', 'Contains lowercase letters', 'Contains numbers', 'Contains special characters', 'No consecutive repeating characters', 'Weak: Contains common patterns']\n    assert candidate(\"Password123\") == ['Length is at least 8 characters', 'Contains uppercase letters', 'Contains lowercase letters', 'Contains numbers', 'Weak: No special characters', 'Weak: Contains consecutive repeating characters', 'Weak: Contains common patterns']\n\n    [/EXAMPLES]\n    \"\"\"\n    strengths = []\n    weaknesses = []\n\n    # Check length\n    if len(password) >= 8:\n        strengths.append(\"Length is at least 8 characters\")\n    else:\n        weaknesses.append(\"Weak: Less than 8 characters\")\n\n    # Check for uppercase letters\n    if re.search(r'[A-Z]', password):\n        strengths.append(\"Contains uppercase letters\")\n    else:\n        weaknesses.append(\"Weak: No uppercase letters\")\n\n    # Check for lowercase letters\n    if re.search(r'[a-z]', password):\n        strengths.append(\"Contains lowercase letters\")\n    else:\n        weaknesses.append(\"Weak: No lowercase letters\")\n\n    # Check for numbers\n    if re.search(r'\\d', password):\n        strengths.append(\"Contains numbers\")\n    else:\n        weaknesses.append(\"Weak: No numbers\")\n\n    # Check for special characters\n    if re.search(r'[!@#$%^&*(),.?\":{}|<>]', password):\n        strengths.append(\"Contains special characters\")\n    else:\n        weaknesses.append(\"Weak: No special characters\")\n\n    # Check for consecutive repeating characters\n    if not re.search(r'(.)\\1', password):\n        strengths.append(\"No consecutive repeating characters\")\n    else:\n        weaknesses.append(\"Weak: Contains consecutive repeating characters\")\n\n    # Check for common patterns (e.g., qwerty, 123)\n    common_patterns = ['qwerty', '123', 'abc', 'password']\n    if any(pattern in password.lower() for pattern in common_patterns):\n        weaknesses.append(\"Weak: Contains common patterns\")\n\n    # Combine strengths and weaknesses\n    result = strengths + weaknesses\n\n    return result\n\n", "test": "def check(candidate):\n    assert candidate(\"p@ssw0rd\") == ['Length is at least 8 characters', 'Contains lowercase letters', 'Contains numbers', 'Contains special characters', 'Weak: No uppercase letters', 'Weak: Contains consecutive repeating characters']\n    assert candidate(\"!@#$%^&*()_+-={}[]|\\\\:;\\\"'<>,.?/\") == ['Length is at least 8 characters', 'Contains special characters', 'No consecutive repeating characters', 'Weak: No uppercase letters', 'Weak: No lowercase letters', 'Weak: No numbers']\n    assert candidate(\"ThisIsAVeryLongPasswordWithoutSpecialCharactersOrNumbers\") == ['Length is at least 8 characters', 'Contains uppercase letters', 'Contains lowercase letters', 'Weak: No numbers', 'Weak: No special characters', 'Weak: Contains consecutive repeating characters', 'Weak: Contains common patterns']\n    assert candidate(\"!@#$%^&*\") == ['Length is at least 8 characters', 'Contains special characters', 'No consecutive repeating characters', 'Weak: No uppercase letters', 'Weak: No lowercase letters', 'Weak: No numbers']\n    assert candidate(\"abcdefgh\") == ['Length is at least 8 characters', 'Contains lowercase letters', 'No consecutive repeating characters', 'Weak: No uppercase letters', 'Weak: No numbers', 'Weak: No special characters', 'Weak: Contains common patterns']\n    assert candidate(\"Password123\") == ['Length is at least 8 characters', 'Contains uppercase letters', 'Contains lowercase letters', 'Contains numbers', 'Weak: No special characters', 'Weak: Contains consecutive repeating characters', 'Weak: Contains common patterns']\n    assert candidate(\"12345678901234567890\") == ['Length is at least 8 characters', 'Contains numbers', 'No consecutive repeating characters', 'Weak: No uppercase letters', 'Weak: No lowercase letters', 'Weak: No special characters', 'Weak: Contains common patterns']\n    assert candidate(\"!\") == ['Contains special characters', 'No consecutive repeating characters', 'Weak: Less than 8 characters', 'Weak: No uppercase letters', 'Weak: No lowercase letters', 'Weak: No numbers']\n    assert candidate(\"12345678\") == ['Length is at least 8 characters', 'Contains numbers', 'No consecutive repeating characters', 'Weak: No uppercase letters', 'Weak: No lowercase letters', 'Weak: No special characters', 'Weak: Contains common patterns']\n    assert candidate(\"abcABC123!@#\") == ['Length is at least 8 characters', 'Contains uppercase letters', 'Contains lowercase letters', 'Contains numbers', 'Contains special characters', 'No consecutive repeating characters', 'Weak: Contains common patterns']\n", "language": "python"}
{"task_id": "ea2cd6a6-abcc-47c2-ac98-7b1037e77c491004185030746542692", "prompt": "Develop a function that satisfies all the given requirements. Ensure your solution is contained entirely within a single code block that can run independently. Do not write any code outside the function. Only use libraries that are already imported in the problem. Include any necessary helper functions or classes inside the main function definition. Provide exactly one code block in your answer.\n\n```python\ndef calculate_asteroid_trajectory(initial_position: tuple, velocity: tuple, time: float) -> tuple:\n    \"\"\"\n    An astronomer is studying the trajectory of an asteroid in a 3D space. This function calculates\n    the final position of the asteroid given its initial position, velocity, and time elapsed.\n\n    Args:\n    initial_position (tuple): The initial (x, y, z) coordinates of the asteroid.\n    velocity (tuple): The (vx, vy, vz) velocity components of the asteroid.\n    time (float): The time elapsed in seconds.\n\n    Returns:\n    tuple: The final (x, y, z) coordinates of the asteroid.\n\n\n    [EXAMPLES]\n    \n    assert candidate((5, 5, 5), (-1, -1, -1), 5) == (0, 0, 0)\n    assert candidate((1.5, -2.7, 3.8), (0.1, -0.2, 0.3), 100) == (11.5, -22.7, 33.8)\n\n    [/EXAMPLES]\n    \"\"\"\n```\n", "entry_point": "calculate_asteroid_trajectory", "solution": "def calculate_asteroid_trajectory(initial_position: tuple, velocity: tuple, time: float) -> tuple:\n    \"\"\"\n    An astronomer is studying the trajectory of an asteroid in a 3D space. This function calculates\n    the final position of the asteroid given its initial position, velocity, and time elapsed.\n\n    Args:\n    initial_position (tuple): The initial (x, y, z) coordinates of the asteroid.\n    velocity (tuple): The (vx, vy, vz) velocity components of the asteroid.\n    time (float): The time elapsed in seconds.\n\n    Returns:\n    tuple: The final (x, y, z) coordinates of the asteroid.\n\n\n    [EXAMPLES]\n    \n    assert candidate((5, 5, 5), (-1, -1, -1), 5) == (0, 0, 0)\n    assert candidate((1.5, -2.7, 3.8), (0.1, -0.2, 0.3), 100) == (11.5, -22.7, 33.8)\n\n    [/EXAMPLES]\n    \"\"\"\n    # Unpack the initial position and velocity tuples\n    x0, y0, z0 = initial_position\n    vx, vy, vz = velocity\n\n    # Calculate the displacement in each dimension\n    dx = vx * time\n    dy = vy * time\n    dz = vz * time\n\n    # Calculate the final position by adding the displacement to the initial position\n    x = x0 + dx\n    y = y0 + dy\n    z = z0 + dz\n\n    # Return the final position as a tuple\n    return (x, y, z)\n\n", "test": "def check(candidate):\n    assert candidate((1.5, -2.7, 3.8), (0.1, -0.2, 0.3), 100) == (11.5, -22.7, 33.8)\n    assert candidate((0.5, -0.5, 0), (1, -1, 0), 0.5) == (1.0, -1.0, 0.0)\n    assert candidate((-5000, 10000, -15000), (50, -100, 150), 100) == (0, 0, 0)\n    assert candidate((5, 5, 5), (-1, -1, -1), 5) == (0, 0, 0)\n    assert candidate((-10, -10, -10), (2, 2, 2), 5) == (0, 0, 0)\n    assert candidate((0, 0, 0), (1, 1, 1), 10) == (10, 10, 10)\n    assert candidate((10, -5, 3), (-2, 0.5, 1), 5) == (0, -2.5, 8)\n    assert candidate((3.14159, 2.71828, 1.41421), (1, 1, 1), 3.14159) == (6.28318, 5.85987, 4.5558)\n    assert candidate((-999.99, 999.99, -999.99), (99.99, -99.99, 99.99), 10) == (-0.09000000000003183, 0.09000000000003183, -0.09000000000003183)\n    assert candidate((999999, 999999, 999999), (-1, -1, -1), 999999) == (0, 0, 0)\n", "language": "python"}
{"task_id": "bddc4149-df15-4215-9c14-61bfc25968037775649229638656514", "prompt": "Based on the provided doc string, please complete the function in a single code block. Implement the functionality as described.\n\n```python\ndef calculate_compound_interest(principal: float, rate: float, time: int, compounds_per_year: int) -> float:\n    \"\"\"\n    Calculate the compound interest for an investment.\n\n    This function computes the total amount after applying compound interest to a principal\n    investment. It takes into account the principal amount, interest rate, time period,\n    and the number of times interest is compounded per year. The calculation involves\n    exponentiation and financial formulas.\n\n    Args:\n    principal (float): The initial investment amount.\n    rate (float): The annual interest rate as a decimal (e.g., 0.05 for 5%).\n    time (int): The number of years for the investment.\n    compounds_per_year (int): The number of times interest is compounded per year.\n\n    Returns:\n    float: The total amount after applying compound interest, rounded to two decimal places.\n\n\n    [EXAMPLES]\n    \n    assert candidate(600, 0.095, 9, 4) == 1396.79\n    assert candidate(25000, 0.025, 40, 12) == 67886.39\n\n    [/EXAMPLES]\n    \"\"\"\n```\n", "entry_point": "calculate_compound_interest", "solution": "def calculate_compound_interest(principal: float, rate: float, time: int, compounds_per_year: int) -> float:\n    \"\"\"\n    Calculate the compound interest for an investment.\n\n    This function computes the total amount after applying compound interest to a principal\n    investment. It takes into account the principal amount, interest rate, time period,\n    and the number of times interest is compounded per year. The calculation involves\n    exponentiation and financial formulas.\n\n    Args:\n    principal (float): The initial investment amount.\n    rate (float): The annual interest rate as a decimal (e.g., 0.05 for 5%).\n    time (int): The number of years for the investment.\n    compounds_per_year (int): The number of times interest is compounded per year.\n\n    Returns:\n    float: The total amount after applying compound interest, rounded to two decimal places.\n\n\n    [EXAMPLES]\n    \n    assert candidate(600, 0.095, 9, 4) == 1396.79\n    assert candidate(25000, 0.025, 40, 12) == 67886.39\n\n    [/EXAMPLES]\n    \"\"\"\n    # Calculate the total amount using the compound interest formula\n    total_amount = principal * (1 + rate / compounds_per_year) ** (compounds_per_year * time)\n    \n    # Round the result to two decimal places\n    rounded_amount = round(total_amount, 2)\n    \n    return rounded_amount\n\n", "test": "def check(candidate):\n    assert candidate(600, 0.095, 9, 4) == 1396.79\n    assert candidate(2000, 0.08, 15, 2) == 6486.8\n    assert candidate(50000, 0.045, 12, 4) == 85542.05\n    assert candidate(25000, 0.025, 40, 12) == 67886.39\n    assert candidate(3000, 0.09, 8, 24) == 6155.01\n    assert candidate(10000, 0.03, 20, 1) == 18061.11\n    assert candidate(75000, 0.015, 50, 365) == 158772.55\n    assert candidate(1, 1.0, 1, 1) == 2.0\n    assert candidate(1500, 0.055, 6, 2) == 2077.18\n    assert candidate(400, 0.12, 1, 52) == 450.94\n", "language": "python"}
{"task_id": "f33ae043-0b71-459a-8672-0bba2200e486-2560396649507338736", "prompt": "Please implement the function as described in the docstring. Maintain the existing function name and parameters. Provide a complete solution in one code block.\n\n```python\ndef optimize_delivery_route(packages: int, truck_capacity: int) -> int:\n    \"\"\"\n    A delivery company wants to optimize its route planning. They have a number of packages to deliver\n    and a truck with a certain capacity. The goal is to find the minimum number of trips required to\n    deliver all packages while maximizing the truck's capacity usage on each trip.\n\n    This function takes two parameters:\n    - packages: The total number of packages to be delivered\n    - truck_capacity: The maximum number of packages the truck can carry in one trip\n\n    The function should return the minimum number of trips required.\n\n\n    [EXAMPLES]\n    \n    assert candidate(49, 50) == 1\n    assert candidate(51, 50) == 2\n\n    [/EXAMPLES]\n    \"\"\"\n```\n", "entry_point": "optimize_delivery_route", "solution": "def optimize_delivery_route(packages: int, truck_capacity: int) -> int:\n    \"\"\"\n    A delivery company wants to optimize its route planning. They have a number of packages to deliver\n    and a truck with a certain capacity. The goal is to find the minimum number of trips required to\n    deliver all packages while maximizing the truck's capacity usage on each trip.\n\n    This function takes two parameters:\n    - packages: The total number of packages to be delivered\n    - truck_capacity: The maximum number of packages the truck can carry in one trip\n\n    The function should return the minimum number of trips required.\n\n\n    [EXAMPLES]\n    \n    assert candidate(49, 50) == 1\n    assert candidate(51, 50) == 2\n\n    [/EXAMPLES]\n    \"\"\"\n    if packages <= 0 or truck_capacity <= 0:\n        return 0\n\n    full_trips = packages // truck_capacity\n    remaining_packages = packages % truck_capacity\n\n    if remaining_packages > 0:\n        return full_trips + 1\n    else:\n        return full_trips\n\n", "test": "def check(candidate):\n    assert candidate(49, 50) == 1\n    assert candidate(10, 7) == 2\n    assert candidate(500000, 499999) == 2\n    assert candidate(3, 2) == 2\n    assert candidate(499999, 500000) == 1\n    assert candidate(100, 1) == 100\n    assert candidate(51, 50) == 2\n    assert candidate(333, 1000) == 1\n    assert candidate(10000, 9999) == 2\n    assert candidate(1, 100) == 1\n", "language": "python"}
{"task_id": "95838676-a365-4964-96d5-ad7adbc0c2df2732788459260794797", "prompt": "Following the docstring specifications, I'll complete the function implementation. The code will be presented in a single block with proper handling of edge cases.\n\n```python\nimport re\n\ndef emoji_translator(text: str) -> str:\n    \"\"\"\n    In a world where emojis have become a universal language, a translator is needed\n    to convert certain words into their emoji equivalents. This function takes a text\n    input and replaces specific words with corresponding emojis.\n\n    The translation rules are as follows:\n    - \"happy\" or \"joy\" -> \"\ud83d\ude0a\"\n    - \"sad\" or \"unhappy\" -> \"\ud83d\ude22\"\n    - \"angry\" or \"mad\" -> \"\ud83d\ude20\"\n    - \"confused\" -> \"\ud83d\ude15\"\n    - \"heart\" or \"love\" -> \"\u2764\ufe0f\"\n\n    The function should be case-insensitive and should only replace whole words,\n    not parts of words.\n\n\n    [EXAMPLES]\n    \n    assert candidate(\"ANGRY BIRDS LOVE HAPPY FEET BUT ARE CONFUSED BY SAD SONGS\") == '\ud83d\ude20 BIRDS \u2764\ufe0f \ud83d\ude0a FEET BUT ARE \ud83d\ude15 BY \ud83d\ude22 SONGS'\n    assert candidate(\"Why are you so angry? Don't be sad.\") == \"Why are you so \ud83d\ude20? Don't be \ud83d\ude22.\"\n\n    [/EXAMPLES]\n    \"\"\"\n```\n", "entry_point": "emoji_translator", "solution": "import re\n\ndef emoji_translator(text: str) -> str:\n    \"\"\"\n    In a world where emojis have become a universal language, a translator is needed\n    to convert certain words into their emoji equivalents. This function takes a text\n    input and replaces specific words with corresponding emojis.\n\n    The translation rules are as follows:\n    - \"happy\" or \"joy\" -> \"\ud83d\ude0a\"\n    - \"sad\" or \"unhappy\" -> \"\ud83d\ude22\"\n    - \"angry\" or \"mad\" -> \"\ud83d\ude20\"\n    - \"confused\" -> \"\ud83d\ude15\"\n    - \"heart\" or \"love\" -> \"\u2764\ufe0f\"\n\n    The function should be case-insensitive and should only replace whole words,\n    not parts of words.\n\n\n    [EXAMPLES]\n    \n    assert candidate(\"ANGRY BIRDS LOVE HAPPY FEET BUT ARE CONFUSED BY SAD SONGS\") == '\ud83d\ude20 BIRDS \u2764\ufe0f \ud83d\ude0a FEET BUT ARE \ud83d\ude15 BY \ud83d\ude22 SONGS'\n    assert candidate(\"Why are you so angry? Don't be sad.\") == \"Why are you so \ud83d\ude20? Don't be \ud83d\ude22.\"\n\n    [/EXAMPLES]\n    \"\"\"\n    # Define the translation dictionary\n    emoji_dict = {\n        r'\\b(happy|joy)\\b': '\ud83d\ude0a',\n        r'\\b(sad|unhappy)\\b': '\ud83d\ude22',\n        r'\\b(angry|mad)\\b': '\ud83d\ude20',\n        r'\\b(confused)\\b': '\ud83d\ude15',\n        r'\\b(heart|love)\\b': '\u2764\ufe0f'\n    }\n\n    # Perform the translation\n    for word_pattern, emoji in emoji_dict.items():\n        text = re.sub(word_pattern, emoji, text, flags=re.IGNORECASE)\n\n    return text\n\n", "test": "def check(candidate):\n    assert candidate(\"I'm happy!!! Are you sad??? Why so angry?!?!\") == \"I'm \ud83d\ude0a!!! Are you \ud83d\ude22??? Why so \ud83d\ude20?!?!\"\n    assert candidate(\"happy happier happiest sad saddest angrily loving heartily confusedly\") == '\ud83d\ude0a happier happiest \ud83d\ude22 saddest angrily loving heartily confusedly'\n    assert candidate(\"I love you with all my heart!\") == 'I \u2764\ufe0f you with all my \u2764\ufe0f!'\n    assert candidate(\"ANGRY BIRDS LOVE HAPPY FEET BUT ARE CONFUSED BY SAD SONGS\") == '\ud83d\ude20 BIRDS \u2764\ufe0f \ud83d\ude0a FEET BUT ARE \ud83d\ude15 BY \ud83d\ude22 SONGS'\n    assert candidate(\"The happiest and saddest moments often involve love.\") == 'The happiest and saddest moments often involve \u2764\ufe0f.'\n    assert candidate(\"Joy joy joy, sad sad sad, mad mad mad, confused confused confused\") == '\ud83d\ude0a \ud83d\ude0a \ud83d\ude0a, \ud83d\ude22 \ud83d\ude22 \ud83d\ude22, \ud83d\ude20 \ud83d\ude20 \ud83d\ude20, \ud83d\ude15 \ud83d\ude15 \ud83d\ude15'\n    assert candidate(\"No emojis here.\") == 'No emojis here.'\n    assert candidate(\"Why are you so angry? Don't be sad.\") == \"Why are you so \ud83d\ude20? Don't be \ud83d\ude22.\"\n    assert candidate(\"The word 'happy' should be replaced, but 'happily' should not.\") == \"The word '\ud83d\ude0a' should be replaced, but 'happily' should not.\"\n    assert candidate(\"He was mad, but now he's ANGRY!\") == \"He was \ud83d\ude20, but now he's \ud83d\ude20!\"\n", "language": "python"}
{"task_id": "02a5158a-e090-4c0f-a0b8-5a33a2669d35-4351432440527815731", "prompt": "I'll implement the function according to the documentation string. The complete function will be in one code block:\n\n```python\ndef balanced_brackets(expression: str) -> bool:\n    \"\"\"\n    Determine if a given expression containing various types of brackets is balanced.\n    The function should check for proper nesting and closing of parentheses (), square brackets [],\n    and curly braces {}. Other characters in the expression should be ignored.\n\n    Parameters:\n    expression (str): The input string containing brackets and other characters\n\n    Returns:\n    bool: True if the brackets are balanced, False otherwise\n\n\n    [EXAMPLES]\n    \n    assert candidate(\")))]]]}}}((([[[{{{\") == False\n    assert candidate(\"()[]{}()[]{}()[]{}()\") == True\n\n    [/EXAMPLES]\n    \"\"\"\n```\n", "entry_point": "balanced_brackets", "solution": "def balanced_brackets(expression: str) -> bool:\n    \"\"\"\n    Determine if a given expression containing various types of brackets is balanced.\n    The function should check for proper nesting and closing of parentheses (), square brackets [],\n    and curly braces {}. Other characters in the expression should be ignored.\n\n    Parameters:\n    expression (str): The input string containing brackets and other characters\n\n    Returns:\n    bool: True if the brackets are balanced, False otherwise\n\n\n    [EXAMPLES]\n    \n    assert candidate(\")))]]]}}}((([[[{{{\") == False\n    assert candidate(\"()[]{}()[]{}()[]{}()\") == True\n\n    [/EXAMPLES]\n    \"\"\"\n    stack = []\n    opening = \"({[\"\n    closing = \")}]\"\n    pairs = {\")\": \"(\", \"}\": \"{\", \"]\": \"[\"}\n\n    for char in expression:\n        if char in opening:\n            stack.append(char)\n        elif char in closing:\n            if not stack or stack.pop() != pairs[char]:\n                return False\n\n    return len(stack) == 0\n\n", "test": "def check(candidate):\n    assert candidate(\"((()))\") == True\n    assert candidate(\"(a[b{c}d]e)\") == True\n    assert candidate(\")))]]]}}}((([[[{{{\") == False\n    assert candidate(\"([]{})\") == True\n    assert candidate(\"([{]}\") == False\n    assert candidate(\"\") == True\n    assert candidate(\"a(b)c[d]e{f}\") == True\n    assert candidate(\"((([[[[{{{{}}}}]]]]))\") == False\n    assert candidate(\"{}\") == True\n    assert candidate(\"()[]{}()[]{}()[]{}()\") == True\n", "language": "python"}
{"task_id": "14ef2182-f821-4ae7-8c30-3338dfa6dba7-7849139642949916015", "prompt": "You serve as a coding assistant. Complete the function provided so it works when executed in a code block. Only use the libraries that were imported in the problem statement. If you need to create helper functions or classes, define them inside the main function rather than outside it.\n\n```python\nfrom typing import List\n\ndef find_magic_index(sorted_array: List[int]) -> int:\n    \"\"\"\n    Find the magic index in a sorted array of distinct integers.\n\n    A magic index in an array A[0...n-1] is defined as an index i such that A[i] = i.\n    Given a sorted array of distinct integers, find the magic index if one exists.\n    If there is no magic index, return -1.\n\n    Args:\n    sorted_array (List[int]): A sorted list of distinct integers.\n\n    Returns:\n    int: The magic index if it exists, otherwise -1.\n\n\n    [EXAMPLES]\n    \n    assert candidate([-10, -9, -8, -7, -6, -5, -4, -3, -2, -1]) == -1\n    assert candidate([0, 2, 4, 6, 8, 10, 12, 14]) == 0\n\n    [/EXAMPLES]\n    \"\"\"\n```\n", "entry_point": "find_magic_index", "solution": "from typing import List\n\ndef find_magic_index(sorted_array: List[int]) -> int:\n    \"\"\"\n    Find the magic index in a sorted array of distinct integers.\n\n    A magic index in an array A[0...n-1] is defined as an index i such that A[i] = i.\n    Given a sorted array of distinct integers, find the magic index if one exists.\n    If there is no magic index, return -1.\n\n    Args:\n    sorted_array (List[int]): A sorted list of distinct integers.\n\n    Returns:\n    int: The magic index if it exists, otherwise -1.\n\n\n    [EXAMPLES]\n    \n    assert candidate([-10, -9, -8, -7, -6, -5, -4, -3, -2, -1]) == -1\n    assert candidate([0, 2, 4, 6, 8, 10, 12, 14]) == 0\n\n    [/EXAMPLES]\n    \"\"\"\n    def binary_search(left: int, right: int) -> int:\n        if left > right:\n            return -1\n\n        mid = (left + right) // 2\n        if sorted_array[mid] == mid:\n            return mid\n        elif sorted_array[mid] > mid:\n            return binary_search(left, mid - 1)\n        else:\n            return binary_search(mid + 1, right)\n\n    return binary_search(0, len(sorted_array) - 1)\n\n", "test": "def check(candidate):\n    assert candidate([0, 2, 4, 6, 8, 10, 12, 14]) == 0\n    assert candidate([-3, -2, -1, 0, 1, 2, 3]) == -1\n    assert candidate([1, 2, 4, 5, 6]) == -1\n    assert candidate([0]) == 0\n    assert candidate([]) == -1\n    assert candidate([-1, 0, 1, 2, 4]) == 4\n    assert candidate([-2, 0, 2, 4, 6, 8, 10]) == 2\n    assert candidate([0, 1, 2, 3, 4, 5, 6, 7, 8, 9]) == 4\n    assert candidate([-2, -1, 1, 3, 5, 7, 9]) == 3\n    assert candidate([-10, -9, -8, -7, -6, -5, -4, -3, -2, -1]) == -1\n", "language": "python"}
{"task_id": "6dd1443a-a0b3-4400-ba3c-92c842e56cf63630589499795463674", "prompt": "Here's the code completion within a single code block.\n\n```python\nfrom typing import List, Tuple\n\ndef space_mission(fuel: int, planets: List[Tuple[int, int]]) -> List[int]:\n    \"\"\"\n    Determines the maximum number of planets that can be visited on a space mission.\n\n    In an interplanetary exploration mission, we need to visit as many planets as\n    possible with a limited amount of fuel. Each planet requires a certain amount\n    of fuel to reach and explore.\n\n    The function takes the initial fuel amount and a list of planets represented\n    by tuples (fuel_to_reach, fuel_to_explore). It returns a list of planet indices\n    that can be visited, maximizing the number of explored planets.\n\n\n    [EXAMPLES]\n    \n    assert candidate(100, [(10, 10), (20, 20), (30, 30), (40, 40)]) == [0, 1]\n    assert candidate(5, [(2, 2), (2, 2), (2, 2)]) == [0]\n\n    [/EXAMPLES]\n    \"\"\"\n```\n", "entry_point": "space_mission", "solution": "from typing import List, Tuple\n\ndef space_mission(fuel: int, planets: List[Tuple[int, int]]) -> List[int]:\n    \"\"\"\n    Determines the maximum number of planets that can be visited on a space mission.\n\n    In an interplanetary exploration mission, we need to visit as many planets as\n    possible with a limited amount of fuel. Each planet requires a certain amount\n    of fuel to reach and explore.\n\n    The function takes the initial fuel amount and a list of planets represented\n    by tuples (fuel_to_reach, fuel_to_explore). It returns a list of planet indices\n    that can be visited, maximizing the number of explored planets.\n\n\n    [EXAMPLES]\n    \n    assert candidate(100, [(10, 10), (20, 20), (30, 30), (40, 40)]) == [0, 1]\n    assert candidate(5, [(2, 2), (2, 2), (2, 2)]) == [0]\n\n    [/EXAMPLES]\n    \"\"\"\n    def explore(current_fuel: int, current_planet: int, visited: List[int]) -> List[int]:\n        if current_planet >= len(planets):\n            return visited\n\n        fuel_to_reach, fuel_to_explore = planets[current_planet]\n        \n        # Try to visit the current planet\n        if current_fuel >= fuel_to_reach + fuel_to_explore:\n            visit_result = explore(current_fuel - fuel_to_reach - fuel_to_explore, current_planet + 1, visited + [current_planet])\n        else:\n            visit_result = []\n\n        # Try to skip the current planet\n        skip_result = explore(current_fuel, current_planet + 1, visited)\n\n        # Return the result with more planets visited\n        return max(visit_result, skip_result, key=len)\n\n    return explore(fuel, 0, [])\n\n", "test": "def check(candidate):\n    assert candidate(15, [(3, 3), (3, 3), (3, 3), (3, 3), (3, 3)]) == [0, 1]\n    assert candidate(20, [(5, 5), (5, 5), (5, 5), (5, 5)]) == [0, 1]\n    assert candidate(100, [(10, 10), (20, 20), (30, 30), (40, 40), (50, 50)]) == [0, 1]\n    assert candidate(5, []) == []\n    assert candidate(1000, [(1, 1), (10, 10), (100, 100), (1000, 1000)]) == [0, 1, 2]\n    assert candidate(100, [(10, 10), (20, 20), (30, 30), (40, 40)]) == [0, 1]\n    assert candidate(500, [(100, 100), (100, 100), (100, 100), (100, 100), (100, 100)]) == [0, 1]\n    assert candidate(30, [(1, 1), (2, 2), (3, 3), (4, 4), (5, 5), (6, 6)]) == [0, 1, 2, 3, 4]\n    assert candidate(1000, [(100, 100), (200, 200), (300, 300), (400, 400)]) == [0, 1]\n    assert candidate(5, [(2, 2), (2, 2), (2, 2)]) == [0]\n", "language": "python"}
{"task_id": "5a9610a5-08b0-44ca-bff4-b43d7e231f0e5254521846485266540", "prompt": "Complete the provided function to make it executable as-is in one code segment. Confine all code to within the function. Restrict yourself to libraries already imported in the problem. Place any supplementary functions or classes inside the given function. Submit just one code block.\n\n```python\nfrom typing import List\n\ndef filter_prime_palindromes(numbers: List[int]) -> List[int]:\n    \"\"\"\n    In a cryptography challenge, participants are given a list of numbers and must identify\n    those that are both prime and palindromic.\n\n    This function takes a list of integers and returns a new list containing only the numbers\n    that are both prime and palindromic.\n\n    A number is prime if it's only divisible by 1 and itself.\n    A number is palindromic if it reads the same forwards and backwards.\n\n\n    [EXAMPLES]\n    \n    assert candidate([313, 323, 333, 343, 353, 363, 373, 383, 393]) == [313, 353, 373, 383]\n    assert candidate([2, 3, 5, 7, 11, 13, 17, 19, 23, 29]) == [2, 3, 5, 7, 11]\n\n    [/EXAMPLES]\n    \"\"\"\n```\n", "entry_point": "filter_prime_palindromes", "solution": "from typing import List\n\ndef filter_prime_palindromes(numbers: List[int]) -> List[int]:\n    \"\"\"\n    In a cryptography challenge, participants are given a list of numbers and must identify\n    those that are both prime and palindromic.\n\n    This function takes a list of integers and returns a new list containing only the numbers\n    that are both prime and palindromic.\n\n    A number is prime if it's only divisible by 1 and itself.\n    A number is palindromic if it reads the same forwards and backwards.\n\n\n    [EXAMPLES]\n    \n    assert candidate([313, 323, 333, 343, 353, 363, 373, 383, 393]) == [313, 353, 373, 383]\n    assert candidate([2, 3, 5, 7, 11, 13, 17, 19, 23, 29]) == [2, 3, 5, 7, 11]\n\n    [/EXAMPLES]\n    \"\"\"\n    def is_prime(n: int) -> bool:\n        if n < 2:\n            return False\n        for i in range(2, int(n**0.5) + 1):\n            if n % i == 0:\n                return False\n        return True\n\n    def is_palindrome(n: int) -> bool:\n        return str(n) == str(n)[::-1]\n\n    return [num for num in numbers if is_prime(num) and is_palindrome(num)]\n\n", "test": "def check(candidate):\n    assert candidate([10, 11, 12, 13, 14, 15]) == [11]\n    assert candidate([313, 323, 333, 343, 353, 363, 373, 383, 393]) == [313, 353, 373, 383]\n    assert candidate([4, 6, 8, 9, 10, 12, 14, 15, 16, 18]) == []\n    assert candidate([2, 3, 5, 7, 11, 13, 17, 19, 23, 29]) == [2, 3, 5, 7, 11]\n    assert candidate([11]) == [11]\n    assert candidate([100, 1000, 10000, 100000, 1000000]) == []\n    assert candidate([101, 202, 303, 404, 505]) == [101]\n    assert candidate([1, 10, 100, 1000, 10000, 100000]) == []\n", "language": "python"}
{"task_id": "b9564f38-6a25-41e6-a5af-3d5225e50e9c-6805796724563966938", "prompt": "Let me finish this function for you by following the details in the docstring. I'll provide the complete implementation in one code block.\n\n```python\ndef decode_ancient_script(encoded_text: str, cipher_key: dict) -> str:\n    \"\"\"\n    An archaeologist has discovered an ancient script and believes they have cracked the cipher. \n    This function attempts to decode the text using the provided cipher key.\n\n    The function should use both dictionary manipulation and string operations to decode the text.\n\n\n    [EXAMPLES]\n    \n    assert candidate(\"A B C\", {'A': '1', 'B': '2', 'C': '3'}) == '1 2 3'\n    assert candidate(\"ABC DEF GHI\", {'A': 'Z', 'B': 'Y', 'C': 'X', 'D': 'W', 'E': 'V', 'F': 'U', 'G': 'T', 'H': 'S', 'I': 'R'}) == 'ZYX WVU TSR'\n\n    [/EXAMPLES]\n    \"\"\"\n```\n", "entry_point": "decode_ancient_script", "solution": "def decode_ancient_script(encoded_text: str, cipher_key: dict) -> str:\n    \"\"\"\n    An archaeologist has discovered an ancient script and believes they have cracked the cipher. \n    This function attempts to decode the text using the provided cipher key.\n\n    The function should use both dictionary manipulation and string operations to decode the text.\n\n\n    [EXAMPLES]\n    \n    assert candidate(\"A B C\", {'A': '1', 'B': '2', 'C': '3'}) == '1 2 3'\n    assert candidate(\"ABC DEF GHI\", {'A': 'Z', 'B': 'Y', 'C': 'X', 'D': 'W', 'E': 'V', 'F': 'U', 'G': 'T', 'H': 'S', 'I': 'R'}) == 'ZYX WVU TSR'\n\n    [/EXAMPLES]\n    \"\"\"\n    def decode_char(char: str) -> str:\n        \"\"\"Helper function to decode a single character.\"\"\"\n        return cipher_key.get(char, char)\n    \n    # Split the encoded text into words\n    encoded_words = encoded_text.split()\n    \n    # Decode each word\n    decoded_words = []\n    for word in encoded_words:\n        decoded_word = ''.join(decode_char(char) for char in word)\n        decoded_words.append(decoded_word)\n    \n    # Join the decoded words back into a string\n    decoded_text = ' '.join(decoded_words)\n    \n    return decoded_text\n\n", "test": "def check(candidate):\n    assert candidate(\"HELLO WORLD\", {'H': 'G', 'E': 'O', 'L': 'D', 'O': 'B', 'W': 'H', 'R': 'E', 'D': 'L'}) == 'GODDB HBEDL'\n    assert candidate(\"ABCDEFG\", {'A': 'Z', 'B': 'Y', 'C': 'X', 'D': 'W', 'E': 'V', 'F': 'U', 'G': 'T'}) == 'ZYXWVUT'\n    assert candidate(\"123 456 789\", {'1': 'A', '2': 'B', '3': 'C', '4': 'D', '5': 'E', '6': 'F', '7': 'G', '8': 'H', '9': 'I'}) == 'ABC DEF GHI'\n    assert candidate(\"ABC DEF GHI\", {'A': 'Z', 'B': 'Y', 'C': 'X', 'D': 'W', 'E': 'V', 'F': 'U', 'G': 'T', 'H': 'S', 'I': 'R'}) == 'ZYX WVU TSR'\n    assert candidate(\"aAbBcC\", {'a': 'x', 'A': 'X', 'b': 'y', 'B': 'Y', 'c': 'z', 'C': 'Z'}) == 'xXyYzZ'\n    assert candidate(\"\", {}) == ''\n    assert candidate(\"!@#$%^&*()\", {'!': '1', '@': '2', '#': '3', '$': '4', '%': '5', '^': '6', '&': '7', '*': '8', '(': '9', ')': '0'}) == '1234567890'\n    assert candidate(\"XYZ\", {'X': 'A', 'Y': 'B', 'Z': 'C'}) == 'ABC'\n    assert candidate(\"A B C\", {'A': '1', 'B': '2', 'C': '3'}) == '1 2 3'\n    assert candidate(\"ABCDE FGHIJ\", {}) == 'ABCDE FGHIJ'\n", "language": "python"}
{"task_id": "c25ad63c-fc66-480b-9a00-72a216b13071-2945290647709678852", "prompt": "I'll implement the requested function in one self-contained code block. The solution will only use libraries that are already imported in the problem. Any necessary helper functions or classes will be defined within the main function. You'll get exactly one code block that can be executed directly.\n\n```python\nimport math\nfrom typing import List\n\ndef optimize_solar_panel_placement(roof_dimensions: List[float], panel_dimensions: List[float], efficiency_factor: float) -> dict:\n    \"\"\"As a renewable energy engineer, you need to optimize the placement of solar panels on a rectangular roof.\n    Given the roof dimensions, solar panel dimensions, and an efficiency factor, calculate the optimal configuration\n    of panels and the total power output.\n\n    The function takes three parameters:\n    1. roof_dimensions: A list of two floats [length, width] representing the roof's dimensions in meters.\n    2. panel_dimensions: A list of two floats [length, width] representing a single panel's dimensions in meters.\n    3. efficiency_factor: A float representing the panel's efficiency (0 to 1).\n\n    Return a dictionary containing:\n    - 'panels_length': Number of panels that fit along the roof's length\n    - 'panels_width': Number of panels that fit along the roof's width\n    - 'total_panels': Total number of panels that can be installed\n    - 'power_output': Total power output in watts (assume 1000 W/m^2 solar irradiance)\n\n\n    [EXAMPLES]\n    \n    assert candidate([12.2, 9.8], [1.6, 0.9], 0.21) == {'panels_length': 7, 'panels_width': 10, 'total_panels': 70, 'power_output': 21168.0}\n    assert candidate([5.0, 4.0], [1.0, 0.7], 0.15) == {'panels_length': 5, 'panels_width': 5, 'total_panels': 25, 'power_output': 2625.0}\n\n    [/EXAMPLES]\n    \"\"\"\n```\n", "entry_point": "optimize_solar_panel_placement", "solution": "import math\nfrom typing import List\n\ndef optimize_solar_panel_placement(roof_dimensions: List[float], panel_dimensions: List[float], efficiency_factor: float) -> dict:\n    \"\"\"As a renewable energy engineer, you need to optimize the placement of solar panels on a rectangular roof.\n    Given the roof dimensions, solar panel dimensions, and an efficiency factor, calculate the optimal configuration\n    of panels and the total power output.\n\n    The function takes three parameters:\n    1. roof_dimensions: A list of two floats [length, width] representing the roof's dimensions in meters.\n    2. panel_dimensions: A list of two floats [length, width] representing a single panel's dimensions in meters.\n    3. efficiency_factor: A float representing the panel's efficiency (0 to 1).\n\n    Return a dictionary containing:\n    - 'panels_length': Number of panels that fit along the roof's length\n    - 'panels_width': Number of panels that fit along the roof's width\n    - 'total_panels': Total number of panels that can be installed\n    - 'power_output': Total power output in watts (assume 1000 W/m^2 solar irradiance)\n\n\n    [EXAMPLES]\n    \n    assert candidate([12.2, 9.8], [1.6, 0.9], 0.21) == {'panels_length': 7, 'panels_width': 10, 'total_panels': 70, 'power_output': 21168.0}\n    assert candidate([5.0, 4.0], [1.0, 0.7], 0.15) == {'panels_length': 5, 'panels_width': 5, 'total_panels': 25, 'power_output': 2625.0}\n\n    [/EXAMPLES]\n    \"\"\"\n    # Extract dimensions\n    roof_length, roof_width = roof_dimensions\n    panel_length, panel_width = panel_dimensions\n\n    # Calculate number of panels that fit along length and width\n    panels_length = math.floor(roof_length / panel_length)\n    panels_width = math.floor(roof_width / panel_width)\n\n    # Calculate total number of panels\n    total_panels = panels_length * panels_width\n\n    # Calculate total panel area\n    total_panel_area = total_panels * panel_length * panel_width\n\n    # Calculate power output\n    # Assuming 1000 W/m^2 solar irradiance\n    power_output = total_panel_area * 1000 * efficiency_factor\n\n    # Prepare and return the result dictionary\n    result = {\n        'panels_length': panels_length,\n        'panels_width': panels_width,\n        'total_panels': total_panels,\n        'power_output': power_output\n    }\n\n    return result\n\n", "test": "def check(candidate):\n    assert candidate([11.1, 8.9], [1.7, 1.2], 0.21) == {'panels_length': 6, 'panels_width': 7, 'total_panels': 42, 'power_output': 17992.799999999996}\n    assert candidate([5.0, 4.0], [1.0, 0.7], 0.15) == {'panels_length': 5, 'panels_width': 5, 'total_panels': 25, 'power_output': 2625.0}\n    assert candidate([25.5, 20.1], [2.1, 1.4], 0.24) == {'panels_length': 12, 'panels_width': 14, 'total_panels': 168, 'power_output': 118540.79999999999}\n    assert candidate([13.5, 11.0], [1.8, 1.1], 0.19) == {'panels_length': 7, 'panels_width': 10, 'total_panels': 70, 'power_output': 26334.000000000007}\n    assert candidate([9.9, 7.8], [1.9, 1.3], 0.20) == {'panels_length': 5, 'panels_width': 6, 'total_panels': 30, 'power_output': 14820.000000000004}\n    assert candidate([10.0, 8.0], [1.5, 1.0], 0.2) == {'panels_length': 6, 'panels_width': 8, 'total_panels': 48, 'power_output': 14400.0}\n    assert candidate([14.7, 12.2], [1.9, 1.4], 0.23) == {'panels_length': 7, 'panels_width': 8, 'total_panels': 56, 'power_output': 34260.799999999996}\n    assert candidate([18.3, 14.7], [2.2, 1.3], 0.23) == {'panels_length': 8, 'panels_width': 11, 'total_panels': 88, 'power_output': 57886.40000000001}\n    assert candidate([28.3, 22.6], [2.4, 1.8], 0.26) == {'panels_length': 11, 'panels_width': 12, 'total_panels': 132, 'power_output': 148262.4}\n    assert candidate([12.2, 9.8], [1.6, 0.9], 0.21) == {'panels_length': 7, 'panels_width': 10, 'total_panels': 70, 'power_output': 21168.0}\n", "language": "python"}
{"task_id": "0e49638f-8d31-47bc-9df1-6c47d51c6658-3761141409733362795", "prompt": "Let me complete the function implementation according to the specifications in the docstring. The entire function will be in one code block.\n\n```python\nfrom typing import List\nfrom collections import deque\n\ndef find_treasure_path(map_grid: List[List[int]]) -> List[tuple]:\n    \"\"\"\n    An adventurer has discovered an ancient map leading to hidden treasure.\n    The map is represented as a grid where:\n    0 represents passable terrain\n    1 represents impassable obstacles\n    2 represents the starting point\n    3 represents the treasure location\n\n    Your task is to find the shortest path from the starting point to the treasure,\n    avoiding obstacles and minimizing the number of steps.\n\n    This function should use breadth-first search and a queue data structure to find the optimal path.\n\n    Return a list of tuples representing the coordinates of the path, including start and end points.\n    If no path exists, return an empty list.\n\n\n    [EXAMPLES]\n    \n    assert candidate([[3]]) == []\n    assert candidate([[0, 0, 0, 0], [0, 2, 1, 0], [0, 0, 3, 0]]) == [(1, 1), (2, 1), (2, 2)]\n\n    [/EXAMPLES]\n    \"\"\"\n```\n", "entry_point": "find_treasure_path", "solution": "from typing import List\nfrom collections import deque\n\ndef find_treasure_path(map_grid: List[List[int]]) -> List[tuple]:\n    \"\"\"\n    An adventurer has discovered an ancient map leading to hidden treasure.\n    The map is represented as a grid where:\n    0 represents passable terrain\n    1 represents impassable obstacles\n    2 represents the starting point\n    3 represents the treasure location\n\n    Your task is to find the shortest path from the starting point to the treasure,\n    avoiding obstacles and minimizing the number of steps.\n\n    This function should use breadth-first search and a queue data structure to find the optimal path.\n\n    Return a list of tuples representing the coordinates of the path, including start and end points.\n    If no path exists, return an empty list.\n\n\n    [EXAMPLES]\n    \n    assert candidate([[3]]) == []\n    assert candidate([[0, 0, 0, 0], [0, 2, 1, 0], [0, 0, 3, 0]]) == [(1, 1), (2, 1), (2, 2)]\n\n    [/EXAMPLES]\n    \"\"\"\n    def is_valid(x, y):\n        return 0 <= x < rows and 0 <= y < cols and map_grid[x][y] != 1\n\n    def get_neighbors(x, y):\n        return [(x+dx, y+dy) for dx, dy in [(0, 1), (1, 0), (0, -1), (-1, 0)] if is_valid(x+dx, y+dy)]\n\n    rows, cols = len(map_grid), len(map_grid[0])\n    start = None\n    end = None\n\n    # Find start and end positions\n    for i in range(rows):\n        for j in range(cols):\n            if map_grid[i][j] == 2:\n                start = (i, j)\n            elif map_grid[i][j] == 3:\n                end = (i, j)\n\n    if not start or not end:\n        return []\n\n    queue = deque([(start, [start])])\n    visited = set([start])\n\n    while queue:\n        (x, y), path = queue.popleft()\n\n        if (x, y) == end:\n            return path\n\n        for nx, ny in get_neighbors(x, y):\n            if (nx, ny) not in visited:\n                visited.add((nx, ny))\n                new_path = path + [(nx, ny)]\n                queue.append(((nx, ny), new_path))\n\n    return []\n\n", "test": "def check(candidate):\n    assert candidate([[2, 0, 1], [1, 1, 3], [0, 0, 0]]) == []\n    assert candidate([[3]]) == []\n    assert candidate([[2, 0, 0], [0, 0, 0], [0, 0, 3]]) == [(0, 0), (0, 1), (0, 2), (1, 2), (2, 2)]\n    assert candidate([[2]]) == []\n    assert candidate([[2, 3]]) == [(0, 0), (0, 1)]\n    assert candidate([[2, 1, 1], [1, 3, 1], [1, 1, 1]]) == []\n    assert candidate([[2, 0, 0, 0], [1, 1, 0, 1], [0, 0, 0, 0], [0, 1, 3, 0]]) == [(0, 0), (0, 1), (0, 2), (1, 2), (2, 2), (3, 2)]\n    assert candidate([[3, 0, 2]]) == [(0, 2), (0, 1), (0, 0)]\n    assert candidate([[0, 0, 0, 0], [0, 2, 1, 0], [0, 0, 3, 0]]) == [(1, 1), (2, 1), (2, 2)]\n    assert candidate([[2, 0, 0, 0, 0], [0, 1, 1, 1, 0], [0, 0, 0, 1, 0], [1, 1, 0, 0, 3]]) == [(0, 0), (0, 1), (0, 2), (0, 3), (0, 4), (1, 4), (2, 4), (3, 4)]\n", "language": "python"}
{"task_id": "33faba1e-3864-4a5d-9e66-9574a6cf6f46615420095206711809", "prompt": "Your job is to finish a function that's ready for execution in a single code block. Don't include any code outside the function's scope. Stick to using only the libraries that are already imported in the problem statement. If you need additional functions or classes, define them within the main function. Provide just one complete code block in your response.\n\n```python\nfrom collections import defaultdict\nfrom typing import List, Tuple\nfrom typing import List, Tuple, Dict\n\ndef design_network_topology(devices: List[str], connections: List[Tuple[str, str]]) -> Dict[str, List[str]]:\n    \"\"\"\n    Design an optimal network topology based on given devices and their connections.\n\n    This function takes a list of device names and a list of tuples representing\n    connections between devices. It returns a dictionary representing the optimal\n    network topology, where each key is a device and its value is a list of\n    devices it's directly connected to.\n\n    Args:\n    devices (List[str]): A list of device names in the network.\n    connections (List[Tuple[str, str]]): A list of tuples, each representing a connection between two devices.\n\n    Returns:\n    Dict[str, List[str]]: A dictionary representing the optimal network topology.\n\n\n    [EXAMPLES]\n    \n    assert candidate(['X', 'Y', 'Z', 'W'], [('X', 'Y'), ('Y', 'Z'), ('Z', 'W'), ('W', 'X'), ('X', 'Z'), ('Y', 'W')]) == {'X': ['W', 'Y', 'Z'], 'Y': ['W', 'X', 'Z'], 'Z': ['W', 'X', 'Y'], 'W': ['X', 'Y', 'Z']}\n    assert candidate(['1', '2', '3', '4'], [('1', '2'), ('2', '3'), ('3', '4'), ('4', '1'), ('1', '3'), ('2', '4')]) == {'1': ['2', '3', '4'], '2': ['1', '3', '4'], '3': ['1', '2', '4'], '4': ['1', '2', '3']}\n\n    [/EXAMPLES]\n    \"\"\"\n```\n", "entry_point": "design_network_topology", "solution": "from collections import defaultdict\nfrom typing import List, Tuple\nfrom typing import List, Tuple, Dict\n\ndef design_network_topology(devices: List[str], connections: List[Tuple[str, str]]) -> Dict[str, List[str]]:\n    \"\"\"\n    Design an optimal network topology based on given devices and their connections.\n\n    This function takes a list of device names and a list of tuples representing\n    connections between devices. It returns a dictionary representing the optimal\n    network topology, where each key is a device and its value is a list of\n    devices it's directly connected to.\n\n    Args:\n    devices (List[str]): A list of device names in the network.\n    connections (List[Tuple[str, str]]): A list of tuples, each representing a connection between two devices.\n\n    Returns:\n    Dict[str, List[str]]: A dictionary representing the optimal network topology.\n\n\n    [EXAMPLES]\n    \n    assert candidate(['X', 'Y', 'Z', 'W'], [('X', 'Y'), ('Y', 'Z'), ('Z', 'W'), ('W', 'X'), ('X', 'Z'), ('Y', 'W')]) == {'X': ['W', 'Y', 'Z'], 'Y': ['W', 'X', 'Z'], 'Z': ['W', 'X', 'Y'], 'W': ['X', 'Y', 'Z']}\n    assert candidate(['1', '2', '3', '4'], [('1', '2'), ('2', '3'), ('3', '4'), ('4', '1'), ('1', '3'), ('2', '4')]) == {'1': ['2', '3', '4'], '2': ['1', '3', '4'], '3': ['1', '2', '4'], '4': ['1', '2', '3']}\n\n    [/EXAMPLES]\n    \"\"\"\n    # Initialize the topology dictionary with empty lists for each device\n    topology = {device: [] for device in devices}\n\n    # Create a graph representation of the connections\n    graph = defaultdict(list)\n    for dev1, dev2 in connections:\n        graph[dev1].append(dev2)\n        graph[dev2].append(dev1)\n\n    # Build the optimal topology\n    for device in devices:\n        # Sort the connected devices to ensure consistency\n        connected_devices = sorted(set(graph[device]))\n        topology[device] = connected_devices\n\n    return topology\n\n", "test": "def check(candidate):\n    assert candidate(['A', 'B', 'C', 'D', 'E'], [('A', 'B'), ('B', 'C'), ('C', 'D'), ('D', 'E'), ('E', 'A'), ('A', 'C'), ('A', 'D')]) == {'A': ['B', 'C', 'D', 'E'], 'B': ['A', 'C'], 'C': ['A', 'B', 'D'], 'D': ['A', 'C', 'E'], 'E': ['A', 'D']}\n    assert candidate(['A', 'B', 'C', 'D', 'E'], [('A', 'B'), ('A', 'C'), ('A', 'D'), ('A', 'E'), ('B', 'C'), ('B', 'D'), ('B', 'E'), ('C', 'D'), ('C', 'E'), ('D', 'E')]) == {'A': ['B', 'C', 'D', 'E'], 'B': ['A', 'C', 'D', 'E'], 'C': ['A', 'B', 'D', 'E'], 'D': ['A', 'B', 'C', 'E'], 'E': ['A', 'B', 'C', 'D']}\n    assert candidate(['1', '2'], []) == {'1': [], '2': []}\n    assert candidate(['X', 'Y', 'Z', 'W'], [('X', 'Y'), ('Y', 'Z'), ('Z', 'W'), ('W', 'X'), ('X', 'Z'), ('Y', 'W')]) == {'X': ['W', 'Y', 'Z'], 'Y': ['W', 'X', 'Z'], 'Z': ['W', 'X', 'Y'], 'W': ['X', 'Y', 'Z']}\n    assert candidate(['A', 'B', 'C', 'D', 'E'], [('A', 'B'), ('B', 'C'), ('C', 'D'), ('D', 'E')]) == {'A': ['B'], 'B': ['A', 'C'], 'C': ['B', 'D'], 'D': ['C', 'E'], 'E': ['D']}\n    assert candidate(['A', 'B', 'C', 'D'], [('A', 'B'), ('B', 'C'), ('C', 'D'), ('D', 'A')]) == {'A': ['B', 'D'], 'B': ['A', 'C'], 'C': ['B', 'D'], 'D': ['A', 'C']}\n    assert candidate(['X', 'Y', 'Z'], [('X', 'Y'), ('Y', 'Z'), ('Z', 'X')]) == {'X': ['Y', 'Z'], 'Y': ['X', 'Z'], 'Z': ['X', 'Y']}\n    assert candidate(['1', '2', '3', '4'], [('1', '2'), ('2', '3'), ('3', '4'), ('4', '1'), ('1', '3'), ('2', '4')]) == {'1': ['2', '3', '4'], '2': ['1', '3', '4'], '3': ['1', '2', '4'], '4': ['1', '2', '3']}\n    assert candidate(['X', 'Y', 'Z', 'W', 'V'], [('X', 'Y'), ('Y', 'Z'), ('Z', 'W'), ('W', 'V'), ('V', 'X'), ('X', 'Z'), ('Y', 'W'), ('Z', 'V')]) == {'X': ['V', 'Y', 'Z'], 'Y': ['W', 'X', 'Z'], 'Z': ['V', 'W', 'X', 'Y'], 'W': ['V', 'Y', 'Z'], 'V': ['W', 'X', 'Z']}\n    assert candidate(['X', 'Y'], [('X', 'Y'), ('Y', 'X')]) == {'X': ['Y'], 'Y': ['X']}\n", "language": "python"}
{"task_id": "0d9cfa85-df91-4ce5-963f-9fdef753927e-8711308103293398533", "prompt": "Implement the function as requested, ensuring it's contained in a single executable code block. Don't add any code outside the function. Only use libraries imported in the problem. Any helper functions or classes should be defined inside the main function. I'll present just one code block as the solution.\n\n```python\nfrom typing import List\n\ndef optimize_study_schedule(subjects: List[str], study_times: List[int], breaks: List[int]) -> List[str]:\n    \"\"\"\n    A student is preparing for exams and wants to create an optimal study schedule.\n    They have a list of subjects to study, the time required for each subject (in minutes),\n    and a list of break durations (in minutes) to be taken between study sessions.\n\n    The student wants to maximize their study efficiency by following these rules:\n    1. Study subjects in the order they appear in the input list.\n    2. Take breaks between study sessions, using break durations in the order they appear in the input list.\n    3. If there are more subjects than breaks, continue studying without breaks after using all break durations.\n    4. If there are more breaks than subjects, ignore the extra breaks.\n\n    Your task is to create a function that takes the list of subjects, study times, and break durations,\n    and returns a list representing the optimal study schedule. Each element in the output list should be\n    either a subject name (string) or \"Break\" to indicate a break period.\n\n\n    [EXAMPLES]\n    \n    assert candidate([\"Art\", \"Music\"], [180, 120], [30, 45, 60]) == ['Art', 'Break', 'Music', 'Break']\n    assert candidate([\"Physics\", \"Chemistry\"], [90, 75], []) == ['Physics', 'Chemistry']\n\n    [/EXAMPLES]\n    \"\"\"\n```\n", "entry_point": "optimize_study_schedule", "solution": "from typing import List\n\ndef optimize_study_schedule(subjects: List[str], study_times: List[int], breaks: List[int]) -> List[str]:\n    \"\"\"\n    A student is preparing for exams and wants to create an optimal study schedule.\n    They have a list of subjects to study, the time required for each subject (in minutes),\n    and a list of break durations (in minutes) to be taken between study sessions.\n\n    The student wants to maximize their study efficiency by following these rules:\n    1. Study subjects in the order they appear in the input list.\n    2. Take breaks between study sessions, using break durations in the order they appear in the input list.\n    3. If there are more subjects than breaks, continue studying without breaks after using all break durations.\n    4. If there are more breaks than subjects, ignore the extra breaks.\n\n    Your task is to create a function that takes the list of subjects, study times, and break durations,\n    and returns a list representing the optimal study schedule. Each element in the output list should be\n    either a subject name (string) or \"Break\" to indicate a break period.\n\n\n    [EXAMPLES]\n    \n    assert candidate([\"Art\", \"Music\"], [180, 120], [30, 45, 60]) == ['Art', 'Break', 'Music', 'Break']\n    assert candidate([\"Physics\", \"Chemistry\"], [90, 75], []) == ['Physics', 'Chemistry']\n\n    [/EXAMPLES]\n    \"\"\"\n    schedule = []\n    min_length = min(len(subjects), len(breaks) + 1)\n\n    for i in range(min_length):\n        schedule.append(subjects[i])\n        if i < len(breaks):\n            schedule.append(\"Break\")\n\n    # Add remaining subjects if there are more subjects than breaks\n    if len(subjects) > len(breaks) + 1:\n        schedule.extend(subjects[len(breaks)+1:])\n\n    return schedule\n\n", "test": "def check(candidate):\n    assert candidate([], [], [10, 15, 20]) == []\n    assert candidate([\"A\"] * 20, [10] * 20, [5] * 19) == ['A', 'Break', 'A', 'Break', 'A', 'Break', 'A', 'Break', 'A', 'Break', 'A', 'Break', 'A', 'Break', 'A', 'Break', 'A', 'Break', 'A', 'Break', 'A', 'Break', 'A', 'Break', 'A', 'Break', 'A', 'Break', 'A', 'Break', 'A', 'Break', 'A', 'Break', 'A', 'Break', 'A', 'Break', 'A']\n    assert candidate([\"Short\", \"Medium\", \"Long\"], [15, 45, 90], [30, 60]) == ['Short', 'Break', 'Medium', 'Break', 'Long']\n    assert candidate([\"Physics\", \"Chemistry\"], [90, 75], []) == ['Physics', 'Chemistry']\n    assert candidate([\"Long Subject\"], [240], [10, 10, 10]) == ['Long Subject', 'Break']\n    assert candidate([\"Programming\", \"Algorithms\", \"Data Structures\", \"Databases\"], [120, 90, 100, 80], [15, 10, 20]) == ['Programming', 'Break', 'Algorithms', 'Break', 'Data Structures', 'Break', 'Databases']\n    assert candidate([\"Art\", \"Music\"], [180, 120], [30, 45, 60]) == ['Art', 'Break', 'Music', 'Break']\n    assert candidate([\"Math\", \"Physics\", \"Chemistry\"], [60, 90, 75], [15, 20]) == ['Math', 'Break', 'Physics', 'Break', 'Chemistry']\n    assert candidate([\"Subject1\", \"Subject2\"], [1, 1], [1]) == ['Subject1', 'Break', 'Subject2']\n    assert candidate([\"English\", \"French\", \"Spanish\", \"German\", \"Italian\"], [45, 60, 55, 50, 40], [10, 15, 10, 10]) == ['English', 'Break', 'French', 'Break', 'Spanish', 'Break', 'German', 'Break', 'Italian']\n", "language": "python"}
{"task_id": "09580b90-ea17-46bf-9b84-0383b4182d3b3977798608940189638", "prompt": "I need you to finish a function such that it works when executed directly in a single code block. Everything must be inside the function, with no code outside of it. Only use libraries that are already imported in the problem. If you need helper functions or classes, define them within the main function.\n\n```python\nfrom typing import List\n\ndef design_rollercoaster(heights: List[int]) -> int:\n    \"\"\"\n    An amusement park is designing a new rollercoaster. They want to create a thrilling experience by maximizing\n    the number of \"excitement points\". An excitement point is earned when a car goes down a slope. The height of\n    each section of the track is given, and the goal is to find the maximum number of excitement points possible\n    by arranging the sections in any order.\n\n    This function takes a list of integers representing the heights of track sections and returns the maximum\n    number of excitement points that can be achieved.\n\n\n    [EXAMPLES]\n    \n    assert candidate([1, 1, 1, 1, 1]) == 0\n    assert candidate([50, 49, 48, 47, 46, 45, 44, 43, 42, 41, 40, 39, 38, 37, 36]) == 14\n\n    [/EXAMPLES]\n    \"\"\"\n```\n", "entry_point": "design_rollercoaster", "solution": "from typing import List\n\ndef design_rollercoaster(heights: List[int]) -> int:\n    \"\"\"\n    An amusement park is designing a new rollercoaster. They want to create a thrilling experience by maximizing\n    the number of \"excitement points\". An excitement point is earned when a car goes down a slope. The height of\n    each section of the track is given, and the goal is to find the maximum number of excitement points possible\n    by arranging the sections in any order.\n\n    This function takes a list of integers representing the heights of track sections and returns the maximum\n    number of excitement points that can be achieved.\n\n\n    [EXAMPLES]\n    \n    assert candidate([1, 1, 1, 1, 1]) == 0\n    assert candidate([50, 49, 48, 47, 46, 45, 44, 43, 42, 41, 40, 39, 38, 37, 36]) == 14\n\n    [/EXAMPLES]\n    \"\"\"\n    if not heights:\n        return 0\n\n    # Sort the heights in descending order\n    sorted_heights = sorted(heights, reverse=True)\n    \n    excitement_points = 0\n    max_height = sorted_heights[0]\n\n    # Count the number of times the height decreases\n    for height in sorted_heights[1:]:\n        if height < max_height:\n            excitement_points += 1\n            max_height = height\n\n    return excitement_points\n\n", "test": "def check(candidate):\n    assert candidate([1, 3, 5, 7, 9, 8, 6, 4, 2]) == 8\n    assert candidate([5, 5, 5, 4, 4, 4, 3, 3, 3]) == 2\n    assert candidate([3, 2, 1, 2, 3]) == 2\n    assert candidate([1, 2, 3, 4, 5]) == 4\n    assert candidate([1, 1, 1, 1, 1]) == 0\n    assert candidate([5, 4, 3, 2, 1, 2, 3, 4, 5]) == 4\n    assert candidate([1, 10, 1, 10, 1]) == 1\n    assert candidate([5, 4, 3, 2, 1]) == 4\n    assert candidate([50, 49, 48, 47, 46, 45, 44, 43, 42, 41, 40, 39, 38, 37, 36]) == 14\n    assert candidate([100, 99, 98, 97, 96, 95, 94, 93, 92, 91]) == 9\n", "language": "python"}
{"task_id": "2eb2dfb8-b4f3-4b2b-b04e-f012b5800088-6077538778950980341", "prompt": "I'll assist you with coding by providing complete, executable function implementations. My code will be confined to the function you need help with, using only the libraries imported in your problem. Any auxiliary functions or classes will be defined within the scope of the main function.\n\n```python\nfrom typing import List, Tuple\n\ndef optimize_plant_layout(garden: List[List[int]], plant_types: int) -> List[List[int]]:\n    \"\"\"A botanical garden wants to optimize its plant layout to maximize biodiversity and aesthetic appeal.\n    The garden is represented as a 2D grid, where each cell can hold one plant.\n    Your task is to arrange different plant types in the garden such that no two adjacent cells \n    (horizontally or vertically) contain the same plant type.\n    \n    The function takes a 2D list representing the initial garden layout (where 0 indicates an empty cell)\n    and the number of different plant types available. It returns the optimized garden layout.\n    \n    This problem combines the concepts of backtracking and constraint satisfaction.\n    \n\n    [EXAMPLES]\n    \n    assert candidate([[0]], 1) == [[1]]\n    assert candidate([[0,0,0,0],[0,0,0,0],[0,0,0,0],[0,0,0,0]], 4) == [[1, 2, 1, 2], [2, 1, 2, 1], [1, 2, 1, 2], [2, 1, 2, 1]]\n\n    [/EXAMPLES]\n    \"\"\"\n```\n", "entry_point": "optimize_plant_layout", "solution": "from typing import List, Tuple\n\ndef optimize_plant_layout(garden: List[List[int]], plant_types: int) -> List[List[int]]:\n    \"\"\"A botanical garden wants to optimize its plant layout to maximize biodiversity and aesthetic appeal.\n    The garden is represented as a 2D grid, where each cell can hold one plant.\n    Your task is to arrange different plant types in the garden such that no two adjacent cells \n    (horizontally or vertically) contain the same plant type.\n    \n    The function takes a 2D list representing the initial garden layout (where 0 indicates an empty cell)\n    and the number of different plant types available. It returns the optimized garden layout.\n    \n    This problem combines the concepts of backtracking and constraint satisfaction.\n    \n\n    [EXAMPLES]\n    \n    assert candidate([[0]], 1) == [[1]]\n    assert candidate([[0,0,0,0],[0,0,0,0],[0,0,0,0],[0,0,0,0]], 4) == [[1, 2, 1, 2], [2, 1, 2, 1], [1, 2, 1, 2], [2, 1, 2, 1]]\n\n    [/EXAMPLES]\n    \"\"\"\n    def is_valid(row: int, col: int, plant: int) -> bool:\n        # Check if the plant can be placed at the given position\n        if row > 0 and garden[row-1][col] == plant:\n            return False\n        if row < len(garden) - 1 and garden[row+1][col] == plant:\n            return False\n        if col > 0 and garden[row][col-1] == plant:\n            return False\n        if col < len(garden[0]) - 1 and garden[row][col+1] == plant:\n            return False\n        return True\n\n    def backtrack(row: int, col: int) -> bool:\n        if row == len(garden):\n            return True\n        \n        if col == len(garden[0]):\n            return backtrack(row + 1, 0)\n        \n        if garden[row][col] != 0:\n            return backtrack(row, col + 1)\n        \n        for plant in range(1, plant_types + 1):\n            if is_valid(row, col, plant):\n                garden[row][col] = plant\n                if backtrack(row, col + 1):\n                    return True\n                garden[row][col] = 0\n        \n        return False\n\n    if backtrack(0, 0):\n        return garden\n    else:\n        return []  # No valid solution found\n\n\n", "test": "def check(candidate):\n    assert candidate([[0,0],[0,0],[0,0]], 3) == [[1, 2], [2, 1], [1, 2]]\n    assert candidate([[0]], 1) == [[1]]\n    assert candidate([[0,0,0,0,0],[0,0,0,0,0]], 3) == [[1, 2, 1, 2, 1], [2, 1, 2, 1, 2]]\n    assert candidate([[1,0,1],[0,2,0],[1,0,1]], 3) == [[1, 3, 1], [3, 2, 3], [1, 3, 1]]\n    assert candidate([[0,0,0,0,0,0],[0,0,0,0,0,0],[0,0,0,0,0,0],[0,0,0,0,0,0],[0,0,0,0,0,0],[0,0,0,0,0,0]], 6) == [[1, 2, 1, 2, 1, 2], [2, 1, 2, 1, 2, 1], [1, 2, 1, 2, 1, 2], [2, 1, 2, 1, 2, 1], [1, 2, 1, 2, 1, 2], [2, 1, 2, 1, 2, 1]]\n    assert candidate([[0,0,0,0,0],[0,0,0,0,0],[0,0,0,0,0],[0,0,0,0,0]], 4) == [[1, 2, 1, 2, 1], [2, 1, 2, 1, 2], [1, 2, 1, 2, 1], [2, 1, 2, 1, 2]]\n    assert candidate([[0,0,0],[0,0,0]], 2) == [[1, 2, 1], [2, 1, 2]]\n    assert candidate([[1,2,3],[0,0,0],[0,0,0]], 3) == [[1, 2, 3], [2, 1, 2], [1, 2, 1]]\n    assert candidate([[0,0,0,0],[0,1,0,0],[0,0,2,0],[0,0,0,3]], 4) == [[1, 2, 1, 2], [2, 1, 3, 1], [1, 3, 2, 4], [2, 1, 4, 3]]\n    assert candidate([[0,0,0,0],[0,0,0,0],[0,0,0,0],[0,0,0,0]], 4) == [[1, 2, 1, 2], [2, 1, 2, 1], [1, 2, 1, 2], [2, 1, 2, 1]]\n", "language": "python"}
{"task_id": "d03c25bf-686f-4785-abad-7c9156661a0e3841333376358752876", "prompt": "Your function will be implemented in a single code block, ready to run without modifications. I'll ensure all necessary code is contained within the function itself, including any additional functions or classes that may be needed. I'll only use the libraries that were imported in the problem statement.\n\n```python\nfrom typing import List, Tuple\n\ndef optimize_solar_panel_placement(roof: List[List[int]], panel_size: Tuple[int, int]) -> int:\n    \"\"\"\n    A sustainable energy company is designing a system to optimize solar panel placement on rooftops.\n    The roof is represented as a 2D grid where 1 represents a suitable location for a panel and 0\n    represents an unsuitable location (e.g., chimney, skylight).\n\n    Given the roof layout and the size of a standard solar panel, determine the maximum number of\n    solar panels that can be placed on the roof without overlap.\n\n    This function takes the roof layout as a 2D list and the panel size as a tuple (width, height),\n    and returns the maximum number of panels that can be placed.\n\n\n    [EXAMPLES]\n    \n    assert candidate([[1,0,1,0],[0,1,0,1],[1,0,1,0],[0,1,0,1]], (1,1)) == 8\n    assert candidate([[1]], (1,1)) == 1\n\n    [/EXAMPLES]\n    \"\"\"\n```\n", "entry_point": "optimize_solar_panel_placement", "solution": "from typing import List, Tuple\n\ndef optimize_solar_panel_placement(roof: List[List[int]], panel_size: Tuple[int, int]) -> int:\n    \"\"\"\n    A sustainable energy company is designing a system to optimize solar panel placement on rooftops.\n    The roof is represented as a 2D grid where 1 represents a suitable location for a panel and 0\n    represents an unsuitable location (e.g., chimney, skylight).\n\n    Given the roof layout and the size of a standard solar panel, determine the maximum number of\n    solar panels that can be placed on the roof without overlap.\n\n    This function takes the roof layout as a 2D list and the panel size as a tuple (width, height),\n    and returns the maximum number of panels that can be placed.\n\n\n    [EXAMPLES]\n    \n    assert candidate([[1,0,1,0],[0,1,0,1],[1,0,1,0],[0,1,0,1]], (1,1)) == 8\n    assert candidate([[1]], (1,1)) == 1\n\n    [/EXAMPLES]\n    \"\"\"\n    def can_place_panel(x: int, y: int) -> bool:\n        \"\"\"Check if a panel can be placed at position (x, y)\"\"\"\n        if x + panel_width > roof_width or y + panel_height > roof_height:\n            return False\n        for i in range(panel_height):\n            for j in range(panel_width):\n                if roof[y + i][x + j] == 0:\n                    return False\n        return True\n\n    def place_panel(x: int, y: int) -> None:\n        \"\"\"Mark the area occupied by a panel as unavailable\"\"\"\n        for i in range(panel_height):\n            for j in range(panel_width):\n                roof[y + i][x + j] = 0\n\n    roof_height = len(roof)\n    roof_width = len(roof[0])\n    panel_width, panel_height = panel_size\n    panel_count = 0\n\n    for y in range(roof_height):\n        for x in range(roof_width):\n            if can_place_panel(x, y):\n                place_panel(x, y)\n                panel_count += 1\n\n    return panel_count\n\n", "test": "def check(candidate):\n    assert candidate([[1,1,1],[1,1,1],[1,1,1]], (2,2)) == 1\n    assert candidate([[1,0,1,0],[0,1,0,1],[1,0,1,0],[0,1,0,1]], (1,1)) == 8\n    assert candidate([[1]], (1,1)) == 1\n    assert candidate([[1,1,1],[1,1,1],[1,1,1]], (1,3)) == 3\n    assert candidate([[1,1,1,1,1],[1,1,1,1,1],[1,1,1,1,1],[1,1,1,1,1],[1,1,1,1,1]], (2,3)) == 2\n    assert candidate([[1,0,1],[0,1,0],[1,0,1]], (1,1)) == 5\n    assert candidate([[1,1,1,1],[1,1,1,1],[1,1,1,1]], (3,2)) == 1\n    assert candidate([[0,0,0],[0,1,0],[0,0,0]], (1,1)) == 1\n    assert candidate([[1,0,1,0,1],[1,1,1,1,1],[1,1,1,1,1],[0,1,1,1,0]], (1,2)) == 6\n    assert candidate([[1,1,1,1],[1,1,1,1],[1,1,1,1],[1,1,1,1]], (2,2)) == 4\n", "language": "python"}
{"task_id": "625e3ad3-3a58-4bcf-a86e-ba9715ddd2fa4517484261862416316", "prompt": "I'll implement the function according to the documentation string. The function name and arguments will remain the same, and I'll provide the complete function in one code block.\n\n```python\nfrom typing import List\nimport heapq\n\ndef optimize_production_line(tasks: List[int], workers: int) -> int:\n    \"\"\"\n    A factory manager needs to optimize the production line by assigning tasks to workers efficiently.\n    Given a list of task durations and the number of available workers, determine the minimum time\n    required to complete all tasks if tasks can be performed in parallel.\n\n    This function uses both task scheduling and parallel processing concepts to solve the problem.\n\n\n    [EXAMPLES]\n    \n    assert candidate([100], 1) == 100\n    assert candidate([5, 10, 15, 20, 25, 30], 2) == 55\n\n    [/EXAMPLES]\n    \"\"\"\n```\n", "entry_point": "optimize_production_line", "solution": "from typing import List\nimport heapq\n\ndef optimize_production_line(tasks: List[int], workers: int) -> int:\n    \"\"\"\n    A factory manager needs to optimize the production line by assigning tasks to workers efficiently.\n    Given a list of task durations and the number of available workers, determine the minimum time\n    required to complete all tasks if tasks can be performed in parallel.\n\n    This function uses both task scheduling and parallel processing concepts to solve the problem.\n\n\n    [EXAMPLES]\n    \n    assert candidate([100], 1) == 100\n    assert candidate([5, 10, 15, 20, 25, 30], 2) == 55\n\n    [/EXAMPLES]\n    \"\"\"\n    # Sort tasks in descending order\n    tasks.sort(reverse=True)\n    \n    # Initialize a min heap to keep track of worker finish times\n    worker_times = [0] * workers\n    heapq.heapify(worker_times)\n    \n    # Assign tasks to workers\n    for task in tasks:\n        # Get the worker with the earliest finish time\n        earliest_finish = heapq.heappop(worker_times)\n        # Assign the task to this worker\n        new_finish_time = earliest_finish + task\n        # Update the worker's finish time\n        heapq.heappush(worker_times, new_finish_time)\n    \n    # The total time is the maximum finish time among all workers\n    return max(worker_times)\n\n", "test": "def check(candidate):\n    assert candidate([1, 2, 3, 4, 5], 5) == 5\n    assert candidate([5, 10, 15, 20, 25, 30], 2) == 55\n    assert candidate([3, 3, 3, 3, 3, 3, 3, 3, 3, 3], 2) == 15\n    assert candidate([50, 50, 50, 50, 50], 3) == 100\n    assert candidate([1, 1, 1, 1, 1], 2) == 3\n    assert candidate([5, 5, 5, 5, 5], 5) == 5\n    assert candidate([100], 1) == 100\n    assert candidate([1, 2, 3], 1) == 6\n    assert candidate([1, 2, 3, 4, 5, 6, 7, 8, 9, 10], 3) == 19\n    assert candidate([10, 20, 30, 40, 50], 2) == 80\n", "language": "python"}
{"task_id": "8294ebf0-26f7-4070-8ebe-4a18c702fd411238387657134669580", "prompt": "I'll implement the rest of the function to match what the docstring describes. The full solution will be in a single code block.\n\n```python\nfrom typing import List\n\ndef treasure_hunt(map_size: int, clues: List[str]) -> List[int]:\n    \"\"\"\n    You are a treasure hunter in an ancient temple. The temple floor is a grid of size n x n,\n    and you have a list of cryptic clues that guide you to the treasure. Each clue is a string\n    that represents a movement direction: 'N' (North), 'S' (South), 'E' (East), or 'W' (West).\n    Your task is to follow these clues and find the final position of the treasure.\n\n    You start at position [0, 0] (top-left corner of the grid). If a move would take you off\n    the grid, it wraps around to the opposite side.\n\n    Return the final [x, y] coordinates of the treasure.\n\n\n    [EXAMPLES]\n    \n    assert candidate(5, []) == [0, 0]\n    assert candidate(50, [\"S\"] * 25 + [\"W\"] * 25) == [25, 25]\n\n    [/EXAMPLES]\n    \"\"\"\n```\n", "entry_point": "treasure_hunt", "solution": "from typing import List\n\ndef treasure_hunt(map_size: int, clues: List[str]) -> List[int]:\n    \"\"\"\n    You are a treasure hunter in an ancient temple. The temple floor is a grid of size n x n,\n    and you have a list of cryptic clues that guide you to the treasure. Each clue is a string\n    that represents a movement direction: 'N' (North), 'S' (South), 'E' (East), or 'W' (West).\n    Your task is to follow these clues and find the final position of the treasure.\n\n    You start at position [0, 0] (top-left corner of the grid). If a move would take you off\n    the grid, it wraps around to the opposite side.\n\n    Return the final [x, y] coordinates of the treasure.\n\n\n    [EXAMPLES]\n    \n    assert candidate(5, []) == [0, 0]\n    assert candidate(50, [\"S\"] * 25 + [\"W\"] * 25) == [25, 25]\n\n    [/EXAMPLES]\n    \"\"\"\n    def move(position, direction):\n        x, y = position\n        if direction == 'N':\n            y = (y - 1) % map_size\n        elif direction == 'S':\n            y = (y + 1) % map_size\n        elif direction == 'E':\n            x = (x + 1) % map_size\n        elif direction == 'W':\n            x = (x - 1) % map_size\n        return [x, y]\n\n    position = [0, 0]\n    for clue in clues:\n        position = move(position, clue)\n\n    return position\n\n", "test": "def check(candidate):\n    assert candidate(7, [\"E\", \"E\", \"E\", \"E\", \"E\", \"E\", \"E\"]) == [0, 0]\n    assert candidate(100, [\"N\"] * 99 + [\"E\"] * 99) == [99, 1]\n    assert candidate(3, [\"S\", \"S\", \"S\", \"S\", \"E\", \"E\", \"N\", \"W\"]) == [1, 0]\n    assert candidate(15, [\"N\"] * 7 + [\"E\"] * 7 + [\"S\"] * 7 + [\"W\"] * 7) == [0, 0]\n    assert candidate(50, [\"S\"] * 25 + [\"W\"] * 25) == [25, 25]\n    assert candidate(5, []) == [0, 0]\n    assert candidate(8, [\"N\", \"E\"] * 8) == [0, 0]\n    assert candidate(3, [\"N\", \"E\", \"S\", \"W\"] * 100) == [0, 0]\n    assert candidate(10, [\"N\", \"N\", \"N\", \"N\", \"N\", \"N\", \"N\", \"N\", \"N\", \"N\"]) == [0, 0]\n    assert candidate(30, [\"N\", \"N\", \"E\", \"E\", \"S\", \"S\", \"W\", \"W\"] * 5) == [0, 0]\n", "language": "python"}
{"task_id": "789d7267-dcf0-4039-8e9c-83edd89212bb3515225911570896020", "prompt": "Please complete the function implementation based on the provided docstring. Here's the function in a single code block. I'll ensure it handles edge cases properly.\n\n```python\nimport re\n\ndef analyze_password_strength(password: str) -> str:\n    \"\"\"\n    In a cybersecurity application, this function evaluates the strength of a given password.\n    It checks for the following criteria:\n    1. At least 8 characters long\n    2. Contains both uppercase and lowercase letters\n    3. Contains at least one digit\n    4. Contains at least one special character (!@#$%^&*()_+-=[]{}|;:,.<>?)\n    \n    The function returns 'Weak' if 0-1 criteria are met, 'Moderate' for 2-3 criteria, and 'Strong' for all 4.\n    This implementation requires the use of regular expressions and conditional statements.\n\n\n    [EXAMPLES]\n    \n    assert candidate(\"Abcd@#$%\") == 'Moderate'\n    assert candidate(\"a\") == 'Weak'\n\n    [/EXAMPLES]\n    \"\"\"\n```\n", "entry_point": "analyze_password_strength", "solution": "import re\n\ndef analyze_password_strength(password: str) -> str:\n    \"\"\"\n    In a cybersecurity application, this function evaluates the strength of a given password.\n    It checks for the following criteria:\n    1. At least 8 characters long\n    2. Contains both uppercase and lowercase letters\n    3. Contains at least one digit\n    4. Contains at least one special character (!@#$%^&*()_+-=[]{}|;:,.<>?)\n    \n    The function returns 'Weak' if 0-1 criteria are met, 'Moderate' for 2-3 criteria, and 'Strong' for all 4.\n    This implementation requires the use of regular expressions and conditional statements.\n\n\n    [EXAMPLES]\n    \n    assert candidate(\"Abcd@#$%\") == 'Moderate'\n    assert candidate(\"a\") == 'Weak'\n\n    [/EXAMPLES]\n    \"\"\"\n    criteria_met = 0\n\n    # Check length\n    if len(password) >= 8:\n        criteria_met += 1\n\n    # Check for uppercase and lowercase letters\n    if re.search(r'[a-z]', password) and re.search(r'[A-Z]', password):\n        criteria_met += 1\n\n    # Check for at least one digit\n    if re.search(r'\\d', password):\n        criteria_met += 1\n\n    # Check for at least one special character\n    if re.search(r'[!@#$%^&*()_+\\-=\\[\\]{}|;:,.<>?]', password):\n        criteria_met += 1\n\n    # Determine password strength based on criteria met\n    if criteria_met <= 1:\n        return \"Weak\"\n    elif criteria_met <= 3:\n        return \"Moderate\"\n    else:\n        return \"Strong\"\n\n", "test": "def check(candidate):\n    assert candidate(\"password123!\") == 'Moderate'\n    assert candidate(\"ABCDEFGH\") == 'Weak'\n    assert candidate(\"a\") == 'Weak'\n    assert candidate(\"P@ssw0rd\") == 'Strong'\n    assert candidate(\"Password123\") == 'Moderate'\n    assert candidate(\"abcd@#$%\") == 'Moderate'\n    assert candidate(\"Abcd1@#$\") == 'Strong'\n    assert candidate(\"!@#$%^&*()_+-=[]{}|;:,.<>?\") == 'Moderate'\n    assert candidate(\"Abcd@#$%\") == 'Moderate'\n    assert candidate(\"Aa1!\") == 'Moderate'\n", "language": "python"}
{"task_id": "69b10ed8-571f-46a1-9a0a-8cf9dddd051c3723567581862836450", "prompt": "Your function completion is coming up. I'll ensure it's contained within a single executable code block, with any necessary helper functionality defined inside the main function. Only libraries already imported in the problem will be used, and I won't add any code outside the function scope.\n\n```python\ndef decrypt_ancient_script(encrypted_text: str, shift: int) -> str:\n    \"\"\"\n    Decrypt an ancient script using a simple substitution cipher.\n\n    This function takes an encrypted text from an archaeological dig and attempts\n    to decrypt it using a Caesar cipher-like method. It involves concepts of\n    string manipulation and modular arithmetic.\n\n    Args:\n    encrypted_text (str): The text to be decrypted, containing only uppercase letters.\n    shift (int): The number of positions each letter should be shifted back.\n\n    Returns:\n    str: The decrypted text.\n\n\n    [EXAMPLES]\n    \n    assert candidate(\"ABCDEFGHIJKLMNOPQRSTUVWXYZ\", 26) == 'ABCDEFGHIJKLMNOPQRSTUVWXYZ'\n    assert candidate(\"KHOOR ZRUOG\", 3) == 'HELLO WORLD'\n\n    [/EXAMPLES]\n    \"\"\"\n```\n", "entry_point": "decrypt_ancient_script", "solution": "def decrypt_ancient_script(encrypted_text: str, shift: int) -> str:\n    \"\"\"\n    Decrypt an ancient script using a simple substitution cipher.\n\n    This function takes an encrypted text from an archaeological dig and attempts\n    to decrypt it using a Caesar cipher-like method. It involves concepts of\n    string manipulation and modular arithmetic.\n\n    Args:\n    encrypted_text (str): The text to be decrypted, containing only uppercase letters.\n    shift (int): The number of positions each letter should be shifted back.\n\n    Returns:\n    str: The decrypted text.\n\n\n    [EXAMPLES]\n    \n    assert candidate(\"ABCDEFGHIJKLMNOPQRSTUVWXYZ\", 26) == 'ABCDEFGHIJKLMNOPQRSTUVWXYZ'\n    assert candidate(\"KHOOR ZRUOG\", 3) == 'HELLO WORLD'\n\n    [/EXAMPLES]\n    \"\"\"\n    decrypted_text = \"\"\n    for char in encrypted_text:\n        if char.isalpha():\n            # Convert the character to its ASCII value\n            ascii_value = ord(char)\n            # Shift the ASCII value back by the specified amount\n            shifted_ascii = (ascii_value - 65 - shift) % 26 + 65\n            # Convert the shifted ASCII value back to a character\n            decrypted_char = chr(shifted_ascii)\n            decrypted_text += decrypted_char\n        else:\n            # If the character is not a letter, keep it as is\n            decrypted_text += char\n    \n    return decrypted_text\n\n", "test": "def check(candidate):\n    assert candidate(\"ABCDEFGHIJKLMNOPQRSTUVWXYZ\", 26) == 'ABCDEFGHIJKLMNOPQRSTUVWXYZ'\n    assert candidate(\"A\", 25) == 'B'\n    assert candidate(\"X\", 24) == 'Z'\n    assert candidate(\"ZZZZZZ\", 1) == 'YYYYYY'\n    assert candidate(\"THE QUICK BROWN FOX JUMPS OVER THE LAZY DOG\", 23) == 'WKH TXLFN EURZQ IRA MXPSV RYHU WKH ODCB GRJ'\n    assert candidate(\"AAAAAA\", 25) == 'BBBBBB'\n    assert candidate(\"ARCHAEOLOGICAL DIG\", 10) == 'QHSXQUEBEWYSQB TYW'\n    assert candidate(\"ABC\", 1) == 'ZAB'\n    assert candidate(\"KHOOR ZRUOG\", 3) == 'HELLO WORLD'\n    assert candidate(\"QRSTUVWXYZABCDEFGHIJKLMNOP\", 16) == 'ABCDEFGHIJKLMNOPQRSTUVWXYZ'\n", "language": "python"}
{"task_id": "c25ad63c-fc66-480b-9a00-72a216b130716089560425529860418", "prompt": "I serve as a coding assistant dedicated to completing functions that can run immediately when executed. My code will be confined to the function block you specify, utilizing only the libraries mentioned in your problem. Any supplementary functions or classes will be defined within the main function.\n\n```python\nfrom typing import List\nimport heapq\n\ndef optimize_network_latency(nodes: int, connections: List[List[int]], source: int) -> List[int]:\n    \"\"\"You're a network engineer tasked with optimizing the latency in a computer network. The network consists of nodes\n    connected by bidirectional links with varying latencies. Your goal is to find the minimum latency from a source node\n    to all other nodes in the network.\n\n    The function takes three parameters:\n    1. nodes: An integer representing the number of nodes in the network (0 to nodes-1).\n    2. connections: A list of lists, where each inner list [a, b, latency] represents a bidirectional connection\n       between nodes a and b with the given latency.\n    3. source: An integer representing the source node.\n\n    Return a list of integers where the i-th element represents the minimum latency from the source node to node i.\n    If a node is unreachable, its latency should be -1.\n\n    Use Dijkstra's algorithm with a priority queue for optimal performance.\n\n\n    [EXAMPLES]\n    \n    assert candidate(3, [[0,1,1],[1,2,1],[0,2,3]], 1) == [1, 0, 1]\n    assert candidate(6, [[0,1,1],[1,2,1],[2,3,1],[3,4,1],[4,5,1]], 0) == [0, 1, 2, 3, 4, 5]\n\n    [/EXAMPLES]\n    \"\"\"\n```\n", "entry_point": "optimize_network_latency", "solution": "from typing import List\nimport heapq\n\ndef optimize_network_latency(nodes: int, connections: List[List[int]], source: int) -> List[int]:\n    \"\"\"You're a network engineer tasked with optimizing the latency in a computer network. The network consists of nodes\n    connected by bidirectional links with varying latencies. Your goal is to find the minimum latency from a source node\n    to all other nodes in the network.\n\n    The function takes three parameters:\n    1. nodes: An integer representing the number of nodes in the network (0 to nodes-1).\n    2. connections: A list of lists, where each inner list [a, b, latency] represents a bidirectional connection\n       between nodes a and b with the given latency.\n    3. source: An integer representing the source node.\n\n    Return a list of integers where the i-th element represents the minimum latency from the source node to node i.\n    If a node is unreachable, its latency should be -1.\n\n    Use Dijkstra's algorithm with a priority queue for optimal performance.\n\n\n    [EXAMPLES]\n    \n    assert candidate(3, [[0,1,1],[1,2,1],[0,2,3]], 1) == [1, 0, 1]\n    assert candidate(6, [[0,1,1],[1,2,1],[2,3,1],[3,4,1],[4,5,1]], 0) == [0, 1, 2, 3, 4, 5]\n\n    [/EXAMPLES]\n    \"\"\"\n    def build_graph(nodes, connections):\n        graph = [[] for _ in range(nodes)]\n        for a, b, latency in connections:\n            graph[a].append((b, latency))\n            graph[b].append((a, latency))\n        return graph\n\n    def dijkstra(graph, source, nodes):\n        latencies = [-1] * nodes\n        latencies[source] = 0\n        pq = [(0, source)]\n\n        while pq:\n            current_latency, current_node = heapq.heappop(pq)\n\n            if current_latency > latencies[current_node]:\n                continue\n\n            for neighbor, edge_latency in graph[current_node]:\n                new_latency = current_latency + edge_latency\n\n                if latencies[neighbor] == -1 or new_latency < latencies[neighbor]:\n                    latencies[neighbor] = new_latency\n                    heapq.heappush(pq, (new_latency, neighbor))\n\n        return latencies\n\n    graph = build_graph(nodes, connections)\n    return dijkstra(graph, source, nodes)\n\n", "test": "def check(candidate):\n    assert candidate(3, [[0,1,1],[1,2,1],[0,2,3]], 1) == [1, 0, 1]\n    assert candidate(5, [[0,1,3],[1,2,2],[0,3,5],[3,4,1]], 0) == [0, 3, 5, 5, 6]\n    assert candidate(3, [[0,1,1],[1,2,1]], 0) == [0, 1, 2]\n    assert candidate(6, [[0,1,1],[1,2,1],[2,3,1],[3,4,1],[4,5,1]], 0) == [0, 1, 2, 3, 4, 5]\n    assert candidate(8, [[0,1,1],[1,2,1],[2,3,1],[3,4,1],[4,5,1],[5,6,1],[6,7,1],[0,7,10]], 0) == [0, 1, 2, 3, 4, 5, 6, 7]\n    assert candidate(5, [[0,1,1],[1,2,2],[2,3,3],[3,4,4]], 4) == [10, 9, 7, 4, 0]\n    assert candidate(3, [[0,1,1],[1,2,1]], 1) == [1, 0, 1]\n    assert candidate(4, [[0,1,10],[0,2,5],[1,2,2],[2,3,4]], 0) == [0, 7, 5, 9]\n    assert candidate(4, [[0,1,1],[1,2,1],[2,3,1],[3,0,1]], 2) == [2, 1, 0, 1]\n    assert candidate(2, [[0,1,100]], 0) == [0, 100]\n", "language": "python"}
{"task_id": "0d04938a-7ab0-4af3-819b-f1983256a9f48351355809035390108", "prompt": "Please implement the rest of the function according to the documentation string. Put the entire function in one code block, and make sure you handle all potential edge cases.\n\n```python\nfrom typing import List\n\ndef calculate_water_flow(heights: List[int]) -> int:\n    \"\"\"\n    Calculate the amount of water that can be trapped between walls of different heights.\n\n    Given a list of non-negative integers representing the heights of walls,\n    compute how much water can be trapped between the walls when it rains.\n\n    Args:\n    heights (List[int]): A list of integers representing the heights of walls.\n\n    Returns:\n    int: The total amount of water that can be trapped.\n\n\n    [EXAMPLES]\n    \n    assert candidate([7,0,7,0,7]) == 14\n    assert candidate([1,0,1,0,1,0,1]) == 3\n\n    [/EXAMPLES]\n    \"\"\"\n```\n", "entry_point": "calculate_water_flow", "solution": "from typing import List\n\ndef calculate_water_flow(heights: List[int]) -> int:\n    \"\"\"\n    Calculate the amount of water that can be trapped between walls of different heights.\n\n    Given a list of non-negative integers representing the heights of walls,\n    compute how much water can be trapped between the walls when it rains.\n\n    Args:\n    heights (List[int]): A list of integers representing the heights of walls.\n\n    Returns:\n    int: The total amount of water that can be trapped.\n\n\n    [EXAMPLES]\n    \n    assert candidate([7,0,7,0,7]) == 14\n    assert candidate([1,0,1,0,1,0,1]) == 3\n\n    [/EXAMPLES]\n    \"\"\"\n    if not heights:\n        return 0\n\n    n = len(heights)\n    left_max = [0] * n\n    right_max = [0] * n\n    water = 0\n\n    # Calculate maximum height to the left of each position\n    left_max[0] = heights[0]\n    for i in range(1, n):\n        left_max[i] = max(left_max[i-1], heights[i])\n\n    # Calculate maximum height to the right of each position\n    right_max[n-1] = heights[n-1]\n    for i in range(n-2, -1, -1):\n        right_max[i] = max(right_max[i+1], heights[i])\n\n    # Calculate water trapped at each position\n    for i in range(n):\n        water += min(left_max[i], right_max[i]) - heights[i]\n\n    return water\n\n", "test": "def check(candidate):\n    assert candidate([1]) == 0\n    assert candidate([1,2,3,4,5]) == 0\n    assert candidate([5,4,3,2,1]) == 0\n    assert candidate([0,1,0,2,1,0,1,3,2,1,2,1]) == 6\n    assert candidate([1,0,1,0,1,0,1]) == 3\n    assert candidate([7,0,7,0,7]) == 14\n    assert candidate([0,0,0,0,5]) == 0\n    assert candidate([10,0,10]) == 10\n    assert candidate([2,1,2]) == 1\n    assert candidate([3,0,0,2,0,4]) == 10\n", "language": "python"}
{"task_id": "80daaf82-6802-4ba2-8277-e7e2c380fb1e8082636522981318095", "prompt": "My task is to implement a function that works when executed directly. I'll include any necessary helper functions inside the main function, use only the imported libraries mentioned, and provide my solution as a single code block.\n\n```python\nfrom typing import List\n\ndef decode_alien_message(symbols: List[str]) -> str:\n    \"\"\"\n    An alien civilization has sent us a message encoded in their unique symbol system.\n    We've discovered that their language uses a stack-based encoding where certain symbols\n    represent operations on the previous symbols.\n\n    The function takes a list of alien symbols and returns the decoded message as a string.\n    \n    The decoding rules are as follows:\n    - Normal symbols are added to the message.\n    - '#' deletes the last symbol added.\n    - '@' duplicates the last symbol.\n    - '&' swaps the last two symbols.\n\n    This function should use a stack data structure to decode the message.\n\n\n    [EXAMPLES]\n    \n    assert candidate(['a', 'b', 'c', '#', '@', '&', '#', '@', '&']) == 'abb'\n    assert candidate(['1', '2', '3', '@', '4', '5', '&', '#', '6']) == '123356'\n\n    [/EXAMPLES]\n    \"\"\"\n```\n", "entry_point": "decode_alien_message", "solution": "from typing import List\n\ndef decode_alien_message(symbols: List[str]) -> str:\n    \"\"\"\n    An alien civilization has sent us a message encoded in their unique symbol system.\n    We've discovered that their language uses a stack-based encoding where certain symbols\n    represent operations on the previous symbols.\n\n    The function takes a list of alien symbols and returns the decoded message as a string.\n    \n    The decoding rules are as follows:\n    - Normal symbols are added to the message.\n    - '#' deletes the last symbol added.\n    - '@' duplicates the last symbol.\n    - '&' swaps the last two symbols.\n\n    This function should use a stack data structure to decode the message.\n\n\n    [EXAMPLES]\n    \n    assert candidate(['a', 'b', 'c', '#', '@', '&', '#', '@', '&']) == 'abb'\n    assert candidate(['1', '2', '3', '@', '4', '5', '&', '#', '6']) == '123356'\n\n    [/EXAMPLES]\n    \"\"\"\n    stack = []\n    \n    for symbol in symbols:\n        if symbol == '#':\n            if stack:\n                stack.pop()\n        elif symbol == '@':\n            if stack:\n                stack.append(stack[-1])\n        elif symbol == '&':\n            if len(stack) >= 2:\n                stack[-1], stack[-2] = stack[-2], stack[-1]\n        else:\n            stack.append(symbol)\n    \n    return ''.join(stack)\n\n", "test": "def check(candidate):\n    assert candidate(['h', 'e', 'l', 'l', 'o', '#', '#', '#', '#', '#', 'w', 'o', 'r', 'l', 'd']) == 'world'\n    assert candidate(['a', 'b', 'c', '@', '@', '@']) == 'abcccc'\n    assert candidate(['1', '2', '3', '@', '4', '5', '&', '#', '6']) == '123356'\n    assert candidate(['a', 'b', '&', 'c', 'd', '&', 'e', 'f', '&']) == 'badcfe'\n    assert candidate(['x', 'y', 'z', '#', '#', '#', 'a', 'b', 'c', '@', '@', '@']) == 'abcccc'\n    assert candidate(['a', 'b', 'c', '#', '@', '&', '#', '@', '&']) == 'abb'\n    assert candidate(['@']) == ''\n    assert candidate(['a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', '#', '#', '#', '#', '#']) == 'abcde'\n", "language": "python"}
{"task_id": "2bbb90ac-c576-4ade-8751-2a65ab6f147f4421152663559636046", "prompt": "Complete the function code according to the specifications in the docstring. Present the full function in a single code block.\n\n```python\nfrom typing import List, Dict\nfrom collections import defaultdict\n\ndef ancient_library_organizer(n: int, scrolls: Dict[int, List[str]]) -> List[str]:\n    \"\"\"\n    In an ancient library, scrolls are organized in a unique hierarchical system. Each level of the library\n    contains scrolls with titles sorted alphabetically. Each scroll has a reference to the next scroll on the\n    same level and to a list of related scrolls on the level below.\n\n    Your task is to reorganize the scrolls into a single, alphabetically sorted list for easier access.\n\n\n    [EXAMPLES]\n    \n    assert candidate(3, {3: ['C'], 2: ['B', 'B'], 1: ['A', 'A', 'A']}) == ['A', 'A', 'A', 'B', 'B', 'C']\n    assert candidate(2, {2: [], 1: []}) == []\n\n    [/EXAMPLES]\n    \"\"\"\n```\n", "entry_point": "ancient_library_organizer", "solution": "from typing import List, Dict\nfrom collections import defaultdict\n\ndef ancient_library_organizer(n: int, scrolls: Dict[int, List[str]]) -> List[str]:\n    \"\"\"\n    In an ancient library, scrolls are organized in a unique hierarchical system. Each level of the library\n    contains scrolls with titles sorted alphabetically. Each scroll has a reference to the next scroll on the\n    same level and to a list of related scrolls on the level below.\n\n    Your task is to reorganize the scrolls into a single, alphabetically sorted list for easier access.\n\n\n    [EXAMPLES]\n    \n    assert candidate(3, {3: ['C'], 2: ['B', 'B'], 1: ['A', 'A', 'A']}) == ['A', 'A', 'A', 'B', 'B', 'C']\n    assert candidate(2, {2: [], 1: []}) == []\n\n    [/EXAMPLES]\n    \"\"\"\n    def merge_sorted_lists(list1: List[str], list2: List[str]) -> List[str]:\n        \"\"\"\n        Merge two sorted lists into a single sorted list.\n        \"\"\"\n        merged = []\n        i, j = 0, 0\n        while i < len(list1) and j < len(list2):\n            if list1[i] <= list2[j]:\n                merged.append(list1[i])\n                i += 1\n            else:\n                merged.append(list2[j])\n                j += 1\n        merged.extend(list1[i:])\n        merged.extend(list2[j:])\n        return merged\n\n    # Start from the bottom level and merge upwards\n    sorted_scrolls = scrolls.get(1, [])\n    for level in range(2, n + 1):\n        current_level_scrolls = scrolls.get(level, [])\n        sorted_scrolls = merge_sorted_lists(sorted_scrolls, current_level_scrolls)\n\n    return sorted_scrolls\n\n", "test": "def check(candidate):\n    assert candidate(1, {1: []}) == []\n    assert candidate(2, {2: [], 1: []}) == []\n    assert candidate(3, {3: ['I', 'H', 'G'], 2: ['F', 'E', 'D'], 1: ['C', 'B', 'A']}) == ['C', 'B', 'A', 'F', 'E', 'D', 'I', 'H', 'G']\n    assert candidate(3, {3: ['C'], 2: ['B'], 1: ['A']}) == ['A', 'B', 'C']\n    assert candidate(1, {1: ['Z', 'Y', 'X']}) == ['Z', 'Y', 'X']\n    assert candidate(3, {3: [], 2: [], 1: []}) == []\n    assert candidate(1, {1: ['A']}) == ['A']\n    assert candidate(1, {1: ['A', 'A', 'A']}) == ['A', 'A', 'A']\n    assert candidate(2, {2: ['Ab', 'aB'], 1: ['AB', 'ab']}) == ['AB', 'Ab', 'aB', 'ab']\n    assert candidate(3, {3: ['C'], 2: ['B', 'B'], 1: ['A', 'A', 'A']}) == ['A', 'A', 'A', 'B', 'B', 'C']\n", "language": "python"}
{"task_id": "7500d734-06e1-448d-b134-6eab300e47d8538736204032902902", "prompt": "The function will be implemented in full, with any additional classes or functions defined inside it. I'll only use the libraries already imported and will provide code that can be executed without modification.\n\n```python\nfrom typing import List\n\ndef design_rollercoaster(height_requirements: List[int], rider_heights: List[int]) -> int:\n    \"\"\"\n    As an amusement park engineer, you're designing a new rollercoaster with multiple sections. Each\n    section has a minimum height requirement. You want to determine how many riders can experience the\n    entire rollercoaster.\n\n    The function takes two lists:\n    1. height_requirements: A list of integers representing the minimum height required for each section\n       of the rollercoaster, in order.\n    2. rider_heights: A list of integers representing the heights of potential riders.\n\n    Return the number of riders who meet the height requirements for all sections of the rollercoaster.\n\n\n    [EXAMPLES]\n    \n    assert candidate([100, 200], [150]) == 0\n    assert candidate([200, 200, 200, 200], [199, 200, 201]) == 2\n\n    [/EXAMPLES]\n    \"\"\"\n```\n", "entry_point": "design_rollercoaster", "solution": "from typing import List\n\ndef design_rollercoaster(height_requirements: List[int], rider_heights: List[int]) -> int:\n    \"\"\"\n    As an amusement park engineer, you're designing a new rollercoaster with multiple sections. Each\n    section has a minimum height requirement. You want to determine how many riders can experience the\n    entire rollercoaster.\n\n    The function takes two lists:\n    1. height_requirements: A list of integers representing the minimum height required for each section\n       of the rollercoaster, in order.\n    2. rider_heights: A list of integers representing the heights of potential riders.\n\n    Return the number of riders who meet the height requirements for all sections of the rollercoaster.\n\n\n    [EXAMPLES]\n    \n    assert candidate([100, 200], [150]) == 0\n    assert candidate([200, 200, 200, 200], [199, 200, 201]) == 2\n\n    [/EXAMPLES]\n    \"\"\"\n    def can_ride_all_sections(rider_height: int) -> bool:\n        \"\"\"\n        Check if a rider can ride all sections of the rollercoaster.\n        \"\"\"\n        return all(rider_height >= req for req in height_requirements)\n\n    eligible_riders = sum(1 for rider in rider_heights if can_ride_all_sections(rider))\n    return eligible_riders\n\n", "test": "def check(candidate):\n    assert candidate([100], [100]) == 1\n    assert candidate([100, 100, 100], [99, 100, 101]) == 2\n    assert candidate([140, 150, 160, 170, 180], [135, 145, 155, 165, 175, 185]) == 1\n    assert candidate([130, 140, 150], [129, 139, 149, 159]) == 1\n    assert candidate([100, 200, 300], [50, 150, 250, 350]) == 1\n    assert candidate([120, 130, 140], [110, 120, 130, 140, 150]) == 2\n    assert candidate([150], []) == 0\n    assert candidate([200, 200, 200, 200], [199, 200, 201]) == 2\n    assert candidate([100], [99, 100, 101]) == 2\n    assert candidate([100, 200], [150]) == 0\n", "language": "python"}
{"task_id": "eed70b34-772c-4340-a7fa-f44e0a6127b74734023043839609861", "prompt": "Please finish implementing the function according to its documentation. Provide the complete function in one code block.\n\n```python\ndef calculate_delivery_fee(distance: float, weight: float, express: bool) -> float:\n    \"\"\"\n    Calculates the delivery fee for a package based on distance, weight, and delivery speed.\n\n    This function determines the cost of shipping a package using a combination of\n    distance-based and weight-based pricing, with an additional fee for express delivery.\n    The base rate is $5, with $0.5 per km and $2 per kg. Express delivery adds a 50% surcharge.\n\n    Args:\n        distance (float): The distance to deliver the package in kilometers.\n        weight (float): The weight of the package in kilograms.\n        express (bool): Whether express delivery is requested.\n\n    Returns:\n        float: The calculated delivery fee.\n\n\n    [EXAMPLES]\n    \n    assert candidate(100, 10, False) == 75.0\n    assert candidate(200, 0.5, False) == 106.0\n\n    [/EXAMPLES]\n    \"\"\"\n```\n", "entry_point": "calculate_delivery_fee", "solution": "def calculate_delivery_fee(distance: float, weight: float, express: bool) -> float:\n    \"\"\"\n    Calculates the delivery fee for a package based on distance, weight, and delivery speed.\n\n    This function determines the cost of shipping a package using a combination of\n    distance-based and weight-based pricing, with an additional fee for express delivery.\n    The base rate is $5, with $0.5 per km and $2 per kg. Express delivery adds a 50% surcharge.\n\n    Args:\n        distance (float): The distance to deliver the package in kilometers.\n        weight (float): The weight of the package in kilograms.\n        express (bool): Whether express delivery is requested.\n\n    Returns:\n        float: The calculated delivery fee.\n\n\n    [EXAMPLES]\n    \n    assert candidate(100, 10, False) == 75.0\n    assert candidate(200, 0.5, False) == 106.0\n\n    [/EXAMPLES]\n    \"\"\"\n    # Base rate\n    base_fee = 5.0\n\n    # Distance-based fee\n    distance_fee = 0.5 * distance\n\n    # Weight-based fee\n    weight_fee = 2.0 * weight\n\n    # Calculate total fee\n    total_fee = base_fee + distance_fee + weight_fee\n\n    # Apply express delivery surcharge if requested\n    if express:\n        total_fee *= 1.5\n\n    # Round the fee to two decimal places\n    return round(total_fee, 2)\n\n", "test": "def check(candidate):\n    assert candidate(0.1, 0.1, True) == 7.88\n    assert candidate(100, 10, False) == 75.0\n    assert candidate(75.3, 15.8, True) == 111.38\n    assert candidate(200, 0.5, True) == 159.0\n    assert candidate(50.5, 7.5, False) == 45.25\n    assert candidate(200, 0.5, False) == 106.0\n    assert candidate(50.5, 7.5, True) == 67.88\n    assert candidate(0.1, 0.1, False) == 5.25\n    assert candidate(1, 1, True) == 11.25\n    assert candidate(0, 0, True) == 7.5\n", "language": "python"}
{"task_id": "5d5d3d8e-ecfc-4aad-8ce3-19d4d9e1b3593993755257218349349", "prompt": "I'll create a complete implementation of the specified function that's ready to execute. Any additional functions or classes will be defined within the main function scope. I'll only use the libraries that are already imported in the problem statement.\n\n```python\ndef optimize_knapsack(values: list, weights: list, capacity: int) -> int:\n    \"\"\"\n    In operations research, the knapsack problem is a problem in combinatorial optimization.\n    This function solves the 0/1 knapsack problem using dynamic programming.\n\n    Parameters:\n    values (list): A list of integers representing the values of the items\n    weights (list): A list of integers representing the weights of the items\n    capacity (int): The maximum weight capacity of the knapsack\n\n    Returns:\n    int: The maximum value that can be achieved\n\n\n    [EXAMPLES]\n    \n    assert candidate([5, 4, 3, 2, 1], [5, 4, 3, 2, 1], 10) == 10\n    assert candidate([1, 1, 1], [1, 1, 1], 2) == 2\n\n    [/EXAMPLES]\n    \"\"\"\n```\n", "entry_point": "optimize_knapsack", "solution": "def optimize_knapsack(values: list, weights: list, capacity: int) -> int:\n    \"\"\"\n    In operations research, the knapsack problem is a problem in combinatorial optimization.\n    This function solves the 0/1 knapsack problem using dynamic programming.\n\n    Parameters:\n    values (list): A list of integers representing the values of the items\n    weights (list): A list of integers representing the weights of the items\n    capacity (int): The maximum weight capacity of the knapsack\n\n    Returns:\n    int: The maximum value that can be achieved\n\n\n    [EXAMPLES]\n    \n    assert candidate([5, 4, 3, 2, 1], [5, 4, 3, 2, 1], 10) == 10\n    assert candidate([1, 1, 1], [1, 1, 1], 2) == 2\n\n    [/EXAMPLES]\n    \"\"\"\n    n = len(values)\n    \n    # Create a 2D table to store the maximum values\n    # dp[i][w] represents the maximum value that can be obtained\n    # using the first i items and a knapsack of capacity w\n    dp = [[0 for _ in range(capacity + 1)] for _ in range(n + 1)]\n    \n    # Fill the dp table\n    for i in range(1, n + 1):\n        for w in range(1, capacity + 1):\n            if weights[i-1] <= w:\n                # If the current item can fit, we have two choices:\n                # 1. Include the item\n                # 2. Don't include the item\n                # We take the maximum of these two choices\n                dp[i][w] = max(values[i-1] + dp[i-1][w-weights[i-1]], dp[i-1][w])\n            else:\n                # If the current item doesn't fit, we can't include it\n                dp[i][w] = dp[i-1][w]\n    \n    # The maximum value is stored in the bottom-right cell of the dp table\n    return dp[n][capacity]\n\n", "test": "def check(candidate):\n    assert candidate([1000], [1000], 999) == 0\n    assert candidate([1], [1], 1) == 1\n    assert candidate([100, 200, 300, 400], [10, 20, 30, 40], 50) == 500\n    assert candidate([10, 20, 30, 40, 50], [5, 5, 5, 5, 5], 15) == 120\n    assert candidate([], [], 0) == 0\n    assert candidate([100, 100, 100, 100, 100], [1, 2, 3, 4, 5], 10) == 400\n    assert candidate([1, 1, 1], [1, 1, 1], 2) == 2\n    assert candidate([5, 10, 15, 20, 25], [1, 2, 3, 4, 5], 10) == 50\n    assert candidate([1000, 2000, 3000], [10, 20, 30], 50) == 5000\n    assert candidate([5, 4, 3, 2, 1], [5, 4, 3, 2, 1], 10) == 10\n", "language": "python"}
{"task_id": "c951ae91-aa07-4e95-abfb-20e6b61b44ee4668618576733137913", "prompt": "Here's the full implementation of the function that satisfies the docstring requirements, in one code block:\n\n```python\ndef compress_dna_sequence(dna: str) -> str:\n    \"\"\"\n    A bioinformatician wants to compress long DNA sequences to save storage space.\n    This function takes a DNA sequence (a string containing only 'A', 'T', 'C', and 'G')\n    and compresses it by replacing consecutive repeated nucleotides with the nucleotide\n    followed by the number of repetitions.\n\n    :param dna: A string representing a DNA sequence\n    :return: The compressed DNA sequence as a string\n\n\n    [EXAMPLES]\n    \n    assert candidate(\"AAABBBCCCDDDEEEFFF\") == 'A3B3C3D3E3F3'\n    assert candidate(\"AAAACCCCTTTGGGGA\") == 'A4C4T3G4A'\n\n    [/EXAMPLES]\n    \"\"\"\n```\n", "entry_point": "compress_dna_sequence", "solution": "def compress_dna_sequence(dna: str) -> str:\n    \"\"\"\n    A bioinformatician wants to compress long DNA sequences to save storage space.\n    This function takes a DNA sequence (a string containing only 'A', 'T', 'C', and 'G')\n    and compresses it by replacing consecutive repeated nucleotides with the nucleotide\n    followed by the number of repetitions.\n\n    :param dna: A string representing a DNA sequence\n    :return: The compressed DNA sequence as a string\n\n\n    [EXAMPLES]\n    \n    assert candidate(\"AAABBBCCCDDDEEEFFF\") == 'A3B3C3D3E3F3'\n    assert candidate(\"AAAACCCCTTTGGGGA\") == 'A4C4T3G4A'\n\n    [/EXAMPLES]\n    \"\"\"\n    if not dna:\n        return \"\"\n\n    compressed = []\n    current_nucleotide = dna[0]\n    count = 1\n\n    for nucleotide in dna[1:]:\n        if nucleotide == current_nucleotide:\n            count += 1\n        else:\n            compressed.append(current_nucleotide)\n            if count > 1:\n                compressed.append(str(count))\n            current_nucleotide = nucleotide\n            count = 1\n\n    compressed.append(current_nucleotide)\n    if count > 1:\n        compressed.append(str(count))\n\n    return \"\".join(compressed)\n\n", "test": "def check(candidate):\n    assert candidate(\"AAAAAAAAAATTTTTTTTTT\") == 'A10T10'\n    assert candidate(\"AAAACCCCTTTGGGGA\") == 'A4C4T3G4A'\n    assert candidate(\"ATGC\") == 'ATGC'\n    assert candidate(\"ACGTACGTACGTACGT\") == 'ACGTACGTACGTACGT'\n    assert candidate(\"AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\") == 'A40'\n    assert candidate(\"ATATATATATAT\") == 'ATATATATATAT'\n    assert candidate(\"AAATTTCCCGGG\") == 'A3T3C3G3'\n    assert candidate(\"ATCGATCGATCGATCGATCG\") == 'ATCGATCGATCGATCGATCG'\n    assert candidate(\"AAABBBCCCDDDEEEFFF\") == 'A3B3C3D3E3F3'\n    assert candidate(\"AAAA\") == 'A4'\n", "language": "python"}
{"task_id": "a2b11015-32c3-4880-b5af-2df78817f99c-606644509273804937", "prompt": "Following the documentation string, complete the function implementation. Write your entire solution in one code block.\n\n```python\nimport re\nfrom typing import List\n\ndef decode_alien_message(encoded_message: str, codebook: List[str]) -> str:\n    \"\"\"\n    Decipher an encoded message from an alien civilization using a provided codebook.\n    The codebook contains alien symbols and their corresponding Earth language translations.\n\n    Parameters:\n    encoded_message (str): The message encoded with alien symbols\n    codebook (List[str]): A list of strings where each string is in the format \"alien_symbol:earth_translation\"\n\n    Returns the decoded message in Earth language.\n\n\n    [EXAMPLES]\n    \n    assert candidate(\"\u03b6\u03c8\u03bb\u03b8\u03c8\u03b6\", [\"\u03b6:greetings\", \"\u03c8:from\", \"\u03bb:outer\", \"\u03b8:space\"]) == 'greetingsfromouterspacefromgreetings'\n    assert candidate(\"\u03c4\u03c5\u03c6\u03c7\u03c8\u03c9\", [\"\u03c4:!\", \"\u03c5:@\", \"\u03c6:#\", \"\u03c7:$\", \"\u03c8:%\", \"\u03c9:^\"]) == '!@#$%^'\n\n    [/EXAMPLES]\n    \"\"\"\n```\n", "entry_point": "decode_alien_message", "solution": "import re\nfrom typing import List\n\ndef decode_alien_message(encoded_message: str, codebook: List[str]) -> str:\n    \"\"\"\n    Decipher an encoded message from an alien civilization using a provided codebook.\n    The codebook contains alien symbols and their corresponding Earth language translations.\n\n    Parameters:\n    encoded_message (str): The message encoded with alien symbols\n    codebook (List[str]): A list of strings where each string is in the format \"alien_symbol:earth_translation\"\n\n    Returns the decoded message in Earth language.\n\n\n    [EXAMPLES]\n    \n    assert candidate(\"\u03b6\u03c8\u03bb\u03b8\u03c8\u03b6\", [\"\u03b6:greetings\", \"\u03c8:from\", \"\u03bb:outer\", \"\u03b8:space\"]) == 'greetingsfromouterspacefromgreetings'\n    assert candidate(\"\u03c4\u03c5\u03c6\u03c7\u03c8\u03c9\", [\"\u03c4:!\", \"\u03c5:@\", \"\u03c6:#\", \"\u03c7:$\", \"\u03c8:%\", \"\u03c9:^\"]) == '!@#$%^'\n\n    [/EXAMPLES]\n    \"\"\"\n    # Create a dictionary from the codebook\n    translation_dict = dict(entry.split(':') for entry in codebook)\n    \n    # Function to replace alien symbols with Earth translations\n    def replace_symbol(match):\n        symbol = match.group(0)\n        return translation_dict.get(symbol, symbol)\n    \n    # Create a regular expression pattern from alien symbols\n    alien_symbols = '|'.join(re.escape(symbol) for symbol in translation_dict.keys())\n    \n    # Use regex to replace all alien symbols with their Earth translations\n    decoded_message = re.sub(alien_symbols, replace_symbol, encoded_message)\n    \n    return decoded_message\n\n", "test": "def check(candidate):\n    assert candidate(\"\u00a7\u03a9\u00a5\", [\"\u00a7:hello\", \"\u03a9:world\", \"\u00a5:beautiful\", \"\u03a6:universe\"]) == 'helloworldbeautiful'\n    assert candidate(\"\u03b1\u03b2\u03b3\u03b4\u03b5\u03b6\u03b7\u03b8\u03b9\u03ba\u03bb\u03bc\u03bd\u03be\u03bf\u03c0\u03c1\u03c3\u03c4\u03c5\u03c6\u03c7\u03c8\u03c9\", [\"\u03b1:n\", \"\u03b2:o\", \"\u03b3:p\", \"\u03b4:q\", \"\u03b5:r\", \"\u03b6:s\", \"\u03b7:t\", \"\u03b8:u\", \"\u03b9:v\", \"\u03ba:w\", \"\u03bb:x\", \"\u03bc:y\", \"\u03bd:z\", \"\u03be:0\", \"\u03bf:1\", \"\u03c0:2\", \"\u03c1:3\", \"\u03c3:4\", \"\u03c4:5\", \"\u03c5:6\", \"\u03c6:7\", \"\u03c7:8\", \"\u03c8:9\", \"\u03c9: \"]) == 'nopqrstuvwxyz0123456789 '\n    assert candidate(\"\u00a7\u03a9\u00a5\u00a7\u03a9\", [\"\u00a7:hello\", \"\u03a9:world\", \"\u00a5:beautiful\"]) == 'helloworldbeautifulhelloworld'\n    assert candidate(\"\u03bd\u03be\u03bf\u03c0\u03c1\u03c3\", [\"\u03bd:1\", \"\u03be:2\", \"\u03bf:3\", \"\u03c0:4\", \"\u03c1:5\", \"\u03c3:6\"]) == '123456'\n    assert candidate(\"\u03b1\u03b2\u03b3\u03b4\u03b5\u03b6\u03b7\u03b8\u03b9\u03ba\u03bb\u03bc\u03bd\u03be\u03bf\u03c0\u03c1\u03c3\u03c4\u03c5\u03c6\u03c7\u03c8\u03c9\", [\"\u03b1:a\", \"\u03b2:b\", \"\u03b3:c\", \"\u03b4:d\", \"\u03b5:e\", \"\u03b6:f\", \"\u03b7:g\", \"\u03b8:h\", \"\u03b9:i\", \"\u03ba:j\", \"\u03bb:k\", \"\u03bc:l\", \"\u03bd:m\", \"\u03be:n\", \"\u03bf:o\", \"\u03c0:p\", \"\u03c1:q\", \"\u03c3:r\", \"\u03c4:s\", \"\u03c5:t\", \"\u03c6:u\", \"\u03c7:v\", \"\u03c8:w\", \"\u03c9:x\"]) == 'abcdefghijklmnopqrstuvwx'\n    assert candidate(\"\u03bc\u03bd\u03be\u03bf\u03c0\u03c1\", [\"\u03bc:hello\", \"\u03bd:world\", \"\u03be:how\", \"\u03bf:are\", \"\u03c0:you\", \"\u03c1:?\"]) == 'helloworldhowareyou?'\n    assert candidate(\"\u03c4\u03c5\u03c6\u03c7\u03c8\u03c9\", [\"\u03c4:!\", \"\u03c5:@\", \"\u03c6:#\", \"\u03c7:$\", \"\u03c8:%\", \"\u03c9:^\"]) == '!@#$%^'\n    assert candidate(\"\u03bc\u03bd\u03be\u03bf\u03c0\u03c1\u03c3\u03c4\u03c5\u03c6\u03c7\u03c8\u03c9\", [\"\u03bc:a\", \"\u03bd:b\", \"\u03be:c\", \"\u03bf:d\", \"\u03c0:e\", \"\u03c1:f\", \"\u03c3:g\", \"\u03c4:h\", \"\u03c5:i\", \"\u03c6:j\", \"\u03c7:k\", \"\u03c8:l\", \"\u03c9:m\"]) == 'abcdefghijklm'\n    assert candidate(\"ABCDEFG\", [\"A:1\", \"B:2\", \"C:3\", \"D:4\", \"E:5\", \"F:6\", \"G:7\"]) == '1234567'\n    assert candidate(\"\u03b6\u03c8\u03bb\u03b8\u03c8\u03b6\", [\"\u03b6:greetings\", \"\u03c8:from\", \"\u03bb:outer\", \"\u03b8:space\"]) == 'greetingsfromouterspacefromgreetings'\n", "language": "python"}
{"task_id": "31a89407-ec4e-4f62-995c-a47559812d701592685107597171663", "prompt": "Based on the provided documentation string, finish writing the function. Deliver your code in a single code block, and be sure to account for all possible edge cases.\n\n```python\nfrom typing import List\n\ndef decrypt_message(cipher: List[int], key: int) -> str:\n    \"\"\"You are a cryptanalyst working for a secret agency. You've intercepted an encrypted message \n    represented as a list of integers. Each integer represents a letter in the alphabet (1-26). \n    However, the message has been encrypted using a simple substitution cipher with a key.\n\n    Your task is to decrypt the message by shifting each number back by the key value, \n    wrapping around if necessary (e.g., 1 with key 2 becomes 25). \n    Then convert the decrypted numbers back to letters (1=A, 2=B, ..., 26=Z).\n\n    Take a list of integers 'cipher' and an integer 'key' as input, and return the decrypted message as a string.\n\n\n    [EXAMPLES]\n    \n    assert candidate([1, 1, 1, 1, 1], 25) == 'BBBBB'\n    assert candidate([20, 8, 5, 17, 21, 9, 3, 11, 2, 18, 15, 23, 14, 6, 15, 24], 3) == 'QEBNRFZHYOLTKCLU'\n\n    [/EXAMPLES]\n    \"\"\"\n```\n", "entry_point": "decrypt_message", "solution": "from typing import List\n\ndef decrypt_message(cipher: List[int], key: int) -> str:\n    \"\"\"You are a cryptanalyst working for a secret agency. You've intercepted an encrypted message \n    represented as a list of integers. Each integer represents a letter in the alphabet (1-26). \n    However, the message has been encrypted using a simple substitution cipher with a key.\n\n    Your task is to decrypt the message by shifting each number back by the key value, \n    wrapping around if necessary (e.g., 1 with key 2 becomes 25). \n    Then convert the decrypted numbers back to letters (1=A, 2=B, ..., 26=Z).\n\n    Take a list of integers 'cipher' and an integer 'key' as input, and return the decrypted message as a string.\n\n\n    [EXAMPLES]\n    \n    assert candidate([1, 1, 1, 1, 1], 25) == 'BBBBB'\n    assert candidate([20, 8, 5, 17, 21, 9, 3, 11, 2, 18, 15, 23, 14, 6, 15, 24], 3) == 'QEBNRFZHYOLTKCLU'\n\n    [/EXAMPLES]\n    \"\"\"\n    def shift_and_wrap(num, key):\n        return (num - key - 1) % 26 + 1\n\n    def num_to_letter(num):\n        return chr(num + 64)\n\n    decrypted_nums = [shift_and_wrap(num, key) for num in cipher]\n    decrypted_letters = [num_to_letter(num) for num in decrypted_nums]\n    return ''.join(decrypted_letters)\n\n", "test": "def check(candidate):\n    assert candidate([26], 26) == 'Z'\n    assert candidate([26, 25, 24, 23, 22, 21, 20, 19, 18, 17, 16, 15, 14, 13, 12, 11, 10, 9, 8, 7, 6, 5, 4, 3, 2, 1], 26) == 'ZYXWVUTSRQPONMLKJIHGFEDCBA'\n    assert candidate([26, 1, 26, 1, 26], 26) == 'ZAZAZ'\n    assert candidate([20, 5, 19, 20], 15) == 'EPDE'\n    assert candidate([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26], 0) == 'ABCDEFGHIJKLMNOPQRSTUVWXYZ'\n    assert candidate([1, 1, 1, 1, 1], 25) == 'BBBBB'\n    assert candidate([22, 23, 24, 25, 26, 1, 2, 3, 4, 5], 21) == 'ABCDEFGHIJ'\n    assert candidate([20, 8, 5, 17, 21, 9, 3, 11, 2, 18, 15, 23, 14, 6, 15, 24], 3) == 'QEBNRFZHYOLTKCLU'\n    assert candidate([1], 1) == 'Z'\n    assert candidate([13, 13, 13, 13], 13) == 'ZZZZ'\n", "language": "python"}
{"task_id": "6a104abe-24c7-4d5e-b459-e9799c585ba6-977670049895500826", "prompt": "Your role is that of a coding assistant. Complete the provided function to ensure it can be run as-is in a code block. Do not write any code outside the function's scope. Utilize only those libraries that are imported in the problem. If you need auxiliary functions or classes, define them inside the main function.\n\n```python\nimport math\nfrom typing import List, Tuple\n\ndef optimize_network_latency(nodes: int, connections: List[Tuple[int, int, int]]) -> float:\n    \"\"\"\n    In a computer network, we need to optimize the latency between all pairs of nodes.\n    Given a list of direct connections between nodes and their corresponding latencies,\n    calculate the average minimum latency between all pairs of nodes in the network.\n\n    Parameters:\n    nodes (int): The number of nodes in the network.\n    connections (List[Tuple[int, int, int]]): A list of tuples representing direct connections.\n                                              Each tuple contains (node1, node2, latency).\n\n    Returns:\n    float: The average minimum latency between all pairs of nodes.\n\n    This function implements the Floyd-Warshall algorithm for all-pairs shortest paths.\n\n\n    [EXAMPLES]\n    \n    assert candidate(2, [(0, 1, 1)]) == 1.0\n    assert candidate(4, [(0, 1, 1), (1, 2, 1), (2, 3, 1), (3, 0, 1)]) == 1.3333333333333333\n\n    [/EXAMPLES]\n    \"\"\"\n```\n", "entry_point": "optimize_network_latency", "solution": "import math\nfrom typing import List, Tuple\n\ndef optimize_network_latency(nodes: int, connections: List[Tuple[int, int, int]]) -> float:\n    \"\"\"\n    In a computer network, we need to optimize the latency between all pairs of nodes.\n    Given a list of direct connections between nodes and their corresponding latencies,\n    calculate the average minimum latency between all pairs of nodes in the network.\n\n    Parameters:\n    nodes (int): The number of nodes in the network.\n    connections (List[Tuple[int, int, int]]): A list of tuples representing direct connections.\n                                              Each tuple contains (node1, node2, latency).\n\n    Returns:\n    float: The average minimum latency between all pairs of nodes.\n\n    This function implements the Floyd-Warshall algorithm for all-pairs shortest paths.\n\n\n    [EXAMPLES]\n    \n    assert candidate(2, [(0, 1, 1)]) == 1.0\n    assert candidate(4, [(0, 1, 1), (1, 2, 1), (2, 3, 1), (3, 0, 1)]) == 1.3333333333333333\n\n    [/EXAMPLES]\n    \"\"\"\n    # Initialize the distance matrix with infinity\n    dist = [[float('inf')] * nodes for _ in range(nodes)]\n    \n    # Set diagonal elements to 0\n    for i in range(nodes):\n        dist[i][i] = 0\n    \n    # Set direct connections\n    for node1, node2, latency in connections:\n        dist[node1][node2] = latency\n        dist[node2][node1] = latency  # Assuming bidirectional connections\n    \n    # Floyd-Warshall algorithm\n    for k in range(nodes):\n        for i in range(nodes):\n            for j in range(nodes):\n                dist[i][j] = min(dist[i][j], dist[i][k] + dist[k][j])\n    \n    # Calculate the sum of all minimum latencies\n    total_latency = sum(sum(row) for row in dist)\n    \n    # Calculate the number of pairs (excluding self-connections)\n    num_pairs = nodes * (nodes - 1)\n    \n    # Calculate and return the average minimum latency\n    return total_latency / num_pairs if num_pairs > 0 else 0.0\n\n", "test": "def check(candidate):\n    assert candidate(2, [(0, 1, 1000000)]) == 1000000.0\n    assert candidate(5, [(0, 1, 1), (0, 2, 2), (0, 3, 3), (0, 4, 4)]) == 4.0\n    assert candidate(4, [(0, 1, 1), (1, 2, 1), (2, 3, 1), (3, 0, 1)]) == 1.3333333333333333\n    assert candidate(7, [(0, 1, 1), (1, 2, 2), (2, 3, 3), (3, 4, 4), (4, 5, 5), (5, 6, 6)]) == 9.333333333333334\n    assert candidate(4, [(0, 1, 1), (0, 2, 2), (0, 3, 3), (1, 2, 4), (1, 3, 5), (2, 3, 6)]) == 3.0\n    assert candidate(3, [(0, 1, 1), (1, 2, 1)]) == 1.3333333333333333\n    assert candidate(4, [(0, 1, 1), (1, 2, 1), (2, 3, 1)]) == 1.6666666666666667\n    assert candidate(5, [(0, 1, 10), (1, 2, 20), (2, 3, 30), (3, 4, 40), (4, 0, 50)]) == 42.0\n    assert candidate(3, [(0, 1, 1), (1, 2, 1), (2, 0, 1)]) == 1.0\n    assert candidate(2, [(0, 1, 1)]) == 1.0\n", "language": "python"}
{"task_id": "3b198b8e-f4df-42d1-a34f-33b5feff278d6623661976480590390", "prompt": "Your goal is to implement a complete function that can be executed directly in a single code block. Do not include any code outside the function boundary. Stick to using only the libraries that are imported in the problem statement. Any additional functions or classes should be defined within the main function. Provide just one code block as your output.\n\n```python\nfrom typing import List, Tuple\n\ndef decode_ancient_script(symbols: List[str], translations: List[Tuple[str, str]]) -> str:\n    \"\"\"\n    An archaeologist has discovered an ancient script and wants to decode its message.\n    This function takes a list of symbols representing the encoded message and a list of\n    known symbol-to-letter translations, then returns the decoded message.\n\n    The function should use both dictionary comprehension and lambda functions to solve this problem.\n\n\n    [EXAMPLES]\n    \n    assert candidate(['a', 'b', 'c', 'd', 'e', 'f'], [('a', '1'), ('b', '2'), ('c', '3'), ('d', '4'), ('e', '5'), ('f', '6')]) == '123456'\n    assert candidate(['1', '2', '3'], [('1', 'X'), ('2', 'Y'), ('3', 'Z')]) == 'XYZ'\n\n    [/EXAMPLES]\n    \"\"\"\n```\n", "entry_point": "decode_ancient_script", "solution": "from typing import List, Tuple\n\ndef decode_ancient_script(symbols: List[str], translations: List[Tuple[str, str]]) -> str:\n    \"\"\"\n    An archaeologist has discovered an ancient script and wants to decode its message.\n    This function takes a list of symbols representing the encoded message and a list of\n    known symbol-to-letter translations, then returns the decoded message.\n\n    The function should use both dictionary comprehension and lambda functions to solve this problem.\n\n\n    [EXAMPLES]\n    \n    assert candidate(['a', 'b', 'c', 'd', 'e', 'f'], [('a', '1'), ('b', '2'), ('c', '3'), ('d', '4'), ('e', '5'), ('f', '6')]) == '123456'\n    assert candidate(['1', '2', '3'], [('1', 'X'), ('2', 'Y'), ('3', 'Z')]) == 'XYZ'\n\n    [/EXAMPLES]\n    \"\"\"\n    # Create a dictionary from the translations using dictionary comprehension\n    translation_dict = {symbol: letter for symbol, letter in translations}\n    \n    # Use a lambda function with map to decode each symbol\n    decoded_message = ''.join(map(lambda x: translation_dict.get(x, x), symbols))\n    \n    return decoded_message\n\n", "test": "def check(candidate):\n    assert candidate(['1', '2', '3'], [('1', 'X'), ('2', 'Y'), ('3', 'Z')]) == 'XYZ'\n    assert candidate(['A', 'B', 'C', 'A', 'B', 'C'], [('A', 'X'), ('B', 'Y'), ('C', 'Z')]) == 'XYZXYZ'\n    assert candidate(['!', '@', '#', '$', '%', '^', '&', '*', '(', ')'], [('!', 'A'), ('@', 'B'), ('#', 'C'), ('$', 'D'), ('%', 'E'), ('^', 'F'), ('&', 'G'), ('*', 'H'), ('(', 'I'), (')', 'J')]) == 'ABCDEFGHIJ'\n    assert candidate(['a', 'b', 'c', 'd', 'e', 'f'], [('a', '1'), ('b', '2'), ('c', '3'), ('d', '4'), ('e', '5'), ('f', '6')]) == '123456'\n    assert candidate(['@'], [('@', 'A')]) == 'A'\n    assert candidate(['a', 'b', 'c'], [('a', 'X'), ('b', 'Y'), ('c', 'Z')]) == 'XYZ'\n    assert candidate(['1', '2', '3', '4', '5'], [('1', 'A'), ('2', 'B'), ('3', 'C'), ('4', 'D'), ('5', 'E')]) == 'ABCDE'\n    assert candidate(['A', 'B', 'C', 'D'], [('A', 'Z'), ('B', 'Y'), ('C', 'X'), ('D', 'W')]) == 'ZYXW'\n    assert candidate(['*', '&', '^', '%', '$', '#', '@', '!'], [('*', 'S'), ('&', 'E'), ('^', 'C'), ('%', 'R'), ('$', 'E'), ('#', 'T'), ('@', 'S'), ('!', '!')]) == 'SECRETS!'\n    assert candidate([], []) == ''\n", "language": "python"}
{"task_id": "b31258b2-7fa5-4183-be99-2391452bdf1f3789023662635289391", "prompt": "I'll generate a complete, executable function as a single code block. I'll ensure it only uses the imported libraries from the problem statement and will include any helper functions within the main function.\n\n```python\nfrom typing import List\n\ndef analyze_movie_ratings(ratings: List[float], genre: str) -> tuple:\n    \"\"\"\n    In a film studies class, students are tasked with analyzing movie ratings for different genres.\n    This function takes a list of movie ratings and a genre, then calculates various statistics.\n\n    The function should utilize list comprehension and lambda functions to perform the analysis.\n\n    Parameters:\n    ratings (List[float]): A list of movie ratings (0.0 to 10.0)\n    genre (str): The genre of the movies being analyzed\n\n    Returns:\n    tuple: A tuple containing (average_rating, highest_rating, lowest_rating, rating_range)\n\n\n    [EXAMPLES]\n    \n    assert candidate([0.0, 0.0, 0.0, 0.0, 0.0], \"Musical\") == (0.0, 0.0, 0.0, 0.0)\n    assert candidate([9.9, 9.8, 9.7, 9.6, 9.5, 9.4], \"History\") == (9.65, 9.9, 9.4, 0.5)\n\n    [/EXAMPLES]\n    \"\"\"\n```\n", "entry_point": "analyze_movie_ratings", "solution": "from typing import List\n\ndef analyze_movie_ratings(ratings: List[float], genre: str) -> tuple:\n    \"\"\"\n    In a film studies class, students are tasked with analyzing movie ratings for different genres.\n    This function takes a list of movie ratings and a genre, then calculates various statistics.\n\n    The function should utilize list comprehension and lambda functions to perform the analysis.\n\n    Parameters:\n    ratings (List[float]): A list of movie ratings (0.0 to 10.0)\n    genre (str): The genre of the movies being analyzed\n\n    Returns:\n    tuple: A tuple containing (average_rating, highest_rating, lowest_rating, rating_range)\n\n\n    [EXAMPLES]\n    \n    assert candidate([0.0, 0.0, 0.0, 0.0, 0.0], \"Musical\") == (0.0, 0.0, 0.0, 0.0)\n    assert candidate([9.9, 9.8, 9.7, 9.6, 9.5, 9.4], \"History\") == (9.65, 9.9, 9.4, 0.5)\n\n    [/EXAMPLES]\n    \"\"\"\n    # Using list comprehension to ensure all ratings are floats\n    ratings = [float(rating) for rating in ratings]\n    \n    # Using lambda functions for calculations\n    average_rating = round(sum(ratings) / len(ratings), 2)\n    highest_rating = max(ratings)\n    lowest_rating = min(ratings)\n    rating_range = round(highest_rating - lowest_rating, 1)\n    \n    return (average_rating, highest_rating, lowest_rating, rating_range)\n\n", "test": "def check(candidate):\n    assert candidate([3.3, 6.6, 9.9], \"Adventure\") == (6.6, 9.9, 3.3, 6.6)\n    assert candidate([9.9, 9.8, 9.7, 9.6, 9.5, 9.4], \"History\") == (9.65, 9.9, 9.4, 0.5)\n    assert candidate([0.1, 0.3, 0.2, 0.4, 0.5], \"Romance\") == (0.3, 0.5, 0.1, 0.4)\n    assert candidate([7.0, 7.0, 7.0, 7.0, 7.0], \"Sci-Fi\") == (7.0, 7.0, 7.0, 0.0)\n    assert candidate([0.0, 0.0, 0.0, 0.0, 0.0], \"Musical\") == (0.0, 0.0, 0.0, 0.0)\n    assert candidate([1.0, 10.0], \"Thriller\") == (5.5, 10.0, 1.0, 9.0)\n    assert candidate([9.2, 8.1, 7.0, 5.9, 4.8, 3.7, 2.6, 1.5, 0.4], \"Sport\") == (4.8, 9.2, 0.4, 8.8)\n    assert candidate([5.5, 5.6, 5.7, 5.8, 5.9], \"Biography\") == (5.7, 5.9, 5.5, 0.4)\n    assert candidate([4.7], \"Musical\") == (4.7, 4.7, 4.7, 0.0)\n    assert candidate([1.1, 2.2, 3.3, 4.4, 5.5, 6.6, 7.7, 8.8, 9.9], \"Crime\") == (5.5, 9.9, 1.1, 8.8)\n", "language": "python"}
{"task_id": "a352ba5a-80fb-4027-9baf-47e7c5b2d62d4375039523641014242", "prompt": "My goal is to finish the provided function so it works as expected. I'll only use the libraries that are already imported and will create any supporting functions or classes within the main function. The code will be contained in a single, executable code block.\n\n```python\nfrom typing import List, Tuple\n\ndef cheese_production(milk_supply: List[int], cheese_demand: List[int]) -> Tuple[int, int]:\n    \"\"\"\n    A small dairy farm wants to optimize its cheese production. Each day, they receive a certain amount of milk\n    and have a specific demand for cheese. It takes 10 liters of milk to produce 1 kg of cheese. Excess milk can be\n    stored for the next day, but cheese must be produced and sold on the same day.\n\n    This function takes two lists: the daily milk supply (in liters) and the daily cheese demand (in kg) for a week.\n    It returns a tuple containing the total amount of cheese produced and the amount of milk left over at the end of the week.\n\n\n    [EXAMPLES]\n    \n    assert candidate([5, 15, 25, 35, 45, 55, 65], [0, 1, 2, 3, 4, 5, 6]) == (21, 35)\n    assert candidate([10, 20, 30, 40, 50, 60, 70], [1, 2, 3, 4, 5, 6, 7]) == (28, 0)\n\n    [/EXAMPLES]\n    \"\"\"\n```\n", "entry_point": "cheese_production", "solution": "from typing import List, Tuple\n\ndef cheese_production(milk_supply: List[int], cheese_demand: List[int]) -> Tuple[int, int]:\n    \"\"\"\n    A small dairy farm wants to optimize its cheese production. Each day, they receive a certain amount of milk\n    and have a specific demand for cheese. It takes 10 liters of milk to produce 1 kg of cheese. Excess milk can be\n    stored for the next day, but cheese must be produced and sold on the same day.\n\n    This function takes two lists: the daily milk supply (in liters) and the daily cheese demand (in kg) for a week.\n    It returns a tuple containing the total amount of cheese produced and the amount of milk left over at the end of the week.\n\n\n    [EXAMPLES]\n    \n    assert candidate([5, 15, 25, 35, 45, 55, 65], [0, 1, 2, 3, 4, 5, 6]) == (21, 35)\n    assert candidate([10, 20, 30, 40, 50, 60, 70], [1, 2, 3, 4, 5, 6, 7]) == (28, 0)\n\n    [/EXAMPLES]\n    \"\"\"\n    total_cheese_produced = 0\n    stored_milk = 0\n\n    for milk, demand in zip(milk_supply, cheese_demand):\n        available_milk = stored_milk + milk\n        cheese_to_produce = min(demand, available_milk // 10)\n        \n        total_cheese_produced += cheese_to_produce\n        milk_used = cheese_to_produce * 10\n        stored_milk = available_milk - milk_used\n\n    return (total_cheese_produced, stored_milk)\n\n", "test": "def check(candidate):\n    assert candidate([99, 99, 99, 99, 99, 99, 99], [9, 9, 9, 9, 9, 9, 9]) == (63, 63)\n    assert candidate([50, 60, 70, 80, 90, 100, 110], [5, 6, 7, 8, 9, 10, 11]) == (56, 0)\n    assert candidate([10, 20, 30, 40, 50, 60, 70], [1, 2, 3, 4, 5, 6, 7]) == (28, 0)\n    assert candidate([1, 10, 100, 1000, 10000, 100000, 1000000], [0, 1, 10, 100, 1000, 10000, 100000]) == (111111, 1)\n    assert candidate([100, 0, 100, 0, 100, 0, 100], [10, 0, 10, 0, 10, 0, 10]) == (40, 0)\n    assert candidate([10000, 10000, 10000, 10000, 10000, 10000, 10000], [1000, 1000, 1000, 1000, 1000, 1000, 1000]) == (7000, 0)\n    assert candidate([5, 15, 25, 35, 45, 55, 65], [0, 1, 2, 3, 4, 5, 6]) == (21, 35)\n    assert candidate([100, 120, 90, 110, 95, 105, 100], [8, 10, 7, 12, 9, 8, 11]) == (65, 70)\n    assert candidate([1, 2, 3, 4, 5, 6, 7], [0, 0, 0, 0, 0, 0, 0]) == (0, 28)\n    assert candidate([200, 150, 100, 50, 0, 0, 0], [20, 15, 10, 5, 0, 0, 0]) == (50, 0)\n", "language": "python"}
{"task_id": "884ce179-c7e0-4e1d-8b18-6867653cc351-4455563354083133970", "prompt": "You are a coding assistant. I'll complete functions as requested, ensuring they can be executed as-is in code blocks. I'll only use libraries imported in the problem and will define any additional functions or classes inside the main function.\n\n```python\ndef calculate_stock_profit(prices: list[int]) -> int:\n    \"\"\"In a stock market simulation game, players are given a list of stock prices \n    for consecutive days. This function calculates the maximum profit that can be \n    made by buying and selling a stock once, given that you must buy before you sell.\n\n    Args:\n    prices (list[int]): A list of stock prices, where prices[i] is the price on the i-th day.\n\n    Returns:\n    int: The maximum profit that can be achieved. If no profit can be made, return 0.\n\n\n    [EXAMPLES]\n    \n    assert candidate([1,100,1]) == 99\n    assert candidate([100,1,100]) == 99\n\n    [/EXAMPLES]\n    \"\"\"\n```\n", "entry_point": "calculate_stock_profit", "solution": "def calculate_stock_profit(prices: list[int]) -> int:\n    \"\"\"In a stock market simulation game, players are given a list of stock prices \n    for consecutive days. This function calculates the maximum profit that can be \n    made by buying and selling a stock once, given that you must buy before you sell.\n\n    Args:\n    prices (list[int]): A list of stock prices, where prices[i] is the price on the i-th day.\n\n    Returns:\n    int: The maximum profit that can be achieved. If no profit can be made, return 0.\n\n\n    [EXAMPLES]\n    \n    assert candidate([1,100,1]) == 99\n    assert candidate([100,1,100]) == 99\n\n    [/EXAMPLES]\n    \"\"\"\n    if not prices or len(prices) < 2:\n        return 0\n\n    min_price = float('inf')\n    max_profit = 0\n\n    for price in prices:\n        if price < min_price:\n            min_price = price\n        else:\n            current_profit = price - min_price\n            if current_profit > max_profit:\n                max_profit = current_profit\n\n    return max_profit\n\n", "test": "def check(candidate):\n    assert candidate([10,9,8,7,6,5,4,3,2,1,10]) == 9\n    assert candidate([1,100,1]) == 99\n    assert candidate([100,1,100]) == 99\n    assert candidate([2,1,2,1,0,1,2]) == 2\n    assert candidate([1]) == 0\n    assert candidate([1,2,3,4,5,4,3,2,1]) == 4\n    assert candidate([2,1]) == 0\n    assert candidate([1,2,3,4,5]) == 4\n    assert candidate([]) == 0\n", "language": "python"}
{"task_id": "3fb191f6-cfce-43e6-88d1-0067fe501dd7-5528944080812744384", "prompt": "Given the function signature and doc string, please complete the function implementation in a single code block.\n\n```python\nfrom typing import List\n\ndef optimal_study_plan(subjects: List[int], study_days: int) -> int:\n    \"\"\"\n    Determine the minimum difficulty of the optimal study plan for a student preparing for exams.\n\n    The student has 'study_days' to prepare, and must study one subject each day. The 'subjects' list\n    represents the difficulty of each subject. The student can choose to study subjects in any order,\n    but the difficulty of each day is determined by the hardest subject studied so far.\n    The goal is to minimize the maximum daily difficulty over the study period.\n\n\n    [EXAMPLES]\n    \n    assert candidate([1, 3, 2, 5, 4, 7, 6], 5) == 7\n    assert candidate([1, 2, 3, 4, 5], 5) == 5\n\n    [/EXAMPLES]\n    \"\"\"\n```\n", "entry_point": "optimal_study_plan", "solution": "from typing import List\n\ndef optimal_study_plan(subjects: List[int], study_days: int) -> int:\n    \"\"\"\n    Determine the minimum difficulty of the optimal study plan for a student preparing for exams.\n\n    The student has 'study_days' to prepare, and must study one subject each day. The 'subjects' list\n    represents the difficulty of each subject. The student can choose to study subjects in any order,\n    but the difficulty of each day is determined by the hardest subject studied so far.\n    The goal is to minimize the maximum daily difficulty over the study period.\n\n\n    [EXAMPLES]\n    \n    assert candidate([1, 3, 2, 5, 4, 7, 6], 5) == 7\n    assert candidate([1, 2, 3, 4, 5], 5) == 5\n\n    [/EXAMPLES]\n    \"\"\"\n    def can_study_with_difficulty(max_difficulty: int) -> bool:\n        days_needed = 1\n        current_max = 0\n        for subject in subjects:\n            if subject > max_difficulty:\n                return False\n            if current_max + subject > max_difficulty:\n                days_needed += 1\n                current_max = subject\n            else:\n                current_max = max(current_max, subject)\n            if days_needed > study_days:\n                return False\n        return True\n\n    left, right = max(subjects), sum(subjects)\n    result = right\n\n    while left <= right:\n        mid = (left + right) // 2\n        if can_study_with_difficulty(mid):\n            result = mid\n            right = mid - 1\n        else:\n            left = mid + 1\n\n    return result\n\n", "test": "def check(candidate):\n    assert candidate([1, 1, 1, 1, 1], 5) == 1\n    assert candidate([7, 6, 5, 4, 3, 2, 1], 4) == 7\n    assert candidate([9, 8, 7, 6, 5, 4, 3, 2, 1], 6) == 9\n    assert candidate([1, 2, 3, 4, 5], 5) == 5\n    assert candidate([5, 4, 3, 2, 1], 3) == 5\n    assert candidate([100, 200, 300, 400, 500], 2) == 700\n    assert candidate([1, 3, 2, 5, 4, 7, 6], 5) == 7\n    assert candidate([10, 20, 30, 40, 50], 3) == 50\n    assert candidate([1, 10, 1, 10, 1], 3) == 11\n    assert candidate([5, 4, 3, 2, 1, 1, 2, 3, 4, 5], 8) == 5\n", "language": "python"}
{"task_id": "813e4c91-65c6-4dc3-a585-8ffc6a3e06d1-5370454347365305605", "prompt": "Your function will be completed in one executable code block. I won't add any code outside the function boundaries. The solution will only use libraries already imported in the problem, and any supporting functions or classes will be defined within the main function itself.\n\n```python\nfrom typing import List\n\ndef calculate_water_retention(heights: List[int]) -> int:\n    \"\"\"\n    In a landscape architecture project, you need to calculate the amount of water that can be retained\n    between buildings of varying heights. Each building is represented by its height in the input list.\n\n    The function should return the total units of water that can be trapped between the buildings after\n    a rainstorm.\n\n\n    [EXAMPLES]\n    \n    assert candidate([1]) == 0\n    assert candidate([10, 0, 10]) == 10\n\n    [/EXAMPLES]\n    \"\"\"\n```\n", "entry_point": "calculate_water_retention", "solution": "from typing import List\n\ndef calculate_water_retention(heights: List[int]) -> int:\n    \"\"\"\n    In a landscape architecture project, you need to calculate the amount of water that can be retained\n    between buildings of varying heights. Each building is represented by its height in the input list.\n\n    The function should return the total units of water that can be trapped between the buildings after\n    a rainstorm.\n\n\n    [EXAMPLES]\n    \n    assert candidate([1]) == 0\n    assert candidate([10, 0, 10]) == 10\n\n    [/EXAMPLES]\n    \"\"\"\n    if not heights:\n        return 0\n\n    n = len(heights)\n    left_max = [0] * n\n    right_max = [0] * n\n    water = 0\n\n    # Calculate maximum height to the left of each building\n    left_max[0] = heights[0]\n    for i in range(1, n):\n        left_max[i] = max(left_max[i-1], heights[i])\n\n    # Calculate maximum height to the right of each building\n    right_max[n-1] = heights[n-1]\n    for i in range(n-2, -1, -1):\n        right_max[i] = max(right_max[i+1], heights[i])\n\n    # Calculate water trapped at each position\n    for i in range(n):\n        water += max(0, min(left_max[i], right_max[i]) - heights[i])\n\n    return water\n\n", "test": "def check(candidate):\n    assert candidate([5, 4, 3, 2, 1, 2, 3, 4, 5]) == 16\n    assert candidate([1]) == 0\n    assert candidate([100, 0, 100, 0, 100]) == 200\n    assert candidate([4, 2, 0, 3, 2, 5]) == 9\n    assert candidate([10, 0, 10]) == 10\n    assert candidate([1, 1, 1, 1, 2, 1, 1, 1, 1]) == 0\n    assert candidate([3, 0, 3]) == 3\n    assert candidate([3, 0, 0, 3]) == 6\n    assert candidate([2, 1, 2]) == 1\n    assert candidate([5, 0, 5]) == 5\n", "language": "python"}
{"task_id": "3665f545-a1db-4940-b636-aef96445db1c873206117201876961", "prompt": "Based on the doc string, finish coding the function. Present the complete solution in a single code block, with careful consideration of edge cases.\n\n```python\nfrom typing import List\n\ndef calculate_ecosystem_stability(species_counts: List[int]) -> float:\n    \"\"\"\n    In a fragile ecosystem, scientists are trying to measure its stability based on the population\n    counts of different species. Each integer in the input list represents the count of a specific\n    species. The ecosystem's stability is calculated as the ratio of the average population to the\n    difference between the maximum and minimum populations.\n\n    A higher stability score indicates a more balanced ecosystem. If all species have the same\n    population, the ecosystem is considered perfectly stable and should return float('inf').\n\n    Parameters:\n    species_counts (List[int]): A list of integers representing the population count of each species.\n\n    Returns:\n    float: The calculated stability score of the ecosystem.\n\n\n    [EXAMPLES]\n    \n    assert candidate([1, 10, 100, 1000, 10000]) == 0.22224222422242224\n    assert candidate([10, 20, 30, 40]) == 0.8333333333333334\n\n    [/EXAMPLES]\n    \"\"\"\n```\n", "entry_point": "calculate_ecosystem_stability", "solution": "from typing import List\n\ndef calculate_ecosystem_stability(species_counts: List[int]) -> float:\n    \"\"\"\n    In a fragile ecosystem, scientists are trying to measure its stability based on the population\n    counts of different species. Each integer in the input list represents the count of a specific\n    species. The ecosystem's stability is calculated as the ratio of the average population to the\n    difference between the maximum and minimum populations.\n\n    A higher stability score indicates a more balanced ecosystem. If all species have the same\n    population, the ecosystem is considered perfectly stable and should return float('inf').\n\n    Parameters:\n    species_counts (List[int]): A list of integers representing the population count of each species.\n\n    Returns:\n    float: The calculated stability score of the ecosystem.\n\n\n    [EXAMPLES]\n    \n    assert candidate([1, 10, 100, 1000, 10000]) == 0.22224222422242224\n    assert candidate([10, 20, 30, 40]) == 0.8333333333333334\n\n    [/EXAMPLES]\n    \"\"\"\n    if not species_counts:\n        return 0.0  # Return 0 for empty list\n\n    min_count = min(species_counts)\n    max_count = max(species_counts)\n    \n    if min_count == max_count:\n        return float('inf')  # Perfectly stable ecosystem\n    \n    average_population = sum(species_counts) / len(species_counts)\n    population_difference = max_count - min_count\n    \n    stability_score = average_population / population_difference\n    \n    return stability_score\n\n", "test": "def check(candidate):\n    assert candidate([999, 1000, 1001]) == 500.0\n    assert candidate([1000, 2000, 3000, 4000, 5000]) == 0.75\n    assert candidate([1, 2, 3, 4, 5, 6, 7, 8, 9, 10]) == 0.6111111111111112\n    assert candidate([1, 2, 4, 8, 16, 32, 64, 128]) == 0.25098425196850394\n    assert candidate([1000000, 1000001]) == 1000000.5\n    assert candidate([10, 10, 10, 11]) == 10.25\n    assert candidate([7, 7, 7, 7, 7, 7, 8]) == 7.142857142857143\n    assert candidate([10, 20, 30, 40]) == 0.8333333333333334\n    assert candidate([1, 10, 100, 1000, 10000]) == 0.22224222422242224\n    assert candidate([5, 5, 5, 5, 6]) == 5.2\n", "language": "python"}
{"task_id": "2759d41c-3a2e-48a8-9fa7-6bb3f7503a2a-162872868780914568", "prompt": "Here's the implementation of the requested function, contained within a single executable code block. I've only used the libraries mentioned in the problem, with any auxiliary functions or classes defined within the main function. The response consists of just one code block.\n\n```python\nimport math\n\ndef cosmic_distance(coord1: tuple, coord2: tuple) -> float:\n    \"\"\"\n    In a distant galaxy, astronomers have discovered a unique coordinate system for mapping celestial bodies. The system uses three-dimensional coordinates, but distances are calculated using a special formula that accounts for the curvature of space-time.\n\n    Your task is to write a function that calculates the cosmic distance between two points in this galactic coordinate system.\n\n    The function should use both tuple unpacking (to handle the coordinates) and the math module (to perform the distance calculation).\n\n\n    [EXAMPLES]\n    \n    assert candidate((3.14, 2.71, 1.41), (9.81, 6.02, 1.62)) == 7.456274530826315\n    assert candidate((-1, -2, -3), (1, 2, 3)) == 7.532517668348674\n\n    [/EXAMPLES]\n    \"\"\"\n```\n", "entry_point": "cosmic_distance", "solution": "import math\n\ndef cosmic_distance(coord1: tuple, coord2: tuple) -> float:\n    \"\"\"\n    In a distant galaxy, astronomers have discovered a unique coordinate system for mapping celestial bodies. The system uses three-dimensional coordinates, but distances are calculated using a special formula that accounts for the curvature of space-time.\n\n    Your task is to write a function that calculates the cosmic distance between two points in this galactic coordinate system.\n\n    The function should use both tuple unpacking (to handle the coordinates) and the math module (to perform the distance calculation).\n\n\n    [EXAMPLES]\n    \n    assert candidate((3.14, 2.71, 1.41), (9.81, 6.02, 1.62)) == 7.456274530826315\n    assert candidate((-1, -2, -3), (1, 2, 3)) == 7.532517668348674\n\n    [/EXAMPLES]\n    \"\"\"\n    # Unpack the coordinates\n    x1, y1, z1 = coord1\n    x2, y2, z2 = coord2\n\n    # Calculate the differences\n    dx = x2 - x1\n    dy = y2 - y1\n    dz = z2 - z1\n\n    # Calculate the cosmic distance using a special formula\n    # This formula accounts for the curvature of space-time\n    distance = math.sqrt(\n        (dx ** 2 + dy ** 2 + dz ** 2) +\n        (math.sin(dx) ** 2 + math.sin(dy) ** 2 + math.sin(dz) ** 2) / 2\n    )\n\n    return distance\n\n", "test": "def check(candidate):\n    assert candidate((10, 20, 30), (40, 50, 60)) == 51.97561264415564\n    assert candidate((-10, -20, -30), (-40, -50, -60)) == 51.97561264415564\n    assert candidate((3.14, 2.71, 1.41), (9.81, 6.02, 1.62)) == 7.456274530826315\n    assert candidate((1e-6, 1e-6, 1e-6), (2e-6, 2e-6, 2e-6)) == 2.1213203435595247e-06\n    assert candidate((100, 200, 300), (400, 500, 600)) == 519.61668493959\n    assert candidate((-1, -2, -3), (1, 2, 3)) == 7.532517668348674\n", "language": "python"}
{"task_id": "76bc44aa-2877-4324-80fe-055f36565203-1092018633725268746", "prompt": "I need you to complete the specified function in an executable format within one code block. Only use libraries that are imported in the problem statement. Any additional helper functions or classes should be defined inside the main function. Do not add any code outside the function definition.\n\n```python\nimport re\nfrom typing import List\n\ndef parse_dna_sequence(dna: str) -> List[str]:\n    \"\"\"\n    You are a bioinformatician working on decoding alien DNA sequences. The alien DNA uses the same\n    nucleotides as Earth DNA (A, C, G, T), but their genes are structured differently. Your task is to\n    parse the DNA sequence and extract all valid alien genes.\n\n    An alien gene is defined by the following rules:\n    1. It starts with the sequence \"ATG\".\n    2. It ends with one of the sequences \"TAA\", \"TAG\", or \"TGA\".\n    3. Its length (including start and stop codons) is a multiple of 3.\n    4. It contains only the characters A, C, G, and T.\n\n\n    [EXAMPLES]\n    \n    assert candidate(\"CCCAAATTTGGG\") == []\n    assert candidate(\"ATGAAATGAAATGAAATGAAATGAAATGAAATAA\") == ['ATGAAATGA', 'ATGAAATGA', 'ATGAAATGA']\n\n    [/EXAMPLES]\n    \"\"\"\n```\n", "entry_point": "parse_dna_sequence", "solution": "import re\nfrom typing import List\n\ndef parse_dna_sequence(dna: str) -> List[str]:\n    \"\"\"\n    You are a bioinformatician working on decoding alien DNA sequences. The alien DNA uses the same\n    nucleotides as Earth DNA (A, C, G, T), but their genes are structured differently. Your task is to\n    parse the DNA sequence and extract all valid alien genes.\n\n    An alien gene is defined by the following rules:\n    1. It starts with the sequence \"ATG\".\n    2. It ends with one of the sequences \"TAA\", \"TAG\", or \"TGA\".\n    3. Its length (including start and stop codons) is a multiple of 3.\n    4. It contains only the characters A, C, G, and T.\n\n\n    [EXAMPLES]\n    \n    assert candidate(\"CCCAAATTTGGG\") == []\n    assert candidate(\"ATGAAATGAAATGAAATGAAATGAAATGAAATAA\") == ['ATGAAATGA', 'ATGAAATGA', 'ATGAAATGA']\n\n    [/EXAMPLES]\n    \"\"\"\n    def is_valid_gene(gene: str) -> bool:\n        \"\"\"Check if a gene is valid according to the alien gene rules.\"\"\"\n        return (\n            len(gene) % 3 == 0 and\n            gene.startswith(\"ATG\") and\n            gene.endswith((\"TAA\", \"TAG\", \"TGA\")) and\n            set(gene).issubset({\"A\", \"C\", \"G\", \"T\"})\n        )\n\n    # Find all potential genes\n    potential_genes = re.findall(r'ATG(?:...)*?(?:TAA|TAG|TGA)', dna)\n\n    # Filter out invalid genes\n    valid_genes = [gene for gene in potential_genes if is_valid_gene(gene)]\n\n    return valid_genes\n\n", "test": "def check(candidate):\n    assert candidate(\"ATGCCCTAG\") == ['ATGCCCTAG']\n    assert candidate(\"ATGAAATAGATGTAATGAAATAGATGTAATGAAATAGATGTAA\") == ['ATGAAATAG', 'ATGTAA', 'ATGTAA', 'ATGTAA']\n    assert candidate(\"ATGAAATGCCCTAGAAAATGAAATAGATGTAA\") == ['ATGAAATGCCCTAGAAAATGA', 'ATGTAA']\n    assert candidate(\"ATGTGAATGTAGATGTAA\") == ['ATGTGA', 'ATGTAG', 'ATGTAA']\n    assert candidate(\"ATGCGATACTAATGCATCATGTTAAGCTATGCAT\") == ['ATGCGATACTAA']\n    assert candidate(\"ATGC\" * 1000 + \"TAA\") == ['ATGCATGCATGCATGCATGCATGCATGCATGCATGCATGCATGCATGCATGCATGCATGCATGCATGCATGCATGCATGCATGCATGCATGCATGCATGCATGCATGCATGCATGCATGCATGCATGCATGCATGCATGCATGCATGCATGCATGCATGCATGCATGCATGCATGCATGCATGCATGCATGCATGCATGCATGCATGCATGCATGCATGCATGCATGCATGCATGCATGCATGCATGCATGCATGCATGCATGCATGCATGCATGCATGCATGCATGCATGCATGCATGCATGCATGCATGCATGCATGCATGCATGCATGCATGCATGCATGCATGCATGCATGCATGCATGCATGCATGCATGCATGCATGCATGCATGCATGCATGCATGCATGCATGCATGCATGCATGCATGCATGCATGCATGCATGCATGCATGCATGCATGCATGCATGCATGCATGCATGCATGCATGCATGCATGCATGCATGCATGCATGCATGCATGCATGCATGCATGCATGCATGCATGCATGCATGCATGCATGCATGCATGCATGCATGCATGCATGCATGCATGCATGCATGCATGCATGCATGCATGCATGCATGCATGCATGCATGCATGCATGCATGCATGCATGCATGCATGCATGCATGCATGCATGCATGCATGCATGCATGCATGCATGCATGCATGCATGCATGCATGCATGCATGCATGCATGCATGCATGCATGCATGCATGCATGCATGCATGCATGCATGCATGCATGCATGCATGCATGCATGCATGCATGCATGCATGCATGCATGCATGCATGCATGCATGCATGCATGCATGCATGCATGCATGCATGCATGCATGCATGCATGCATGCATGCATGCATGCATGCATGCATGCATGCATGCATGCATGCATGCATGCATGCATGCATGCATGCATGCATGCATGCATGCATGCATGCATGCATGCATGCATGCATGCATGCATGCATGCATGCATGCATGCATGCATGCATGCATGCATGCATGCATGCATGCATGCATGCATGCATGCATGCATGCATGCATGCATGCATGCATGCATGCATGCATGCATGCATGCATGCATGCATGCATGCATGCATGCATGCATGCATGCATGCATGCATGCATGCATGCATGCATGCATGCATGCATGCATGCATGCATGCATGCATGCATGCATGCATGCATGCATGCATGCATGCATGCATGCATGCATGCATGCATGCATGCATGCATGCATGCATGCATGCATGCATGCATGCATGCATGCATGCATGCATGCATGCATGCATGCATGCATGCATGCATGCATGCATGCATGCATGCATGCATGCATGCATGCATGCATGCATGCATGCATGCATGCATGCATGCATGCATGCATGCATGCATGCATGCATGCATGCATGCATGCATGCATGCATGCATGCATGCATGCATGCATGCATGCATGCATGCATGCATGCATGCATGCATGCATGCATGCATGCATGCATGCATGCATGCATGCATGCATGCATGCATGCATGCATGCATGCATGCATGCATGCATGCATGCATGCATGCATGCATGCATGCATGCATGCATGCATGCATGCATGCATGCATGCATGCATGCATGCATGCATGCATGCATGCATGCATGCATGCATGCATGCATGCATGCATGCATGCATGCATGCATGCATGCATGCATGCATGCATGCATGCATGCATGCATGCATGCATGCATGCATGCATGCATGCATGCATGCATGCATGCATGCATGCATGCATGCATGCATGCATGCATGCATGCATGCATGCATGCATGCATGCATGCATGCATGCATGCATGCATGCATGCATGCATGCATGCATGCATGCATGCATGCATGCATGCATGCATGCATGCATGCATGCATGCATGCATGCATGCATGCATGCATGCATGCATGCATGCATGCATGCATGCATGCATGCATGCATGCATGCATGCATGCATGCATGCATGCATGCATGCATGCATGCATGCATGCATGCATGCATGCATGCATGCATGCATGCATGCATGCATGCATGCATGCATGCATGCATGCATGCATGCATGCATGCATGCATGCATGCATGCATGCATGCATGCATGCATGCATGCATGCATGCATGCATGCATGCATGCATGCATGCATGCATGCATGCATGCATGCATGCATGCATGCATGCATGCATGCATGCATGCATGCATGCATGCATGCATGCATGCATGCATGCATGCATGCATGCATGCATGCATGCATGCATGCATGCATGCATGCATGCATGCATGCATGCATGCATGCATGCATGCATGCATGCATGCATGCATGCATGCATGCATGCATGCATGCATGCATGCATGCATGCATGCATGCATGCATGCATGCATGCATGCATGCATGCATGCATGCATGCATGCATGCATGCATGCATGCATGCATGCATGCATGCATGCATGCATGCATGCATGCATGCATGCATGCATGCATGCATGCATGCATGCATGCATGCATGCATGCATGCATGCATGCATGCATGCATGCATGCATGCATGCATGCATGCATGCATGCATGCATGCATGCATGCATGCATGCATGCATGCATGCATGCATGCATGCATGCATGCATGCATGCATGCATGCATGCATGCATGCATGCATGCATGCATGCATGCATGCATGCATGCATGCATGCATGCATGCATGCATGCATGCATGCATGCATGCATGCATGCATGCATGCATGCATGCATGCATGCATGCATGCATGCATGCATGCATGCATGCATGCATGCATGCATGCATGCATGCATGCATGCATGCATGCATGCATGCATGCATGCATGCATGCATGCATGCATGCATGCATGCATGCATGCATGCATGCATGCATGCATGCATGCATGCATGCATGCATGCATGCATGCATGCATGCATGCATGCATGCATGCATGCATGCATGCATGCATGCATGCATGCATGCATGCATGCATGCATGCATGCATGCATGCATGCATGCATGCATGCATGCATGCATGCATGCATGCATGCATGCATGCATGCATGCATGCATGCATGCATGCATGCATGCATGCATGCATGCATGCATGCATGCATGCATGCATGCATGCATGCATGCATGCATGCATGCATGCATGCATGCATGCATGCATGCATGCATGCATGCATGCATGCATGCATGCATGCATGCATGCATGCATGCATGCATGCATGCATGCATGCATGCATGCATGCATGCATGCATGCATGCATGCATGCATGCATGCATGCATGCATGCATGCATGCATGCATGCATGCATGCATGCATGCATGCATGCATGCATGCATGCATGCATGCATGCATGCATGCATGCATGCATGCATGCATGCATGCATGCATGCATGCATGCATGCATGCATGCATGCATGCATGCATGCATGCATGCATGCATGCATGCATGCATGCATGCATGCATGCATGCATGCATGCATGCATGCATGCATGCATGCATGCATGCATGCATGCATGCATGCATGCATGCATGCATGCATGCATGCATGCATGCATGCATGCATGCATGCATGCATGCATGCATGCATGCATGCATGCATGCATGCATGCATGCATGCATGCATGCATGCATGCATGCATGCATGCATGCATGCATGCATGCATGCATGCATGCATGCATGCATGCATGCATGCATGCATGCATGCATGCATGCATGCATGCATGCATGCATGCATGCATGCATGCATGCATGCATGCATGCATGCATGCATGCATGCATGCATGCATGCATGCATGCATGCATGCATGCATGCATGCATGCATGCATGCATGCATGCATGCATGCATGCATGCATGCATGCATGCATGCATGCATGCATGCATGCATGCATGCATGCATGCATGCATGCATGCATGCATGCATGCTAA']\n    assert candidate(\"CCTATGAAATAACCATGCCCTAGATGAAATAA\") == ['ATGAAATAA', 'ATGCCCTAG', 'ATGAAATAA']\n    assert candidate(\"ATGAAATGAAATGAAATGAAATGAAATGAAATAA\") == ['ATGAAATGA', 'ATGAAATGA', 'ATGAAATGA']\n    assert candidate(\"ATGCCCTAGATGAAATAA\") == ['ATGCCCTAG', 'ATGAAATAA']\n    assert candidate(\"CCCAAATTTGGG\") == []\n", "language": "python"}
{"task_id": "b8f1762e-4641-4e9a-8888-70e8b18e6e951523723942057206355", "prompt": "I need you to implement the provided function completely so it's ready for execution. Don't add any code outside the function definition. Only use libraries that are imported in the original problem statement. If you need helper functions or classes, define them within the main function.\n\n```python\nimport re\n\ndef validate_isbn13(isbn: str) -> bool:\n    \"\"\"\n    Validates whether a given string is a valid ISBN-13 number.\n\n    This function checks if the input string conforms to the ISBN-13 format\n    and calculates the check digit to ensure its validity.\n\n\n    [EXAMPLES]\n    \n    assert candidate(\"978 0 306 40615 7\") == True\n    assert candidate(\"978-1-56619-909-4\") == True\n\n    [/EXAMPLES]\n    \"\"\"\n```\n", "entry_point": "validate_isbn13", "solution": "import re\n\ndef validate_isbn13(isbn: str) -> bool:\n    \"\"\"\n    Validates whether a given string is a valid ISBN-13 number.\n\n    This function checks if the input string conforms to the ISBN-13 format\n    and calculates the check digit to ensure its validity.\n\n\n    [EXAMPLES]\n    \n    assert candidate(\"978 0 306 40615 7\") == True\n    assert candidate(\"978-1-56619-909-4\") == True\n\n    [/EXAMPLES]\n    \"\"\"\n    # Remove hyphens and spaces\n    isbn = re.sub(r'[-\\s]', '', isbn)\n    \n    # Check if the ISBN is exactly 13 digits\n    if not re.match(r'^\\d{13}$', isbn):\n        return False\n    \n    # Calculate the check digit\n    total = 0\n    for i in range(12):\n        digit = int(isbn[i])\n        total += digit if i % 2 == 0 else 3 * digit\n    \n    check_digit = (10 - (total % 10)) % 10\n    \n    # Compare the calculated check digit with the last digit of ISBN\n    return check_digit == int(isbn[-1])\n\n", "test": "def check(candidate):\n    assert candidate(\"111-1-111-11111-1\") == False\n    assert candidate(\"999-9-999-99999-9\") == False\n    assert candidate(\"978 0 306 40615 7\") == True\n    assert candidate(\"978-0-7356-6724-4\") == False\n    assert candidate(\"978-3-16-148410-0\") == True\n    assert candidate(\"978 0 7356 6724 4\") == False\n    assert candidate(\"978-0-306-40615-7-1\") == False\n    assert candidate(\"9780306406157\") == True\n    assert candidate(\"978-1-56619-909-4\") == True\n    assert candidate(\"978-1-56619-909-5\") == False\n", "language": "python"}
{"task_id": "4e6bf629-2d6a-44a1-9048-9c89020c2d512481366359697896151", "prompt": "You need to complete a provided function, ensuring it's executable as-is within a single code block. Don't add any code outside the function. Use only the libraries already imported in the problem statement. If you need additional functions or classes, define them within the given function itself.\n\n```python\ndef analyze_social_network(connections: dict, start_person: str, max_depth: int) -> dict:\n    \"\"\"\n    You are a data scientist analyzing a social network. \n    Your task is to create a function that explores the network connections of a given person up to a specified depth.\n\n    The function should take three parameters:\n    1. connections: A dictionary representing the social network. Keys are people's names, and values are lists of their direct connections.\n    2. start_person: The name of the person to start the analysis from.\n    3. max_depth: The maximum depth of connections to explore.\n\n    The function should return a dictionary where:\n    - Keys are the depths (0 to max_depth)\n    - Values are sets of people connected at that depth\n\n    Rules:\n    - Depth 0 contains only the start_person.\n    - Each subsequent depth contains people directly connected to anyone in the previous depth, who haven't appeared at a lower depth.\n    - The function should use breadth-first search and handle cycles in the network.\n\n\n    [EXAMPLES]\n    \n    assert candidate({\"A\": [\"B\", \"C\"], \"B\": [\"A\", \"D\"], \"C\": [\"A\", \"E\"], \"D\": [\"B\"], \"E\": [\"C\"], \"F\": [\"G\"], \"G\": [\"F\"]}, \"A\", 5) == {0: {'A'}, 1: {'C', 'B'}, 2: {'D', 'E'}, 3: set(), 4: set(), 5: set()}\n    assert candidate({\"A\": [\"B\", \"C\"], \"B\": [\"A\", \"D\"], \"C\": [\"A\", \"E\"], \"D\": [\"B\", \"F\"], \"E\": [\"C\", \"F\"], \"F\": [\"D\", \"E\"]}, \"A\", 3) == {0: {'A'}, 1: {'C', 'B'}, 2: {'D', 'E'}, 3: {'F'}}\n\n    [/EXAMPLES]\n    \"\"\"\n```\n", "entry_point": "analyze_social_network", "solution": "def analyze_social_network(connections: dict, start_person: str, max_depth: int) -> dict:\n    \"\"\"\n    You are a data scientist analyzing a social network. \n    Your task is to create a function that explores the network connections of a given person up to a specified depth.\n\n    The function should take three parameters:\n    1. connections: A dictionary representing the social network. Keys are people's names, and values are lists of their direct connections.\n    2. start_person: The name of the person to start the analysis from.\n    3. max_depth: The maximum depth of connections to explore.\n\n    The function should return a dictionary where:\n    - Keys are the depths (0 to max_depth)\n    - Values are sets of people connected at that depth\n\n    Rules:\n    - Depth 0 contains only the start_person.\n    - Each subsequent depth contains people directly connected to anyone in the previous depth, who haven't appeared at a lower depth.\n    - The function should use breadth-first search and handle cycles in the network.\n\n\n    [EXAMPLES]\n    \n    assert candidate({\"A\": [\"B\", \"C\"], \"B\": [\"A\", \"D\"], \"C\": [\"A\", \"E\"], \"D\": [\"B\"], \"E\": [\"C\"], \"F\": [\"G\"], \"G\": [\"F\"]}, \"A\", 5) == {0: {'A'}, 1: {'C', 'B'}, 2: {'D', 'E'}, 3: set(), 4: set(), 5: set()}\n    assert candidate({\"A\": [\"B\", \"C\"], \"B\": [\"A\", \"D\"], \"C\": [\"A\", \"E\"], \"D\": [\"B\", \"F\"], \"E\": [\"C\", \"F\"], \"F\": [\"D\", \"E\"]}, \"A\", 3) == {0: {'A'}, 1: {'C', 'B'}, 2: {'D', 'E'}, 3: {'F'}}\n\n    [/EXAMPLES]\n    \"\"\"\n    def bfs(start, max_depth):\n        result = {depth: set() for depth in range(max_depth + 1)}\n        result[0].add(start)\n        \n        queue = [(start, 0)]\n        visited = set([start])\n        \n        while queue:\n            person, depth = queue.pop(0)\n            \n            if depth >= max_depth:\n                break\n            \n            for friend in connections.get(person, []):\n                if friend not in visited:\n                    visited.add(friend)\n                    result[depth + 1].add(friend)\n                    queue.append((friend, depth + 1))\n        \n        return result\n\n    return bfs(start_person, max_depth)\n\n", "test": "def check(candidate):\n    assert candidate({\"A\": [\"B\", \"C\"], \"B\": [\"A\", \"D\"], \"C\": [\"A\", \"E\"], \"D\": [\"B\", \"F\"], \"E\": [\"C\", \"F\"], \"F\": [\"D\", \"E\", \"G\"], \"G\": [\"F\"]}, \"A\", 4) == {0: {'A'}, 1: {'C', 'B'}, 2: {'D', 'E'}, 3: {'F'}, 4: {'G'}}\n    assert candidate({\"A\": [\"B\", \"C\"], \"B\": [\"A\", \"D\", \"E\"], \"C\": [\"A\", \"F\"], \"D\": [\"B\"], \"E\": [\"B\", \"F\"], \"F\": [\"C\", \"E\"]}, \"A\", 3) == {0: {'A'}, 1: {'C', 'B'}, 2: {'F', 'D', 'E'}, 3: set()}\n    assert candidate({\"Solo\": []}, \"Solo\", 5) == {0: {'Solo'}, 1: set(), 2: set(), 3: set(), 4: set(), 5: set()}\n    assert candidate({\"A\": [\"B\", \"C\", \"D\", \"E\"], \"B\": [\"A\"], \"C\": [\"A\"], \"D\": [\"A\"], \"E\": [\"A\"]}, \"A\", 1) == {0: {'A'}, 1: {'D', 'B', 'E', 'C'}}\n    assert candidate({\"A\": [\"B\"], \"B\": [\"A\"]}, \"A\", 10) == {0: {'A'}, 1: {'B'}, 2: set(), 3: set(), 4: set(), 5: set(), 6: set(), 7: set(), 8: set(), 9: set(), 10: set()}\n    assert candidate({\"A\": [\"B\", \"C\"], \"B\": [\"A\", \"D\"], \"C\": [\"A\", \"E\"], \"D\": [\"B\", \"F\"], \"E\": [\"C\", \"F\"], \"F\": [\"D\", \"E\"]}, \"A\", 3) == {0: {'A'}, 1: {'C', 'B'}, 2: {'D', 'E'}, 3: {'F'}}\n    assert candidate({\"Alice\": [\"Bob\", \"Charlie\"], \"Bob\": [\"Alice\", \"David\"], \"Charlie\": [\"Alice\", \"Eve\"], \"David\": [\"Bob\", \"Eve\"], \"Eve\": [\"Charlie\", \"David\"]}, \"Alice\", 2) == {0: {'Alice'}, 1: {'Charlie', 'Bob'}, 2: {'Eve', 'David'}}\n    assert candidate({\"A\": [\"B\"], \"B\": [\"C\"], \"C\": [\"D\"], \"D\": [\"E\"], \"E\": [\"A\"]}, \"C\", 3) == {0: {'C'}, 1: {'D'}, 2: {'E'}, 3: {'A'}}\n    assert candidate({\"A\": [\"B\", \"C\"], \"B\": [\"A\", \"D\"], \"C\": [\"A\", \"E\"], \"D\": [\"B\"], \"E\": [\"C\"], \"F\": [\"G\"], \"G\": [\"F\"]}, \"A\", 5) == {0: {'A'}, 1: {'C', 'B'}, 2: {'D', 'E'}, 3: set(), 4: set(), 5: set()}\n    assert candidate({\"A\": [\"B\"], \"B\": [\"C\"], \"C\": [\"D\"], \"D\": [\"E\"], \"E\": [\"F\"], \"F\": [\"G\"]}, \"G\", 6) == {0: {'G'}, 1: set(), 2: set(), 3: set(), 4: set(), 5: set(), 6: set()}\n", "language": "python"}
{"task_id": "51d221e2-f2f3-40c3-bf8c-707ac27526c94436233402211251531", "prompt": "Your job is to write code that completes the provided function so it works correctly. Keep everything within the function scope, using only the libraries that are already imported. Any helper functions or classes should be defined inside the main function.\n\n```python\nfrom typing import List\n\ndef analyze_stock_prices(prices: List[float], window: int) -> List[float]:\n    \"\"\"\n    In a financial analysis project, you need to calculate the moving average of stock prices.\n    Given a list of daily stock prices and a window size, compute the moving average for each\n    window of consecutive days. The function should use list comprehension and slicing to\n    efficiently calculate the averages.\n\n    Parameters:\n    prices (List[float]): A list of daily stock prices\n    window (int): The number of days to consider for each moving average calculation\n\n    Returns:\n    List[float]: A list of moving averages\n\n\n    [EXAMPLES]\n    \n    assert candidate([1.1, 2.2, 3.3, 4.4, 5.5], 2) == [1.6500000000000001, 2.75, 3.85, 4.95]\n    assert candidate([100.0, 99.9, 99.8, 99.7, 99.6], 2) == [99.95, 99.85, 99.75, 99.65]\n\n    [/EXAMPLES]\n    \"\"\"\n```\n", "entry_point": "analyze_stock_prices", "solution": "from typing import List\n\ndef analyze_stock_prices(prices: List[float], window: int) -> List[float]:\n    \"\"\"\n    In a financial analysis project, you need to calculate the moving average of stock prices.\n    Given a list of daily stock prices and a window size, compute the moving average for each\n    window of consecutive days. The function should use list comprehension and slicing to\n    efficiently calculate the averages.\n\n    Parameters:\n    prices (List[float]): A list of daily stock prices\n    window (int): The number of days to consider for each moving average calculation\n\n    Returns:\n    List[float]: A list of moving averages\n\n\n    [EXAMPLES]\n    \n    assert candidate([1.1, 2.2, 3.3, 4.4, 5.5], 2) == [1.6500000000000001, 2.75, 3.85, 4.95]\n    assert candidate([100.0, 99.9, 99.8, 99.7, 99.6], 2) == [99.95, 99.85, 99.75, 99.65]\n\n    [/EXAMPLES]\n    \"\"\"\n    if not prices or window <= 0 or window > len(prices):\n        return []\n\n    return [sum(prices[i:i+window]) / window for i in range(len(prices) - window + 1)]\n\n", "test": "def check(candidate):\n    assert candidate([50.5, 51.0, 51.5, 52.0, 52.5], 5) == [51.5]\n    assert candidate([100.0, 99.9, 99.8, 99.7, 99.6], 2) == [99.95, 99.85, 99.75, 99.65]\n    assert candidate([100.0, 99.0, 98.0, 97.0, 96.0], 4) == [98.5, 97.5]\n    assert candidate([0.1, 1.0, 10.0, 100.0, 1000.0], 5) == [222.21999999999997]\n    assert candidate([0.5, 1.5, 2.5, 3.5, 4.5], 3) == [1.5, 2.5, 3.5]\n    assert candidate([1.0, 10.0, 100.0, 1000.0, 10000.0], 2) == [5.5, 55.0, 550.0, 5500.0]\n    assert candidate([0.1, 0.2, 0.3, 0.4, 0.5], 4) == [0.25, 0.35]\n    assert candidate([9.99, 19.99, 29.99, 39.99, 49.99], 4) == [24.990000000000002, 34.99]\n    assert candidate([1.0, 2.0, 3.0, 4.0, 5.0], 2) == [1.5, 2.5, 3.5, 4.5]\n    assert candidate([1.1, 2.2, 3.3, 4.4, 5.5], 2) == [1.6500000000000001, 2.75, 3.85, 4.95]\n", "language": "python"}
{"task_id": "d882a491-dd4b-47bc-9866-5ef01655749f-1926336753603886041", "prompt": "Your function should be implementation-ready with no code outside its definition. Only utilize libraries that are imported in the problem statement. Any additional functionality should be defined as nested functions or classes within the main function.\n\n```python\nfrom typing import List\n\ndef submarine_sonar(depths: List[int]) -> int:\n    \"\"\"\n    A submarine is navigating through an underwater canyon and needs to determine\n    the number of times the depth increases from one measurement to the next.\n\n    This function takes a list of depth measurements and returns the count of depth\n    increases. It utilizes list comprehension and comparison operations.\n\n\n    [EXAMPLES]\n    \n    assert candidate([-5, -4, -3, -2, -1, 0]) == 5\n    assert candidate([10000, 1000, 100, 10, 1]) == 0\n\n    [/EXAMPLES]\n    \"\"\"\n```\n", "entry_point": "submarine_sonar", "solution": "from typing import List\n\ndef submarine_sonar(depths: List[int]) -> int:\n    \"\"\"\n    A submarine is navigating through an underwater canyon and needs to determine\n    the number of times the depth increases from one measurement to the next.\n\n    This function takes a list of depth measurements and returns the count of depth\n    increases. It utilizes list comprehension and comparison operations.\n\n\n    [EXAMPLES]\n    \n    assert candidate([-5, -4, -3, -2, -1, 0]) == 5\n    assert candidate([10000, 1000, 100, 10, 1]) == 0\n\n    [/EXAMPLES]\n    \"\"\"\n    return sum(1 for i in range(1, len(depths)) if depths[i] > depths[i-1])\n\n", "test": "def check(candidate):\n    assert candidate([-5, -4, -3, -2, -1, 0]) == 5\n    assert candidate([0, 0, 1, 1, 2, 2, 3, 3]) == 3\n    assert candidate([100, 101, 102, 103, 104, 105]) == 5\n    assert candidate([1, 2, 1, 2, 1, 2]) == 3\n    assert candidate([100]) == 0\n    assert candidate([3, 3, 2, 2, 1, 1, 0, 0]) == 0\n    assert candidate([1000000, 999999, 1000001, 999998, 1000002]) == 2\n    assert candidate([10000, 1000, 100, 10, 1]) == 0\n", "language": "python"}
{"task_id": "72dc1b70-f072-4ded-8258-40a3f4f55f237465091152818684800", "prompt": "I'll finish writing this function according to the docstring specification. Here's the complete implementation in one code block:\n\n```python\ndef longest_palindrome_substring(s: str) -> str:\n    \"\"\"\n    A computer science student is working on a string manipulation problem for a coding competition.\n    This function takes a string as input and returns the longest palindromic substring within it.\n    A palindrome is a string that reads the same forward and backward.\n    If there are multiple palindromic substrings with the maximum length, return the first one that occurs.\n    The function should be case-sensitive.\n\n\n    [EXAMPLES]\n    \n    assert candidate(\"a\") == 'a'\n    assert candidate(\"aaaaaa\") == 'aaaaaa'\n\n    [/EXAMPLES]\n    \"\"\"\n```\n", "entry_point": "longest_palindrome_substring", "solution": "def longest_palindrome_substring(s: str) -> str:\n    \"\"\"\n    A computer science student is working on a string manipulation problem for a coding competition.\n    This function takes a string as input and returns the longest palindromic substring within it.\n    A palindrome is a string that reads the same forward and backward.\n    If there are multiple palindromic substrings with the maximum length, return the first one that occurs.\n    The function should be case-sensitive.\n\n\n    [EXAMPLES]\n    \n    assert candidate(\"a\") == 'a'\n    assert candidate(\"aaaaaa\") == 'aaaaaa'\n\n    [/EXAMPLES]\n    \"\"\"\n    def expand_around_center(left: int, right: int) -> str:\n        while left >= 0 and right < len(s) and s[left] == s[right]:\n            left -= 1\n            right += 1\n        return s[left + 1:right]\n\n    if len(s) < 2:\n        return s\n\n    longest = \"\"\n    for i in range(len(s)):\n        # Check for odd-length palindromes\n        palindrome1 = expand_around_center(i, i)\n        if len(palindrome1) > len(longest):\n            longest = palindrome1\n\n        # Check for even-length palindromes\n        palindrome2 = expand_around_center(i, i + 1)\n        if len(palindrome2) > len(longest):\n            longest = palindrome2\n\n    return longest\n\n", "test": "def check(candidate):\n    assert candidate(\"abcdeedcba\") == 'abcdeedcba'\n    assert candidate(\"racecar\") == 'racecar'\n    assert candidate(\"A man a plan a canal Panama\") == ' a '\n    assert candidate(\"a\") == 'a'\n    assert candidate(\"abcba\") == 'abcba'\n    assert candidate(\"aba\") == 'aba'\n    assert candidate(\"abba\") == 'abba'\n    assert candidate(\"Hannah\") == 'anna'\n    assert candidate(\"abcdefghhgfedcba\") == 'abcdefghhgfedcba'\n    assert candidate(\"aaaaaa\") == 'aaaaaa'\n", "language": "python"}
{"task_id": "22619443-c73d-443f-ae55-bf37ba6d90be7316761911549844787", "prompt": "Acting as a coding assistant, your job is to complete a function that can be executed in a code block without modification. Keep all code confined to the function scope. Only use libraries that were imported in the problem description. Define any supplementary functions or classes inside the main function.\n\n```python\nfrom typing import List, Tuple\n\ndef treasure_hunt(map_size: Tuple[int, int], clues: List[str]) -> int:\n    \"\"\"\n    A group of adventurers have stumbled upon an ancient treasure map. The map is represented by a grid,\n    and the clues are a series of directions. Your task is to determine how many treasures they can find.\n\n    The map_size parameter represents the dimensions of the grid (rows, columns).\n    The clues parameter is a list of strings, where each string is a series of directions:\n    'N' for North, 'S' for South, 'E' for East, and 'W' for West.\n\n    Each clue starts from the top-left corner of the map (0, 0) and may lead to a treasure.\n    If a clue leads outside the map boundaries, it's considered invalid and no treasure is found.\n    Multiple clues may lead to the same location, but it's counted as only one treasure.\n\n    Return the number of unique treasures found.\n\n\n    [EXAMPLES]\n    \n    assert candidate((3, 3), [\"SE\", \"EE\", \"SS\", \"NN\", \"WW\"]) == 3\n    assert candidate((3, 2), [\"SEW\", \"NEW\", \"SWE\", \"NWE\"]) == 1\n\n    [/EXAMPLES]\n    \"\"\"\n```\n", "entry_point": "treasure_hunt", "solution": "from typing import List, Tuple\n\ndef treasure_hunt(map_size: Tuple[int, int], clues: List[str]) -> int:\n    \"\"\"\n    A group of adventurers have stumbled upon an ancient treasure map. The map is represented by a grid,\n    and the clues are a series of directions. Your task is to determine how many treasures they can find.\n\n    The map_size parameter represents the dimensions of the grid (rows, columns).\n    The clues parameter is a list of strings, where each string is a series of directions:\n    'N' for North, 'S' for South, 'E' for East, and 'W' for West.\n\n    Each clue starts from the top-left corner of the map (0, 0) and may lead to a treasure.\n    If a clue leads outside the map boundaries, it's considered invalid and no treasure is found.\n    Multiple clues may lead to the same location, but it's counted as only one treasure.\n\n    Return the number of unique treasures found.\n\n\n    [EXAMPLES]\n    \n    assert candidate((3, 3), [\"SE\", \"EE\", \"SS\", \"NN\", \"WW\"]) == 3\n    assert candidate((3, 2), [\"SEW\", \"NEW\", \"SWE\", \"NWE\"]) == 1\n\n    [/EXAMPLES]\n    \"\"\"\n    def follow_clue(clue: str) -> Tuple[int, int]:\n        x, y = 0, 0\n        for direction in clue:\n            if direction == 'N':\n                y -= 1\n            elif direction == 'S':\n                y += 1\n            elif direction == 'E':\n                x += 1\n            elif direction == 'W':\n                x -= 1\n            \n            if x < 0 or x >= map_size[1] or y < 0 or y >= map_size[0]:\n                return None\n        \n        return (x, y)\n\n    treasures = set()\n    \n    for clue in clues:\n        location = follow_clue(clue)\n        if location is not None:\n            treasures.add(location)\n    \n    return len(treasures)\n\n", "test": "def check(candidate):\n    assert candidate((2, 2), [\"E\", \"S\", \"W\", \"N\"]) == 2\n    assert candidate((8, 8), [\"NNNNSSSS\", \"EEEEWWWW\", \"NESWNESW\"]) == 1\n    assert candidate((5, 5), [\"NSEW\", \"EWNS\", \"SESW\", \"NWNE\"]) == 1\n    assert candidate((2, 3), [\"EEN\", \"EES\", \"WWN\", \"WWS\"]) == 1\n    assert candidate((3, 2), [\"SEW\", \"NEW\", \"SWE\", \"NWE\"]) == 1\n    assert candidate((7, 7), [\"NENENENE\", \"SESESESW\", \"EWEWEWEWE\"]) == 2\n    assert candidate((3, 3), [\"SE\", \"EE\", \"SS\", \"NN\", \"WW\"]) == 3\n    assert candidate((5, 3), [\"EEE\", \"SSS\", \"NNN\", \"WWW\"]) == 1\n    assert candidate((4, 4), [\"\", \"E\", \"EE\", \"EEE\"]) == 4\n    assert candidate((6, 6), [\"NNNSSS\", \"EEEWWW\", \"NESESW\"]) == 1\n", "language": "python"}
{"task_id": "abf35833-7e4f-4196-9008-0f2fc53e64a78919516089725099237", "prompt": "Your response should contain only the completed function that can run as-is in one code block. All supporting functions or classes must be nested within the main function. Restrict library usage to only those imported in the problem description. Do not include any code outside the function definition.\n\n```python\nfrom typing import List\nfrom collections import deque\n\ndef maze_shortest_path(maze: List[List[int]]) -> int:\n    \"\"\"\n    A robot is trying to navigate through a maze represented as a 2D grid.\n    This function finds the length of the shortest path from the top-left corner (0,0)\n    to the bottom-right corner of the maze. The maze is represented as a 2D list of 0s and 1s,\n    where 0 represents an open cell and 1 represents a wall. The robot can move in four\n    directions: up, down, left, and right. If there is no valid path, return -1.\n\n\n    [EXAMPLES]\n    \n    assert candidate([[0,0,0,0,0],[0,1,1,1,0],[0,1,0,1,0],[0,1,0,0,0],[0,0,0,1,0]]) == 8\n    assert candidate([[0,0],[0,0]]) == 2\n\n    [/EXAMPLES]\n    \"\"\"\n```\n", "entry_point": "maze_shortest_path", "solution": "from typing import List\nfrom collections import deque\n\ndef maze_shortest_path(maze: List[List[int]]) -> int:\n    \"\"\"\n    A robot is trying to navigate through a maze represented as a 2D grid.\n    This function finds the length of the shortest path from the top-left corner (0,0)\n    to the bottom-right corner of the maze. The maze is represented as a 2D list of 0s and 1s,\n    where 0 represents an open cell and 1 represents a wall. The robot can move in four\n    directions: up, down, left, and right. If there is no valid path, return -1.\n\n\n    [EXAMPLES]\n    \n    assert candidate([[0,0,0,0,0],[0,1,1,1,0],[0,1,0,1,0],[0,1,0,0,0],[0,0,0,1,0]]) == 8\n    assert candidate([[0,0],[0,0]]) == 2\n\n    [/EXAMPLES]\n    \"\"\"\n    if not maze or not maze[0]:\n        return -1\n\n    rows, cols = len(maze), len(maze[0])\n    \n    # Check if start or end is blocked\n    if maze[0][0] == 1 or maze[rows-1][cols-1] == 1:\n        return -1\n\n    # Define directions: up, right, down, left\n    directions = [(-1, 0), (0, 1), (1, 0), (0, -1)]\n    \n    # Initialize queue for BFS\n    queue = deque([(0, 0, 0)])  # (row, col, distance)\n    visited = set([(0, 0)])\n\n    while queue:\n        row, col, distance = queue.popleft()\n\n        # Check if we've reached the bottom-right corner\n        if row == rows - 1 and col == cols - 1:\n            return distance\n\n        # Explore all four directions\n        for dr, dc in directions:\n            new_row, new_col = row + dr, col + dc\n\n            # Check if the new position is valid and not visited\n            if (0 <= new_row < rows and \n                0 <= new_col < cols and \n                maze[new_row][new_col] == 0 and \n                (new_row, new_col) not in visited):\n                \n                queue.append((new_row, new_col, distance + 1))\n                visited.add((new_row, new_col))\n\n    # If we've exhausted all possibilities without reaching the end\n    return -1\n\n", "test": "def check(candidate):\n    assert candidate([[0,0,0],[0,1,0],[0,0,0]]) == 4\n    assert candidate([[0,0],[0,0]]) == 2\n    assert candidate([[0,0,0,0],[1,1,1,0],[0,0,0,0]]) == 5\n    assert candidate([[0,1,1,1,1],[0,0,0,0,1],[1,1,1,0,1],[1,0,0,0,1],[1,1,1,1,0]]) == -1\n    assert candidate([[0,1,0,0,0],[0,1,0,1,0],[0,0,0,0,0],[1,1,1,1,0],[0,0,0,1,0]]) == 8\n    assert candidate([[0,0,0,0],[1,1,1,0],[0,0,0,0],[0,1,1,0]]) == 6\n    assert candidate([[0,0,0,0,1],[1,1,1,0,1],[0,0,0,0,1],[0,1,1,1,1],[0,0,0,0,0]]) == 14\n    assert candidate([[0,0,0,0,0],[0,1,1,1,0],[0,1,0,1,0],[0,1,0,0,0],[0,0,0,1,0]]) == 8\n    assert candidate([[0,0,0,0,0],[1,1,1,1,0],[0,0,0,1,0],[0,1,0,1,0],[0,1,0,0,0]]) == 8\n    assert candidate([[0]]) == 0\n", "language": "python"}
{"task_id": "099a13c7-37a4-47a1-a2bc-50c30d4e32d05082641098523271073", "prompt": "Complete the given function to make it fully executable within a single code block. Don't add any code outside the function. Limit yourself to libraries that are already imported in the problem. Any additional functions or classes should be defined inside the main function. Provide only one code block in your response.\n\n```python\nfrom collections import Counter, deque\nfrom typing import List\n\ndef schedule_tasks(tasks: List[str], cooldown: int) -> int:\n    \"\"\"\n    A computer scientist is designing a task scheduler for a CPU.\n    Given a list of tasks (represented by letters) and a cooldown period,\n    determine the least number of units of time that the CPU will take to finish all tasks.\n    The same task cannot be executed twice within n units of time, where n is the cooldown period.\n\n    This function uses a greedy approach with a queue to simulate the scheduling process.\n\n\n    [EXAMPLES]\n    \n    assert candidate(['A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O', 'P', 'Q', 'R', 'S', 'T'], 5) == 20\n    assert candidate(['A', 'A', 'A'], 1) == 5\n\n    [/EXAMPLES]\n    \"\"\"\n```\n", "entry_point": "schedule_tasks", "solution": "from collections import Counter, deque\nfrom typing import List\n\ndef schedule_tasks(tasks: List[str], cooldown: int) -> int:\n    \"\"\"\n    A computer scientist is designing a task scheduler for a CPU.\n    Given a list of tasks (represented by letters) and a cooldown period,\n    determine the least number of units of time that the CPU will take to finish all tasks.\n    The same task cannot be executed twice within n units of time, where n is the cooldown period.\n\n    This function uses a greedy approach with a queue to simulate the scheduling process.\n\n\n    [EXAMPLES]\n    \n    assert candidate(['A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O', 'P', 'Q', 'R', 'S', 'T'], 5) == 20\n    assert candidate(['A', 'A', 'A'], 1) == 5\n\n    [/EXAMPLES]\n    \"\"\"\n    if not tasks:\n        return 0\n\n    task_counts = Counter(tasks)\n    max_count = max(task_counts.values())\n    max_count_tasks = sum(1 for count in task_counts.values() if count == max_count)\n\n    min_time = (max_count - 1) * (cooldown + 1) + max_count_tasks\n\n    return max(min_time, len(tasks))\n\n", "test": "def check(candidate):\n    assert candidate(['A', 'A', 'A'], 1) == 5\n    assert candidate(['A'], 10) == 1\n    assert candidate(['A', 'A', 'B', 'B', 'C', 'C'], 2) == 6\n    assert candidate(['A', 'A', 'A', 'A', 'A', 'B', 'B', 'B', 'B', 'B', 'C', 'C', 'C', 'C', 'C'], 2) == 15\n    assert candidate(['A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O', 'P', 'Q', 'R', 'S', 'T'], 5) == 20\n    assert candidate(['A', 'A', 'A', 'A', 'A', 'A', 'B', 'C'], 2) == 16\n    assert candidate(['A', 'B', 'C', 'D'], 0) == 4\n    assert candidate(['A', 'B', 'C', 'A', 'D', 'E'], 3) == 6\n    assert candidate(['A', 'A', 'A', 'B', 'B', 'B'], 3) == 10\n    assert candidate(['A', 'B', 'C', 'A', 'B', 'C', 'A', 'B', 'C'], 2) == 9\n", "language": "python"}
{"task_id": "02a5158a-e090-4c0f-a0b8-5a33a2669d35-2314515137599122095", "prompt": "Continue implementing the function based on the provided docstring. Ensure your solution is contained within a single code block, and account for all edge cases.\n\n```python\nfrom typing import List, Tuple\n\ndef decrypt_message(encrypted: str, key: List[Tuple[str, str]]) -> str:\n    \"\"\"\n    Implement a decryption function for a simple substitution cipher.\n    \n    The function takes two parameters:\n    1. A string containing the encrypted message (may include spaces and punctuation).\n    2. A list of tuples representing the decryption key, where each tuple contains\n       an encrypted character and its corresponding decrypted character.\n    \n    The function should decrypt the message using the provided key. Characters not\n    present in the key should remain unchanged. The decryption should be case-sensitive.\n    \n    Return the decrypted message as a string.\n    \n\n    [EXAMPLES]\n    \n    assert candidate(\"UPPERCASE\", [('U', 'L'), ('P', 'O'), ('E', 'W')]) == 'LOOWRCASW'\n    assert candidate(\"EmptyPairs\", [('', ''), ('', '')]) == 'EmptyPairs'\n\n    [/EXAMPLES]\n    \"\"\"\n```\n", "entry_point": "decrypt_message", "solution": "from typing import List, Tuple\n\ndef decrypt_message(encrypted: str, key: List[Tuple[str, str]]) -> str:\n    \"\"\"\n    Implement a decryption function for a simple substitution cipher.\n    \n    The function takes two parameters:\n    1. A string containing the encrypted message (may include spaces and punctuation).\n    2. A list of tuples representing the decryption key, where each tuple contains\n       an encrypted character and its corresponding decrypted character.\n    \n    The function should decrypt the message using the provided key. Characters not\n    present in the key should remain unchanged. The decryption should be case-sensitive.\n    \n    Return the decrypted message as a string.\n    \n\n    [EXAMPLES]\n    \n    assert candidate(\"UPPERCASE\", [('U', 'L'), ('P', 'O'), ('E', 'W')]) == 'LOOWRCASW'\n    assert candidate(\"EmptyPairs\", [('', ''), ('', '')]) == 'EmptyPairs'\n\n    [/EXAMPLES]\n    \"\"\"\n    # Create a dictionary from the key for efficient lookup\n    decryption_dict = dict(key)\n    \n    # Initialize an empty list to store decrypted characters\n    decrypted_chars = []\n    \n    # Iterate through each character in the encrypted message\n    for char in encrypted:\n        # If the character is in the decryption dictionary, replace it\n        # Otherwise, keep the original character\n        decrypted_char = decryption_dict.get(char, char)\n        decrypted_chars.append(decrypted_char)\n    \n    # Join the decrypted characters into a string\n    decrypted_message = ''.join(decrypted_chars)\n    \n    return decrypted_message\n\n", "test": "def check(candidate):\n    assert candidate(\"!@#$%\", [('!', 'a'), ('@', 'b'), ('#', 'c'), ('$', 'd'), ('%', 'e')]) == 'abcde'\n    assert candidate(\"lowercase\", [('l', 'u'), ('o', 'p'), ('w', 'q'), ('e', 'r')]) == 'upqrrcasr'\n    assert candidate(\"Line1\\nLine2\", [('\\n', ' ')]) == 'Line1 Line2'\n    assert candidate(\"No change needed\", [('z', 'y')]) == 'No change needed'\n    assert candidate(\"Hello, World!\", [('H', 'G'), ('e', 'd'), ('l', 'k'), ('o', 'n'), ('W', 'V'), ('r', 'q'), ('d', 'c')]) == 'Gdkkn, Vnqkc!'\n    assert candidate(\"Repeated\", [('e', 'a'), ('e', 'b'), ('e', 'c')]) == 'Rcpcatcd'\n    assert candidate(\"abcdefghijklmnopqrstuvwxyz\", [('a', 'z'), ('b', 'y'), ('c', 'x'), ('d', 'w'), ('e', 'v'), ('f', 'u'), ('g', 't'), ('h', 's'), ('i', 'r'), ('j', 'q'), ('k', 'p'), ('l', 'o'), ('m', 'n'), ('n', 'm'), ('o', 'l'), ('p', 'k'), ('q', 'j'), ('r', 'i'), ('s', 'h'), ('t', 'g'), ('u', 'f'), ('v', 'e'), ('w', 'd'), ('x', 'c'), ('y', 'b'), ('z', 'a')]) == 'zyxwvutsrqponmlkjihgfedcba'\n    assert candidate(\"Hello, World!\", []) == 'Hello, World!'\n    assert candidate(\"UPPERCASE\", [('U', 'L'), ('P', 'O'), ('E', 'W')]) == 'LOOWRCASW'\n    assert candidate(\"EmptyPairs\", [('', ''), ('', '')]) == 'EmptyPairs'\n", "language": "python"}
{"task_id": "ba80be6e-73d8-4f18-a76e-f2236ea9d3297441053573288171554", "prompt": "I'll need you to complete the function implementation as specified in the docstring. Please provide the code in one cohesive block and be sure to account for any edge cases that might arise.\n\n```python\nfrom typing import List, Tuple\n\ndef stock_span(prices: List[float]) -> List[int]:\n    \"\"\"\n    A stock trader wants to analyze the span of stock prices. The span of a stock's price on a given day is the\n    maximum number of consecutive days (starting from that day and going backward) for which the stock price\n    was less than or equal to the price on that day.\n\n    This function takes a list of daily stock prices and returns a list of corresponding spans.\n\n\n    [EXAMPLES]\n    \n    assert candidate([1.0, 2.0, 1.0, 2.0, 1.0, 2.0, 1.0]) == [1, 2, 1, 4, 1, 6, 1]\n    assert candidate([10, 4, 5, 90, 120, 80]) == [1, 1, 2, 4, 5, 1]\n\n    [/EXAMPLES]\n    \"\"\"\n```\n", "entry_point": "stock_span", "solution": "from typing import List, Tuple\n\ndef stock_span(prices: List[float]) -> List[int]:\n    \"\"\"\n    A stock trader wants to analyze the span of stock prices. The span of a stock's price on a given day is the\n    maximum number of consecutive days (starting from that day and going backward) for which the stock price\n    was less than or equal to the price on that day.\n\n    This function takes a list of daily stock prices and returns a list of corresponding spans.\n\n\n    [EXAMPLES]\n    \n    assert candidate([1.0, 2.0, 1.0, 2.0, 1.0, 2.0, 1.0]) == [1, 2, 1, 4, 1, 6, 1]\n    assert candidate([10, 4, 5, 90, 120, 80]) == [1, 1, 2, 4, 5, 1]\n\n    [/EXAMPLES]\n    \"\"\"\n    n = len(prices)\n    spans = [1] * n\n    stack: List[Tuple[int, float]] = []\n\n    for i, price in enumerate(prices):\n        while stack and price >= stack[-1][1]:\n            stack.pop()\n        \n        if stack:\n            spans[i] = i - stack[-1][0]\n        else:\n            spans[i] = i + 1\n        \n        stack.append((i, price))\n\n    return spans\n\n", "test": "def check(candidate):\n    assert candidate([0.1, 0.2, 0.3, 0.4, 0.5]) == [1, 2, 3, 4, 5]\n    assert candidate([1.0, 1.0, 1.0, 1.0, 1.0]) == [1, 2, 3, 4, 5]\n    assert candidate([1.0, 1.1, 1.01, 1.001, 1.0001]) == [1, 2, 1, 1, 1]\n    assert candidate([5.5, 4.4, 3.3, 2.2, 1.1]) == [1, 1, 1, 1, 1]\n    assert candidate([1.0, 2.0, 1.0, 2.0, 1.0, 2.0, 1.0]) == [1, 2, 1, 4, 1, 6, 1]\n    assert candidate([1.0, 1.5, 2.0, 2.5, 3.0, 3.5, 4.0]) == [1, 2, 3, 4, 5, 6, 7]\n    assert candidate([1.1, 2.2, 3.3, 4.4, 5.5]) == [1, 2, 3, 4, 5]\n    assert candidate([100, 80, 60, 70, 60, 75, 85]) == [1, 1, 1, 2, 1, 4, 6]\n    assert candidate([10.0]) == [1]\n    assert candidate([10, 4, 5, 90, 120, 80]) == [1, 1, 2, 4, 5, 1]\n", "language": "python"}
{"task_id": "9b490412-df50-47d7-9af0-b1385c56b970-530241473280102896", "prompt": "I am a coding assistant here to help you complete functions that are ready to be executed. I'll provide the implementation within the code block, using only the libraries specified in the problem. Any additional functions or classes I create will be defined inside the main function. I won't add unnecessary code outside the function scope.\n\n```python\nimport math\nfrom typing import List\n\ndef analyze_ecosystem_diversity(species_counts: List[int]) -> float:\n    \"\"\"\n    In an ecological study, analyze the diversity of species in an ecosystem using the\n    Shannon diversity index.\n\n    Given a list of integer counts representing the number of individuals for each species\n    observed in the ecosystem, calculate the Shannon diversity index.\n\n    The Shannon diversity index is calculated as:\n    H = -sum(p_i * log(p_i))\n    where p_i is the proportion of individuals belonging to the i-th species.\n\n    This function combines the concepts of mathematical operations and logarithms to\n    compute the diversity index.\n\n\n    [EXAMPLES]\n    \n    assert candidate([1, 2, 3, 4, 5]) == 1.4897503188505912\n    assert candidate([1, 1, 1, 1, 1, 95]) == 0.2789871389675776\n\n    [/EXAMPLES]\n    \"\"\"\n```\n", "entry_point": "analyze_ecosystem_diversity", "solution": "import math\nfrom typing import List\n\ndef analyze_ecosystem_diversity(species_counts: List[int]) -> float:\n    \"\"\"\n    In an ecological study, analyze the diversity of species in an ecosystem using the\n    Shannon diversity index.\n\n    Given a list of integer counts representing the number of individuals for each species\n    observed in the ecosystem, calculate the Shannon diversity index.\n\n    The Shannon diversity index is calculated as:\n    H = -sum(p_i * log(p_i))\n    where p_i is the proportion of individuals belonging to the i-th species.\n\n    This function combines the concepts of mathematical operations and logarithms to\n    compute the diversity index.\n\n\n    [EXAMPLES]\n    \n    assert candidate([1, 2, 3, 4, 5]) == 1.4897503188505912\n    assert candidate([1, 1, 1, 1, 1, 95]) == 0.2789871389675776\n\n    [/EXAMPLES]\n    \"\"\"\n    total_individuals = sum(species_counts)\n    \n    # Calculate Shannon diversity index\n    shannon_index = 0\n    for count in species_counts:\n        if count > 0:  # Avoid log(0) which is undefined\n            p_i = count / total_individuals\n            shannon_index -= p_i * math.log(p_i)\n    \n    return shannon_index\n\n", "test": "def check(candidate):\n    assert candidate([500, 500, 500, 500]) == 1.3862943611198906\n    assert candidate([9999, 1]) == 0.0010210290370309323\n    assert candidate([2, 4, 8, 16, 32, 64]) == 1.3045319869555663\n    assert candidate([1, 1, 1, 1, 1, 95]) == 0.2789871389675776\n    assert candidate([1, 2, 3, 4, 5, 6, 7, 8, 9, 10]) == 2.151281720651836\n    assert candidate([10, 20, 30, 40]) == 1.2798542258336676\n    assert candidate([1, 2, 3, 4, 5]) == 1.4897503188505912\n    assert candidate([1, 1, 1, 1, 1, 1, 1, 1, 1, 1]) == 2.3025850929940455\n    assert candidate([1, 10, 100, 1000]) == 0.3601821726181299\n    assert candidate([1, 3, 5, 7, 9, 11]) == 1.6080670865569413\n", "language": "python"}
{"task_id": "f9138a15-9175-4629-90e0-bfafc16f41486614307707173419600", "prompt": "Fill in the given function with code that can be executed directly. Don't add any code outside the function boundaries. Only use libraries that were imported in the original problem. Place any helper functions or classes inside the main function definition.\n\n```python\ndef genetic_mutation_probability(dna_sequence: str, mutation_rate: float) -> float:\n    \"\"\"\n    In a genetics study, you need to calculate the probability of a specific DNA sequence\n    mutating entirely. Each nucleotide in the sequence has an independent chance of mutating\n    based on the given mutation rate.\n\n    Args:\n    dna_sequence (str): A string representing the DNA sequence, containing only A, T, C, and G.\n    mutation_rate (float): The probability of a single nucleotide mutating, between 0 and 1.\n\n    Returns:\n    float: The probability that the entire DNA sequence will mutate.\n\n\n    [EXAMPLES]\n    \n    assert candidate(\"ATATATATATAT\", 0.5) == 0.000244140625\n    assert candidate(\"ATCGATCG\", 0.05) == 3.906250000000002e-11\n\n    [/EXAMPLES]\n    \"\"\"\n```\n", "entry_point": "genetic_mutation_probability", "solution": "def genetic_mutation_probability(dna_sequence: str, mutation_rate: float) -> float:\n    \"\"\"\n    In a genetics study, you need to calculate the probability of a specific DNA sequence\n    mutating entirely. Each nucleotide in the sequence has an independent chance of mutating\n    based on the given mutation rate.\n\n    Args:\n    dna_sequence (str): A string representing the DNA sequence, containing only A, T, C, and G.\n    mutation_rate (float): The probability of a single nucleotide mutating, between 0 and 1.\n\n    Returns:\n    float: The probability that the entire DNA sequence will mutate.\n\n\n    [EXAMPLES]\n    \n    assert candidate(\"ATATATATATAT\", 0.5) == 0.000244140625\n    assert candidate(\"ATCGATCG\", 0.05) == 3.906250000000002e-11\n\n    [/EXAMPLES]\n    \"\"\"\n    # Validate input\n    if not all(nucleotide in 'ATCG' for nucleotide in dna_sequence):\n        raise ValueError(\"DNA sequence should only contain A, T, C, and G\")\n    \n    if not 0 <= mutation_rate <= 1:\n        raise ValueError(\"Mutation rate should be between 0 and 1\")\n\n    # Calculate the probability of a single nucleotide mutating\n    single_mutation_prob = mutation_rate\n\n    # Calculate the probability of the entire sequence mutating\n    # This is the product of individual mutation probabilities\n    total_mutation_prob = single_mutation_prob ** len(dna_sequence)\n\n    return total_mutation_prob\n\n", "test": "def check(candidate):\n    assert candidate(\"TATATATA\", 0.3) == 6.560999999999998e-05\n    assert candidate(\"ATATATATATAT\", 0.5) == 0.000244140625\n    assert candidate(\"AAAA\", 1.0) == 1.0\n    assert candidate(\"TTTT\", 0.01) == 1e-08\n    assert candidate(\"ATCGATCG\", 0.05) == 3.906250000000002e-11\n    assert candidate(\"AAAAAAAAAAAAAAA\", 0.1) == 1.0000000000000009e-15\n    assert candidate(\"AAGGTTCC\", 0.125) == 5.960464477539063e-08\n    assert candidate(\"AT\", 0.75) == 0.5625\n    assert candidate(\"ACTGACTGACTG\", 0.33) == 1.667889514952986e-06\n    assert candidate(\"GCGCGC\", 0.1) == 1.0000000000000004e-06\n", "language": "python"}
{"task_id": "1215ecab-c663-4f37-abf3-98bcd1a700714282030427172249573", "prompt": "Implement the given function to be directly executable within a single code block. Do not add any code outside the function's scope. Utilize only the libraries that are already imported. If you need helper functions or classes, define them inside the main function. Provide exactly one code block in your response.\n\n```python\nfrom typing import List, Dict, Tuple\nfrom collections import defaultdict\nfrom typing import List, Dict\n\ndef analyze_social_network(connections: List[Tuple[str, str]]) -> Dict[str, int]:\n    \"\"\"\n    Analyzes a social network to determine the influence of each user.\n\n    This function takes a list of connections between users in a social network and calculates\n    the influence score for each user based on their number of connections. It utilizes graph\n    representation and dictionary manipulation to process the network data.\n\n    Args:\n        connections (List[Tuple[str, str]]): A list of tuples representing connections between users.\n\n    Returns:\n        Dict[str, int]: A dictionary mapping each user to their influence score.\n\n\n    [EXAMPLES]\n    \n    assert candidate([(\"A\", \"B\")]) == {'A': 1, 'B': 1}\n    assert candidate([(\"A\", \"B\"), (\"B\", \"C\"), (\"C\", \"A\"), (\"D\", \"E\"), (\"E\", \"F\"), (\"F\", \"D\")]) == {'A': 2, 'B': 2, 'C': 2, 'D': 2, 'E': 2, 'F': 2}\n\n    [/EXAMPLES]\n    \"\"\"\n```\n", "entry_point": "analyze_social_network", "solution": "from typing import List, Dict, Tuple\nfrom collections import defaultdict\nfrom typing import List, Dict\n\ndef analyze_social_network(connections: List[Tuple[str, str]]) -> Dict[str, int]:\n    \"\"\"\n    Analyzes a social network to determine the influence of each user.\n\n    This function takes a list of connections between users in a social network and calculates\n    the influence score for each user based on their number of connections. It utilizes graph\n    representation and dictionary manipulation to process the network data.\n\n    Args:\n        connections (List[Tuple[str, str]]): A list of tuples representing connections between users.\n\n    Returns:\n        Dict[str, int]: A dictionary mapping each user to their influence score.\n\n\n    [EXAMPLES]\n    \n    assert candidate([(\"A\", \"B\")]) == {'A': 1, 'B': 1}\n    assert candidate([(\"A\", \"B\"), (\"B\", \"C\"), (\"C\", \"A\"), (\"D\", \"E\"), (\"E\", \"F\"), (\"F\", \"D\")]) == {'A': 2, 'B': 2, 'C': 2, 'D': 2, 'E': 2, 'F': 2}\n\n    [/EXAMPLES]\n    \"\"\"\n    # Create a defaultdict to store the graph representation\n    graph = defaultdict(set)\n    \n    # Build the graph\n    for user1, user2 in connections:\n        graph[user1].add(user2)\n        graph[user2].add(user1)\n    \n    # Calculate influence scores\n    influence_scores = {}\n    for user in graph:\n        influence_scores[user] = len(graph[user])\n    \n    return influence_scores\n\n", "test": "def check(candidate):\n    assert candidate([(\"X\", \"X\")]) == {'X': 1}\n    assert candidate([(\"A\", \"B\"), (\"B\", \"C\"), (\"C\", \"A\"), (\"D\", \"E\"), (\"E\", \"F\"), (\"F\", \"D\")]) == {'A': 2, 'B': 2, 'C': 2, 'D': 2, 'E': 2, 'F': 2}\n    assert candidate([(\"A\", \"B\")]) == {'A': 1, 'B': 1}\n    assert candidate([(\"Hub\", \"Spoke\" + str(i)) for i in range(100)]) == {'Hub': 100, 'Spoke0': 1, 'Spoke1': 1, 'Spoke2': 1, 'Spoke3': 1, 'Spoke4': 1, 'Spoke5': 1, 'Spoke6': 1, 'Spoke7': 1, 'Spoke8': 1, 'Spoke9': 1, 'Spoke10': 1, 'Spoke11': 1, 'Spoke12': 1, 'Spoke13': 1, 'Spoke14': 1, 'Spoke15': 1, 'Spoke16': 1, 'Spoke17': 1, 'Spoke18': 1, 'Spoke19': 1, 'Spoke20': 1, 'Spoke21': 1, 'Spoke22': 1, 'Spoke23': 1, 'Spoke24': 1, 'Spoke25': 1, 'Spoke26': 1, 'Spoke27': 1, 'Spoke28': 1, 'Spoke29': 1, 'Spoke30': 1, 'Spoke31': 1, 'Spoke32': 1, 'Spoke33': 1, 'Spoke34': 1, 'Spoke35': 1, 'Spoke36': 1, 'Spoke37': 1, 'Spoke38': 1, 'Spoke39': 1, 'Spoke40': 1, 'Spoke41': 1, 'Spoke42': 1, 'Spoke43': 1, 'Spoke44': 1, 'Spoke45': 1, 'Spoke46': 1, 'Spoke47': 1, 'Spoke48': 1, 'Spoke49': 1, 'Spoke50': 1, 'Spoke51': 1, 'Spoke52': 1, 'Spoke53': 1, 'Spoke54': 1, 'Spoke55': 1, 'Spoke56': 1, 'Spoke57': 1, 'Spoke58': 1, 'Spoke59': 1, 'Spoke60': 1, 'Spoke61': 1, 'Spoke62': 1, 'Spoke63': 1, 'Spoke64': 1, 'Spoke65': 1, 'Spoke66': 1, 'Spoke67': 1, 'Spoke68': 1, 'Spoke69': 1, 'Spoke70': 1, 'Spoke71': 1, 'Spoke72': 1, 'Spoke73': 1, 'Spoke74': 1, 'Spoke75': 1, 'Spoke76': 1, 'Spoke77': 1, 'Spoke78': 1, 'Spoke79': 1, 'Spoke80': 1, 'Spoke81': 1, 'Spoke82': 1, 'Spoke83': 1, 'Spoke84': 1, 'Spoke85': 1, 'Spoke86': 1, 'Spoke87': 1, 'Spoke88': 1, 'Spoke89': 1, 'Spoke90': 1, 'Spoke91': 1, 'Spoke92': 1, 'Spoke93': 1, 'Spoke94': 1, 'Spoke95': 1, 'Spoke96': 1, 'Spoke97': 1, 'Spoke98': 1, 'Spoke99': 1}\n    assert candidate([(\"User1\", \"User2\"), (\"User2\", \"User3\"), (\"User3\", \"User4\"), (\"User4\", \"User1\")]) == {'User1': 2, 'User2': 2, 'User3': 2, 'User4': 2}\n    assert candidate([(\"Alice\", \"Bob\"), (\"Bob\", \"Charlie\"), (\"Alice\", \"David\"), (\"Eve\", \"Alice\")]) == {'Alice': 3, 'Bob': 2, 'Charlie': 1, 'David': 1, 'Eve': 1}\n    assert candidate([(\"A\", \"B\"), (\"B\", \"C\"), (\"C\", \"D\"), (\"D\", \"E\"), (\"E\", \"A\"), (\"A\", \"C\"), (\"B\", \"D\"), (\"C\", \"E\")]) == {'A': 3, 'B': 3, 'C': 4, 'D': 3, 'E': 3}\n    assert candidate([(\"X\", \"Y\")] + [(\"Y\", str(i)) for i in range(50)]) == {'X': 1, 'Y': 51, '0': 1, '1': 1, '2': 1, '3': 1, '4': 1, '5': 1, '6': 1, '7': 1, '8': 1, '9': 1, '10': 1, '11': 1, '12': 1, '13': 1, '14': 1, '15': 1, '16': 1, '17': 1, '18': 1, '19': 1, '20': 1, '21': 1, '22': 1, '23': 1, '24': 1, '25': 1, '26': 1, '27': 1, '28': 1, '29': 1, '30': 1, '31': 1, '32': 1, '33': 1, '34': 1, '35': 1, '36': 1, '37': 1, '38': 1, '39': 1, '40': 1, '41': 1, '42': 1, '43': 1, '44': 1, '45': 1, '46': 1, '47': 1, '48': 1, '49': 1}\n    assert candidate([(\"X\", \"Y\"), (\"Y\", \"Z\"), (\"Z\", \"X\"), (\"X\", \"W\"), (\"W\", \"V\"), (\"V\", \"U\"), (\"U\", \"X\")]) == {'X': 4, 'Y': 2, 'Z': 2, 'W': 2, 'V': 2, 'U': 2}\n    assert candidate([(\"A\", \"B\"), (\"B\", \"C\"), (\"C\", \"D\"), (\"D\", \"E\"), (\"E\", \"A\"), (\"A\", \"C\"), (\"C\", \"E\"), (\"E\", \"B\"), (\"B\", \"D\"), (\"D\", \"A\")]) == {'A': 4, 'B': 4, 'C': 4, 'D': 4, 'E': 4}\n", "language": "python"}
{"task_id": "f245fc6f-664e-4f84-8045-eb715c1505f3-205066719700961157", "prompt": "Based on the doc string, finish the remaining part of the function. Present the complete function in one code block.\n\n```python\ndef create_unit_converter(conversion_factor: float) -> callable:\n    \"\"\"\n    In a scientific laboratory, we need to create flexible unit converters for various measurements.\n    This function creates a unit converter based on a given conversion factor.\n\n    The function takes one parameter:\n    - conversion_factor: The factor to multiply the input value by for conversion\n\n    It returns a function that takes a value as input and returns the converted value.\n    Use closures to maintain the conversion factor for each converter.\n\n\n    [EXAMPLES]\n    \n    assert candidate(0.0174533)(90) == 1.5707970000000002\n    assert candidate(3.28084)(10) == 32.8084\n\n    [/EXAMPLES]\n    \"\"\"\n```\n", "entry_point": "create_unit_converter", "solution": "def create_unit_converter(conversion_factor: float) -> callable:\n    \"\"\"\n    In a scientific laboratory, we need to create flexible unit converters for various measurements.\n    This function creates a unit converter based on a given conversion factor.\n\n    The function takes one parameter:\n    - conversion_factor: The factor to multiply the input value by for conversion\n\n    It returns a function that takes a value as input and returns the converted value.\n    Use closures to maintain the conversion factor for each converter.\n\n\n    [EXAMPLES]\n    \n    assert candidate(0.0174533)(90) == 1.5707970000000002\n    assert candidate(3.28084)(10) == 32.8084\n\n    [/EXAMPLES]\n    \"\"\"\n    def converter(value: float) -> float:\n        return value * conversion_factor\n    \n    return converter\n\n", "test": "def check(candidate):\n    assert candidate(1.8)(0) == 0.0\n    assert candidate(9.80665)(1) == 9.80665\n    assert candidate(3.28084)(10) == 32.8084\n    assert candidate(0.0174533)(90) == 1.5707970000000002\n", "language": "python"}
{"task_id": "c44d4289-fc96-4403-b898-186706b2a46b-3708889814600949844", "prompt": "Based on the provided docstring, I'll write the complete function implementation in one code block.\n\n```python\ndef decode_alien_message(encoded: str) -> int:\n    \"\"\"\n    An alien civilization has sent us an encoded message consisting of digits.\n    Each digit or pair of digits represents a letter in their alphabet.\n    Our task is to determine the total number of possible decodings of the message.\n\n    Rules for decoding:\n    1. A single digit can always be decoded (1-9 map to A-I).\n    2. Two digits can be decoded if they form a number from 10 to 26 (mapping to J-Z).\n\n    Use dynamic programming to solve this problem efficiently.\n\n    Parameters:\n    encoded (str): The encoded alien message consisting of digits\n\n    Returns:\n    int: The total number of possible decodings\n\n\n    [EXAMPLES]\n    \n    assert candidate(\"1234\") == 3\n    assert candidate(\"301\") == 0\n\n    [/EXAMPLES]\n    \"\"\"\n```\n", "entry_point": "decode_alien_message", "solution": "def decode_alien_message(encoded: str) -> int:\n    \"\"\"\n    An alien civilization has sent us an encoded message consisting of digits.\n    Each digit or pair of digits represents a letter in their alphabet.\n    Our task is to determine the total number of possible decodings of the message.\n\n    Rules for decoding:\n    1. A single digit can always be decoded (1-9 map to A-I).\n    2. Two digits can be decoded if they form a number from 10 to 26 (mapping to J-Z).\n\n    Use dynamic programming to solve this problem efficiently.\n\n    Parameters:\n    encoded (str): The encoded alien message consisting of digits\n\n    Returns:\n    int: The total number of possible decodings\n\n\n    [EXAMPLES]\n    \n    assert candidate(\"1234\") == 3\n    assert candidate(\"301\") == 0\n\n    [/EXAMPLES]\n    \"\"\"\n    if not encoded or encoded[0] == '0':\n        return 0\n\n    n = len(encoded)\n    dp = [0] * (n + 1)\n    dp[0] = 1\n    dp[1] = 1\n\n    for i in range(2, n + 1):\n        # Check if the current digit can be decoded (not zero)\n        if encoded[i-1] != '0':\n            dp[i] += dp[i-1]\n        \n        # Check if the last two digits can be decoded as a letter\n        two_digit = int(encoded[i-2:i])\n        if 10 <= two_digit <= 26:\n            dp[i] += dp[i-2]\n\n    return dp[n]\n\n", "test": "def check(candidate):\n    assert candidate(\"2626\") == 4\n    assert candidate(\"230\") == 0\n    assert candidate(\"10\") == 1\n    assert candidate(\"1234\") == 3\n    assert candidate(\"101\") == 1\n    assert candidate(\"06\") == 0\n    assert candidate(\"9999\") == 1\n    assert candidate(\"11111\") == 8\n    assert candidate(\"301\") == 0\n    assert candidate(\"12345678\") == 3\n", "language": "python"}
{"task_id": "2beaa28e-256f-400d-8560-834ff817971f-8671679558882336936", "prompt": "Let me finish writing this function based on its docstring. I'll provide the complete implementation in one code block while accounting for all potential edge cases.\n\n```python\nfrom typing import List\n\ndef calculate_rainfall_deficit(monthly_rainfall: List[float], annual_average: float) -> float:\n    \"\"\"\n    Calculate the rainfall deficit for a region based on monthly rainfall data and annual average.\n\n    This function takes a list of monthly rainfall amounts and the expected annual average,\n    then calculates the total deficit or surplus for the year. It utilizes list comprehension\n    and conditional expressions to perform the calculation.\n\n    Args:\n    monthly_rainfall (List[float]): A list of 12 float values representing monthly rainfall in mm.\n    annual_average (float): The expected annual average rainfall in mm.\n\n    Returns:\n    float: The rainfall deficit (negative) or surplus (positive) in mm.\n\n\n    [EXAMPLES]\n    \n    assert candidate([0.5, 1.0, 1.5, 2.0, 2.5, 3.0, 3.5, 4.0, 4.5, 5.0, 5.5, 6.0], 50.0) == -11.0\n    assert candidate([50.0, 60.0, 70.0, 80.0, 90.0, 100.0, 110.0, 120.0, 130.0, 140.0, 150.0, 160.0], 1500.0) == -240.0\n\n    [/EXAMPLES]\n    \"\"\"\n```\n", "entry_point": "calculate_rainfall_deficit", "solution": "from typing import List\n\ndef calculate_rainfall_deficit(monthly_rainfall: List[float], annual_average: float) -> float:\n    \"\"\"\n    Calculate the rainfall deficit for a region based on monthly rainfall data and annual average.\n\n    This function takes a list of monthly rainfall amounts and the expected annual average,\n    then calculates the total deficit or surplus for the year. It utilizes list comprehension\n    and conditional expressions to perform the calculation.\n\n    Args:\n    monthly_rainfall (List[float]): A list of 12 float values representing monthly rainfall in mm.\n    annual_average (float): The expected annual average rainfall in mm.\n\n    Returns:\n    float: The rainfall deficit (negative) or surplus (positive) in mm.\n\n\n    [EXAMPLES]\n    \n    assert candidate([0.5, 1.0, 1.5, 2.0, 2.5, 3.0, 3.5, 4.0, 4.5, 5.0, 5.5, 6.0], 50.0) == -11.0\n    assert candidate([50.0, 60.0, 70.0, 80.0, 90.0, 100.0, 110.0, 120.0, 130.0, 140.0, 150.0, 160.0], 1500.0) == -240.0\n\n    [/EXAMPLES]\n    \"\"\"\n    # Calculate the total annual rainfall from the monthly data\n    total_rainfall = sum(monthly_rainfall)\n    \n    # Calculate the deficit or surplus\n    deficit = total_rainfall - annual_average\n    \n    # Round the result to one decimal place\n    return round(deficit, 1)\n\n", "test": "def check(candidate):\n    assert candidate([150.0, 140.0, 130.0, 120.0, 110.0, 100.0, 90.0, 80.0, 70.0, 60.0, 50.0, 40.0], 1500.0) == -360.0\n    assert candidate([100.0, 120.0, 140.0, 160.0, 180.0, 200.0, 220.0, 240.0, 260.0, 280.0, 300.0, 320.0], 2000.0) == 520.0\n    assert candidate([50.0, 60.0, 70.0, 80.0, 90.0, 100.0, 110.0, 120.0, 130.0, 140.0, 150.0, 160.0], 1500.0) == -240.0\n    assert candidate([0.5, 1.0, 1.5, 2.0, 2.5, 3.0, 3.5, 4.0, 4.5, 5.0, 5.5, 6.0], 50.0) == -11.0\n    assert candidate([83.5, 75.2, 91.8, 102.3, 88.7, 79.6, 95.4, 110.1, 87.9, 93.2, 81.5, 97.8], 1200.0) == -113.0\n    assert candidate([10.5, 15.2, 20.8, 25.3, 30.7, 35.6, 40.4, 45.1, 50.9, 55.2, 60.5, 65.8], 500.0) == -44.0\n    assert candidate([0.1, 0.2, 0.3, 0.4, 0.5, 0.6, 0.7, 0.8, 0.9, 1.0, 1.1, 1.2], 10.0) == -2.2\n    assert candidate([50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0], 600.0) == 0.0\n    assert candidate([200.0, 180.0, 160.0, 140.0, 120.0, 100.0, 80.0, 60.0, 40.0, 20.0, 10.0, 5.0], 1500.0) == -385.0\n    assert candidate([200.0, 190.0, 180.0, 170.0, 160.0, 150.0, 140.0, 130.0, 120.0, 110.0, 100.0, 90.0], 2000.0) == -260.0\n", "language": "python"}
{"task_id": "036320ab-f5dc-4bce-ad7e-8be6091358c67232135253824447625", "prompt": "Acting as your code implementation assistant, I'll provide a complete solution for the requested function that's immediately executable. All helper functions or classes will be nested within the main function, and I'll only use libraries that are already imported.\n\n```python\nfrom typing import List, Tuple\n\ndef optimize_knapsack(items: List[Tuple[str, int, int]], capacity: int) -> Tuple[int, List[str]]:\n    \"\"\"\n    Solve the 0/1 Knapsack problem to maximize the value of items that can be carried in a knapsack with a given capacity.\n    Each item has a name, weight, and value. The function should return the maximum total value and the list of selected items.\n    Use dynamic programming to solve this problem efficiently.\n\n\n    [EXAMPLES]\n    \n    assert candidate([(\"Heavy\", 10, 100), (\"Light\", 1, 1)], 9) == (1, ['Light'])\n    assert candidate([(\"Valuable\", 1, 1000), (\"Worthless\", 1, 0)], 1) == (1000, ['Valuable'])\n\n    [/EXAMPLES]\n    \"\"\"\n```\n", "entry_point": "optimize_knapsack", "solution": "from typing import List, Tuple\n\ndef optimize_knapsack(items: List[Tuple[str, int, int]], capacity: int) -> Tuple[int, List[str]]:\n    \"\"\"\n    Solve the 0/1 Knapsack problem to maximize the value of items that can be carried in a knapsack with a given capacity.\n    Each item has a name, weight, and value. The function should return the maximum total value and the list of selected items.\n    Use dynamic programming to solve this problem efficiently.\n\n\n    [EXAMPLES]\n    \n    assert candidate([(\"Heavy\", 10, 100), (\"Light\", 1, 1)], 9) == (1, ['Light'])\n    assert candidate([(\"Valuable\", 1, 1000), (\"Worthless\", 1, 0)], 1) == (1000, ['Valuable'])\n\n    [/EXAMPLES]\n    \"\"\"\n    n = len(items)\n    \n    # Create a 2D table for dynamic programming\n    dp = [[0 for _ in range(capacity + 1)] for _ in range(n + 1)]\n    \n    # Fill the dp table\n    for i in range(1, n + 1):\n        for w in range(capacity + 1):\n            if items[i-1][1] <= w:\n                dp[i][w] = max(dp[i-1][w], dp[i-1][w-items[i-1][1]] + items[i-1][2])\n            else:\n                dp[i][w] = dp[i-1][w]\n    \n    # Backtrack to find the selected items\n    selected_items = []\n    i, w = n, capacity\n    while i > 0 and w > 0:\n        if dp[i][w] != dp[i-1][w]:\n            selected_items.append(items[i-1][0])\n            w -= items[i-1][1]\n        i -= 1\n    \n    # Reverse the list to get items in original order\n    selected_items.reverse()\n    \n    return (dp[n][capacity], selected_items)\n\n", "test": "def check(candidate):\n    assert candidate([(\"X\", 2, 3), (\"Y\", 3, 4), (\"Z\", 4, 5), (\"W\", 5, 6)], 9) == (12, ['X', 'Y', 'Z'])\n    assert candidate([(\"Valuable\", 1, 1000), (\"Worthless\", 1, 0)], 1) == (1000, ['Valuable'])\n    assert candidate([(\"X\", 1, 1), (\"Y\", 2, 2), (\"Z\", 3, 3)], 3) == (3, ['X', 'Y'])\n    assert candidate([(\"Item\" + str(i), i, i*10) for i in range(1, 11)], 25) == (250, ['Item1', 'Item2', 'Item4', 'Item5', 'Item6', 'Item7'])\n    assert candidate([(\"A\", 2, 10), (\"B\", 3, 15), (\"C\", 5, 25), (\"D\", 7, 35)], 10) == (50, ['A', 'B', 'C'])\n    assert candidate([(\"A\", 1, 1)], 1) == (1, ['A'])\n    assert candidate([(\"Item1\", 10, 60), (\"Item2\", 20, 100), (\"Item3\", 30, 120)], 50) == (220, ['Item2', 'Item3'])\n    assert candidate([(\"Heavy1\", 100, 1), (\"Heavy2\", 100, 2), (\"Light\", 1, 100)], 100) == (100, ['Light'])\n    assert candidate([(\"Heavy\", 10, 100), (\"Light\", 1, 1)], 9) == (1, ['Light'])\n    assert candidate([], 5) == (0, [])\n", "language": "python"}
{"task_id": "e91007e1-5712-497e-8581-b9f0534206fe-5322356564762958484", "prompt": "As a coding assistant, I'm here to complete functions that are ready to execute. I'll provide the code within the function scope you provide, utilizing only imported libraries. Any helper functions or classes will be defined inside your main function to ensure everything works correctly.\n\n```python\nimport heapq\nfrom typing import List, Tuple\n\ndef minimum_spanning_tree(nodes: int, edges: List[Tuple[int, int, int]]) -> List[Tuple[int, int, int]]:\n    \"\"\"\n    You are an urban planner designing a new city's infrastructure. Given a set of potential road connections between districts and their associated costs, your task is to determine the minimum spanning tree (MST) that connects all districts while minimizing the total cost.\n\n    Implement Prim's algorithm using a priority queue to find the minimum spanning tree of the given graph. The graph is represented as an undirected weighted graph.\n\n    :param nodes: The number of districts (nodes) in the city\n    :param edges: A list of tuples (u, v, w) where u and v are district indices and w is the cost of building a road between them\n    :return: A list of tuples representing the edges in the minimum spanning tree\n\n\n    [EXAMPLES]\n    \n    assert candidate(2, [(0, 1, 5)]) == [(0, 1, 5)]\n    assert candidate(3, [(0, 1, 1), (1, 2, 2), (0, 2, 3)]) == [(0, 1, 1), (1, 2, 2)]\n\n    [/EXAMPLES]\n    \"\"\"\n```\n", "entry_point": "minimum_spanning_tree", "solution": "import heapq\nfrom typing import List, Tuple\n\ndef minimum_spanning_tree(nodes: int, edges: List[Tuple[int, int, int]]) -> List[Tuple[int, int, int]]:\n    \"\"\"\n    You are an urban planner designing a new city's infrastructure. Given a set of potential road connections between districts and their associated costs, your task is to determine the minimum spanning tree (MST) that connects all districts while minimizing the total cost.\n\n    Implement Prim's algorithm using a priority queue to find the minimum spanning tree of the given graph. The graph is represented as an undirected weighted graph.\n\n    :param nodes: The number of districts (nodes) in the city\n    :param edges: A list of tuples (u, v, w) where u and v are district indices and w is the cost of building a road between them\n    :return: A list of tuples representing the edges in the minimum spanning tree\n\n\n    [EXAMPLES]\n    \n    assert candidate(2, [(0, 1, 5)]) == [(0, 1, 5)]\n    assert candidate(3, [(0, 1, 1), (1, 2, 2), (0, 2, 3)]) == [(0, 1, 1), (1, 2, 2)]\n\n    [/EXAMPLES]\n    \"\"\"\n    # Create an adjacency list representation of the graph\n    graph = [[] for _ in range(nodes)]\n    for u, v, w in edges:\n        graph[u].append((v, w))\n        graph[v].append((u, w))\n    \n    # Initialize data structures\n    mst = []\n    visited = [False] * nodes\n    min_heap = [(0, 0, -1)]  # (weight, node, parent)\n    \n    while min_heap and len(mst) < nodes - 1:\n        weight, node, parent = heapq.heappop(min_heap)\n        \n        if visited[node]:\n            continue\n        \n        visited[node] = True\n        \n        if parent != -1:\n            mst.append((parent, node, weight))\n        \n        for neighbor, edge_weight in graph[node]:\n            if not visited[neighbor]:\n                heapq.heappush(min_heap, (edge_weight, neighbor, node))\n    \n    return mst\n\n\n", "test": "def check(candidate):\n    assert candidate(5, [(0, 1, 10), (0, 2, 20), (0, 3, 30), (0, 4, 40), (1, 2, 50), (1, 3, 60), (1, 4, 70), (2, 3, 80), (2, 4, 90), (3, 4, 100)]) == [(0, 1, 10), (0, 2, 20), (0, 3, 30), (0, 4, 40)]\n    assert candidate(4, [(0, 1, 1), (0, 2, 2), (0, 3, 3), (1, 2, 4), (1, 3, 5), (2, 3, 6)]) == [(0, 1, 1), (0, 2, 2), (0, 3, 3)]\n    assert candidate(5, [(0, 1, 2), (0, 3, 6), (1, 2, 3), (1, 3, 8), (1, 4, 5), (2, 4, 7), (3, 4, 9)]) == [(0, 1, 2), (1, 2, 3), (1, 4, 5), (0, 3, 6)]\n    assert candidate(3, [(0, 1, 1), (1, 2, 2), (0, 2, 3)]) == [(0, 1, 1), (1, 2, 2)]\n    assert candidate(6, [(0, 1, 1), (1, 2, 1), (2, 3, 1), (3, 4, 1), (4, 5, 1), (5, 0, 1)]) == [(0, 1, 1), (1, 2, 1), (2, 3, 1), (3, 4, 1), (0, 5, 1)]\n    assert candidate(5, [(0, 1, 1), (1, 2, 2), (2, 3, 3), (3, 4, 4), (0, 4, 5), (0, 2, 6), (1, 3, 7), (1, 4, 8), (0, 3, 9)]) == [(0, 1, 1), (1, 2, 2), (2, 3, 3), (3, 4, 4)]\n    assert candidate(1, []) == []\n    assert candidate(2, [(0, 1, 5)]) == [(0, 1, 5)]\n    assert candidate(5, [(0, 1, 1), (1, 2, 2), (2, 3, 3), (3, 4, 4), (4, 0, 5)]) == [(0, 1, 1), (1, 2, 2), (2, 3, 3), (3, 4, 4)]\n    assert candidate(4, [(0, 1, 10), (0, 2, 6), (0, 3, 5), (1, 2, 4), (2, 3, 4)]) == [(0, 3, 5), (3, 2, 4), (2, 1, 4)]\n", "language": "python"}
{"task_id": "30084dff-0ced-48e2-858b-5d4dc221c943-8656611383410083143", "prompt": "Please complete the provided function in a single code block. Make sure the function is executable as is, without any code outside of it. Only use the libraries that are already imported in the problem. If you need additional functions or classes, define them within the main function. I'll provide just one code block with the solution.\n\n```python\nfrom typing import List, Tuple, Dict\nimport itertools\nfrom collections import deque\nfrom typing import List\nfrom collections import defaultdict, deque\n\ndef social_network_analysis(connections: List[Tuple[str, str]], target_user: str) -> Dict[str, int]:\n    \"\"\"\n    Analyze the social network of a target user to determine their degree of connection with other users.\n    This function uses graph theory concepts to calculate the shortest path between the target user and all other users.\n\n    Args:\n    connections (List[Tuple[str, str]]): A list of tuples representing connections between users\n    target_user (str): The user for whom we want to analyze the network\n\n    Returns:\n    Dict[str, int]: A dictionary with users as keys and their degree of connection to the target user as values\n\n\n    [EXAMPLES]\n    \n    assert candidate([(\"1\", \"2\"), (\"2\", \"3\"), (\"3\", \"4\"), (\"4\", \"5\"), (\"5\", \"6\"), (\"6\", \"1\")], \"4\") == {'3': 1, '5': 1, '2': 2, '6': 2, '1': 3}\n    assert candidate([(\"A\", \"B\"), (\"B\", \"C\"), (\"C\", \"D\"), (\"D\", \"E\")], \"A\") == {'B': 1, 'C': 2, 'D': 3, 'E': 4}\n\n    [/EXAMPLES]\n    \"\"\"\n```\n", "entry_point": "social_network_analysis", "solution": "from typing import List, Tuple, Dict\nimport itertools\nfrom collections import deque\nfrom typing import List\nfrom collections import defaultdict, deque\n\ndef social_network_analysis(connections: List[Tuple[str, str]], target_user: str) -> Dict[str, int]:\n    \"\"\"\n    Analyze the social network of a target user to determine their degree of connection with other users.\n    This function uses graph theory concepts to calculate the shortest path between the target user and all other users.\n\n    Args:\n    connections (List[Tuple[str, str]]): A list of tuples representing connections between users\n    target_user (str): The user for whom we want to analyze the network\n\n    Returns:\n    Dict[str, int]: A dictionary with users as keys and their degree of connection to the target user as values\n\n\n    [EXAMPLES]\n    \n    assert candidate([(\"1\", \"2\"), (\"2\", \"3\"), (\"3\", \"4\"), (\"4\", \"5\"), (\"5\", \"6\"), (\"6\", \"1\")], \"4\") == {'3': 1, '5': 1, '2': 2, '6': 2, '1': 3}\n    assert candidate([(\"A\", \"B\"), (\"B\", \"C\"), (\"C\", \"D\"), (\"D\", \"E\")], \"A\") == {'B': 1, 'C': 2, 'D': 3, 'E': 4}\n\n    [/EXAMPLES]\n    \"\"\"\n    # Create an adjacency list to represent the graph\n    graph = defaultdict(list)\n    for u, v in connections:\n        graph[u].append(v)\n        graph[v].append(u)  # Assuming undirected connections\n\n    # Perform BFS to find shortest paths\n    queue = deque([(target_user, 0)])\n    visited = {target_user: 0}\n\n    while queue:\n        current_user, distance = queue.popleft()\n        for neighbor in graph[current_user]:\n            if neighbor not in visited:\n                visited[neighbor] = distance + 1\n                queue.append((neighbor, distance + 1))\n\n    # Remove the target user from the result\n    del visited[target_user]\n\n    return dict(visited)\n\n", "test": "def check(candidate):\n    assert candidate([(\"Start\", \"Middle\"), (\"Middle\", \"End\")], \"Start\") == {'Middle': 1, 'End': 2}\n    assert candidate([(\"1\", \"2\"), (\"2\", \"3\"), (\"3\", \"4\"), (\"4\", \"5\"), (\"5\", \"1\")], \"3\") == {'2': 1, '4': 1, '1': 2, '5': 2}\n    assert candidate([(\"First\", \"Second\"), (\"Second\", \"Third\"), (\"Third\", \"Fourth\"), (\"Fourth\", \"Fifth\")], \"Third\") == {'Second': 1, 'Fourth': 1, 'First': 2, 'Fifth': 2}\n    assert candidate([(\"A\", \"B\"), (\"B\", \"C\"), (\"A\", \"C\")], \"B\") == {'C': 1, 'A': 1}\n    assert candidate([(\"A\", \"B\"), (\"B\", \"C\"), (\"C\", \"D\"), (\"D\", \"E\"), (\"E\", \"F\"), (\"F\", \"A\")], \"D\") == {'C': 1, 'E': 1, 'B': 2, 'F': 2, 'A': 3}\n    assert candidate([(\"A\", \"B\"), (\"B\", \"C\"), (\"C\", \"D\"), (\"D\", \"A\")], \"B\") == {'A': 1, 'C': 1, 'D': 2}\n    assert candidate([(\"1\", \"2\"), (\"2\", \"3\"), (\"3\", \"4\"), (\"4\", \"5\"), (\"5\", \"1\")], \"3\") == {'4': 1, '2': 1, '5': 2, '1': 2}\n    assert candidate([(\"First\", \"Second\"), (\"Second\", \"Third\"), (\"Third\", \"Fourth\"), (\"Fourth\", \"Fifth\")], \"Third\") == {'Fourth': 1, 'Second': 1, 'Fifth': 2, 'First': 2}\n    assert candidate([(\"1\", \"2\"), (\"2\", \"3\"), (\"3\", \"4\"), (\"4\", \"5\"), (\"5\", \"6\"), (\"6\", \"1\")], \"4\") == {'3': 1, '5': 1, '2': 2, '6': 2, '1': 3}\n    assert candidate([(\"A\", \"B\"), (\"B\", \"C\"), (\"C\", \"D\"), (\"D\", \"E\")], \"A\") == {'B': 1, 'C': 2, 'D': 3, 'E': 4}\n", "language": "python"}
{"task_id": "cb0b866d-b9fa-44e4-b984-5999b93d1188-2044526675772456653", "prompt": "Please complete the function provided in the problem, ensuring it's executable as-is within a single code block. I'll only use the libraries that are already imported. If needed, I'll define helper functions or classes inside the main function. My response will contain exactly one code block with the complete implementation.\n\n```python\ndef calculate_water_bill(consumption: int) -> float:\n    \"\"\"\n    A water utility company needs to calculate bills based on water consumption.\n\n    This function calculates the water bill for a household based on their monthly water consumption in cubic meters.\n    The billing structure is as follows:\n    - First 10 cubic meters: $1 per cubic meter\n    - Next 20 cubic meters: $1.5 per cubic meter\n    - Next 30 cubic meters: $2 per cubic meter\n    - Above 60 cubic meters: $3 per cubic meter\n\n    Args:\n    consumption (int): The amount of water consumed in cubic meters.\n\n    Returns:\n    float: The total water bill in dollars, rounded to two decimal places.\n\n\n    [EXAMPLES]\n    \n    assert candidate(15) == 17.5\n    assert candidate(20) == 25.0\n\n    [/EXAMPLES]\n    \"\"\"\n```\n", "entry_point": "calculate_water_bill", "solution": "def calculate_water_bill(consumption: int) -> float:\n    \"\"\"\n    A water utility company needs to calculate bills based on water consumption.\n\n    This function calculates the water bill for a household based on their monthly water consumption in cubic meters.\n    The billing structure is as follows:\n    - First 10 cubic meters: $1 per cubic meter\n    - Next 20 cubic meters: $1.5 per cubic meter\n    - Next 30 cubic meters: $2 per cubic meter\n    - Above 60 cubic meters: $3 per cubic meter\n\n    Args:\n    consumption (int): The amount of water consumed in cubic meters.\n\n    Returns:\n    float: The total water bill in dollars, rounded to two decimal places.\n\n\n    [EXAMPLES]\n    \n    assert candidate(15) == 17.5\n    assert candidate(20) == 25.0\n\n    [/EXAMPLES]\n    \"\"\"\n    bill = 0.0\n\n    if consumption <= 10:\n        bill = consumption * 1.0\n    elif consumption <= 30:\n        bill = 10 * 1.0 + (consumption - 10) * 1.5\n    elif consumption <= 60:\n        bill = 10 * 1.0 + 20 * 1.5 + (consumption - 30) * 2.0\n    else:\n        bill = 10 * 1.0 + 20 * 1.5 + 30 * 2.0 + (consumption - 60) * 3.0\n\n    return round(bill, 2)\n\n", "test": "def check(candidate):\n    assert candidate(20) == 25.0\n    assert candidate(61) == 103.0\n    assert candidate(200) == 520.0\n    assert candidate(60) == 100.0\n    assert candidate(5) == 5.0\n    assert candidate(0) == 0\n    assert candidate(40) == 60.0\n    assert candidate(150) == 370.0\n    assert candidate(15) == 17.5\n    assert candidate(1000) == 2920.0\n", "language": "python"}
{"task_id": "adc1b3e0-047d-4c86-91fc-f7b79c12aa309123956673699335132", "prompt": "I'm a coding assistant here to complete functions you provide. I'll ensure the completed code can be directly executed, using only imported libraries from the problem statement. Any helper functions or classes I create will be defined within the main function. Please share your function to complete.\n\n```python\nfrom typing import List, Tuple\n\ndef solve_tower_of_hanoi(n: int) -> List[Tuple[int, int]]:\n    \"\"\"You are creating a simulation of the Tower of Hanoi puzzle for a virtual reality game. \n    Implement a function that solves the Tower of Hanoi problem and returns a list of moves.\n\n    The Tower of Hanoi consists of three rods (numbered 1, 2, and 3) and n disks of different sizes \n    which can slide onto any rod. The puzzle starts with all disks stacked on rod 1 in order of \n    decreasing size, with the smallest at the top.\n\n    The objective is to move the entire stack to rod 3, obeying the following rules:\n    1. Only one disk can be moved at a time.\n    2. Each move consists of taking the upper disk from one of the stacks and placing it on top \n       of another stack or on an empty rod.\n    3. No larger disk may be placed on top of a smaller disk.\n\n    Return a list of tuples, where each tuple (a, b) represents moving a disk from rod a to rod b.\n\n\n    [EXAMPLES]\n    \n    assert candidate(5) == [(1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3)]\n    assert candidate(1) == [(1, 3)]\n\n    [/EXAMPLES]\n    \"\"\"\n```\n", "entry_point": "solve_tower_of_hanoi", "solution": "from typing import List, Tuple\n\ndef solve_tower_of_hanoi(n: int) -> List[Tuple[int, int]]:\n    \"\"\"You are creating a simulation of the Tower of Hanoi puzzle for a virtual reality game. \n    Implement a function that solves the Tower of Hanoi problem and returns a list of moves.\n\n    The Tower of Hanoi consists of three rods (numbered 1, 2, and 3) and n disks of different sizes \n    which can slide onto any rod. The puzzle starts with all disks stacked on rod 1 in order of \n    decreasing size, with the smallest at the top.\n\n    The objective is to move the entire stack to rod 3, obeying the following rules:\n    1. Only one disk can be moved at a time.\n    2. Each move consists of taking the upper disk from one of the stacks and placing it on top \n       of another stack or on an empty rod.\n    3. No larger disk may be placed on top of a smaller disk.\n\n    Return a list of tuples, where each tuple (a, b) represents moving a disk from rod a to rod b.\n\n\n    [EXAMPLES]\n    \n    assert candidate(5) == [(1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3)]\n    assert candidate(1) == [(1, 3)]\n\n    [/EXAMPLES]\n    \"\"\"\n    def move_tower(height, source, destination, auxiliary):\n        if height >= 1:\n            # Move n-1 disks from source to auxiliary\n            move_tower(height - 1, source, auxiliary, destination)\n            \n            # Move the nth disk from source to destination\n            moves.append((source, destination))\n            \n            # Move n-1 disks from auxiliary to destination\n            move_tower(height - 1, auxiliary, destination, source)\n\n    moves = []\n    move_tower(n, 1, 3, 2)\n    return moves\n\n", "test": "def check(candidate):\n    assert candidate(5) == [(1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3)]\n    assert candidate(11) == [(1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3)]\n    assert candidate(2) == [(1, 2), (1, 3), (2, 3)]\n    assert candidate(8) == [(1, 2), (1, 3), (2, 3), (1, 2), (3, 1), (3, 2), (1, 2), (1, 3), (2, 3), (2, 1), (3, 1), (2, 3), (1, 2), (1, 3), (2, 3), (1, 2), (3, 1), (3, 2), (1, 2), (3, 1), (2, 3), (2, 1), (3, 1), (3, 2), (1, 2), (1, 3), (2, 3), (1, 2), (3, 1), (3, 2), (1, 2), (1, 3), (2, 3), (2, 1), (3, 1), (2, 3), (1, 2), (1, 3), (2, 3), (2, 1), (3, 1), (3, 2), (1, 2), (3, 1), (2, 3), (2, 1), (3, 1), (2, 3), (1, 2), (1, 3), (2, 3), (1, 2), (3, 1), (3, 2), (1, 2), (1, 3), (2, 3), (2, 1), (3, 1), (2, 3), (1, 2), (1, 3), (2, 3), (1, 2), (3, 1), (3, 2), (1, 2), (3, 1), (2, 3), (2, 1), (3, 1), (3, 2), (1, 2), (1, 3), (2, 3), (1, 2), (3, 1), (3, 2), (1, 2), (3, 1), (2, 3), (2, 1), (3, 1), (2, 3), (1, 2), (1, 3), (2, 3), (2, 1), (3, 1), (3, 2), (1, 2), (3, 1), (2, 3), (2, 1), (3, 1), (3, 2), (1, 2), (1, 3), (2, 3), (1, 2), (3, 1), (3, 2), (1, 2), (1, 3), (2, 3), (2, 1), (3, 1), (2, 3), (1, 2), (1, 3), (2, 3), (1, 2), (3, 1), (3, 2), (1, 2), (3, 1), (2, 3), (2, 1), (3, 1), (3, 2), (1, 2), (1, 3), (2, 3), (1, 2), (3, 1), (3, 2), (1, 2), (1, 3), (2, 3), (2, 1), (3, 1), (2, 3), (1, 2), (1, 3), (2, 3), (2, 1), (3, 1), (3, 2), (1, 2), (3, 1), (2, 3), (2, 1), (3, 1), (2, 3), (1, 2), (1, 3), (2, 3), (1, 2), (3, 1), (3, 2), (1, 2), (1, 3), (2, 3), (2, 1), (3, 1), (2, 3), (1, 2), (1, 3), (2, 3), (2, 1), (3, 1), (3, 2), (1, 2), (3, 1), (2, 3), (2, 1), (3, 1), (3, 2), (1, 2), (1, 3), (2, 3), (1, 2), (3, 1), (3, 2), (1, 2), (3, 1), (2, 3), (2, 1), (3, 1), (2, 3), (1, 2), (1, 3), (2, 3), (2, 1), (3, 1), (3, 2), (1, 2), (3, 1), (2, 3), (2, 1), (3, 1), (2, 3), (1, 2), (1, 3), (2, 3), (1, 2), (3, 1), (3, 2), (1, 2), (1, 3), (2, 3), (2, 1), (3, 1), (2, 3), (1, 2), (1, 3), (2, 3), (1, 2), (3, 1), (3, 2), (1, 2), (3, 1), (2, 3), (2, 1), (3, 1), (3, 2), (1, 2), (1, 3), (2, 3), (1, 2), (3, 1), (3, 2), (1, 2), (1, 3), (2, 3), (2, 1), (3, 1), (2, 3), (1, 2), (1, 3), (2, 3), (2, 1), (3, 1), (3, 2), (1, 2), (3, 1), (2, 3), (2, 1), (3, 1), (2, 3), (1, 2), (1, 3), (2, 3), (1, 2), (3, 1), (3, 2), (1, 2), (1, 3), (2, 3), (2, 1), (3, 1), (2, 3), (1, 2), (1, 3), (2, 3)]\n    assert candidate(9) == [(1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3)]\n    assert candidate(4) == [(1, 2), (1, 3), (2, 3), (1, 2), (3, 1), (3, 2), (1, 2), (1, 3), (2, 3), (2, 1), (3, 1), (2, 3), (1, 2), (1, 3), (2, 3)]\n    assert candidate(7) == [(1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3)]\n    assert candidate(12) == [(1, 2), (1, 3), (2, 3), (1, 2), (3, 1), (3, 2), (1, 2), (1, 3), (2, 3), (2, 1), (3, 1), (2, 3), (1, 2), (1, 3), (2, 3), (1, 2), (3, 1), (3, 2), (1, 2), (3, 1), (2, 3), (2, 1), (3, 1), (3, 2), (1, 2), (1, 3), (2, 3), (1, 2), (3, 1), (3, 2), (1, 2), (1, 3), (2, 3), (2, 1), (3, 1), (2, 3), (1, 2), (1, 3), (2, 3), (2, 1), (3, 1), (3, 2), (1, 2), (3, 1), (2, 3), (2, 1), (3, 1), (2, 3), (1, 2), (1, 3), (2, 3), (1, 2), (3, 1), (3, 2), (1, 2), (1, 3), (2, 3), (2, 1), (3, 1), (2, 3), (1, 2), (1, 3), (2, 3), (1, 2), (3, 1), (3, 2), (1, 2), (3, 1), (2, 3), (2, 1), (3, 1), (3, 2), (1, 2), (1, 3), (2, 3), (1, 2), (3, 1), (3, 2), (1, 2), (3, 1), (2, 3), (2, 1), (3, 1), (2, 3), (1, 2), (1, 3), (2, 3), (2, 1), (3, 1), (3, 2), (1, 2), (3, 1), (2, 3), (2, 1), (3, 1), (3, 2), (1, 2), (1, 3), (2, 3), (1, 2), (3, 1), (3, 2), (1, 2), (1, 3), (2, 3), (2, 1), (3, 1), (2, 3), (1, 2), (1, 3), (2, 3), (1, 2), (3, 1), (3, 2), (1, 2), (3, 1), (2, 3), (2, 1), (3, 1), (3, 2), (1, 2), (1, 3), (2, 3), (1, 2), (3, 1), (3, 2), (1, 2), (1, 3), (2, 3), (2, 1), (3, 1), (2, 3), (1, 2), (1, 3), (2, 3), (2, 1), (3, 1), (3, 2), (1, 2), (3, 1), (2, 3), (2, 1), (3, 1), (2, 3), (1, 2), (1, 3), (2, 3), (1, 2), (3, 1), (3, 2), (1, 2), (1, 3), (2, 3), (2, 1), (3, 1), (2, 3), (1, 2), (1, 3), (2, 3), (2, 1), (3, 1), (3, 2), (1, 2), (3, 1), (2, 3), (2, 1), (3, 1), (3, 2), (1, 2), (1, 3), (2, 3), (1, 2), (3, 1), (3, 2), (1, 2), (3, 1), (2, 3), (2, 1), (3, 1), (2, 3), (1, 2), (1, 3), (2, 3), (2, 1), (3, 1), (3, 2), (1, 2), (3, 1), (2, 3), (2, 1), (3, 1), (2, 3), (1, 2), (1, 3), (2, 3), (1, 2), (3, 1), (3, 2), (1, 2), (1, 3), (2, 3), (2, 1), (3, 1), (2, 3), (1, 2), (1, 3), (2, 3), (1, 2), (3, 1), (3, 2), (1, 2), (3, 1), (2, 3), (2, 1), (3, 1), (3, 2), (1, 2), (1, 3), (2, 3), (1, 2), (3, 1), (3, 2), (1, 2), (1, 3), (2, 3), (2, 1), (3, 1), (2, 3), (1, 2), (1, 3), (2, 3), (2, 1), (3, 1), (3, 2), (1, 2), (3, 1), (2, 3), (2, 1), (3, 1), (2, 3), (1, 2), (1, 3), (2, 3), (1, 2), (3, 1), (3, 2), (1, 2), (1, 3), (2, 3), (2, 1), (3, 1), (2, 3), (1, 2), (1, 3), (2, 3), (1, 2), (3, 1), (3, 2), (1, 2), (3, 1), (2, 3), (2, 1), (3, 1), (3, 2), (1, 2), (1, 3), (2, 3), (1, 2), (3, 1), (3, 2), (1, 2), (3, 1), (2, 3), (2, 1), (3, 1), (2, 3), (1, 2), (1, 3), (2, 3), (2, 1), (3, 1), (3, 2), (1, 2), (3, 1), (2, 3), (2, 1), (3, 1), (3, 2), (1, 2), (1, 3), (2, 3), (1, 2), (3, 1), (3, 2), (1, 2), (1, 3), (2, 3), (2, 1), (3, 1), (2, 3), (1, 2), (1, 3), (2, 3), (1, 2), (3, 1), (3, 2), (1, 2), (3, 1), (2, 3), (2, 1), (3, 1), (3, 2), (1, 2), (1, 3), (2, 3), (1, 2), (3, 1), (3, 2), (1, 2), (3, 1), (2, 3), (2, 1), (3, 1), (2, 3), (1, 2), (1, 3), (2, 3), (2, 1), (3, 1), (3, 2), (1, 2), (3, 1), (2, 3), (2, 1), (3, 1), (2, 3), (1, 2), (1, 3), (2, 3), (1, 2), (3, 1), (3, 2), (1, 2), (1, 3), (2, 3), (2, 1), (3, 1), (2, 3), (1, 2), (1, 3), (2, 3), (2, 1), (3, 1), (3, 2), (1, 2), (3, 1), (2, 3), (2, 1), (3, 1), (3, 2), (1, 2), (1, 3), (2, 3), (1, 2), (3, 1), (3, 2), (1, 2), (3, 1), (2, 3), (2, 1), (3, 1), (2, 3), (1, 2), (1, 3), (2, 3), (2, 1), (3, 1), (3, 2), (1, 2), (3, 1), (2, 3), (2, 1), (3, 1), (3, 2), (1, 2), (1, 3), (2, 3), (1, 2), (3, 1), (3, 2), (1, 2), (1, 3), (2, 3), (2, 1), (3, 1), (2, 3), (1, 2), (1, 3), (2, 3), (1, 2), (3, 1), (3, 2), (1, 2), (3, 1), (2, 3), (2, 1), (3, 1), (3, 2), (1, 2), (1, 3), (2, 3), (1, 2), (3, 1), (3, 2), (1, 2), (1, 3), (2, 3), (2, 1), (3, 1), (2, 3), (1, 2), (1, 3), (2, 3), (2, 1), (3, 1), (3, 2), (1, 2), (3, 1), (2, 3), (2, 1), (3, 1), (2, 3), (1, 2), (1, 3), (2, 3), (1, 2), (3, 1), (3, 2), (1, 2), (1, 3), (2, 3), (2, 1), (3, 1), (2, 3), (1, 2), (1, 3), (2, 3), (1, 2), (3, 1), (3, 2), (1, 2), (3, 1), (2, 3), (2, 1), (3, 1), (3, 2), (1, 2), (1, 3), (2, 3), (1, 2), (3, 1), (3, 2), (1, 2), (3, 1), (2, 3), (2, 1), (3, 1), (2, 3), (1, 2), (1, 3), (2, 3), (2, 1), (3, 1), (3, 2), (1, 2), (3, 1), (2, 3), (2, 1), (3, 1), (3, 2), (1, 2), (1, 3), (2, 3), (1, 2), (3, 1), (3, 2), (1, 2), (1, 3), (2, 3), (2, 1), (3, 1), (2, 3), (1, 2), (1, 3), (2, 3), (1, 2), (3, 1), (3, 2), (1, 2), (3, 1), (2, 3), (2, 1), (3, 1), (3, 2), (1, 2), (1, 3), (2, 3), (1, 2), (3, 1), (3, 2), (1, 2), (1, 3), (2, 3), (2, 1), (3, 1), (2, 3), (1, 2), (1, 3), (2, 3), (2, 1), (3, 1), (3, 2), (1, 2), (3, 1), (2, 3), (2, 1), (3, 1), (2, 3), (1, 2), (1, 3), (2, 3), (1, 2), (3, 1), (3, 2), (1, 2), (1, 3), (2, 3), (2, 1), (3, 1), (2, 3), (1, 2), (1, 3), (2, 3), (2, 1), (3, 1), (3, 2), (1, 2), (3, 1), (2, 3), (2, 1), (3, 1), (3, 2), (1, 2), (1, 3), (2, 3), (1, 2), (3, 1), (3, 2), (1, 2), (3, 1), (2, 3), (2, 1), (3, 1), (2, 3), (1, 2), (1, 3), (2, 3), (2, 1), (3, 1), (3, 2), (1, 2), (3, 1), (2, 3), (2, 1), (3, 1), (2, 3), (1, 2), (1, 3), (2, 3), (1, 2), (3, 1), (3, 2), (1, 2), (1, 3), (2, 3), (2, 1), (3, 1), (2, 3), (1, 2), (1, 3), (2, 3), (1, 2), (3, 1), (3, 2), (1, 2), (3, 1), (2, 3), (2, 1), (3, 1), (3, 2), (1, 2), (1, 3), (2, 3), (1, 2), (3, 1), (3, 2), (1, 2), (1, 3), (2, 3), (2, 1), (3, 1), (2, 3), (1, 2), (1, 3), (2, 3), (2, 1), (3, 1), (3, 2), (1, 2), (3, 1), (2, 3), (2, 1), (3, 1), (2, 3), (1, 2), (1, 3), (2, 3), (1, 2), (3, 1), (3, 2), (1, 2), (1, 3), (2, 3), (2, 1), (3, 1), (2, 3), (1, 2), (1, 3), (2, 3), (2, 1), (3, 1), (3, 2), (1, 2), (3, 1), (2, 3), (2, 1), (3, 1), (3, 2), (1, 2), (1, 3), (2, 3), (1, 2), (3, 1), (3, 2), (1, 2), (3, 1), (2, 3), (2, 1), (3, 1), (2, 3), (1, 2), (1, 3), (2, 3), (2, 1), (3, 1), (3, 2), (1, 2), (3, 1), (2, 3), (2, 1), (3, 1), (3, 2), (1, 2), (1, 3), (2, 3), (1, 2), (3, 1), (3, 2), (1, 2), (1, 3), (2, 3), (2, 1), (3, 1), (2, 3), (1, 2), (1, 3), (2, 3), (1, 2), (3, 1), (3, 2), (1, 2), (3, 1), (2, 3), (2, 1), (3, 1), (3, 2), (1, 2), (1, 3), (2, 3), (1, 2), (3, 1), (3, 2), (1, 2), (3, 1), (2, 3), (2, 1), (3, 1), (2, 3), (1, 2), (1, 3), (2, 3), (2, 1), (3, 1), (3, 2), (1, 2), (3, 1), (2, 3), (2, 1), (3, 1), (2, 3), (1, 2), (1, 3), (2, 3), (1, 2), (3, 1), (3, 2), (1, 2), (1, 3), (2, 3), (2, 1), (3, 1), (2, 3), (1, 2), (1, 3), (2, 3), (2, 1), (3, 1), (3, 2), (1, 2), (3, 1), (2, 3), (2, 1), (3, 1), (3, 2), (1, 2), (1, 3), (2, 3), (1, 2), (3, 1), (3, 2), (1, 2), (3, 1), (2, 3), (2, 1), (3, 1), (2, 3), (1, 2), (1, 3), (2, 3), (2, 1), (3, 1), (3, 2), (1, 2), (3, 1), (2, 3), (2, 1), (3, 1), (2, 3), (1, 2), (1, 3), (2, 3), (1, 2), (3, 1), (3, 2), (1, 2), (1, 3), (2, 3), (2, 1), (3, 1), (2, 3), (1, 2), (1, 3), (2, 3), (1, 2), (3, 1), (3, 2), (1, 2), (3, 1), (2, 3), (2, 1), (3, 1), (3, 2), (1, 2), (1, 3), (2, 3), (1, 2), (3, 1), (3, 2), (1, 2), (1, 3), (2, 3), (2, 1), (3, 1), (2, 3), (1, 2), (1, 3), (2, 3), (2, 1), (3, 1), (3, 2), (1, 2), (3, 1), (2, 3), (2, 1), (3, 1), (2, 3), (1, 2), (1, 3), (2, 3), (1, 2), (3, 1), (3, 2), (1, 2), (1, 3), (2, 3), (2, 1), (3, 1), (2, 3), (1, 2), (1, 3), (2, 3), (1, 2), (3, 1), (3, 2), (1, 2), (3, 1), (2, 3), (2, 1), (3, 1), (3, 2), (1, 2), (1, 3), (2, 3), (1, 2), (3, 1), (3, 2), (1, 2), (3, 1), (2, 3), (2, 1), (3, 1), (2, 3), (1, 2), (1, 3), (2, 3), (2, 1), (3, 1), (3, 2), (1, 2), (3, 1), (2, 3), (2, 1), (3, 1), (3, 2), (1, 2), (1, 3), (2, 3), (1, 2), (3, 1), (3, 2), (1, 2), (1, 3), (2, 3), (2, 1), (3, 1), (2, 3), (1, 2), (1, 3), (2, 3), (1, 2), (3, 1), (3, 2), (1, 2), (3, 1), (2, 3), (2, 1), (3, 1), (3, 2), (1, 2), (1, 3), (2, 3), (1, 2), (3, 1), (3, 2), (1, 2), (1, 3), (2, 3), (2, 1), (3, 1), (2, 3), (1, 2), (1, 3), (2, 3), (2, 1), (3, 1), (3, 2), (1, 2), (3, 1), (2, 3), (2, 1), (3, 1), (2, 3), (1, 2), (1, 3), (2, 3), (1, 2), (3, 1), (3, 2), (1, 2), (1, 3), (2, 3), (2, 1), (3, 1), (2, 3), (1, 2), (1, 3), (2, 3), (2, 1), (3, 1), (3, 2), (1, 2), (3, 1), (2, 3), (2, 1), (3, 1), (3, 2), (1, 2), (1, 3), (2, 3), (1, 2), (3, 1), (3, 2), (1, 2), (3, 1), (2, 3), (2, 1), (3, 1), (2, 3), (1, 2), (1, 3), (2, 3), (2, 1), (3, 1), (3, 2), (1, 2), (3, 1), (2, 3), (2, 1), (3, 1), (2, 3), (1, 2), (1, 3), (2, 3), (1, 2), (3, 1), (3, 2), (1, 2), (1, 3), (2, 3), (2, 1), (3, 1), (2, 3), (1, 2), (1, 3), (2, 3), (1, 2), (3, 1), (3, 2), (1, 2), (3, 1), (2, 3), (2, 1), (3, 1), (3, 2), (1, 2), (1, 3), (2, 3), (1, 2), (3, 1), (3, 2), (1, 2), (1, 3), (2, 3), (2, 1), (3, 1), (2, 3), (1, 2), (1, 3), (2, 3), (2, 1), (3, 1), (3, 2), (1, 2), (3, 1), (2, 3), (2, 1), (3, 1), (2, 3), (1, 2), (1, 3), (2, 3), (1, 2), (3, 1), (3, 2), (1, 2), (1, 3), (2, 3), (2, 1), (3, 1), (2, 3), (1, 2), (1, 3), (2, 3), (1, 2), (3, 1), (3, 2), (1, 2), (3, 1), (2, 3), (2, 1), (3, 1), (3, 2), (1, 2), (1, 3), (2, 3), (1, 2), (3, 1), (3, 2), (1, 2), (3, 1), (2, 3), (2, 1), (3, 1), (2, 3), (1, 2), (1, 3), (2, 3), (2, 1), (3, 1), (3, 2), (1, 2), (3, 1), (2, 3), (2, 1), (3, 1), (3, 2), (1, 2), (1, 3), (2, 3), (1, 2), (3, 1), (3, 2), (1, 2), (1, 3), (2, 3), (2, 1), (3, 1), (2, 3), (1, 2), (1, 3), (2, 3), (1, 2), (3, 1), (3, 2), (1, 2), (3, 1), (2, 3), (2, 1), (3, 1), (3, 2), (1, 2), (1, 3), (2, 3), (1, 2), (3, 1), (3, 2), (1, 2), (3, 1), (2, 3), (2, 1), (3, 1), (2, 3), (1, 2), (1, 3), (2, 3), (2, 1), (3, 1), (3, 2), (1, 2), (3, 1), (2, 3), (2, 1), (3, 1), (2, 3), (1, 2), (1, 3), (2, 3), (1, 2), (3, 1), (3, 2), (1, 2), (1, 3), (2, 3), (2, 1), (3, 1), (2, 3), (1, 2), (1, 3), (2, 3), (2, 1), (3, 1), (3, 2), (1, 2), (3, 1), (2, 3), (2, 1), (3, 1), (3, 2), (1, 2), (1, 3), (2, 3), (1, 2), (3, 1), (3, 2), (1, 2), (3, 1), (2, 3), (2, 1), (3, 1), (2, 3), (1, 2), (1, 3), (2, 3), (2, 1), (3, 1), (3, 2), (1, 2), (3, 1), (2, 3), (2, 1), (3, 1), (3, 2), (1, 2), (1, 3), (2, 3), (1, 2), (3, 1), (3, 2), (1, 2), (1, 3), (2, 3), (2, 1), (3, 1), (2, 3), (1, 2), (1, 3), (2, 3), (1, 2), (3, 1), (3, 2), (1, 2), (3, 1), (2, 3), (2, 1), (3, 1), (3, 2), (1, 2), (1, 3), (2, 3), (1, 2), (3, 1), (3, 2), (1, 2), (1, 3), (2, 3), (2, 1), (3, 1), (2, 3), (1, 2), (1, 3), (2, 3), (2, 1), (3, 1), (3, 2), (1, 2), (3, 1), (2, 3), (2, 1), (3, 1), (2, 3), (1, 2), (1, 3), (2, 3), (1, 2), (3, 1), (3, 2), (1, 2), (1, 3), (2, 3), (2, 1), (3, 1), (2, 3), (1, 2), (1, 3), (2, 3), (1, 2), (3, 1), (3, 2), (1, 2), (3, 1), (2, 3), (2, 1), (3, 1), (3, 2), (1, 2), (1, 3), (2, 3), (1, 2), (3, 1), (3, 2), (1, 2), (3, 1), (2, 3), (2, 1), (3, 1), (2, 3), (1, 2), (1, 3), (2, 3), (2, 1), (3, 1), (3, 2), (1, 2), (3, 1), (2, 3), (2, 1), (3, 1), (3, 2), (1, 2), (1, 3), (2, 3), (1, 2), (3, 1), (3, 2), (1, 2), (1, 3), (2, 3), (2, 1), (3, 1), (2, 3), (1, 2), (1, 3), (2, 3), (1, 2), (3, 1), (3, 2), (1, 2), (3, 1), (2, 3), (2, 1), (3, 1), (3, 2), (1, 2), (1, 3), (2, 3), (1, 2), (3, 1), (3, 2), (1, 2), (3, 1), (2, 3), (2, 1), (3, 1), (2, 3), (1, 2), (1, 3), (2, 3), (2, 1), (3, 1), (3, 2), (1, 2), (3, 1), (2, 3), (2, 1), (3, 1), (2, 3), (1, 2), (1, 3), (2, 3), (1, 2), (3, 1), (3, 2), (1, 2), (1, 3), (2, 3), (2, 1), (3, 1), (2, 3), (1, 2), (1, 3), (2, 3), (2, 1), (3, 1), (3, 2), (1, 2), (3, 1), (2, 3), (2, 1), (3, 1), (3, 2), (1, 2), (1, 3), (2, 3), (1, 2), (3, 1), (3, 2), (1, 2), (3, 1), (2, 3), (2, 1), (3, 1), (2, 3), (1, 2), (1, 3), (2, 3), (2, 1), (3, 1), (3, 2), (1, 2), (3, 1), (2, 3), (2, 1), (3, 1), (2, 3), (1, 2), (1, 3), (2, 3), (1, 2), (3, 1), (3, 2), (1, 2), (1, 3), (2, 3), (2, 1), (3, 1), (2, 3), (1, 2), (1, 3), (2, 3), (1, 2), (3, 1), (3, 2), (1, 2), (3, 1), (2, 3), (2, 1), (3, 1), (3, 2), (1, 2), (1, 3), (2, 3), (1, 2), (3, 1), (3, 2), (1, 2), (1, 3), (2, 3), (2, 1), (3, 1), (2, 3), (1, 2), (1, 3), (2, 3), (2, 1), (3, 1), (3, 2), (1, 2), (3, 1), (2, 3), (2, 1), (3, 1), (2, 3), (1, 2), (1, 3), (2, 3), (1, 2), (3, 1), (3, 2), (1, 2), (1, 3), (2, 3), (2, 1), (3, 1), (2, 3), (1, 2), (1, 3), (2, 3), (2, 1), (3, 1), (3, 2), (1, 2), (3, 1), (2, 3), (2, 1), (3, 1), (3, 2), (1, 2), (1, 3), (2, 3), (1, 2), (3, 1), (3, 2), (1, 2), (3, 1), (2, 3), (2, 1), (3, 1), (2, 3), (1, 2), (1, 3), (2, 3), (2, 1), (3, 1), (3, 2), (1, 2), (3, 1), (2, 3), (2, 1), (3, 1), (3, 2), (1, 2), (1, 3), (2, 3), (1, 2), (3, 1), (3, 2), (1, 2), (1, 3), (2, 3), (2, 1), (3, 1), (2, 3), (1, 2), (1, 3), (2, 3), (1, 2), (3, 1), (3, 2), (1, 2), (3, 1), (2, 3), (2, 1), (3, 1), (3, 2), (1, 2), (1, 3), (2, 3), (1, 2), (3, 1), (3, 2), (1, 2), (3, 1), (2, 3), (2, 1), (3, 1), (2, 3), (1, 2), (1, 3), (2, 3), (2, 1), (3, 1), (3, 2), (1, 2), (3, 1), (2, 3), (2, 1), (3, 1), (2, 3), (1, 2), (1, 3), (2, 3), (1, 2), (3, 1), (3, 2), (1, 2), (1, 3), (2, 3), (2, 1), (3, 1), (2, 3), (1, 2), (1, 3), (2, 3), (2, 1), (3, 1), (3, 2), (1, 2), (3, 1), (2, 3), (2, 1), (3, 1), (3, 2), (1, 2), (1, 3), (2, 3), (1, 2), (3, 1), (3, 2), (1, 2), (3, 1), (2, 3), (2, 1), (3, 1), (2, 3), (1, 2), (1, 3), (2, 3), (2, 1), (3, 1), (3, 2), (1, 2), (3, 1), (2, 3), (2, 1), (3, 1), (3, 2), (1, 2), (1, 3), (2, 3), (1, 2), (3, 1), (3, 2), (1, 2), (1, 3), (2, 3), (2, 1), (3, 1), (2, 3), (1, 2), (1, 3), (2, 3), (1, 2), (3, 1), (3, 2), (1, 2), (3, 1), (2, 3), (2, 1), (3, 1), (3, 2), (1, 2), (1, 3), (2, 3), (1, 2), (3, 1), (3, 2), (1, 2), (1, 3), (2, 3), (2, 1), (3, 1), (2, 3), (1, 2), (1, 3), (2, 3), (2, 1), (3, 1), (3, 2), (1, 2), (3, 1), (2, 3), (2, 1), (3, 1), (2, 3), (1, 2), (1, 3), (2, 3), (1, 2), (3, 1), (3, 2), (1, 2), (1, 3), (2, 3), (2, 1), (3, 1), (2, 3), (1, 2), (1, 3), (2, 3), (1, 2), (3, 1), (3, 2), (1, 2), (3, 1), (2, 3), (2, 1), (3, 1), (3, 2), (1, 2), (1, 3), (2, 3), (1, 2), (3, 1), (3, 2), (1, 2), (3, 1), (2, 3), (2, 1), (3, 1), (2, 3), (1, 2), (1, 3), (2, 3), (2, 1), (3, 1), (3, 2), (1, 2), (3, 1), (2, 3), (2, 1), (3, 1), (3, 2), (1, 2), (1, 3), (2, 3), (1, 2), (3, 1), (3, 2), (1, 2), (1, 3), (2, 3), (2, 1), (3, 1), (2, 3), (1, 2), (1, 3), (2, 3), (1, 2), (3, 1), (3, 2), (1, 2), (3, 1), (2, 3), (2, 1), (3, 1), (3, 2), (1, 2), (1, 3), (2, 3), (1, 2), (3, 1), (3, 2), (1, 2), (1, 3), (2, 3), (2, 1), (3, 1), (2, 3), (1, 2), (1, 3), (2, 3), (2, 1), (3, 1), (3, 2), (1, 2), (3, 1), (2, 3), (2, 1), (3, 1), (2, 3), (1, 2), (1, 3), (2, 3), (1, 2), (3, 1), (3, 2), (1, 2), (1, 3), (2, 3), (2, 1), (3, 1), (2, 3), (1, 2), (1, 3), (2, 3), (2, 1), (3, 1), (3, 2), (1, 2), (3, 1), (2, 3), (2, 1), (3, 1), (3, 2), (1, 2), (1, 3), (2, 3), (1, 2), (3, 1), (3, 2), (1, 2), (3, 1), (2, 3), (2, 1), (3, 1), (2, 3), (1, 2), (1, 3), (2, 3), (2, 1), (3, 1), (3, 2), (1, 2), (3, 1), (2, 3), (2, 1), (3, 1), (2, 3), (1, 2), (1, 3), (2, 3), (1, 2), (3, 1), (3, 2), (1, 2), (1, 3), (2, 3), (2, 1), (3, 1), (2, 3), (1, 2), (1, 3), (2, 3), (1, 2), (3, 1), (3, 2), (1, 2), (3, 1), (2, 3), (2, 1), (3, 1), (3, 2), (1, 2), (1, 3), (2, 3), (1, 2), (3, 1), (3, 2), (1, 2), (1, 3), (2, 3), (2, 1), (3, 1), (2, 3), (1, 2), (1, 3), (2, 3), (2, 1), (3, 1), (3, 2), (1, 2), (3, 1), (2, 3), (2, 1), (3, 1), (2, 3), (1, 2), (1, 3), (2, 3), (1, 2), (3, 1), (3, 2), (1, 2), (1, 3), (2, 3), (2, 1), (3, 1), (2, 3), (1, 2), (1, 3), (2, 3), (1, 2), (3, 1), (3, 2), (1, 2), (3, 1), (2, 3), (2, 1), (3, 1), (3, 2), (1, 2), (1, 3), (2, 3), (1, 2), (3, 1), (3, 2), (1, 2), (3, 1), (2, 3), (2, 1), (3, 1), (2, 3), (1, 2), (1, 3), (2, 3), (2, 1), (3, 1), (3, 2), (1, 2), (3, 1), (2, 3), (2, 1), (3, 1), (3, 2), (1, 2), (1, 3), (2, 3), (1, 2), (3, 1), (3, 2), (1, 2), (1, 3), (2, 3), (2, 1), (3, 1), (2, 3), (1, 2), (1, 3), (2, 3), (1, 2), (3, 1), (3, 2), (1, 2), (3, 1), (2, 3), (2, 1), (3, 1), (3, 2), (1, 2), (1, 3), (2, 3), (1, 2), (3, 1), (3, 2), (1, 2), (3, 1), (2, 3), (2, 1), (3, 1), (2, 3), (1, 2), (1, 3), (2, 3), (2, 1), (3, 1), (3, 2), (1, 2), (3, 1), (2, 3), (2, 1), (3, 1), (2, 3), (1, 2), (1, 3), (2, 3), (1, 2), (3, 1), (3, 2), (1, 2), (1, 3), (2, 3), (2, 1), (3, 1), (2, 3), (1, 2), (1, 3), (2, 3), (2, 1), (3, 1), (3, 2), (1, 2), (3, 1), (2, 3), (2, 1), (3, 1), (3, 2), (1, 2), (1, 3), (2, 3), (1, 2), (3, 1), (3, 2), (1, 2), (3, 1), (2, 3), (2, 1), (3, 1), (2, 3), (1, 2), (1, 3), (2, 3), (2, 1), (3, 1), (3, 2), (1, 2), (3, 1), (2, 3), (2, 1), (3, 1), (3, 2), (1, 2), (1, 3), (2, 3), (1, 2), (3, 1), (3, 2), (1, 2), (1, 3), (2, 3), (2, 1), (3, 1), (2, 3), (1, 2), (1, 3), (2, 3), (1, 2), (3, 1), (3, 2), (1, 2), (3, 1), (2, 3), (2, 1), (3, 1), (3, 2), (1, 2), (1, 3), (2, 3), (1, 2), (3, 1), (3, 2), (1, 2), (1, 3), (2, 3), (2, 1), (3, 1), (2, 3), (1, 2), (1, 3), (2, 3), (2, 1), (3, 1), (3, 2), (1, 2), (3, 1), (2, 3), (2, 1), (3, 1), (2, 3), (1, 2), (1, 3), (2, 3), (1, 2), (3, 1), (3, 2), (1, 2), (1, 3), (2, 3), (2, 1), (3, 1), (2, 3), (1, 2), (1, 3), (2, 3), (1, 2), (3, 1), (3, 2), (1, 2), (3, 1), (2, 3), (2, 1), (3, 1), (3, 2), (1, 2), (1, 3), (2, 3), (1, 2), (3, 1), (3, 2), (1, 2), (3, 1), (2, 3), (2, 1), (3, 1), (2, 3), (1, 2), (1, 3), (2, 3), (2, 1), (3, 1), (3, 2), (1, 2), (3, 1), (2, 3), (2, 1), (3, 1), (3, 2), (1, 2), (1, 3), (2, 3), (1, 2), (3, 1), (3, 2), (1, 2), (1, 3), (2, 3), (2, 1), (3, 1), (2, 3), (1, 2), (1, 3), (2, 3), (1, 2), (3, 1), (3, 2), (1, 2), (3, 1), (2, 3), (2, 1), (3, 1), (3, 2), (1, 2), (1, 3), (2, 3), (1, 2), (3, 1), (3, 2), (1, 2), (1, 3), (2, 3), (2, 1), (3, 1), (2, 3), (1, 2), (1, 3), (2, 3), (2, 1), (3, 1), (3, 2), (1, 2), (3, 1), (2, 3), (2, 1), (3, 1), (2, 3), (1, 2), (1, 3), (2, 3), (1, 2), (3, 1), (3, 2), (1, 2), (1, 3), (2, 3), (2, 1), (3, 1), (2, 3), (1, 2), (1, 3), (2, 3), (2, 1), (3, 1), (3, 2), (1, 2), (3, 1), (2, 3), (2, 1), (3, 1), (3, 2), (1, 2), (1, 3), (2, 3), (1, 2), (3, 1), (3, 2), (1, 2), (3, 1), (2, 3), (2, 1), (3, 1), (2, 3), (1, 2), (1, 3), (2, 3), (2, 1), (3, 1), (3, 2), (1, 2), (3, 1), (2, 3), (2, 1), (3, 1), (2, 3), (1, 2), (1, 3), (2, 3), (1, 2), (3, 1), (3, 2), (1, 2), (1, 3), (2, 3), (2, 1), (3, 1), (2, 3), (1, 2), (1, 3), (2, 3), (1, 2), (3, 1), (3, 2), (1, 2), (3, 1), (2, 3), (2, 1), (3, 1), (3, 2), (1, 2), (1, 3), (2, 3), (1, 2), (3, 1), (3, 2), (1, 2), (1, 3), (2, 3), (2, 1), (3, 1), (2, 3), (1, 2), (1, 3), (2, 3), (2, 1), (3, 1), (3, 2), (1, 2), (3, 1), (2, 3), (2, 1), (3, 1), (2, 3), (1, 2), (1, 3), (2, 3), (1, 2), (3, 1), (3, 2), (1, 2), (1, 3), (2, 3), (2, 1), (3, 1), (2, 3), (1, 2), (1, 3), (2, 3), (2, 1), (3, 1), (3, 2), (1, 2), (3, 1), (2, 3), (2, 1), (3, 1), (3, 2), (1, 2), (1, 3), (2, 3), (1, 2), (3, 1), (3, 2), (1, 2), (3, 1), (2, 3), (2, 1), (3, 1), (2, 3), (1, 2), (1, 3), (2, 3), (2, 1), (3, 1), (3, 2), (1, 2), (3, 1), (2, 3), (2, 1), (3, 1), (3, 2), (1, 2), (1, 3), (2, 3), (1, 2), (3, 1), (3, 2), (1, 2), (1, 3), (2, 3), (2, 1), (3, 1), (2, 3), (1, 2), (1, 3), (2, 3), (1, 2), (3, 1), (3, 2), (1, 2), (3, 1), (2, 3), (2, 1), (3, 1), (3, 2), (1, 2), (1, 3), (2, 3), (1, 2), (3, 1), (3, 2), (1, 2), (3, 1), (2, 3), (2, 1), (3, 1), (2, 3), (1, 2), (1, 3), (2, 3), (2, 1), (3, 1), (3, 2), (1, 2), (3, 1), (2, 3), (2, 1), (3, 1), (2, 3), (1, 2), (1, 3), (2, 3), (1, 2), (3, 1), (3, 2), (1, 2), (1, 3), (2, 3), (2, 1), (3, 1), (2, 3), (1, 2), (1, 3), (2, 3), (2, 1), (3, 1), (3, 2), (1, 2), (3, 1), (2, 3), (2, 1), (3, 1), (3, 2), (1, 2), (1, 3), (2, 3), (1, 2), (3, 1), (3, 2), (1, 2), (3, 1), (2, 3), (2, 1), (3, 1), (2, 3), (1, 2), (1, 3), (2, 3), (2, 1), (3, 1), (3, 2), (1, 2), (3, 1), (2, 3), (2, 1), (3, 1), (2, 3), (1, 2), (1, 3), (2, 3), (1, 2), (3, 1), (3, 2), (1, 2), (1, 3), (2, 3), (2, 1), (3, 1), (2, 3), (1, 2), (1, 3), (2, 3), (1, 2), (3, 1), (3, 2), (1, 2), (3, 1), (2, 3), (2, 1), (3, 1), (3, 2), (1, 2), (1, 3), (2, 3), (1, 2), (3, 1), (3, 2), (1, 2), (1, 3), (2, 3), (2, 1), (3, 1), (2, 3), (1, 2), (1, 3), (2, 3), (2, 1), (3, 1), (3, 2), (1, 2), (3, 1), (2, 3), (2, 1), (3, 1), (2, 3), (1, 2), (1, 3), (2, 3), (1, 2), (3, 1), (3, 2), (1, 2), (1, 3), (2, 3), (2, 1), (3, 1), (2, 3), (1, 2), (1, 3), (2, 3), (1, 2), (3, 1), (3, 2), (1, 2), (3, 1), (2, 3), (2, 1), (3, 1), (3, 2), (1, 2), (1, 3), (2, 3), (1, 2), (3, 1), (3, 2), (1, 2), (3, 1), (2, 3), (2, 1), (3, 1), (2, 3), (1, 2), (1, 3), (2, 3), (2, 1), (3, 1), (3, 2), (1, 2), (3, 1), (2, 3), (2, 1), (3, 1), (3, 2), (1, 2), (1, 3), (2, 3), (1, 2), (3, 1), (3, 2), (1, 2), (1, 3), (2, 3), (2, 1), (3, 1), (2, 3), (1, 2), (1, 3), (2, 3), (1, 2), (3, 1), (3, 2), (1, 2), (3, 1), (2, 3), (2, 1), (3, 1), (3, 2), (1, 2), (1, 3), (2, 3), (1, 2), (3, 1), (3, 2), (1, 2), (1, 3), (2, 3), (2, 1), (3, 1), (2, 3), (1, 2), (1, 3), (2, 3), (2, 1), (3, 1), (3, 2), (1, 2), (3, 1), (2, 3), (2, 1), (3, 1), (2, 3), (1, 2), (1, 3), (2, 3), (1, 2), (3, 1), (3, 2), (1, 2), (1, 3), (2, 3), (2, 1), (3, 1), (2, 3), (1, 2), (1, 3), (2, 3), (2, 1), (3, 1), (3, 2), (1, 2), (3, 1), (2, 3), (2, 1), (3, 1), (3, 2), (1, 2), (1, 3), (2, 3), (1, 2), (3, 1), (3, 2), (1, 2), (3, 1), (2, 3), (2, 1), (3, 1), (2, 3), (1, 2), (1, 3), (2, 3), (2, 1), (3, 1), (3, 2), (1, 2), (3, 1), (2, 3), (2, 1), (3, 1), (2, 3), (1, 2), (1, 3), (2, 3), (1, 2), (3, 1), (3, 2), (1, 2), (1, 3), (2, 3), (2, 1), (3, 1), (2, 3), (1, 2), (1, 3), (2, 3), (1, 2), (3, 1), (3, 2), (1, 2), (3, 1), (2, 3), (2, 1), (3, 1), (3, 2), (1, 2), (1, 3), (2, 3), (1, 2), (3, 1), (3, 2), (1, 2), (1, 3), (2, 3), (2, 1), (3, 1), (2, 3), (1, 2), (1, 3), (2, 3), (2, 1), (3, 1), (3, 2), (1, 2), (3, 1), (2, 3), (2, 1), (3, 1), (2, 3), (1, 2), (1, 3), (2, 3), (1, 2), (3, 1), (3, 2), (1, 2), (1, 3), (2, 3), (2, 1), (3, 1), (2, 3), (1, 2), (1, 3), (2, 3), (2, 1), (3, 1), (3, 2), (1, 2), (3, 1), (2, 3), (2, 1), (3, 1), (3, 2), (1, 2), (1, 3), (2, 3), (1, 2), (3, 1), (3, 2), (1, 2), (3, 1), (2, 3), (2, 1), (3, 1), (2, 3), (1, 2), (1, 3), (2, 3), (2, 1), (3, 1), (3, 2), (1, 2), (3, 1), (2, 3), (2, 1), (3, 1), (3, 2), (1, 2), (1, 3), (2, 3), (1, 2), (3, 1), (3, 2), (1, 2), (1, 3), (2, 3), (2, 1), (3, 1), (2, 3), (1, 2), (1, 3), (2, 3), (1, 2), (3, 1), (3, 2), (1, 2), (3, 1), (2, 3), (2, 1), (3, 1), (3, 2), (1, 2), (1, 3), (2, 3), (1, 2), (3, 1), (3, 2), (1, 2), (3, 1), (2, 3), (2, 1), (3, 1), (2, 3), (1, 2), (1, 3), (2, 3), (2, 1), (3, 1), (3, 2), (1, 2), (3, 1), (2, 3), (2, 1), (3, 1), (2, 3), (1, 2), (1, 3), (2, 3), (1, 2), (3, 1), (3, 2), (1, 2), (1, 3), (2, 3), (2, 1), (3, 1), (2, 3), (1, 2), (1, 3), (2, 3), (2, 1), (3, 1), (3, 2), (1, 2), (3, 1), (2, 3), (2, 1), (3, 1), (3, 2), (1, 2), (1, 3), (2, 3), (1, 2), (3, 1), (3, 2), (1, 2), (3, 1), (2, 3), (2, 1), (3, 1), (2, 3), (1, 2), (1, 3), (2, 3), (2, 1), (3, 1), (3, 2), (1, 2), (3, 1), (2, 3), (2, 1), (3, 1), (3, 2), (1, 2), (1, 3), (2, 3), (1, 2), (3, 1), (3, 2), (1, 2), (1, 3), (2, 3), (2, 1), (3, 1), (2, 3), (1, 2), (1, 3), (2, 3), (1, 2), (3, 1), (3, 2), (1, 2), (3, 1), (2, 3), (2, 1), (3, 1), (3, 2), (1, 2), (1, 3), (2, 3), (1, 2), (3, 1), (3, 2), (1, 2), (1, 3), (2, 3), (2, 1), (3, 1), (2, 3), (1, 2), (1, 3), (2, 3), (2, 1), (3, 1), (3, 2), (1, 2), (3, 1), (2, 3), (2, 1), (3, 1), (2, 3), (1, 2), (1, 3), (2, 3), (1, 2), (3, 1), (3, 2), (1, 2), (1, 3), (2, 3), (2, 1), (3, 1), (2, 3), (1, 2), (1, 3), (2, 3), (1, 2), (3, 1), (3, 2), (1, 2), (3, 1), (2, 3), (2, 1), (3, 1), (3, 2), (1, 2), (1, 3), (2, 3), (1, 2), (3, 1), (3, 2), (1, 2), (3, 1), (2, 3), (2, 1), (3, 1), (2, 3), (1, 2), (1, 3), (2, 3), (2, 1), (3, 1), (3, 2), (1, 2), (3, 1), (2, 3), (2, 1), (3, 1), (3, 2), (1, 2), (1, 3), (2, 3), (1, 2), (3, 1), (3, 2), (1, 2), (1, 3), (2, 3), (2, 1), (3, 1), (2, 3), (1, 2), (1, 3), (2, 3), (1, 2), (3, 1), (3, 2), (1, 2), (3, 1), (2, 3), (2, 1), (3, 1), (3, 2), (1, 2), (1, 3), (2, 3), (1, 2), (3, 1), (3, 2), (1, 2), (3, 1), (2, 3), (2, 1), (3, 1), (2, 3), (1, 2), (1, 3), (2, 3), (2, 1), (3, 1), (3, 2), (1, 2), (3, 1), (2, 3), (2, 1), (3, 1), (2, 3), (1, 2), (1, 3), (2, 3), (1, 2), (3, 1), (3, 2), (1, 2), (1, 3), (2, 3), (2, 1), (3, 1), (2, 3), (1, 2), (1, 3), (2, 3), (2, 1), (3, 1), (3, 2), (1, 2), (3, 1), (2, 3), (2, 1), (3, 1), (3, 2), (1, 2), (1, 3), (2, 3), (1, 2), (3, 1), (3, 2), (1, 2), (3, 1), (2, 3), (2, 1), (3, 1), (2, 3), (1, 2), (1, 3), (2, 3), (2, 1), (3, 1), (3, 2), (1, 2), (3, 1), (2, 3), (2, 1), (3, 1), (2, 3), (1, 2), (1, 3), (2, 3), (1, 2), (3, 1), (3, 2), (1, 2), (1, 3), (2, 3), (2, 1), (3, 1), (2, 3), (1, 2), (1, 3), (2, 3), (1, 2), (3, 1), (3, 2), (1, 2), (3, 1), (2, 3), (2, 1), (3, 1), (3, 2), (1, 2), (1, 3), (2, 3), (1, 2), (3, 1), (3, 2), (1, 2), (1, 3), (2, 3), (2, 1), (3, 1), (2, 3), (1, 2), (1, 3), (2, 3), (2, 1), (3, 1), (3, 2), (1, 2), (3, 1), (2, 3), (2, 1), (3, 1), (2, 3), (1, 2), (1, 3), (2, 3), (1, 2), (3, 1), (3, 2), (1, 2), (1, 3), (2, 3), (2, 1), (3, 1), (2, 3), (1, 2), (1, 3), (2, 3), (2, 1), (3, 1), (3, 2), (1, 2), (3, 1), (2, 3), (2, 1), (3, 1), (3, 2), (1, 2), (1, 3), (2, 3), (1, 2), (3, 1), (3, 2), (1, 2), (3, 1), (2, 3), (2, 1), (3, 1), (2, 3), (1, 2), (1, 3), (2, 3), (2, 1), (3, 1), (3, 2), (1, 2), (3, 1), (2, 3), (2, 1), (3, 1), (3, 2), (1, 2), (1, 3), (2, 3), (1, 2), (3, 1), (3, 2), (1, 2), (1, 3), (2, 3), (2, 1), (3, 1), (2, 3), (1, 2), (1, 3), (2, 3), (1, 2), (3, 1), (3, 2), (1, 2), (3, 1), (2, 3), (2, 1), (3, 1), (3, 2), (1, 2), (1, 3), (2, 3), (1, 2), (3, 1), (3, 2), (1, 2), (3, 1), (2, 3), (2, 1), (3, 1), (2, 3), (1, 2), (1, 3), (2, 3), (2, 1), (3, 1), (3, 2), (1, 2), (3, 1), (2, 3), (2, 1), (3, 1), (2, 3), (1, 2), (1, 3), (2, 3), (1, 2), (3, 1), (3, 2), (1, 2), (1, 3), (2, 3), (2, 1), (3, 1), (2, 3), (1, 2), (1, 3), (2, 3), (2, 1), (3, 1), (3, 2), (1, 2), (3, 1), (2, 3), (2, 1), (3, 1), (3, 2), (1, 2), (1, 3), (2, 3), (1, 2), (3, 1), (3, 2), (1, 2), (3, 1), (2, 3), (2, 1), (3, 1), (2, 3), (1, 2), (1, 3), (2, 3), (2, 1), (3, 1), (3, 2), (1, 2), (3, 1), (2, 3), (2, 1), (3, 1), (2, 3), (1, 2), (1, 3), (2, 3), (1, 2), (3, 1), (3, 2), (1, 2), (1, 3), (2, 3), (2, 1), (3, 1), (2, 3), (1, 2), (1, 3), (2, 3), (1, 2), (3, 1), (3, 2), (1, 2), (3, 1), (2, 3), (2, 1), (3, 1), (3, 2), (1, 2), (1, 3), (2, 3), (1, 2), (3, 1), (3, 2), (1, 2), (1, 3), (2, 3), (2, 1), (3, 1), (2, 3), (1, 2), (1, 3), (2, 3), (2, 1), (3, 1), (3, 2), (1, 2), (3, 1), (2, 3), (2, 1), (3, 1), (2, 3), (1, 2), (1, 3), (2, 3), (1, 2), (3, 1), (3, 2), (1, 2), (1, 3), (2, 3), (2, 1), (3, 1), (2, 3), (1, 2), (1, 3), (2, 3), (1, 2), (3, 1), (3, 2), (1, 2), (3, 1), (2, 3), (2, 1), (3, 1), (3, 2), (1, 2), (1, 3), (2, 3), (1, 2), (3, 1), (3, 2), (1, 2), (3, 1), (2, 3), (2, 1), (3, 1), (2, 3), (1, 2), (1, 3), (2, 3), (2, 1), (3, 1), (3, 2), (1, 2), (3, 1), (2, 3), (2, 1), (3, 1), (3, 2), (1, 2), (1, 3), (2, 3), (1, 2), (3, 1), (3, 2), (1, 2), (1, 3), (2, 3), (2, 1), (3, 1), (2, 3), (1, 2), (1, 3), (2, 3), (1, 2), (3, 1), (3, 2), (1, 2), (3, 1), (2, 3), (2, 1), (3, 1), (3, 2), (1, 2), (1, 3), (2, 3), (1, 2), (3, 1), (3, 2), (1, 2), (1, 3), (2, 3), (2, 1), (3, 1), (2, 3), (1, 2), (1, 3), (2, 3), (2, 1), (3, 1), (3, 2), (1, 2), (3, 1), (2, 3), (2, 1), (3, 1), (2, 3), (1, 2), (1, 3), (2, 3), (1, 2), (3, 1), (3, 2), (1, 2), (1, 3), (2, 3), (2, 1), (3, 1), (2, 3), (1, 2), (1, 3), (2, 3), (2, 1), (3, 1), (3, 2), (1, 2), (3, 1), (2, 3), (2, 1), (3, 1), (3, 2), (1, 2), (1, 3), (2, 3), (1, 2), (3, 1), (3, 2), (1, 2), (3, 1), (2, 3), (2, 1), (3, 1), (2, 3), (1, 2), (1, 3), (2, 3), (2, 1), (3, 1), (3, 2), (1, 2), (3, 1), (2, 3), (2, 1), (3, 1), (2, 3), (1, 2), (1, 3), (2, 3), (1, 2), (3, 1), (3, 2), (1, 2), (1, 3), (2, 3), (2, 1), (3, 1), (2, 3), (1, 2), (1, 3), (2, 3), (1, 2), (3, 1), (3, 2), (1, 2), (3, 1), (2, 3), (2, 1), (3, 1), (3, 2), (1, 2), (1, 3), (2, 3), (1, 2), (3, 1), (3, 2), (1, 2), (1, 3), (2, 3), (2, 1), (3, 1), (2, 3), (1, 2), (1, 3), (2, 3), (2, 1), (3, 1), (3, 2), (1, 2), (3, 1), (2, 3), (2, 1), (3, 1), (2, 3), (1, 2), (1, 3), (2, 3), (1, 2), (3, 1), (3, 2), (1, 2), (1, 3), (2, 3), (2, 1), (3, 1), (2, 3), (1, 2), (1, 3), (2, 3), (1, 2), (3, 1), (3, 2), (1, 2), (3, 1), (2, 3), (2, 1), (3, 1), (3, 2), (1, 2), (1, 3), (2, 3), (1, 2), (3, 1), (3, 2), (1, 2), (3, 1), (2, 3), (2, 1), (3, 1), (2, 3), (1, 2), (1, 3), (2, 3), (2, 1), (3, 1), (3, 2), (1, 2), (3, 1), (2, 3), (2, 1), (3, 1), (3, 2), (1, 2), (1, 3), (2, 3), (1, 2), (3, 1), (3, 2), (1, 2), (1, 3), (2, 3), (2, 1), (3, 1), (2, 3), (1, 2), (1, 3), (2, 3), (1, 2), (3, 1), (3, 2), (1, 2), (3, 1), (2, 3), (2, 1), (3, 1), (3, 2), (1, 2), (1, 3), (2, 3), (1, 2), (3, 1), (3, 2), (1, 2), (3, 1), (2, 3), (2, 1), (3, 1), (2, 3), (1, 2), (1, 3), (2, 3), (2, 1), (3, 1), (3, 2), (1, 2), (3, 1), (2, 3), (2, 1), (3, 1), (2, 3), (1, 2), (1, 3), (2, 3), (1, 2), (3, 1), (3, 2), (1, 2), (1, 3), (2, 3), (2, 1), (3, 1), (2, 3), (1, 2), (1, 3), (2, 3), (2, 1), (3, 1), (3, 2), (1, 2), (3, 1), (2, 3), (2, 1), (3, 1), (3, 2), (1, 2), (1, 3), (2, 3), (1, 2), (3, 1), (3, 2), (1, 2), (3, 1), (2, 3), (2, 1), (3, 1), (2, 3), (1, 2), (1, 3), (2, 3), (2, 1), (3, 1), (3, 2), (1, 2), (3, 1), (2, 3), (2, 1), (3, 1), (3, 2), (1, 2), (1, 3), (2, 3), (1, 2), (3, 1), (3, 2), (1, 2), (1, 3), (2, 3), (2, 1), (3, 1), (2, 3), (1, 2), (1, 3), (2, 3), (1, 2), (3, 1), (3, 2), (1, 2), (3, 1), (2, 3), (2, 1), (3, 1), (3, 2), (1, 2), (1, 3), (2, 3), (1, 2), (3, 1), (3, 2), (1, 2), (1, 3), (2, 3), (2, 1), (3, 1), (2, 3), (1, 2), (1, 3), (2, 3), (2, 1), (3, 1), (3, 2), (1, 2), (3, 1), (2, 3), (2, 1), (3, 1), (2, 3), (1, 2), (1, 3), (2, 3), (1, 2), (3, 1), (3, 2), (1, 2), (1, 3), (2, 3), (2, 1), (3, 1), (2, 3), (1, 2), (1, 3), (2, 3), (1, 2), (3, 1), (3, 2), (1, 2), (3, 1), (2, 3), (2, 1), (3, 1), (3, 2), (1, 2), (1, 3), (2, 3), (1, 2), (3, 1), (3, 2), (1, 2), (3, 1), (2, 3), (2, 1), (3, 1), (2, 3), (1, 2), (1, 3), (2, 3), (2, 1), (3, 1), (3, 2), (1, 2), (3, 1), (2, 3), (2, 1), (3, 1), (3, 2), (1, 2), (1, 3), (2, 3), (1, 2), (3, 1), (3, 2), (1, 2), (1, 3), (2, 3), (2, 1), (3, 1), (2, 3), (1, 2), (1, 3), (2, 3), (1, 2), (3, 1), (3, 2), (1, 2), (3, 1), (2, 3), (2, 1), (3, 1), (3, 2), (1, 2), (1, 3), (2, 3), (1, 2), (3, 1), (3, 2), (1, 2), (1, 3), (2, 3), (2, 1), (3, 1), (2, 3), (1, 2), (1, 3), (2, 3), (2, 1), (3, 1), (3, 2), (1, 2), (3, 1), (2, 3), (2, 1), (3, 1), (2, 3), (1, 2), (1, 3), (2, 3), (1, 2), (3, 1), (3, 2), (1, 2), (1, 3), (2, 3), (2, 1), (3, 1), (2, 3), (1, 2), (1, 3), (2, 3), (2, 1), (3, 1), (3, 2), (1, 2), (3, 1), (2, 3), (2, 1), (3, 1), (3, 2), (1, 2), (1, 3), (2, 3), (1, 2), (3, 1), (3, 2), (1, 2), (3, 1), (2, 3), (2, 1), (3, 1), (2, 3), (1, 2), (1, 3), (2, 3), (2, 1), (3, 1), (3, 2), (1, 2), (3, 1), (2, 3), (2, 1), (3, 1), (2, 3), (1, 2), (1, 3), (2, 3), (1, 2), (3, 1), (3, 2), (1, 2), (1, 3), (2, 3), (2, 1), (3, 1), (2, 3), (1, 2), (1, 3), (2, 3), (1, 2), (3, 1), (3, 2), (1, 2), (3, 1), (2, 3), (2, 1), (3, 1), (3, 2), (1, 2), (1, 3), (2, 3), (1, 2), (3, 1), (3, 2), (1, 2), (1, 3), (2, 3), (2, 1), (3, 1), (2, 3), (1, 2), (1, 3), (2, 3), (2, 1), (3, 1), (3, 2), (1, 2), (3, 1), (2, 3), (2, 1), (3, 1), (2, 3), (1, 2), (1, 3), (2, 3), (1, 2), (3, 1), (3, 2), (1, 2), (1, 3), (2, 3), (2, 1), (3, 1), (2, 3), (1, 2), (1, 3), (2, 3), (2, 1), (3, 1), (3, 2), (1, 2), (3, 1), (2, 3), (2, 1), (3, 1), (3, 2), (1, 2), (1, 3), (2, 3), (1, 2), (3, 1), (3, 2), (1, 2), (3, 1), (2, 3), (2, 1), (3, 1), (2, 3), (1, 2), (1, 3), (2, 3), (2, 1), (3, 1), (3, 2), (1, 2), (3, 1), (2, 3), (2, 1), (3, 1), (3, 2), (1, 2), (1, 3), (2, 3), (1, 2), (3, 1), (3, 2), (1, 2), (1, 3), (2, 3), (2, 1), (3, 1), (2, 3), (1, 2), (1, 3), (2, 3), (1, 2), (3, 1), (3, 2), (1, 2), (3, 1), (2, 3), (2, 1), (3, 1), (3, 2), (1, 2), (1, 3), (2, 3), (1, 2), (3, 1), (3, 2), (1, 2), (3, 1), (2, 3), (2, 1), (3, 1), (2, 3), (1, 2), (1, 3), (2, 3), (2, 1), (3, 1), (3, 2), (1, 2), (3, 1), (2, 3), (2, 1), (3, 1), (2, 3), (1, 2), (1, 3), (2, 3), (1, 2), (3, 1), (3, 2), (1, 2), (1, 3), (2, 3), (2, 1), (3, 1), (2, 3), (1, 2), (1, 3), (2, 3), (2, 1), (3, 1), (3, 2), (1, 2), (3, 1), (2, 3), (2, 1), (3, 1), (3, 2), (1, 2), (1, 3), (2, 3), (1, 2), (3, 1), (3, 2), (1, 2), (3, 1), (2, 3), (2, 1), (3, 1), (2, 3), (1, 2), (1, 3), (2, 3), (2, 1), (3, 1), (3, 2), (1, 2), (3, 1), (2, 3), (2, 1), (3, 1), (2, 3), (1, 2), (1, 3), (2, 3), (1, 2), (3, 1), (3, 2), (1, 2), (1, 3), (2, 3), (2, 1), (3, 1), (2, 3), (1, 2), (1, 3), (2, 3), (1, 2), (3, 1), (3, 2), (1, 2), (3, 1), (2, 3), (2, 1), (3, 1), (3, 2), (1, 2), (1, 3), (2, 3), (1, 2), (3, 1), (3, 2), (1, 2), (1, 3), (2, 3), (2, 1), (3, 1), (2, 3), (1, 2), (1, 3), (2, 3), (2, 1), (3, 1), (3, 2), (1, 2), (3, 1), (2, 3), (2, 1), (3, 1), (2, 3), (1, 2), (1, 3), (2, 3), (1, 2), (3, 1), (3, 2), (1, 2), (1, 3), (2, 3), (2, 1), (3, 1), (2, 3), (1, 2), (1, 3), (2, 3), (1, 2), (3, 1), (3, 2), (1, 2), (3, 1), (2, 3), (2, 1), (3, 1), (3, 2), (1, 2), (1, 3), (2, 3), (1, 2), (3, 1), (3, 2), (1, 2), (3, 1), (2, 3), (2, 1), (3, 1), (2, 3), (1, 2), (1, 3), (2, 3), (2, 1), (3, 1), (3, 2), (1, 2), (3, 1), (2, 3), (2, 1), (3, 1), (3, 2), (1, 2), (1, 3), (2, 3), (1, 2), (3, 1), (3, 2), (1, 2), (1, 3), (2, 3), (2, 1), (3, 1), (2, 3), (1, 2), (1, 3), (2, 3), (1, 2), (3, 1), (3, 2), (1, 2), (3, 1), (2, 3), (2, 1), (3, 1), (3, 2), (1, 2), (1, 3), (2, 3), (1, 2), (3, 1), (3, 2), (1, 2), (1, 3), (2, 3), (2, 1), (3, 1), (2, 3), (1, 2), (1, 3), (2, 3), (2, 1), (3, 1), (3, 2), (1, 2), (3, 1), (2, 3), (2, 1), (3, 1), (2, 3), (1, 2), (1, 3), (2, 3), (1, 2), (3, 1), (3, 2), (1, 2), (1, 3), (2, 3), (2, 1), (3, 1), (2, 3), (1, 2), (1, 3), (2, 3), (2, 1), (3, 1), (3, 2), (1, 2), (3, 1), (2, 3), (2, 1), (3, 1), (3, 2), (1, 2), (1, 3), (2, 3), (1, 2), (3, 1), (3, 2), (1, 2), (3, 1), (2, 3), (2, 1), (3, 1), (2, 3), (1, 2), (1, 3), (2, 3), (2, 1), (3, 1), (3, 2), (1, 2), (3, 1), (2, 3), (2, 1), (3, 1), (2, 3), (1, 2), (1, 3), (2, 3), (1, 2), (3, 1), (3, 2), (1, 2), (1, 3), (2, 3), (2, 1), (3, 1), (2, 3), (1, 2), (1, 3), (2, 3), (1, 2), (3, 1), (3, 2), (1, 2), (3, 1), (2, 3), (2, 1), (3, 1), (3, 2), (1, 2), (1, 3), (2, 3), (1, 2), (3, 1), (3, 2), (1, 2), (1, 3), (2, 3), (2, 1), (3, 1), (2, 3), (1, 2), (1, 3), (2, 3), (2, 1), (3, 1), (3, 2), (1, 2), (3, 1), (2, 3), (2, 1), (3, 1), (2, 3), (1, 2), (1, 3), (2, 3), (1, 2), (3, 1), (3, 2), (1, 2), (1, 3), (2, 3), (2, 1), (3, 1), (2, 3), (1, 2), (1, 3), (2, 3)]\n    assert candidate(1) == [(1, 3)]\n    assert candidate(15) == [(1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (3, 1), (2, 1), (3, 2), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3), (2, 1), (3, 2), (3, 1), (2, 1), (2, 3), (1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3)]\n", "language": "python"}
{"task_id": "fca6893b-7f1b-461d-8eec-39aa7199ab345297052629345870880", "prompt": "My task is to implement a function that works as a standalone piece of code. I'll provide a complete solution within the function boundaries, defining any helper methods or classes within the main function. I'll strictly use only the libraries that were imported in the original problem.\n\n```python\nfrom typing import List, Tuple\nfrom typing import List\n\ndef decode_alien_message(message: str, code_book: List[Tuple[str, str]]) -> str:\n    \"\"\"\n    Decode an alien message using a provided code book.\n\n    This function takes an encoded alien message and a code book, which is a list of\n    tuples containing encoded and decoded character pairs. It then decodes the message\n    by replacing each encoded character with its corresponding decoded character.\n\n    Args:\n    message (str): The encoded alien message\n    code_book (List[Tuple[str, str]]): A list of tuples, where each tuple contains\n                                       (encoded_char, decoded_char)\n\n    Returns:\n    str: The decoded message\n\n\n    [EXAMPLES]\n    \n    assert candidate(\"abcde\", [(\"a\", \"z\"), (\"b\", \"y\"), (\"c\", \"x\"), (\"d\", \"w\"), (\"e\", \"v\")]) == 'zyxwv'\n    assert candidate(\"!@#$%^&*()\", [(\"!\", \"0\"), (\"@\", \"1\"), (\"#\", \"2\"), (\"$\", \"3\"), (\"%\", \"4\"), (\"^\", \"5\"), (\"&\", \"6\"), (\"*\", \"7\"), (\"(\", \"8\"), (\")\", \"9\")]) == '0123456789'\n\n    [/EXAMPLES]\n    \"\"\"\n```\n", "entry_point": "decode_alien_message", "solution": "from typing import List, Tuple\nfrom typing import List\n\ndef decode_alien_message(message: str, code_book: List[Tuple[str, str]]) -> str:\n    \"\"\"\n    Decode an alien message using a provided code book.\n\n    This function takes an encoded alien message and a code book, which is a list of\n    tuples containing encoded and decoded character pairs. It then decodes the message\n    by replacing each encoded character with its corresponding decoded character.\n\n    Args:\n    message (str): The encoded alien message\n    code_book (List[Tuple[str, str]]): A list of tuples, where each tuple contains\n                                       (encoded_char, decoded_char)\n\n    Returns:\n    str: The decoded message\n\n\n    [EXAMPLES]\n    \n    assert candidate(\"abcde\", [(\"a\", \"z\"), (\"b\", \"y\"), (\"c\", \"x\"), (\"d\", \"w\"), (\"e\", \"v\")]) == 'zyxwv'\n    assert candidate(\"!@#$%^&*()\", [(\"!\", \"0\"), (\"@\", \"1\"), (\"#\", \"2\"), (\"$\", \"3\"), (\"%\", \"4\"), (\"^\", \"5\"), (\"&\", \"6\"), (\"*\", \"7\"), (\"(\", \"8\"), (\")\", \"9\")]) == '0123456789'\n\n    [/EXAMPLES]\n    \"\"\"\n    # Create a dictionary from the code book for efficient lookup\n    decode_dict = dict(code_book)\n    \n    # Initialize an empty list to store decoded characters\n    decoded_chars = []\n    \n    # Iterate through each character in the message\n    for char in message:\n        # If the character is in the decode dictionary, append its decoded version\n        # Otherwise, append the original character\n        decoded_chars.append(decode_dict.get(char, char))\n    \n    # Join the decoded characters into a string and return\n    return ''.join(decoded_chars)\n\n", "test": "def check(candidate):\n    assert candidate(\"123123\", [(\"1\", \"A\"), (\"2\", \"B\"), (\"3\", \"C\")]) == 'ABCABC'\n    assert candidate(\"!@#$%^\", [(\"!\", \"H\"), (\"@\", \"e\"), (\"#\", \"l\"), (\"$\", \"l\"), (\"%\", \"o\"), (\"^\", \" \")]) == 'Hello '\n    assert candidate(\"abcde\", [(\"a\", \"z\"), (\"b\", \"y\"), (\"c\", \"x\"), (\"d\", \"w\"), (\"e\", \"v\")]) == 'zyxwv'\n    assert candidate(\"HELLO\", [(\"H\", \"h\"), (\"E\", \"e\"), (\"L\", \"l\"), (\"O\", \"o\")]) == 'hello'\n    assert candidate(\"aabbcc\", [(\"a\", \"1\"), (\"b\", \"2\"), (\"c\", \"3\")]) == '112233'\n    assert candidate(\"123\", [(\"1\", \"S\"), (\"2\", \"O\"), (\"3\", \"S\")]) == 'SOS'\n    assert candidate(\"!@#$%^&*()\", [(\"!\", \"0\"), (\"@\", \"1\"), (\"#\", \"2\"), (\"$\", \"3\"), (\"%\", \"4\"), (\"^\", \"5\"), (\"&\", \"6\"), (\"*\", \"7\"), (\"(\", \"8\"), (\")\", \"9\")]) == '0123456789'\n    assert candidate(\"ABCD\", [(\"A\", \"1\"), (\"B\", \"2\"), (\"C\", \"3\"), (\"D\", \"4\")]) == '1234'\n    assert candidate(\"abcABC\", [(\"a\", \"1\"), (\"b\", \"2\"), (\"c\", \"3\"), (\"A\", \"4\"), (\"B\", \"5\"), (\"C\", \"6\")]) == '123456'\n    assert candidate(\"12345\", [(\"1\", \"one\"), (\"2\", \"two\"), (\"3\", \"three\"), (\"4\", \"four\"), (\"5\", \"five\")]) == 'onetwothreefourfive'\n", "language": "python"}
{"task_id": "325f0954-d72d-4f19-9921-4a0b132647a22486479978788069152", "prompt": "Acting as your coding helper, I'll complete your function so it's ready to run. I'll deliver a code block containing just the finished function, utilizing only the libraries mentioned in the problem. If I need additional functionality, I'll define those helper functions or classes within the main function you've provided.\n\n```python\nfrom typing import List\n\ndef optimize_solar_panels(roof_layout: List[List[int]]) -> int:\n    \"\"\"\n    You're designing a solar panel installation for a neighborhood. Each house's roof is represented\n    by a grid, where 1 indicates a suitable spot for a panel and 0 indicates an unsuitable spot.\n    Your goal is to find the largest square area of contiguous suitable spots on each roof.\n\n    :param roof_layout: A 2D list of integers representing the roof layout.\n    :return: An integer representing the side length of the largest square of suitable spots.\n\n\n    [EXAMPLES]\n    \n    assert candidate([[1,1,1,1,1],[1,1,1,1,1],[1,1,0,1,1],[1,1,1,1,1],[1,1,1,1,1]]) == 2\n    assert candidate([[1,1,1],[1,1,1],[1,1,1]]) == 3\n\n    [/EXAMPLES]\n    \"\"\"\n```\n", "entry_point": "optimize_solar_panels", "solution": "from typing import List\n\ndef optimize_solar_panels(roof_layout: List[List[int]]) -> int:\n    \"\"\"\n    You're designing a solar panel installation for a neighborhood. Each house's roof is represented\n    by a grid, where 1 indicates a suitable spot for a panel and 0 indicates an unsuitable spot.\n    Your goal is to find the largest square area of contiguous suitable spots on each roof.\n\n    :param roof_layout: A 2D list of integers representing the roof layout.\n    :return: An integer representing the side length of the largest square of suitable spots.\n\n\n    [EXAMPLES]\n    \n    assert candidate([[1,1,1,1,1],[1,1,1,1,1],[1,1,0,1,1],[1,1,1,1,1],[1,1,1,1,1]]) == 2\n    assert candidate([[1,1,1],[1,1,1],[1,1,1]]) == 3\n\n    [/EXAMPLES]\n    \"\"\"\n    if not roof_layout or not roof_layout[0]:\n        return 0\n\n    rows, cols = len(roof_layout), len(roof_layout[0])\n    dp = [[0] * (cols + 1) for _ in range(rows + 1)]\n    max_side = 0\n\n    for i in range(1, rows + 1):\n        for j in range(1, cols + 1):\n            if roof_layout[i-1][j-1] == 1:\n                dp[i][j] = min(dp[i-1][j], dp[i][j-1], dp[i-1][j-1]) + 1\n                max_side = max(max_side, dp[i][j])\n\n    return max_side\n\n", "test": "def check(candidate):\n    assert candidate([[0,0],[0,0]]) == 0\n    assert candidate([[1,1,1,1],[1,1,1,1],[1,1,1,1],[1,1,1,1]]) == 4\n    assert candidate([[0,0,0,0,0,0],[0,0,0,0,0,0],[0,0,0,0,0,0],[0,0,0,0,0,0],[0,0,0,0,0,0]]) == 0\n    assert candidate([[1,1,1],[1,1,1],[1,1,1]]) == 3\n    assert candidate([[1],[1],[1],[1],[1],[1],[1],[1],[1],[1]]) == 1\n    assert candidate([[0]]) == 0\n    assert candidate([[1,1,1,1,1],[1,1,1,1,1],[1,1,0,1,1],[1,1,1,1,1],[1,1,1,1,1]]) == 2\n    assert candidate([[1,1,1,1,1],[1,0,0,0,1],[1,0,1,0,1],[1,0,0,0,1],[1,1,1,1,1]]) == 1\n    assert candidate([[1,1,1,1,1],[1,1,1,1,1],[1,1,1,1,1],[1,1,1,1,1],[1,1,1,1,0]]) == 4\n    assert candidate([[1,0,1,0,1,0,1,0,1,0],[0,1,0,1,0,1,0,1,0,1]]) == 1\n", "language": "python"}
{"task_id": "66c32c5a-0ab9-4375-915e-e16c1c7955f2-12519183587340183", "prompt": "Based on the docstring description, here's the full function implementation in one code block:\n\n```python\nfrom typing import List, Tuple\n\ndef knapsack(values: List[int], weights: List[int], capacity: int) -> Tuple[int, List[int]]:\n    \"\"\"A treasure hunter has discovered a set of ancient artifacts, each with its own value and weight.\n    However, their knapsack can only hold a limited weight. They want to maximize the total value of\n    the artifacts they can carry without exceeding the weight limit of their knapsack.\n\n    This function solves the 0/1 Knapsack problem, returning the maximum value that can be achieved\n    and a list of indices representing which items to include in the knapsack.\n\n    The solution uses dynamic programming to build a table of optimal values for different capacities\n    and items, then backtracks to determine which items to include.\n\n\n    [EXAMPLES]\n    \n    assert candidate([30, 40, 50, 60], [3, 4, 5, 6], 10) == (100, [1, 3])\n    assert candidate([10, 20, 30], [1, 2, 3], 6) == (60, [0, 1, 2])\n\n    [/EXAMPLES]\n    \"\"\"\n```\n", "entry_point": "knapsack", "solution": "from typing import List, Tuple\n\ndef knapsack(values: List[int], weights: List[int], capacity: int) -> Tuple[int, List[int]]:\n    \"\"\"A treasure hunter has discovered a set of ancient artifacts, each with its own value and weight.\n    However, their knapsack can only hold a limited weight. They want to maximize the total value of\n    the artifacts they can carry without exceeding the weight limit of their knapsack.\n\n    This function solves the 0/1 Knapsack problem, returning the maximum value that can be achieved\n    and a list of indices representing which items to include in the knapsack.\n\n    The solution uses dynamic programming to build a table of optimal values for different capacities\n    and items, then backtracks to determine which items to include.\n\n\n    [EXAMPLES]\n    \n    assert candidate([30, 40, 50, 60], [3, 4, 5, 6], 10) == (100, [1, 3])\n    assert candidate([10, 20, 30], [1, 2, 3], 6) == (60, [0, 1, 2])\n\n    [/EXAMPLES]\n    \"\"\"\n    n = len(values)\n    # Create a 2D table to store the maximum values for different capacities and items\n    dp = [[0 for _ in range(capacity + 1)] for _ in range(n + 1)]\n\n    # Fill the dp table\n    for i in range(1, n + 1):\n        for w in range(capacity + 1):\n            if weights[i-1] <= w:\n                dp[i][w] = max(dp[i-1][w], dp[i-1][w-weights[i-1]] + values[i-1])\n            else:\n                dp[i][w] = dp[i-1][w]\n\n    # Backtrack to find which items are included\n    included_items = []\n    w = capacity\n    for i in range(n, 0, -1):\n        if dp[i][w] != dp[i-1][w]:\n            included_items.append(i - 1)\n            w -= weights[i-1]\n\n    # Reverse the list to get items in ascending order of indices\n    included_items.reverse()\n\n    return dp[n][capacity], included_items\n\n", "test": "def check(candidate):\n    assert candidate([1, 1, 1], [1, 1, 1], 2) == (2, [0, 1])\n    assert candidate([10, 20, 30, 40, 50], [1, 2, 3, 4, 5], 5) == (50, [1, 2])\n    assert candidate([1000, 2000, 3000, 4000], [1, 3, 4, 5], 7) == (5000, [1, 2])\n    assert candidate([1, 2, 4, 8, 16, 32, 64, 128], [1, 2, 3, 4, 5, 6, 7, 8], 20) == (208, [4, 6, 7])\n    assert candidate([100, 200, 300, 400, 500], [5, 10, 15, 20, 25], 30) == (600, [0, 1, 2])\n    assert candidate([10, 20, 30], [1, 2, 3], 6) == (60, [0, 1, 2])\n    assert candidate([30, 40, 50, 60], [3, 4, 5, 6], 10) == (100, [1, 3])\n    assert candidate([5, 10, 15, 20], [2, 3, 4, 5], 10) == (35, [0, 1, 3])\n    assert candidate([100], [10], 10) == (100, [0])\n    assert candidate([50, 100, 150, 200, 250], [8, 16, 24, 32, 40], 64) == (400, [0, 2, 3])\n", "language": "python"}
{"task_id": "88e68f1e-f024-4997-82bb-541910055db63493167461256064036", "prompt": "Based on the docstring information, I'll implement the remainder of the function. The function name and parameters will remain as given, with the full code in a single block.\n\n```python\nfrom typing import List\n\ndef analyze_stock_prices(prices: List[float], window: int) -> List[float]:\n    \"\"\"\n    Analyze stock price trends using a moving average technique.\n\n    This function takes a list of daily stock prices and calculates the moving average\n    over a specified window size. It returns a list of moving averages, which can be\n    used to identify trends in stock price movements.\n\n    The function utilizes list comprehension and slicing to efficiently compute\n    the moving averages for each window of prices.\n\n    Args:\n    prices (List[float]): A list of daily stock prices.\n    window (int): The size of the moving average window.\n\n    Returns:\n    List[float]: A list of moving averages for the given stock prices.\n\n\n    [EXAMPLES]\n    \n    assert candidate([50.0, 51.0, 52.0, 53.0, 54.0, 55.0], 4) == [51.5, 52.5, 53.5]\n    assert candidate([1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0], 7) == [1.0]\n\n    [/EXAMPLES]\n    \"\"\"\n```\n", "entry_point": "analyze_stock_prices", "solution": "from typing import List\n\ndef analyze_stock_prices(prices: List[float], window: int) -> List[float]:\n    \"\"\"\n    Analyze stock price trends using a moving average technique.\n\n    This function takes a list of daily stock prices and calculates the moving average\n    over a specified window size. It returns a list of moving averages, which can be\n    used to identify trends in stock price movements.\n\n    The function utilizes list comprehension and slicing to efficiently compute\n    the moving averages for each window of prices.\n\n    Args:\n    prices (List[float]): A list of daily stock prices.\n    window (int): The size of the moving average window.\n\n    Returns:\n    List[float]: A list of moving averages for the given stock prices.\n\n\n    [EXAMPLES]\n    \n    assert candidate([50.0, 51.0, 52.0, 53.0, 54.0, 55.0], 4) == [51.5, 52.5, 53.5]\n    assert candidate([1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0], 7) == [1.0]\n\n    [/EXAMPLES]\n    \"\"\"\n    if len(prices) < window:\n        return []\n\n    # Calculate moving averages using list comprehension and slicing\n    moving_averages = [sum(prices[i:i+window]) / window for i in range(len(prices) - window + 1)]\n\n    # Round the results to two decimal places\n    return [round(avg, 2) for avg in moving_averages]\n\n", "test": "def check(candidate):\n    assert candidate([1.5, 2.5, 3.5, 4.5, 5.5], 4) == [3.0, 4.0]\n    assert candidate([100.0, 90.0, 80.0, 70.0, 60.0], 2) == [95.0, 85.0, 75.0, 65.0]\n    assert candidate([50.0, 50.0, 50.0, 50.0, 50.0], 3) == [50.0, 50.0, 50.0]\n    assert candidate([1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0], 7) == [1.0]\n    assert candidate([1000.0, 995.5, 1005.0, 1010.0, 1007.5], 2) == [997.75, 1000.25, 1007.5, 1008.75]\n    assert candidate([50.0, 51.0, 52.0, 53.0, 54.0, 55.0], 4) == [51.5, 52.5, 53.5]\n    assert candidate([1000.0, 1000.0, 1000.0, 1000.0, 1000.0], 3) == [1000.0, 1000.0, 1000.0]\n    assert candidate([10.0, 20.0, 30.0, 40.0, 50.0], 2) == [15.0, 25.0, 35.0, 45.0]\n    assert candidate([100.0, 200.0, 300.0, 400.0, 500.0], 3) == [200.0, 300.0, 400.0]\n    assert candidate([5.5, 5.4, 5.3, 5.2, 5.1, 5.0], 5) == [5.3, 5.2]\n", "language": "python"}
{"task_id": "9d1b19a6-b404-466e-8dc3-d00d5c788150-3958253073282013301", "prompt": "My task is to write a complete, executable function in one code block. I won't add code outside the function scope, will stick to libraries specified in the problem, and will include any necessary helper functions or classes within the main function definition.\n\n```python\ndef knapsack(weights: list, values: list, capacity: int) -> int:\n    \"\"\"\n    A space explorer needs to choose the most valuable items to take on a mission, given weight constraints of the spacecraft.\n    Each item has a weight and a value, and the spacecraft has a maximum weight capacity.\n\n    Given a list of item weights, a list of corresponding item values, and the weight capacity of the spacecraft,\n    determine the maximum value of items that can be taken on the mission without exceeding the weight limit.\n\n    This function uses recursion and memoization to solve the 0/1 Knapsack problem.\n\n\n    [EXAMPLES]\n    \n    assert candidate([1, 3, 4, 5], [1, 4, 5, 7], 7) == 9\n    assert candidate([1, 2, 3, 4, 5, 6, 7, 8, 9, 10], [10, 9, 8, 7, 6, 5, 4, 3, 2, 1], 30) == 49\n\n    [/EXAMPLES]\n    \"\"\"\n```\n", "entry_point": "knapsack", "solution": "def knapsack(weights: list, values: list, capacity: int) -> int:\n    \"\"\"\n    A space explorer needs to choose the most valuable items to take on a mission, given weight constraints of the spacecraft.\n    Each item has a weight and a value, and the spacecraft has a maximum weight capacity.\n\n    Given a list of item weights, a list of corresponding item values, and the weight capacity of the spacecraft,\n    determine the maximum value of items that can be taken on the mission without exceeding the weight limit.\n\n    This function uses recursion and memoization to solve the 0/1 Knapsack problem.\n\n\n    [EXAMPLES]\n    \n    assert candidate([1, 3, 4, 5], [1, 4, 5, 7], 7) == 9\n    assert candidate([1, 2, 3, 4, 5, 6, 7, 8, 9, 10], [10, 9, 8, 7, 6, 5, 4, 3, 2, 1], 30) == 49\n\n    [/EXAMPLES]\n    \"\"\"\n    def knapsack_recursive(index, current_capacity, memo):\n        if index == len(weights) or current_capacity == 0:\n            return 0\n        \n        if (index, current_capacity) in memo:\n            return memo[(index, current_capacity)]\n        \n        if weights[index] > current_capacity:\n            result = knapsack_recursive(index + 1, current_capacity, memo)\n        else:\n            include = values[index] + knapsack_recursive(index + 1, current_capacity - weights[index], memo)\n            exclude = knapsack_recursive(index + 1, current_capacity, memo)\n            result = max(include, exclude)\n        \n        memo[(index, current_capacity)] = result\n        return result\n\n    memo = {}\n    return knapsack_recursive(0, capacity, memo)\n\n", "test": "def check(candidate):\n    assert candidate([1], [10], 2) == 10\n    assert candidate([3, 2, 4], [4, 3, 5], 6) == 8\n    assert candidate([1, 1, 1, 1, 1, 1, 1, 1, 1, 1], [10, 20, 30, 40, 50, 60, 70, 80, 90, 100], 5) == 400\n    assert candidate([1, 3, 4, 5], [1, 4, 5, 7], 7) == 9\n    assert candidate([5, 4, 6, 3], [10, 40, 30, 50], 10) == 90\n    assert candidate([5, 10, 15, 20, 25], [25, 20, 15, 10, 5], 50) == 70\n    assert candidate([1, 2, 3, 4, 5, 6, 7, 8, 9, 10], [10, 9, 8, 7, 6, 5, 4, 3, 2, 1], 30) == 49\n    assert candidate([2, 3, 4, 5], [3, 4, 5, 6], 5) == 7\n    assert candidate([10, 20, 30, 40, 50], [50, 120, 150, 200, 250], 100) == 520\n    assert candidate([1, 2, 3], [10, 15, 40], 6) == 65\n", "language": "python"}
{"task_id": "ecdfd1ed-baa1-4c07-9124-3ab3aa21cd66-3583541122796638781", "prompt": "Let me complete that code for you in one cohesive block.\n\n```python\nfrom typing import List, Tuple\nfrom typing import List, Tuple, Dict\n\ndef decode_ancient_script(symbols: List[str], key: Dict[str, str]) -> Tuple[str, int]:\n    \"\"\"\n    Decipher an ancient script using a provided decoding key and count the number of vowels in the decoded message.\n\n    You are an archaeologist who has discovered an ancient script carved into stone. Your task is to decode the message\n    using a provided key and analyze the resulting text. The function should return the decoded message and the count of\n    vowels (a, e, i, o, u) in the message.\n\n    :param symbols: A list of symbols representing the encoded message\n    :param key: A dictionary mapping symbols to their corresponding letters\n    :return: A tuple containing the decoded message (string) and the vowel count (integer)\n\n\n    [EXAMPLES]\n    \n    assert candidate(['A'], {'A': ''}) == ('', 0)\n    assert candidate(['A', 'A', 'A', 'A', 'A'], {'A': 'a'}) == ('aaaaa', 5)\n\n    [/EXAMPLES]\n    \"\"\"\n```\n", "entry_point": "decode_ancient_script", "solution": "from typing import List, Tuple\nfrom typing import List, Tuple, Dict\n\ndef decode_ancient_script(symbols: List[str], key: Dict[str, str]) -> Tuple[str, int]:\n    \"\"\"\n    Decipher an ancient script using a provided decoding key and count the number of vowels in the decoded message.\n\n    You are an archaeologist who has discovered an ancient script carved into stone. Your task is to decode the message\n    using a provided key and analyze the resulting text. The function should return the decoded message and the count of\n    vowels (a, e, i, o, u) in the message.\n\n    :param symbols: A list of symbols representing the encoded message\n    :param key: A dictionary mapping symbols to their corresponding letters\n    :return: A tuple containing the decoded message (string) and the vowel count (integer)\n\n\n    [EXAMPLES]\n    \n    assert candidate(['A'], {'A': ''}) == ('', 0)\n    assert candidate(['A', 'A', 'A', 'A', 'A'], {'A': 'a'}) == ('aaaaa', 5)\n\n    [/EXAMPLES]\n    \"\"\"\n    def count_vowels(text: str) -> int:\n        vowels = set('aeiou')\n        return sum(1 for char in text.lower() if char in vowels)\n\n    decoded_message = ''.join(key.get(symbol, symbol) for symbol in symbols)\n    vowel_count = count_vowels(decoded_message)\n\n    return decoded_message, vowel_count\n\n", "test": "def check(candidate):\n    assert candidate(['X', 'Y', 'Z'], {'X': 'x', 'Y': 'y', 'Z': 'z'}) == ('xyz', 0)\n    assert candidate(['A', 'A', 'A', 'A', 'A'], {'A': 'a'}) == ('aaaaa', 5)\n    assert candidate(['X', 'Y', 'Z'], {'A': 'x', 'B': 'y', 'C': 'z'}) == ('XYZ', 0)\n    assert candidate(['1', '2', '3'], {'1': 'one', '2': 'two', '3': 'three'}) == ('onetwothree', 5)\n    assert candidate(['Q', 'W', 'E', 'R', 'T', 'Y'], {'Q': 'q', 'W': 'w', 'E': 'e', 'R': 'r', 'T': 't', 'Y': 'y'}) == ('qwerty', 1)\n    assert candidate([], {}) == ('', 0)\n    assert candidate(['A'], {'A': ''}) == ('', 0)\n    assert candidate(['A', 'B', 'C'], {'A': 'a', 'B': 'b', 'C': 'c', 'A': 'd'}) == ('dbc', 0)\n    assert candidate(['A', 'B', 'C', 'D', 'E'], {'A': 'a', 'B': 'e', 'C': 'i', 'D': 'o', 'E': 'u'}) == ('aeiou', 5)\n    assert candidate(['\u2605', '\u25ef', '\u25b2', '\u25a0', '\u25cf', '\u25c6'], {'\u2605': 'p', '\u25ef': 'y', '\u25b2': 't', '\u25a0': 'h', '\u25cf': 'o', '\u25c6': 'n'}) == ('python', 1)\n", "language": "python"}
{"task_id": "67dda6ec-f705-4aea-a8e2-fb382720842c-7361611433082858000", "prompt": "My role as a coding assistant is to complete your given function to ensure it's executable in a code block. I will only use libraries that are imported in the problem statement and will define any additional helper functions or classes inside the main function, not separately.\n\n```python\nfrom typing import List\n\ndef decode_alien_message(encoded_message: str, codebook: List[str]) -> str:\n    \"\"\"\n    An alien civilization has sent an encoded message to Earth. Scientists have determined\n    that the message is encoded using a variable-length prefix code, where no codeword\n    is a prefix of another. Your task is to decode the message using the provided codebook.\n\n    The encoded message is a string of digits, and the codebook is a list of valid codewords.\n    Each codeword in the codebook corresponds to a letter in the alien alphabet.\n\n    This function should return the decoded message as a string of letters.\n\n    Args:\n    encoded_message (str): The encoded message as a string of digits\n    codebook (List[str]): A list of valid codewords, where each codeword is a string of digits\n\n    Returns:\n    str: The decoded message as a string of letters\n\n\n    [EXAMPLES]\n    \n    assert candidate(\"110011001100\", [\"11\", \"00\"]) == 'ABABAB'\n    assert candidate(\"123321123321\", [\"123\", \"321\"]) == 'ABAB'\n\n    [/EXAMPLES]\n    \"\"\"\n```\n", "entry_point": "decode_alien_message", "solution": "from typing import List\n\ndef decode_alien_message(encoded_message: str, codebook: List[str]) -> str:\n    \"\"\"\n    An alien civilization has sent an encoded message to Earth. Scientists have determined\n    that the message is encoded using a variable-length prefix code, where no codeword\n    is a prefix of another. Your task is to decode the message using the provided codebook.\n\n    The encoded message is a string of digits, and the codebook is a list of valid codewords.\n    Each codeword in the codebook corresponds to a letter in the alien alphabet.\n\n    This function should return the decoded message as a string of letters.\n\n    Args:\n    encoded_message (str): The encoded message as a string of digits\n    codebook (List[str]): A list of valid codewords, where each codeword is a string of digits\n\n    Returns:\n    str: The decoded message as a string of letters\n\n\n    [EXAMPLES]\n    \n    assert candidate(\"110011001100\", [\"11\", \"00\"]) == 'ABABAB'\n    assert candidate(\"123321123321\", [\"123\", \"321\"]) == 'ABAB'\n\n    [/EXAMPLES]\n    \"\"\"\n    def build_codebook_dict(codebook):\n        return {code: chr(ord('A') + i) for i, code in enumerate(codebook)}\n    \n    codebook_dict = build_codebook_dict(codebook)\n    decoded_message = []\n    current_code = \"\"\n    \n    for digit in encoded_message:\n        current_code += digit\n        if current_code in codebook_dict:\n            decoded_message.append(codebook_dict[current_code])\n            current_code = \"\"\n    \n    return \"\".join(decoded_message)\n\n", "test": "def check(candidate):\n    assert candidate(\"9876543210\", [\"9\", \"87\", \"654\", \"3210\"]) == 'ABCD'\n    assert candidate(\"1234567890\", [\"1\", \"2\", \"3\", \"4\", \"5\", \"6\", \"7\", \"8\", \"9\", \"0\"]) == 'ABCDEFGHIJ'\n    assert candidate(\"110011001100\", [\"11\", \"00\"]) == 'ABABAB'\n    assert candidate(\"123321123321\", [\"123\", \"321\"]) == 'ABAB'\n    assert candidate(\"11110000\", [\"1111\", \"0000\"]) == 'AB'\n    assert candidate(\"111111\", [\"1\"]) == 'AAAAAA'\n    assert candidate(\"1010101010\", [\"10\"]) == 'AAAAA'\n    assert candidate(\"01230123\", [\"0\", \"1\", \"2\", \"3\"]) == 'ABCDABCD'\n    assert candidate(\"101010\", [\"1\", \"0\"]) == 'ABABAB'\n    assert candidate(\"0123456789\", [\"01\", \"23\", \"45\", \"67\", \"89\"]) == 'ABCDE'\n", "language": "python"}
{"task_id": "0205458e-6c68-49c4-9ce5-6bfa34622ecb-8227164500021980410", "prompt": "I need you to implement the function that was specified. The solution should be a complete, executable code block with no code outside the function. Only use libraries that are imported in the problem statement. Any helper functions or classes must be defined inside the main function. Please respond with exactly one code block.\n\n```python\ndef decode_alien_message(encoded_message: str) -> str:\n    \"\"\"\n    An alien civilization has sent us an encoded message. The message consists of lowercase letters\n    and numbers. Each number represents the number of times the previous letter should be repeated.\n    Decode the message to reveal its contents.\n\n    Args:\n    encoded_message (str): The encoded message from the aliens.\n\n    Returns:\n    str: The decoded message.\n\n\n    [EXAMPLES]\n    \n    assert candidate(\"z9y8x7w6v5u4t3s2r1\") == 'zzzzzzzzzyyyyyyyyxxxxxxxwwwwwwvvvvvuuuutttssr'\n    assert candidate(\"a1b2c3\") == 'abbccc'\n\n    [/EXAMPLES]\n    \"\"\"\n```\n", "entry_point": "decode_alien_message", "solution": "def decode_alien_message(encoded_message: str) -> str:\n    \"\"\"\n    An alien civilization has sent us an encoded message. The message consists of lowercase letters\n    and numbers. Each number represents the number of times the previous letter should be repeated.\n    Decode the message to reveal its contents.\n\n    Args:\n    encoded_message (str): The encoded message from the aliens.\n\n    Returns:\n    str: The decoded message.\n\n\n    [EXAMPLES]\n    \n    assert candidate(\"z9y8x7w6v5u4t3s2r1\") == 'zzzzzzzzzyyyyyyyyxxxxxxxwwwwwwvvvvvuuuutttssr'\n    assert candidate(\"a1b2c3\") == 'abbccc'\n\n    [/EXAMPLES]\n    \"\"\"\n    decoded_message = []\n    current_letter = ''\n    current_number = ''\n\n    for char in encoded_message:\n        if char.isalpha():\n            if current_letter and current_number:\n                decoded_message.append(current_letter * int(current_number))\n            current_letter = char\n            current_number = ''\n        elif char.isdigit():\n            current_number += char\n\n    # Handle the last group\n    if current_letter and current_number:\n        decoded_message.append(current_letter * int(current_number))\n\n    return ''.join(decoded_message)\n\n", "test": "def check(candidate):\n    assert candidate(\"z9y8x7w6v5u4t3s2r1\") == 'zzzzzzzzzyyyyyyyyxxxxxxxwwwwwwvvvvvuuuutttssr'\n    assert candidate(\"a1b2c3d4e5f6g7h8i9j10\") == 'abbcccddddeeeeeffffffggggggghhhhhhhhiiiiiiiiijjjjjjjjjj'\n    assert candidate(\"a5b4c3d2e1\") == 'aaaaabbbbcccdde'\n    assert candidate(\"a99b99\") == 'aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaabbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb'\n    assert candidate(\"a1b2c3\") == 'abbccc'\n    assert candidate(\"a0b0c0\") == ''\n    assert candidate(\"h4e2l3o1\") == 'hhhheelllo'\n    assert candidate(\"z5y4x3w2v1u1t2s3r4q5\") == 'zzzzzyyyyxxxwwvuttsssrrrrqqqqq'\n    assert candidate(\"w1o2r3l4d5\") == 'woorrrllllddddd'\n    assert candidate(\"a1\") == 'a'\n", "language": "python"}
{"task_id": "879be55b-a6c7-46aa-8315-76cc8460cd4b7055018780433581986", "prompt": "Complete the specified function that can be executed as a standalone code block. Don't include any code outside the function's boundaries. Use exclusively the libraries that were imported in the problem statement. Any helper functions or classes should be defined inside the given function.\n\n```python\ndef optimize_delivery_route(packages: list, max_weight: int, max_volume: int) -> list:\n    \"\"\"As a logistics manager for a delivery company, you need to optimize the loading of packages onto delivery trucks. Each package has a weight, volume, and value.\n    \n    Your function should take a list of tuples (weight, volume, value) representing packages, the maximum weight capacity, and the maximum volume capacity of the truck. It should return a list of indices representing the optimal selection of packages that maximizes total value without exceeding weight and volume constraints.\n    \n    Use dynamic programming to solve this problem efficiently.\n    \n\n    [EXAMPLES]\n    \n    assert candidate([(1, 2, 3), (2, 3, 4), (3, 4, 5), (4, 5, 6)], 10, 14) == [0, 1, 2, 3]\n    assert candidate([], 10, 10) == []\n\n    [/EXAMPLES]\n    \"\"\"\n```\n", "entry_point": "optimize_delivery_route", "solution": "def optimize_delivery_route(packages: list, max_weight: int, max_volume: int) -> list:\n    \"\"\"As a logistics manager for a delivery company, you need to optimize the loading of packages onto delivery trucks. Each package has a weight, volume, and value.\n    \n    Your function should take a list of tuples (weight, volume, value) representing packages, the maximum weight capacity, and the maximum volume capacity of the truck. It should return a list of indices representing the optimal selection of packages that maximizes total value without exceeding weight and volume constraints.\n    \n    Use dynamic programming to solve this problem efficiently.\n    \n\n    [EXAMPLES]\n    \n    assert candidate([(1, 2, 3), (2, 3, 4), (3, 4, 5), (4, 5, 6)], 10, 14) == [0, 1, 2, 3]\n    assert candidate([], 10, 10) == []\n\n    [/EXAMPLES]\n    \"\"\"\n    n = len(packages)\n    \n    # Create a 3D DP table\n    dp = [[[0 for _ in range(max_volume + 1)] for _ in range(max_weight + 1)] for _ in range(n + 1)]\n    \n    # Fill the DP table\n    for i in range(1, n + 1):\n        for w in range(max_weight + 1):\n            for v in range(max_volume + 1):\n                if packages[i-1][0] <= w and packages[i-1][1] <= v:\n                    dp[i][w][v] = max(dp[i-1][w][v], \n                                      dp[i-1][w-packages[i-1][0]][v-packages[i-1][1]] + packages[i-1][2])\n                else:\n                    dp[i][w][v] = dp[i-1][w][v]\n    \n    # Backtrack to find the selected packages\n    selected = []\n    w, v = max_weight, max_volume\n    for i in range(n, 0, -1):\n        if dp[i][w][v] != dp[i-1][w][v]:\n            selected.append(i-1)\n            w -= packages[i-1][0]\n            v -= packages[i-1][1]\n    \n    # Reverse the list to get the correct order\n    selected.reverse()\n    \n    return selected\n\n", "test": "def check(candidate):\n    assert candidate([(1, 2, 3), (2, 3, 4), (3, 4, 5), (4, 5, 6)], 10, 14) == [0, 1, 2, 3]\n    assert candidate([(1, 1, 1), (2, 2, 4), (3, 3, 9), (4, 4, 16), (5, 5, 25)], 10, 10) == [0, 3, 4]\n    assert candidate([(1, 1, 1000), (1000, 1000, 1)], 999, 999) == [0]\n    assert candidate([], 10, 10) == []\n    assert candidate([(1, 1, 1)], 1, 1) == [0]\n    assert candidate([(1, 5, 10), (2, 4, 9), (3, 3, 8), (4, 2, 7), (5, 1, 6)], 15, 15) == [0, 1, 2, 3, 4]\n    assert candidate([(1, 1, 1), (1, 1, 2), (1, 1, 3)], 2, 2) == [1, 2]\n    assert candidate([(2, 3, 5), (3, 4, 7), (4, 5, 10), (5, 6, 12)], 9, 13) == [0, 1, 2]\n    assert candidate([(i, 10-i, i*10) for i in range(1, 6)], 15, 25) == [2, 3, 4]\n    assert candidate([(1, 1, 1)] * 10, 5, 5) == [0, 1, 2, 3, 4]\n", "language": "python"}
{"task_id": "70552f7c-aaae-4c0c-b19a-02cda3909e10628847492172923531", "prompt": "I'll implement the remaining function code according to the docstring requirements. The complete solution will be in one code block with edge case handling.\n\n```python\nfrom typing import List\nfrom collections import deque\n\ndef maze_escape_time(rows: int, cols: int, maze: List[List[str]]) -> int:\n    \"\"\"\n    In a mysterious labyrinth, an adventurer needs to find the quickest way out. The maze is represented as a 2D grid where\n    'S' marks the start, 'E' marks the exit, '#' represents walls, and '.' represents open paths. The adventurer can move\n    in four directions: up, down, left, and right. Each move takes 1 unit of time.\n\n    This function calculates the minimum time required for the adventurer to reach the exit from the start position.\n    If there's no valid path to the exit, the function returns -1.\n\n    Parameters:\n    rows (int): The number of rows in the maze\n    cols (int): The number of columns in the maze\n    maze (List[List[str]]): A 2D list representing the maze layout\n\n    Returns:\n    int: The minimum time to reach the exit, or -1 if no path exists\n\n\n    [EXAMPLES]\n    \n    assert candidate(5, 3, [['S', '#', '.'], ['.', '#', '.'], ['.', '#', '.'], ['.', '#', '.'], ['.', '#', 'E']]) == -1\n    assert candidate(2, 2, [['S', '.'], ['.', 'E']]) == 2\n\n    [/EXAMPLES]\n    \"\"\"\n```\n", "entry_point": "maze_escape_time", "solution": "from typing import List\nfrom collections import deque\n\ndef maze_escape_time(rows: int, cols: int, maze: List[List[str]]) -> int:\n    \"\"\"\n    In a mysterious labyrinth, an adventurer needs to find the quickest way out. The maze is represented as a 2D grid where\n    'S' marks the start, 'E' marks the exit, '#' represents walls, and '.' represents open paths. The adventurer can move\n    in four directions: up, down, left, and right. Each move takes 1 unit of time.\n\n    This function calculates the minimum time required for the adventurer to reach the exit from the start position.\n    If there's no valid path to the exit, the function returns -1.\n\n    Parameters:\n    rows (int): The number of rows in the maze\n    cols (int): The number of columns in the maze\n    maze (List[List[str]]): A 2D list representing the maze layout\n\n    Returns:\n    int: The minimum time to reach the exit, or -1 if no path exists\n\n\n    [EXAMPLES]\n    \n    assert candidate(5, 3, [['S', '#', '.'], ['.', '#', '.'], ['.', '#', '.'], ['.', '#', '.'], ['.', '#', 'E']]) == -1\n    assert candidate(2, 2, [['S', '.'], ['.', 'E']]) == 2\n\n    [/EXAMPLES]\n    \"\"\"\n    # Find the start position\n    start = None\n    for i in range(rows):\n        for j in range(cols):\n            if maze[i][j] == 'S':\n                start = (i, j)\n                break\n        if start:\n            break\n\n    # If start position not found, return -1\n    if not start:\n        return -1\n\n    # Define possible moves: up, down, left, right\n    directions = [(-1, 0), (1, 0), (0, -1), (0, 1)]\n\n    # Initialize queue for BFS\n    queue = deque([(start[0], start[1], 0)])  # (row, col, time)\n    visited = set([(start[0], start[1])])\n\n    while queue:\n        r, c, time = queue.popleft()\n\n        # Check if we've reached the exit\n        if maze[r][c] == 'E':\n            return time\n\n        # Explore all possible directions\n        for dr, dc in directions:\n            nr, nc = r + dr, c + dc\n\n            # Check if the new position is valid and not visited\n            if (0 <= nr < rows and 0 <= nc < cols and\n                maze[nr][nc] != '#' and (nr, nc) not in visited):\n                queue.append((nr, nc, time + 1))\n                visited.add((nr, nc))\n\n    # If we've explored all reachable positions and haven't found the exit\n    return -1\n\n", "test": "def check(candidate):\n    assert candidate(2, 5, [['S', '.', '#', '.', 'E'], ['#', '.', '.', '.', '#']]) == 6\n    assert candidate(3, 3, [['S', '.', '.'], ['.', '.', '.'], ['.', '.', 'E']]) == 4\n    assert candidate(5, 3, [['S', '#', '.'], ['.', '#', '.'], ['.', '#', '.'], ['.', '#', '.'], ['.', '#', 'E']]) == -1\n    assert candidate(2, 3, [['S', '.', 'E'], ['E', '.', 'S']]) == 1\n    assert candidate(4, 3, [['S', '#', 'E'], ['.', '#', '.'], ['.', '#', '.'], ['.', '.', '.']]) == 8\n    assert candidate(2, 5, [['S', '.', '#', '.', 'E'], ['#', '.', '#', '.', '#']]) == -1\n    assert candidate(2, 2, [['S', '.'], ['.', 'E']]) == 2\n    assert candidate(3, 5, [['S', '.', '.', '.', 'E'], ['#', '#', '#', '#', '#'], ['.', '.', '.', '.', '.']]) == 4\n    assert candidate(4, 4, [['S', '.', '.', '.'], ['.', '.', '.', '.'], ['.', '.', '.', '.'], ['.', '.', '.', 'E']]) == 6\n    assert candidate(5, 5, [['S', '.', '#', '.', '.'], ['#', '.', '#', '.', '#'], ['.', '.', '.', '.', '#'], ['#', '#', '#', '.', '.'], ['#', '#', '#', '#', 'E']]) == 8\n", "language": "python"}
{"task_id": "e9532a9e-559e-4f50-b260-f1e1c7630dd93852618099685500676", "prompt": "Based on the docstring provided, I'll complete the function implementation. Here's the full code in a single block.\n\n```python\nfrom typing import List\n\ndef inventory_optimization(stock: List[int], demand: List[int]) -> int:\n    \"\"\"\n    In a warehouse management system, we need to optimize the inventory to minimize storage costs while meeting customer demand.\n    Given a list of current stock levels for different products and a list of projected customer demand for the next month,\n    calculate the minimum number of additional units that need to be ordered to satisfy all customer demands.\n\n    The function takes two lists as input:\n    - stock: A list of integers representing the current stock levels for each product\n    - demand: A list of integers representing the projected customer demand for each product\n\n    The function should return an integer representing the total number of additional units that need to be ordered.\n\n\n    [EXAMPLES]\n    \n    assert candidate([1, 1, 1, 1, 1], [2, 2, 2, 2, 2]) == 5\n    assert candidate([100, 100, 100], [99, 98, 97]) == 0\n\n    [/EXAMPLES]\n    \"\"\"\n```\n", "entry_point": "inventory_optimization", "solution": "from typing import List\n\ndef inventory_optimization(stock: List[int], demand: List[int]) -> int:\n    \"\"\"\n    In a warehouse management system, we need to optimize the inventory to minimize storage costs while meeting customer demand.\n    Given a list of current stock levels for different products and a list of projected customer demand for the next month,\n    calculate the minimum number of additional units that need to be ordered to satisfy all customer demands.\n\n    The function takes two lists as input:\n    - stock: A list of integers representing the current stock levels for each product\n    - demand: A list of integers representing the projected customer demand for each product\n\n    The function should return an integer representing the total number of additional units that need to be ordered.\n\n\n    [EXAMPLES]\n    \n    assert candidate([1, 1, 1, 1, 1], [2, 2, 2, 2, 2]) == 5\n    assert candidate([100, 100, 100], [99, 98, 97]) == 0\n\n    [/EXAMPLES]\n    \"\"\"\n    def calculate_additional_units(current_stock: int, required_demand: int) -> int:\n        \"\"\"\n        Calculate the additional units needed for a single product.\n        \"\"\"\n        return max(0, required_demand - current_stock)\n\n    total_additional_units = 0\n    \n    for stock_level, demand_level in zip(stock, demand):\n        additional_units = calculate_additional_units(stock_level, demand_level)\n        total_additional_units += additional_units\n    \n    return total_additional_units\n\n", "test": "def check(candidate):\n    assert candidate([1000, 2000, 3000, 4000, 5000], [5000, 4000, 3000, 2000, 1000]) == 6000\n    assert candidate([50, 50, 50, 50], [25, 75, 25, 75]) == 50\n    assert candidate([10, 0, 5, 0, 15], [5, 10, 0, 20, 0]) == 30\n    assert candidate([0, 0, 0], [1, 1, 1]) == 3\n    assert candidate([1000000], [1000001]) == 1\n    assert candidate([1, 1, 1, 1, 1], [2, 2, 2, 2, 2]) == 5\n    assert candidate([1, 2, 3, 4, 5, 6, 7, 8, 9, 10], [10, 9, 8, 7, 6, 5, 4, 3, 2, 1]) == 25\n    assert candidate([10, 5, 8], [6, 8, 9]) == 4\n    assert candidate([100, 100, 100], [99, 98, 97]) == 0\n    assert candidate([10, 20, 30, 40, 50], [11, 21, 31, 41, 51]) == 5\n", "language": "python"}
{"task_id": "2c7be5c2-072d-4611-9f92-10f8eebf2077-7104727829132567400", "prompt": "Following the requirements in the docstring, here's the full implementation of the function:\n\n```python\nfrom typing import List\n\ndef optimal_study_plan(subjects: List[str], difficulties: List[int], time_available: int) -> List[str]:\n    \"\"\"As a student preparing for exams, you want to create an optimal study plan. \n    You have a list of subjects and their corresponding difficulties. \n    Your goal is to maximize the number of subjects you can study within the available time.\n\n    The time required to study a subject is equal to its difficulty squared.\n    You should prioritize subjects with lower difficulty to maximize the number of subjects studied.\n\n    Return a list of subjects that can be studied within the available time, sorted by their order in the input list.\n\n\n    [EXAMPLES]\n    \n    assert candidate(['Math', 'Physics', 'Chemistry', 'Biology'], [3, 4, 2, 5], 30) == ['Math', 'Physics', 'Chemistry']\n    assert candidate(['X', 'Y'], [1, 100], 1) == ['X']\n\n    [/EXAMPLES]\n    \"\"\"\n```\n", "entry_point": "optimal_study_plan", "solution": "from typing import List\n\ndef optimal_study_plan(subjects: List[str], difficulties: List[int], time_available: int) -> List[str]:\n    \"\"\"As a student preparing for exams, you want to create an optimal study plan. \n    You have a list of subjects and their corresponding difficulties. \n    Your goal is to maximize the number of subjects you can study within the available time.\n\n    The time required to study a subject is equal to its difficulty squared.\n    You should prioritize subjects with lower difficulty to maximize the number of subjects studied.\n\n    Return a list of subjects that can be studied within the available time, sorted by their order in the input list.\n\n\n    [EXAMPLES]\n    \n    assert candidate(['Math', 'Physics', 'Chemistry', 'Biology'], [3, 4, 2, 5], 30) == ['Math', 'Physics', 'Chemistry']\n    assert candidate(['X', 'Y'], [1, 100], 1) == ['X']\n\n    [/EXAMPLES]\n    \"\"\"\n    # Create a list of tuples containing (subject, difficulty, time_required, original_index)\n    study_items = [(subject, diff, diff**2, index) \n                   for index, (subject, diff) in enumerate(zip(subjects, difficulties))]\n    \n    # Sort the study items by difficulty (ascending)\n    study_items.sort(key=lambda x: x[1])\n    \n    selected_subjects = []\n    remaining_time = time_available\n    \n    # Select subjects until we run out of time\n    for subject, _, time_required, original_index in study_items:\n        if time_required <= remaining_time:\n            selected_subjects.append((subject, original_index))\n            remaining_time -= time_required\n        else:\n            break\n    \n    # Sort selected subjects by their original order in the input list\n    selected_subjects.sort(key=lambda x: x[1])\n    \n    # Return only the subject names in the correct order\n    return [subject for subject, _ in selected_subjects]\n\n", "test": "def check(candidate):\n    assert candidate(['Math', 'Science'], [5, 5], 49) == ['Math']\n    assert candidate([], [], 50) == []\n    assert candidate(['OnlySubject'], [5], 24) == []\n    assert candidate(['X', 'Y'], [1, 100], 1) == ['X']\n    assert candidate(['Math', 'Physics', 'Chemistry', 'Biology'], [3, 4, 2, 5], 30) == ['Math', 'Physics', 'Chemistry']\n    assert candidate(['Subject1', 'Subject2', 'Subject3'], [3, 4, 5], 50) == ['Subject1', 'Subject2', 'Subject3']\n    assert candidate(['Subject'] * 10, [1, 2, 3, 4, 5, 6, 7, 8, 9, 10], 100) == ['Subject', 'Subject', 'Subject', 'Subject', 'Subject', 'Subject']\n    assert candidate(['LongSubjectName1', 'LongSubjectName2'], [1, 2], 5) == ['LongSubjectName1', 'LongSubjectName2']\n    assert candidate(['S'] * 5, [1, 1, 1, 1, 1], 4) == ['S', 'S', 'S', 'S']\n    assert candidate(['History', 'Literature', 'Geography', 'Economics', 'Art'], [2, 3, 2, 4, 1], 25) == ['History', 'Literature', 'Geography', 'Art']\n", "language": "python"}
{"task_id": "34e0bb93-2bd2-49a0-a2dc-8c4188e80655-8276653471547047149", "prompt": "I'll finish this code implementation for you within a single code block.\n\n```python\nfrom typing import List\n\ndef analyze_stock_prices(prices: List[float], window: int) -> List[float]:\n    \"\"\"\n    A financial analyst needs to calculate the moving average of stock prices.\n\n    This function takes a list of daily stock prices and a window size, then\n    returns a list of moving averages. The moving average for each day is\n    calculated using the prices of the previous 'window' days, including the\n    current day.\n\n    If there are not enough previous days to fill the window, the moving\n    average is calculated using all available previous days.\n\n\n    [EXAMPLES]\n    \n    assert candidate([10.0, 20.0, 30.0, 40.0, 50.0], 3) == [10.0, 15.0, 20.0, 30.0, 40.0]\n    assert candidate([5.5, 6.0, 5.8, 6.2, 6.5, 6.3, 6.7], 4) == [5.5, 5.75, 5.77, 5.88, 6.12, 6.2, 6.42]\n\n    [/EXAMPLES]\n    \"\"\"\n```\n", "entry_point": "analyze_stock_prices", "solution": "from typing import List\n\ndef analyze_stock_prices(prices: List[float], window: int) -> List[float]:\n    \"\"\"\n    A financial analyst needs to calculate the moving average of stock prices.\n\n    This function takes a list of daily stock prices and a window size, then\n    returns a list of moving averages. The moving average for each day is\n    calculated using the prices of the previous 'window' days, including the\n    current day.\n\n    If there are not enough previous days to fill the window, the moving\n    average is calculated using all available previous days.\n\n\n    [EXAMPLES]\n    \n    assert candidate([10.0, 20.0, 30.0, 40.0, 50.0], 3) == [10.0, 15.0, 20.0, 30.0, 40.0]\n    assert candidate([5.5, 6.0, 5.8, 6.2, 6.5, 6.3, 6.7], 4) == [5.5, 5.75, 5.77, 5.88, 6.12, 6.2, 6.42]\n\n    [/EXAMPLES]\n    \"\"\"\n    result = []\n    for i in range(len(prices)):\n        start = max(0, i - window + 1)\n        window_prices = prices[start:i+1]\n        moving_average = sum(window_prices) / len(window_prices)\n        result.append(round(moving_average, 2))\n    return result\n\n", "test": "def check(candidate):\n    assert candidate([50.0, 49.0, 51.0, 48.0, 52.0], 1) == [50.0, 49.0, 51.0, 48.0, 52.0]\n    assert candidate([10.5, 9.8, 11.2, 10.3, 10.7], 2) == [10.5, 10.15, 10.5, 10.75, 10.5]\n    assert candidate([1.0, 2.0, 3.0, 4.0, 5.0], 4) == [1.0, 1.5, 2.0, 2.5, 3.5]\n    assert candidate([1000.0, 1005.0], 3) == [1000.0, 1002.5]\n    assert candidate([1.0, 1.0, 1.0, 1.0, 1.0], 2) == [1.0, 1.0, 1.0, 1.0, 1.0]\n    assert candidate([999.9, 1000.0, 1000.1, 999.8, 1000.2], 4) == [999.9, 999.95, 1000.0, 999.95, 1000.02]\n    assert candidate([10.0, 20.0, 30.0, 40.0, 50.0], 3) == [10.0, 15.0, 20.0, 30.0, 40.0]\n    assert candidate([200.0, 210.0, 205.0, 215.0, 220.0], 5) == [200.0, 205.0, 205.0, 207.5, 210.0]\n    assert candidate([5.5, 6.0, 5.8, 6.2, 6.5, 6.3, 6.7], 4) == [5.5, 5.75, 5.77, 5.88, 6.12, 6.2, 6.42]\n    assert candidate([1000.0, 950.0, 975.0, 1025.0, 1050.0], 2) == [1000.0, 975.0, 962.5, 1000.0, 1037.5]\n", "language": "python"}
{"task_id": "0f51a2a3-30ea-4f17-b903-33b80bc2ab67-6001035335802969768", "prompt": "I'll create a complete, executable function in one code block. The solution will only utilize libraries imported in the problem statement, with any supporting functions or classes defined within the main function.\n\n```python\ndef analyze_stock_trends(prices: list, window_size: int) -> list:\n    \"\"\"You are a financial analyst tasked with identifying trends in stock prices. You need to implement a function that calculates the moving average of stock prices and determines the trend direction.\n\n    Your function should take two inputs:\n    1. prices: A list of daily closing prices for a stock\n    2. window_size: The number of days to use for calculating the moving average\n\n    The function should return a list of tuples, where each tuple contains:\n    (day_number, moving_average, trend_direction)\n\n    The trend_direction should be:\n    - \"Up\" if the current moving average is higher than the previous day's moving average\n    - \"Down\" if the current moving average is lower than the previous day's moving average\n    - \"Neutral\" if the moving average hasn't changed\n\n    Note:\n    - The first (window_size - 1) days will not have a moving average or trend direction (use None for these values).\n    - Round the moving average to two decimal places.\n\n\n    [EXAMPLES]\n    \n    assert candidate([100, 101, 99, 98, 102, 103, 97, 96, 104], 4) == [(1, None, None), (2, None, None), (3, None, None), (4, 99.5, None), (5, 100.0, 'Up'), (6, 100.5, 'Up'), (7, 100.0, 'Down'), (8, 99.5, 'Down'), (9, 100.0, 'Up')]\n    assert candidate([100, 101, 102, 103, 104, 105], 2) == [(1, None, None), (2, 100.5, None), (3, 101.5, 'Up'), (4, 102.5, 'Up'), (5, 103.5, 'Up'), (6, 104.5, 'Up')]\n\n    [/EXAMPLES]\n    \"\"\"\n```\n", "entry_point": "analyze_stock_trends", "solution": "def analyze_stock_trends(prices: list, window_size: int) -> list:\n    \"\"\"You are a financial analyst tasked with identifying trends in stock prices. You need to implement a function that calculates the moving average of stock prices and determines the trend direction.\n\n    Your function should take two inputs:\n    1. prices: A list of daily closing prices for a stock\n    2. window_size: The number of days to use for calculating the moving average\n\n    The function should return a list of tuples, where each tuple contains:\n    (day_number, moving_average, trend_direction)\n\n    The trend_direction should be:\n    - \"Up\" if the current moving average is higher than the previous day's moving average\n    - \"Down\" if the current moving average is lower than the previous day's moving average\n    - \"Neutral\" if the moving average hasn't changed\n\n    Note:\n    - The first (window_size - 1) days will not have a moving average or trend direction (use None for these values).\n    - Round the moving average to two decimal places.\n\n\n    [EXAMPLES]\n    \n    assert candidate([100, 101, 99, 98, 102, 103, 97, 96, 104], 4) == [(1, None, None), (2, None, None), (3, None, None), (4, 99.5, None), (5, 100.0, 'Up'), (6, 100.5, 'Up'), (7, 100.0, 'Down'), (8, 99.5, 'Down'), (9, 100.0, 'Up')]\n    assert candidate([100, 101, 102, 103, 104, 105], 2) == [(1, None, None), (2, 100.5, None), (3, 101.5, 'Up'), (4, 102.5, 'Up'), (5, 103.5, 'Up'), (6, 104.5, 'Up')]\n\n    [/EXAMPLES]\n    \"\"\"\n    def calculate_moving_average(data, window):\n        return round(sum(data) / window, 2)\n\n    result = []\n    moving_averages = []\n\n    for i in range(len(prices)):\n        if i < window_size - 1:\n            result.append((i + 1, None, None))\n        else:\n            current_ma = calculate_moving_average(prices[i - window_size + 1 : i + 1], window_size)\n            moving_averages.append(current_ma)\n\n            if len(moving_averages) == 1:\n                trend = None\n            else:\n                prev_ma = moving_averages[-2]\n                if current_ma > prev_ma:\n                    trend = \"Up\"\n                elif current_ma < prev_ma:\n                    trend = \"Down\"\n                else:\n                    trend = \"Neutral\"\n\n            result.append((i + 1, current_ma, trend))\n\n    return result\n\n", "test": "def check(candidate):\n    assert candidate([1, 1, 1, 1, 1, 2, 2, 2, 2, 2], 5) == [(1, None, None), (2, None, None), (3, None, None), (4, None, None), (5, 1.0, None), (6, 1.2, 'Up'), (7, 1.4, 'Up'), (8, 1.6, 'Up'), (9, 1.8, 'Up'), (10, 2.0, 'Up')]\n    assert candidate([1.5, 2.5, 3.5, 4.5, 5.5], 2) == [(1, None, None), (2, 2.0, None), (3, 3.0, 'Up'), (4, 4.0, 'Up'), (5, 5.0, 'Up')]\n    assert candidate([100, 101, 102, 103, 104, 105], 2) == [(1, None, None), (2, 100.5, None), (3, 101.5, 'Up'), (4, 102.5, 'Up'), (5, 103.5, 'Up'), (6, 104.5, 'Up')]\n    assert candidate([1000, 1000, 1000, 1100, 1200, 1300], 4) == [(1, None, None), (2, None, None), (3, None, None), (4, 1025.0, None), (5, 1075.0, 'Up'), (6, 1150.0, 'Up')]\n    assert candidate([5, 10, 15, 20, 25, 30, 35, 40], 3) == [(1, None, None), (2, None, None), (3, 10.0, None), (4, 15.0, 'Up'), (5, 20.0, 'Up'), (6, 25.0, 'Up'), (7, 30.0, 'Up'), (8, 35.0, 'Up')]\n    assert candidate([100, 101, 99, 98, 102, 103, 97, 96, 104], 4) == [(1, None, None), (2, None, None), (3, None, None), (4, 99.5, None), (5, 100.0, 'Up'), (6, 100.5, 'Up'), (7, 100.0, 'Down'), (8, 99.5, 'Down'), (9, 100.0, 'Up')]\n    assert candidate([10, 20, 30, 20, 10, 20, 30, 20, 10], 3) == [(1, None, None), (2, None, None), (3, 20.0, None), (4, 23.33, 'Up'), (5, 20.0, 'Down'), (6, 16.67, 'Down'), (7, 20.0, 'Up'), (8, 23.33, 'Up'), (9, 20.0, 'Down')]\n    assert candidate([10, 12, 15, 14, 13, 16, 18, 20, 19, 22], 3) == [(1, None, None), (2, None, None), (3, 12.33, None), (4, 13.67, 'Up'), (5, 14.0, 'Up'), (6, 14.33, 'Up'), (7, 15.67, 'Up'), (8, 18.0, 'Up'), (9, 19.0, 'Up'), (10, 20.33, 'Up')]\n    assert candidate([5, 5, 5, 5, 5, 5, 5], 3) == [(1, None, None), (2, None, None), (3, 5.0, None), (4, 5.0, 'Neutral'), (5, 5.0, 'Neutral'), (6, 5.0, 'Neutral'), (7, 5.0, 'Neutral')]\n    assert candidate([20, 19, 18, 17, 16, 15], 3) == [(1, None, None), (2, None, None), (3, 19.0, None), (4, 18.0, 'Down'), (5, 17.0, 'Down'), (6, 16.0, 'Down')]\n", "language": "python"}
{"task_id": "477bbc14-9327-43d1-9b94-53d053e639f71105184677040698", "prompt": "Write a complete solution for the specified function that works as-is when executed. Include all necessary logic within the function itself, using only the imported libraries. If you need additional functionality, define those components inside the primary function.\n\n```python\nfrom typing import List, Union\n\ndef process_student_records(commands: List[List[Union[str, int]]]) -> List[str]:\n    \"\"\"\n    A school administrator is developing a system to manage student records. The system supports three operations:\n    1. Insert a new student record with their name and marks.\n    2. Delete a student record by name.\n    3. Print the marks of a specific student.\n\n    This function takes a list of commands, where each command is a list containing the operation type and necessary parameters. It returns a list of strings representing the output of each command.\n\n    The commands are:\n    - ['i', name, marks]: Insert a new student record\n    - ['d', name]: Delete a student record\n    - ['p', name]: Print a student's marks\n\n\n    [EXAMPLES]\n    \n    assert candidate([['i', 'Alice', 95], ['i', 'Bob', 80], ['p', 'Alice'], ['d', 'Charlie'], ['p', 'Bob']]) == ['Inserted', 'Inserted', 'Marks of Alice is : 95', '-1', 'Marks of Bob is : 80']\n    assert candidate([['i', 'Noah', 82], ['d', 'Noah'], ['i', 'Noah', 89], ['p', 'Noah']]) == ['Inserted', 'Deleted', 'Inserted', 'Marks of Noah is : 89']\n\n    [/EXAMPLES]\n    \"\"\"\n```\n", "entry_point": "process_student_records", "solution": "from typing import List, Union\n\ndef process_student_records(commands: List[List[Union[str, int]]]) -> List[str]:\n    \"\"\"\n    A school administrator is developing a system to manage student records. The system supports three operations:\n    1. Insert a new student record with their name and marks.\n    2. Delete a student record by name.\n    3. Print the marks of a specific student.\n\n    This function takes a list of commands, where each command is a list containing the operation type and necessary parameters. It returns a list of strings representing the output of each command.\n\n    The commands are:\n    - ['i', name, marks]: Insert a new student record\n    - ['d', name]: Delete a student record\n    - ['p', name]: Print a student's marks\n\n\n    [EXAMPLES]\n    \n    assert candidate([['i', 'Alice', 95], ['i', 'Bob', 80], ['p', 'Alice'], ['d', 'Charlie'], ['p', 'Bob']]) == ['Inserted', 'Inserted', 'Marks of Alice is : 95', '-1', 'Marks of Bob is : 80']\n    assert candidate([['i', 'Noah', 82], ['d', 'Noah'], ['i', 'Noah', 89], ['p', 'Noah']]) == ['Inserted', 'Deleted', 'Inserted', 'Marks of Noah is : 89']\n\n    [/EXAMPLES]\n    \"\"\"\n    \n    class StudentRecords:\n        def __init__(self):\n            self.records = {}\n        \n        def insert(self, name: str, marks: int) -> str:\n            self.records[name] = marks\n            return \"Inserted\"\n        \n        def delete(self, name: str) -> str:\n            if name in self.records:\n                del self.records[name]\n                return \"Deleted\"\n            return \"-1\"\n        \n        def print_marks(self, name: str) -> str:\n            if name in self.records:\n                return f\"Marks of {name} is : {self.records[name]}\"\n            return \"-1\"\n    \n    student_system = StudentRecords()\n    output = []\n    \n    for command in commands:\n        operation = command[0]\n        \n        if operation == 'i':\n            output.append(student_system.insert(command[1], command[2]))\n        elif operation == 'd':\n            output.append(student_system.delete(command[1]))\n        elif operation == 'p':\n            output.append(student_system.print_marks(command[1]))\n    \n    return output\n\n", "test": "def check(candidate):\n    assert candidate([['i', 'Ian', 70], ['i', 'Ian', 75], ['i', 'Ian', 80], ['p', 'Ian'], ['d', 'Ian'], ['p', 'Ian']]) == ['Inserted', 'Inserted', 'Inserted', 'Marks of Ian is : 80', 'Deleted', '-1']\n    assert candidate([['i', 'Olivia', 97], ['i', 'Peter', 73], ['d', 'Olivia'], ['d', 'Peter'], ['p', 'Olivia'], ['p', 'Peter']]) == ['Inserted', 'Inserted', 'Deleted', 'Deleted', '-1', '-1']\n    assert candidate([['i', 'Victor', 0], ['i', 'Wendy', 100], ['p', 'Victor'], ['p', 'Wendy']]) == ['Inserted', 'Inserted', 'Marks of Victor is : 0', 'Marks of Wendy is : 100']\n    assert candidate([['i', 'Adam', 75], ['d', 'Adam'], ['i', 'Adam', 80], ['p', 'Adam']]) == ['Inserted', 'Deleted', 'Inserted', 'Marks of Adam is : 80']\n    assert candidate([['i', 'Emma', 100], ['i', 'Emma', 90], ['p', 'Emma'], ['d', 'Emma'], ['p', 'Emma']]) == ['Inserted', 'Inserted', 'Marks of Emma is : 90', 'Deleted', '-1']\n    assert candidate([['i', 'Alice', 95], ['i', 'Bob', 80], ['p', 'Alice'], ['d', 'Charlie'], ['p', 'Bob']]) == ['Inserted', 'Inserted', 'Marks of Alice is : 95', '-1', 'Marks of Bob is : 80']\n    assert candidate([['i', 'Noah', 82], ['d', 'Noah'], ['i', 'Noah', 89], ['p', 'Noah']]) == ['Inserted', 'Deleted', 'Inserted', 'Marks of Noah is : 89']\n    assert candidate([['i', 'Kate', 92], ['i', 'Liam', 78], ['i', 'Mia', 95], ['p', 'Kate'], ['p', 'Liam'], ['p', 'Mia']]) == ['Inserted', 'Inserted', 'Inserted', 'Marks of Kate is : 92', 'Marks of Liam is : 78', 'Marks of Mia is : 95']\n", "language": "python"}
{"task_id": "af8f5e75-cca1-44bf-8010-aa87fc6464428074813585158617794", "prompt": "As your coding assistant, I'll complete the function you provide so it works properly in a code block. I'll restrict my solution to using only the libraries mentioned in the problem and will define any additional functions or classes inside your given function.\n\n```python\nfrom typing import List\n\ndef analyze_stock_trends(prices: List[float]) -> List[str]:\n    \"\"\"\n    A financial analyst is studying stock price trends over time. They want to categorize\n    each day's price movement compared to the previous day.\n\n    This function takes a list of daily closing prices for a stock and returns a list of\n    strings describing the trend for each day. The trends are categorized as follows:\n    - \"Up\" if the price increased\n    - \"Down\" if the price decreased\n    - \"No Change\" if the price remained the same\n\n    The first element in the returned list should always be \"Initial Price\" since there\n    is no previous day to compare with.\n\n\n    [EXAMPLES]\n    \n    assert candidate([100.0, 99.9, 100.1, 100.0, 100.2]) == ['Initial Price', 'Down', 'Up', 'Down', 'Up']\n    assert candidate([75.5, 75.4, 75.3, 75.2, 75.1]) == ['Initial Price', 'Down', 'Down', 'Down', 'Down']\n\n    [/EXAMPLES]\n    \"\"\"\n```\n", "entry_point": "analyze_stock_trends", "solution": "from typing import List\n\ndef analyze_stock_trends(prices: List[float]) -> List[str]:\n    \"\"\"\n    A financial analyst is studying stock price trends over time. They want to categorize\n    each day's price movement compared to the previous day.\n\n    This function takes a list of daily closing prices for a stock and returns a list of\n    strings describing the trend for each day. The trends are categorized as follows:\n    - \"Up\" if the price increased\n    - \"Down\" if the price decreased\n    - \"No Change\" if the price remained the same\n\n    The first element in the returned list should always be \"Initial Price\" since there\n    is no previous day to compare with.\n\n\n    [EXAMPLES]\n    \n    assert candidate([100.0, 99.9, 100.1, 100.0, 100.2]) == ['Initial Price', 'Down', 'Up', 'Down', 'Up']\n    assert candidate([75.5, 75.4, 75.3, 75.2, 75.1]) == ['Initial Price', 'Down', 'Down', 'Down', 'Down']\n\n    [/EXAMPLES]\n    \"\"\"\n    if not prices:\n        return []\n\n    trends = [\"Initial Price\"]\n\n    for i in range(1, len(prices)):\n        if prices[i] > prices[i-1]:\n            trends.append(\"Up\")\n        elif prices[i] < prices[i-1]:\n            trends.append(\"Down\")\n        else:\n            trends.append(\"No Change\")\n\n    return trends\n\n", "test": "def check(candidate):\n    assert candidate([1.0, 2.0, 3.0, 4.0, 5.0]) == ['Initial Price', 'Up', 'Up', 'Up', 'Up']\n    assert candidate([75.5, 75.4, 75.3, 75.2, 75.1]) == ['Initial Price', 'Down', 'Down', 'Down', 'Down']\n    assert candidate([1.0, 1.1, 1.2, 1.1, 1.0]) == ['Initial Price', 'Up', 'Up', 'Down', 'Down']\n    assert candidate([0.5, 0.6, 0.7, 0.7, 0.7]) == ['Initial Price', 'Up', 'Up', 'No Change', 'No Change']\n    assert candidate([100.0, 90.0, 80.0, 70.0, 60.0]) == ['Initial Price', 'Down', 'Down', 'Down', 'Down']\n    assert candidate([100.0, 99.9, 100.1, 100.0, 100.2]) == ['Initial Price', 'Down', 'Up', 'Down', 'Up']\n    assert candidate([99.99, 100.00, 100.01, 100.00, 99.99]) == ['Initial Price', 'Up', 'Up', 'Down', 'Down']\n    assert candidate([1.23, 4.56, 7.89, 10.11, 12.13]) == ['Initial Price', 'Up', 'Up', 'Up', 'Up']\n    assert candidate([0.01, 0.02, 0.01, 0.01, 0.03]) == ['Initial Price', 'Up', 'Down', 'No Change', 'Up']\n    assert candidate([50.0, 49.8, 49.8, 50.2, 50.2]) == ['Initial Price', 'Down', 'No Change', 'Up', 'No Change']\n", "language": "python"}
{"task_id": "8870bc28-5f2e-48be-b380-9d431baccfa5561082801723384601", "prompt": "Fill in the function body according to what's described in the docstring. Maintain the existing function name and parameters, and provide your complete implementation in a single code block.\n\n```python\nfrom typing import List\n\ndef terrain_analyzer(elevation_map: List[List[int]]) -> int:\n    \"\"\"\n    Analyze a terrain elevation map to find the number of local peaks.\n\n    This function takes a 2D list representing an elevation map of a terrain,\n    where each cell contains an integer elevation value. It returns the count\n    of local peaks in the terrain. A local peak is defined as a cell with a\n    higher elevation than all of its adjacent cells (including diagonals).\n\n\n    [EXAMPLES]\n    \n    assert candidate([[1, 1, 1, 1], [1, 2, 2, 1], [1, 2, 3, 1], [1, 1, 1, 1]]) == 1\n    assert candidate([[1, 2, 3], [2, 3, 4], [3, 4, 5]]) == 1\n\n    [/EXAMPLES]\n    \"\"\"\n```\n", "entry_point": "terrain_analyzer", "solution": "from typing import List\n\ndef terrain_analyzer(elevation_map: List[List[int]]) -> int:\n    \"\"\"\n    Analyze a terrain elevation map to find the number of local peaks.\n\n    This function takes a 2D list representing an elevation map of a terrain,\n    where each cell contains an integer elevation value. It returns the count\n    of local peaks in the terrain. A local peak is defined as a cell with a\n    higher elevation than all of its adjacent cells (including diagonals).\n\n\n    [EXAMPLES]\n    \n    assert candidate([[1, 1, 1, 1], [1, 2, 2, 1], [1, 2, 3, 1], [1, 1, 1, 1]]) == 1\n    assert candidate([[1, 2, 3], [2, 3, 4], [3, 4, 5]]) == 1\n\n    [/EXAMPLES]\n    \"\"\"\n    def is_peak(i: int, j: int) -> bool:\n        \"\"\"Check if the cell at (i, j) is a local peak.\"\"\"\n        for di in [-1, 0, 1]:\n            for dj in [-1, 0, 1]:\n                if di == 0 and dj == 0:\n                    continue\n                ni, nj = i + di, j + dj\n                if 0 <= ni < rows and 0 <= nj < cols:\n                    if elevation_map[ni][nj] >= elevation_map[i][j]:\n                        return False\n        return True\n\n    rows = len(elevation_map)\n    cols = len(elevation_map[0]) if rows > 0 else 0\n    peak_count = 0\n\n    for i in range(rows):\n        for j in range(cols):\n            if is_peak(i, j):\n                peak_count += 1\n\n    return peak_count\n\n", "test": "def check(candidate):\n    assert candidate([[1, 2, 1], [2, 3, 2], [1, 2, 1]]) == 1\n    assert candidate([[1, 2, 1], [2, 1, 2], [1, 2, 1], [2, 1, 2]]) == 0\n    assert candidate([[1, 2, 1, 2], [2, 3, 2, 1], [1, 2, 1, 2], [2, 1, 2, 3]]) == 2\n    assert candidate([[1, 1, 1, 1], [1, 2, 2, 1], [1, 2, 3, 1], [1, 1, 1, 1]]) == 1\n    assert candidate([[1]]) == 1\n    assert candidate([[5, 4, 3], [4, 3, 2], [3, 2, 1]]) == 1\n    assert candidate([[0, 0, 0], [0, 1, 0], [0, 0, 0]]) == 1\n    assert candidate([[1, 1], [1, 1]]) == 0\n    assert candidate([[3, 2, 1], [2, 1, 2], [1, 2, 3]]) == 2\n    assert candidate([[1, 2, 3], [2, 3, 4], [3, 4, 5]]) == 1\n", "language": "python"}
{"task_id": "d03c25bf-686f-4785-abad-7c9156661a0e3536067439205581652", "prompt": "Please implement the requested function completely so it's ready for execution. Your code should be contained entirely within the function definition. Any additional helper functions or classes should be defined inside the main function. Use only the libraries that are imported in the problem description. Don't add any code outside the function or explanatory text.\n\n```python\nfrom collections import deque\nfrom typing import List, Tuple\n\ndef navigate_treasure_maze(maze: List[List[int]], start: Tuple[int, int], end: Tuple[int, int]) -> int:\n    \"\"\"\n    In a treasure hunt game, players navigate through a maze to collect coins. The maze is\n    represented as a 2D grid where 0 represents an open path, 1 represents a wall, and any\n    number greater than 1 represents coins.\n\n    This function takes the maze layout, start position, and end position as input. It returns\n    the maximum number of coins that can be collected while moving from the start to the end\n    position. Players can only move up, down, left, or right, and cannot move through walls.\n\n\n    [EXAMPLES]\n    \n    assert candidate([[9,9,9],[9,1,9],[9,9,9]], (0,0), (2,2)) == 45\n    assert candidate([[1,1,1,1],[1,0,0,1],[1,0,0,1],[1,1,1,1]], (1,1), (2,2)) == 0\n\n    [/EXAMPLES]\n    \"\"\"\n```\n", "entry_point": "navigate_treasure_maze", "solution": "from collections import deque\nfrom typing import List, Tuple\n\ndef navigate_treasure_maze(maze: List[List[int]], start: Tuple[int, int], end: Tuple[int, int]) -> int:\n    \"\"\"\n    In a treasure hunt game, players navigate through a maze to collect coins. The maze is\n    represented as a 2D grid where 0 represents an open path, 1 represents a wall, and any\n    number greater than 1 represents coins.\n\n    This function takes the maze layout, start position, and end position as input. It returns\n    the maximum number of coins that can be collected while moving from the start to the end\n    position. Players can only move up, down, left, or right, and cannot move through walls.\n\n\n    [EXAMPLES]\n    \n    assert candidate([[9,9,9],[9,1,9],[9,9,9]], (0,0), (2,2)) == 45\n    assert candidate([[1,1,1,1],[1,0,0,1],[1,0,0,1],[1,1,1,1]], (1,1), (2,2)) == 0\n\n    [/EXAMPLES]\n    \"\"\"\n    rows, cols = len(maze), len(maze[0])\n    \n    # Define directions: up, right, down, left\n    directions = [(-1, 0), (0, 1), (1, 0), (0, -1)]\n    \n    # Initialize the queue with the start position, collected coins, and visited positions\n    queue = deque([(start[0], start[1], maze[start[0]][start[1]], {start})])\n    \n    max_coins = 0\n    \n    while queue:\n        x, y, coins, visited = queue.popleft()\n        \n        if (x, y) == end:\n            max_coins = max(max_coins, coins)\n            continue\n        \n        for dx, dy in directions:\n            nx, ny = x + dx, y + dy\n            \n            if (0 <= nx < rows and 0 <= ny < cols and\n                maze[nx][ny] != 1 and (nx, ny) not in visited):\n                \n                new_coins = coins + maze[nx][ny] if maze[nx][ny] > 1 else coins\n                new_visited = visited | {(nx, ny)}\n                \n                queue.append((nx, ny, new_coins, new_visited))\n    \n    return max_coins\n\n", "test": "def check(candidate):\n    assert candidate([[9,9,9],[9,1,9],[9,9,9]], (0,0), (2,2)) == 45\n    assert candidate([[0,0,0],[0,0,0],[0,0,0]], (0,0), (2,2)) == 0\n    assert candidate([[0,1,0,0],[0,1,0,0],[0,1,0,0],[0,0,0,0]], (0,0), (3,3)) == 0\n    assert candidate([[0,1,0],[0,1,0],[0,1,0]], (0,0), (2,2)) == 0\n    assert candidate([[0,2,0],[1,3,1],[0,4,0]], (0,0), (2,2)) == 9\n    assert candidate([[1,1,1,1],[1,0,0,1],[1,0,0,1],[1,1,1,1]], (1,1), (2,2)) == 0\n    assert candidate([[1,1,1],[1,0,1],[1,1,1]], (1,1), (1,1)) == 0\n    assert candidate([[0,1],[1,0]], (0,0), (1,1)) == 0\n    assert candidate([[0,0,0],[0,1,0],[0,0,0]], (0,0), (2,2)) == 0\n    assert candidate([[0,0],[0,0]], (0,0), (1,1)) == 0\n", "language": "python"}
{"task_id": "33b73f15-0eb1-4265-a69c-495d010e8fd7-7893998818051956042", "prompt": "Complete the function provided in the problem. Your solution should be a single code block that can run as-is. Don't add any code outside the function's scope. Use only the libraries that appear in the imports of the problem. Any additional functions or classes should be nested within the given function.\n\n```python\nfrom typing import List, Tuple\n\ndef space_station_docking(arrival_times: List[int], docking_duration: List[int]) -> int:\n    \"\"\"\n    The International Space Station (ISS) has a single docking port for incoming spacecraft.\n    Given a list of arrival times and docking durations for various spacecraft, determine\n    the minimum number of spacecraft that need to be redirected to ensure no collisions occur.\n\n    :param arrival_times: A list of integers representing the arrival times of spacecraft\n    :param docking_duration: A list of integers representing the docking duration for each spacecraft\n    :return: The minimum number of spacecraft that need to be redirected\n\n\n    [EXAMPLES]\n    \n    assert candidate([1, 2, 3, 4], [2, 3, 2, 1]) == 2\n    assert candidate([100, 200, 300, 400], [50, 50, 50, 50]) == 0\n\n    [/EXAMPLES]\n    \"\"\"\n```\n", "entry_point": "space_station_docking", "solution": "from typing import List, Tuple\n\ndef space_station_docking(arrival_times: List[int], docking_duration: List[int]) -> int:\n    \"\"\"\n    The International Space Station (ISS) has a single docking port for incoming spacecraft.\n    Given a list of arrival times and docking durations for various spacecraft, determine\n    the minimum number of spacecraft that need to be redirected to ensure no collisions occur.\n\n    :param arrival_times: A list of integers representing the arrival times of spacecraft\n    :param docking_duration: A list of integers representing the docking duration for each spacecraft\n    :return: The minimum number of spacecraft that need to be redirected\n\n\n    [EXAMPLES]\n    \n    assert candidate([1, 2, 3, 4], [2, 3, 2, 1]) == 2\n    assert candidate([100, 200, 300, 400], [50, 50, 50, 50]) == 0\n\n    [/EXAMPLES]\n    \"\"\"\n    # Combine arrival times and docking durations into a list of tuples\n    schedule = sorted(zip(arrival_times, docking_duration))\n    \n    redirected = 0\n    last_departure = 0\n    \n    for arrival, duration in schedule:\n        if arrival >= last_departure:\n            # Spacecraft can dock without conflict\n            last_departure = arrival + duration\n        else:\n            # Conflict detected, redirect this spacecraft\n            redirected += 1\n    \n    return redirected\n\n", "test": "def check(candidate):\n    assert candidate([100, 200, 300, 400], [50, 50, 50, 50]) == 0\n    assert candidate([1, 3, 5], [2, 2, 2]) == 0\n    assert candidate([1, 2, 3, 4], [2, 3, 2, 1]) == 2\n    assert candidate([1, 2, 3, 4, 5], [1, 1, 1, 1, 1]) == 0\n    assert candidate([1, 1, 1, 1, 1], [1, 2, 3, 4, 5]) == 4\n    assert candidate([1, 2, 4, 8, 16], [1, 1, 1, 1, 1]) == 0\n    assert candidate([1, 2, 4, 8, 16, 32, 64, 128, 256, 512], [1, 2, 4, 8, 16, 32, 64, 128, 256, 512]) == 0\n    assert candidate([], []) == 0\n    assert candidate([1, 1, 1], [1, 1, 1]) == 2\n    assert candidate([1, 2, 3, 4, 5, 6, 7, 8, 9, 10], [1, 1, 1, 1, 1, 1, 1, 1, 1, 1]) == 0\n", "language": "python"}
{"task_id": "fad2dd50-a684-435d-b1bf-494812b17c4e-8956588263575276563", "prompt": "Working as your coding assistant, I'll complete functions that can run as-is in code blocks. I won't add code outside the function boundary and will use only the libraries specified in the problem. If needed, I'll define supporting functions or classes inside the main function.\n\n```python\nfrom typing import List, Tuple\nimport itertools\n\ndef optimize_study_schedule(subjects: List[str], time_slots: List[int], preferences: List[List[int]]) -> List[Tuple[str, int]]:\n    \"\"\"\n    Creates an optimal study schedule based on subject preferences and available time slots.\n\n    This function uses itertools to generate all possible combinations of subject-timeslot\n    pairs and selects the combination that maximizes the total preference score while\n    ensuring each subject is assigned to exactly one time slot.\n\n    Args:\n    subjects (List[str]): List of subjects to be studied.\n    time_slots (List[int]): Available time slots for studying (in minutes).\n    preferences (List[List[int]]): A 2D list where preferences[i][j] represents the\n                                   preference score for studying subject i in time slot j.\n\n    Returns:\n    List[Tuple[str, int]]: A list of tuples, each containing a subject and its assigned time slot.\n\n\n    [EXAMPLES]\n    \n    assert candidate(['Subject1', 'Subject2', 'Subject3', 'Subject4', 'Subject5'], [30, 45, 60, 75, 90], [[1, 2, 3, 4, 5], [5, 4, 3, 2, 1], [3, 3, 3, 3, 3], [2, 4, 1, 5, 3], [4, 1, 5, 2, 3]]) == [('Subject1', 90), ('Subject2', 30), ('Subject3', 45), ('Subject4', 75), ('Subject5', 60)]\n    assert candidate(['Math'], [60], [[5]]) == [('Math', 60)]\n\n    [/EXAMPLES]\n    \"\"\"\n```\n", "entry_point": "optimize_study_schedule", "solution": "from typing import List, Tuple\nimport itertools\n\ndef optimize_study_schedule(subjects: List[str], time_slots: List[int], preferences: List[List[int]]) -> List[Tuple[str, int]]:\n    \"\"\"\n    Creates an optimal study schedule based on subject preferences and available time slots.\n\n    This function uses itertools to generate all possible combinations of subject-timeslot\n    pairs and selects the combination that maximizes the total preference score while\n    ensuring each subject is assigned to exactly one time slot.\n\n    Args:\n    subjects (List[str]): List of subjects to be studied.\n    time_slots (List[int]): Available time slots for studying (in minutes).\n    preferences (List[List[int]]): A 2D list where preferences[i][j] represents the\n                                   preference score for studying subject i in time slot j.\n\n    Returns:\n    List[Tuple[str, int]]: A list of tuples, each containing a subject and its assigned time slot.\n\n\n    [EXAMPLES]\n    \n    assert candidate(['Subject1', 'Subject2', 'Subject3', 'Subject4', 'Subject5'], [30, 45, 60, 75, 90], [[1, 2, 3, 4, 5], [5, 4, 3, 2, 1], [3, 3, 3, 3, 3], [2, 4, 1, 5, 3], [4, 1, 5, 2, 3]]) == [('Subject1', 90), ('Subject2', 30), ('Subject3', 45), ('Subject4', 75), ('Subject5', 60)]\n    assert candidate(['Math'], [60], [[5]]) == [('Math', 60)]\n\n    [/EXAMPLES]\n    \"\"\"\n    def calculate_score(schedule):\n        return sum(preferences[subjects.index(subject)][time_slots.index(slot)] \n                   for subject, slot in schedule)\n\n    best_schedule = None\n    best_score = float('-inf')\n\n    for permutation in itertools.permutations(time_slots):\n        current_schedule = list(zip(subjects, permutation))\n        current_score = calculate_score(current_schedule)\n        \n        if current_score > best_score:\n            best_score = current_score\n            best_schedule = current_schedule\n\n    return best_schedule\n\n", "test": "def check(candidate):\n    assert candidate(['Subject1', 'Subject2', 'Subject3'], [60, 60, 60], [[5, 5, 5], [5, 5, 5], [5, 5, 5]]) == [('Subject1', 60), ('Subject2', 60), ('Subject3', 60)]\n    assert candidate(['A', 'B'], [1, 2], [[1, 2], [2, 1]]) == [('A', 2), ('B', 1)]\n    assert candidate(['English', 'Physics'], [90, 120], [[4, 3], [2, 5]]) == [('English', 90), ('Physics', 120)]\n    assert candidate(['A', 'B', 'C', 'D', 'E'], [10, 20, 30, 40, 50], [[5, 4, 3, 2, 1], [1, 2, 3, 4, 5], [3, 3, 3, 3, 3], [2, 4, 1, 5, 3], [4, 1, 5, 2, 3]]) == [('A', 10), ('B', 50), ('C', 20), ('D', 40), ('E', 30)]\n    assert candidate(['Math', 'History', 'Science'], [60, 45, 30], [[5, 3, 1], [2, 4, 3], [4, 2, 5]]) == [('Math', 60), ('History', 45), ('Science', 30)]\n    assert candidate(['Art', 'Music'], [120, 180], [[5, 4], [3, 5]]) == [('Art', 120), ('Music', 180)]\n    assert candidate(['Subject1', 'Subject2', 'Subject3', 'Subject4', 'Subject5'], [30, 45, 60, 75, 90], [[1, 2, 3, 4, 5], [5, 4, 3, 2, 1], [3, 3, 3, 3, 3], [2, 4, 1, 5, 3], [4, 1, 5, 2, 3]]) == [('Subject1', 90), ('Subject2', 30), ('Subject3', 45), ('Subject4', 75), ('Subject5', 60)]\n    assert candidate(['Math', 'History'], [60, 45], [[5, 3], [2, 4]]) == [('Math', 60), ('History', 45)]\n    assert candidate(['Math', 'Physics', 'Chemistry', 'Biology'], [30, 45, 60, 75], [[1, 2, 3, 4], [4, 3, 2, 1], [2, 4, 1, 3], [3, 1, 4, 2]]) == [('Math', 75), ('Physics', 30), ('Chemistry', 45), ('Biology', 60)]\n    assert candidate(['Math'], [60], [[5]]) == [('Math', 60)]\n", "language": "python"}
{"task_id": "fb9060f6-059b-4093-82d9-a24056913d05-6870820142118741618", "prompt": "Complete the function provided so it can be executed as a standalone code block. Don't write any code outside of the function scope. Restrict yourself to using only the libraries imported in the problem statement. If you need additional functionality, define those functions or classes inside the main function.\n\n```python\nfrom typing import List\nimport math\n\ndef calculate_team_score(team_performance: List[float], player_bonuses: List[float]) -> float:\n    \"\"\"\n    In a futuristic sport league, team scores are calculated based on overall team performance\n    and individual player bonuses. This function computes the final team score.\n\n    The team performance is a list of float values representing different aspects of the team's play.\n    Player bonuses are additional points awarded to individual players for exceptional performance.\n\n    The final score is calculated by summing the team performance values, then adding the square root\n    of the sum of player bonuses.\n\n\n    [EXAMPLES]\n    \n    assert candidate([10.0, 10.0, 10.0], [0.0, 0.0, 0.0]) == 30.0\n    assert candidate([0.001, 0.002, 0.003], [0.004, 0.005, 0.006]) == 0.1284744871391589\n\n    [/EXAMPLES]\n    \"\"\"\n```\n", "entry_point": "calculate_team_score", "solution": "from typing import List\nimport math\n\ndef calculate_team_score(team_performance: List[float], player_bonuses: List[float]) -> float:\n    \"\"\"\n    In a futuristic sport league, team scores are calculated based on overall team performance\n    and individual player bonuses. This function computes the final team score.\n\n    The team performance is a list of float values representing different aspects of the team's play.\n    Player bonuses are additional points awarded to individual players for exceptional performance.\n\n    The final score is calculated by summing the team performance values, then adding the square root\n    of the sum of player bonuses.\n\n\n    [EXAMPLES]\n    \n    assert candidate([10.0, 10.0, 10.0], [0.0, 0.0, 0.0]) == 30.0\n    assert candidate([0.001, 0.002, 0.003], [0.004, 0.005, 0.006]) == 0.1284744871391589\n\n    [/EXAMPLES]\n    \"\"\"\n    # Calculate the sum of team performance values\n    team_performance_sum = sum(team_performance)\n    \n    # Calculate the sum of player bonuses\n    player_bonuses_sum = sum(player_bonuses)\n    \n    # Calculate the square root of the sum of player bonuses\n    bonus_sqrt = math.sqrt(player_bonuses_sum)\n    \n    # Calculate the final team score\n    final_score = team_performance_sum + bonus_sqrt\n    \n    return final_score\n\n", "test": "def check(candidate):\n    assert candidate([0.1, 0.2, 0.3], [10.0, 20.0, 30.0]) == 8.345966692414834\n    assert candidate([50.0, 50.0], [25.0, 25.0]) == 107.07106781186548\n    assert candidate([5.5, 6.2, 7.1, 8.3], [0.5, 1.5, 2.5, 3.5]) == 29.92842712474619\n    assert candidate([1.23, 4.56, 7.89], [9.87, 6.54, 3.21]) == 18.10944691807002\n    assert candidate([0.0, 0.0, 0.0], [0.0, 0.0, 0.0]) == 0.0\n    assert candidate([0.5, 1.5, 2.5], [3.5, 2.5, 1.5]) == 7.238612787525831\n    assert candidate([10.0, 10.0, 10.0], [0.0, 0.0, 0.0]) == 30.0\n    assert candidate([9.9], [4.0]) == 11.9\n    assert candidate([5.0, 5.0, 5.0, 5.0, 5.0], [1.0, 1.0, 1.0, 1.0, 1.0]) == 27.23606797749979\n    assert candidate([0.001, 0.002, 0.003], [0.004, 0.005, 0.006]) == 0.1284744871391589\n", "language": "python"}
{"task_id": "431b7fa6-c753-4dce-96a5-9e894531bf215194205394825522063", "prompt": "I'll complete the function as requested, delivering a single code block that can be executed directly. The implementation will only use libraries mentioned in the problem imports. Any helper functions or classes will be defined within the main function's scope. I'll provide exactly one code block with the full solution.\n\n```python\ndef encode_message(plaintext: str, key: int) -> str:\n    \"\"\"\n    In a secret spy organization, agents need to encode their messages before transmission.\n    This function implements a simple shift cipher to encode a message.\n    Each letter in the plaintext is shifted 'key' positions down the alphabet.\n    The function should wrap around if a shift goes past 'z' (e.g., 'z' with key 1 becomes 'a').\n    Only alphabetic characters are shifted; other characters remain unchanged.\n    The function preserves the case of the original message.\n\n\n    [EXAMPLES]\n    \n    assert candidate(\"UPPERCASE\", 10) == 'EZZOBMKCO'\n    assert candidate(\"lowercase\", 5) == 'qtbjwhfxj'\n\n    [/EXAMPLES]\n    \"\"\"\n```\n", "entry_point": "encode_message", "solution": "def encode_message(plaintext: str, key: int) -> str:\n    \"\"\"\n    In a secret spy organization, agents need to encode their messages before transmission.\n    This function implements a simple shift cipher to encode a message.\n    Each letter in the plaintext is shifted 'key' positions down the alphabet.\n    The function should wrap around if a shift goes past 'z' (e.g., 'z' with key 1 becomes 'a').\n    Only alphabetic characters are shifted; other characters remain unchanged.\n    The function preserves the case of the original message.\n\n\n    [EXAMPLES]\n    \n    assert candidate(\"UPPERCASE\", 10) == 'EZZOBMKCO'\n    assert candidate(\"lowercase\", 5) == 'qtbjwhfxj'\n\n    [/EXAMPLES]\n    \"\"\"\n    def shift_char(char: str, shift: int) -> str:\n        if not char.isalpha():\n            return char\n        \n        ascii_offset = ord('A') if char.isupper() else ord('a')\n        shifted = (ord(char) - ascii_offset + shift) % 26\n        return chr(shifted + ascii_offset)\n\n    return ''.join(shift_char(char, key) for char in plaintext)\n\n", "test": "def check(candidate):\n    assert candidate(\"12345!@#$%\", 7) == '12345!@#$%'\n    assert candidate(\"Hello World!\", 0) == 'Hello World!'\n    assert candidate(\"a b c d e f g\", 1) == 'b c d e f g h'\n    assert candidate(\"The quick brown fox jumps over the lazy dog.\", 13) == 'Gur dhvpx oebja sbk whzcf bire gur ynml qbt.'\n    assert candidate(\"lowercase\", 5) == 'qtbjwhfxj'\n    assert candidate(\"abcdefghijklmnopqrstuvwxyz\", 25) == 'zabcdefghijklmnopqrstuvwxy'\n    assert candidate(\"UPPERCASE\", 10) == 'EZZOBMKCO'\n    assert candidate(\"Punctuation! Is, Preserved; Right?\", 11) == 'Afynefletzy! Td, Acpdpcgpo; Ctrse?'\n    assert candidate(\"XYZ\", 3) == 'ABC'\n    assert candidate(\"SECRET MESSAGE\", 25) == 'RDBQDS LDRRZFD'\n", "language": "python"}
{"task_id": "9a7f3870-7e49-4abe-b9e8-c0e6a2b612f44491019319267971285", "prompt": "Let me generate a complete implementation of the code in one unified code block.\n\n```python\nfrom typing import List\n\ndef encrypt_message(message: str, key: int) -> List[str]:\n    \"\"\"\n    A secret agent needs to encrypt a message using a custom Caesar cipher algorithm.\n    The algorithm shifts each letter in the message by the key value, wrapping around\n    the alphabet if necessary. Additionally, it splits the encrypted message into\n    groups of 5 characters each.\n\n    This function takes a message and a key as input, encrypts the message using the\n    custom Caesar cipher, and returns the result as a list of 5-character groups.\n\n\n    [EXAMPLES]\n    \n    assert candidate(\"SINGLE\", 0) == ['SINGL', 'E']\n    assert candidate(\"ABCDEFGHIJKLMNOPQRSTUVWXYZ\", 0) == ['ABCDE', 'FGHIJ', 'KLMNO', 'PQRST', 'UVWXY', 'Z']\n\n    [/EXAMPLES]\n    \"\"\"\n```\n", "entry_point": "encrypt_message", "solution": "from typing import List\n\ndef encrypt_message(message: str, key: int) -> List[str]:\n    \"\"\"\n    A secret agent needs to encrypt a message using a custom Caesar cipher algorithm.\n    The algorithm shifts each letter in the message by the key value, wrapping around\n    the alphabet if necessary. Additionally, it splits the encrypted message into\n    groups of 5 characters each.\n\n    This function takes a message and a key as input, encrypts the message using the\n    custom Caesar cipher, and returns the result as a list of 5-character groups.\n\n\n    [EXAMPLES]\n    \n    assert candidate(\"SINGLE\", 0) == ['SINGL', 'E']\n    assert candidate(\"ABCDEFGHIJKLMNOPQRSTUVWXYZ\", 0) == ['ABCDE', 'FGHIJ', 'KLMNO', 'PQRST', 'UVWXY', 'Z']\n\n    [/EXAMPLES]\n    \"\"\"\n    def shift_char(char: str, shift: int) -> str:\n        if not char.isalpha():\n            return char\n        ascii_offset = ord('A')\n        return chr((ord(char) - ascii_offset + shift) % 26 + ascii_offset)\n\n    # Remove spaces and convert to uppercase\n    message = message.replace(\" \", \"\").upper()\n    \n    # Encrypt the message\n    encrypted = ''.join(shift_char(char, key) for char in message)\n    \n    # Split into groups of 5\n    groups = [encrypted[i:i+5] for i in range(0, len(encrypted), 5)]\n    \n    return groups\n\n", "test": "def check(candidate):\n    assert candidate(\"VERYLONGMESSAGEWITHOUTSPACES\", 15) == ['KTGNA', 'DCVBT', 'HHPVT', 'LXIWD', 'JIHEP', 'RTH']\n    assert candidate(\"SINGLE\", 0) == ['SINGL', 'E']\n    assert candidate(\"A\", 25) == ['Z']\n    assert candidate(\"Z\" * 100, 1) == ['AAAAA', 'AAAAA', 'AAAAA', 'AAAAA', 'AAAAA', 'AAAAA', 'AAAAA', 'AAAAA', 'AAAAA', 'AAAAA', 'AAAAA', 'AAAAA', 'AAAAA', 'AAAAA', 'AAAAA', 'AAAAA', 'AAAAA', 'AAAAA', 'AAAAA', 'AAAAA']\n    assert candidate(\"1234567890\", 3) == ['12345', '67890']\n    assert candidate(\"HELLO WORLD\", 1) == ['IFMMP', 'XPSME']\n    assert candidate(\"SHORT MSG\", 100) == ['ODKNP', 'IOC']\n    assert candidate(\"NEGATIVE KEY\", -3) == ['KBDXQ', 'FSBHB', 'V']\n    assert candidate(\"CRYPTOGRAPHY\", 5) == ['HWDUY', 'TLWFU', 'MD']\n    assert candidate(\"ABCDEFGHIJKLMNOPQRSTUVWXYZ\", 0) == ['ABCDE', 'FGHIJ', 'KLMNO', 'PQRST', 'UVWXY', 'Z']\n", "language": "python"}
{"task_id": "457a5143-6485-46e0-a424-307ad774d856-2555873656581039879", "prompt": "You are a coding assistant. I'll complete functions that can be directly executed within code blocks, ensuring I use only the imported libraries. I won't provide code outside the function, and any additional functions or classes will be defined within the given function.\n\n```python\ndef calculate_ship_efficiency(crew_size: int, cargo_weight: float, distance: float) -> float:\n    \"\"\"\n    Calculate the efficiency of a space freighter based on its crew size, cargo weight, and travel distance.\n\n    In the Galactic Trade Federation, ship efficiency is a crucial metric for evaluating transport vessels.\n    This function computes the efficiency score using a proprietary algorithm that considers the relationship\n    between crew size, cargo capacity, and the ability to cover long distances.\n\n    Args:\n    crew_size (int): Number of crew members on the ship\n    cargo_weight (float): Weight of the cargo in metric tons\n    distance (float): Distance traveled in light-years\n\n    Returns:\n    float: The calculated efficiency score of the ship\n\n\n    [EXAMPLES]\n    \n    assert candidate(2, 500.0, 15.0) == 193.6\n    assert candidate(100, 100000.0, 5000.0) == 14142.1\n\n    [/EXAMPLES]\n    \"\"\"\n```\n", "entry_point": "calculate_ship_efficiency", "solution": "def calculate_ship_efficiency(crew_size: int, cargo_weight: float, distance: float) -> float:\n    \"\"\"\n    Calculate the efficiency of a space freighter based on its crew size, cargo weight, and travel distance.\n\n    In the Galactic Trade Federation, ship efficiency is a crucial metric for evaluating transport vessels.\n    This function computes the efficiency score using a proprietary algorithm that considers the relationship\n    between crew size, cargo capacity, and the ability to cover long distances.\n\n    Args:\n    crew_size (int): Number of crew members on the ship\n    cargo_weight (float): Weight of the cargo in metric tons\n    distance (float): Distance traveled in light-years\n\n    Returns:\n    float: The calculated efficiency score of the ship\n\n\n    [EXAMPLES]\n    \n    assert candidate(2, 500.0, 15.0) == 193.6\n    assert candidate(100, 100000.0, 5000.0) == 14142.1\n\n    [/EXAMPLES]\n    \"\"\"\n    # Base efficiency score\n    base_efficiency = cargo_weight / crew_size\n\n    # Distance factor: Efficiency increases with distance, but at a diminishing rate\n    distance_factor = (distance ** 0.5) / 10\n\n    # Cargo-to-crew ratio factor: Rewards higher cargo-to-crew ratios\n    cargo_crew_ratio = cargo_weight / crew_size\n    ratio_factor = min(cargo_crew_ratio / 100, 2)  # Cap the ratio factor at 2\n\n    # Calculate the final efficiency score\n    efficiency_score = base_efficiency * distance_factor * ratio_factor\n\n    # Round the result to 1 decimal place\n    return round(efficiency_score, 1)\n\n", "test": "def check(candidate):\n    assert candidate(20, 10000.0, 500.0) == 2236.1\n    assert candidate(5, 1000.0, 50.0) == 282.8\n    assert candidate(3, 750.5, 25.5) == 252.7\n    assert candidate(2, 500.0, 15.0) == 193.6\n    assert candidate(7, 3500.0, 80.0) == 894.4\n    assert candidate(100, 100000.0, 5000.0) == 14142.1\n", "language": "python"}
{"task_id": "be6a34e9-bac6-4f23-afab-93805556ba16-354369971410301782", "prompt": "I need you to finish a function that's ready for immediate execution. Provide the implementation within the function block only. No code should appear outside the given function. Only use libraries that are imported in the problem statement. If you need helper functions or classes, define them inside the main function.\n\n```python\nimport cmath\nfrom typing import List, Tuple\n\ndef radar_detection(obstacles: List[Tuple[float, float]], range_limit: float) -> List[Tuple[float, float]]:\n    \"\"\"\n    A maritime radar system needs to identify potential obstacles within a certain range.\n    This function takes a list of obstacle coordinates (x, y) and a range limit,\n    then returns a list of obstacles that are within the specified range from the origin (0, 0).\n\n    The function uses complex numbers to represent coordinates and calculate distances,\n    demonstrating the use of complex arithmetic and list comprehension.\n\n\n    [EXAMPLES]\n    \n    assert candidate([(1, 0), (0, 1), (-1, 0), (0, -1)], 1) == [(1, 0), (0, 1), (-1, 0), (0, -1)]\n    assert candidate([(100, 100), (200, 200), (300, 300)], 1000) == [(100, 100), (200, 200), (300, 300)]\n\n    [/EXAMPLES]\n    \"\"\"\n```\n", "entry_point": "radar_detection", "solution": "import cmath\nfrom typing import List, Tuple\n\ndef radar_detection(obstacles: List[Tuple[float, float]], range_limit: float) -> List[Tuple[float, float]]:\n    \"\"\"\n    A maritime radar system needs to identify potential obstacles within a certain range.\n    This function takes a list of obstacle coordinates (x, y) and a range limit,\n    then returns a list of obstacles that are within the specified range from the origin (0, 0).\n\n    The function uses complex numbers to represent coordinates and calculate distances,\n    demonstrating the use of complex arithmetic and list comprehension.\n\n\n    [EXAMPLES]\n    \n    assert candidate([(1, 0), (0, 1), (-1, 0), (0, -1)], 1) == [(1, 0), (0, 1), (-1, 0), (0, -1)]\n    assert candidate([(100, 100), (200, 200), (300, 300)], 1000) == [(100, 100), (200, 200), (300, 300)]\n\n    [/EXAMPLES]\n    \"\"\"\n    # Convert obstacles to complex numbers and filter based on range\n    return [\n        (obstacle[0], obstacle[1])\n        for obstacle in obstacles\n        if abs(complex(obstacle[0], obstacle[1])) <= range_limit\n    ]\n\n", "test": "def check(candidate):\n    assert candidate([(1e-6, 1e-6), (1e-5, 1e-5), (1e-4, 1e-4)], 1e-4) == [(1e-06, 1e-06), (1e-05, 1e-05)]\n    assert candidate([(10, 0), (0, 10), (-10, 0), (0, -10)], 10) == [(10, 0), (0, 10), (-10, 0), (0, -10)]\n    assert candidate([(100, 100), (200, 200), (300, 300)], 1000) == [(100, 100), (200, 200), (300, 300)]\n    assert candidate([(3.14, 2.72), (2.72, 3.14), (1.41, 1.73)], 4) == [(1.41, 1.73)]\n    assert candidate([(0, 0)], 1) == [(0, 0)]\n    assert candidate([(1, 1), (2, 2), (3, 3), (4, 4), (5, 5)], 3) == [(1, 1), (2, 2)]\n    assert candidate([(2, 2), (3, 3), (4, 4)], 4) == [(2, 2)]\n    assert candidate([(1, 0), (0, 1), (-1, 0), (0, -1)], 1) == [(1, 0), (0, 1), (-1, 0), (0, -1)]\n    assert candidate([], 10) == []\n    assert candidate([(10, 10), (-10, -10), (10, -10), (-10, 10)], 15) == [(10, 10), (-10, -10), (10, -10), (-10, 10)]\n", "language": "python"}
{"task_id": "fd75da5f-1fe6-4f4e-aac8-18a34a155ed29206263278204251712", "prompt": "I need you to finish a specified function that can be directly run as a standalone code block. Keep all code strictly within the function definition. Only use libraries that are already imported in the problem statement. If you need helper functions or additional classes, define them inside the main function. Provide exactly one code block in your response.\n\n```python\nfrom typing import List\n\ndef word_transformer(text: str, operations: List[str]) -> str:\n    \"\"\"\n    In a text processing application, we need to apply a series of operations to transform a given text.\n    The operations can be 'reverse' (reverse the entire text), 'capitalize' (capitalize the first letter of each word),\n    or 'remove_vowels' (remove all vowels from the text). Apply the given operations in order and return the result.\n\n    Parameters:\n    text (str): The input text to be transformed\n    operations (List[str]): A list of operations to apply\n\n    Returns:\n    str: The transformed text after applying all operations\n\n\n    [EXAMPLES]\n    \n    assert candidate(\"Testing 123\", [\"remove_vowels\", \"capitalize\"]) == 'Tstng 123'\n    assert candidate(\"a b c d e\", [\"capitalize\", \"reverse\"]) == 'E D C B A'\n\n    [/EXAMPLES]\n    \"\"\"\n```\n", "entry_point": "word_transformer", "solution": "from typing import List\n\ndef word_transformer(text: str, operations: List[str]) -> str:\n    \"\"\"\n    In a text processing application, we need to apply a series of operations to transform a given text.\n    The operations can be 'reverse' (reverse the entire text), 'capitalize' (capitalize the first letter of each word),\n    or 'remove_vowels' (remove all vowels from the text). Apply the given operations in order and return the result.\n\n    Parameters:\n    text (str): The input text to be transformed\n    operations (List[str]): A list of operations to apply\n\n    Returns:\n    str: The transformed text after applying all operations\n\n\n    [EXAMPLES]\n    \n    assert candidate(\"Testing 123\", [\"remove_vowels\", \"capitalize\"]) == 'Tstng 123'\n    assert candidate(\"a b c d e\", [\"capitalize\", \"reverse\"]) == 'E D C B A'\n\n    [/EXAMPLES]\n    \"\"\"\n    def reverse(s: str) -> str:\n        return s[::-1]\n\n    def capitalize(s: str) -> str:\n        return ' '.join(word.capitalize() for word in s.split())\n\n    def remove_vowels(s: str) -> str:\n        return ''.join(char for char in s if char.lower() not in 'aeiou')\n\n    operation_map = {\n        'reverse': reverse,\n        'capitalize': capitalize,\n        'remove_vowels': remove_vowels\n    }\n\n    result = text\n    for operation in operations:\n        if operation in operation_map:\n            result = operation_map[operation](result)\n\n    return result\n\n", "test": "def check(candidate):\n    assert candidate(\"a b c d e\", [\"capitalize\", \"reverse\"]) == 'E D C B A'\n    assert candidate(\"The quick brown fox\", [\"remove_vowels\", \"reverse\"]) == 'xf nwrb kcq hT'\n    assert candidate(\"  Spaces  Test  \", [\"remove_vowels\", \"reverse\", \"capitalize\"]) == 'Tst Scps'\n    assert candidate(\"Multiple    Spaces\", [\"remove_vowels\", \"reverse\", \"capitalize\"]) == 'Scps Lptlm'\n    assert candidate(\"12345\", [\"reverse\", \"capitalize\", \"remove_vowels\"]) == '54321'\n    assert candidate(\"\", [\"reverse\", \"capitalize\", \"remove_vowels\"]) == ''\n    assert candidate(\"aeiou\", [\"remove_vowels\"]) == ''\n    assert candidate(\"Testing 123\", [\"remove_vowels\", \"capitalize\"]) == 'Tstng 123'\n    assert candidate(\"Long text \" * 100, [\"reverse\", \"capitalize\"]) == 'Txet Gnol Txet Gnol Txet Gnol Txet Gnol Txet Gnol Txet Gnol Txet Gnol Txet Gnol Txet Gnol Txet Gnol Txet Gnol Txet Gnol Txet Gnol Txet Gnol Txet Gnol Txet Gnol Txet Gnol Txet Gnol Txet Gnol Txet Gnol Txet Gnol Txet Gnol Txet Gnol Txet Gnol Txet Gnol Txet Gnol Txet Gnol Txet Gnol Txet Gnol Txet Gnol Txet Gnol Txet Gnol Txet Gnol Txet Gnol Txet Gnol Txet Gnol Txet Gnol Txet Gnol Txet Gnol Txet Gnol Txet Gnol Txet Gnol Txet Gnol Txet Gnol Txet Gnol Txet Gnol Txet Gnol Txet Gnol Txet Gnol Txet Gnol Txet Gnol Txet Gnol Txet Gnol Txet Gnol Txet Gnol Txet Gnol Txet Gnol Txet Gnol Txet Gnol Txet Gnol Txet Gnol Txet Gnol Txet Gnol Txet Gnol Txet Gnol Txet Gnol Txet Gnol Txet Gnol Txet Gnol Txet Gnol Txet Gnol Txet Gnol Txet Gnol Txet Gnol Txet Gnol Txet Gnol Txet Gnol Txet Gnol Txet Gnol Txet Gnol Txet Gnol Txet Gnol Txet Gnol Txet Gnol Txet Gnol Txet Gnol Txet Gnol Txet Gnol Txet Gnol Txet Gnol Txet Gnol Txet Gnol Txet Gnol Txet Gnol Txet Gnol Txet Gnol Txet Gnol Txet Gnol Txet Gnol Txet Gnol'\n    assert candidate(\"MiXeD CaSe TeXt\", [\"reverse\", \"capitalize\", \"remove_vowels\"]) == 'Txt sc Dxm'\n", "language": "python"}
{"task_id": "f245fc6f-664e-4f84-8045-eb715c1505f3-631844522341450147", "prompt": "Below is the complete code implementation in a single block.\n\n```python\ndef create_temperature_converter(from_scale: str, to_scale: str) -> callable:\n    \"\"\"\n    In a weather monitoring station, we need to create flexible temperature converters.\n    This function creates a temperature converter that can convert temperatures between different scales.\n\n    The function takes two parameters:\n    - from_scale: The scale to convert from ('C' for Celsius, 'F' for Fahrenheit, 'K' for Kelvin)\n    - to_scale: The scale to convert to ('C' for Celsius, 'F' for Fahrenheit, 'K' for Kelvin)\n\n    It returns a function that takes a temperature value as input and returns the converted temperature.\n    Use closures to maintain the conversion scales for each converter.\n\n\n    [EXAMPLES]\n    \n    assert candidate('K', 'F')(273.15) == 31.999999999999943\n    assert candidate('F', 'F')(77) == 77\n\n    [/EXAMPLES]\n    \"\"\"\n```\n", "entry_point": "create_temperature_converter", "solution": "def create_temperature_converter(from_scale: str, to_scale: str) -> callable:\n    \"\"\"\n    In a weather monitoring station, we need to create flexible temperature converters.\n    This function creates a temperature converter that can convert temperatures between different scales.\n\n    The function takes two parameters:\n    - from_scale: The scale to convert from ('C' for Celsius, 'F' for Fahrenheit, 'K' for Kelvin)\n    - to_scale: The scale to convert to ('C' for Celsius, 'F' for Fahrenheit, 'K' for Kelvin)\n\n    It returns a function that takes a temperature value as input and returns the converted temperature.\n    Use closures to maintain the conversion scales for each converter.\n\n\n    [EXAMPLES]\n    \n    assert candidate('K', 'F')(273.15) == 31.999999999999943\n    assert candidate('F', 'F')(77) == 77\n\n    [/EXAMPLES]\n    \"\"\"\n    def celsius_to_fahrenheit(celsius):\n        return (celsius * 9/5) + 32\n\n    def celsius_to_kelvin(celsius):\n        return celsius + 273.15\n\n    def fahrenheit_to_celsius(fahrenheit):\n        return (fahrenheit - 32) * 5/9\n\n    def fahrenheit_to_kelvin(fahrenheit):\n        return (fahrenheit + 459.67) * 5/9\n\n    def kelvin_to_celsius(kelvin):\n        return kelvin - 273.15\n\n    def kelvin_to_fahrenheit(kelvin):\n        return (kelvin * 9/5) - 459.67\n\n    conversion_map = {\n        ('C', 'F'): celsius_to_fahrenheit,\n        ('C', 'K'): celsius_to_kelvin,\n        ('F', 'C'): fahrenheit_to_celsius,\n        ('F', 'K'): fahrenheit_to_kelvin,\n        ('K', 'C'): kelvin_to_celsius,\n        ('K', 'F'): kelvin_to_fahrenheit,\n    }\n\n    if from_scale == to_scale:\n        return lambda x: x\n\n    if (from_scale, to_scale) in conversion_map:\n        return conversion_map[(from_scale, to_scale)]\n    else:\n        raise ValueError(\"Invalid conversion scales. Use 'C', 'F', or 'K'.\")\n\n\n", "test": "def check(candidate):\n    assert candidate('K', 'F')(273.15) == 31.999999999999943\n    assert candidate('K', 'F')(0) == -459.67\n    assert candidate('K', 'C')(0) == -273.15\n    assert candidate('C', 'C')(25) == 25\n    assert candidate('C', 'K')(0) == 273.15\n    assert candidate('F', 'K')(32) == 273.15\n    assert candidate('C', 'F')(-40) == -40.0\n    assert candidate('F', 'F')(77) == 77\n    assert candidate('F', 'C')(212) == 100.0\n    assert candidate('C', 'F')(0) == 32.0\n", "language": "python"}
{"task_id": "0f43fb31-8b46-4be1-a7eb-318f675ad5661000722805112952943", "prompt": "I'll implement the rest of the function according to its documentation string. Here's the complete function in one code block:\n\n```python\nfrom typing import List, Tuple\n\ndef simulate_ecosystem(initial_population: List[int], interactions: List[Tuple[int, int, float]], generations: int) -> List[int]:\n    \"\"\"\n    A biologist is studying the interactions between different species in an ecosystem.\n    This function simulates the population changes over time based on the initial population\n    of each species and their interactions.\n\n    Parameters:\n    - initial_population: A list of integers representing the initial population of each species.\n    - interactions: A list of tuples (i, j, factor) where i and j are species indices, and factor\n      is the impact of species i on species j's growth rate (positive for beneficial, negative for harmful).\n    - generations: The number of generations to simulate.\n\n    Returns the final population of each species after the specified number of generations.\n\n\n    [EXAMPLES]\n    \n    assert candidate([10, 20], [(0, 1, 0.5), (1, 0, -0.5)], 30) == [0, 120]\n    assert candidate([1000000, 1, 1, 1, 1], [(0, 1, -0.1), (0, 2, -0.1), (0, 3, -0.1), (0, 4, -0.1)], 500) == [1000000, 0, 0, 0, 0]\n\n    [/EXAMPLES]\n    \"\"\"\n```\n", "entry_point": "simulate_ecosystem", "solution": "from typing import List, Tuple\n\ndef simulate_ecosystem(initial_population: List[int], interactions: List[Tuple[int, int, float]], generations: int) -> List[int]:\n    \"\"\"\n    A biologist is studying the interactions between different species in an ecosystem.\n    This function simulates the population changes over time based on the initial population\n    of each species and their interactions.\n\n    Parameters:\n    - initial_population: A list of integers representing the initial population of each species.\n    - interactions: A list of tuples (i, j, factor) where i and j are species indices, and factor\n      is the impact of species i on species j's growth rate (positive for beneficial, negative for harmful).\n    - generations: The number of generations to simulate.\n\n    Returns the final population of each species after the specified number of generations.\n\n\n    [EXAMPLES]\n    \n    assert candidate([10, 20], [(0, 1, 0.5), (1, 0, -0.5)], 30) == [0, 120]\n    assert candidate([1000000, 1, 1, 1, 1], [(0, 1, -0.1), (0, 2, -0.1), (0, 3, -0.1), (0, 4, -0.1)], 500) == [1000000, 0, 0, 0, 0]\n\n    [/EXAMPLES]\n    \"\"\"\n    def calculate_growth_rate(species: int, populations: List[int]) -> float:\n        growth_rate = 1.0\n        for i, j, factor in interactions:\n            if j == species:\n                growth_rate += factor * populations[i]\n        return growth_rate\n\n    population = initial_population.copy()\n\n    for _ in range(generations):\n        new_population = []\n        for i, count in enumerate(population):\n            growth_rate = calculate_growth_rate(i, population)\n            new_count = int(count * growth_rate)\n            new_count = max(0, new_count)  # Ensure population doesn't go negative\n            new_population.append(new_count)\n        population = new_population\n\n    return population\n\n", "test": "def check(candidate):\n    assert candidate([0, 10, 20], [(1, 2, 0.1)], 50) == [0, 10, 22517998136852480]\n    assert candidate([1, 10000], [(1, 0, 0.9)], 10) == [3490660543566512068861261254434731589632, 10000]\n    assert candidate([100, 50, 80], [(0, 1, -0.1), (1, 2, 0.2), (2, 0, 0.1)], 10) == [315320763336736702464, 0, 880]\n    assert candidate([1000000, 1, 1, 1, 1], [(0, 1, -0.1), (0, 2, -0.1), (0, 3, -0.1), (0, 4, -0.1)], 500) == [1000000, 0, 0, 0, 0]\n    assert candidate([10, 20, 30, 40], [(0, 1, 0.1), (1, 2, -0.2), (2, 3, 0.3), (3, 0, -0.1)], 15) == [0, 40, 0, 400]\n    assert candidate([1000000, 1000000], [(0, 1, -0.00001), (1, 0, -0.00001)], 100) == [0, 0]\n    assert candidate([100, 100, 100, 100], [(0, 1, -0.1), (1, 2, -0.1), (2, 3, -0.1), (3, 0, -0.1)], 30) == [0, 0, 0, 0]\n    assert candidate([10000, 1], [(0, 1, -0.9)], 10) == [10000, 0]\n    assert candidate([1000, 1000, 1000], [(0, 1, -0.2), (1, 2, -0.2), (2, 0, -0.2)], 80) == [0, 0, 0]\n    assert candidate([10, 20], [(0, 1, 0.5), (1, 0, -0.5)], 30) == [0, 120]\n", "language": "python"}
{"task_id": "af0a9b53-14f5-45b0-94ab-5c1b57f6ebf6-7175721120800621272", "prompt": "I'll need you to finish a specified function that can be run as-is within one code block. Don't add any code outside the function scope. Use only the libraries that are already imported in the problem statement. Any additional functions or classes must be defined within the main function. Provide exactly one code block in your response.\n\n```python\nimport math\n\ndef design_circular_garden(radius: float, plant_spacing: float) -> int:\n    \"\"\"\n    A landscape architect is designing a circular garden and needs to determine\n    the maximum number of plants that can be placed along the circumference of the garden,\n    given a specific spacing between plants.\n\n    This function calculates the number of plants that can fit around the circular garden's edge,\n    considering the garden's radius and the required spacing between plants.\n\n\n    [EXAMPLES]\n    \n    assert candidate(30.0, 1.0) == 188\n    assert candidate(8.75, 1.75) == 31\n\n    [/EXAMPLES]\n    \"\"\"\n```\n", "entry_point": "design_circular_garden", "solution": "import math\n\ndef design_circular_garden(radius: float, plant_spacing: float) -> int:\n    \"\"\"\n    A landscape architect is designing a circular garden and needs to determine\n    the maximum number of plants that can be placed along the circumference of the garden,\n    given a specific spacing between plants.\n\n    This function calculates the number of plants that can fit around the circular garden's edge,\n    considering the garden's radius and the required spacing between plants.\n\n\n    [EXAMPLES]\n    \n    assert candidate(30.0, 1.0) == 188\n    assert candidate(8.75, 1.75) == 31\n\n    [/EXAMPLES]\n    \"\"\"\n    # Calculate the circumference of the garden\n    circumference = 2 * math.pi * radius\n    \n    # Calculate the number of plants that can fit along the circumference\n    # We use floor division (//) to ensure we get an integer result\n    # We don't round up because we can't have partial plants\n    num_plants = int(circumference // plant_spacing)\n    \n    return num_plants\n\n", "test": "def check(candidate):\n    assert candidate(10.0, 2.0) == 31\n    assert candidate(8.75, 1.75) == 31\n    assert candidate(100.0, 5.0) == 125\n    assert candidate(0.5, 0.05) == 62\n    assert candidate(0.001, 0.0001) == 62\n    assert candidate(7.5, 2.5) == 18\n    assert candidate(6.28, 1.0) == 39\n    assert candidate(30.0, 1.0) == 188\n    assert candidate(3.0, 0.5) == 37\n    assert candidate(50.0, 10.0) == 31\n", "language": "python"}
{"task_id": "bc6e88ba-aa74-4836-8c91-e804cb17e2278089996104879475858", "prompt": "As your coding assistant, I'll complete the function you provide so it's ready to run. I'll work strictly within the function block, utilizing only the libraries already imported. If needed, I'll define additional helper functions or classes within your main function.\n\n```python\nfrom typing import List\n\ndef find_unique_paths(grid: List[List[int]]) -> int:\n    \"\"\"\n    Calculate the number of unique paths through a grid with obstacles.\n\n    Given a grid represented by a 2D list of integers where 0 represents an\n    empty cell and 1 represents an obstacle, this function determines the\n    number of unique paths from the top-left corner to the bottom-right corner.\n\n    The function uses dynamic programming to efficiently compute the result,\n    taking into account that you can only move right or down.\n\n\n    [EXAMPLES]\n    \n    assert candidate([[0,0,0,0],[0,0,0,0],[0,0,0,0],[0,0,0,0]]) == 20\n    assert candidate([[0,0,0],[0,1,0],[0,0,0]]) == 2\n\n    [/EXAMPLES]\n    \"\"\"\n```\n", "entry_point": "find_unique_paths", "solution": "from typing import List\n\ndef find_unique_paths(grid: List[List[int]]) -> int:\n    \"\"\"\n    Calculate the number of unique paths through a grid with obstacles.\n\n    Given a grid represented by a 2D list of integers where 0 represents an\n    empty cell and 1 represents an obstacle, this function determines the\n    number of unique paths from the top-left corner to the bottom-right corner.\n\n    The function uses dynamic programming to efficiently compute the result,\n    taking into account that you can only move right or down.\n\n\n    [EXAMPLES]\n    \n    assert candidate([[0,0,0,0],[0,0,0,0],[0,0,0,0],[0,0,0,0]]) == 20\n    assert candidate([[0,0,0],[0,1,0],[0,0,0]]) == 2\n\n    [/EXAMPLES]\n    \"\"\"\n    if not grid or not grid[0]:\n        return 0\n\n    m, n = len(grid), len(grid[0])\n    \n    # Initialize the DP table\n    dp = [[0] * n for _ in range(m)]\n    \n    # Initialize the first cell\n    dp[0][0] = 1 if grid[0][0] == 0 else 0\n    \n    # Initialize the first row\n    for j in range(1, n):\n        if grid[0][j] == 0:\n            dp[0][j] = dp[0][j-1]\n    \n    # Initialize the first column\n    for i in range(1, m):\n        if grid[i][0] == 0:\n            dp[i][0] = dp[i-1][0]\n    \n    # Fill the DP table\n    for i in range(1, m):\n        for j in range(1, n):\n            if grid[i][j] == 0:\n                dp[i][j] = dp[i-1][j] + dp[i][j-1]\n    \n    # Return the number of unique paths to the bottom-right corner\n    return dp[m-1][n-1]\n\n", "test": "def check(candidate):\n    assert candidate([[0,0,0,0],[0,0,0,0],[0,0,0,0],[0,0,0,0]]) == 20\n    assert candidate([[0,0,0],[0,0,0],[0,0,1]]) == 0\n    assert candidate([[0]]) == 1\n    assert candidate([[0,0],[0,1]]) == 0\n    assert candidate([[0,0],[0,0]]) == 2\n    assert candidate([[0,0,0],[0,1,0],[0,0,0]]) == 2\n    assert candidate([[1,1,1,1],[1,1,1,1],[1,1,1,1],[1,1,1,0]]) == 0\n    assert candidate([[1,0],[0,0]]) == 0\n    assert candidate([[0,0,0,0],[0,1,0,0],[0,0,1,0],[0,0,0,0]]) == 4\n    assert candidate([[0,0,0],[0,0,0],[0,0,0]]) == 6\n", "language": "python"}
{"task_id": "ed870fc4-0226-4ce8-a44a-7b03ea1a66bc-1143731049238640813", "prompt": "I'll complete the given function so it can be executed as is. I'll use only the libraries imported in the problem statement and will place any additional functions or classes inside the main function.\n\n```python\nfrom typing import List\n\ndef optimize_study_plan(subjects: List[str], difficulties: List[int], time_available: int) -> List[str]:\n    \"\"\"\n    A student wants to optimize their study plan for an upcoming exam. This function helps determine the best combination of subjects to study given limited time.\n\n    Each subject has a difficulty level, which represents the time needed to study it effectively. The goal is to maximize the number of subjects studied within the available time, prioritizing more difficult subjects.\n\n    Parameters:\n    subjects (List[str]): List of subject names.\n    difficulties (List[int]): List of corresponding difficulty levels for each subject.\n    time_available (int): Total time available for studying (in hours).\n\n    Returns:\n    List[str]: A list of subjects that should be studied to maximize preparation within the given time constraint.\n\n\n    [EXAMPLES]\n    \n    assert candidate([\"Data Structures\", \"Algorithms\", \"Operating Systems\", \"Computer Networks\", \"Database Systems\"], [4, 5, 4, 3, 4], 15) == ['Algorithms', 'Data Structures', 'Operating Systems']\n    assert candidate([\"Piano\", \"Guitar\", \"Drums\", \"Violin\", \"Flute\"], [4, 3, 3, 4, 2], 11) == ['Piano', 'Violin', 'Guitar']\n\n    [/EXAMPLES]\n    \"\"\"\n```\n", "entry_point": "optimize_study_plan", "solution": "from typing import List\n\ndef optimize_study_plan(subjects: List[str], difficulties: List[int], time_available: int) -> List[str]:\n    \"\"\"\n    A student wants to optimize their study plan for an upcoming exam. This function helps determine the best combination of subjects to study given limited time.\n\n    Each subject has a difficulty level, which represents the time needed to study it effectively. The goal is to maximize the number of subjects studied within the available time, prioritizing more difficult subjects.\n\n    Parameters:\n    subjects (List[str]): List of subject names.\n    difficulties (List[int]): List of corresponding difficulty levels for each subject.\n    time_available (int): Total time available for studying (in hours).\n\n    Returns:\n    List[str]: A list of subjects that should be studied to maximize preparation within the given time constraint.\n\n\n    [EXAMPLES]\n    \n    assert candidate([\"Data Structures\", \"Algorithms\", \"Operating Systems\", \"Computer Networks\", \"Database Systems\"], [4, 5, 4, 3, 4], 15) == ['Algorithms', 'Data Structures', 'Operating Systems']\n    assert candidate([\"Piano\", \"Guitar\", \"Drums\", \"Violin\", \"Flute\"], [4, 3, 3, 4, 2], 11) == ['Piano', 'Violin', 'Guitar']\n\n    [/EXAMPLES]\n    \"\"\"\n    \n    # Create a list of tuples containing (subject, difficulty)\n    subject_difficulty_pairs = list(zip(subjects, difficulties))\n    \n    # Sort the pairs by difficulty in descending order\n    subject_difficulty_pairs.sort(key=lambda x: x[1], reverse=True)\n    \n    optimal_plan = []\n    remaining_time = time_available\n    \n    for subject, difficulty in subject_difficulty_pairs:\n        if difficulty <= remaining_time:\n            optimal_plan.append(subject)\n            remaining_time -= difficulty\n        else:\n            break\n    \n    return optimal_plan\n\n", "test": "def check(candidate):\n    assert candidate([\"Math\", \"Physics\", \"Chemistry\", \"Biology\", \"History\"], [4, 3, 3, 2, 1], 10) == ['Math', 'Physics', 'Chemistry']\n    assert candidate([\"Data Structures\", \"Algorithms\", \"Operating Systems\", \"Computer Networks\", \"Database Systems\"], [4, 5, 4, 3, 4], 15) == ['Algorithms', 'Data Structures', 'Operating Systems']\n    assert candidate([\"Classical Mechanics\", \"Electromagnetism\", \"Thermodynamics\", \"Quantum Mechanics\", \"Optics\"], [4, 4, 3, 5, 3], 16) == ['Quantum Mechanics', 'Classical Mechanics', 'Electromagnetism', 'Thermodynamics']\n    assert candidate([\"Astronomy\", \"Geology\", \"Meteorology\", \"Oceanography\"], [4, 3, 3, 3], 11) == ['Astronomy', 'Geology', 'Meteorology']\n    assert candidate([\"Piano\", \"Guitar\", \"Drums\", \"Violin\", \"Flute\"], [4, 3, 3, 4, 2], 11) == ['Piano', 'Violin', 'Guitar']\n    assert candidate([\"Microeconomics\", \"Macroeconomics\", \"International Economics\"], [3, 4, 4], 7) == ['Macroeconomics']\n    assert candidate([\"Calculus\", \"Linear Algebra\", \"Statistics\", \"Discrete Math\"], [5, 4, 3, 4], 10) == ['Calculus', 'Linear Algebra']\n    assert candidate([\"Psychology\", \"Sociology\", \"Anthropology\"], [4, 3, 4], 6) == ['Psychology']\n", "language": "python"}
{"task_id": "04969393-4ef8-4844-a295-aa3d744c98a9-9222229333334208326", "prompt": "Based on the docstring provided, finish implementing this function. Present the complete code in one block without altering the function name or parameter list.\n\n```python\nfrom typing import List, Tuple\nfrom collections import defaultdict\n\ndef optimize_network_flow(nodes: int, edges: List[Tuple[int, int, int]], source: int, sink: int) -> int:\n    \"\"\"\n    A telecommunications company wants to optimize the flow of data through their network.\n    This function calculates the maximum flow possible from a source node to a sink node in a network.\n\n    The function uses the Ford-Fulkerson algorithm to compute the maximum flow in the network.\n    It takes the number of nodes, a list of edges (each represented as a tuple of source, destination, and capacity),\n    and the source and sink nodes as input.\n\n    Args:\n    nodes (int): The number of nodes in the network\n    edges (List[Tuple[int, int, int]]): A list of edges, where each edge is (source, destination, capacity)\n    source (int): The source node\n    sink (int): The sink node\n\n    Returns:\n    int: The maximum flow possible from source to sink\n\n\n    [EXAMPLES]\n    \n    assert candidate(2, [(0,1,5)], 0, 1) == 5\n    assert candidate(4, [(0,1,1000000), (1,2,1000000), (2,3,1000000)], 0, 3) == 1000000\n\n    [/EXAMPLES]\n    \"\"\"\n```\n", "entry_point": "optimize_network_flow", "solution": "from typing import List, Tuple\nfrom collections import defaultdict\n\ndef optimize_network_flow(nodes: int, edges: List[Tuple[int, int, int]], source: int, sink: int) -> int:\n    \"\"\"\n    A telecommunications company wants to optimize the flow of data through their network.\n    This function calculates the maximum flow possible from a source node to a sink node in a network.\n\n    The function uses the Ford-Fulkerson algorithm to compute the maximum flow in the network.\n    It takes the number of nodes, a list of edges (each represented as a tuple of source, destination, and capacity),\n    and the source and sink nodes as input.\n\n    Args:\n    nodes (int): The number of nodes in the network\n    edges (List[Tuple[int, int, int]]): A list of edges, where each edge is (source, destination, capacity)\n    source (int): The source node\n    sink (int): The sink node\n\n    Returns:\n    int: The maximum flow possible from source to sink\n\n\n    [EXAMPLES]\n    \n    assert candidate(2, [(0,1,5)], 0, 1) == 5\n    assert candidate(4, [(0,1,1000000), (1,2,1000000), (2,3,1000000)], 0, 3) == 1000000\n\n    [/EXAMPLES]\n    \"\"\"\n    def bfs(graph, source, sink, parent):\n        visited = [False] * nodes\n        queue = []\n        \n        queue.append(source)\n        visited[source] = True\n        \n        while queue:\n            u = queue.pop(0)\n            for v, capacity in graph[u].items():\n                if not visited[v] and capacity > 0:\n                    queue.append(v)\n                    visited[v] = True\n                    parent[v] = u\n                    if v == sink:\n                        return True\n        \n        return False\n\n    # Create a residual graph\n    graph = defaultdict(dict)\n    for u, v, capacity in edges:\n        graph[u][v] = capacity\n        graph[v][u] = 0  # Reverse edge\n\n    parent = [-1] * nodes\n    max_flow = 0\n\n    while bfs(graph, source, sink, parent):\n        path_flow = float('inf')\n        s = sink\n        while s != source:\n            path_flow = min(path_flow, graph[parent[s]][s])\n            s = parent[s]\n\n        max_flow += path_flow\n\n        v = sink\n        while v != source:\n            u = parent[v]\n            graph[u][v] -= path_flow\n            graph[v][u] += path_flow\n            v = parent[v]\n\n    return max_flow\n\n", "test": "def check(candidate):\n    assert candidate(5, [(0,1,1), (1,2,2), (2,3,3), (3,4,4)], 0, 4) == 1\n    assert candidate(4, [(0,1,7), (0,2,4), (1,2,3), (1,3,5), (2,3,2)], 0, 3) == 7\n    assert candidate(2, [(0,1,5)], 0, 1) == 5\n    assert candidate(5, [(0,1,10), (1,2,5), (1,3,5), (2,4,5), (3,4,5)], 0, 4) == 10\n    assert candidate(4, [(0,1,5), (0,2,5), (1,3,3), (2,3,3), (1,2,2)], 0, 3) == 6\n    assert candidate(5, [(0,1,5), (1,2,3), (2,3,2), (3,4,4), (0,4,7)], 0, 4) == 9\n    assert candidate(5, [(0,1,3), (0,2,2), (1,2,1), (1,3,3), (2,3,4), (3,4,5)], 0, 4) == 5\n    assert candidate(4, [(0,1,1000000), (1,2,1000000), (2,3,1000000)], 0, 3) == 1000000\n    assert candidate(6, [(0,1,10), (0,2,10), (1,3,5), (2,3,5), (3,4,10), (4,5,10)], 0, 5) == 10\n    assert candidate(3, [(0,1,100), (1,2,1)], 0, 2) == 1\n", "language": "python"}
{"task_id": "3ad63291-f4fe-403a-aa0c-a07aac49f8b75057681555743904611", "prompt": "Implement the requested function as a single, executable code block. Don't include any code outside the function definition. Only use libraries that are already imported in the problem description. Any additional helper functions or classes must be defined inside the main function. Your response should consist of only one code block.\n\n```python\ndef encrypt_message(message: str, key: int) -> str:\n    \"\"\"\n    A secret agent needs to send an encrypted message to headquarters. The\n    encryption method works as follows:\n    1. Convert each character to its ASCII value.\n    2. Add the key to the ASCII value.\n    3. Take the modulo 128 of the result (to wrap around the ASCII table).\n    4. Convert the new value back to a character.\n\n    This function takes a message string and an integer key, and returns the\n    encrypted message. Use list comprehension and the built-in ord() and chr()\n    functions to implement this encryption method.\n\n\n    [EXAMPLES]\n    \n    assert candidate(\"Z\", 127) == 'Y'\n    assert candidate(\"Min ASCII: \", 2) == 'Okp\"CUEKK<\"'\n\n    [/EXAMPLES]\n    \"\"\"\n```\n", "entry_point": "encrypt_message", "solution": "def encrypt_message(message: str, key: int) -> str:\n    \"\"\"\n    A secret agent needs to send an encrypted message to headquarters. The\n    encryption method works as follows:\n    1. Convert each character to its ASCII value.\n    2. Add the key to the ASCII value.\n    3. Take the modulo 128 of the result (to wrap around the ASCII table).\n    4. Convert the new value back to a character.\n\n    This function takes a message string and an integer key, and returns the\n    encrypted message. Use list comprehension and the built-in ord() and chr()\n    functions to implement this encryption method.\n\n\n    [EXAMPLES]\n    \n    assert candidate(\"Z\", 127) == 'Y'\n    assert candidate(\"Min ASCII: \", 2) == 'Okp\"CUEKK<\"'\n\n    [/EXAMPLES]\n    \"\"\"\n    return ''.join([chr((ord(char) + key) % 128) for char in message])\n\n", "test": "def check(candidate):\n    assert candidate(\"Hello\\nWorld\", 30) == 'f\\x03\\n\\n\\r(u\\r\\x10\\n\\x02'\n    assert candidate(\"Z\", 127) == 'Y'\n    assert candidate(\"Min ASCII: \", 2) == 'Okp\"CUEKK<\"'\n    assert candidate(\"Secret Agent\", 7) == \"Zljyl{'Hnlu{\"\n", "language": "python"}
{"task_id": "03f769de-6f70-4647-b658-e78dbb8b9b0c-1293605806488868369", "prompt": "I'll complete the code within one single code block, with any helper functions or classes defined inside the given function as requested.\n\n```python\ndef analyze_stock_trends(prices: list) -> tuple:\n    \"\"\"\n    A financial analyst needs to analyze a series of daily stock prices to identify the best days\n    for buying and selling to maximize profit.\n\n    This function takes a list of stock prices and returns a tuple containing:\n    1. The maximum profit that could be made\n    2. The day to buy (index)\n    3. The day to sell (index)\n\n    If no profit can be made, return (0, -1, -1).\n\n\n    [EXAMPLES]\n    \n    assert candidate([1, 2, 3, 4, 3, 2, 1]) == (3, 0, 3)\n    assert candidate([7, 1, 5, 3, 6, 4]) == (5, 1, 4)\n\n    [/EXAMPLES]\n    \"\"\"\n```\n", "entry_point": "analyze_stock_trends", "solution": "def analyze_stock_trends(prices: list) -> tuple:\n    \"\"\"\n    A financial analyst needs to analyze a series of daily stock prices to identify the best days\n    for buying and selling to maximize profit.\n\n    This function takes a list of stock prices and returns a tuple containing:\n    1. The maximum profit that could be made\n    2. The day to buy (index)\n    3. The day to sell (index)\n\n    If no profit can be made, return (0, -1, -1).\n\n\n    [EXAMPLES]\n    \n    assert candidate([1, 2, 3, 4, 3, 2, 1]) == (3, 0, 3)\n    assert candidate([7, 1, 5, 3, 6, 4]) == (5, 1, 4)\n\n    [/EXAMPLES]\n    \"\"\"\n    if len(prices) < 2:\n        return (0, -1, -1)\n\n    max_profit = 0\n    buy_day = -1\n    sell_day = -1\n    min_price = float('inf')\n    min_day = 0\n\n    for current_day, price in enumerate(prices):\n        if price < min_price:\n            min_price = price\n            min_day = current_day\n        \n        current_profit = price - min_price\n        if current_profit > max_profit:\n            max_profit = current_profit\n            buy_day = min_day\n            sell_day = current_day\n\n    if max_profit == 0:\n        return (0, -1, -1)\n    else:\n        return (max_profit, buy_day, sell_day)\n\n", "test": "def check(candidate):\n    assert candidate([10]) == (0, -1, -1)\n    assert candidate([2, 1]) == (0, -1, -1)\n    assert candidate([7, 1, 5, 3, 6, 4]) == (5, 1, 4)\n    assert candidate([1, 5, 1, 5, 1, 5]) == (4, 0, 1)\n    assert candidate([5, 0, 0, 0, 0]) == (0, -1, -1)\n    assert candidate([3, 3, 5, 0, 0, 3, 1, 4]) == (4, 3, 7)\n    assert candidate([1, 2, 3, 4, 3, 2, 1]) == (3, 0, 3)\n    assert candidate([1, 2]) == (1, 0, 1)\n    assert candidate([0, 100, 0, 100, 0, 100]) == (100, 0, 1)\n    assert candidate([10, 9, 8, 7, 6, 5, 4, 3, 2, 1, 0]) == (0, -1, -1)\n", "language": "python"}
{"task_id": "e4a9d722-e162-431c-a7e4-5a2b41152e0e4909227672057097297", "prompt": "I'll provide a complete function implementation in a single code block. The function will be self-contained and ready to execute. Any helper functions or classes needed will be defined inside the main function, and I'll only use the libraries that are included in the problem statement.\n\n```python\nfrom typing import List, Tuple\nimport heapq\n\ndef optimize_network_latency(nodes: int, connections: List[Tuple[int, int, int]], source: int) -> List[int]:\n    \"\"\"Optimize network latency in a distributed system.\n\n    Given a number of nodes, a list of connections (source, target, latency),\n    and a source node, calculate the minimum latency to reach each node from the source.\n    Use Dijkstra's algorithm with a priority queue for efficient computation.\n    Return a list of minimum latencies, where the index represents the node number.\n\n\n    [EXAMPLES]\n    \n    assert candidate(7, [(0, 1, 1), (1, 2, 1), (2, 3, 1), (3, 4, 1), (4, 5, 1), (5, 6, 1), (0, 6, 10)], 0) == [0, 1, 2, 3, 4, 5, 6]\n    assert candidate(7, [(0, 1, 2), (0, 2, 6), (1, 3, 5), (2, 3, 8), (2, 4, 4), (3, 5, 3), (4, 5, 2), (5, 6, 1)], 0) == [0, 2, 6, 7, 10, 10, 11]\n\n    [/EXAMPLES]\n    \"\"\"\n```\n", "entry_point": "optimize_network_latency", "solution": "from typing import List, Tuple\nimport heapq\n\ndef optimize_network_latency(nodes: int, connections: List[Tuple[int, int, int]], source: int) -> List[int]:\n    \"\"\"Optimize network latency in a distributed system.\n\n    Given a number of nodes, a list of connections (source, target, latency),\n    and a source node, calculate the minimum latency to reach each node from the source.\n    Use Dijkstra's algorithm with a priority queue for efficient computation.\n    Return a list of minimum latencies, where the index represents the node number.\n\n\n    [EXAMPLES]\n    \n    assert candidate(7, [(0, 1, 1), (1, 2, 1), (2, 3, 1), (3, 4, 1), (4, 5, 1), (5, 6, 1), (0, 6, 10)], 0) == [0, 1, 2, 3, 4, 5, 6]\n    assert candidate(7, [(0, 1, 2), (0, 2, 6), (1, 3, 5), (2, 3, 8), (2, 4, 4), (3, 5, 3), (4, 5, 2), (5, 6, 1)], 0) == [0, 2, 6, 7, 10, 10, 11]\n\n    [/EXAMPLES]\n    \"\"\"\n    # Create an adjacency list to represent the graph\n    graph = [[] for _ in range(nodes)]\n    for src, dst, latency in connections:\n        graph[src].append((dst, latency))\n        graph[dst].append((src, latency))  # Assuming bidirectional connections\n\n    # Initialize distances with infinity, except for the source node\n    distances = [float('inf')] * nodes\n    distances[source] = 0\n\n    # Priority queue to store nodes to visit (latency, node)\n    pq = [(0, source)]\n\n    while pq:\n        current_latency, current_node = heapq.heappop(pq)\n\n        # If we've found a longer path, skip\n        if current_latency > distances[current_node]:\n            continue\n\n        # Check all neighbors of the current node\n        for neighbor, latency in graph[current_node]:\n            new_latency = current_latency + latency\n\n            # If we've found a shorter path, update and add to queue\n            if new_latency < distances[neighbor]:\n                distances[neighbor] = new_latency\n                heapq.heappush(pq, (new_latency, neighbor))\n\n    return distances\n\n", "test": "def check(candidate):\n    assert candidate(7, [(0, 1, 2), (0, 2, 6), (1, 3, 5), (2, 3, 8), (2, 4, 4), (3, 5, 3), (4, 5, 2), (5, 6, 1)], 0) == [0, 2, 6, 7, 10, 10, 11]\n    assert candidate(3, [(0, 1, 5), (1, 2, 5), (0, 2, 11)], 0) == [0, 5, 10]\n    assert candidate(6, [(0, 1, 1), (1, 2, 2), (2, 3, 3), (3, 4, 4), (4, 5, 5), (5, 0, 6)], 0) == [0, 1, 3, 6, 10, 6]\n    assert candidate(4, [(0, 1, 1), (0, 2, 1), (0, 3, 1)], 0) == [0, 1, 1, 1]\n    assert candidate(5, [(0, 1, 1), (1, 2, 2), (2, 3, 3), (3, 4, 4), (0, 4, 20)], 0) == [0, 1, 3, 6, 10]\n    assert candidate(4, [(0, 1, 10), (0, 2, 5), (1, 2, 2), (1, 3, 1), (2, 3, 4)], 0) == [0, 7, 5, 8]\n    assert candidate(4, [(0, 1, 10), (1, 2, 20), (2, 3, 30), (3, 0, 40)], 2) == [30, 20, 0, 30]\n    assert candidate(5, [(0, 1, 1), (1, 2, 2), (2, 3, 3), (3, 4, 4), (4, 0, 5)], 4) == [5, 6, 7, 4, 0]\n    assert candidate(7, [(0, 1, 1), (1, 2, 1), (2, 3, 1), (3, 4, 1), (4, 5, 1), (5, 6, 1), (0, 6, 10)], 0) == [0, 1, 2, 3, 4, 5, 6]\n    assert candidate(3, [(0, 1, 1), (1, 2, 1)], 0) == [0, 1, 2]\n", "language": "python"}
{"task_id": "036320ab-f5dc-4bce-ad7e-8be6091358c6-7076873123614046832", "prompt": "I'll deliver a single code block containing the complete function implementation. All supporting functions or classes will be defined inside the main function. The solution will only use libraries that are mentioned in the imports.\n\n```python\ndef compress_rle(data: str) -> str:\n    \"\"\"Compress a string using Run-Length Encoding (RLE).\n\n    This function implements the Run-Length Encoding (RLE) algorithm to compress\n    a given string. RLE works by replacing consecutive repeated characters with\n    the character followed by the number of occurrences.\n\n    Args:\n        data (str): The input string to be compressed.\n\n    Returns:\n        str: The compressed string using RLE.\n\n\n    [EXAMPLES]\n    \n    assert candidate(\"WWWWWWWWWWWWBWWWWWWWWWWWWBBBWWWWWWWWWWWWWWWWWWB\") == 'W12B1W12B3W18B1'\n    assert candidate(\"aabbccddee\") == 'a2b2c2d2e2'\n\n    [/EXAMPLES]\n    \"\"\"\n```\n", "entry_point": "compress_rle", "solution": "def compress_rle(data: str) -> str:\n    \"\"\"Compress a string using Run-Length Encoding (RLE).\n\n    This function implements the Run-Length Encoding (RLE) algorithm to compress\n    a given string. RLE works by replacing consecutive repeated characters with\n    the character followed by the number of occurrences.\n\n    Args:\n        data (str): The input string to be compressed.\n\n    Returns:\n        str: The compressed string using RLE.\n\n\n    [EXAMPLES]\n    \n    assert candidate(\"WWWWWWWWWWWWBWWWWWWWWWWWWBBBWWWWWWWWWWWWWWWWWWB\") == 'W12B1W12B3W18B1'\n    assert candidate(\"aabbccddee\") == 'a2b2c2d2e2'\n\n    [/EXAMPLES]\n    \"\"\"\n    if not data:\n        return \"\"\n\n    compressed = []\n    count = 1\n    current_char = data[0]\n\n    for char in data[1:]:\n        if char == current_char:\n            count += 1\n        else:\n            compressed.append(current_char + str(count))\n            current_char = char\n            count = 1\n\n    compressed.append(current_char + str(count))\n\n    return ''.join(compressed)\n\n", "test": "def check(candidate):\n    assert candidate(\"aabbccddee\") == 'a2b2c2d2e2'\n    assert candidate(\"WWWWWWWWWWWWBWWWWWWWWWWWWBBBWWWWWWWWWWWWWWWWWWB\") == 'W12B1W12B3W18B1'\n    assert candidate(\"AB\" * 50) == 'A1B1A1B1A1B1A1B1A1B1A1B1A1B1A1B1A1B1A1B1A1B1A1B1A1B1A1B1A1B1A1B1A1B1A1B1A1B1A1B1A1B1A1B1A1B1A1B1A1B1A1B1A1B1A1B1A1B1A1B1A1B1A1B1A1B1A1B1A1B1A1B1A1B1A1B1A1B1A1B1A1B1A1B1A1B1A1B1A1B1A1B1A1B1A1B1A1B1A1B1'\n    assert candidate(\"\\n\\n\\n\\t\\t\\t\") == '\\n3\\t3'\n", "language": "python"}
{"task_id": "849d4366-6e69-4b89-9c0d-8671acf4ed3f8939960063333285934", "prompt": "The function will be implemented in full within one executable code block. I'll restrict my use to libraries specified in the imports. All supporting functions and classes will be defined within the main function's body.\n\n```python\ndef calculate_galaxy_distance(x1: float, y1: float, z1: float, x2: float, y2: float, z2: float) -> float:\n    \"\"\"\n    In an intergalactic navigation system, this function calculates the Euclidean distance between two galaxies\n    in a three-dimensional space. The coordinates of each galaxy are represented by (x, y, z) values.\n\n    Args:\n    x1, y1, z1 (float): Coordinates of the first galaxy.\n    x2, y2, z2 (float): Coordinates of the second galaxy.\n\n    Returns:\n    float: The distance between the two galaxies in light-years.\n\n\n    [EXAMPLES]\n    \n    assert candidate(1, 0, 0, 0, 1, 0) == 1.4142135623730951\n    assert candidate(0, 0, 0, 0, 0, 0) == 0.0\n\n    [/EXAMPLES]\n    \"\"\"\n```\n", "entry_point": "calculate_galaxy_distance", "solution": "def calculate_galaxy_distance(x1: float, y1: float, z1: float, x2: float, y2: float, z2: float) -> float:\n    \"\"\"\n    In an intergalactic navigation system, this function calculates the Euclidean distance between two galaxies\n    in a three-dimensional space. The coordinates of each galaxy are represented by (x, y, z) values.\n\n    Args:\n    x1, y1, z1 (float): Coordinates of the first galaxy.\n    x2, y2, z2 (float): Coordinates of the second galaxy.\n\n    Returns:\n    float: The distance between the two galaxies in light-years.\n\n\n    [EXAMPLES]\n    \n    assert candidate(1, 0, 0, 0, 1, 0) == 1.4142135623730951\n    assert candidate(0, 0, 0, 0, 0, 0) == 0.0\n\n    [/EXAMPLES]\n    \"\"\"\n    import math\n\n    # Calculate the differences in each dimension\n    dx = x2 - x1\n    dy = y2 - y1\n    dz = z2 - z1\n\n    # Calculate the squared distance\n    squared_distance = dx**2 + dy**2 + dz**2\n\n    # Calculate the Euclidean distance using the square root of the squared distance\n    distance = math.sqrt(squared_distance)\n\n    return distance\n\n", "test": "def check(candidate):\n    assert candidate(-1.5, 2.7, 3.1, 4.2, -0.8, 1.9) == 6.795586803212803\n    assert candidate(1000000, 1000000, 1000000, -1000000, -1000000, -1000000) == 3464101.6151377545\n    assert candidate(1.23456789, 2.34567891, 3.45678912, 4.56789123, 5.67891234, 6.78912345) == 5.772862519994294\n    assert candidate(0, 0, 0, 0, 0, 0) == 0.0\n    assert candidate(-5000, 0, 5000, 5000, 0, -5000) == 14142.13562373095\n    assert candidate(0.1, 0.2, 0.3, 0.4, 0.5, 0.6) == 0.5196152422706632\n    assert candidate(-1e10, 1e10, -1e10, 1e10, -1e10, 1e10) == 34641016151.37755\n    assert candidate(1, 0, 0, 0, 1, 0) == 1.4142135623730951\n    assert candidate(0.5, -0.5, 0.5, -0.5, 0.5, -0.5) == 1.7320508075688772\n    assert candidate(3.14159, 2.71828, 1.41421, 0, 0, 0) == 4.3884648580796455\n", "language": "python"}
{"task_id": "24b18d7a-2946-4c05-b179-cef2abcf4ea65210194793524006404", "prompt": "Code the implementation of the function according to the documentation string specifications. Present the entire function in one consolidated code block.\n\n```python\nfrom typing import List\nimport re\n\ndef alien_dictionary(words: List[str]) -> str:\n    \"\"\"\n    An alien civilization uses a unique alphabetical order for their language.\n    Given a list of words sorted lexicographically in this alien language,\n    deduce and return the order of the alien alphabet as a string.\n    If no valid order exists, return an empty string.\n    Assume all letters are lowercase.\n\n\n    [EXAMPLES]\n    \n    assert candidate([\"abc\", \"abd\", \"abf\", \"abg\"]) == 'cdfgba'\n    assert candidate([\"aaaaa\", \"aaaa\", \"aaa\", \"aa\", \"a\"]) == ''\n\n    [/EXAMPLES]\n    \"\"\"\n```\n", "entry_point": "alien_dictionary", "solution": "from typing import List\nimport re\n\ndef alien_dictionary(words: List[str]) -> str:\n    \"\"\"\n    An alien civilization uses a unique alphabetical order for their language.\n    Given a list of words sorted lexicographically in this alien language,\n    deduce and return the order of the alien alphabet as a string.\n    If no valid order exists, return an empty string.\n    Assume all letters are lowercase.\n\n\n    [EXAMPLES]\n    \n    assert candidate([\"abc\", \"abd\", \"abf\", \"abg\"]) == 'cdfgba'\n    assert candidate([\"aaaaa\", \"aaaa\", \"aaa\", \"aa\", \"a\"]) == ''\n\n    [/EXAMPLES]\n    \"\"\"\n    def build_graph(words):\n        graph = {c: set() for word in words for c in word}\n        for i in range(len(words) - 1):\n            w1, w2 = words[i], words[i + 1]\n            min_len = min(len(w1), len(w2))\n            if len(w1) > len(w2) and w1[:min_len] == w2[:min_len]:\n                return None  # Invalid order\n            for j in range(min_len):\n                if w1[j] != w2[j]:\n                    graph[w1[j]].add(w2[j])\n                    break\n        return graph\n\n    def topological_sort(graph):\n        def dfs(node):\n            if node in visited:\n                return visited[node]\n            visited[node] = False\n            for neighbor in graph[node]:\n                if dfs(neighbor) == False:\n                    return False\n            visited[node] = True\n            result.append(node)\n            return True\n\n        visited = {}\n        result = []\n        for node in graph:\n            if dfs(node) == False:\n                return \"\"\n        return \"\".join(reversed(result))\n\n    graph = build_graph(words)\n    if graph is None:\n        return \"\"\n    return topological_sort(graph)\n\n", "test": "def check(candidate):\n    assert candidate([]) == ''\n    assert candidate([\"ac\", \"ab\", \"b\"]) == 'cab'\n    assert candidate([\"z\"]) == 'z'\n    assert candidate([\"aaaaa\", \"aaaa\", \"aaa\", \"aa\", \"a\"]) == ''\n    assert candidate([\"aab\", \"ab\"]) == 'ab'\n    assert candidate([\"baa\", \"abcd\", \"abca\", \"cab\", \"cad\"]) == 'bdac'\n    assert candidate([\"abc\", \"abd\", \"abf\", \"abg\"]) == 'cdfgba'\n    assert candidate([\"z\", \"x\", \"z\"]) == ''\n    assert candidate([\"zy\", \"zx\"]) == 'yxz'\n    assert candidate([\"ab\", \"adc\"]) == 'cbda'\n", "language": "python"}
{"task_id": "75af1aff-0ce3-4cb4-b943-2f8791d48592-5234047231717608117", "prompt": "I'll write the complete function implementation based on the docstring. The code will be provided in one code block as requested.\n\n```python\nfrom typing import List, Dict\n\ndef inventory_tracker(items: List[str], quantities: List[int], restock_levels: List[int]) -> Dict[str, Dict[str, int]]:\n    \"\"\"\n    A local grocery store owner wants to keep track of their inventory and automatically generate restock orders.\n    This function takes in lists of items, their current quantities, and restock levels, then returns a nested\n    dictionary with inventory status and restock requirements.\n\n    The function should use list comprehension and dictionary comprehension to create the output.\n\n\n    [EXAMPLES]\n    \n    assert candidate(['a', 'b', 'c'], [10, 20, 30], [10, 20, 30]) == {'a': {'current': 10, 'restock': 0}, 'b': {'current': 20, 'restock': 0}, 'c': {'current': 30, 'restock': 0}}\n    assert candidate(['item1'], [10], [20]) == {'item1': {'current': 10, 'restock': 10}}\n\n    [/EXAMPLES]\n    \"\"\"\n```\n", "entry_point": "inventory_tracker", "solution": "from typing import List, Dict\n\ndef inventory_tracker(items: List[str], quantities: List[int], restock_levels: List[int]) -> Dict[str, Dict[str, int]]:\n    \"\"\"\n    A local grocery store owner wants to keep track of their inventory and automatically generate restock orders.\n    This function takes in lists of items, their current quantities, and restock levels, then returns a nested\n    dictionary with inventory status and restock requirements.\n\n    The function should use list comprehension and dictionary comprehension to create the output.\n\n\n    [EXAMPLES]\n    \n    assert candidate(['a', 'b', 'c'], [10, 20, 30], [10, 20, 30]) == {'a': {'current': 10, 'restock': 0}, 'b': {'current': 20, 'restock': 0}, 'c': {'current': 30, 'restock': 0}}\n    assert candidate(['item1'], [10], [20]) == {'item1': {'current': 10, 'restock': 10}}\n\n    [/EXAMPLES]\n    \"\"\"\n    return {\n        item: {\n            'current': quantity,\n            'restock': max(0, restock_level - quantity)\n        }\n        for item, quantity, restock_level in zip(items, quantities, restock_levels)\n    }\n\n", "test": "def check(candidate):\n    assert candidate(['item1'], [10], [20]) == {'item1': {'current': 10, 'restock': 10}}\n    assert candidate(['item1', 'item2', 'item3', 'item4', 'item5'], [1, 10, 100, 1000, 10000], [2, 20, 200, 2000, 20000]) == {'item1': {'current': 1, 'restock': 1}, 'item2': {'current': 10, 'restock': 10}, 'item3': {'current': 100, 'restock': 100}, 'item4': {'current': 1000, 'restock': 1000}, 'item5': {'current': 10000, 'restock': 10000}}\n    assert candidate(['A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J'], [1, 2, 3, 4, 5, 6, 7, 8, 9, 10], [10, 20, 30, 40, 50, 60, 70, 80, 90, 100]) == {'A': {'current': 1, 'restock': 9}, 'B': {'current': 2, 'restock': 18}, 'C': {'current': 3, 'restock': 27}, 'D': {'current': 4, 'restock': 36}, 'E': {'current': 5, 'restock': 45}, 'F': {'current': 6, 'restock': 54}, 'G': {'current': 7, 'restock': 63}, 'H': {'current': 8, 'restock': 72}, 'I': {'current': 9, 'restock': 81}, 'J': {'current': 10, 'restock': 90}}\n    assert candidate(['x', 'y'], [100, 200], [100, 200]) == {'x': {'current': 100, 'restock': 0}, 'y': {'current': 200, 'restock': 0}}\n    assert candidate(['product1', 'product2', 'product3', 'product4'], [25, 50, 75, 100], [100, 100, 100, 100]) == {'product1': {'current': 25, 'restock': 75}, 'product2': {'current': 50, 'restock': 50}, 'product3': {'current': 75, 'restock': 25}, 'product4': {'current': 100, 'restock': 0}}\n    assert candidate(['a', 'b', 'c'], [10, 20, 30], [10, 20, 30]) == {'a': {'current': 10, 'restock': 0}, 'b': {'current': 20, 'restock': 0}, 'c': {'current': 30, 'restock': 0}}\n    assert candidate(['product_a', 'product_b'], [5, 5], [10, 10]) == {'product_a': {'current': 5, 'restock': 5}, 'product_b': {'current': 5, 'restock': 5}}\n    assert candidate(['a', 'b', 'c', 'd', 'e'], [1, 2, 3, 4, 5], [10, 20, 30, 40, 50]) == {'a': {'current': 1, 'restock': 9}, 'b': {'current': 2, 'restock': 18}, 'c': {'current': 3, 'restock': 27}, 'd': {'current': 4, 'restock': 36}, 'e': {'current': 5, 'restock': 45}}\n    assert candidate(['apples', 'bananas', 'oranges'], [50, 30, 75], [100, 80, 120]) == {'apples': {'current': 50, 'restock': 50}, 'bananas': {'current': 30, 'restock': 50}, 'oranges': {'current': 75, 'restock': 45}}\n    assert candidate(['A'], [100], [100]) == {'A': {'current': 100, 'restock': 0}}\n", "language": "python"}
{"task_id": "a927d946-48fe-46ab-9a8a-6814a874e0411531838682312715401", "prompt": "I'll implement the full function according to the documentation string, preserving the original name and parameters. The entire solution will be contained in a single code block.\n\n```python\nfrom collections import Counter\nfrom typing import List\n\ndef decode_alien_message(signal: List[int]) -> str:\n    \"\"\"You've intercepted a mysterious signal from an alien civilization! The signal is a list of integers, which you believe to be an encoded message. Your task is to decode this message using the following rules:\n\n    1. Each integer represents a character in the alien alphabet.\n    2. The alien alphabet has 26 characters, similar to English, but mapped differently.\n    3. The mapping is determined by the frequency of each integer in the signal.\n    4. The most frequent integer maps to 'A', the second most frequent to 'B', and so on.\n    5. If there's a tie in frequency, the lower integer value comes first in the alphabet.\n    6. Integers that don't appear in the top 26 most frequent are ignored.\n\n    Return the decoded message as a string, with each integer replaced by its corresponding letter.\n\n\n    [EXAMPLES]\n    \n    assert candidate([1]) == 'A'\n    assert candidate([1, 1, 1, 1, 1]) == 'AAAAA'\n\n    [/EXAMPLES]\n    \"\"\"\n```\n", "entry_point": "decode_alien_message", "solution": "from collections import Counter\nfrom typing import List\n\ndef decode_alien_message(signal: List[int]) -> str:\n    \"\"\"You've intercepted a mysterious signal from an alien civilization! The signal is a list of integers, which you believe to be an encoded message. Your task is to decode this message using the following rules:\n\n    1. Each integer represents a character in the alien alphabet.\n    2. The alien alphabet has 26 characters, similar to English, but mapped differently.\n    3. The mapping is determined by the frequency of each integer in the signal.\n    4. The most frequent integer maps to 'A', the second most frequent to 'B', and so on.\n    5. If there's a tie in frequency, the lower integer value comes first in the alphabet.\n    6. Integers that don't appear in the top 26 most frequent are ignored.\n\n    Return the decoded message as a string, with each integer replaced by its corresponding letter.\n\n\n    [EXAMPLES]\n    \n    assert candidate([1]) == 'A'\n    assert candidate([1, 1, 1, 1, 1]) == 'AAAAA'\n\n    [/EXAMPLES]\n    \"\"\"\n    \n    def get_char_mapping(signal):\n        # Count the frequency of each integer in the signal\n        freq_counter = Counter(signal)\n        \n        # Sort the integers by frequency (descending) and then by value (ascending)\n        sorted_chars = sorted(freq_counter.items(), key=lambda x: (-x[1], x[0]))\n        \n        # Create the mapping of integers to letters\n        char_map = {}\n        for i, (num, _) in enumerate(sorted_chars[:26]):\n            char_map[num] = chr(65 + i)  # 65 is the ASCII value for 'A'\n        \n        return char_map\n\n    # Get the character mapping\n    char_map = get_char_mapping(signal)\n    \n    # Decode the message\n    decoded_message = ''.join(char_map.get(num, '') for num in signal)\n    \n    return decoded_message\n\n", "test": "def check(candidate):\n    assert candidate([1, 2, 3, 4, 5] * 20) == 'ABCDEABCDEABCDEABCDEABCDEABCDEABCDEABCDEABCDEABCDEABCDEABCDEABCDEABCDEABCDEABCDEABCDEABCDEABCDEABCDE'\n    assert candidate([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26]) == 'ABCDEFGHIJKLMNOPQRSTUVWXYZ'\n    assert candidate([1, 2, 3, 4, 1, 2, 1, 3, 1, 4, 2, 1]) == 'ABCDABACADBA'\n    assert candidate([1]) == 'A'\n    assert candidate([i % 26 + 1 for i in range(1000)]) == 'ABCDEFGHIJKLMNOPQRSTUVWXYZABCDEFGHIJKLMNOPQRSTUVWXYZABCDEFGHIJKLMNOPQRSTUVWXYZABCDEFGHIJKLMNOPQRSTUVWXYZABCDEFGHIJKLMNOPQRSTUVWXYZABCDEFGHIJKLMNOPQRSTUVWXYZABCDEFGHIJKLMNOPQRSTUVWXYZABCDEFGHIJKLMNOPQRSTUVWXYZABCDEFGHIJKLMNOPQRSTUVWXYZABCDEFGHIJKLMNOPQRSTUVWXYZABCDEFGHIJKLMNOPQRSTUVWXYZABCDEFGHIJKLMNOPQRSTUVWXYZABCDEFGHIJKLMNOPQRSTUVWXYZABCDEFGHIJKLMNOPQRSTUVWXYZABCDEFGHIJKLMNOPQRSTUVWXYZABCDEFGHIJKLMNOPQRSTUVWXYZABCDEFGHIJKLMNOPQRSTUVWXYZABCDEFGHIJKLMNOPQRSTUVWXYZABCDEFGHIJKLMNOPQRSTUVWXYZABCDEFGHIJKLMNOPQRSTUVWXYZABCDEFGHIJKLMNOPQRSTUVWXYZABCDEFGHIJKLMNOPQRSTUVWXYZABCDEFGHIJKLMNOPQRSTUVWXYZABCDEFGHIJKLMNOPQRSTUVWXYZABCDEFGHIJKLMNOPQRSTUVWXYZABCDEFGHIJKLMNOPQRSTUVWXYZABCDEFGHIJKLMNOPQRSTUVWXYZABCDEFGHIJKLMNOPQRSTUVWXYZABCDEFGHIJKLMNOPQRSTUVWXYZABCDEFGHIJKLMNOPQRSTUVWXYZABCDEFGHIJKLMNOPQRSTUVWXYZABCDEFGHIJKLMNOPQRSTUVWXYZABCDEFGHIJKLMNOPQRSTUVWXYZABCDEFGHIJKLMNOPQRSTUVWXYZABCDEFGHIJKLMNOPQRSTUVWXYZABCDEFGHIJKLMNOPQRSTUVWXYZABCDEFGHIJKLMNOPQRSTUVWXYZABCDEFGHIJKLMNOPQRSTUVWXYZABCDEFGHIJKL'\n    assert candidate([1] * 100 + [2] * 90 + [3] * 80 + [4] * 70 + [5] * 60 + [6] * 50 + [7] * 40 + [8] * 30 + [9] * 20 + [10] * 10) == 'AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHIIIIIIIIIIIIIIIIIIIIJJJJJJJJJJ'\n    assert candidate([1, 1, 1, 1, 1]) == 'AAAAA'\n    assert candidate([1, 2, 1, 3, 1, 4, 1, 5, 1, 6, 1, 7, 1, 8, 1, 9, 1, 10]) == 'ABACADAEAFAGAHAIAJ'\n    assert candidate([10, 20, 30, 40, 50, 10, 20, 30, 40, 50, 60, 70, 80, 90, 100]) == 'ABCDEABCDEFGHIJ'\n    assert candidate([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10]) == 'ABCDEFGHIJABCDEFGHIJ'\n", "language": "python"}
{"task_id": "9c777979-d756-4f53-b1ed-b28eb8a352ce-7540809879595444122", "prompt": "You are a coding assistant. I'm here to complete functions that can be executed as-is in code blocks. I'll only include code within the specified function, avoiding any code outside it. I'll utilize only the libraries that are imported in the problem. Any additional functions or classes I create will be defined inside the given function.\n\n```python\nfrom typing import List\n\ndef analyze_star_clusters(observations: List[float], threshold: float) -> List[int]:\n    \"\"\"\n    An astronomer is studying the distribution of stars in a distant galaxy. They have collected\n    a series of brightness measurements from different regions of the galaxy and want to identify\n    significant star clusters. Your task is to analyze these observations and determine the\n    positions of star clusters based on a brightness threshold.\n\n    The function takes two parameters:\n    - observations: A list of float values representing the brightness measurements.\n    - threshold: A float value representing the minimum brightness to consider as a star cluster.\n\n    The function should return a list of integer indices where star clusters are located.\n    A star cluster is defined as a region where the brightness exceeds the threshold.\n\n\n    [EXAMPLES]\n    \n    assert candidate([0.1, 0.01, 0.001, 0.0001, 0.00001], 0.001) == [0, 1, 2]\n    assert candidate([], 1.0) == []\n\n    [/EXAMPLES]\n    \"\"\"\n```\n", "entry_point": "analyze_star_clusters", "solution": "from typing import List\n\ndef analyze_star_clusters(observations: List[float], threshold: float) -> List[int]:\n    \"\"\"\n    An astronomer is studying the distribution of stars in a distant galaxy. They have collected\n    a series of brightness measurements from different regions of the galaxy and want to identify\n    significant star clusters. Your task is to analyze these observations and determine the\n    positions of star clusters based on a brightness threshold.\n\n    The function takes two parameters:\n    - observations: A list of float values representing the brightness measurements.\n    - threshold: A float value representing the minimum brightness to consider as a star cluster.\n\n    The function should return a list of integer indices where star clusters are located.\n    A star cluster is defined as a region where the brightness exceeds the threshold.\n\n\n    [EXAMPLES]\n    \n    assert candidate([0.1, 0.01, 0.001, 0.0001, 0.00001], 0.001) == [0, 1, 2]\n    assert candidate([], 1.0) == []\n\n    [/EXAMPLES]\n    \"\"\"\n    star_clusters = []\n    \n    for index, brightness in enumerate(observations):\n        if brightness >= threshold:\n            star_clusters.append(index)\n    \n    return star_clusters\n\n", "test": "def check(candidate):\n    assert candidate([0.1, 0.01, 0.001, 0.0001, 0.00001], 0.001) == [0, 1, 2]\n    assert candidate([1.0], 0.5) == [0]\n    assert candidate([3.3, 3.3, 3.3, 3.3, 3.3], 3.3) == [0, 1, 2, 3, 4]\n    assert candidate([4.0, 3.5, 3.0, 2.5, 2.0, 1.5, 1.0, 0.5], 2.5) == [0, 1, 2, 3]\n    assert candidate([3.14, 2.71, 1.41, 1.73, 2.23, 3.14], 2.5) == [0, 1, 5]\n    assert candidate([1.0, 2.0, 3.0, 4.0, 5.0], 3.0) == [2, 3, 4]\n    assert candidate([], 1.0) == []\n    assert candidate([5.0, 4.0, 3.0, 2.0, 1.0], 3.0) == [0, 1, 2]\n    assert candidate([-1.0, -2.0, -3.0, -4.0, -5.0], -3.0) == [0, 1, 2]\n    assert candidate([10000.0, 1000.0, 100.0, 10.0, 1.0], 100.0) == [0, 1, 2]\n", "language": "python"}
{"task_id": "ba80be6e-73d8-4f18-a76e-f2236ea9d329-6600261834579489875", "prompt": "Based on the provided docstring, implement the rest of the function. Include the complete function in a single code block and make sure to consider all edge cases.\n\n```python\nfrom typing import List, Tuple\n\ndef recipe_scaling(ingredients: List[Tuple[str, float]], servings: int, target: int) -> List[Tuple[str, float]]:\n    \"\"\"\n    A chef wants to scale a recipe for a different number of servings. This function takes the original recipe\n    ingredients, the number of servings it's designed for, and the target number of servings. It returns the\n    scaled ingredient quantities.\n\n    Each ingredient is represented as a tuple of (name, quantity). The quantity is in cups.\n    Round the scaled quantities to 2 decimal places.\n\n\n    [EXAMPLES]\n    \n    assert candidate([(\"yogurt\", 1.0), (\"granola\", 0.5), (\"honey\", 0.1)], 1, 5) == [('yogurt', 5.0), ('granola', 2.5), ('honey', 0.5)]\n    assert candidate([(\"lemon juice\", 0.25), (\"sugar\", 0.5), (\"water\", 2.0)], 4, 1) == [('lemon juice', 0.06), ('sugar', 0.12), ('water', 0.5)]\n\n    [/EXAMPLES]\n    \"\"\"\n```\n", "entry_point": "recipe_scaling", "solution": "from typing import List, Tuple\n\ndef recipe_scaling(ingredients: List[Tuple[str, float]], servings: int, target: int) -> List[Tuple[str, float]]:\n    \"\"\"\n    A chef wants to scale a recipe for a different number of servings. This function takes the original recipe\n    ingredients, the number of servings it's designed for, and the target number of servings. It returns the\n    scaled ingredient quantities.\n\n    Each ingredient is represented as a tuple of (name, quantity). The quantity is in cups.\n    Round the scaled quantities to 2 decimal places.\n\n\n    [EXAMPLES]\n    \n    assert candidate([(\"yogurt\", 1.0), (\"granola\", 0.5), (\"honey\", 0.1)], 1, 5) == [('yogurt', 5.0), ('granola', 2.5), ('honey', 0.5)]\n    assert candidate([(\"lemon juice\", 0.25), (\"sugar\", 0.5), (\"water\", 2.0)], 4, 1) == [('lemon juice', 0.06), ('sugar', 0.12), ('water', 0.5)]\n\n    [/EXAMPLES]\n    \"\"\"\n    # Calculate the scaling factor\n    scaling_factor = target / servings\n\n    # Scale each ingredient quantity and round to 2 decimal places\n    scaled_ingredients = []\n    for ingredient, quantity in ingredients:\n        scaled_quantity = round(quantity * scaling_factor, 2)\n        scaled_ingredients.append((ingredient, scaled_quantity))\n\n    return scaled_ingredients\n\n", "test": "def check(candidate):\n    assert candidate([(\"flour\", 3.0), (\"yeast\", 0.25), (\"salt\", 0.1), (\"sugar\", 0.05)], 1, 10) == [('flour', 30.0), ('yeast', 2.5), ('salt', 1.0), ('sugar', 0.5)]\n    assert candidate([(\"yogurt\", 1.0), (\"granola\", 0.5), (\"honey\", 0.1)], 1, 5) == [('yogurt', 5.0), ('granola', 2.5), ('honey', 0.5)]\n    assert candidate([(\"olive oil\", 0.25), (\"vinegar\", 0.25), (\"mustard\", 0.1)], 4, 12) == [('olive oil', 0.75), ('vinegar', 0.75), ('mustard', 0.3)]\n    assert candidate([(\"potato\", 2.0), (\"onion\", 0.5), (\"oil\", 0.25)], 2, 0) == [('potato', 0.0), ('onion', 0.0), ('oil', 0.0)]\n    assert candidate([(\"rice\", 1.5), (\"water\", 3.0)], 3, 1) == [('rice', 0.5), ('water', 1.0)]\n    assert candidate([(\"ground beef\", 1.0), (\"onion\", 0.5), (\"garlic\", 0.1)], 4, 16) == [('ground beef', 4.0), ('onion', 2.0), ('garlic', 0.4)]\n    assert candidate([(\"lemon juice\", 0.25), (\"sugar\", 0.5), (\"water\", 2.0)], 4, 1) == [('lemon juice', 0.06), ('sugar', 0.12), ('water', 0.5)]\n    assert candidate([(\"chicken broth\", 4.0), (\"carrots\", 0.5), (\"celery\", 0.5), (\"onion\", 0.25)], 6, 3) == [('chicken broth', 2.0), ('carrots', 0.25), ('celery', 0.25), ('onion', 0.12)]\n    assert candidate([(\"oats\", 1.0), (\"milk\", 1.0), (\"banana\", 0.5)], 1, 1) == [('oats', 1.0), ('milk', 1.0), ('banana', 0.5)]\n    assert candidate([(\"milk\", 1.0), (\"eggs\", 2.0)], 2, 4) == [('milk', 2.0), ('eggs', 4.0)]\n", "language": "python"}
{"task_id": "e7b1039b-255d-4375-9d07-5189031b56bd8881113039553009345", "prompt": "I've completed the requested function below. The implementation is self-contained and can be executed as-is. Any helper functions or additional classes are defined within the main function scope, and I've only used the libraries imported in the original problem.\n\n```python\ndef calculate_factorial(n: int) -> int:\n    \"\"\"\n    Calculates the factorial of a given non-negative integer.\n    The factorial of n (denoted as n!) is the product of all positive integers up to n.\n\n    Args:\n        n (int): The non-negative integer for which to calculate the factorial.\n\n    Returns:\n        int: The factorial of the input number.\n\n    Raises:\n        ValueError: If the input is negative.\n\n\n    [EXAMPLES]\n    \n    assert candidate(1) == 1\n    assert candidate(25) == 15511210043330985984000000\n\n    [/EXAMPLES]\n    \"\"\"\n```\n", "entry_point": "calculate_factorial", "solution": "def calculate_factorial(n: int) -> int:\n    \"\"\"\n    Calculates the factorial of a given non-negative integer.\n    The factorial of n (denoted as n!) is the product of all positive integers up to n.\n\n    Args:\n        n (int): The non-negative integer for which to calculate the factorial.\n\n    Returns:\n        int: The factorial of the input number.\n\n    Raises:\n        ValueError: If the input is negative.\n\n\n    [EXAMPLES]\n    \n    assert candidate(1) == 1\n    assert candidate(25) == 15511210043330985984000000\n\n    [/EXAMPLES]\n    \"\"\"\n    if n < 0:\n        raise ValueError(\"Factorial is not defined for negative numbers.\")\n    \n    if n == 0 or n == 1:\n        return 1\n    \n    result = 1\n    for i in range(2, n + 1):\n        result *= i\n    \n    return result\n\n", "test": "def check(candidate):\n    assert candidate(10) == 3628800\n    assert candidate(4) == 24\n    assert candidate(60) == 8320987112741390144276341183223364380754172606361245952449277696409600000000000000\n    assert candidate(8) == 40320\n    assert candidate(6) == 720\n    assert candidate(25) == 15511210043330985984000000\n    assert candidate(20) == 2432902008176640000\n    assert candidate(0) == 1\n    assert candidate(1) == 1\n    assert candidate(100) == 93326215443944152681699238856266700490715968264381621468592963895217599993229915608941463976156518286253697920827223758251185210916864000000000000000000000000\n", "language": "python"}
{"task_id": "d5cdfde8-1f2a-49b6-869c-de8578c3bb04-3548378327605596401", "prompt": "Based on the docstring, I'll provide the complete function implementation in a single code block. I'll ensure edge cases are properly handled.\n\n```python\ndef decode_morse(morse_code: str) -> str:\n    \"\"\"\n    As a communications specialist in a historical reenactment, you need to decode\n    Morse code messages. This function takes a string of Morse code and returns the\n    decoded message in uppercase English letters.\n\n    In the input, dots and dashes represent Morse code symbols, spaces separate\n    letters, and double spaces separate words. The function should handle all\n    26 letters of the alphabet and the digits 0-9.\n\n\n    [EXAMPLES]\n    \n    assert candidate(\".- -... -.-.  -.. . ..-.  --. .... ..  .--- -.- .-..  -- -. ---  .--. --.- .-.  ... - ..-  ...- .-- -..-  -.-- --..\") == 'ABC DEF GHI JKL MNO PQR STU VWX YZ'\n    assert candidate(\"...\") == 'S'\n\n    [/EXAMPLES]\n    \"\"\"\n```\n", "entry_point": "decode_morse", "solution": "def decode_morse(morse_code: str) -> str:\n    \"\"\"\n    As a communications specialist in a historical reenactment, you need to decode\n    Morse code messages. This function takes a string of Morse code and returns the\n    decoded message in uppercase English letters.\n\n    In the input, dots and dashes represent Morse code symbols, spaces separate\n    letters, and double spaces separate words. The function should handle all\n    26 letters of the alphabet and the digits 0-9.\n\n\n    [EXAMPLES]\n    \n    assert candidate(\".- -... -.-.  -.. . ..-.  --. .... ..  .--- -.- .-..  -- -. ---  .--. --.- .-.  ... - ..-  ...- .-- -..-  -.-- --..\") == 'ABC DEF GHI JKL MNO PQR STU VWX YZ'\n    assert candidate(\"...\") == 'S'\n\n    [/EXAMPLES]\n    \"\"\"\n    # Morse code dictionary\n    morse_dict = {\n        '.-': 'A', '-...': 'B', '-.-.': 'C', '-..': 'D', '.': 'E',\n        '..-.': 'F', '--.': 'G', '....': 'H', '..': 'I', '.---': 'J',\n        '-.-': 'K', '.-..': 'L', '--': 'M', '-.': 'N', '---': 'O',\n        '.--.': 'P', '--.-': 'Q', '.-.': 'R', '...': 'S', '-': 'T',\n        '..-': 'U', '...-': 'V', '.--': 'W', '-..-': 'X', '-.--': 'Y',\n        '--..': 'Z', '-----': '0', '.----': '1', '..---': '2', '...--': '3',\n        '....-': '4', '.....': '5', '-....': '6', '--...': '7', '---..': '8',\n        '----.': '9'\n    }\n    \n    # Split the morse code into words\n    words = morse_code.split('  ')\n    \n    decoded_message = []\n    for word in words:\n        # Split each word into letters\n        letters = word.split(' ')\n        decoded_word = ''.join(morse_dict.get(letter, '') for letter in letters)\n        decoded_message.append(decoded_word)\n    \n    # Join the decoded words with spaces\n    return ' '.join(decoded_message)\n\n", "test": "def check(candidate):\n    assert candidate(\".---- ..--- ...-- .....  -.... --...\") == '1235 67'\n    assert candidate(\".- -... -.-.  -.. . ..-.  --. .... ..  .--- -.- .-..  -- -. ---  .--. --.- .-.  ... - ..-  ...- .-- -..-  -.-- --..\") == 'ABC DEF GHI JKL MNO PQR STU VWX YZ'\n    assert candidate(\".- -... -.-.  -.. . ..-.\") == 'ABC DEF'\n    assert candidate(\"-... --- .- -\") == 'BOAT'\n    assert candidate(\"-.. --- -. -  ..-. --- .-. --. . -  - ---  -.. .-. .. -. -.-  -.-- --- ..- .-.  --- ...- .- .-.. - .. -. .\") == 'DONT FORGET TO DRINK YOUR OVALTINE'\n    assert candidate(\".-\") == 'A'\n    assert candidate(\"...\") == 'S'\n    assert candidate(\" \") == ''\n    assert candidate(\"\") == ''\n    assert candidate(\"----. -----\") == '90'\n", "language": "python"}
{"task_id": "c30f5569-89fe-4c3e-8aa4-a5b8c68c919e-3420052111901656264", "prompt": "Ready to complete your code. What's the starting code you'd like me to work with?\n\n```python\nfrom collections import deque\nfrom typing import List\n\ndef zombie_apocalypse(grid: List[List[int]]) -> int:\n    \"\"\"\n    In a post-apocalyptic world, a zombie virus is spreading through a city. The city is represented by a 2D grid\n    where 0 represents an uninfected person, 1 represents a zombie, and -1 represents an empty cell.\n\n    Every day, zombies infect all adjacent (up, down, left, right) uninfected people. This function calculates\n    the number of days it takes for the entire population to be infected or for the infection to stop spreading.\n\n    Return -1 if it's impossible for all humans to be infected.\n\n\n    [EXAMPLES]\n    \n    assert candidate([[1, 0, 0, 0], [0, 0, 0, 0], [0, 0, 0, 0], [0, 0, 0, 0]]) == 5\n    assert candidate([[0, 0], [0, 0]]) == -1\n\n    [/EXAMPLES]\n    \"\"\"\n```\n", "entry_point": "zombie_apocalypse", "solution": "from collections import deque\nfrom typing import List\n\ndef zombie_apocalypse(grid: List[List[int]]) -> int:\n    \"\"\"\n    In a post-apocalyptic world, a zombie virus is spreading through a city. The city is represented by a 2D grid\n    where 0 represents an uninfected person, 1 represents a zombie, and -1 represents an empty cell.\n\n    Every day, zombies infect all adjacent (up, down, left, right) uninfected people. This function calculates\n    the number of days it takes for the entire population to be infected or for the infection to stop spreading.\n\n    Return -1 if it's impossible for all humans to be infected.\n\n\n    [EXAMPLES]\n    \n    assert candidate([[1, 0, 0, 0], [0, 0, 0, 0], [0, 0, 0, 0], [0, 0, 0, 0]]) == 5\n    assert candidate([[0, 0], [0, 0]]) == -1\n\n    [/EXAMPLES]\n    \"\"\"\n    if not grid or not grid[0]:\n        return -1\n\n    rows, cols = len(grid), len(grid[0])\n    queue = deque()\n    humans = 0\n    \n    # Find initial zombies and count humans\n    for r in range(rows):\n        for c in range(cols):\n            if grid[r][c] == 1:\n                queue.append((r, c, 0))  # (row, col, days)\n            elif grid[r][c] == 0:\n                humans += 1\n\n    if not humans:\n        return 0  # No humans to infect\n\n    directions = [(1, 0), (-1, 0), (0, 1), (0, -1)]\n    max_days = 0\n\n    while queue and humans:\n        r, c, days = queue.popleft()\n        max_days = max(max_days, days)\n\n        for dr, dc in directions:\n            nr, nc = r + dr, c + dc\n            if 0 <= nr < rows and 0 <= nc < cols and grid[nr][nc] == 0:\n                grid[nr][nc] = 1\n                humans -= 1\n                queue.append((nr, nc, days + 1))\n\n    return max_days if humans == 0 else -1\n\n", "test": "def check(candidate):\n    assert candidate([[1, 0, 0, 0], [0, 0, 0, 0], [0, 0, 0, 0], [0, 0, 0, 0]]) == 5\n    assert candidate([[0, 0, 0], [0, 1, 0], [0, 0, 0], [0, 0, 0], [0, 0, 0]]) == 3\n    assert candidate([[1, 1, 1], [1, 1, 1], [1, 1, 1]]) == 0\n    assert candidate([[0, 0], [0, 0]]) == -1\n    assert candidate([[-1]]) == 0\n    assert candidate([[0, 1], [1, 0]]) == 0\n    assert candidate([[0, 0, 0, 0], [0, 0, 0, 0], [0, 0, 0, 1]]) == 4\n    assert candidate([[-1, -1, -1], [-1, 0, -1], [-1, -1, -1]]) == -1\n    assert candidate([[0, 0, 0], [-1, -1, -1], [0, 0, 0]]) == -1\n    assert candidate([[1]]) == 0\n", "language": "python"}
{"task_id": "18d79774-b401-455c-af69-e9667c7411ea1287318281037182831", "prompt": "Based on the function's documentation, I'll provide the complete implementation in one code block.\n\n```python\nfrom typing import List\nimport math\n\ndef calculate_ecosystem_stability(species_populations: List[int], interactions: List[List[int]]) -> float:\n    \"\"\"\n    Ecologists want to assess the stability of an ecosystem based on the populations\n    of different species and their interactions. A higher stability score indicates\n    a more balanced and resilient ecosystem.\n\n    The function takes two parameters:\n    - species_populations: A list of integers representing the population of each species\n    - interactions: A 2D list where interactions[i][j] represents the impact of\n                    species i on species j (positive for beneficial, negative for harmful)\n\n    The function should return a float representing the ecosystem stability score.\n\n\n    [EXAMPLES]\n    \n    assert candidate([1000, 1000, 1000, 1000], [[0, 1, 1, 1], [1, 0, 1, 1], [1, 1, 0, 1], [1, 1, 1, 0]]) == 0.71\n    assert candidate([1, 10, 100, 1000], [[0, -1, -1, -1], [1, 0, -1, -1], [1, 1, 0, -1], [1, 1, 1, 0]]) == 0.6\n\n    [/EXAMPLES]\n    \"\"\"\n```\n", "entry_point": "calculate_ecosystem_stability", "solution": "from typing import List\nimport math\n\ndef calculate_ecosystem_stability(species_populations: List[int], interactions: List[List[int]]) -> float:\n    \"\"\"\n    Ecologists want to assess the stability of an ecosystem based on the populations\n    of different species and their interactions. A higher stability score indicates\n    a more balanced and resilient ecosystem.\n\n    The function takes two parameters:\n    - species_populations: A list of integers representing the population of each species\n    - interactions: A 2D list where interactions[i][j] represents the impact of\n                    species i on species j (positive for beneficial, negative for harmful)\n\n    The function should return a float representing the ecosystem stability score.\n\n\n    [EXAMPLES]\n    \n    assert candidate([1000, 1000, 1000, 1000], [[0, 1, 1, 1], [1, 0, 1, 1], [1, 1, 0, 1], [1, 1, 1, 0]]) == 0.71\n    assert candidate([1, 10, 100, 1000], [[0, -1, -1, -1], [1, 0, -1, -1], [1, 1, 0, -1], [1, 1, 1, 0]]) == 0.6\n\n    [/EXAMPLES]\n    \"\"\"\n    def calculate_diversity_index(populations):\n        total = sum(populations)\n        proportions = [p / total for p in populations]\n        return -sum(p * math.log(p) for p in proportions if p > 0)\n\n    def calculate_interaction_balance(interactions):\n        n = len(interactions)\n        total_impact = sum(abs(sum(row)) for row in interactions)\n        max_possible_impact = n * n\n        return 1 - (total_impact / max_possible_impact)\n\n    def calculate_population_stability(populations):\n        mean = sum(populations) / len(populations)\n        variance = sum((p - mean) ** 2 for p in populations) / len(populations)\n        coefficient_of_variation = math.sqrt(variance) / mean\n        return 1 / (1 + coefficient_of_variation)\n\n    diversity_score = calculate_diversity_index(species_populations)\n    interaction_score = calculate_interaction_balance(interactions)\n    population_stability_score = calculate_population_stability(species_populations)\n\n    # Combine the scores with equal weights\n    stability_score = (diversity_score + interaction_score + population_stability_score) / 3\n\n    # Normalize the score to be between 0 and 1\n    normalized_score = 1 / (1 + math.exp(-stability_score))\n\n    return round(normalized_score, 2)\n\n", "test": "def check(candidate):\n    assert candidate([50, 50, 50, 50, 50], [[0, 0, 0, 0, 0], [0, 0, 0, 0, 0], [0, 0, 0, 0, 0], [0, 0, 0, 0, 0], [0, 0, 0, 0, 0]]) == 0.77\n    assert candidate([1, 10, 100, 1000], [[0, -1, -1, -1], [1, 0, -1, -1], [1, 1, 0, -1], [1, 1, 1, 0]]) == 0.6\n    assert candidate([1000, 1000, 1000, 1000], [[0, 1, 1, 1], [1, 0, 1, 1], [1, 1, 0, 1], [1, 1, 1, 0]]) == 0.71\n    assert candidate([100, 100], [[0, 1], [1, 0]]) == 0.68\n    assert candidate([1, 2, 3, 4, 5, 6, 7, 8, 9, 10], [[0, -1, 1, -1, 1, -1, 1, -1, 1, -1], [1, 0, -1, 1, -1, 1, -1, 1, -1, 1], [-1, 1, 0, -1, 1, -1, 1, -1, 1, -1], [1, -1, 1, 0, -1, 1, -1, 1, -1, 1], [-1, 1, -1, 1, 0, -1, 1, -1, 1, -1], [1, -1, 1, -1, 1, 0, -1, 1, -1, 1], [-1, 1, -1, 1, -1, 1, 0, -1, 1, -1], [1, -1, 1, -1, 1, -1, 1, 0, -1, 1], [-1, 1, -1, 1, -1, 1, -1, 1, 0, -1], [1, -1, 1, -1, 1, -1, 1, -1, 1, 0]]) == 0.77\n    assert candidate([1, 1, 1, 1, 1, 1, 1, 1, 1, 1], [[0]*10 for _ in range(10)]) == 0.81\n", "language": "python"}
{"task_id": "9ce919af-24b3-477c-a97c-82bcb68c595b5479894916283299983", "prompt": "I function as a coding assistant, specializing in completing executable functions within code blocks. I'll restrict myself to using only imported libraries and will include any necessary helper functions or classes within the function you need completed.\n\n```python\nimport heapq\nfrom typing import List\n\ndef space_mission_fuel(planets: int, fuel_requirements: List[List[int]]) -> int:\n    \"\"\"\n    In an interstellar exploration mission, we need to calculate the minimum fuel required\n    to visit all planets in a star system.\n\n    Given the number of planets and the fuel requirements between each pair of planets,\n    determine the minimum total fuel needed for the entire mission.\n\n    The fuel requirements are bidirectional, meaning the fuel needed to travel from\n    planet A to B is the same as from B to A.\n\n    :param planets: The number of planets in the star system\n    :param fuel_requirements: A 2D list where fuel_requirements[i][j] represents the fuel\n                              needed to travel between planets i and j\n    :return: The minimum total fuel required for the mission\n\n\n    [EXAMPLES]\n    \n    assert candidate(4, [[0, 10, 15, 20], [10, 0, 35, 25], [15, 35, 0, 30], [20, 25, 30, 0]]) == 45\n    assert candidate(5, [[0, 1, 1, 1, 1], [1, 0, 2, 2, 2], [1, 2, 0, 3, 3], [1, 2, 3, 0, 4], [1, 2, 3, 4, 0]]) == 4\n\n    [/EXAMPLES]\n    \"\"\"\n```\n", "entry_point": "space_mission_fuel", "solution": "import heapq\nfrom typing import List\n\ndef space_mission_fuel(planets: int, fuel_requirements: List[List[int]]) -> int:\n    \"\"\"\n    In an interstellar exploration mission, we need to calculate the minimum fuel required\n    to visit all planets in a star system.\n\n    Given the number of planets and the fuel requirements between each pair of planets,\n    determine the minimum total fuel needed for the entire mission.\n\n    The fuel requirements are bidirectional, meaning the fuel needed to travel from\n    planet A to B is the same as from B to A.\n\n    :param planets: The number of planets in the star system\n    :param fuel_requirements: A 2D list where fuel_requirements[i][j] represents the fuel\n                              needed to travel between planets i and j\n    :return: The minimum total fuel required for the mission\n\n\n    [EXAMPLES]\n    \n    assert candidate(4, [[0, 10, 15, 20], [10, 0, 35, 25], [15, 35, 0, 30], [20, 25, 30, 0]]) == 45\n    assert candidate(5, [[0, 1, 1, 1, 1], [1, 0, 2, 2, 2], [1, 2, 0, 3, 3], [1, 2, 3, 0, 4], [1, 2, 3, 4, 0]]) == 4\n\n    [/EXAMPLES]\n    \"\"\"\n    \n    def prim_mst(graph):\n        total_fuel = 0\n        visited = [False] * planets\n        min_heap = [(0, 0)]  # (fuel, planet)\n        \n        while min_heap:\n            fuel, planet = heapq.heappop(min_heap)\n            \n            if visited[planet]:\n                continue\n            \n            visited[planet] = True\n            total_fuel += fuel\n            \n            for next_planet in range(planets):\n                if not visited[next_planet]:\n                    heapq.heappush(min_heap, (graph[planet][next_planet], next_planet))\n        \n        return total_fuel\n\n    return prim_mst(fuel_requirements)\n\n", "test": "def check(candidate):\n    assert candidate(1, [[0]]) == 0\n    assert candidate(5, [[0, 1, 1, 1, 1], [1, 0, 2, 2, 2], [1, 2, 0, 3, 3], [1, 2, 3, 0, 4], [1, 2, 3, 4, 0]]) == 4\n    assert candidate(4, [[0, 1, 1, 1], [1, 0, 1, 1], [1, 1, 0, 1], [1, 1, 1, 0]]) == 3\n    assert candidate(5, [[0, 10, 20, 30, 40], [10, 0, 50, 60, 70], [20, 50, 0, 80, 90], [30, 60, 80, 0, 100], [40, 70, 90, 100, 0]]) == 100\n    assert candidate(4, [[0, 10, 15, 20], [10, 0, 35, 25], [15, 35, 0, 30], [20, 25, 30, 0]]) == 45\n    assert candidate(3, [[0, 1, 2], [1, 0, 3], [2, 3, 0]]) == 3\n    assert candidate(6, [[0, 10, 20, 30, 40, 50], [10, 0, 15, 25, 35, 45], [20, 15, 0, 5, 10, 15], [30, 25, 5, 0, 20, 25], [40, 35, 10, 20, 0, 30], [50, 45, 15, 25, 30, 0]]) == 55\n    assert candidate(3, [[0, 5, 10], [5, 0, 15], [10, 15, 0]]) == 15\n    assert candidate(4, [[0, 1000, 2000, 3000], [1000, 0, 4000, 5000], [2000, 4000, 0, 6000], [3000, 5000, 6000, 0]]) == 6000\n    assert candidate(3, [[0, 10, 20], [10, 0, 30], [20, 30, 0]]) == 30\n", "language": "python"}
{"task_id": "0911de5e-17c3-4eeb-baad-92aff5e23f36-943936120603809825", "prompt": "Based on the docstring provided, I'll implement the rest of the function. The code will be presented in one block with the original function name and argument structure preserved.\n\n```python\ndef encrypt_message(message: str, key: int) -> str:\n    \"\"\"\n    A secret agent needs to encrypt a message before sending it to headquarters.\n    The encryption method involves shifting each letter in the message by a certain\n    number of positions in the alphabet, wrapping around if necessary.\n\n    Given a message (consisting of lowercase letters and spaces) and a key (an integer),\n    encrypt the message by shifting each letter by the number of positions specified by the key.\n    Spaces should remain unchanged.\n\n    The function takes two parameters:\n    - message: The string to be encrypted\n    - key: An integer representing the number of positions to shift each letter\n\n    Returns the encrypted message as a string.\n\n\n    [EXAMPLES]\n    \n    assert candidate(\"hello world\", 0) == 'hello world'\n    assert candidate(\"hello world\", 100) == 'dahhk sknhz'\n\n    [/EXAMPLES]\n    \"\"\"\n```\n", "entry_point": "encrypt_message", "solution": "def encrypt_message(message: str, key: int) -> str:\n    \"\"\"\n    A secret agent needs to encrypt a message before sending it to headquarters.\n    The encryption method involves shifting each letter in the message by a certain\n    number of positions in the alphabet, wrapping around if necessary.\n\n    Given a message (consisting of lowercase letters and spaces) and a key (an integer),\n    encrypt the message by shifting each letter by the number of positions specified by the key.\n    Spaces should remain unchanged.\n\n    The function takes two parameters:\n    - message: The string to be encrypted\n    - key: An integer representing the number of positions to shift each letter\n\n    Returns the encrypted message as a string.\n\n\n    [EXAMPLES]\n    \n    assert candidate(\"hello world\", 0) == 'hello world'\n    assert candidate(\"hello world\", 100) == 'dahhk sknhz'\n\n    [/EXAMPLES]\n    \"\"\"\n    def shift_letter(char: str, shift: int) -> str:\n        if char.isalpha():\n            # Calculate the ASCII value of 'a'\n            base = ord('a')\n            # Shift the letter and wrap around if necessary\n            return chr((ord(char) - base + shift) % 26 + base)\n        return char\n\n    # Use a list comprehension to apply the shift to each character\n    encrypted_chars = [shift_letter(char, key) for char in message]\n    \n    # Join the encrypted characters back into a string\n    return ''.join(encrypted_chars)\n\n", "test": "def check(candidate):\n    assert candidate(\"abcdefghijklmnopqrstuvwxyz\", 26) == 'abcdefghijklmnopqrstuvwxyz'\n    assert candidate(\"meet me at midnight\", 3) == 'phhw ph dw plgqljkw'\n    assert candidate(\"hello world\", 0) == 'hello world'\n    assert candidate(\"z\", 1) == 'a'\n    assert candidate(\"mixed case SHOULD become lowercase\", 15) == 'bxmts rpht bqxdum qtrdbt adltgrpht'\n    assert candidate(\"this is a very long message that should still work properly with the given encryption method and it should handle long inputs without any issues\", 7) == 'aopz pz h clyf svun tlzzhnl aoha zovbsk zapss dvyr wyvwlysf dpao aol npclu lujyfwapvu tlaovk huk pa zovbsk ohuksl svun puwbaz dpaovba huf pzzblz'\n    assert candidate(\"extreme shift\", 1000000) == 'slhfsas gvwth'\n    assert candidate(\"hello world\", 1) == 'ifmmp xpsme'\n    assert candidate(\"hello world\", 100) == 'dahhk sknhz'\n    assert candidate(\"zzz\", 1) == 'aaa'\n", "language": "python"}
{"task_id": "f374e8ce-d50d-490d-bef5-1739271428cf3538928791439323938", "prompt": "I work as a coding assistant. My job is to implement functions that can run immediately in code blocks. I'll stick to the imported libraries and won't define code outside the requested function. Any helper functions or classes will be nested inside the main function.\n\n```python\nfrom typing import List, Tuple\n\ndef design_roller_coaster(heights: List[int], min_height: int, max_height: int) -> Tuple[int, List[int]]:\n    \"\"\"\n    An amusement park engineer is designing a new roller coaster. Given a list of customer heights and the minimum\n    and maximum height requirements for the ride, determine the maximum number of customers that can ride together\n    and their positions in the original list.\n\n    This function utilizes list comprehension and conditional logic to solve the problem.\n\n    Args:\n    heights (List[int]): A list of integers representing customer heights.\n    min_height (int): The minimum height requirement for the ride.\n    max_height (int): The maximum height requirement for the ride.\n\n    Returns:\n    Tuple[int, List[int]]: A tuple containing the maximum number of eligible riders and their positions in the original list.\n\n\n    [EXAMPLES]\n    \n    assert candidate([130, 135, 140, 145, 150], 135, 145) == (3, [1, 2, 3])\n    assert candidate([170, 175, 180, 185, 190], 175, 185) == (3, [1, 2, 3])\n\n    [/EXAMPLES]\n    \"\"\"\n```\n", "entry_point": "design_roller_coaster", "solution": "from typing import List, Tuple\n\ndef design_roller_coaster(heights: List[int], min_height: int, max_height: int) -> Tuple[int, List[int]]:\n    \"\"\"\n    An amusement park engineer is designing a new roller coaster. Given a list of customer heights and the minimum\n    and maximum height requirements for the ride, determine the maximum number of customers that can ride together\n    and their positions in the original list.\n\n    This function utilizes list comprehension and conditional logic to solve the problem.\n\n    Args:\n    heights (List[int]): A list of integers representing customer heights.\n    min_height (int): The minimum height requirement for the ride.\n    max_height (int): The maximum height requirement for the ride.\n\n    Returns:\n    Tuple[int, List[int]]: A tuple containing the maximum number of eligible riders and their positions in the original list.\n\n\n    [EXAMPLES]\n    \n    assert candidate([130, 135, 140, 145, 150], 135, 145) == (3, [1, 2, 3])\n    assert candidate([170, 175, 180, 185, 190], 175, 185) == (3, [1, 2, 3])\n\n    [/EXAMPLES]\n    \"\"\"\n    # Use list comprehension to get the positions of eligible riders\n    eligible_positions = [i for i, height in enumerate(heights) if min_height <= height <= max_height]\n    \n    # Calculate the number of eligible riders\n    num_eligible_riders = len(eligible_positions)\n    \n    # Return the tuple with the number of eligible riders and their positions\n    return (num_eligible_riders, eligible_positions)\n\n", "test": "def check(candidate):\n    assert candidate([170, 175, 180, 185, 190], 175, 185) == (3, [1, 2, 3])\n    assert candidate([100, 110, 120, 130, 140], 115, 135) == (2, [2, 3])\n    assert candidate([130, 135, 140, 145, 150], 135, 145) == (3, [1, 2, 3])\n    assert candidate([120, 130, 140, 150, 160], 125, 155) == (3, [1, 2, 3])\n    assert candidate([145, 155, 165, 175, 185], 160, 180) == (2, [2, 3])\n    assert candidate([150, 151, 152, 153, 154], 152, 153) == (2, [2, 3])\n    assert candidate([160, 160, 160, 160, 160], 160, 160) == (5, [0, 1, 2, 3, 4])\n    assert candidate([160, 175, 150, 180, 165], 155, 178) == (3, [0, 1, 4])\n    assert candidate([190, 180, 170, 160, 150], 155, 185) == (3, [1, 2, 3])\n    assert candidate([165, 155, 175, 185, 195], 170, 190) == (2, [2, 3])\n", "language": "python"}
{"task_id": "aede681a-4cb7-468e-a782-ea4dfc3a72151811521683312116587", "prompt": "Your job is to implement the provided function so it runs properly in a single code block. Ensure you only use libraries that are already imported in the problem description. Any auxiliary functions or classes should be defined within the main function's scope, not outside it.\n\n```python\nfrom typing import List, Tuple\nimport math\n\ndef optimize_solar_panel_placement(roof_dimensions: Tuple[float, float], panel_dimensions: Tuple[float, float], energy_requirements: float) -> int:\n    \"\"\"You are an engineer tasked with designing a solar panel system for a residential building.\n    Given the dimensions of the roof, the dimensions of each solar panel, and the daily energy requirements of the household,\n    determine the maximum number of solar panels that can be installed while meeting the energy needs.\n\n    The roof is rectangular, and panels must be placed with their edges parallel to the roof edges.\n    Each panel produces 250 watts of power for 5 hours a day on average.\n    \n    Return the maximum number of panels that can be installed to meet or exceed the energy requirements.\n\n\n    [EXAMPLES]\n    \n    assert candidate((5.0, 5.0), (1.0, 1.0), 1000.0) == 1\n    assert candidate((28.0, 22.0), (1.75, 1.25), 35000.0) == 28\n\n    [/EXAMPLES]\n    \"\"\"\n```\n", "entry_point": "optimize_solar_panel_placement", "solution": "from typing import List, Tuple\nimport math\n\ndef optimize_solar_panel_placement(roof_dimensions: Tuple[float, float], panel_dimensions: Tuple[float, float], energy_requirements: float) -> int:\n    \"\"\"You are an engineer tasked with designing a solar panel system for a residential building.\n    Given the dimensions of the roof, the dimensions of each solar panel, and the daily energy requirements of the household,\n    determine the maximum number of solar panels that can be installed while meeting the energy needs.\n\n    The roof is rectangular, and panels must be placed with their edges parallel to the roof edges.\n    Each panel produces 250 watts of power for 5 hours a day on average.\n    \n    Return the maximum number of panels that can be installed to meet or exceed the energy requirements.\n\n\n    [EXAMPLES]\n    \n    assert candidate((5.0, 5.0), (1.0, 1.0), 1000.0) == 1\n    assert candidate((28.0, 22.0), (1.75, 1.25), 35000.0) == 28\n\n    [/EXAMPLES]\n    \"\"\"\n    def calculate_max_panels(roof_length, roof_width, panel_length, panel_width):\n        panels_length = math.floor(roof_length / panel_length)\n        panels_width = math.floor(roof_width / panel_width)\n        return panels_length * panels_width\n\n    def calculate_energy_production(num_panels):\n        return num_panels * 250 * 5  # 250 watts * 5 hours\n\n    roof_length, roof_width = roof_dimensions\n    panel_length, panel_width = panel_dimensions\n\n    # Calculate max panels for both orientations\n    max_panels_orientation1 = calculate_max_panels(roof_length, roof_width, panel_length, panel_width)\n    max_panels_orientation2 = calculate_max_panels(roof_length, roof_width, panel_width, panel_length)\n\n    # Choose the orientation that allows for more panels\n    max_possible_panels = max(max_panels_orientation1, max_panels_orientation2)\n\n    # Calculate the minimum number of panels needed to meet energy requirements\n    min_panels_needed = math.ceil(energy_requirements / (250 * 5))\n\n    # Return the minimum between max possible panels and panels needed to meet energy requirements\n    return min(max_possible_panels, min_panels_needed)\n\n", "test": "def check(candidate):\n    assert candidate((28.0, 22.0), (1.75, 1.25), 35000.0) == 28\n    assert candidate((50.0, 40.0), (2.5, 2.0), 100000.0) == 80\n    assert candidate((10.0, 8.0), (1.5, 1.0), 5000.0) == 4\n    assert candidate((20.0, 15.0), (2.0, 1.2), 15000.0) == 12\n    assert candidate((30.0, 20.0), (1.8, 1.2), 25000.0) == 20\n    assert candidate((13.5, 9.5), (1.35, 0.95), 8000.0) == 7\n    assert candidate((5.0, 5.0), (1.0, 1.0), 1000.0) == 1\n    assert candidate((40.0, 30.0), (2.0, 1.5), 50000.0) == 40\n    assert candidate((22.0, 16.0), (2.0, 1.4), 18000.0) == 15\n    assert candidate((0.1, 0.1), (0.05, 0.05), 1.0) == 1\n", "language": "python"}
{"task_id": "31aa3604-4bbe-4eab-b716-5982962d93e74623787337018553537", "prompt": "I'm your coding assistant. When you provide a function to complete, I'll ensure my solution works as-is within a code block. I'll use only the libraries mentioned in the problem and keep any additional functions or classes contained inside the main function.\n\n```python\ndef compress_dna_sequence(sequence: str) -> str:\n    \"\"\"\n    You're working on a DNA compression algorithm for a genomics project. Given a DNA sequence\n    (a string containing only the characters 'A', 'T', 'C', and 'G'), compress it using the following rules:\n\n    1. If a nucleotide appears consecutively more than twice, replace it with the nucleotide followed by the count in parentheses.\n    2. If a nucleotide appears consecutively exactly twice, leave it as is.\n    3. Single occurrences of nucleotides should remain unchanged.\n\n    Your task is to implement this compression algorithm and return the compressed sequence.\n\n\n    [EXAMPLES]\n    \n    assert candidate(\"AAATTTCCCGGG\") == 'A(3)T(3)C(3)G(3)'\n    assert candidate(\"AAAAACCCCCAATGGG\") == 'A(5)C(5)AATG(3)'\n\n    [/EXAMPLES]\n    \"\"\"\n```\n", "entry_point": "compress_dna_sequence", "solution": "def compress_dna_sequence(sequence: str) -> str:\n    \"\"\"\n    You're working on a DNA compression algorithm for a genomics project. Given a DNA sequence\n    (a string containing only the characters 'A', 'T', 'C', and 'G'), compress it using the following rules:\n\n    1. If a nucleotide appears consecutively more than twice, replace it with the nucleotide followed by the count in parentheses.\n    2. If a nucleotide appears consecutively exactly twice, leave it as is.\n    3. Single occurrences of nucleotides should remain unchanged.\n\n    Your task is to implement this compression algorithm and return the compressed sequence.\n\n\n    [EXAMPLES]\n    \n    assert candidate(\"AAATTTCCCGGG\") == 'A(3)T(3)C(3)G(3)'\n    assert candidate(\"AAAAACCCCCAATGGG\") == 'A(5)C(5)AATG(3)'\n\n    [/EXAMPLES]\n    \"\"\"\n    if not sequence:\n        return \"\"\n\n    compressed = []\n    count = 1\n    current_nucleotide = sequence[0]\n\n    for nucleotide in sequence[1:]:\n        if nucleotide == current_nucleotide:\n            count += 1\n        else:\n            if count > 2:\n                compressed.append(f\"{current_nucleotide}({count})\")\n            elif count == 2:\n                compressed.append(current_nucleotide * 2)\n            else:\n                compressed.append(current_nucleotide)\n            current_nucleotide = nucleotide\n            count = 1\n\n    # Handle the last group of nucleotides\n    if count > 2:\n        compressed.append(f\"{current_nucleotide}({count})\")\n    elif count == 2:\n        compressed.append(current_nucleotide * 2)\n    else:\n        compressed.append(current_nucleotide)\n\n    return \"\".join(compressed)\n\n", "test": "def check(candidate):\n    assert candidate(\"ATATATATATAT\") == 'ATATATATATAT'\n    assert candidate(\"ACGTACGTACGT\") == 'ACGTACGTACGT'\n    assert candidate(\"AATTCCGG\") == 'AATTCCGG'\n    assert candidate(\"AAAATTTTCCCCGGGG\") == 'A(4)T(4)C(4)G(4)'\n    assert candidate(\"A\") == 'A'\n    assert candidate(\"AAA\") == 'A(3)'\n    assert candidate(\"CCCCCCCCCCCCCCCC\") == 'C(16)'\n    assert candidate(\"ATGCATGC\") == 'ATGCATGC'\n    assert candidate(\"AAAAACCCCCAATGGG\") == 'A(5)C(5)AATG(3)'\n    assert candidate(\"AAATTTCCCGGG\") == 'A(3)T(3)C(3)G(3)'\n", "language": "python"}
{"task_id": "d30685d5-4bed-4edc-aa65-7cdf22e929735952776545579712881", "prompt": "Following the specifications in the docstring, I'll write the complete function implementation. The function signature will remain unchanged, and all code will be in a single block.\n\n```python\nfrom typing import List, Tuple\nimport concurrent.futures\nimport math\n\ndef concurrent_prime_factorization(numbers: List[int]) -> List[Tuple[int, List[int]]]:\n    \"\"\"\n    In a cryptography challenge, participants need to find the prime factors of multiple\n    large numbers quickly. This function takes a list of integers and returns their\n    prime factorizations using concurrent processing.\n\n    The function leverages concurrency to perform factorizations in parallel, improving\n    performance for large sets of numbers.\n\n\n    [EXAMPLES]\n    \n    assert candidate([2**8 * 3**4 * 5**2, 2**6 * 3**5 * 7**2]) == [(518400, [2, 2, 2, 2, 2, 2, 2, 2, 3, 3, 3, 3, 5, 5]), (762048, [2, 2, 2, 2, 2, 2, 3, 3, 3, 3, 3, 7, 7])]\n    assert candidate([999983, 999979, 999961]) == [(999983, [999983]), (999979, [999979]), (999961, [999961])]\n\n    [/EXAMPLES]\n    \"\"\"\n```\n", "entry_point": "concurrent_prime_factorization", "solution": "from typing import List, Tuple\nimport concurrent.futures\nimport math\n\ndef concurrent_prime_factorization(numbers: List[int]) -> List[Tuple[int, List[int]]]:\n    \"\"\"\n    In a cryptography challenge, participants need to find the prime factors of multiple\n    large numbers quickly. This function takes a list of integers and returns their\n    prime factorizations using concurrent processing.\n\n    The function leverages concurrency to perform factorizations in parallel, improving\n    performance for large sets of numbers.\n\n\n    [EXAMPLES]\n    \n    assert candidate([2**8 * 3**4 * 5**2, 2**6 * 3**5 * 7**2]) == [(518400, [2, 2, 2, 2, 2, 2, 2, 2, 3, 3, 3, 3, 5, 5]), (762048, [2, 2, 2, 2, 2, 2, 3, 3, 3, 3, 3, 7, 7])]\n    assert candidate([999983, 999979, 999961]) == [(999983, [999983]), (999979, [999979]), (999961, [999961])]\n\n    [/EXAMPLES]\n    \"\"\"\n    def prime_factorize(n: int) -> List[int]:\n        factors = []\n        d = 2\n        while n > 1:\n            while n % d == 0:\n                factors.append(d)\n                n //= d\n            d += 1\n            if d * d > n:\n                if n > 1:\n                    factors.append(n)\n                break\n        return factors\n\n    def process_number(num: int) -> Tuple[int, List[int]]:\n        return num, prime_factorize(num)\n\n    with concurrent.futures.ThreadPoolExecutor() as executor:\n        results = list(executor.map(process_number, numbers))\n\n    return results\n\n", "test": "def check(candidate):\n    assert candidate([11111, 22222, 33333, 44444, 55555]) == [(11111, [41, 271]), (22222, [2, 41, 271]), (33333, [3, 41, 271]), (44444, [2, 2, 41, 271]), (55555, [5, 41, 271])]\n    assert candidate([9876543210]) == [(9876543210, [2, 3, 3, 5, 17, 17, 379721])]\n    assert candidate([999983, 999979, 999961]) == [(999983, [999983]), (999979, [999979]), (999961, [999961])]\n    assert candidate([10000000]) == [(10000000, [2, 2, 2, 2, 2, 2, 2, 5, 5, 5, 5, 5, 5, 5])]\n    assert candidate([12345, 23456, 34567, 45678, 56789]) == [(12345, [3, 5, 823]), (23456, [2, 2, 2, 2, 2, 733]), (34567, [13, 2659]), (45678, [2, 3, 23, 331]), (56789, [109, 521])]\n    assert candidate([97, 101, 103, 107, 109]) == [(97, [97]), (101, [101]), (103, [103]), (107, [107]), (109, [109])]\n    assert candidate([2, 4, 8, 16, 32, 64, 128, 256, 512, 1024]) == [(2, [2]), (4, [2, 2]), (8, [2, 2, 2]), (16, [2, 2, 2, 2]), (32, [2, 2, 2, 2, 2]), (64, [2, 2, 2, 2, 2, 2]), (128, [2, 2, 2, 2, 2, 2, 2]), (256, [2, 2, 2, 2, 2, 2, 2, 2]), (512, [2, 2, 2, 2, 2, 2, 2, 2, 2]), (1024, [2, 2, 2, 2, 2, 2, 2, 2, 2, 2])]\n    assert candidate([1000003, 1000033, 1000037]) == [(1000003, [1000003]), (1000033, [1000033]), (1000037, [1000037])]\n    assert candidate([2**8 * 3**4 * 5**2, 2**6 * 3**5 * 7**2]) == [(518400, [2, 2, 2, 2, 2, 2, 2, 2, 3, 3, 3, 3, 5, 5]), (762048, [2, 2, 2, 2, 2, 2, 3, 3, 3, 3, 3, 7, 7])]\n    assert candidate([999999999, 1000000000]) == [(999999999, [3, 3, 3, 3, 37, 333667]), (1000000000, [2, 2, 2, 2, 2, 2, 2, 2, 2, 5, 5, 5, 5, 5, 5, 5, 5, 5])]\n", "language": "python"}
{"task_id": "d0ac1925-341c-436b-b8cc-791721181f99203046302880735794", "prompt": "Following the documentation comment, code the remaining part of the function. Provide the entire function in one code block.\n\n```python\nfrom typing import List\n\ndef alien_language(words: List[str], order: str) -> bool:\n    \"\"\"\n    In an alien language, the order of letters is different from Earth languages. Given a list of words in the alien language\n    and the order of the alien alphabet, determine if the words are sorted lexicographically in this new language.\n\n    This function uses recursion to compare adjacent words and verify if they follow the given alphabetical order.\n\n    Args:\n    words (List[str]): A list of words in the alien language\n    order (str): A string representing the order of letters in the alien alphabet\n\n    Returns:\n    bool: True if the words are sorted lexicographically, False otherwise\n\n\n    [EXAMPLES]\n    \n    assert candidate([\"a\", \"b\", \"c\", \"d\", \"e\"], \"edcba\") == False\n    assert candidate([\"app\", \"apple\"], \"abcdefghijklmnopqrstuvwxyz\") == True\n\n    [/EXAMPLES]\n    \"\"\"\n```\n", "entry_point": "alien_language", "solution": "from typing import List\n\ndef alien_language(words: List[str], order: str) -> bool:\n    \"\"\"\n    In an alien language, the order of letters is different from Earth languages. Given a list of words in the alien language\n    and the order of the alien alphabet, determine if the words are sorted lexicographically in this new language.\n\n    This function uses recursion to compare adjacent words and verify if they follow the given alphabetical order.\n\n    Args:\n    words (List[str]): A list of words in the alien language\n    order (str): A string representing the order of letters in the alien alphabet\n\n    Returns:\n    bool: True if the words are sorted lexicographically, False otherwise\n\n\n    [EXAMPLES]\n    \n    assert candidate([\"a\", \"b\", \"c\", \"d\", \"e\"], \"edcba\") == False\n    assert candidate([\"app\", \"apple\"], \"abcdefghijklmnopqrstuvwxyz\") == True\n\n    [/EXAMPLES]\n    \"\"\"\n    def compare_words(word1: str, word2: str) -> bool:\n        for c1, c2 in zip(word1, word2):\n            if c1 != c2:\n                return order.index(c1) < order.index(c2)\n        return len(word1) <= len(word2)\n\n    def is_sorted(words: List[str]) -> bool:\n        if len(words) <= 1:\n            return True\n        if not compare_words(words[0], words[1]):\n            return False\n        return is_sorted(words[1:])\n\n    return is_sorted(words)\n\n", "test": "def check(candidate):\n    assert candidate([\"\"], \"abcdefghijklmnopqrstuvwxyz\") == True\n    assert candidate([\"word\", \"world\", \"row\"], \"worldabcefghijkmnpqstuvxyz\") == False\n    assert candidate([\"hello\", \"hello\"], \"abcdefghijklmnopqrstuvwxyz\") == True\n    assert candidate([\"app\", \"apple\"], \"abcdefghijklmnopqrstuvwxyz\") == True\n    assert candidate([\"kuvp\", \"q\"], \"ngxlkthsjuoqcpavbfdermiywz\") == True\n    assert candidate([\"a\", \"b\", \"c\"], \"abc\") == True\n    assert candidate([\"z\", \"x\", \"y\"], \"zxy\") == True\n    assert candidate([\"hello\", \"leetcode\"], \"hlabcdefgijkmnopqrstuvwxyz\") == True\n    assert candidate([\"a\", \"b\", \"c\", \"d\", \"e\"], \"edcba\") == False\n    assert candidate([\"aaa\", \"aa\", \"a\"], \"a\") == False\n", "language": "python"}
{"task_id": "516342b8-54b4-40d5-9180-304eed9064332135994154970300500", "prompt": "You're a coding assistant tasked with completing functions that are ready for execution. Your solutions should be contained entirely within the provided function, with no code outside this scope. Only use libraries that are explicitly imported in the problem statement. Any additional helper functions or classes you create must be defined inside the main function.\n\n```python\nfrom typing import List\n\ndef decode_alien_message(encoded_message: List[int]) -> str:\n    \"\"\"\n    Decode an alien message encoded as a list of integers.\n\n    This function takes a list of integers representing an encoded alien message\n    and returns the decoded message as a string. The encoding scheme used by the\n    aliens maps each lowercase letter (a-z) to its position in the alphabet (1-26),\n    with spaces represented by 0.\n\n\n    [EXAMPLES]\n    \n    assert candidate([5, 14, 3, 15, 4, 5, 4, 0, 13, 5, 19, 19, 1, 7, 5]) == 'encoded message'\n    assert candidate([26]) == 'z'\n\n    [/EXAMPLES]\n    \"\"\"\n```\n", "entry_point": "decode_alien_message", "solution": "from typing import List\n\ndef decode_alien_message(encoded_message: List[int]) -> str:\n    \"\"\"\n    Decode an alien message encoded as a list of integers.\n\n    This function takes a list of integers representing an encoded alien message\n    and returns the decoded message as a string. The encoding scheme used by the\n    aliens maps each lowercase letter (a-z) to its position in the alphabet (1-26),\n    with spaces represented by 0.\n\n\n    [EXAMPLES]\n    \n    assert candidate([5, 14, 3, 15, 4, 5, 4, 0, 13, 5, 19, 19, 1, 7, 5]) == 'encoded message'\n    assert candidate([26]) == 'z'\n\n    [/EXAMPLES]\n    \"\"\"\n    def decode_char(num: int) -> str:\n        if num == 0:\n            return ' '\n        elif 1 <= num <= 26:\n            return chr(num + 96)  # ASCII 'a' starts at 97\n        else:\n            raise ValueError(f\"Invalid encoded character: {num}\")\n\n    try:\n        decoded_message = ''.join(decode_char(num) for num in encoded_message)\n        return decoded_message\n    except ValueError as e:\n        return f\"Error: {str(e)}\"\n\n", "test": "def check(candidate):\n    assert candidate([0, 0, 0]) == '   '\n    assert candidate([1]) == 'a'\n    assert candidate([0]) == ' '\n    assert candidate([5, 14, 3, 15, 4, 5, 4, 0, 13, 5, 19, 19, 1, 7, 5]) == 'encoded message'\n    assert candidate([26, 0, 25, 0, 24, 0, 23]) == 'z y x w'\n    assert candidate([0, 1, 0, 2, 0, 3, 0, 4, 0, 5, 0]) == ' a b c d e '\n    assert candidate([1, 2, 3, 0, 4, 5, 6]) == 'abc def'\n    assert candidate([18, 5, 16, 5, 1, 20]) == 'repeat'\n    assert candidate([26, 25, 24, 23, 22]) == 'zyxwv'\n    assert candidate([26]) == 'z'\n", "language": "python"}
{"task_id": "d1032821-73de-47a4-8b49-4722261a67f3-2674401415607027748", "prompt": "As your coding assistant, I'll complete functions that are ready to execute in a code block. I'll stick to the libraries imported in the problem and won't add code outside the requested function. Any helper functions or classes will be defined within the main function.\n\n```python\nfrom collections import defaultdict\nfrom typing import List, Dict, Tuple\nfrom typing import List, Dict\n\ndef analyze_social_network(connections: List[Tuple[str, str]]) -> Dict[str, List[str]]:\n    \"\"\"\n    Analyze social network connections and create an adjacency list representation.\n\n    This function takes a list of tuples representing connections between individuals\n    in a social network. It processes these connections and returns a dictionary\n    representing the network as an adjacency list.\n\n    Args:\n        connections (List[Tuple[str, str]]): A list of tuples, each containing two names\n                                             representing a connection between individuals.\n\n    Returns:\n        Dict[str, List[str]]: A dictionary where keys are individuals and values are\n                              lists of their connections.\n\n\n    [EXAMPLES]\n    \n    assert candidate([(\"Alice\", \"Bob\"), (\"Bob\", \"Charlie\"), (\"Alice\", \"David\")]) == {'Alice': ['Bob', 'David'], 'Bob': ['Alice', 'Charlie'], 'Charlie': ['Bob'], 'David': ['Alice']}\n    assert candidate([(\"A\", \"B\"), (\"B\", \"C\"), (\"C\", \"A\"), (\"D\", \"E\"), (\"E\", \"F\"), (\"F\", \"D\")]) == {'A': ['B', 'C'], 'B': ['A', 'C'], 'C': ['B', 'A'], 'D': ['E', 'F'], 'E': ['D', 'F'], 'F': ['E', 'D']}\n\n    [/EXAMPLES]\n    \"\"\"\n```\n", "entry_point": "analyze_social_network", "solution": "from collections import defaultdict\nfrom typing import List, Dict, Tuple\nfrom typing import List, Dict\n\ndef analyze_social_network(connections: List[Tuple[str, str]]) -> Dict[str, List[str]]:\n    \"\"\"\n    Analyze social network connections and create an adjacency list representation.\n\n    This function takes a list of tuples representing connections between individuals\n    in a social network. It processes these connections and returns a dictionary\n    representing the network as an adjacency list.\n\n    Args:\n        connections (List[Tuple[str, str]]): A list of tuples, each containing two names\n                                             representing a connection between individuals.\n\n    Returns:\n        Dict[str, List[str]]: A dictionary where keys are individuals and values are\n                              lists of their connections.\n\n\n    [EXAMPLES]\n    \n    assert candidate([(\"Alice\", \"Bob\"), (\"Bob\", \"Charlie\"), (\"Alice\", \"David\")]) == {'Alice': ['Bob', 'David'], 'Bob': ['Alice', 'Charlie'], 'Charlie': ['Bob'], 'David': ['Alice']}\n    assert candidate([(\"A\", \"B\"), (\"B\", \"C\"), (\"C\", \"A\"), (\"D\", \"E\"), (\"E\", \"F\"), (\"F\", \"D\")]) == {'A': ['B', 'C'], 'B': ['A', 'C'], 'C': ['B', 'A'], 'D': ['E', 'F'], 'E': ['D', 'F'], 'F': ['E', 'D']}\n\n    [/EXAMPLES]\n    \"\"\"\n    # Use defaultdict to automatically initialize empty lists for new keys\n    network = defaultdict(list)\n\n    # Process each connection\n    for person1, person2 in connections:\n        # Add person2 to person1's connections if not already present\n        if person2 not in network[person1]:\n            network[person1].append(person2)\n        \n        # Add person1 to person2's connections if not already present\n        if person1 not in network[person2]:\n            network[person2].append(person1)\n\n    # Convert defaultdict to regular dict before returning\n    return dict(network)\n\n", "test": "def check(candidate):\n    assert candidate([(\"Long\" + \"Name\" * i, \"Person\" + str(i)) for i in range(10)]) == {'Long': ['Person0'], 'Person0': ['Long'], 'LongName': ['Person1'], 'Person1': ['LongName'], 'LongNameName': ['Person2'], 'Person2': ['LongNameName'], 'LongNameNameName': ['Person3'], 'Person3': ['LongNameNameName'], 'LongNameNameNameName': ['Person4'], 'Person4': ['LongNameNameNameName'], 'LongNameNameNameNameName': ['Person5'], 'Person5': ['LongNameNameNameNameName'], 'LongNameNameNameNameNameName': ['Person6'], 'Person6': ['LongNameNameNameNameNameName'], 'LongNameNameNameNameNameNameName': ['Person7'], 'Person7': ['LongNameNameNameNameNameNameName'], 'LongNameNameNameNameNameNameNameName': ['Person8'], 'Person8': ['LongNameNameNameNameNameNameNameName'], 'LongNameNameNameNameNameNameNameNameName': ['Person9'], 'Person9': ['LongNameNameNameNameNameNameNameNameName']}\n    assert candidate([(\"Alice\", \"Bob\"), (\"Bob\", \"Alice\")]) == {'Alice': ['Bob'], 'Bob': ['Alice']}\n    assert candidate([(\"A\" + str(i), \"B\" + str(i)) for i in range(500)]) == {'A0': ['B0'], 'B0': ['A0'], 'A1': ['B1'], 'B1': ['A1'], 'A2': ['B2'], 'B2': ['A2'], 'A3': ['B3'], 'B3': ['A3'], 'A4': ['B4'], 'B4': ['A4'], 'A5': ['B5'], 'B5': ['A5'], 'A6': ['B6'], 'B6': ['A6'], 'A7': ['B7'], 'B7': ['A7'], 'A8': ['B8'], 'B8': ['A8'], 'A9': ['B9'], 'B9': ['A9'], 'A10': ['B10'], 'B10': ['A10'], 'A11': ['B11'], 'B11': ['A11'], 'A12': ['B12'], 'B12': ['A12'], 'A13': ['B13'], 'B13': ['A13'], 'A14': ['B14'], 'B14': ['A14'], 'A15': ['B15'], 'B15': ['A15'], 'A16': ['B16'], 'B16': ['A16'], 'A17': ['B17'], 'B17': ['A17'], 'A18': ['B18'], 'B18': ['A18'], 'A19': ['B19'], 'B19': ['A19'], 'A20': ['B20'], 'B20': ['A20'], 'A21': ['B21'], 'B21': ['A21'], 'A22': ['B22'], 'B22': ['A22'], 'A23': ['B23'], 'B23': ['A23'], 'A24': ['B24'], 'B24': ['A24'], 'A25': ['B25'], 'B25': ['A25'], 'A26': ['B26'], 'B26': ['A26'], 'A27': ['B27'], 'B27': ['A27'], 'A28': ['B28'], 'B28': ['A28'], 'A29': ['B29'], 'B29': ['A29'], 'A30': ['B30'], 'B30': ['A30'], 'A31': ['B31'], 'B31': ['A31'], 'A32': ['B32'], 'B32': ['A32'], 'A33': ['B33'], 'B33': ['A33'], 'A34': ['B34'], 'B34': ['A34'], 'A35': ['B35'], 'B35': ['A35'], 'A36': ['B36'], 'B36': ['A36'], 'A37': ['B37'], 'B37': ['A37'], 'A38': ['B38'], 'B38': ['A38'], 'A39': ['B39'], 'B39': ['A39'], 'A40': ['B40'], 'B40': ['A40'], 'A41': ['B41'], 'B41': ['A41'], 'A42': ['B42'], 'B42': ['A42'], 'A43': ['B43'], 'B43': ['A43'], 'A44': ['B44'], 'B44': ['A44'], 'A45': ['B45'], 'B45': ['A45'], 'A46': ['B46'], 'B46': ['A46'], 'A47': ['B47'], 'B47': ['A47'], 'A48': ['B48'], 'B48': ['A48'], 'A49': ['B49'], 'B49': ['A49'], 'A50': ['B50'], 'B50': ['A50'], 'A51': ['B51'], 'B51': ['A51'], 'A52': ['B52'], 'B52': ['A52'], 'A53': ['B53'], 'B53': ['A53'], 'A54': ['B54'], 'B54': ['A54'], 'A55': ['B55'], 'B55': ['A55'], 'A56': ['B56'], 'B56': ['A56'], 'A57': ['B57'], 'B57': ['A57'], 'A58': ['B58'], 'B58': ['A58'], 'A59': ['B59'], 'B59': ['A59'], 'A60': ['B60'], 'B60': ['A60'], 'A61': ['B61'], 'B61': ['A61'], 'A62': ['B62'], 'B62': ['A62'], 'A63': ['B63'], 'B63': ['A63'], 'A64': ['B64'], 'B64': ['A64'], 'A65': ['B65'], 'B65': ['A65'], 'A66': ['B66'], 'B66': ['A66'], 'A67': ['B67'], 'B67': ['A67'], 'A68': ['B68'], 'B68': ['A68'], 'A69': ['B69'], 'B69': ['A69'], 'A70': ['B70'], 'B70': ['A70'], 'A71': ['B71'], 'B71': ['A71'], 'A72': ['B72'], 'B72': ['A72'], 'A73': ['B73'], 'B73': ['A73'], 'A74': ['B74'], 'B74': ['A74'], 'A75': ['B75'], 'B75': ['A75'], 'A76': ['B76'], 'B76': ['A76'], 'A77': ['B77'], 'B77': ['A77'], 'A78': ['B78'], 'B78': ['A78'], 'A79': ['B79'], 'B79': ['A79'], 'A80': ['B80'], 'B80': ['A80'], 'A81': ['B81'], 'B81': ['A81'], 'A82': ['B82'], 'B82': ['A82'], 'A83': ['B83'], 'B83': ['A83'], 'A84': ['B84'], 'B84': ['A84'], 'A85': ['B85'], 'B85': ['A85'], 'A86': ['B86'], 'B86': ['A86'], 'A87': ['B87'], 'B87': ['A87'], 'A88': ['B88'], 'B88': ['A88'], 'A89': ['B89'], 'B89': ['A89'], 'A90': ['B90'], 'B90': ['A90'], 'A91': ['B91'], 'B91': ['A91'], 'A92': ['B92'], 'B92': ['A92'], 'A93': ['B93'], 'B93': ['A93'], 'A94': ['B94'], 'B94': ['A94'], 'A95': ['B95'], 'B95': ['A95'], 'A96': ['B96'], 'B96': ['A96'], 'A97': ['B97'], 'B97': ['A97'], 'A98': ['B98'], 'B98': ['A98'], 'A99': ['B99'], 'B99': ['A99'], 'A100': ['B100'], 'B100': ['A100'], 'A101': ['B101'], 'B101': ['A101'], 'A102': ['B102'], 'B102': ['A102'], 'A103': ['B103'], 'B103': ['A103'], 'A104': ['B104'], 'B104': ['A104'], 'A105': ['B105'], 'B105': ['A105'], 'A106': ['B106'], 'B106': ['A106'], 'A107': ['B107'], 'B107': ['A107'], 'A108': ['B108'], 'B108': ['A108'], 'A109': ['B109'], 'B109': ['A109'], 'A110': ['B110'], 'B110': ['A110'], 'A111': ['B111'], 'B111': ['A111'], 'A112': ['B112'], 'B112': ['A112'], 'A113': ['B113'], 'B113': ['A113'], 'A114': ['B114'], 'B114': ['A114'], 'A115': ['B115'], 'B115': ['A115'], 'A116': ['B116'], 'B116': ['A116'], 'A117': ['B117'], 'B117': ['A117'], 'A118': ['B118'], 'B118': ['A118'], 'A119': ['B119'], 'B119': ['A119'], 'A120': ['B120'], 'B120': ['A120'], 'A121': ['B121'], 'B121': ['A121'], 'A122': ['B122'], 'B122': ['A122'], 'A123': ['B123'], 'B123': ['A123'], 'A124': ['B124'], 'B124': ['A124'], 'A125': ['B125'], 'B125': ['A125'], 'A126': ['B126'], 'B126': ['A126'], 'A127': ['B127'], 'B127': ['A127'], 'A128': ['B128'], 'B128': ['A128'], 'A129': ['B129'], 'B129': ['A129'], 'A130': ['B130'], 'B130': ['A130'], 'A131': ['B131'], 'B131': ['A131'], 'A132': ['B132'], 'B132': ['A132'], 'A133': ['B133'], 'B133': ['A133'], 'A134': ['B134'], 'B134': ['A134'], 'A135': ['B135'], 'B135': ['A135'], 'A136': ['B136'], 'B136': ['A136'], 'A137': ['B137'], 'B137': ['A137'], 'A138': ['B138'], 'B138': ['A138'], 'A139': ['B139'], 'B139': ['A139'], 'A140': ['B140'], 'B140': ['A140'], 'A141': ['B141'], 'B141': ['A141'], 'A142': ['B142'], 'B142': ['A142'], 'A143': ['B143'], 'B143': ['A143'], 'A144': ['B144'], 'B144': ['A144'], 'A145': ['B145'], 'B145': ['A145'], 'A146': ['B146'], 'B146': ['A146'], 'A147': ['B147'], 'B147': ['A147'], 'A148': ['B148'], 'B148': ['A148'], 'A149': ['B149'], 'B149': ['A149'], 'A150': ['B150'], 'B150': ['A150'], 'A151': ['B151'], 'B151': ['A151'], 'A152': ['B152'], 'B152': ['A152'], 'A153': ['B153'], 'B153': ['A153'], 'A154': ['B154'], 'B154': ['A154'], 'A155': ['B155'], 'B155': ['A155'], 'A156': ['B156'], 'B156': ['A156'], 'A157': ['B157'], 'B157': ['A157'], 'A158': ['B158'], 'B158': ['A158'], 'A159': ['B159'], 'B159': ['A159'], 'A160': ['B160'], 'B160': ['A160'], 'A161': ['B161'], 'B161': ['A161'], 'A162': ['B162'], 'B162': ['A162'], 'A163': ['B163'], 'B163': ['A163'], 'A164': ['B164'], 'B164': ['A164'], 'A165': ['B165'], 'B165': ['A165'], 'A166': ['B166'], 'B166': ['A166'], 'A167': ['B167'], 'B167': ['A167'], 'A168': ['B168'], 'B168': ['A168'], 'A169': ['B169'], 'B169': ['A169'], 'A170': ['B170'], 'B170': ['A170'], 'A171': ['B171'], 'B171': ['A171'], 'A172': ['B172'], 'B172': ['A172'], 'A173': ['B173'], 'B173': ['A173'], 'A174': ['B174'], 'B174': ['A174'], 'A175': ['B175'], 'B175': ['A175'], 'A176': ['B176'], 'B176': ['A176'], 'A177': ['B177'], 'B177': ['A177'], 'A178': ['B178'], 'B178': ['A178'], 'A179': ['B179'], 'B179': ['A179'], 'A180': ['B180'], 'B180': ['A180'], 'A181': ['B181'], 'B181': ['A181'], 'A182': ['B182'], 'B182': ['A182'], 'A183': ['B183'], 'B183': ['A183'], 'A184': ['B184'], 'B184': ['A184'], 'A185': ['B185'], 'B185': ['A185'], 'A186': ['B186'], 'B186': ['A186'], 'A187': ['B187'], 'B187': ['A187'], 'A188': ['B188'], 'B188': ['A188'], 'A189': ['B189'], 'B189': ['A189'], 'A190': ['B190'], 'B190': ['A190'], 'A191': ['B191'], 'B191': ['A191'], 'A192': ['B192'], 'B192': ['A192'], 'A193': ['B193'], 'B193': ['A193'], 'A194': ['B194'], 'B194': ['A194'], 'A195': ['B195'], 'B195': ['A195'], 'A196': ['B196'], 'B196': ['A196'], 'A197': ['B197'], 'B197': ['A197'], 'A198': ['B198'], 'B198': ['A198'], 'A199': ['B199'], 'B199': ['A199'], 'A200': ['B200'], 'B200': ['A200'], 'A201': ['B201'], 'B201': ['A201'], 'A202': ['B202'], 'B202': ['A202'], 'A203': ['B203'], 'B203': ['A203'], 'A204': ['B204'], 'B204': ['A204'], 'A205': ['B205'], 'B205': ['A205'], 'A206': ['B206'], 'B206': ['A206'], 'A207': ['B207'], 'B207': ['A207'], 'A208': ['B208'], 'B208': ['A208'], 'A209': ['B209'], 'B209': ['A209'], 'A210': ['B210'], 'B210': ['A210'], 'A211': ['B211'], 'B211': ['A211'], 'A212': ['B212'], 'B212': ['A212'], 'A213': ['B213'], 'B213': ['A213'], 'A214': ['B214'], 'B214': ['A214'], 'A215': ['B215'], 'B215': ['A215'], 'A216': ['B216'], 'B216': ['A216'], 'A217': ['B217'], 'B217': ['A217'], 'A218': ['B218'], 'B218': ['A218'], 'A219': ['B219'], 'B219': ['A219'], 'A220': ['B220'], 'B220': ['A220'], 'A221': ['B221'], 'B221': ['A221'], 'A222': ['B222'], 'B222': ['A222'], 'A223': ['B223'], 'B223': ['A223'], 'A224': ['B224'], 'B224': ['A224'], 'A225': ['B225'], 'B225': ['A225'], 'A226': ['B226'], 'B226': ['A226'], 'A227': ['B227'], 'B227': ['A227'], 'A228': ['B228'], 'B228': ['A228'], 'A229': ['B229'], 'B229': ['A229'], 'A230': ['B230'], 'B230': ['A230'], 'A231': ['B231'], 'B231': ['A231'], 'A232': ['B232'], 'B232': ['A232'], 'A233': ['B233'], 'B233': ['A233'], 'A234': ['B234'], 'B234': ['A234'], 'A235': ['B235'], 'B235': ['A235'], 'A236': ['B236'], 'B236': ['A236'], 'A237': ['B237'], 'B237': ['A237'], 'A238': ['B238'], 'B238': ['A238'], 'A239': ['B239'], 'B239': ['A239'], 'A240': ['B240'], 'B240': ['A240'], 'A241': ['B241'], 'B241': ['A241'], 'A242': ['B242'], 'B242': ['A242'], 'A243': ['B243'], 'B243': ['A243'], 'A244': ['B244'], 'B244': ['A244'], 'A245': ['B245'], 'B245': ['A245'], 'A246': ['B246'], 'B246': ['A246'], 'A247': ['B247'], 'B247': ['A247'], 'A248': ['B248'], 'B248': ['A248'], 'A249': ['B249'], 'B249': ['A249'], 'A250': ['B250'], 'B250': ['A250'], 'A251': ['B251'], 'B251': ['A251'], 'A252': ['B252'], 'B252': ['A252'], 'A253': ['B253'], 'B253': ['A253'], 'A254': ['B254'], 'B254': ['A254'], 'A255': ['B255'], 'B255': ['A255'], 'A256': ['B256'], 'B256': ['A256'], 'A257': ['B257'], 'B257': ['A257'], 'A258': ['B258'], 'B258': ['A258'], 'A259': ['B259'], 'B259': ['A259'], 'A260': ['B260'], 'B260': ['A260'], 'A261': ['B261'], 'B261': ['A261'], 'A262': ['B262'], 'B262': ['A262'], 'A263': ['B263'], 'B263': ['A263'], 'A264': ['B264'], 'B264': ['A264'], 'A265': ['B265'], 'B265': ['A265'], 'A266': ['B266'], 'B266': ['A266'], 'A267': ['B267'], 'B267': ['A267'], 'A268': ['B268'], 'B268': ['A268'], 'A269': ['B269'], 'B269': ['A269'], 'A270': ['B270'], 'B270': ['A270'], 'A271': ['B271'], 'B271': ['A271'], 'A272': ['B272'], 'B272': ['A272'], 'A273': ['B273'], 'B273': ['A273'], 'A274': ['B274'], 'B274': ['A274'], 'A275': ['B275'], 'B275': ['A275'], 'A276': ['B276'], 'B276': ['A276'], 'A277': ['B277'], 'B277': ['A277'], 'A278': ['B278'], 'B278': ['A278'], 'A279': ['B279'], 'B279': ['A279'], 'A280': ['B280'], 'B280': ['A280'], 'A281': ['B281'], 'B281': ['A281'], 'A282': ['B282'], 'B282': ['A282'], 'A283': ['B283'], 'B283': ['A283'], 'A284': ['B284'], 'B284': ['A284'], 'A285': ['B285'], 'B285': ['A285'], 'A286': ['B286'], 'B286': ['A286'], 'A287': ['B287'], 'B287': ['A287'], 'A288': ['B288'], 'B288': ['A288'], 'A289': ['B289'], 'B289': ['A289'], 'A290': ['B290'], 'B290': ['A290'], 'A291': ['B291'], 'B291': ['A291'], 'A292': ['B292'], 'B292': ['A292'], 'A293': ['B293'], 'B293': ['A293'], 'A294': ['B294'], 'B294': ['A294'], 'A295': ['B295'], 'B295': ['A295'], 'A296': ['B296'], 'B296': ['A296'], 'A297': ['B297'], 'B297': ['A297'], 'A298': ['B298'], 'B298': ['A298'], 'A299': ['B299'], 'B299': ['A299'], 'A300': ['B300'], 'B300': ['A300'], 'A301': ['B301'], 'B301': ['A301'], 'A302': ['B302'], 'B302': ['A302'], 'A303': ['B303'], 'B303': ['A303'], 'A304': ['B304'], 'B304': ['A304'], 'A305': ['B305'], 'B305': ['A305'], 'A306': ['B306'], 'B306': ['A306'], 'A307': ['B307'], 'B307': ['A307'], 'A308': ['B308'], 'B308': ['A308'], 'A309': ['B309'], 'B309': ['A309'], 'A310': ['B310'], 'B310': ['A310'], 'A311': ['B311'], 'B311': ['A311'], 'A312': ['B312'], 'B312': ['A312'], 'A313': ['B313'], 'B313': ['A313'], 'A314': ['B314'], 'B314': ['A314'], 'A315': ['B315'], 'B315': ['A315'], 'A316': ['B316'], 'B316': ['A316'], 'A317': ['B317'], 'B317': ['A317'], 'A318': ['B318'], 'B318': ['A318'], 'A319': ['B319'], 'B319': ['A319'], 'A320': ['B320'], 'B320': ['A320'], 'A321': ['B321'], 'B321': ['A321'], 'A322': ['B322'], 'B322': ['A322'], 'A323': ['B323'], 'B323': ['A323'], 'A324': ['B324'], 'B324': ['A324'], 'A325': ['B325'], 'B325': ['A325'], 'A326': ['B326'], 'B326': ['A326'], 'A327': ['B327'], 'B327': ['A327'], 'A328': ['B328'], 'B328': ['A328'], 'A329': ['B329'], 'B329': ['A329'], 'A330': ['B330'], 'B330': ['A330'], 'A331': ['B331'], 'B331': ['A331'], 'A332': ['B332'], 'B332': ['A332'], 'A333': ['B333'], 'B333': ['A333'], 'A334': ['B334'], 'B334': ['A334'], 'A335': ['B335'], 'B335': ['A335'], 'A336': ['B336'], 'B336': ['A336'], 'A337': ['B337'], 'B337': ['A337'], 'A338': ['B338'], 'B338': ['A338'], 'A339': ['B339'], 'B339': ['A339'], 'A340': ['B340'], 'B340': ['A340'], 'A341': ['B341'], 'B341': ['A341'], 'A342': ['B342'], 'B342': ['A342'], 'A343': ['B343'], 'B343': ['A343'], 'A344': ['B344'], 'B344': ['A344'], 'A345': ['B345'], 'B345': ['A345'], 'A346': ['B346'], 'B346': ['A346'], 'A347': ['B347'], 'B347': ['A347'], 'A348': ['B348'], 'B348': ['A348'], 'A349': ['B349'], 'B349': ['A349'], 'A350': ['B350'], 'B350': ['A350'], 'A351': ['B351'], 'B351': ['A351'], 'A352': ['B352'], 'B352': ['A352'], 'A353': ['B353'], 'B353': ['A353'], 'A354': ['B354'], 'B354': ['A354'], 'A355': ['B355'], 'B355': ['A355'], 'A356': ['B356'], 'B356': ['A356'], 'A357': ['B357'], 'B357': ['A357'], 'A358': ['B358'], 'B358': ['A358'], 'A359': ['B359'], 'B359': ['A359'], 'A360': ['B360'], 'B360': ['A360'], 'A361': ['B361'], 'B361': ['A361'], 'A362': ['B362'], 'B362': ['A362'], 'A363': ['B363'], 'B363': ['A363'], 'A364': ['B364'], 'B364': ['A364'], 'A365': ['B365'], 'B365': ['A365'], 'A366': ['B366'], 'B366': ['A366'], 'A367': ['B367'], 'B367': ['A367'], 'A368': ['B368'], 'B368': ['A368'], 'A369': ['B369'], 'B369': ['A369'], 'A370': ['B370'], 'B370': ['A370'], 'A371': ['B371'], 'B371': ['A371'], 'A372': ['B372'], 'B372': ['A372'], 'A373': ['B373'], 'B373': ['A373'], 'A374': ['B374'], 'B374': ['A374'], 'A375': ['B375'], 'B375': ['A375'], 'A376': ['B376'], 'B376': ['A376'], 'A377': ['B377'], 'B377': ['A377'], 'A378': ['B378'], 'B378': ['A378'], 'A379': ['B379'], 'B379': ['A379'], 'A380': ['B380'], 'B380': ['A380'], 'A381': ['B381'], 'B381': ['A381'], 'A382': ['B382'], 'B382': ['A382'], 'A383': ['B383'], 'B383': ['A383'], 'A384': ['B384'], 'B384': ['A384'], 'A385': ['B385'], 'B385': ['A385'], 'A386': ['B386'], 'B386': ['A386'], 'A387': ['B387'], 'B387': ['A387'], 'A388': ['B388'], 'B388': ['A388'], 'A389': ['B389'], 'B389': ['A389'], 'A390': ['B390'], 'B390': ['A390'], 'A391': ['B391'], 'B391': ['A391'], 'A392': ['B392'], 'B392': ['A392'], 'A393': ['B393'], 'B393': ['A393'], 'A394': ['B394'], 'B394': ['A394'], 'A395': ['B395'], 'B395': ['A395'], 'A396': ['B396'], 'B396': ['A396'], 'A397': ['B397'], 'B397': ['A397'], 'A398': ['B398'], 'B398': ['A398'], 'A399': ['B399'], 'B399': ['A399'], 'A400': ['B400'], 'B400': ['A400'], 'A401': ['B401'], 'B401': ['A401'], 'A402': ['B402'], 'B402': ['A402'], 'A403': ['B403'], 'B403': ['A403'], 'A404': ['B404'], 'B404': ['A404'], 'A405': ['B405'], 'B405': ['A405'], 'A406': ['B406'], 'B406': ['A406'], 'A407': ['B407'], 'B407': ['A407'], 'A408': ['B408'], 'B408': ['A408'], 'A409': ['B409'], 'B409': ['A409'], 'A410': ['B410'], 'B410': ['A410'], 'A411': ['B411'], 'B411': ['A411'], 'A412': ['B412'], 'B412': ['A412'], 'A413': ['B413'], 'B413': ['A413'], 'A414': ['B414'], 'B414': ['A414'], 'A415': ['B415'], 'B415': ['A415'], 'A416': ['B416'], 'B416': ['A416'], 'A417': ['B417'], 'B417': ['A417'], 'A418': ['B418'], 'B418': ['A418'], 'A419': ['B419'], 'B419': ['A419'], 'A420': ['B420'], 'B420': ['A420'], 'A421': ['B421'], 'B421': ['A421'], 'A422': ['B422'], 'B422': ['A422'], 'A423': ['B423'], 'B423': ['A423'], 'A424': ['B424'], 'B424': ['A424'], 'A425': ['B425'], 'B425': ['A425'], 'A426': ['B426'], 'B426': ['A426'], 'A427': ['B427'], 'B427': ['A427'], 'A428': ['B428'], 'B428': ['A428'], 'A429': ['B429'], 'B429': ['A429'], 'A430': ['B430'], 'B430': ['A430'], 'A431': ['B431'], 'B431': ['A431'], 'A432': ['B432'], 'B432': ['A432'], 'A433': ['B433'], 'B433': ['A433'], 'A434': ['B434'], 'B434': ['A434'], 'A435': ['B435'], 'B435': ['A435'], 'A436': ['B436'], 'B436': ['A436'], 'A437': ['B437'], 'B437': ['A437'], 'A438': ['B438'], 'B438': ['A438'], 'A439': ['B439'], 'B439': ['A439'], 'A440': ['B440'], 'B440': ['A440'], 'A441': ['B441'], 'B441': ['A441'], 'A442': ['B442'], 'B442': ['A442'], 'A443': ['B443'], 'B443': ['A443'], 'A444': ['B444'], 'B444': ['A444'], 'A445': ['B445'], 'B445': ['A445'], 'A446': ['B446'], 'B446': ['A446'], 'A447': ['B447'], 'B447': ['A447'], 'A448': ['B448'], 'B448': ['A448'], 'A449': ['B449'], 'B449': ['A449'], 'A450': ['B450'], 'B450': ['A450'], 'A451': ['B451'], 'B451': ['A451'], 'A452': ['B452'], 'B452': ['A452'], 'A453': ['B453'], 'B453': ['A453'], 'A454': ['B454'], 'B454': ['A454'], 'A455': ['B455'], 'B455': ['A455'], 'A456': ['B456'], 'B456': ['A456'], 'A457': ['B457'], 'B457': ['A457'], 'A458': ['B458'], 'B458': ['A458'], 'A459': ['B459'], 'B459': ['A459'], 'A460': ['B460'], 'B460': ['A460'], 'A461': ['B461'], 'B461': ['A461'], 'A462': ['B462'], 'B462': ['A462'], 'A463': ['B463'], 'B463': ['A463'], 'A464': ['B464'], 'B464': ['A464'], 'A465': ['B465'], 'B465': ['A465'], 'A466': ['B466'], 'B466': ['A466'], 'A467': ['B467'], 'B467': ['A467'], 'A468': ['B468'], 'B468': ['A468'], 'A469': ['B469'], 'B469': ['A469'], 'A470': ['B470'], 'B470': ['A470'], 'A471': ['B471'], 'B471': ['A471'], 'A472': ['B472'], 'B472': ['A472'], 'A473': ['B473'], 'B473': ['A473'], 'A474': ['B474'], 'B474': ['A474'], 'A475': ['B475'], 'B475': ['A475'], 'A476': ['B476'], 'B476': ['A476'], 'A477': ['B477'], 'B477': ['A477'], 'A478': ['B478'], 'B478': ['A478'], 'A479': ['B479'], 'B479': ['A479'], 'A480': ['B480'], 'B480': ['A480'], 'A481': ['B481'], 'B481': ['A481'], 'A482': ['B482'], 'B482': ['A482'], 'A483': ['B483'], 'B483': ['A483'], 'A484': ['B484'], 'B484': ['A484'], 'A485': ['B485'], 'B485': ['A485'], 'A486': ['B486'], 'B486': ['A486'], 'A487': ['B487'], 'B487': ['A487'], 'A488': ['B488'], 'B488': ['A488'], 'A489': ['B489'], 'B489': ['A489'], 'A490': ['B490'], 'B490': ['A490'], 'A491': ['B491'], 'B491': ['A491'], 'A492': ['B492'], 'B492': ['A492'], 'A493': ['B493'], 'B493': ['A493'], 'A494': ['B494'], 'B494': ['A494'], 'A495': ['B495'], 'B495': ['A495'], 'A496': ['B496'], 'B496': ['A496'], 'A497': ['B497'], 'B497': ['A497'], 'A498': ['B498'], 'B498': ['A498'], 'A499': ['B499'], 'B499': ['A499']}\n    assert candidate([]) == {}\n    assert candidate([(\"A\", \"B\"), (\"B\", \"C\"), (\"C\", \"A\"), (\"D\", \"E\"), (\"E\", \"F\"), (\"F\", \"D\")]) == {'A': ['B', 'C'], 'B': ['A', 'C'], 'C': ['B', 'A'], 'D': ['E', 'F'], 'E': ['D', 'F'], 'F': ['E', 'D']}\n    assert candidate([(\"X\", \"Y\"), (\"Y\", \"Z\"), (\"Z\", \"X\"), (\"X\", \"Z\")]) == {'X': ['Y', 'Z'], 'Y': ['X', 'Z'], 'Z': ['Y', 'X']}\n    assert candidate([(\"A\", \"B\"), (\"B\", \"C\"), (\"C\", \"D\"), (\"D\", \"E\"), (\"E\", \"A\")]) == {'A': ['B', 'E'], 'B': ['A', 'C'], 'C': ['B', 'D'], 'D': ['C', 'E'], 'E': ['D', 'A']}\n    assert candidate([(\"Alice\", \"Bob\"), (\"Bob\", \"Charlie\"), (\"Alice\", \"David\")]) == {'Alice': ['Bob', 'David'], 'Bob': ['Alice', 'Charlie'], 'Charlie': ['Bob'], 'David': ['Alice']}\n    assert candidate([(\"A\", \"B\")] * 10) == {'A': ['B'], 'B': ['A']}\n    assert candidate([(\"Eva\", \"Frank\"), (\"Frank\", \"George\"), (\"George\", \"Eva\")]) == {'Eva': ['Frank', 'George'], 'Frank': ['Eva', 'George'], 'George': ['Frank', 'Eva']}\n", "language": "python"}
{"task_id": "8d4055f7-8804-4a2d-8cb4-aa97b19f77f6-1240378904801812985", "prompt": "Complete the function provided so it can be run directly in a code block. Use only the libraries that are imported in the problem description. Any additional helper functions or classes should be defined within the main function.\n\n```python\nimport math\nfrom typing import List\n\ndef forest_regrowth(years: int, initial_trees: List[int], growth_rates: List[float]) -> List[int]:\n    \"\"\"\n    Simulates the regrowth of a forest over a specified number of years.\n\n    In a reforestation project, we want to predict the number of trees in different areas\n    of the forest after a certain number of years. Each area starts with an initial number\n    of trees and has its own growth rate.\n\n    Args:\n    years (int): The number of years to simulate forest growth.\n    initial_trees (List[int]): A list of initial tree counts for each area.\n    growth_rates (List[float]): A list of annual growth rates for each area (as decimals).\n\n    Returns:\n    List[int]: The predicted number of trees in each area after the specified years.\n\n\n    [EXAMPLES]\n    \n    assert candidate(8, [1000, 2000, 3000, 4000], [0.02, 0.04, 0.06, 0.08]) == [1171, 2737, 4781, 7403]\n    assert candidate(12, [300, 400, 500], [0.03, 0.06, 0.09]) == [427, 804, 1406]\n\n    [/EXAMPLES]\n    \"\"\"\n```\n", "entry_point": "forest_regrowth", "solution": "import math\nfrom typing import List\n\ndef forest_regrowth(years: int, initial_trees: List[int], growth_rates: List[float]) -> List[int]:\n    \"\"\"\n    Simulates the regrowth of a forest over a specified number of years.\n\n    In a reforestation project, we want to predict the number of trees in different areas\n    of the forest after a certain number of years. Each area starts with an initial number\n    of trees and has its own growth rate.\n\n    Args:\n    years (int): The number of years to simulate forest growth.\n    initial_trees (List[int]): A list of initial tree counts for each area.\n    growth_rates (List[float]): A list of annual growth rates for each area (as decimals).\n\n    Returns:\n    List[int]: The predicted number of trees in each area after the specified years.\n\n\n    [EXAMPLES]\n    \n    assert candidate(8, [1000, 2000, 3000, 4000], [0.02, 0.04, 0.06, 0.08]) == [1171, 2737, 4781, 7403]\n    assert candidate(12, [300, 400, 500], [0.03, 0.06, 0.09]) == [427, 804, 1406]\n\n    [/EXAMPLES]\n    \"\"\"\n    def calculate_growth(initial: int, rate: float, years: int) -> int:\n        return int(initial * (1 + rate) ** years)\n\n    if len(initial_trees) != len(growth_rates):\n        raise ValueError(\"The number of initial tree counts must match the number of growth rates.\")\n\n    result = []\n    for initial, rate in zip(initial_trees, growth_rates):\n        final_count = calculate_growth(initial, rate, years)\n        result.append(final_count)\n\n    return result\n\n", "test": "def check(candidate):\n    assert candidate(3, [5000, 7500], [0.005, 0.007]) == [5075, 7658]\n    assert candidate(2, [500, 600, 700, 800, 900], [0.1, 0.2, 0.3, 0.4, 0.5]) == [605, 864, 1183, 1567, 2025]\n    assert candidate(1, [50], [0.2]) == [60]\n    assert candidate(12, [300, 400, 500], [0.03, 0.06, 0.09]) == [427, 804, 1406]\n    assert candidate(0, [100, 200, 300], [0.05, 0.1, 0.15]) == [100, 200, 300]\n    assert candidate(15, [200, 300, 400], [0.08, 0.12, 0.16]) == [634, 1642, 3706]\n    assert candidate(8, [1000, 2000, 3000, 4000], [0.02, 0.04, 0.06, 0.08]) == [1171, 2737, 4781, 7403]\n    assert candidate(18, [250, 500, 750], [0.07, 0.14, 0.21]) == [844, 5287, 23184]\n    assert candidate(10, [10000, 20000], [0.001, 0.002]) == [10100, 20403]\n    assert candidate(1, [10000], [0.5]) == [15000]\n", "language": "python"}
{"task_id": "bb1ca402-6b9a-4866-8d48-3640cf0727b0-7712236364567045803", "prompt": "I'll complete the given function in a self-contained manner, ensuring it can be executed directly. Any helper functions or classes will be defined inside the main function. I will restrict myself to using only the libraries that are imported in the original problem description.\n\n```python\nfrom typing import List, Tuple\n\ndef analyze_stock_prices(prices: List[float]) -> Tuple[int, int, float]:\n    \"\"\"\n    A financial analyst wants to analyze a series of daily stock prices. Given a \n    list of prices, this function finds the best days to buy and sell the stock \n    to maximize profit, as well as the maximum profit that can be achieved.\n\n    The function returns a tuple containing the buy day index, sell day index, \n    and the maximum profit. If no profit can be made, it returns (0, 0, 0.0).\n\n\n    [EXAMPLES]\n    \n    assert candidate([5, 4, 3, 2, 1]) == (0, 0, 0.0)\n    assert candidate([10.0, 10.0, 10.0, 10.0, 10.0]) == (0, 0, 0.0)\n\n    [/EXAMPLES]\n    \"\"\"\n```\n", "entry_point": "analyze_stock_prices", "solution": "from typing import List, Tuple\n\ndef analyze_stock_prices(prices: List[float]) -> Tuple[int, int, float]:\n    \"\"\"\n    A financial analyst wants to analyze a series of daily stock prices. Given a \n    list of prices, this function finds the best days to buy and sell the stock \n    to maximize profit, as well as the maximum profit that can be achieved.\n\n    The function returns a tuple containing the buy day index, sell day index, \n    and the maximum profit. If no profit can be made, it returns (0, 0, 0.0).\n\n\n    [EXAMPLES]\n    \n    assert candidate([5, 4, 3, 2, 1]) == (0, 0, 0.0)\n    assert candidate([10.0, 10.0, 10.0, 10.0, 10.0]) == (0, 0, 0.0)\n\n    [/EXAMPLES]\n    \"\"\"\n    if len(prices) < 2:\n        return (0, 0, 0.0)\n\n    min_price = float('inf')\n    max_profit = 0.0\n    min_price_index = 0\n    buy_day = 0\n    sell_day = 0\n\n    for i, price in enumerate(prices):\n        if price < min_price:\n            min_price = price\n            min_price_index = i\n        elif price - min_price > max_profit:\n            max_profit = price - min_price\n            buy_day = min_price_index\n            sell_day = i\n\n    if max_profit == 0:\n        return (0, 0, 0.0)\n    else:\n        return (buy_day, sell_day, max_profit)\n\n", "test": "def check(candidate):\n    assert candidate([1.0, 2.0, 1.0, 2.0, 1.0]) == (0, 1, 1.0)\n    assert candidate([1]) == (0, 0, 0.0)\n    assert candidate([0.1, 0.2, 0.3, 0.4, 0.5]) == (0, 4, 0.4)\n    assert candidate([1, 1, 1, 1, 1]) == (0, 0, 0.0)\n    assert candidate([1000.0, 900.0, 800.0, 700.0, 600.0]) == (0, 0, 0.0)\n    assert candidate([]) == (0, 0, 0.0)\n    assert candidate([2, 1]) == (0, 0, 0.0)\n    assert candidate([10, 7, 5, 8, 11, 9]) == (2, 4, 6)\n    assert candidate([5, 4, 3, 2, 1]) == (0, 0, 0.0)\n    assert candidate([10.0, 10.0, 10.0, 10.0, 10.0]) == (0, 0, 0.0)\n", "language": "python"}
{"task_id": "347e8733-0f25-40b1-93c6-0c770cc917828244990688360724965", "prompt": "As your coding assistant, I complete functions that are ready to run in code blocks. I only use libraries imported in the problem statement and keep any helper functions or classes contained within the main function definition.\n\n```python\nfrom typing import List, Tuple\n\ndef optimize_study_schedule(subjects: List[str], difficulties: List[int], time_available: int) -> List[Tuple[str, int]]:\n    \"\"\"\n    Create an optimized study schedule based on subject difficulties and available time.\n    The function should use both recursion and memoization to solve the problem.\n\n\n    [EXAMPLES]\n    \n    assert candidate([\"History\", \"Literature\", \"Art\", \"Music\"], [2, 3, 1, 2], 4) == [('Art', 1), ('Music', 2)]\n    assert candidate([\"Philosophy\", \"Ethics\", \"Logic\"], [3, 2, 4], 6) == [('Ethics', 2), ('Logic', 4)]\n\n    [/EXAMPLES]\n    \"\"\"\n```\n", "entry_point": "optimize_study_schedule", "solution": "from typing import List, Tuple\n\ndef optimize_study_schedule(subjects: List[str], difficulties: List[int], time_available: int) -> List[Tuple[str, int]]:\n    \"\"\"\n    Create an optimized study schedule based on subject difficulties and available time.\n    The function should use both recursion and memoization to solve the problem.\n\n\n    [EXAMPLES]\n    \n    assert candidate([\"History\", \"Literature\", \"Art\", \"Music\"], [2, 3, 1, 2], 4) == [('Art', 1), ('Music', 2)]\n    assert candidate([\"Philosophy\", \"Ethics\", \"Logic\"], [3, 2, 4], 6) == [('Ethics', 2), ('Logic', 4)]\n\n    [/EXAMPLES]\n    \"\"\"\n    n = len(subjects)\n    memo = {}\n\n    def knapsack(index: int, remaining_time: int) -> Tuple[int, List[Tuple[str, int]]]:\n        if index == n or remaining_time == 0:\n            return 0, []\n\n        if (index, remaining_time) in memo:\n            return memo[(index, remaining_time)]\n\n        # Skip current subject\n        skip_value, skip_subjects = knapsack(index + 1, remaining_time)\n\n        # Include current subject if possible\n        if difficulties[index] <= remaining_time:\n            include_value, include_subjects = knapsack(index + 1, remaining_time - difficulties[index])\n            include_value += 1  # Count of subjects\n            include_subjects = [(subjects[index], difficulties[index])] + include_subjects\n\n            if include_value > skip_value:\n                result = (include_value, include_subjects)\n            else:\n                result = (skip_value, skip_subjects)\n        else:\n            result = (skip_value, skip_subjects)\n\n        memo[(index, remaining_time)] = result\n        return result\n\n    _, optimal_schedule = knapsack(0, time_available)\n    return optimal_schedule\n\n\n", "test": "def check(candidate):\n    assert candidate([\"Physics\", \"Chemistry\", \"Biology\", \"Math\"], [5, 4, 3, 5], 12) == [('Chemistry', 4), ('Biology', 3), ('Math', 5)]\n    assert candidate([\"Philosophy\", \"Ethics\", \"Logic\"], [3, 2, 4], 6) == [('Ethics', 2), ('Logic', 4)]\n    assert candidate([\"Algebra\", \"Geometry\", \"Trigonometry\", \"Calculus\"], [3, 2, 4, 5], 10) == [('Algebra', 3), ('Geometry', 2), ('Calculus', 5)]\n    assert candidate([\"English\", \"French\", \"Spanish\", \"German\", \"Italian\"], [2, 2, 2, 2, 2], 8) == [('French', 2), ('Spanish', 2), ('German', 2), ('Italian', 2)]\n    assert candidate([\"Art\", \"Music\", \"Dance\", \"Theater\"], [1, 1, 1, 1], 3) == [('Music', 1), ('Dance', 1), ('Theater', 1)]\n    assert candidate([\"Machine Learning\", \"Data Science\", \"AI\"], [5, 4, 5], 10) == [('Data Science', 4), ('AI', 5)]\n    assert candidate([\"Cooking\", \"Baking\", \"Grilling\"], [2, 3, 2], 4) == [('Cooking', 2), ('Grilling', 2)]\n    assert candidate([\"Astronomy\", \"Geology\"], [5, 4], 9) == [('Astronomy', 5), ('Geology', 4)]\n    assert candidate([\"Quantum Physics\", \"Relativity\"], [5, 5], 5) == [('Relativity', 5)]\n    assert candidate([\"History\", \"Literature\", \"Art\", \"Music\"], [2, 3, 1, 2], 4) == [('Art', 1), ('Music', 2)]\n", "language": "python"}
{"task_id": "2f9c558f-4439-42d0-b51a-1ba0a51535b27433323976154866597", "prompt": "I'll complete the function so it's ready to execute. The code block will contain only the implemented function with any helper functions or classes nested inside it. No external imports or code will be added - just the function implementation.\n\n```python\nimport re\nfrom typing import List\n\ndef dna_sequence_analysis(sequence: str, mutations: List[str]) -> List[int]:\n    \"\"\"\n    In a genomics research lab, scientists are studying DNA sequences and their mutations.\n    They need a tool to analyze a given DNA sequence and find the positions of specific\n    mutations within it. The DNA sequence is represented as a string of nucleotides\n    (A, C, G, T), and mutations are short sequences that may appear multiple times.\n\n    Args:\n    sequence (str): The DNA sequence to be analyzed.\n    mutations (List[str]): A list of mutation sequences to search for in the DNA sequence.\n\n    Returns:\n    List[int]: A list containing the count of occurrences for each mutation in the same order\n               as provided in the mutations list.\n\n\n    [EXAMPLES]\n    \n    assert candidate(\"AGCTAGCTAGCT\", [\"AGC\", \"GCT\", \"CTA\"]) == [3, 3, 2]\n    assert candidate(\"GATTACAGATTACA\", [\"GATTACA\", \"ATTACAG\", \"TTACAGA\"]) == [2, 1, 1]\n\n    [/EXAMPLES]\n    \"\"\"\n```\n", "entry_point": "dna_sequence_analysis", "solution": "import re\nfrom typing import List\n\ndef dna_sequence_analysis(sequence: str, mutations: List[str]) -> List[int]:\n    \"\"\"\n    In a genomics research lab, scientists are studying DNA sequences and their mutations.\n    They need a tool to analyze a given DNA sequence and find the positions of specific\n    mutations within it. The DNA sequence is represented as a string of nucleotides\n    (A, C, G, T), and mutations are short sequences that may appear multiple times.\n\n    Args:\n    sequence (str): The DNA sequence to be analyzed.\n    mutations (List[str]): A list of mutation sequences to search for in the DNA sequence.\n\n    Returns:\n    List[int]: A list containing the count of occurrences for each mutation in the same order\n               as provided in the mutations list.\n\n\n    [EXAMPLES]\n    \n    assert candidate(\"AGCTAGCTAGCT\", [\"AGC\", \"GCT\", \"CTA\"]) == [3, 3, 2]\n    assert candidate(\"GATTACAGATTACA\", [\"GATTACA\", \"ATTACAG\", \"TTACAGA\"]) == [2, 1, 1]\n\n    [/EXAMPLES]\n    \"\"\"\n    def count_overlapping(pattern, string):\n        \"\"\"\n        Helper function to count overlapping occurrences of a pattern in a string.\n        \"\"\"\n        return len(re.findall(f'(?={pattern})', string))\n    \n    result = []\n    for mutation in mutations:\n        count = count_overlapping(mutation, sequence)\n        result.append(count)\n    \n    return result\n\n", "test": "def check(candidate):\n    assert candidate(\"AAAAAAAAAAAA\", [\"A\", \"AA\", \"AAA\", \"AAAA\"]) == [12, 11, 10, 9]\n    assert candidate(\"ACGT\", [\"ACGT\", \"CGTA\", \"GTAC\", \"TACG\"]) == [1, 0, 0, 0]\n    assert candidate(\"AGCTAGCTAGCT\", [\"AGC\", \"GCT\", \"CTA\"]) == [3, 3, 2]\n    assert candidate(\"ACGTACGTACGT\", [\"ACG\", \"CGT\", \"TTT\"]) == [3, 3, 0]\n    assert candidate(\"AGTCAGTCAGTC\", [\"AGT\", \"GTC\", \"CAG\"]) == [3, 3, 2]\n    assert candidate(\"GATTACAGATTACA\", [\"GATTACA\", \"ATTACAG\", \"TTACAGA\"]) == [2, 1, 1]\n    assert candidate(\"AAAAGGGGCCCCTTTT\", [\"AA\", \"GG\", \"CC\", \"TT\"]) == [3, 3, 3, 3]\n    assert candidate(\"\", [\"A\", \"C\", \"G\", \"T\"]) == [0, 0, 0, 0]\n    assert candidate(\"TTTTTTTTTTTT\", [\"T\", \"TT\", \"TTT\", \"TTTT\", \"TTTTT\"]) == [12, 11, 10, 9, 8]\n    assert candidate(\"ACACACACACAC\", [\"AC\", \"CA\", \"ACA\", \"CAC\"]) == [6, 5, 5, 5]\n", "language": "python"}
{"task_id": "14ef2182-f821-4ae7-8c30-3338dfa6dba76364782858099069742", "prompt": "Complete the specified function so it runs as-is in one code block. Avoid adding any code outside the function. Utilize only libraries that are included in the problem's import statements. Any supporting functions or classes must be defined within the main function itself.\n\n```python\nfrom typing import List\n\ndef decompress_run_length(compressed: List[int]) -> List[int]:\n    \"\"\"\n    Decompress a run-length encoded list of integers.\n\n    This function takes a run-length encoded list where even-indexed elements represent\n    frequencies and odd-indexed elements represent values. It returns the decompressed\n    version of the list.\n\n    Args:\n    compressed (List[int]): A run-length encoded list of integers.\n\n    Returns:\n    List[int]: The decompressed list of integers.\n\n\n    [EXAMPLES]\n    \n    assert candidate([]) == []\n    assert candidate([1, 1, 3, 2]) == [1, 2, 2, 2]\n\n    [/EXAMPLES]\n    \"\"\"\n```\n", "entry_point": "decompress_run_length", "solution": "from typing import List\n\ndef decompress_run_length(compressed: List[int]) -> List[int]:\n    \"\"\"\n    Decompress a run-length encoded list of integers.\n\n    This function takes a run-length encoded list where even-indexed elements represent\n    frequencies and odd-indexed elements represent values. It returns the decompressed\n    version of the list.\n\n    Args:\n    compressed (List[int]): A run-length encoded list of integers.\n\n    Returns:\n    List[int]: The decompressed list of integers.\n\n\n    [EXAMPLES]\n    \n    assert candidate([]) == []\n    assert candidate([1, 1, 3, 2]) == [1, 2, 2, 2]\n\n    [/EXAMPLES]\n    \"\"\"\n    decompressed = []\n    \n    for i in range(0, len(compressed), 2):\n        frequency = compressed[i]\n        value = compressed[i + 1]\n        decompressed.extend([value] * frequency)\n    \n    return decompressed\n\n", "test": "def check(candidate):\n    assert candidate([100, 1]) == [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]\n    assert candidate([10000, 1, 1, 2]) == [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 2]\n    assert candidate([1, 1]) == [1]\n    assert candidate([3, 100, 3, 200, 3, 300]) == [100, 100, 100, 200, 200, 200, 300, 300, 300]\n    assert candidate([1, 1, 3, 2]) == [1, 2, 2, 2]\n    assert candidate([5, 1, 4, 2, 3, 3, 2, 4, 1, 5]) == [1, 1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 4, 4, 5]\n    assert candidate([1, -1, 1, 0, 1, 1]) == [-1, 0, 1]\n    assert candidate([]) == []\n", "language": "python"}
{"task_id": "d2a2ae66-ae37-4d38-a457-b4c4b271a1b4-4304846287340277405", "prompt": "I'll implement the function according to the docstring while keeping the function name and parameters unchanged. The complete code will be in a single block.\n\n```python\nimport math\n\ndef optimal_beehive_cells(honey_volume: float) -> int:\n    \"\"\"\n    A beekeeper is designing an innovative beehive and needs to determine the optimal \n    number of hexagonal cells to construct based on the expected honey production. \n    Each cell is a regular hexagonal prism with a side length of 3 mm and a depth of 11 mm.\n\n    Given the expected volume of honey in cubic millimeters, calculate the minimum \n    number of cells needed to store all the honey, rounding up to the nearest whole number.\n\n\n    [EXAMPLES]\n    \n    assert candidate(5000) == 20\n    assert candidate(1) == 1\n\n    [/EXAMPLES]\n    \"\"\"\n```\n", "entry_point": "optimal_beehive_cells", "solution": "import math\n\ndef optimal_beehive_cells(honey_volume: float) -> int:\n    \"\"\"\n    A beekeeper is designing an innovative beehive and needs to determine the optimal \n    number of hexagonal cells to construct based on the expected honey production. \n    Each cell is a regular hexagonal prism with a side length of 3 mm and a depth of 11 mm.\n\n    Given the expected volume of honey in cubic millimeters, calculate the minimum \n    number of cells needed to store all the honey, rounding up to the nearest whole number.\n\n\n    [EXAMPLES]\n    \n    assert candidate(5000) == 20\n    assert candidate(1) == 1\n\n    [/EXAMPLES]\n    \"\"\"\n    # Calculate the volume of a single hexagonal cell\n    side_length = 3  # mm\n    depth = 11  # mm\n    \n    # Area of a regular hexagon: (3 * sqrt(3) * s^2) / 2\n    hexagon_area = (3 * math.sqrt(3) * side_length**2) / 2\n    \n    # Volume of a single cell\n    cell_volume = hexagon_area * depth\n    \n    # Calculate the number of cells needed\n    cells_needed = honey_volume / cell_volume\n    \n    # Round up to the nearest whole number\n    return math.ceil(cells_needed)\n\n", "test": "def check(candidate):\n    assert candidate(1500.5) == 6\n    assert candidate(1) == 1\n    assert candidate(3.14159) == 1\n    assert candidate(1e8) == 388789\n    assert candidate(5000) == 20\n    assert candidate(10000) == 39\n    assert candidate(50000) == 195\n    assert candidate(2.71828) == 1\n    assert candidate(1000) == 4\n    assert candidate(1500) == 6\n", "language": "python"}
{"task_id": "16706cb7-e992-4d78-9f56-a0b00c7831bf2625775624889414549", "prompt": "You're a coding assistant. Please complete the provided function so it can be executed as-is within a code block. Only use libraries that are already imported in the problem. Any additional functions or classes should be defined within the given function. Don't include code outside the function scope.\n\n```python\nfrom typing import List\n\ndef optimize_antenna_placement(buildings: List[List[int]], range_limit: int) -> int:\n    \"\"\"\n    A telecommunications company needs to optimize the placement of 5G antennas in a city.\n    The city is represented as a 2D grid where each cell contains the height of a building.\n    An antenna placed on a building can cover all buildings within a certain range that are\n    not taller than the building it's placed on.\n    This function determines the minimum number of antennas needed to cover all buildings.\n\n    Args:\n    buildings (List[List[int]]): A 2D list representing building heights in the city\n    range_limit (int): The maximum range of each antenna\n\n    Returns:\n    int: Minimum number of antennas needed to cover all buildings\n\n\n    [EXAMPLES]\n    \n    assert candidate([[5, 5, 5], [5, 1, 5], [5, 5, 5]], 2) == 1\n    assert candidate([[10, 20, 30], [40, 50, 60], [70, 80, 90]], 1) == 4\n\n    [/EXAMPLES]\n    \"\"\"\n```\n", "entry_point": "optimize_antenna_placement", "solution": "from typing import List\n\ndef optimize_antenna_placement(buildings: List[List[int]], range_limit: int) -> int:\n    \"\"\"\n    A telecommunications company needs to optimize the placement of 5G antennas in a city.\n    The city is represented as a 2D grid where each cell contains the height of a building.\n    An antenna placed on a building can cover all buildings within a certain range that are\n    not taller than the building it's placed on.\n    This function determines the minimum number of antennas needed to cover all buildings.\n\n    Args:\n    buildings (List[List[int]]): A 2D list representing building heights in the city\n    range_limit (int): The maximum range of each antenna\n\n    Returns:\n    int: Minimum number of antennas needed to cover all buildings\n\n\n    [EXAMPLES]\n    \n    assert candidate([[5, 5, 5], [5, 1, 5], [5, 5, 5]], 2) == 1\n    assert candidate([[10, 20, 30], [40, 50, 60], [70, 80, 90]], 1) == 4\n\n    [/EXAMPLES]\n    \"\"\"\n    def can_cover(x, y, height):\n        for i in range(max(0, x - range_limit), min(len(buildings), x + range_limit + 1)):\n            for j in range(max(0, y - range_limit), min(len(buildings[0]), y + range_limit + 1)):\n                if buildings[i][j] <= height:\n                    covered[i][j] = True\n\n    rows, cols = len(buildings), len(buildings[0])\n    covered = [[False for _ in range(cols)] for _ in range(rows)]\n    antennas = 0\n\n    # Sort buildings by height in descending order\n    building_heights = [(i, j, buildings[i][j]) for i in range(rows) for j in range(cols)]\n    building_heights.sort(key=lambda x: x[2], reverse=True)\n\n    for x, y, height in building_heights:\n        if not covered[x][y]:\n            antennas += 1\n            can_cover(x, y, height)\n\n    return antennas\n\n", "test": "def check(candidate):\n    assert candidate([[1, 1], [1, 1]], 1) == 1\n    assert candidate([[0, 0], [0, 0]], 5) == 1\n    assert candidate([[100, 100], [100, 100]], 100) == 1\n    assert candidate([[1, 1, 1, 1], [1, 2, 2, 1], [1, 2, 2, 1], [1, 1, 1, 1]], 2) == 1\n    assert candidate([[1]], 1000000) == 1\n    assert candidate([[5, 5, 5], [5, 1, 5], [5, 5, 5]], 2) == 1\n    assert candidate([[10, 20, 30], [40, 50, 60], [70, 80, 90]], 1) == 4\n    assert candidate([[10]], 100) == 1\n    assert candidate([[1, 2], [3, 4]], 1) == 1\n    assert candidate([[1], [2], [3], [4], [5]], 2) == 2\n", "language": "python"}
{"task_id": "8d68a986-c02d-4da3-b2ae-92875b46ced98943254934534364927", "prompt": "I'll complete the function implementation following the requirements in the docstring. The code will be presented in one cohesive block, with edge cases properly addressed.\n\n```python\nfrom typing import List\n\ndef decode_ancient_script(symbols: List[str], key: List[str]) -> str:\n    \"\"\"\n    An archaeologist has discovered an ancient script carved into stone tablets. They have also\n    found a partial key that maps some of the symbols to modern letters. The archaeologist wants\n    to decode the script as much as possible using the available key.\n\n    This function takes two arguments:\n    1. A list of symbols representing the ancient script.\n    2. A list of strings representing the known key, where each string is in the format \"symbol=letter\".\n\n    The function should return a string with as much of the script decoded as possible, leaving\n    unknown symbols unchanged. The decoding should be case-insensitive.\n\n\n    [EXAMPLES]\n    \n    assert candidate(['@', '@', '@', '@', '@'], ['@=X']) == 'XXXXX'\n    assert candidate(['A', 'B', 'C', 'D', 'E'], ['A=1', 'B=2', 'C=3', 'D=4', 'E=5', 'F=6']) == '12345'\n\n    [/EXAMPLES]\n    \"\"\"\n```\n", "entry_point": "decode_ancient_script", "solution": "from typing import List\n\ndef decode_ancient_script(symbols: List[str], key: List[str]) -> str:\n    \"\"\"\n    An archaeologist has discovered an ancient script carved into stone tablets. They have also\n    found a partial key that maps some of the symbols to modern letters. The archaeologist wants\n    to decode the script as much as possible using the available key.\n\n    This function takes two arguments:\n    1. A list of symbols representing the ancient script.\n    2. A list of strings representing the known key, where each string is in the format \"symbol=letter\".\n\n    The function should return a string with as much of the script decoded as possible, leaving\n    unknown symbols unchanged. The decoding should be case-insensitive.\n\n\n    [EXAMPLES]\n    \n    assert candidate(['@', '@', '@', '@', '@'], ['@=X']) == 'XXXXX'\n    assert candidate(['A', 'B', 'C', 'D', 'E'], ['A=1', 'B=2', 'C=3', 'D=4', 'E=5', 'F=6']) == '12345'\n\n    [/EXAMPLES]\n    \"\"\"\n    # Create a dictionary to store the symbol-to-letter mapping\n    symbol_map = {}\n\n    # Parse the key and populate the symbol_map\n    for mapping in key:\n        symbol, letter = mapping.split('=')\n        symbol_map[symbol.lower()] = letter.upper()\n\n    # Decode the symbols\n    decoded_script = []\n    for symbol in symbols:\n        decoded_symbol = symbol_map.get(symbol.lower(), symbol)\n        decoded_script.append(decoded_symbol)\n\n    # Join the decoded symbols into a string\n    return ''.join(decoded_script)\n\n", "test": "def check(candidate):\n    assert candidate(['1', '2', '3', '4', '5'], ['1=ONE', '2=TWO', '3=THREE', '4=FOUR', '5=FIVE']) == 'ONETWOTHREEFOURFIVE'\n    assert candidate([], ['A=1', 'B=2', 'C=3']) == ''\n    assert candidate(['A', 'B', 'C', 'D', 'E'], ['A=1', 'B=2', 'C=3', 'D=4', 'E=5', 'F=6']) == '12345'\n    assert candidate(['A', 'B', 'C', 'D', 'E'], ['A=Z', 'B=Y', 'C=X', 'D=W', 'E=V']) == 'ZYXWV'\n    assert candidate(['A', 'a', 'B', 'b', 'C', 'c'], ['A=X', 'B=Y', 'C=Z']) == 'XXYYZZ'\n    assert candidate(['@', '@', '@', '@', '@'], ['@=X']) == 'XXXXX'\n    assert candidate(['!', '@', '#', '$', '%'], ['!=!', '@=@', '#=#', '$=$', '%=%']) == '!@#$%'\n    assert candidate(['!', '@', '#', '$', '%'], ['!=1', '@=2', '#=3', '$=4', '%=5', '!=ONE', '@=TWO', '#=THREE']) == 'ONETWOTHREE45'\n    assert candidate(['\u03b1', '\u03b2', '\u03b3', '\u03b4', '\u03b5'], ['\u03b1=a', '\u03b2=b', '\u03b3=c', '\u03b4=d', '\u03b5=e']) == 'ABCDE'\n    assert candidate(['A', 'B', 'C', 'A', 'B', 'C'], ['A=X', 'B=Y', 'C=Z', 'A=1', 'B=2', 'C=3']) == '123123'\n", "language": "python"}
{"task_id": "efe61509-75a7-4c4c-bde8-316a3e36f5416342637515989065575", "prompt": "You're asked to implement a specified function completely within a single code block. Your implementation should be self-contained within the function signature provided, with any auxiliary functions or classes nested inside it. Only use libraries that are already imported in the problem statement. Provide only the function implementation as a code block, with no additional code or explanations outside of it.\n\n```python\nfrom typing import List\n\ndef longest_increasing_path(matrix: List[List[int]]) -> int:\n    \"\"\"In a 2D terrain map represented by a matrix of integers, find the length of the longest increasing path.\n    From each cell, you can move to adjacent cells (up, down, left, right) if the next cell's value is greater\n    than the current cell's value.\n\n    This function takes a 2D list representing the terrain heights and returns the length of the longest\n    strictly increasing path in the matrix.\n\n\n    [EXAMPLES]\n    \n    assert candidate([[1]]) == 1\n    assert candidate([[1,2,3],[8,9,4],[7,6,5]]) == 9\n\n    [/EXAMPLES]\n    \"\"\"\n```\n", "entry_point": "longest_increasing_path", "solution": "from typing import List\n\ndef longest_increasing_path(matrix: List[List[int]]) -> int:\n    \"\"\"In a 2D terrain map represented by a matrix of integers, find the length of the longest increasing path.\n    From each cell, you can move to adjacent cells (up, down, left, right) if the next cell's value is greater\n    than the current cell's value.\n\n    This function takes a 2D list representing the terrain heights and returns the length of the longest\n    strictly increasing path in the matrix.\n\n\n    [EXAMPLES]\n    \n    assert candidate([[1]]) == 1\n    assert candidate([[1,2,3],[8,9,4],[7,6,5]]) == 9\n\n    [/EXAMPLES]\n    \"\"\"\n    if not matrix or not matrix[0]:\n        return 0\n\n    def dfs(i: int, j: int) -> int:\n        if (i, j) in memo:\n            return memo[(i, j)]\n\n        max_length = 1\n\n        for di, dj in directions:\n            ni, nj = i + di, j + dj\n            if 0 <= ni < m and 0 <= nj < n and matrix[ni][nj] > matrix[i][j]:\n                max_length = max(max_length, 1 + dfs(ni, nj))\n\n        memo[(i, j)] = max_length\n        return max_length\n\n    m, n = len(matrix), len(matrix[0])\n    directions = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n    memo = {}\n    max_path = 0\n\n    for i in range(m):\n        for j in range(n):\n            max_path = max(max_path, dfs(i, j))\n\n    return max_path\n\n", "test": "def check(candidate):\n    assert candidate([[5,4,3],[6,7,8],[9,8,7]]) == 7\n    assert candidate([[9,9,4],[6,6,8],[2,1,1]]) == 4\n    assert candidate([[1,2],[3,4]]) == 3\n    assert candidate([[1,2,3,4,5],[2,3,4,5,6],[3,4,5,6,7],[4,5,6,7,8],[5,6,7,8,9]]) == 9\n    assert candidate([[1,2],[2,3]]) == 3\n    assert candidate([[1,2,3,4],[12,13,14,5],[11,16,15,6],[10,9,8,7]]) == 16\n    assert candidate([[1,2,3],[8,9,4],[7,6,5]]) == 9\n    assert candidate([[1]]) == 1\n    assert candidate([[1,2,3],[4,5,6]]) == 4\n    assert candidate([[1],[2],[3]]) == 3\n", "language": "python"}
{"task_id": "5da00b38-ddef-4fc3-b3d6-7bc386b6b9312480853015617769868", "prompt": "Complete the function based on the provided docstring. Include the entire function in a single code block.\n\n```python\ndef analyze_social_network(connections: list) -> dict:\n    \"\"\"\n    A sociologist is studying the structure of a small community's social network.\n    This function analyzes the connections between individuals and returns various\n    metrics about the network.\n\n    :param connections: A list of tuples, each representing a connection between two individuals\n    :return: A dictionary containing network metrics (node count, edge count, average degree)\n\n\n    [EXAMPLES]\n    \n    assert candidate([('Alice', 'Bob'), ('Alice', 'Charlie'), ('Alice', 'David'), ('Bob', 'Charlie'), ('Bob', 'David'), ('Charlie', 'David')]) == {'node_count': 4, 'edge_count': 6, 'average_degree': 3.0}\n    assert candidate([('A', 'B'), ('C', 'D'), ('E', 'F'), ('G', 'H')]) == {'node_count': 8, 'edge_count': 4, 'average_degree': 1.0}\n\n    [/EXAMPLES]\n    \"\"\"\n```\n", "entry_point": "analyze_social_network", "solution": "def analyze_social_network(connections: list) -> dict:\n    \"\"\"\n    A sociologist is studying the structure of a small community's social network.\n    This function analyzes the connections between individuals and returns various\n    metrics about the network.\n\n    :param connections: A list of tuples, each representing a connection between two individuals\n    :return: A dictionary containing network metrics (node count, edge count, average degree)\n\n\n    [EXAMPLES]\n    \n    assert candidate([('Alice', 'Bob'), ('Alice', 'Charlie'), ('Alice', 'David'), ('Bob', 'Charlie'), ('Bob', 'David'), ('Charlie', 'David')]) == {'node_count': 4, 'edge_count': 6, 'average_degree': 3.0}\n    assert candidate([('A', 'B'), ('C', 'D'), ('E', 'F'), ('G', 'H')]) == {'node_count': 8, 'edge_count': 4, 'average_degree': 1.0}\n\n    [/EXAMPLES]\n    \"\"\"\n    # Create a set of unique nodes\n    nodes = set()\n    for connection in connections:\n        nodes.update(connection)\n\n    node_count = len(nodes)\n    edge_count = len(connections)\n\n    # Calculate the average degree\n    total_degree = 2 * edge_count  # Each edge contributes to the degree of two nodes\n    average_degree = total_degree / node_count if node_count > 0 else 0\n\n    # Round average_degree to 2 decimal places\n    average_degree = round(average_degree, 2)\n\n    return {\n        'node_count': node_count,\n        'edge_count': edge_count,\n        'average_degree': average_degree\n    }\n\n", "test": "def check(candidate):\n    assert candidate([('A', 'B'), ('B', 'C'), ('C', 'D'), ('D', 'E'), ('E', 'F'), ('F', 'A'), ('A', 'D'), ('B', 'E'), ('C', 'F')]) == {'node_count': 6, 'edge_count': 9, 'average_degree': 3.0}\n    assert candidate([('A', 'B'), ('B', 'C'), ('C', 'D'), ('D', 'E'), ('E', 'A')]) == {'node_count': 5, 'edge_count': 5, 'average_degree': 2.0}\n    assert candidate([('Person' + str(i), 'Person' + str(j)) for i in range(5) for j in range(i+1, 5)]) == {'node_count': 5, 'edge_count': 10, 'average_degree': 4.0}\n    assert candidate([('A', 'B'), ('C', 'D'), ('E', 'F'), ('G', 'H')]) == {'node_count': 8, 'edge_count': 4, 'average_degree': 1.0}\n    assert candidate([('Alice', 'Bob'), ('Bob', 'Charlie')]) == {'node_count': 3, 'edge_count': 2, 'average_degree': 1.33}\n    assert candidate([('Alice', 'Bob'), ('Bob', 'Charlie'), ('Charlie', 'Alice')]) == {'node_count': 3, 'edge_count': 3, 'average_degree': 2.0}\n    assert candidate([('A', 'A')]) == {'node_count': 1, 'edge_count': 1, 'average_degree': 2.0}\n    assert candidate([('A', 'B'), ('C', 'D'), ('E', 'F'), ('G', 'H'), ('I', 'J'), ('K', 'L'), ('M', 'N'), ('O', 'P')]) == {'node_count': 16, 'edge_count': 8, 'average_degree': 1.0}\n    assert candidate([('Alice', 'Bob'), ('Alice', 'Charlie'), ('Alice', 'David'), ('Bob', 'Charlie'), ('Bob', 'David'), ('Charlie', 'David')]) == {'node_count': 4, 'edge_count': 6, 'average_degree': 3.0}\n    assert candidate([('Node' + str(i), 'Node' + str(i + 1)) for i in range(100)]) == {'node_count': 101, 'edge_count': 100, 'average_degree': 1.98}\n", "language": "python"}
{"task_id": "ddf6efad-7f61-4cd4-a3a6-7c556f30faae-9042753435230716116", "prompt": "Based on the given doc string, finish the function implementation. Place the entire function in one code block and don't forget to address edge cases.\n\n```python\ndef encrypt_message(message: str, key: str) -> str:\n    \"\"\"\n    A secret agent needs to encrypt a message using a custom substitution cipher. The cipher is based on a\n    keyword, which is used to generate a mixed alphabet for substitution.\n\n    The function takes two parameters:\n    - message: A string containing the message to be encrypted (uppercase letters only, no spaces)\n    - key: A string containing the keyword for generating the cipher alphabet (uppercase letters only)\n\n    The function should return the encrypted message as a string.\n\n\n    [EXAMPLES]\n    \n    assert candidate(\"THEQUICKBROWNFOXJUMPSOVERTHELAZYDOG\", \"PANGRAM\") == 'TCROUDNFAQKWJMKXEUILSKVRQTCRHPZYGKB'\n    assert candidate(\"MISSION\", \"IMPOSSIBLE\") == 'GARRAJH'\n\n    [/EXAMPLES]\n    \"\"\"\n```\n", "entry_point": "encrypt_message", "solution": "def encrypt_message(message: str, key: str) -> str:\n    \"\"\"\n    A secret agent needs to encrypt a message using a custom substitution cipher. The cipher is based on a\n    keyword, which is used to generate a mixed alphabet for substitution.\n\n    The function takes two parameters:\n    - message: A string containing the message to be encrypted (uppercase letters only, no spaces)\n    - key: A string containing the keyword for generating the cipher alphabet (uppercase letters only)\n\n    The function should return the encrypted message as a string.\n\n\n    [EXAMPLES]\n    \n    assert candidate(\"THEQUICKBROWNFOXJUMPSOVERTHELAZYDOG\", \"PANGRAM\") == 'TCROUDNFAQKWJMKXEUILSKVRQTCRHPZYGKB'\n    assert candidate(\"MISSION\", \"IMPOSSIBLE\") == 'GARRAJH'\n\n    [/EXAMPLES]\n    \"\"\"\n    def generate_cipher_alphabet(keyword):\n        alphabet = \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\"\n        unique_key = \"\".join(dict.fromkeys(keyword))\n        remaining_letters = \"\".join(letter for letter in alphabet if letter not in unique_key)\n        return unique_key + remaining_letters\n\n    cipher_alphabet = generate_cipher_alphabet(key)\n    standard_alphabet = \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\"\n    translation_table = str.maketrans(standard_alphabet, cipher_alphabet)\n    \n    return message.translate(translation_table)\n\n", "test": "def check(candidate):\n    assert candidate(\"SECRETMESSAGE\", \"SECRETKEY\") == 'OTCNTPHTOOSYT'\n    assert candidate(\"ESPIONAGE\", \"UNDERCOVER\") == 'RPKAJIUOR'\n    assert candidate(\"INTELLIGENCE\", \"COVERT\") == 'DJQRHHDARJVR'\n    assert candidate(\"ZZZZZ\", \"ZZZZ\") == 'YYYYY'\n    assert candidate(\"THEQUICKBROWNFOXJUMPSOVERTHELAZYDOG\", \"PANGRAM\") == 'TCROUDNFAQKWJMKXEUILSKVRQTCRHPZYGKB'\n    assert candidate(\"TOPSECRET\", \"KEYWORD\") == 'QJLPOYNOQ'\n    assert candidate(\"ONETWOTHREEFOURFIVESIXSEVENEIGHTNINETEN\", \"NUMBERS\") == 'JIEQWJQAOEERJTORCVEPCXPEVEIECSAQICIEQEI'\n    assert candidate(\"MISSION\", \"IMPOSSIBLE\") == 'GARRAJH'\n    assert candidate(\"CIPHER\", \"ENIGMA\") == 'IDPCMR'\n    assert candidate(\"HELLO\", \"CRYPTO\") == 'BTGGJ'\n", "language": "python"}
{"task_id": "d2dec7cc-928e-4f5b-be3b-e95bcc4afdc87280044386919704985", "prompt": "I'll provide the complete function implementation that can be executed as is in a single code block. I'll ensure it only uses the imported libraries and any additional functions or classes will be defined within the given function. The response will contain just one executable code block.\n\n```python\ndef calculate_spacecraft_fuel(distance: float, payload: float) -> float:\n    \"\"\"\n    Calculate the amount of fuel needed for a spacecraft to travel a given distance with a specific payload.\n\n    This function uses a simplified model of spacecraft propulsion to estimate fuel requirements.\n    It takes into account the distance to be traveled and the mass of the payload.\n\n    Parameters:\n    distance (float): The distance to be traveled in light-years\n    payload (float): The mass of the payload in metric tons\n\n    Returns:\n    float: The amount of fuel needed in metric tons\n\n\n    [EXAMPLES]\n    \n    assert candidate(1e5, 1e5) == 1025000000.0\n    assert candidate(1, 100) == 260.0\n\n    [/EXAMPLES]\n    \"\"\"\n```\n", "entry_point": "calculate_spacecraft_fuel", "solution": "def calculate_spacecraft_fuel(distance: float, payload: float) -> float:\n    \"\"\"\n    Calculate the amount of fuel needed for a spacecraft to travel a given distance with a specific payload.\n\n    This function uses a simplified model of spacecraft propulsion to estimate fuel requirements.\n    It takes into account the distance to be traveled and the mass of the payload.\n\n    Parameters:\n    distance (float): The distance to be traveled in light-years\n    payload (float): The mass of the payload in metric tons\n\n    Returns:\n    float: The amount of fuel needed in metric tons\n\n\n    [EXAMPLES]\n    \n    assert candidate(1e5, 1e5) == 1025000000.0\n    assert candidate(1, 100) == 260.0\n\n    [/EXAMPLES]\n    \"\"\"\n    # Constants for the simplified fuel calculation model\n    BASE_FUEL_PER_LIGHT_YEAR = 250  # metric tons\n    FUEL_FACTOR_PER_TON_PAYLOAD = 0.1  # additional fuel per ton of payload\n\n    # Calculate base fuel needed for the distance\n    base_fuel = distance * BASE_FUEL_PER_LIGHT_YEAR\n\n    # Calculate additional fuel needed for the payload\n    payload_fuel = payload * FUEL_FACTOR_PER_TON_PAYLOAD * distance\n\n    # Total fuel is the sum of base fuel and payload fuel\n    total_fuel = base_fuel + payload_fuel\n\n    return total_fuel\n\n", "test": "def check(candidate):\n    assert candidate(1000, 0.5) == 250050.0\n    assert candidate(1, 100) == 260.0\n    assert candidate(20.7, 1500) == 8280.0\n    assert candidate(1e-10, 1e10) == 0.100000025\n    assert candidate(10, 1000) == 3500.0\n    assert candidate(1e5, 1e5) == 1025000000.0\n", "language": "python"}
{"task_id": "8b7bbca6-3f37-4f24-9b18-c9fa4642411a2822185629126132206", "prompt": "Let me complete this function for you while maintaining the original function name and parameter list as specified in the docstring.\n\n```python\ndef compress_genome_sequence(sequence: str) -> str:\n    \"\"\"\n    A bioinformatician is working on compressing genomic sequences to save storage space.\n    The compression algorithm should replace consecutive repeats of a nucleotide with the number of repeats followed by the nucleotide.\n    Valid nucleotides are 'A', 'C', 'G', and 'T'. If a nucleotide appears only once, it should not be compressed.\n    Return the compressed sequence.\n\n\n    [EXAMPLES]\n    \n    assert candidate(\"G\") == 'G'\n    assert candidate(\"CCCC\") == '4C'\n\n    [/EXAMPLES]\n    \"\"\"\n```\n", "entry_point": "compress_genome_sequence", "solution": "def compress_genome_sequence(sequence: str) -> str:\n    \"\"\"\n    A bioinformatician is working on compressing genomic sequences to save storage space.\n    The compression algorithm should replace consecutive repeats of a nucleotide with the number of repeats followed by the nucleotide.\n    Valid nucleotides are 'A', 'C', 'G', and 'T'. If a nucleotide appears only once, it should not be compressed.\n    Return the compressed sequence.\n\n\n    [EXAMPLES]\n    \n    assert candidate(\"G\") == 'G'\n    assert candidate(\"CCCC\") == '4C'\n\n    [/EXAMPLES]\n    \"\"\"\n    if not sequence:\n        return \"\"\n\n    compressed = []\n    count = 1\n    current_nucleotide = sequence[0]\n\n    for nucleotide in sequence[1:]:\n        if nucleotide == current_nucleotide:\n            count += 1\n        else:\n            if count > 1:\n                compressed.append(str(count) + current_nucleotide)\n            else:\n                compressed.append(current_nucleotide)\n            current_nucleotide = nucleotide\n            count = 1\n\n    # Handle the last group of nucleotides\n    if count > 1:\n        compressed.append(str(count) + current_nucleotide)\n    else:\n        compressed.append(current_nucleotide)\n\n    return \"\".join(compressed)\n\n", "test": "def check(candidate):\n    assert candidate(\"AAAATTTTCCCCGGGG\") == '4A4T4C4G'\n    assert candidate(\"AATTCCGG\") == '2A2T2C2G'\n    assert candidate(\"ATATATATATAT\") == 'ATATATATATAT'\n    assert candidate(\"CCCC\") == '4C'\n    assert candidate(\"GGGG\") == '4G'\n    assert candidate(\"AAAAACCCCCGGGGGTTTTAAAAAAAAAA\") == '5A5C5G4T10A'\n    assert candidate(\"ACTG\") == 'ACTG'\n    assert candidate(\"G\") == 'G'\n", "language": "python"}
{"task_id": "d7037767-07f1-4c76-9cf1-d15211fa5aae-8466290964426728132", "prompt": "Your job is to implement the specified function in a ready-to-run state. The final solution should be contained in one code block, with no code outside the function. Only use libraries that are explicitly imported in the problem statement. Any additional functions or classes should be defined within the main function's scope.\n\n```python\nfrom typing import List\nimport heapq\n\ndef find_minimum_meeting_rooms(intervals: List[List[int]]) -> int:\n    \"\"\"\n    A conference organizer is scheduling meetings and needs to determine the minimum number of rooms required to accommodate all meetings without any overlaps.\n\n    This function takes a list of meeting intervals (start and end times) and returns the minimum number of rooms needed.\n\n\n    [EXAMPLES]\n    \n    assert candidate([[0,1],[0,2],[0,3],[0,4],[0,5]]) == 5\n    assert candidate([[0,30],[5,10],[15,20]]) == 2\n\n    [/EXAMPLES]\n    \"\"\"\n```\n", "entry_point": "find_minimum_meeting_rooms", "solution": "from typing import List\nimport heapq\n\ndef find_minimum_meeting_rooms(intervals: List[List[int]]) -> int:\n    \"\"\"\n    A conference organizer is scheduling meetings and needs to determine the minimum number of rooms required to accommodate all meetings without any overlaps.\n\n    This function takes a list of meeting intervals (start and end times) and returns the minimum number of rooms needed.\n\n\n    [EXAMPLES]\n    \n    assert candidate([[0,1],[0,2],[0,3],[0,4],[0,5]]) == 5\n    assert candidate([[0,30],[5,10],[15,20]]) == 2\n\n    [/EXAMPLES]\n    \"\"\"\n    if not intervals:\n        return 0\n\n    # Sort intervals based on start time\n    intervals.sort(key=lambda x: x[0])\n\n    # Initialize a min heap to store end times of ongoing meetings\n    rooms = []\n    \n    # Initialize the number of rooms needed\n    max_rooms = 0\n\n    for interval in intervals:\n        # Remove meetings that have ended\n        while rooms and rooms[0] <= interval[0]:\n            heapq.heappop(rooms)\n        \n        # Add the end time of the current meeting\n        heapq.heappush(rooms, interval[1])\n        \n        # Update the maximum number of rooms needed\n        max_rooms = max(max_rooms, len(rooms))\n\n    return max_rooms\n\n", "test": "def check(candidate):\n    assert candidate([]) == 0\n    assert candidate([[1,2],[3,4],[5,6],[7,8],[9,10]]) == 1\n    assert candidate([[0,1],[0,2],[0,3],[0,4],[0,5]]) == 5\n    assert candidate([[1,10],[2,9],[3,8],[4,7],[5,6]]) == 5\n    assert candidate([[1,3],[2,4],[3,5],[4,6],[5,7]]) == 2\n    assert candidate([[0,23],[1,22],[2,21],[3,20],[4,19],[5,18]]) == 6\n    assert candidate([[0,30],[5,10],[15,20]]) == 2\n    assert candidate([[1,5],[1,5],[1,5],[2,3],[2,3],[2,3]]) == 6\n    assert candidate([[0,1],[0,1],[1,2],[1,2],[2,3],[2,3]]) == 2\n    assert candidate([[1,2],[2,3],[3,4],[4,5]]) == 1\n", "language": "python"}
{"task_id": "669b176c-cdb3-4978-aeb8-09d767eb8bc27658831686058296173", "prompt": "Please implement the provided function to be ready for execution within a single code block. Any additional functions or classes should be defined within the given function. Use only the libraries that are already imported in the problem statement.\n\n```python\nfrom typing import List, Dict\nimport re\nfrom collections import Counter\n\ndef analyze_word_frequency(text: str, n: int) -> Dict[str, int]:\n    \"\"\"\n    In a linguistics research project, we need to analyze the frequency of words in a given text.\n    This function takes a text string and returns a dictionary of the n most frequent words and their counts.\n\n    The function should use string manipulation and dictionary operations to solve this problem.\n\n\n    [EXAMPLES]\n    \n    assert candidate(\"This is a sentence with some punctuation! How, will it be handled?\", 5) == {'this': 1, 'is': 1, 'a': 1, 'sentence': 1, 'with': 1}\n    assert candidate(\"Short sentence\", 10) == {'short': 1, 'sentence': 1}\n\n    [/EXAMPLES]\n    \"\"\"\n```\n", "entry_point": "analyze_word_frequency", "solution": "from typing import List, Dict\nimport re\nfrom collections import Counter\n\ndef analyze_word_frequency(text: str, n: int) -> Dict[str, int]:\n    \"\"\"\n    In a linguistics research project, we need to analyze the frequency of words in a given text.\n    This function takes a text string and returns a dictionary of the n most frequent words and their counts.\n\n    The function should use string manipulation and dictionary operations to solve this problem.\n\n\n    [EXAMPLES]\n    \n    assert candidate(\"This is a sentence with some punctuation! How, will it be handled?\", 5) == {'this': 1, 'is': 1, 'a': 1, 'sentence': 1, 'with': 1}\n    assert candidate(\"Short sentence\", 10) == {'short': 1, 'sentence': 1}\n\n    [/EXAMPLES]\n    \"\"\"\n    # Convert the text to lowercase\n    text = text.lower()\n    \n    # Use regex to split the text into words, removing punctuation\n    words = re.findall(r'\\b\\w+\\b', text)\n    \n    # Use Counter to count the frequency of each word\n    word_counts = Counter(words)\n    \n    # Get the n most common words\n    most_common = word_counts.most_common(n)\n    \n    # Convert the result to a dictionary\n    result = dict(most_common)\n    \n    return result\n\n\n", "test": "def check(candidate):\n    assert candidate(\"Fuzzy Wuzzy was a bear. Fuzzy Wuzzy had no hair. Fuzzy Wuzzy wasn't very fuzzy, was he?\", 5) == {'fuzzy': 4, 'wuzzy': 3, 'was': 2, 'a': 1, 'bear': 1}\n    assert candidate(\"Short sentence\", 10) == {'short': 1, 'sentence': 1}\n    assert candidate(\"This is a sentence with some punctuation! How, will it be handled?\", 5) == {'this': 1, 'is': 1, 'a': 1, 'sentence': 1, 'with': 1}\n    assert candidate(\"This is a test. This is only a test.\", 3) == {'this': 2, 'is': 2, 'a': 2}\n    assert candidate(\"One fish two fish red fish blue fish\", 3) == {'fish': 4, 'one': 1, 'two': 1}\n    assert candidate(\"Peter Piper picked a peck of pickled peppers.\", 3) == {'peter': 1, 'piper': 1, 'picked': 1}\n    assert candidate(\"UPPER lower MiXeD cAsE words\", 4) == {'upper': 1, 'lower': 1, 'mixed': 1, 'case': 1}\n    assert candidate(\"I scream, you scream, we all scream for ice cream!\", 5) == {'scream': 3, 'i': 1, 'you': 1, 'we': 1, 'all': 1}\n    assert candidate(\"To be or not to be, that is the question.\", 4) == {'to': 2, 'be': 2, 'or': 1, 'not': 1}\n    assert candidate(\"Buffalo buffalo Buffalo buffalo buffalo buffalo Buffalo buffalo\", 1) == {'buffalo': 8}\n", "language": "python"}
{"task_id": "b771b6d2-86c9-48ed-97aa-755e652c9bfe-5743956708012830484", "prompt": "Your function will be delivered in one complete, executable code block. I'll only use libraries that were imported in the problem statement. All supporting functions and classes will be nested within the main function. My response will contain just this one code block.\n\n```python\ndef encode_message(message: str) -> str:\n    \"\"\"\n    A spy agency wants to encode their secret messages using a simple substitution cipher.\n    This function takes a string message and returns an encoded version where each letter\n    is replaced by its corresponding letter 3 positions ahead in the alphabet (wrapping around if necessary).\n    The function preserves spaces and punctuation, and maintains the case of the original message.\n\n\n    [EXAMPLES]\n    \n    assert candidate(\" \") == ' '\n    assert candidate(\"\") == ''\n\n    [/EXAMPLES]\n    \"\"\"\n```\n", "entry_point": "encode_message", "solution": "def encode_message(message: str) -> str:\n    \"\"\"\n    A spy agency wants to encode their secret messages using a simple substitution cipher.\n    This function takes a string message and returns an encoded version where each letter\n    is replaced by its corresponding letter 3 positions ahead in the alphabet (wrapping around if necessary).\n    The function preserves spaces and punctuation, and maintains the case of the original message.\n\n\n    [EXAMPLES]\n    \n    assert candidate(\" \") == ' '\n    assert candidate(\"\") == ''\n\n    [/EXAMPLES]\n    \"\"\"\n    def shift_char(c: str) -> str:\n        if c.isalpha():\n            ascii_offset = ord('A') if c.isupper() else ord('a')\n            return chr((ord(c) - ascii_offset + 3) % 26 + ascii_offset)\n        return c\n\n    return ''.join(shift_char(char) for char in message)\n\n", "test": "def check(candidate):\n    assert candidate(\"Two driven jocks help fax my big quiz.\") == 'Wzr gulyhq mrfnv khos ida pb elj txlc.'\n    assert candidate(\"\") == ''\n    assert candidate(\"Z z Z z Z z\") == 'C c C c C c'\n    assert candidate(\"a b c d e f g\") == 'd e f g h i j'\n    assert candidate(\"How vexingly quick daft zebras jump!\") == 'Krz yhalqjob txlfn gdiw cheudv mxps!'\n    assert candidate(\"A quick movement of the enemy will jeopardize six gunboats.\") == 'D txlfn pryhphqw ri wkh hqhpb zloo mhrsduglch vla jxqerdwv.'\n    assert candidate(\"Pack my box with five dozen liquor jugs.\") == 'Sdfn pb era zlwk ilyh grchq oltxru mxjv.'\n    assert candidate(\" \") == ' '\n    assert candidate(\"Few quips galvanized the mock jury box.\") == 'Ihz txlsv jdoydqlchg wkh prfn mxub era.'\n    assert candidate(\"123 456 789\") == '123 456 789'\n", "language": "python"}
{"task_id": "60a30c61-5d44-4f53-9853-b9f8d8cff63b-6070957155875770226", "prompt": "I need you to finish a function that can be executed as-is in a single code block. Please put all your code inside the given function - don't add anything outside of it. Only use libraries that are already imported in the problem. If you need helper functions or classes, define them within the main function. Provide just one code block in your response.\n\n```python\nfrom typing import List\nfrom collections import defaultdict\n\ndef calculate_tournament_scores(matches: List[tuple]) -> dict:\n    \"\"\"\n    A sports league organizer needs to calculate the final scores for a round-robin tournament.\n    Each match is represented by a tuple (team1, team2, score1, score2).\n    Teams get 3 points for a win, 1 point for a draw, and 0 points for a loss.\n\n    Parameters:\n    matches (List[tuple]): A list of match results, each in the format (team1, team2, score1, score2)\n\n    Returns:\n    dict: A dictionary with team names as keys and their total points as values\n\n\n    [EXAMPLES]\n    \n    assert candidate([(\"A\", \"B\", 2, 1), (\"C\", \"D\", 0, 0), (\"B\", \"C\", 3, 2), (\"D\", \"A\", 1, 1)]) == {'A': 4, 'C': 1, 'D': 2, 'B': 3}\n    assert candidate([(\"A\", \"B\", 2, 1), (\"C\", \"D\", 0, 0), (\"B\", \"C\", 3, 2), (\"D\", \"A\", 1, 1)]) == {'A': 4, 'B': 3, 'C': 1, 'D': 2}\n\n    [/EXAMPLES]\n    \"\"\"\n```\n", "entry_point": "calculate_tournament_scores", "solution": "from typing import List\nfrom collections import defaultdict\n\ndef calculate_tournament_scores(matches: List[tuple]) -> dict:\n    \"\"\"\n    A sports league organizer needs to calculate the final scores for a round-robin tournament.\n    Each match is represented by a tuple (team1, team2, score1, score2).\n    Teams get 3 points for a win, 1 point for a draw, and 0 points for a loss.\n\n    Parameters:\n    matches (List[tuple]): A list of match results, each in the format (team1, team2, score1, score2)\n\n    Returns:\n    dict: A dictionary with team names as keys and their total points as values\n\n\n    [EXAMPLES]\n    \n    assert candidate([(\"A\", \"B\", 2, 1), (\"C\", \"D\", 0, 0), (\"B\", \"C\", 3, 2), (\"D\", \"A\", 1, 1)]) == {'A': 4, 'C': 1, 'D': 2, 'B': 3}\n    assert candidate([(\"A\", \"B\", 2, 1), (\"C\", \"D\", 0, 0), (\"B\", \"C\", 3, 2), (\"D\", \"A\", 1, 1)]) == {'A': 4, 'B': 3, 'C': 1, 'D': 2}\n\n    [/EXAMPLES]\n    \"\"\"\n    scores = defaultdict(int)\n    \n    for match in matches:\n        team1, team2, score1, score2 = match\n        \n        if score1 > score2:\n            scores[team1] += 3\n        elif score1 < score2:\n            scores[team2] += 3\n        else:\n            scores[team1] += 1\n            scores[team2] += 1\n    \n    return dict(scores)\n\n", "test": "def check(candidate):\n    assert candidate([(\"Team1\", \"Team2\", 1, 0), (\"Team2\", \"Team3\", 2, 1), (\"Team3\", \"Team4\", 3, 2), (\"Team4\", \"Team1\", 4, 3), (\"Team1\", \"Team3\", 0, 0), (\"Team2\", \"Team4\", 1, 1)]) == {'Team1': 4, 'Team2': 4, 'Team3': 4, 'Team4': 4}\n    assert candidate([(\"Team1\", \"Team2\", 0, 1), (\"Team2\", \"Team3\", 1, 2), (\"Team3\", \"Team4\", 2, 3), (\"Team4\", \"Team5\", 3, 4), (\"Team5\", \"Team1\", 4, 0)]) == {'Team2': 3, 'Team3': 3, 'Team4': 3, 'Team5': 6}\n    assert candidate([(\"A\", \"B\", 2, 1), (\"C\", \"D\", 0, 0), (\"B\", \"C\", 3, 2), (\"D\", \"A\", 1, 1)]) == {'A': 4, 'B': 3, 'C': 1, 'D': 2}\n    assert candidate([(\"A\", \"B\", 1, 0), (\"C\", \"D\", 2, 1), (\"E\", \"F\", 3, 2), (\"G\", \"H\", 4, 3), (\"I\", \"J\", 5, 4)]) == {'A': 3, 'C': 3, 'E': 3, 'G': 3, 'I': 3}\n    assert candidate([(\"A\", \"B\", 1, 0), (\"B\", \"C\", 0, 1), (\"C\", \"A\", 0, 1)]) == {'A': 6, 'C': 3}\n    assert candidate([(\"A\", \"B\", 2, 1), (\"C\", \"D\", 0, 0), (\"B\", \"C\", 3, 2), (\"D\", \"A\", 1, 1)]) == {'A': 4, 'C': 1, 'D': 2, 'B': 3}\n    assert candidate([(\"X\", \"Y\", 5, 0), (\"Y\", \"Z\", 0, 5), (\"Z\", \"W\", 5, 0), (\"W\", \"X\", 0, 5)]) == {'X': 6, 'Z': 6}\n    assert candidate([(\"A\", \"B\", 0, 0), (\"B\", \"C\", 0, 0), (\"C\", \"D\", 0, 0), (\"D\", \"A\", 0, 0)]) == {'A': 2, 'B': 2, 'C': 2, 'D': 2}\n    assert candidate([(\"Team1\", \"Team2\", 0, 0)]) == {'Team1': 1, 'Team2': 1}\n    assert candidate([(\"X\", \"Y\", 0, 0), (\"Y\", \"Z\", 1, 1), (\"Z\", \"X\", 2, 2)]) == {'X': 2, 'Y': 2, 'Z': 2}\n", "language": "python"}
{"task_id": "aa5f0b44-e4fb-4c6d-9a6c-59a3799b21ec6788923187170226919", "prompt": "You function as a coding assistant. Your objective is to complete a given function to ensure it can be executed as-is in a code block. Refrain from providing code outside the function. Utilize only the libraries that are imported in the problem statement. Any additional functions or classes you create must be defined within the given function.\n\n```python\nfrom typing import List\n\ndef treasure_map(map_grid: List[List[int]]) -> int:\n    \"\"\"\n    You've discovered an ancient treasure map represented as a grid. Each cell contains a number\n    indicating the amount of gold in that location. However, there's a catch: you can only move\n    right or down, and you must reach the bottom-right corner of the map.\n\n    Your task is to find the path that collects the maximum amount of gold while adhering to the\n    movement restrictions.\n\n    Parameters:\n    map_grid (List[List[int]]): A 2D grid representing the treasure map. Each cell contains a\n                                non-negative integer indicating the amount of gold.\n\n    Returns:\n    int: The maximum amount of gold that can be collected.\n\n\n    [EXAMPLES]\n    \n    assert candidate([[0, 0, 0], [0, 1, 0], [0, 0, 0]]) == 1\n    assert candidate([[5, 4, 3], [3, 2, 1], [1, 1, 1]]) == 14\n\n    [/EXAMPLES]\n    \"\"\"\n```\n", "entry_point": "treasure_map", "solution": "from typing import List\n\ndef treasure_map(map_grid: List[List[int]]) -> int:\n    \"\"\"\n    You've discovered an ancient treasure map represented as a grid. Each cell contains a number\n    indicating the amount of gold in that location. However, there's a catch: you can only move\n    right or down, and you must reach the bottom-right corner of the map.\n\n    Your task is to find the path that collects the maximum amount of gold while adhering to the\n    movement restrictions.\n\n    Parameters:\n    map_grid (List[List[int]]): A 2D grid representing the treasure map. Each cell contains a\n                                non-negative integer indicating the amount of gold.\n\n    Returns:\n    int: The maximum amount of gold that can be collected.\n\n\n    [EXAMPLES]\n    \n    assert candidate([[0, 0, 0], [0, 1, 0], [0, 0, 0]]) == 1\n    assert candidate([[5, 4, 3], [3, 2, 1], [1, 1, 1]]) == 14\n\n    [/EXAMPLES]\n    \"\"\"\n    if not map_grid or not map_grid[0]:\n        return 0\n\n    rows, cols = len(map_grid), len(map_grid[0])\n    \n    # Initialize the DP table with the same dimensions as the input grid\n    dp = [[0] * cols for _ in range(rows)]\n    \n    # Fill the DP table\n    for i in range(rows):\n        for j in range(cols):\n            if i == 0 and j == 0:\n                # Starting point\n                dp[i][j] = map_grid[i][j]\n            elif i == 0:\n                # First row: can only come from left\n                dp[i][j] = dp[i][j-1] + map_grid[i][j]\n            elif j == 0:\n                # First column: can only come from above\n                dp[i][j] = dp[i-1][j] + map_grid[i][j]\n            else:\n                # General case: maximum of coming from above or left\n                dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + map_grid[i][j]\n    \n    # The bottom-right cell contains the maximum gold that can be collected\n    return dp[rows-1][cols-1]\n\n", "test": "def check(candidate):\n    assert candidate([[0, 0, 0], [0, 1, 0], [0, 0, 0]]) == 1\n    assert candidate([[1, 2, 3], [4, 5, 6], [7, 8, 9]]) == 29\n    assert candidate([[1, 2], [3, 4]]) == 8\n    assert candidate([[1, 1, 1], [1, 1, 1], [1, 1, 1]]) == 5\n    assert candidate([[1, 1, 1, 1, 1], [1, 1, 1, 1, 1], [1, 1, 1, 1, 1], [1, 1, 1, 1, 1], [1, 1, 1, 1, 1]]) == 9\n    assert candidate([[1, 2, 3, 4, 5]]) == 15\n    assert candidate([[0, 0], [0, 0]]) == 0\n    assert candidate([[5, 4, 3], [3, 2, 1], [1, 1, 1]]) == 14\n    assert candidate([[1, 0, 1], [0, 1, 0], [1, 0, 1]]) == 3\n    assert candidate([[1, 1, 1, 1], [1, 1, 1, 1]]) == 5\n", "language": "python"}
{"task_id": "fdc4e111-20f1-47c5-8581-a354a41915147171459042328815321", "prompt": "I'll deliver a complete, executable function in a single code block. My solution will exclusively use the libraries specified in the problem. Any additional functions or classes needed will be defined inside the main function. The output will consist of just one code block containing the solution.\n\n```python\nfrom typing import List, Tuple\n\ndef optimize_study_schedule(subjects: List[str], study_hours: int) -> List[Tuple[str, float]]:\n    \"\"\"\n    A student preparing for final exams wants to create an optimized study schedule based on the difficulty of each subject.\n\n    This function takes a list of subjects and the total available study hours.\n    It returns a list of tuples, where each tuple contains a subject name and the allocated study time in hours.\n    The study time should be distributed proportionally based on the character count of each subject name,\n    assuming longer names indicate more complex subjects requiring more study time.\n\n    Round the study hours to one decimal place.\n\n\n    [EXAMPLES]\n    \n    assert candidate(['Mechanical Engineering', 'Electrical Engineering', 'Civil Engineering'], 27) == [('Mechanical Engineering', 9.7), ('Electrical Engineering', 9.7), ('Civil Engineering', 7.6)]\n    assert candidate(['Calculus', 'Linear Algebra', 'Statistics'], 24) == [('Calculus', 6.0), ('Linear Algebra', 10.5), ('Statistics', 7.5)]\n\n    [/EXAMPLES]\n    \"\"\"\n```\n", "entry_point": "optimize_study_schedule", "solution": "from typing import List, Tuple\n\ndef optimize_study_schedule(subjects: List[str], study_hours: int) -> List[Tuple[str, float]]:\n    \"\"\"\n    A student preparing for final exams wants to create an optimized study schedule based on the difficulty of each subject.\n\n    This function takes a list of subjects and the total available study hours.\n    It returns a list of tuples, where each tuple contains a subject name and the allocated study time in hours.\n    The study time should be distributed proportionally based on the character count of each subject name,\n    assuming longer names indicate more complex subjects requiring more study time.\n\n    Round the study hours to one decimal place.\n\n\n    [EXAMPLES]\n    \n    assert candidate(['Mechanical Engineering', 'Electrical Engineering', 'Civil Engineering'], 27) == [('Mechanical Engineering', 9.7), ('Electrical Engineering', 9.7), ('Civil Engineering', 7.6)]\n    assert candidate(['Calculus', 'Linear Algebra', 'Statistics'], 24) == [('Calculus', 6.0), ('Linear Algebra', 10.5), ('Statistics', 7.5)]\n\n    [/EXAMPLES]\n    \"\"\"\n    # Calculate total character count\n    total_chars = sum(len(subject) for subject in subjects)\n    \n    # Calculate study time for each subject\n    schedule = []\n    remaining_hours = study_hours\n    \n    for subject in subjects:\n        # Calculate proportional study time\n        subject_hours = (len(subject) / total_chars) * study_hours\n        \n        # Round to one decimal place\n        subject_hours = round(subject_hours, 1)\n        \n        # Adjust for rounding errors\n        if subject == subjects[-1]:\n            subject_hours = round(remaining_hours, 1)\n        else:\n            remaining_hours -= subject_hours\n        \n        schedule.append((subject, subject_hours))\n    \n    return schedule\n\n", "test": "def check(candidate):\n    assert candidate(['Art', 'Music', 'Drama', 'Dance'], 10) == [('Art', 1.7), ('Music', 2.8), ('Drama', 2.8), ('Dance', 2.7)]\n    assert candidate(['Marketing', 'Finance', 'Management', 'Accounting'], 32) == [('Marketing', 8.0), ('Finance', 6.2), ('Management', 8.9), ('Accounting', 8.9)]\n    assert candidate(['Physics', 'Chemistry', 'Biology'], 15) == [('Physics', 4.6), ('Chemistry', 5.9), ('Biology', 4.5)]\n    assert candidate(['Thermodynamics', 'Quantum Mechanics', 'Relativity'], 21) == [('Thermodynamics', 7.2), ('Quantum Mechanics', 8.7), ('Relativity', 5.1)]\n    assert candidate(['Calculus', 'Linear Algebra', 'Statistics'], 24) == [('Calculus', 6.0), ('Linear Algebra', 10.5), ('Statistics', 7.5)]\n    assert candidate(['Mechanical Engineering', 'Electrical Engineering', 'Civil Engineering'], 27) == [('Mechanical Engineering', 9.7), ('Electrical Engineering', 9.7), ('Civil Engineering', 7.6)]\n    assert candidate(['History', 'Geography', 'Economics', 'Literature'], 20) == [('History', 4.0), ('Geography', 5.1), ('Economics', 5.1), ('Literature', 5.8)]\n    assert candidate(['Psychology', 'Sociology', 'Anthropology'], 16) == [('Psychology', 5.2), ('Sociology', 4.6), ('Anthropology', 6.2)]\n    assert candidate(['Painting', 'Sculpture', 'Photography'], 9) == [('Painting', 2.6), ('Sculpture', 2.9), ('Photography', 3.5)]\n    assert candidate(['World History', 'American History', 'European History'], 18) == [('World History', 5.2), ('American History', 6.4), ('European History', 6.4)]\n", "language": "python"}
{"task_id": "8ce380a6-8e37-4d39-8751-c0b0f031b4299016822868084013022", "prompt": "Complete this function based on its documentation. Maintain the original function name and parameter list. Deliver the entire function in a single code block.\n\n```python\ndef encrypt_message(message: str, shift: int) -> str:\n    \"\"\"\n    A secret agent needs to encrypt a message using a simple substitution cipher. This function takes a message\n    and a shift value, then returns the encrypted message using the Caesar cipher technique.\n\n    The function should:\n    1. Shift each letter in the message by the specified amount\n    2. Wrap around the alphabet if necessary (e.g., 'z' shifted by 1 becomes 'a')\n    3. Preserve spaces and punctuation\n    4. Maintain the case of the original letters\n\n\n    [EXAMPLES]\n    \n    assert candidate(\"Hello, World!\", 1) == 'Ifmmp, Xpsme!'\n    assert candidate(\"Wrap around Z to A\", 2) == 'Ytcr ctqwpf B vq C'\n\n    [/EXAMPLES]\n    \"\"\"\n```\n", "entry_point": "encrypt_message", "solution": "def encrypt_message(message: str, shift: int) -> str:\n    \"\"\"\n    A secret agent needs to encrypt a message using a simple substitution cipher. This function takes a message\n    and a shift value, then returns the encrypted message using the Caesar cipher technique.\n\n    The function should:\n    1. Shift each letter in the message by the specified amount\n    2. Wrap around the alphabet if necessary (e.g., 'z' shifted by 1 becomes 'a')\n    3. Preserve spaces and punctuation\n    4. Maintain the case of the original letters\n\n\n    [EXAMPLES]\n    \n    assert candidate(\"Hello, World!\", 1) == 'Ifmmp, Xpsme!'\n    assert candidate(\"Wrap around Z to A\", 2) == 'Ytcr ctqwpf B vq C'\n\n    [/EXAMPLES]\n    \"\"\"\n    def shift_char(char: str, shift: int) -> str:\n        if char.isalpha():\n            ascii_offset = ord('A') if char.isupper() else ord('a')\n            return chr((ord(char) - ascii_offset + shift) % 26 + ascii_offset)\n        return char\n\n    return ''.join(shift_char(char, shift) for char in message)\n\n", "test": "def check(candidate):\n    assert candidate(\"Hello, World!\", 1) == 'Ifmmp, Xpsme!'\n    assert candidate(\"abcdefghijklmnopqrstuvwxyz\", 26) == 'abcdefghijklmnopqrstuvwxyz'\n    assert candidate(\"The quick brown fox jumps over the lazy dog.\", 5) == 'Ymj vznhp gwtbs ktc ozrux tajw ymj qfed itl.'\n    assert candidate(\"Z\" * 1000, -1) == 'YYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYY'\n    assert candidate(\"A\" * 1000, 1) == 'BBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBB'\n    assert candidate(\"    Spaces    at    ends    \", 9) == '    Byjlnb    jc    nwmb    '\n    assert candidate(\"\u00dcml\u00e5\u00fcts \u00e4re n\u00f6t \u00e5ffected\", 4) == 'Dqpgdxw fvi rxx gjjigxih'\n    assert candidate(\"Punctuation! Marks? Are; Preserved.\", 8) == 'Xcvkbcibqwv! Uizsa? Izm; Xzmamzdml.'\n    assert candidate(\"Wrap around Z to A\", 2) == 'Ytcr ctqwpf B vq C'\n    assert candidate(\"a b c d e f g\", 25) == 'z a b c d e f'\n", "language": "python"}
{"task_id": "19b54a96-151e-464b-b557-9692dcecf3624737253763845716675", "prompt": "I'll finish this function according to its docstring. The solution will be presented in one code block with proper handling of edge cases.\n\n```python\nimport math\nfrom typing import List\n\ndef calculate_orbit(planets: List[float], distances: List[float]) -> List[float]:\n    \"\"\"You are an astrophysicist studying the orbital periods of exoplanets in a distant star system.\n    Your task is to calculate the orbital period of each planet given their masses and distances from the star.\n    Use Kepler's Third Law of Planetary Motion to determine the orbital period in Earth years.\n    The formula is: T = 2\u03c0 * sqrt(a^3 / (G * (M + m))), where:\n    T is the orbital period\n    a is the semi-major axis (distance from the star)\n    G is the gravitational constant (use 6.67430e-11 m^3 kg^-1 s^-2)\n    M is the mass of the star (use 1.989e30 kg for a Sun-like star)\n    m is the mass of the planet\n\n    Take two input lists: planets (masses in Earth masses) and distances (in astronomical units).\n    Return a list of orbital periods in Earth years.\n\n\n    [EXAMPLES]\n    \n    assert candidate([2.5], [1.5]) == [1.84]\n    assert candidate([5.0, 10.0, 15.0], [0.5, 1.0, 1.5]) == [0.35, 1.0, 1.84]\n\n    [/EXAMPLES]\n    \"\"\"\n```\n", "entry_point": "calculate_orbit", "solution": "import math\nfrom typing import List\n\ndef calculate_orbit(planets: List[float], distances: List[float]) -> List[float]:\n    \"\"\"You are an astrophysicist studying the orbital periods of exoplanets in a distant star system.\n    Your task is to calculate the orbital period of each planet given their masses and distances from the star.\n    Use Kepler's Third Law of Planetary Motion to determine the orbital period in Earth years.\n    The formula is: T = 2\u03c0 * sqrt(a^3 / (G * (M + m))), where:\n    T is the orbital period\n    a is the semi-major axis (distance from the star)\n    G is the gravitational constant (use 6.67430e-11 m^3 kg^-1 s^-2)\n    M is the mass of the star (use 1.989e30 kg for a Sun-like star)\n    m is the mass of the planet\n\n    Take two input lists: planets (masses in Earth masses) and distances (in astronomical units).\n    Return a list of orbital periods in Earth years.\n\n\n    [EXAMPLES]\n    \n    assert candidate([2.5], [1.5]) == [1.84]\n    assert candidate([5.0, 10.0, 15.0], [0.5, 1.0, 1.5]) == [0.35, 1.0, 1.84]\n\n    [/EXAMPLES]\n    \"\"\"\n    # Constants\n    G = 6.67430e-11  # Gravitational constant in m^3 kg^-1 s^-2\n    M = 1.989e30  # Mass of the star (Sun-like) in kg\n    EARTH_MASS = 5.97e24  # Mass of Earth in kg\n    AU_TO_M = 1.496e11  # 1 AU in meters\n    SECONDS_PER_YEAR = 365.25 * 24 * 60 * 60  # Seconds in a year\n\n    orbital_periods = []\n\n    for planet_mass, distance in zip(planets, distances):\n        # Convert planet mass from Earth masses to kg\n        m = planet_mass * EARTH_MASS\n        \n        # Convert distance from AU to meters\n        a = distance * AU_TO_M\n        \n        # Calculate orbital period using Kepler's Third Law\n        T = 2 * math.pi * math.sqrt(a**3 / (G * (M + m)))\n        \n        # Convert orbital period from seconds to Earth years\n        T_years = T / SECONDS_PER_YEAR\n        \n        orbital_periods.append(round(T_years, 2))\n\n    return orbital_periods\n\n", "test": "def check(candidate):\n    assert candidate([0.01, 0.1, 1.0, 10.0, 100.0], [0.1, 0.5, 1.0, 5.0, 10.0]) == [0.03, 0.35, 1.0, 11.18, 31.61]\n    assert candidate([1.0, 2.0, 3.0, 4.0, 5.0], [0.4, 0.8, 1.2, 1.6, 2.0]) == [0.25, 0.72, 1.31, 2.02, 2.83]\n    assert candidate([317.8], [5.2]) == [11.85]\n    assert candidate([0.0553], [0.387]) == [0.24]\n    assert candidate([0.1], [0.1]) == [0.03]\n    assert candidate([5.0, 10.0, 15.0], [0.5, 1.0, 1.5]) == [0.35, 1.0, 1.84]\n    assert candidate([1.0], [149597870.7]) == [1829534082831.97]\n    assert candidate([100.0], [5.0]) == [11.18]\n    assert candidate([0.001], [0.5]) == [0.35]\n    assert candidate([2.5], [1.5]) == [1.84]\n", "language": "python"}
{"task_id": "ed691086-3daf-4b46-ad51-ec9bfc391418-4053633329897230625", "prompt": "Let me implement the remainder of the function according to the documentation. I'll provide the complete solution in a single code block, with careful consideration of edge cases.\n\n```python\nimport math\nfrom typing import List, Tuple\nfrom typing import List\n\ndef calculate_solar_panel_efficiency(panel_specs: List[Tuple[float, float]], sun_angles: List[float]) -> float:\n    \"\"\"\n    An environmental engineer is designing a solar farm and needs to calculate the overall efficiency\n    of different solar panel configurations throughout the day.\n\n    Parameters:\n    panel_specs (List[Tuple[float, float]]): A list of tuples, each containing:\n        - panel tilt angle in degrees (float)\n        - panel efficiency at optimal angle (float)\n    sun_angles (List[float]): A list of sun angles in degrees throughout the day\n\n    Returns:\n    float: The average efficiency of the solar panel configuration for the given sun angles\n\n\n    [EXAMPLES]\n    \n    assert candidate([(0, 0.1), (90, 0.1)], [0, 1, 89, 90]) == 0.1\n    assert candidate([(0, 0.05), (45, 0.25), (90, 0.05)], [0, 15, 30, 45, 60, 75, 90]) == 0.22\n\n    [/EXAMPLES]\n    \"\"\"\n```\n", "entry_point": "calculate_solar_panel_efficiency", "solution": "import math\nfrom typing import List, Tuple\nfrom typing import List\n\ndef calculate_solar_panel_efficiency(panel_specs: List[Tuple[float, float]], sun_angles: List[float]) -> float:\n    \"\"\"\n    An environmental engineer is designing a solar farm and needs to calculate the overall efficiency\n    of different solar panel configurations throughout the day.\n\n    Parameters:\n    panel_specs (List[Tuple[float, float]]): A list of tuples, each containing:\n        - panel tilt angle in degrees (float)\n        - panel efficiency at optimal angle (float)\n    sun_angles (List[float]): A list of sun angles in degrees throughout the day\n\n    Returns:\n    float: The average efficiency of the solar panel configuration for the given sun angles\n\n\n    [EXAMPLES]\n    \n    assert candidate([(0, 0.1), (90, 0.1)], [0, 1, 89, 90]) == 0.1\n    assert candidate([(0, 0.05), (45, 0.25), (90, 0.05)], [0, 15, 30, 45, 60, 75, 90]) == 0.22\n\n    [/EXAMPLES]\n    \"\"\"\n    def calculate_panel_efficiency(panel_tilt: float, panel_max_efficiency: float, sun_angle: float) -> float:\n        \"\"\"Calculate the efficiency of a single panel for a given sun angle.\"\"\"\n        angle_difference = abs(panel_tilt - sun_angle)\n        # Assume efficiency decreases with cosine of angle difference\n        return panel_max_efficiency * math.cos(math.radians(angle_difference))\n\n    total_efficiency = 0\n    for sun_angle in sun_angles:\n        # Find the most efficient panel for the current sun angle\n        max_efficiency = max(\n            calculate_panel_efficiency(panel_tilt, panel_max_efficiency, sun_angle)\n            for panel_tilt, panel_max_efficiency in panel_specs\n        )\n        total_efficiency += max_efficiency\n\n    # Calculate average efficiency\n    average_efficiency = total_efficiency / len(sun_angles)\n    \n    # Round to 2 decimal places\n    return round(average_efficiency, 2)\n\n", "test": "def check(candidate):\n    assert candidate([(30, 0.18)], [0, 30, 60, 90]) == 0.15\n    assert candidate([(20, 0.15), (40, 0.2), (60, 0.25)], [10, 30, 50, 70]) == 0.22\n    assert candidate([(22.5, 0.18), (45, 0.22), (67.5, 0.18)], [0, 22.5, 45, 67.5, 90]) == 0.19\n    assert candidate([(45, 0.3)], [0, 10, 20, 30, 40, 50, 60, 70, 80, 90]) == 0.26\n    assert candidate([(0, 0.1), (90, 0.1)], [0, 1, 89, 90]) == 0.1\n    assert candidate([(45, 0.5)], [0, 22.5, 45, 67.5, 90]) == 0.43\n    assert candidate([(10, 0.1), (20, 0.15), (30, 0.2)], [5, 10, 15, 20, 25, 30, 35]) == 0.19\n    assert candidate([(30, 0.2), (60, 0.3)], [15, 30, 45, 60, 75]) == 0.27\n    assert candidate([(0, 0.05), (45, 0.25), (90, 0.05)], [0, 15, 30, 45, 60, 75, 90]) == 0.22\n    assert candidate([(0, 0.2), (90, 0.2)], [0, 45, 90]) == 0.18\n", "language": "python"}
{"task_id": "fee138c3-5d1b-4769-b668-c56f0e3c374d-4944376994851382559", "prompt": "Complete the given function based on the provided documentation. Deliver the solution as a single code block and ensure that all edge cases are properly handled.\n\n```python\ndef calculate_water_bill(consumption: float) -> float:\n    \"\"\"\n    As a water utility company employee, you need to calculate a customer's\n    monthly water bill based on their water consumption in cubic meters.\n\n    The billing rules are as follows:\n    - First 10 cubic meters: $1 per cubic meter\n    - Next 20 cubic meters: $1.5 per cubic meter\n    - Next 30 cubic meters: $2 per cubic meter\n    - Above 60 cubic meters: $3 per cubic meter\n\n    Return the total bill amount rounded to 2 decimal places.\n\n\n    [EXAMPLES]\n    \n    assert candidate(40) == 60.0\n    assert candidate(0.5) == 0.5\n\n    [/EXAMPLES]\n    \"\"\"\n```\n", "entry_point": "calculate_water_bill", "solution": "def calculate_water_bill(consumption: float) -> float:\n    \"\"\"\n    As a water utility company employee, you need to calculate a customer's\n    monthly water bill based on their water consumption in cubic meters.\n\n    The billing rules are as follows:\n    - First 10 cubic meters: $1 per cubic meter\n    - Next 20 cubic meters: $1.5 per cubic meter\n    - Next 30 cubic meters: $2 per cubic meter\n    - Above 60 cubic meters: $3 per cubic meter\n\n    Return the total bill amount rounded to 2 decimal places.\n\n\n    [EXAMPLES]\n    \n    assert candidate(40) == 60.0\n    assert candidate(0.5) == 0.5\n\n    [/EXAMPLES]\n    \"\"\"\n    bill = 0.0\n\n    # First 10 cubic meters\n    if consumption <= 10:\n        bill = consumption * 1.0\n    else:\n        bill += 10 * 1.0\n        remaining = consumption - 10\n\n        # Next 20 cubic meters\n        if remaining <= 20:\n            bill += remaining * 1.5\n        else:\n            bill += 20 * 1.5\n            remaining -= 20\n\n            # Next 30 cubic meters\n            if remaining <= 30:\n                bill += remaining * 2.0\n            else:\n                bill += 30 * 2.0\n                remaining -= 30\n\n                # Above 60 cubic meters\n                bill += remaining * 3.0\n\n    return round(bill, 2)\n\n", "test": "def check(candidate):\n    assert candidate(61) == 103.0\n    assert candidate(1000) == 2920.0\n    assert candidate(5) == 5.0\n    assert candidate(59.99) == 99.98\n    assert candidate(100) == 220.0\n    assert candidate(0.5) == 0.5\n    assert candidate(5) == 5\n    assert candidate(40) == 60.0\n", "language": "python"}
{"task_id": "a5615e84-c577-4a2f-9170-308f2474a926-3121015426815912375", "prompt": "Complete the given function so it's ready to execute. Your code should be contained in a single block with no external definitions. Only use libraries that are already imported in the problem. Any helper functions or additional classes should be defined within the main function. Provide only one code block in your response.\n\n```python\nimport math\nfrom typing import List\n\ndef decode_alien_message(signal: List[int]) -> str:\n    \"\"\"\n    You are a cryptographer working for SETI (Search for Extraterrestrial Intelligence).\n    You've received a mysterious signal from outer space, represented as a list of integers.\n    Your task is to decode this signal into a meaningful message.\n\n    The decoding process works as follows:\n    1. Each integer in the signal represents a character in the message.\n    2. To get the actual character, you need to perform a series of operations on each integer:\n       a. Take the square root of the absolute value of the integer.\n       b. Round down to the nearest integer.\n       c. Take the modulo 26 of this value.\n       d. Convert the resulting number to its corresponding uppercase letter (0=A, 1=B, ..., 25=Z).\n\n    Develop an algorithm to decode the alien message and return it as a string.\n\n\n    [EXAMPLES]\n    \n    assert candidate([0]) == 'A'\n    assert candidate([625, -256, 16, 1024, 4, 2401, 4, 3136, 49]) == 'ZQEGCXCEH'\n\n    [/EXAMPLES]\n    \"\"\"\n```\n", "entry_point": "decode_alien_message", "solution": "import math\nfrom typing import List\n\ndef decode_alien_message(signal: List[int]) -> str:\n    \"\"\"\n    You are a cryptographer working for SETI (Search for Extraterrestrial Intelligence).\n    You've received a mysterious signal from outer space, represented as a list of integers.\n    Your task is to decode this signal into a meaningful message.\n\n    The decoding process works as follows:\n    1. Each integer in the signal represents a character in the message.\n    2. To get the actual character, you need to perform a series of operations on each integer:\n       a. Take the square root of the absolute value of the integer.\n       b. Round down to the nearest integer.\n       c. Take the modulo 26 of this value.\n       d. Convert the resulting number to its corresponding uppercase letter (0=A, 1=B, ..., 25=Z).\n\n    Develop an algorithm to decode the alien message and return it as a string.\n\n\n    [EXAMPLES]\n    \n    assert candidate([0]) == 'A'\n    assert candidate([625, -256, 16, 1024, 4, 2401, 4, 3136, 49]) == 'ZQEGCXCEH'\n\n    [/EXAMPLES]\n    \"\"\"\n    def decode_char(num: int) -> str:\n        # Take the square root of the absolute value\n        sqrt_val = math.sqrt(abs(num))\n        \n        # Round down to the nearest integer\n        floor_val = math.floor(sqrt_val)\n        \n        # Take the modulo 26\n        mod_val = floor_val % 26\n        \n        # Convert to corresponding uppercase letter\n        return chr(mod_val + 65)  # ASCII 'A' starts at 65\n    \n    # Decode each integer in the signal and join the resulting characters\n    decoded_message = ''.join(decode_char(num) for num in signal)\n    \n    return decoded_message\n\n", "test": "def check(candidate):\n    assert candidate([625, -256, 16, 1024, 4, 2401, 4, 3136, 49]) == 'ZQEGCXCEH'\n    assert candidate([-10**6, -10**7, -10**8, -10**9, -10**10]) == 'MQQGE'\n    assert candidate([2**i for i in range(20)]) == 'BBCCEFILQWGTMMYZWYSW'\n    assert candidate([1] * 100) == 'BBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBB'\n    assert candidate([10**6, 10**7, 10**8, 10**9, 10**10]) == 'MQQGE'\n    assert candidate([-i**2 for i in range(1, 21)]) == 'BCDEFGHIJKLMNOPQRSTU'\n    assert candidate([2**10, 3**10, 5**10, 7**10, 11**10]) == 'GJFLH'\n    assert candidate([-676, -729, -784, -841, -900]) == 'ABCDE'\n    assert candidate([26] * 100) == 'FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF'\n    assert candidate([0]) == 'A'\n", "language": "python"}
{"task_id": "355867c0-abb4-4850-ae03-acae2bec7aec256148589722063796", "prompt": "I'll implement the requested function in a single code block. The function will be complete and executable, with any additional helper functions or classes defined inside the main function. I'll only use the libraries that were imported in the problem statement.\n\n```python\nfrom typing import List\n\ndef decrypt_ancient_script(encrypted_text: str, codex: List[tuple]) -> str:\n    \"\"\"\n    An archaeologist has discovered an ancient script and a partial codex for decryption.\n    The codex contains pairs of characters, where the first character in each pair should be\n    replaced by the second character. Help decrypt the script using the given codex.\n\n    Args:\n    encrypted_text (str): The encrypted text in the ancient script.\n    codex (List[tuple]): A list of character pairs for decryption.\n\n    Returns:\n    str: The decrypted text.\n\n\n    [EXAMPLES]\n    \n    assert candidate(\"ABC\", []) == 'ABC'\n    assert candidate(\"!@#$%^&*()\", [('!', '1'), ('@', '2'), ('#', '3'), ('$', '4'), ('%', '5'), ('^', '6'), ('&', '7'), ('*', '8'), ('(', '9'), (')', '0')]) == '1234567890'\n\n    [/EXAMPLES]\n    \"\"\"\n```\n", "entry_point": "decrypt_ancient_script", "solution": "from typing import List\n\ndef decrypt_ancient_script(encrypted_text: str, codex: List[tuple]) -> str:\n    \"\"\"\n    An archaeologist has discovered an ancient script and a partial codex for decryption.\n    The codex contains pairs of characters, where the first character in each pair should be\n    replaced by the second character. Help decrypt the script using the given codex.\n\n    Args:\n    encrypted_text (str): The encrypted text in the ancient script.\n    codex (List[tuple]): A list of character pairs for decryption.\n\n    Returns:\n    str: The decrypted text.\n\n\n    [EXAMPLES]\n    \n    assert candidate(\"ABC\", []) == 'ABC'\n    assert candidate(\"!@#$%^&*()\", [('!', '1'), ('@', '2'), ('#', '3'), ('$', '4'), ('%', '5'), ('^', '6'), ('&', '7'), ('*', '8'), ('(', '9'), (')', '0')]) == '1234567890'\n\n    [/EXAMPLES]\n    \"\"\"\n    # Create a dictionary from the codex for efficient lookup\n    decryption_map = dict(codex)\n    \n    # Initialize an empty list to store decrypted characters\n    decrypted_chars = []\n    \n    # Iterate through each character in the encrypted text\n    for char in encrypted_text:\n        # If the character is in the decryption map, replace it\n        # Otherwise, keep the original character\n        decrypted_char = decryption_map.get(char, char)\n        decrypted_chars.append(decrypted_char)\n    \n    # Join the decrypted characters into a string\n    decrypted_text = ''.join(decrypted_chars)\n    \n    return decrypted_text\n\n", "test": "def check(candidate):\n    assert candidate(\"ABCDEFG\", [('A', 'G'), ('B', 'F'), ('C', 'E'), ('D', 'D'), ('E', 'C'), ('F', 'B'), ('G', 'A')]) == 'GFEDCBA'\n    assert candidate(\"!@#$%^&*()\", [('!', '1'), ('@', '2'), ('#', '3'), ('$', '4'), ('%', '5'), ('^', '6'), ('&', '7'), ('*', '8'), ('(', '9'), (')', '0')]) == '1234567890'\n    assert candidate(\"ZYXWVUTSRQPONMLKJIHGFEDCBA\", [('A', 'Z'), ('B', 'Y'), ('C', 'X'), ('D', 'W'), ('E', 'V'), ('F', 'U'), ('G', 'T'), ('H', 'S'), ('I', 'R'), ('J', 'Q'), ('K', 'P'), ('L', 'O'), ('M', 'N'), ('N', 'M'), ('O', 'L'), ('P', 'K'), ('Q', 'J'), ('R', 'I'), ('S', 'H'), ('T', 'G'), ('U', 'F'), ('V', 'E'), ('W', 'D'), ('X', 'C'), ('Y', 'B'), ('Z', 'A')]) == 'ABCDEFGHIJKLMNOPQRSTUVWXYZ'\n    assert candidate(\"123 456 789\", [('1', 'A'), ('2', 'B'), ('3', 'C'), ('4', 'D'), ('5', 'E'), ('6', 'F')]) == 'ABC DEF 789'\n    assert candidate(\"THE QUICK BROWN FOX\", [('T', 'Z'), ('H', 'Y'), ('E', 'X'), ('Q', 'W'), ('U', 'V'), ('I', 'J'), ('C', 'D'), ('K', 'L'), ('B', 'N'), ('R', 'S'), ('O', 'P'), ('W', 'M'), ('N', 'B'), ('F', 'G'), ('X', 'A')]) == 'ZYX WVJDL NSPMB GPA'\n    assert candidate(\"A B C D E F G\", [('A', '1'), ('B', '2'), ('C', '3'), ('D', '4'), ('E', '5'), ('F', '6'), ('G', '7')]) == '1 2 3 4 5 6 7'\n    assert candidate(\"ABC\", []) == 'ABC'\n    assert candidate(\"XAYZ BCDP QRST\", [('X', 'T'), ('Y', 'H'), ('P', 'E'), ('Q', 'I'), ('S', 'M')]) == 'TAHZ BCDE IRMT'\n    assert candidate(\"ABBA DEED FEED\", [('A', 'D'), ('D', 'A'), ('E', 'F'), ('F', 'E')]) == 'DBBD AFFA EFFA'\n    assert candidate(\"AAA BBB CCC\", [('A', 'X'), ('B', 'Y'), ('C', 'Z')]) == 'XXX YYY ZZZ'\n", "language": "python"}
{"task_id": "879be55b-a6c7-46aa-8315-76cc8460cd4b7945969648873988577", "prompt": "Your job is to implement the provided function so it can run directly from one code block. Keep all code within the function boundaries - don't add anything outside it. Only use libraries that are already imported. If you need additional functions or classes, define them inside the main function.\n\n```python\nfrom typing import List\nimport itertools\nfrom itertools import permutations\n\ndef find_shortest_superstring(strings: List[str]) -> str:\n    \"\"\"\n    You are a bioinformatician working on DNA sequence assembly. You have a list of DNA fragments,\n    and your task is to find the shortest superstring that contains all the given fragments as\n    substrings.\n\n    A superstring is a string that contains all the given strings as substrings. The goal is to\n    find the shortest such superstring to minimize redundancy in the assembled sequence.\n\n    The function takes one parameter:\n    1. strings: A list of strings representing DNA fragments.\n\n    Your task is to implement a function that returns the shortest superstring containing all\n    the input strings as substrings.\n\n    Note:\n    - The input strings contain only uppercase letters A, C, G, and T.\n    - The order of the fragments in the superstring doesn't matter.\n    - If multiple shortest superstrings exist, return any one of them.\n\n\n    [EXAMPLES]\n    \n    assert candidate([\"AAATTT\", \"TTTCCC\", \"CCCGGG\"]) == 'AAATTTCCCGGG'\n    assert candidate([\"A\", \"C\", \"G\", \"T\"]) == 'ACGT'\n\n    [/EXAMPLES]\n    \"\"\"\n```\n", "entry_point": "find_shortest_superstring", "solution": "from typing import List\nimport itertools\nfrom itertools import permutations\n\ndef find_shortest_superstring(strings: List[str]) -> str:\n    \"\"\"\n    You are a bioinformatician working on DNA sequence assembly. You have a list of DNA fragments,\n    and your task is to find the shortest superstring that contains all the given fragments as\n    substrings.\n\n    A superstring is a string that contains all the given strings as substrings. The goal is to\n    find the shortest such superstring to minimize redundancy in the assembled sequence.\n\n    The function takes one parameter:\n    1. strings: A list of strings representing DNA fragments.\n\n    Your task is to implement a function that returns the shortest superstring containing all\n    the input strings as substrings.\n\n    Note:\n    - The input strings contain only uppercase letters A, C, G, and T.\n    - The order of the fragments in the superstring doesn't matter.\n    - If multiple shortest superstrings exist, return any one of them.\n\n\n    [EXAMPLES]\n    \n    assert candidate([\"AAATTT\", \"TTTCCC\", \"CCCGGG\"]) == 'AAATTTCCCGGG'\n    assert candidate([\"A\", \"C\", \"G\", \"T\"]) == 'ACGT'\n\n    [/EXAMPLES]\n    \"\"\"\n    def overlap(s1: str, s2: str) -> int:\n        \"\"\"Calculate the maximum overlap between the end of s1 and the start of s2.\"\"\"\n        max_overlap = min(len(s1), len(s2))\n        for i in range(max_overlap, 0, -1):\n            if s1[-i:] == s2[:i]:\n                return i\n        return 0\n\n    def merge(s1: str, s2: str) -> str:\n        \"\"\"Merge two strings based on their overlap.\"\"\"\n        overlap_len = overlap(s1, s2)\n        return s1 + s2[overlap_len:]\n\n    def calculate_superstring(order: List[str]) -> str:\n        \"\"\"Calculate the superstring for a given order of strings.\"\"\"\n        result = order[0]\n        for s in order[1:]:\n            result = merge(result, s)\n        return result\n\n    # Try all permutations of the input strings\n    shortest = None\n    for perm in permutations(strings):\n        superstring = calculate_superstring(perm)\n        if shortest is None or len(superstring) < len(shortest):\n            shortest = superstring\n\n    return shortest\n\n", "test": "def check(candidate):\n    assert candidate([\"AAAA\", \"CCCC\", \"GGGG\", \"TTTT\", \"ACGT\"]) == 'AAAACGTTTTCCCCGGGG'\n    assert candidate([\"AAAACCCCGGGGTTTT\", \"CCCCGGGGTTTTAAAA\", \"GGGGTTTTAAAACCCC\", \"TTTTAAAACCCCGGGG\"]) == 'AAAACCCCGGGGTTTTAAAACCCCGGGG'\n    assert candidate([\"A\", \"C\", \"G\", \"T\"]) == 'ACGT'\n    assert candidate([\"A\", \"C\", \"G\", \"T\", \"AC\", \"CG\", \"GT\", \"TA\"]) == 'ACGTA'\n    assert candidate([\"ACGT\", \"ACGT\", \"ACGT\"]) == 'ACGT'\n    assert candidate([\"ACGT\", \"CGTA\", \"GTAC\", \"TACG\"]) == 'ACGTACG'\n    assert candidate([\"A\", \"AA\", \"AAA\", \"AAAA\"]) == 'AAAA'\n    assert candidate([\"CCCCC\", \"GGGGG\", \"TTTTT\"]) == 'CCCCCGGGGGTTTTT'\n    assert candidate([\"ACGT\" * 5, \"CGTA\" * 5, \"GTAC\" * 5, \"TACG\" * 5]) == 'ACGTACGTACGTACGTACGTACG'\n    assert candidate([\"AAATTT\", \"TTTCCC\", \"CCCGGG\"]) == 'AAATTTCCCGGG'\n", "language": "python"}
{"task_id": "6d55416c-fea1-4c10-b087-2df81345f32f-8526824964512734526", "prompt": "Please finish the function implementation as described in the documentation. Return your solution in a unified code block without modifying the function signature.\n\n```python\nfrom typing import List\n\ndef merge_sorted_sequences(seq1: List[int], seq2: List[int]) -> List[int]:\n    \"\"\"\n    In a parallel universe, two alien civilizations have each developed a unique sequence of prime numbers.\n    These sequences are believed to hold the key to interstellar communication. Your task is to merge these\n    two sorted sequences into a single, sorted sequence that preserves the order of both original sequences.\n\n    This function takes two sorted lists of integers as input and returns a new sorted list containing\n    all elements from both input lists.\n\n\n    [EXAMPLES]\n    \n    assert candidate([0, 2, 4, 6, 8], [1, 3, 5, 7, 9]) == [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]\n    assert candidate([], []) == []\n\n    [/EXAMPLES]\n    \"\"\"\n```\n", "entry_point": "merge_sorted_sequences", "solution": "from typing import List\n\ndef merge_sorted_sequences(seq1: List[int], seq2: List[int]) -> List[int]:\n    \"\"\"\n    In a parallel universe, two alien civilizations have each developed a unique sequence of prime numbers.\n    These sequences are believed to hold the key to interstellar communication. Your task is to merge these\n    two sorted sequences into a single, sorted sequence that preserves the order of both original sequences.\n\n    This function takes two sorted lists of integers as input and returns a new sorted list containing\n    all elements from both input lists.\n\n\n    [EXAMPLES]\n    \n    assert candidate([0, 2, 4, 6, 8], [1, 3, 5, 7, 9]) == [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]\n    assert candidate([], []) == []\n\n    [/EXAMPLES]\n    \"\"\"\n    merged = []\n    i, j = 0, 0\n    \n    while i < len(seq1) and j < len(seq2):\n        if seq1[i] <= seq2[j]:\n            merged.append(seq1[i])\n            i += 1\n        else:\n            merged.append(seq2[j])\n            j += 1\n    \n    # Append any remaining elements from seq1\n    while i < len(seq1):\n        merged.append(seq1[i])\n        i += 1\n    \n    # Append any remaining elements from seq2\n    while j < len(seq2):\n        merged.append(seq2[j])\n        j += 1\n    \n    return merged\n\n", "test": "def check(candidate):\n    assert candidate([-3, -1, 1, 3], [-2, 0, 2, 4]) == [-3, -2, -1, 0, 1, 2, 3, 4]\n    assert candidate([0, 2, 4, 6, 8], [1, 3, 5, 7, 9]) == [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]\n    assert candidate([1, 2, 3, 4, 5], [6, 7, 8, 9, 10]) == [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]\n    assert candidate([1], []) == [1]\n    assert candidate([4, 5, 6], [1, 2, 3]) == [1, 2, 3, 4, 5, 6]\n    assert candidate([1, 3, 5, 7, 9], [2, 4, 6, 8, 10]) == [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]\n    assert candidate([], []) == []\n    assert candidate([1, 3, 5, 7, 9], [2, 4, 6, 8]) == [1, 2, 3, 4, 5, 6, 7, 8, 9]\n    assert candidate([1, 2, 3], [4, 5, 6]) == [1, 2, 3, 4, 5, 6]\n    assert candidate([2, 4, 6], [1, 3, 5]) == [1, 2, 3, 4, 5, 6]\n", "language": "python"}
{"task_id": "d30685d5-4bed-4edc-aa65-7cdf22e92973-3325035122174005", "prompt": "I'll complete the provided function in one code block, making sure it's executable as-is. I'll only use the libraries that are imported in the problem statement and will define any additional functions or classes inside the given function.\n\n```python\nfrom typing import List, Tuple\n\ndef sort_grocery_list(items: List[Tuple[str, float, int]]) -> List[str]:\n    \"\"\"\n    Organize a grocery shopping list based on price per unit and expiration date.\n\n    This function takes a list of tuples, where each tuple contains an item name,\n    its price per unit, and days until expiration. It returns a list of item names\n    sorted primarily by price per unit (ascending) and secondarily by expiration date\n    (ascending).\n\n    Args:\n    items (List[Tuple[str, float, int]]): A list of tuples containing item name,\n                                          price per unit, and days until expiration.\n\n    Returns:\n    List[str]: A list of item names sorted by price per unit and expiration date.\n\n\n    [EXAMPLES]\n    \n    assert candidate([(\"Expensive Item\", 1000.0, 1), (\"Cheap Item\", 0.01, 1000)]) == ['Cheap Item', 'Expensive Item']\n    assert candidate([(\"Z\", 26.0, 26), (\"Y\", 25.0, 25), (\"X\", 24.0, 24), (\"W\", 23.0, 23), (\"V\", 22.0, 22)]) == ['V', 'W', 'X', 'Y', 'Z']\n\n    [/EXAMPLES]\n    \"\"\"\n```\n", "entry_point": "sort_grocery_list", "solution": "from typing import List, Tuple\n\ndef sort_grocery_list(items: List[Tuple[str, float, int]]) -> List[str]:\n    \"\"\"\n    Organize a grocery shopping list based on price per unit and expiration date.\n\n    This function takes a list of tuples, where each tuple contains an item name,\n    its price per unit, and days until expiration. It returns a list of item names\n    sorted primarily by price per unit (ascending) and secondarily by expiration date\n    (ascending).\n\n    Args:\n    items (List[Tuple[str, float, int]]): A list of tuples containing item name,\n                                          price per unit, and days until expiration.\n\n    Returns:\n    List[str]: A list of item names sorted by price per unit and expiration date.\n\n\n    [EXAMPLES]\n    \n    assert candidate([(\"Expensive Item\", 1000.0, 1), (\"Cheap Item\", 0.01, 1000)]) == ['Cheap Item', 'Expensive Item']\n    assert candidate([(\"Z\", 26.0, 26), (\"Y\", 25.0, 25), (\"X\", 24.0, 24), (\"W\", 23.0, 23), (\"V\", 22.0, 22)]) == ['V', 'W', 'X', 'Y', 'Z']\n\n    [/EXAMPLES]\n    \"\"\"\n    def sort_key(item: Tuple[str, float, int]) -> Tuple[float, int]:\n        \"\"\"Helper function to create a sorting key for each item.\"\"\"\n        return (item[1], item[2])  # Sort by price first, then by expiration date\n\n    # Sort the items using the custom sort key\n    sorted_items = sorted(items, key=sort_key)\n\n    # Extract and return only the item names from the sorted list\n    return [item[0] for item in sorted_items]\n\n", "test": "def check(candidate):\n    assert candidate([(\"Ice Cream\", 4.5, 90), (\"Frozen Pizza\", 6.0, 180), (\"Frozen Vegetables\", 2.5, 365)]) == ['Frozen Vegetables', 'Ice Cream', 'Frozen Pizza']\n    assert candidate([]) == []\n    assert candidate([(\"Expensive Item\", 1000.0, 1), (\"Cheap Item\", 0.01, 1000)]) == ['Cheap Item', 'Expensive Item']\n    assert candidate([(\"Apples\", 0.0, 7), (\"Bananas\", 0.0, 4), (\"Oranges\", 0.0, 14)]) == ['Bananas', 'Apples', 'Oranges']\n    assert candidate([(\"Z\", 26.0, 26), (\"Y\", 25.0, 25), (\"X\", 24.0, 24), (\"W\", 23.0, 23), (\"V\", 22.0, 22)]) == ['V', 'W', 'X', 'Y', 'Z']\n    assert candidate([(\"Long Expiry\", 1.0, 3650), (\"Short Expiry\", 1.0, 1)]) == ['Short Expiry', 'Long Expiry']\n    assert candidate([(\"A\", 0.1, 1), (\"B\", 0.2, 2), (\"C\", 0.3, 3), (\"D\", 0.4, 4), (\"E\", 0.5, 5)]) == ['A', 'B', 'C', 'D', 'E']\n    assert candidate([(\"Negative Price\", -1.0, 5), (\"Zero Expiry\", 1.0, 0), (\"Regular Item\", 2.0, 7)]) == ['Negative Price', 'Zero Expiry', 'Regular Item']\n    assert candidate([(\"Soda\", 1.5, 180), (\"Water\", 0.5, 730), (\"Juice\", 2.0, 30), (\"Tea\", 3.0, 365)]) == ['Water', 'Soda', 'Juice', 'Tea']\n    assert candidate([(\"Tomatoes\", 2.5, 5), (\"Cucumbers\", 1.8, 7), (\"Lettuce\", 1.2, 3), (\"Peppers\", 3.0, 10)]) == ['Lettuce', 'Cucumbers', 'Tomatoes', 'Peppers']\n", "language": "python"}
{"task_id": "585aa471-1fc9-4ff4-a6ed-172f6621329b-8411011352808451160", "prompt": "Allow me to implement the function as described in the docstring. The complete code will be in one block, with careful consideration of edge cases.\n\n```python\nfrom typing import List\n\ndef analyze_dna_sequences(sequences: List[str], motif: str) -> List[int]:\n    \"\"\"\n    In a genetic research study, you are tasked with analyzing multiple DNA sequences for the presence of a specific motif.\n    This function takes a list of DNA sequences and a motif as input, and returns a list of integers representing the\n    number of occurrences of the motif in each sequence.\n\n    The function utilizes string manipulation and list comprehension to efficiently process the sequences.\n\n\n    [EXAMPLES]\n    \n    assert candidate(['AAAAA', 'TTTTT', 'CCCCC', 'GGGGG'], 'AA') == [2, 0, 0, 0]\n    assert candidate(['ATCG' * 100], 'ATCG') == [100]\n\n    [/EXAMPLES]\n    \"\"\"\n```\n", "entry_point": "analyze_dna_sequences", "solution": "from typing import List\n\ndef analyze_dna_sequences(sequences: List[str], motif: str) -> List[int]:\n    \"\"\"\n    In a genetic research study, you are tasked with analyzing multiple DNA sequences for the presence of a specific motif.\n    This function takes a list of DNA sequences and a motif as input, and returns a list of integers representing the\n    number of occurrences of the motif in each sequence.\n\n    The function utilizes string manipulation and list comprehension to efficiently process the sequences.\n\n\n    [EXAMPLES]\n    \n    assert candidate(['AAAAA', 'TTTTT', 'CCCCC', 'GGGGG'], 'AA') == [2, 0, 0, 0]\n    assert candidate(['ATCG' * 100], 'ATCG') == [100]\n\n    [/EXAMPLES]\n    \"\"\"\n    def count_motif(sequence: str, motif: str) -> int:\n        return sequence.count(motif)\n    \n    return [count_motif(sequence, motif) for sequence in sequences]\n\n", "test": "def check(candidate):\n    assert candidate(['ATATATATATAT', 'CGCGCGCGCGCG', 'TATATATATATA'], 'ATA') == [3, 0, 3]\n    assert candidate(['ATCGATCGATCG', 'ATCGATCGATCG', 'ATCGATCGATCG'], 'ATC') == [3, 3, 3]\n    assert candidate(['ATCG', 'ATCG', 'ATCG'], 'ATCG') == [1, 1, 1]\n    assert candidate(['GCGCGCGCGCGC'], 'GCG') == [3]\n    assert candidate(['AAAAA', 'TTTTT', 'CCCCC', 'GGGGG'], 'AA') == [2, 0, 0, 0]\n    assert candidate(['ATCG' * 100], 'ATCG') == [100]\n    assert candidate(['A', 'C', 'G', 'T'], 'ACGT') == [0, 0, 0, 0]\n    assert candidate([], 'ATCG') == []\n    assert candidate(['ATATATATATAT'], 'ATAT') == [3]\n    assert candidate(['ATCGATCGATCG'], 'Z') == [0]\n", "language": "python"}
{"task_id": "48d17e51-853b-4d61-9cb2-7f8bc108031a9175174110534657250", "prompt": "I will provide a complete implementation of the specified function that can be executed as-is. The solution will only use libraries imported in the problem statement, and any necessary helper functions or classes will be defined inside the main function.\n\n```python\nfrom collections import defaultdict\nfrom typing import List\n\ndef endangered_species_count(observations: List[List[str]]) -> dict:\n    \"\"\"\n    A wildlife conservation organization is tracking endangered species in a national park.\n    They need a function to count the number of sightings for each species based on ranger observations.\n\n    The function takes a list of observations, where each observation is a list containing\n    the date, location, and species name. It returns a dictionary with species names as keys\n    and their sighting counts as values.\n\n\n    [EXAMPLES]\n    \n    assert candidate([[\"2023-05-01\", \"Location1\", \"SpeciesA\"], [\"2023-05-02\", \"Location2\", \"SpeciesB\"], [\"2023-05-03\", \"Location3\", \"SpeciesC\"]] * 33 + [[\"2023-05-04\", \"Location4\", \"SpeciesD\"]]) == {'SpeciesA': 33, 'SpeciesB': 33, 'SpeciesC': 33, 'SpeciesD': 1}\n    assert candidate([[\"2023-05-01\", \"Location\", \"Species\"]] * 10000) == {'Species': 10000}\n\n    [/EXAMPLES]\n    \"\"\"\n```\n", "entry_point": "endangered_species_count", "solution": "from collections import defaultdict\nfrom typing import List\n\ndef endangered_species_count(observations: List[List[str]]) -> dict:\n    \"\"\"\n    A wildlife conservation organization is tracking endangered species in a national park.\n    They need a function to count the number of sightings for each species based on ranger observations.\n\n    The function takes a list of observations, where each observation is a list containing\n    the date, location, and species name. It returns a dictionary with species names as keys\n    and their sighting counts as values.\n\n\n    [EXAMPLES]\n    \n    assert candidate([[\"2023-05-01\", \"Location1\", \"SpeciesA\"], [\"2023-05-02\", \"Location2\", \"SpeciesB\"], [\"2023-05-03\", \"Location3\", \"SpeciesC\"]] * 33 + [[\"2023-05-04\", \"Location4\", \"SpeciesD\"]]) == {'SpeciesA': 33, 'SpeciesB': 33, 'SpeciesC': 33, 'SpeciesD': 1}\n    assert candidate([[\"2023-05-01\", \"Location\", \"Species\"]] * 10000) == {'Species': 10000}\n\n    [/EXAMPLES]\n    \"\"\"\n    species_count = {}\n\n    for observation in observations:\n        species = observation[2]  # The species name is the third element in each observation\n        if species in species_count:\n            species_count[species] += 1\n        else:\n            species_count[species] = 1\n\n    return species_count\n\n", "test": "def check(candidate):\n    assert candidate([[\"2023-05-01\", \"North Ridge\", \"Snow Leopard \"], [\"2023-05-02\", \"East Valley\", \" Snow Leopard\"]]) == {'Snow Leopard ': 1, ' Snow Leopard': 1}\n    assert candidate([[\"2023-05-01\", \"Location1\", \"SpeciesA\"], [\"2023-05-02\", \"Location2\", \"SpeciesB\"], [\"2023-05-03\", \"Location3\", \"SpeciesC\"]] * 33 + [[\"2023-05-04\", \"Location4\", \"SpeciesD\"]]) == {'SpeciesA': 33, 'SpeciesB': 33, 'SpeciesC': 33, 'SpeciesD': 1}\n    assert candidate([[\"2023-05-01\", \"North Ridge\", \"Snow Leopard\"], [\"2023-05-02\", \"East Valley\", \"Giant Panda\"], [\"2023-05-03\", \"West Forest\", \"Amur Leopard\"], [\"2023-05-04\", \"South Lake\", \"Black Rhino\"]]) == {'Snow Leopard': 1, 'Giant Panda': 1, 'Amur Leopard': 1, 'Black Rhino': 1}\n    assert candidate([[\"2023-05-01\", \"North Ridge\", \"Snow Leopard\"], [\"2023-05-02\", \"East Valley\", \"Snow Leopard\"]]) == {'Snow Leopard': 2}\n    assert candidate([[\"2023-05-01\", \"Location\", \"A\" * 1000]]) == {'AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA': 1}\n    assert candidate([]) == {}\n    assert candidate([[\"2023-05-01\", \"North Ridge\", \"Snow Leopard\"]]) == {'Snow Leopard': 1}\n    assert candidate([[\"2023-05-01\", \"North Ridge\", \"Snow Leopard\"], [\"2023-05-01\", \"North Ridge\", \"Snow Leopard\"], [\"2023-05-01\", \"North Ridge\", \"Snow Leopard\"]]) == {'Snow Leopard': 3}\n    assert candidate([[\"2023-05-01\", \"Location\", \"Species\"]] * 10000) == {'Species': 10000}\n    assert candidate([[\"2023-05-01\", \"North Ridge\", \"Snow Leopard\"]] * 1000) == {'Snow Leopard': 1000}\n", "language": "python"}
{"task_id": "064915c5-6aeb-4e76-825f-506ae8c4151c7191186664136563556", "prompt": "I'll complete the specified function so it can be executed as-is. My solution will be contained in a single code block with no external code, using only the libraries mentioned in the problem description. Any additional functions or classes will be nested within the main function.\n\n```python\nfrom typing import List\n\ndef decrypt_alien_message(message: str, dictionary: List[str]) -> str:\n    \"\"\"\n    You've intercepted an encrypted message from an alien civilization. The message is a string\n    of lowercase letters without spaces. You also have a dictionary of all possible alien words.\n    Your task is to decrypt the message by breaking it into valid words from the dictionary.\n\n    The decryption should use the minimum number of words possible. If multiple valid\n    decryptions with the same number of words exist, return any one of them.\n\n    Parameters:\n    message (str): The encrypted alien message, a string of lowercase letters without spaces.\n    dictionary (List[str]): A list of valid alien words.\n\n    Returns:\n    str: The decrypted message with spaces between words, or \"No valid decryption\" if impossible.\n\n\n    [EXAMPLES]\n    \n    assert candidate(\"aaaabbbb\", [\"a\", \"aa\", \"aaa\", \"aaaa\", \"b\", \"bb\", \"bbb\", \"bbbb\"]) == 'aaaa bbbb'\n    assert candidate(\"abcd\", [\"ab\", \"cd\"]) == 'ab cd'\n\n    [/EXAMPLES]\n    \"\"\"\n```\n", "entry_point": "decrypt_alien_message", "solution": "from typing import List\n\ndef decrypt_alien_message(message: str, dictionary: List[str]) -> str:\n    \"\"\"\n    You've intercepted an encrypted message from an alien civilization. The message is a string\n    of lowercase letters without spaces. You also have a dictionary of all possible alien words.\n    Your task is to decrypt the message by breaking it into valid words from the dictionary.\n\n    The decryption should use the minimum number of words possible. If multiple valid\n    decryptions with the same number of words exist, return any one of them.\n\n    Parameters:\n    message (str): The encrypted alien message, a string of lowercase letters without spaces.\n    dictionary (List[str]): A list of valid alien words.\n\n    Returns:\n    str: The decrypted message with spaces between words, or \"No valid decryption\" if impossible.\n\n\n    [EXAMPLES]\n    \n    assert candidate(\"aaaabbbb\", [\"a\", \"aa\", \"aaa\", \"aaaa\", \"b\", \"bb\", \"bbb\", \"bbbb\"]) == 'aaaa bbbb'\n    assert candidate(\"abcd\", [\"ab\", \"cd\"]) == 'ab cd'\n\n    [/EXAMPLES]\n    \"\"\"\n    n = len(message)\n    word_set = set(dictionary)\n    \n    # dp[i] stores the minimum number of words needed to decrypt message[:i]\n    dp = [float('inf')] * (n + 1)\n    dp[0] = 0\n    \n    # prev[i] stores the starting index of the last word for the optimal solution at i\n    prev = [-1] * (n + 1)\n    \n    for i in range(1, n + 1):\n        for j in range(i):\n            if message[j:i] in word_set and dp[j] + 1 < dp[i]:\n                dp[i] = dp[j] + 1\n                prev[i] = j\n    \n    if dp[n] == float('inf'):\n        return \"No valid decryption\"\n    \n    # Reconstruct the decrypted message\n    result = []\n    i = n\n    while i > 0:\n        j = prev[i]\n        result.append(message[j:i])\n        i = j\n    \n    return \" \".join(result[::-1])\n\n", "test": "def check(candidate):\n    assert candidate(\"abcabcabc\", [\"abc\", \"abca\", \"bcab\"]) == 'abc abc abc'\n    assert candidate(\"aaaabbbb\", [\"a\", \"aa\", \"aaa\", \"aaaa\", \"b\", \"bb\", \"bbb\", \"bbbb\"]) == 'aaaa bbbb'\n    assert candidate(\"pneumonoultramicroscopicsilicovolcanoconiosis\", [\"pneumono\", \"ultra\", \"microscopic\", \"silico\", \"volcano\", \"coniosis\"]) == 'pneumono ultra microscopic silico volcano coniosis'\n    assert candidate(\"xyzxyzxyz\", [\"x\", \"y\", \"z\", \"xyz\"]) == 'xyz xyz xyz'\n    assert candidate(\"abcdefg\", [\"a\", \"b\", \"c\", \"d\", \"e\", \"f\", \"g\"]) == 'a b c d e f g'\n    assert candidate(\"abababab\", [\"a\", \"b\", \"ab\", \"aba\", \"bab\"]) == 'ab aba bab'\n    assert candidate(\"abcdefghijklmnopqrstuvwxyz\", [\"abcdefghijklmnopqrstuvwxyz\"]) == 'abcdefghijklmnopqrstuvwxyz'\n    assert candidate(\"zzz\", [\"z\", \"zz\", \"zzz\"]) == 'zzz'\n    assert candidate(\"a\", [\"a\"]) == 'a'\n    assert candidate(\"abcd\", [\"ab\", \"cd\"]) == 'ab cd'\n", "language": "python"}
{"task_id": "f43beb93-632d-48a2-bbcf-82ee9e1b77377261141555283834335", "prompt": "Let me complete the function according to the described behavior in the docstring. The entire function will be in one code block.\n\n```python\nfrom typing import List, Dict\n\ndef ingredient_mixer(recipe: List[str], pantry: Dict[str, int]) -> str:\n    \"\"\"\n    A culinary student is tasked with creating a new dish using ingredients from their pantry.\n    The recipe requires specific ingredients in a particular order, but the student can only use\n    what's available in their pantry. This function determines if the dish can be prepared and\n    what the final creation looks like.\n\n    Parameters:\n    recipe (List[str]): A list of ingredient names in the order they should be used.\n    pantry (Dict[str, int]): A dictionary where keys are ingredient names and values are quantities available.\n\n    Returns:\n    str: A string representing the final dish, with unavailable ingredients replaced by 'X'.\n\n\n    [EXAMPLES]\n    \n    assert candidate(['water', 'flour', 'salt'], {'water': 100, 'flour': 50, 'salt': 1}) == 'water-flour-salt'\n    assert candidate(['flour', 'eggs', 'sugar', 'butter', 'vanilla'], {'flour': 2, 'eggs': 1, 'sugar': 3, 'salt': 1}) == 'flour-eggs-sugar-X-X'\n\n    [/EXAMPLES]\n    \"\"\"\n```\n", "entry_point": "ingredient_mixer", "solution": "from typing import List, Dict\n\ndef ingredient_mixer(recipe: List[str], pantry: Dict[str, int]) -> str:\n    \"\"\"\n    A culinary student is tasked with creating a new dish using ingredients from their pantry.\n    The recipe requires specific ingredients in a particular order, but the student can only use\n    what's available in their pantry. This function determines if the dish can be prepared and\n    what the final creation looks like.\n\n    Parameters:\n    recipe (List[str]): A list of ingredient names in the order they should be used.\n    pantry (Dict[str, int]): A dictionary where keys are ingredient names and values are quantities available.\n\n    Returns:\n    str: A string representing the final dish, with unavailable ingredients replaced by 'X'.\n\n\n    [EXAMPLES]\n    \n    assert candidate(['water', 'flour', 'salt'], {'water': 100, 'flour': 50, 'salt': 1}) == 'water-flour-salt'\n    assert candidate(['flour', 'eggs', 'sugar', 'butter', 'vanilla'], {'flour': 2, 'eggs': 1, 'sugar': 3, 'salt': 1}) == 'flour-eggs-sugar-X-X'\n\n    [/EXAMPLES]\n    \"\"\"\n    final_dish = []\n    \n    for ingredient in recipe:\n        if ingredient in pantry and pantry[ingredient] > 0:\n            final_dish.append(ingredient)\n            pantry[ingredient] -= 1  # Decrease the quantity of the used ingredient\n        else:\n            final_dish.append('X')\n    \n    return '-'.join(final_dish)\n\n", "test": "def check(candidate):\n    assert candidate(['milk', 'sugar', 'vanilla'], {'milk': 1, 'sugar': 0, 'vanilla': 1}) == 'milk-X-vanilla'\n    assert candidate(['a', 'b', 'c', 'd', 'e'], {}) == 'X-X-X-X-X'\n    assert candidate(['egg', 'egg', 'egg'], {'egg': 2}) == 'egg-egg-X'\n    assert candidate(['a', 'b', 'c'], {'a': 0, 'b': 1, 'c': 1}) == 'X-b-c'\n    assert candidate(['egg', 'milk', 'flour', 'sugar', 'butter'], {'egg': 6, 'milk': 2, 'flour': 3, 'sugar': 1}) == 'egg-milk-flour-sugar-X'\n    assert candidate(['a', 'a', 'a', 'a', 'a'], {'a': 3}) == 'a-a-a-X-X'\n    assert candidate(['apple'], {'apple': 1}) == 'apple'\n    assert candidate(['rice', 'beans', 'corn'], {'rice': 100, 'beans': 50, 'corn': 25}) == 'rice-beans-corn'\n    assert candidate(['flour', 'eggs', 'sugar', 'butter', 'vanilla'], {'flour': 2, 'eggs': 1, 'sugar': 3, 'salt': 1}) == 'flour-eggs-sugar-X-X'\n    assert candidate(['water', 'flour', 'salt'], {'water': 100, 'flour': 50, 'salt': 1}) == 'water-flour-salt'\n", "language": "python"}
{"task_id": "782ba81f-750f-45a5-ae14-6642915aa716-2156848144734749559", "prompt": "Please complete the implementation of the function as per the provided docstring. Ensure that your solution is contained within a single code block and maintains the original function signature.\n\n```python\nfrom typing import List\n\ndef penguin_migration(ice_floes: List[int]) -> int:\n    \"\"\"\n    Determine the minimum number of jumps needed for a penguin to cross a series of ice floes.\n\n    In this Antarctic adventure, a penguin needs to migrate across a stretch of ocean by jumping\n    between ice floes. Each ice floe is represented by an integer indicating the maximum distance\n    the penguin can jump from that floe. The penguin starts on the first ice floe and needs to\n    reach the last one. Calculate the minimum number of jumps required for the penguin to complete\n    its journey.\n\n    Args:\n    ice_floes (List[int]): A list of integers representing the maximum jump distance from each ice floe.\n\n    Returns:\n    int: The minimum number of jumps needed to reach the last ice floe, or -1 if it's impossible.\n\n\n    [EXAMPLES]\n    \n    assert candidate([5]) == 0\n    assert candidate([2, 3, 1, 1, 4]) == 2\n\n    [/EXAMPLES]\n    \"\"\"\n```\n", "entry_point": "penguin_migration", "solution": "from typing import List\n\ndef penguin_migration(ice_floes: List[int]) -> int:\n    \"\"\"\n    Determine the minimum number of jumps needed for a penguin to cross a series of ice floes.\n\n    In this Antarctic adventure, a penguin needs to migrate across a stretch of ocean by jumping\n    between ice floes. Each ice floe is represented by an integer indicating the maximum distance\n    the penguin can jump from that floe. The penguin starts on the first ice floe and needs to\n    reach the last one. Calculate the minimum number of jumps required for the penguin to complete\n    its journey.\n\n    Args:\n    ice_floes (List[int]): A list of integers representing the maximum jump distance from each ice floe.\n\n    Returns:\n    int: The minimum number of jumps needed to reach the last ice floe, or -1 if it's impossible.\n\n\n    [EXAMPLES]\n    \n    assert candidate([5]) == 0\n    assert candidate([2, 3, 1, 1, 4]) == 2\n\n    [/EXAMPLES]\n    \"\"\"\n    n = len(ice_floes)\n    if n <= 1:\n        return 0\n\n    jumps = 0\n    current_max_reach = 0\n    next_max_reach = 0\n\n    for i in range(n - 1):\n        next_max_reach = max(next_max_reach, i + ice_floes[i])\n        \n        if i == current_max_reach:\n            jumps += 1\n            current_max_reach = next_max_reach\n            \n            if current_max_reach >= n - 1:\n                return jumps\n\n    return -1 if current_max_reach < n - 1 else jumps\n\n", "test": "def check(candidate):\n    assert candidate([0]) == 0\n    assert candidate([100] + [1] * 99) == 1\n    assert candidate([2, 3, 1, 1, 4]) == 2\n    assert candidate([10, 9, 8, 7, 6, 5, 4, 3, 2, 1]) == 1\n    assert candidate([3, 2, 1, 0, 4]) == -1\n    assert candidate([1, 1, 1, 1, 4]) == 4\n    assert candidate([4, 1, 1, 1, 1]) == 1\n    assert candidate([5]) == 0\n    assert candidate([3, 3, 3, 3, 3]) == 2\n    assert candidate([2, 0, 3, 1, 4]) == 2\n", "language": "python"}
{"task_id": "2f9c558f-4439-42d0-b51a-1ba0a51535b21876584265061701161", "prompt": "I'll deliver a complete, executable implementation of the function requested, keeping all code within a single code block. The implementation will only use libraries that are imported in the problem statement. Any auxiliary functions or classes will be defined inside the main function to maintain a self-contained solution.\n\n```python\ndef calculate_text_similarity(text1: str, text2: str) -> float:\n    \"\"\"\n    Calculate the similarity between two texts using the Jaccard similarity coefficient.\n\n    This function compares two input texts by converting them to sets of words\n    and calculating the Jaccard similarity coefficient. The coefficient is defined\n    as the size of the intersection divided by the size of the union of the two sets.\n    The result is a float between 0 (completely different) and 1 (identical).\n\n\n    [EXAMPLES]\n    \n    assert candidate(\"Python programming\", \"Java coding\") == 0.0\n    assert candidate(\"Programming in Python\", \"Coding with Python\") == 0.2\n\n    [/EXAMPLES]\n    \"\"\"\n```\n", "entry_point": "calculate_text_similarity", "solution": "def calculate_text_similarity(text1: str, text2: str) -> float:\n    \"\"\"\n    Calculate the similarity between two texts using the Jaccard similarity coefficient.\n\n    This function compares two input texts by converting them to sets of words\n    and calculating the Jaccard similarity coefficient. The coefficient is defined\n    as the size of the intersection divided by the size of the union of the two sets.\n    The result is a float between 0 (completely different) and 1 (identical).\n\n\n    [EXAMPLES]\n    \n    assert candidate(\"Python programming\", \"Java coding\") == 0.0\n    assert candidate(\"Programming in Python\", \"Coding with Python\") == 0.2\n\n    [/EXAMPLES]\n    \"\"\"\n    def tokenize(text):\n        # Convert text to lowercase and split into words\n        return set(text.lower().split())\n\n    # Tokenize both input texts\n    set1 = tokenize(text1)\n    set2 = tokenize(text2)\n\n    # Calculate intersection and union of the two sets\n    intersection = set1.intersection(set2)\n    union = set1.union(set2)\n\n    # Calculate Jaccard similarity coefficient\n    if len(union) == 0:\n        return 0.0  # Handle empty sets to avoid division by zero\n    else:\n        return len(intersection) / len(union)\n\n", "test": "def check(candidate):\n    assert candidate(\"a b c d\", \"e f g h\") == 0.0\n    assert candidate(\"This is a very long text with many words\", \"This is a short text\") == 0.4\n    assert candidate(\"Machine learning algorithms\", \"Deep learning techniques\") == 0.2\n    assert candidate(\"Lorem ipsum dolor sit amet\", \"consectetur adipiscing elit\") == 0.0\n    assert candidate(\"Python programming\", \"Java coding\") == 0.0\n    assert candidate(\"Apples oranges bananas\", \"Apples bananas oranges\") == 1.0\n    assert candidate(\"The cat sat on the mat\", \"The rat ate the cheese\") == 0.125\n    assert candidate(\"Programming in Python\", \"Coding with Python\") == 0.2\n    assert candidate(\"The quick brown fox\", \"The fast brown dog\") == 0.3333333333333333\n    assert candidate(\"\", \"\") == 0.0\n", "language": "python"}
{"task_id": "49542313-50b2-4513-b840-a5aaeb66eb77-859224673522514206", "prompt": "Could you please complete the function based on what's described in the doc string? Here's a single code block with the finished function:\n\n```python\nfrom typing import List\n\ndef optimize_satellite_coverage(orbits: List[List[int]], target_areas: List[int]) -> int:\n    \"\"\"\n    As a space agency engineer, you're tasked with optimizing satellite coverage for specific areas on Earth.\n    Each satellite has a unique orbital path defined by its lowest and highest altitudes.\n    Your goal is to determine the maximum number of target areas that can be covered simultaneously.\n\n    Parameters:\n    orbits (List[List[int]]): A list of satellite orbits, where each orbit is [lowest_altitude, highest_altitude].\n    target_areas (List[int]): A list of altitudes representing areas needing coverage.\n\n    Returns:\n    int: The maximum number of target areas that can be covered simultaneously.\n\n\n    [EXAMPLES]\n    \n    assert candidate([], []) == 0\n    assert candidate([[1, 10], [5, 15], [10, 20]], [1, 5, 10, 15, 20]) == 5\n\n    [/EXAMPLES]\n    \"\"\"\n```\n", "entry_point": "optimize_satellite_coverage", "solution": "from typing import List\n\ndef optimize_satellite_coverage(orbits: List[List[int]], target_areas: List[int]) -> int:\n    \"\"\"\n    As a space agency engineer, you're tasked with optimizing satellite coverage for specific areas on Earth.\n    Each satellite has a unique orbital path defined by its lowest and highest altitudes.\n    Your goal is to determine the maximum number of target areas that can be covered simultaneously.\n\n    Parameters:\n    orbits (List[List[int]]): A list of satellite orbits, where each orbit is [lowest_altitude, highest_altitude].\n    target_areas (List[int]): A list of altitudes representing areas needing coverage.\n\n    Returns:\n    int: The maximum number of target areas that can be covered simultaneously.\n\n\n    [EXAMPLES]\n    \n    assert candidate([], []) == 0\n    assert candidate([[1, 10], [5, 15], [10, 20]], [1, 5, 10, 15, 20]) == 5\n\n    [/EXAMPLES]\n    \"\"\"\n    def is_covered(orbit, area):\n        return orbit[0] <= area <= orbit[1]\n\n    coverage = [0] * len(target_areas)\n    \n    for orbit in orbits:\n        for i, area in enumerate(target_areas):\n            if is_covered(orbit, area):\n                coverage[i] += 1\n    \n    return sum(1 for count in coverage if count > 0)\n\n", "test": "def check(candidate):\n    assert candidate([[1, 1000000]] * 100, [500000] * 100) == 100\n    assert candidate([[1000, 2000], [2500, 3500], [3700, 5000]], [1500, 3000, 4500]) == 3\n    assert candidate([[1, 10], [11, 20], [21, 30]], [5, 15, 25]) == 3\n    assert candidate([[1, 5], [6, 10]], [3, 7]) == 2\n    assert candidate([[100, 200]], [99, 201]) == 0\n    assert candidate([[1, 10], [5, 15], [10, 20]], [1, 5, 10, 15, 20]) == 5\n    assert candidate([], []) == 0\n    assert candidate([[i, i+1] for i in range(1, 1001)], list(range(1, 1001))) == 1000\n    assert candidate([[1, 10], [5, 15], [10, 20], [15, 25]], [7, 12, 17, 22]) == 4\n    assert candidate([[1, 10]], [5]) == 1\n", "language": "python"}
{"task_id": "e0eaa6a2-7cd6-42cb-8db1-1a9d18eec3678818804541217666868", "prompt": "Complete the function by following the docstring. Provide the implementation in a single code block, and pay attention to edge cases.\n\n```python\nfrom typing import List, Tuple\n\ndef simulate_ecosystem(initial_population: List[int], interactions: List[Tuple[int, int, float]]) -> List[int]:\n    \"\"\"\n    In a simplified ecosystem simulation, different species interact with each other.\n    The initial population of each species is given as a list of integers.\n    Interactions between species are represented as tuples (species1, species2, impact),\n    where impact is a float indicating how species1 affects species2's population.\n    This function simulates one generation of the ecosystem and returns the new population counts.\n\n\n    [EXAMPLES]\n    \n    assert candidate([100], []) == [100]\n    assert candidate([1, 1, 1, 1, 1], [(i, j, 0.1) for i in range(5) for j in range(5) if i != j]) == [1, 1, 1, 1, 1]\n\n    [/EXAMPLES]\n    \"\"\"\n```\n", "entry_point": "simulate_ecosystem", "solution": "from typing import List, Tuple\n\ndef simulate_ecosystem(initial_population: List[int], interactions: List[Tuple[int, int, float]]) -> List[int]:\n    \"\"\"\n    In a simplified ecosystem simulation, different species interact with each other.\n    The initial population of each species is given as a list of integers.\n    Interactions between species are represented as tuples (species1, species2, impact),\n    where impact is a float indicating how species1 affects species2's population.\n    This function simulates one generation of the ecosystem and returns the new population counts.\n\n\n    [EXAMPLES]\n    \n    assert candidate([100], []) == [100]\n    assert candidate([1, 1, 1, 1, 1], [(i, j, 0.1) for i in range(5) for j in range(5) if i != j]) == [1, 1, 1, 1, 1]\n\n    [/EXAMPLES]\n    \"\"\"\n    new_population = initial_population.copy()\n    \n    for species1, species2, impact in interactions:\n        # Calculate the change in population for species2\n        change = int(initial_population[species1] * impact)\n        \n        # Apply the change to species2's population\n        new_population[species2] += change\n    \n    # Ensure no population goes below 0\n    new_population = [max(0, pop) for pop in new_population]\n    \n    return new_population\n\n", "test": "def check(candidate):\n    assert candidate([1, 1, 1], [(0, 1, 0.0), (1, 2, 0.0), (2, 0, 0.0)]) == [1, 1, 1]\n    assert candidate([1, 1, 1, 1, 1], [(i, j, 0.1) for i in range(5) for j in range(5) if i != j]) == [1, 1, 1, 1, 1]\n    assert candidate([5, 10, 15, 20], [(0, 1, 0.1), (1, 2, -0.2), (2, 3, 0.3), (3, 0, -0.4)]) == [0, 10, 13, 24]\n    assert candidate([100], []) == [100]\n    assert candidate([1, 2], [(0, 1, 100.0), (1, 0, -100.0)]) == [0, 102]\n    assert candidate([1000, 1], [(0, 1, -0.999)]) == [1000, 0]\n    assert candidate([10**6, 10**6, 10**6], [(0, 1, -10**-6), (1, 2, -10**-6), (2, 0, -10**-6)]) == [999999, 999999, 999999]\n    assert candidate([100, 50, 80], [(0, 1, -0.1), (1, 2, 0.2), (2, 0, -0.05)]) == [96, 40, 90]\n    assert candidate([0, 100, 200], [(0, 1, 0.1), (1, 2, 0.2), (2, 0, 0.3)]) == [60, 100, 220]\n    assert candidate([1000, 500, 250], [(0, 1, -0.2), (1, 2, 0.3), (2, 0, -0.1)]) == [975, 300, 400]\n", "language": "python"}
{"task_id": "3ad63291-f4fe-403a-aa0c-a07aac49f8b7-3302783779229183801", "prompt": "Your assignment is to finish the provided function so it works as a complete, executable code block. Don't include any code outside the function. Restrict yourself to using only the libraries imported in the problem. If you need additional functions or classes, define them inside the given function.\n\n```python\ndef analyze_dna_sequence(sequence: str) -> dict:\n    \"\"\"\n    As a geneticist, you're tasked with analyzing a DNA sequence for its nucleotide composition and potential mutations.\n    This function takes a DNA sequence as input and returns a dictionary containing the count of each nucleotide\n    and the positions of any non-standard bases.\n\n\n    [EXAMPLES]\n    \n    assert candidate(\"ATCGN\") == {'A': 1, 'T': 1, 'C': 1, 'G': 1, 'non_standard': [4]}\n    assert candidate(\"A\" * 1000) == {'A': 1000, 'T': 0, 'C': 0, 'G': 0, 'non_standard': []}\n\n    [/EXAMPLES]\n    \"\"\"\n```\n", "entry_point": "analyze_dna_sequence", "solution": "def analyze_dna_sequence(sequence: str) -> dict:\n    \"\"\"\n    As a geneticist, you're tasked with analyzing a DNA sequence for its nucleotide composition and potential mutations.\n    This function takes a DNA sequence as input and returns a dictionary containing the count of each nucleotide\n    and the positions of any non-standard bases.\n\n\n    [EXAMPLES]\n    \n    assert candidate(\"ATCGN\") == {'A': 1, 'T': 1, 'C': 1, 'G': 1, 'non_standard': [4]}\n    assert candidate(\"A\" * 1000) == {'A': 1000, 'T': 0, 'C': 0, 'G': 0, 'non_standard': []}\n\n    [/EXAMPLES]\n    \"\"\"\n    # Initialize the result dictionary\n    result = {'A': 0, 'T': 0, 'C': 0, 'G': 0, 'non_standard': []}\n    \n    # Define the standard nucleotides\n    standard_nucleotides = set('ATCG')\n    \n    # Iterate through the sequence\n    for index, nucleotide in enumerate(sequence.upper()):\n        if nucleotide in standard_nucleotides:\n            result[nucleotide] += 1\n        else:\n            result['non_standard'].append(index)\n    \n    return result\n\n", "test": "def check(candidate):\n    assert candidate(\"atcg\") == {'A': 1, 'T': 1, 'C': 1, 'G': 1, 'non_standard': []}\n    assert candidate(\"NNNNNN\") == {'A': 0, 'T': 0, 'C': 0, 'G': 0, 'non_standard': [0, 1, 2, 3, 4, 5]}\n    assert candidate(\"ACGTACGTACGTACGT\") == {'A': 4, 'T': 4, 'C': 4, 'G': 4, 'non_standard': []}\n    assert candidate(\"ATCGN\") == {'A': 1, 'T': 1, 'C': 1, 'G': 1, 'non_standard': [4]}\n    assert candidate(\"\") == {'A': 0, 'T': 0, 'C': 0, 'G': 0, 'non_standard': []}\n    assert candidate(\"A\" * 1000) == {'A': 1000, 'T': 0, 'C': 0, 'G': 0, 'non_standard': []}\n    assert candidate(\"A\") == {'A': 1, 'T': 0, 'C': 0, 'G': 0, 'non_standard': []}\n    assert candidate(\"ATCGNATCGN\") == {'A': 2, 'T': 2, 'C': 2, 'G': 2, 'non_standard': [4, 9]}\n    assert candidate(\"TTTTT\") == {'A': 0, 'T': 5, 'C': 0, 'G': 0, 'non_standard': []}\n    assert candidate(\"ATCGATCGATCGATCG\") == {'A': 4, 'T': 4, 'C': 4, 'G': 4, 'non_standard': []}\n", "language": "python"}
{"task_id": "8f5a1d18-7a5c-4900-8a3e-99d68b891889-7054145620430153921", "prompt": "Below is the completed code in a single block. I've kept all additional functions and classes within the given function as requested.\n\n```python\nfrom typing import List\n\ndef decrypt_alien_message(message: str, codebook: List[str]) -> str:\n    \"\"\"\n    You've intercepted an encrypted alien message. The aliens use a special encoding where each word \n    in their language is represented by a sequence of Earth emoji. You have a codebook that maps \n    emoji sequences to their meanings. Your task is to decrypt the message.\n\n    Parameters:\n    message (str): The encrypted message, consisting of emoji separated by spaces.\n    codebook (List[str]): A list of strings, each containing an emoji sequence and its meaning, \n                          separated by a colon.\n\n    Returns:\n    str: The decrypted message.\n\n\n    [EXAMPLES]\n    \n    assert candidate(\"\ud83c\udf1f\ud83c\udf19 \ud83c\udf0d\ud83c\udf33 \ud83d\ude80\ud83c\udf15\", []) == '\ud83c\udf1f\ud83c\udf19 \ud83c\udf0d\ud83c\udf33 \ud83d\ude80\ud83c\udf15'\n    assert candidate(\"\ud83d\udc15\ud83e\uddae \ud83d\udc08\ud83d\udc3e \ud83e\udd9c\ud83e\udd9a\", [\"\ud83d\udc15\ud83e\uddae:dog\", \"\ud83d\udc08\ud83d\udc3e:cat\", \"\ud83e\udd9c\ud83e\udd9a:bird\"]) == 'dog cat bird'\n\n    [/EXAMPLES]\n    \"\"\"\n```\n", "entry_point": "decrypt_alien_message", "solution": "from typing import List\n\ndef decrypt_alien_message(message: str, codebook: List[str]) -> str:\n    \"\"\"\n    You've intercepted an encrypted alien message. The aliens use a special encoding where each word \n    in their language is represented by a sequence of Earth emoji. You have a codebook that maps \n    emoji sequences to their meanings. Your task is to decrypt the message.\n\n    Parameters:\n    message (str): The encrypted message, consisting of emoji separated by spaces.\n    codebook (List[str]): A list of strings, each containing an emoji sequence and its meaning, \n                          separated by a colon.\n\n    Returns:\n    str: The decrypted message.\n\n\n    [EXAMPLES]\n    \n    assert candidate(\"\ud83c\udf1f\ud83c\udf19 \ud83c\udf0d\ud83c\udf33 \ud83d\ude80\ud83c\udf15\", []) == '\ud83c\udf1f\ud83c\udf19 \ud83c\udf0d\ud83c\udf33 \ud83d\ude80\ud83c\udf15'\n    assert candidate(\"\ud83d\udc15\ud83e\uddae \ud83d\udc08\ud83d\udc3e \ud83e\udd9c\ud83e\udd9a\", [\"\ud83d\udc15\ud83e\uddae:dog\", \"\ud83d\udc08\ud83d\udc3e:cat\", \"\ud83e\udd9c\ud83e\udd9a:bird\"]) == 'dog cat bird'\n\n    [/EXAMPLES]\n    \"\"\"\n    # Create a dictionary from the codebook\n    translation_dict = {}\n    for entry in codebook:\n        emoji_sequence, meaning = entry.split(':')\n        translation_dict[emoji_sequence] = meaning\n\n    # Split the message into individual emoji sequences\n    encrypted_words = message.split()\n\n    # Decrypt each emoji sequence\n    decrypted_words = []\n    for word in encrypted_words:\n        if word in translation_dict:\n            decrypted_words.append(translation_dict[word])\n        else:\n            # If the emoji sequence is not in the codebook, keep it as is\n            decrypted_words.append(word)\n\n    # Join the decrypted words into a single string\n    decrypted_message = ' '.join(decrypted_words)\n\n    return decrypted_message\n\n", "test": "def check(candidate):\n    assert candidate(\"\ud83c\udf1f\ud83c\udf19 \ud83c\udf0d\ud83c\udf33 \ud83d\ude80\ud83c\udf15\", []) == '\ud83c\udf1f\ud83c\udf19 \ud83c\udf0d\ud83c\udf33 \ud83d\ude80\ud83c\udf15'\n    assert candidate(\"\ud83c\udf4e\ud83c\udf4f \ud83c\udf4a\ud83c\udf4b \ud83c\udf4c\ud83c\udf4d\", [\"\ud83c\udf4e\ud83c\udf4f:apple\", \"\ud83c\udf4a\ud83c\udf4b:citrus\", \"\ud83c\udf4c\ud83c\udf4d:tropical\"]) == 'apple citrus tropical'\n    assert candidate(\"\ud83d\udc15\ud83e\uddae \ud83d\udc08\ud83d\udc3e \ud83e\udd9c\ud83e\udd9a\", [\"\ud83d\udc15\ud83e\uddae:dog\", \"\ud83d\udc08\ud83d\udc3e:cat\", \"\ud83e\udd9c\ud83e\udd9a:bird\"]) == 'dog cat bird'\n    assert candidate(\"\ud83c\udf1f\ud83c\udf19 \ud83c\udf0d\ud83c\udf33 \ud83d\ude80\ud83c\udf15 \ud83c\udf1e\ud83c\udf3b\", [\"\ud83c\udf1f\ud83c\udf19:hello\", \"\ud83c\udf0d\ud83c\udf33:earthling\", \"\ud83d\ude80\ud83c\udf15:moonbase\", \"\ud83c\udf1e\ud83c\udf3b:sunshine\"]) == 'hello earthling moonbase sunshine'\n    assert candidate(\"\ud83c\udf55\ud83c\udf54 \ud83c\udf63\ud83c\udf71 \ud83c\udf5d\ud83e\udd58\", [\"\ud83c\udf55\ud83c\udf54:fastfood\", \"\ud83c\udf63\ud83c\udf71:japanese\", \"\ud83c\udf5d\ud83e\udd58:italian\"]) == 'fastfood japanese italian'\n    assert candidate(\"\ud83c\udfc3\u200d\u2642\ufe0f\ud83d\udeb4\u200d\u2640\ufe0f \ud83c\udfca\u200d\u2642\ufe0f\ud83c\udfc4\u200d\u2640\ufe0f \ud83e\udd38\u200d\u2642\ufe0f\ud83e\udd3e\u200d\u2640\ufe0f\", [\"\ud83c\udfc3\u200d\u2642\ufe0f\ud83d\udeb4\u200d\u2640\ufe0f:cardio\", \"\ud83c\udfca\u200d\u2642\ufe0f\ud83c\udfc4\u200d\u2640\ufe0f:water\", \"\ud83e\udd38\u200d\u2642\ufe0f\ud83e\udd3e\u200d\u2640\ufe0f:gymnastics\"]) == 'cardio water gymnastics'\n    assert candidate(\"\", []) == ''\n    assert candidate(\"\ud83c\udfb5\ud83c\udfb6 \ud83c\udfb8\ud83e\udd41 \ud83c\udfb9\ud83c\udfb7\", [\"\ud83c\udfb5\ud83c\udfb6:music\", \"\ud83c\udfb8\ud83e\udd41:band\", \"\ud83c\udfb9\ud83c\udfb7:jazz\"]) == 'music band jazz'\n    assert candidate(\"\ud83d\ude97\ud83d\ude95 \ud83d\ude82\ud83d\ude85 \u2708\ufe0f\ud83d\ude80\", [\"\ud83d\ude97\ud83d\ude95:car\", \"\ud83d\ude82\ud83d\ude85:train\", \"\u2708\ufe0f\ud83d\ude80:flying\"]) == 'car train flying'\n    assert candidate(\"\ud83d\udc36\ud83d\udc31 \ud83c\udf08\ud83c\udf44 \ud83d\udc36\ud83d\udc31\", [\"\ud83d\udc36\ud83d\udc31:friend\", \"\ud83c\udf08\ud83c\udf44:rainbow\", \"\ud83c\udf1e\ud83c\udf3b:sunshine\"]) == 'friend rainbow friend'\n", "language": "python"}
{"task_id": "1af91305-fdd1-4bed-ab5d-169657326a092973540115908539004", "prompt": "I need to see the function signature and docstring first before I can implement the rest of the function. Please share the initial function definition and documentation so I can complete it according to your specifications.\n\n```python\nfrom typing import List\n\ndef find_secret_code(encrypted_message: str, key_phrases: List[str]) -> str:\n    \"\"\"\n    In a world of espionage, decode a secret message hidden within an encrypted text.\n    \n    This function takes an encrypted message and a list of key phrases. It searches for\n    occurrences of the key phrases within the message and extracts the characters immediately\n    following each key phrase. These extracted characters, when combined, form the secret code.\n    \n    The function utilizes string manipulation and list comprehension to efficiently process\n    the input and generate the output.\n    \n    Args:\n    encrypted_message (str): The encrypted message containing hidden information.\n    key_phrases (List[str]): A list of key phrases to look for in the encrypted message.\n    \n    Returns:\n    str: The decrypted secret code.\n    \n\n    [EXAMPLES]\n    \n    assert candidate(\"thisisaverylongstringwithnospacesandnopunctuation\", [\"this\", \"very\", \"with\", \"and\"]) == 'ilnn'\n    assert candidate(\"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\", [\"a\"]) == 'a'\n\n    [/EXAMPLES]\n    \"\"\"\n```\n", "entry_point": "find_secret_code", "solution": "from typing import List\n\ndef find_secret_code(encrypted_message: str, key_phrases: List[str]) -> str:\n    \"\"\"\n    In a world of espionage, decode a secret message hidden within an encrypted text.\n    \n    This function takes an encrypted message and a list of key phrases. It searches for\n    occurrences of the key phrases within the message and extracts the characters immediately\n    following each key phrase. These extracted characters, when combined, form the secret code.\n    \n    The function utilizes string manipulation and list comprehension to efficiently process\n    the input and generate the output.\n    \n    Args:\n    encrypted_message (str): The encrypted message containing hidden information.\n    key_phrases (List[str]): A list of key phrases to look for in the encrypted message.\n    \n    Returns:\n    str: The decrypted secret code.\n    \n\n    [EXAMPLES]\n    \n    assert candidate(\"thisisaverylongstringwithnospacesandnopunctuation\", [\"this\", \"very\", \"with\", \"and\"]) == 'ilnn'\n    assert candidate(\"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\", [\"a\"]) == 'a'\n\n    [/EXAMPLES]\n    \"\"\"\n    def find_next_char(phrase: str) -> str:\n        index = encrypted_message.find(phrase)\n        if index != -1 and index + len(phrase) < len(encrypted_message):\n            return encrypted_message[index + len(phrase)]\n        return \"\"\n\n    return ''.join([find_next_char(phrase) for phrase in key_phrases])\n\n", "test": "def check(candidate):\n    assert candidate(\"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\", [\"a\"]) == 'a'\n    assert candidate(\"KEYPHRASEatthebeginningofthestring\", [\"KEYPHRASE\"]) == 'a'\n    assert candidate(\"overlappingkeyPHRASESphrases\", [\"key\", \"PHRASES\", \"phrases\"]) == 'Pp'\n    assert candidate(\"1234567890\", [\"1\", \"3\", \"5\", \"7\", \"9\"]) == '24680'\n    assert candidate(\"caseSENSITIVEtest\", [\"case\", \"SENSITIVE\", \"test\"]) == 'St'\n    assert candidate(\"abcdefghijklmnopqrstuvwxyz\", [\"a\", \"m\", \"z\"]) == 'bn'\n    assert candidate(\"repeatedrepeatedrepeated\", [\"repeated\"]) == 'r'\n    assert candidate(\"thequickbrownfoxjumpsoverthelazydog\", [\"the\"]) == 'q'\n    assert candidate(\"emptykeyphrase\", [\"\"]) == 'e'\n    assert candidate(\"thisisaverylongstringwithnospacesandnopunctuation\", [\"this\", \"very\", \"with\", \"and\"]) == 'ilnn'\n", "language": "python"}
{"task_id": "ad304327-0ccf-4552-a8ed-9212fa722fc0-2079812452574003997", "prompt": "Please provide the function for me to complete. I'll write executable code that fits within the given function, using only the libraries specified in the problem. Any helper functions or classes will be nested within the main function. The final solution will be presented in a single code block.\n\n```python\nfrom typing import List\n\ndef decode_alien_transmission(signal: List[int]) -> str:\n    \"\"\"\n    Scientists have intercepted an alien transmission in the form of a list of integers.\n    They believe each integer represents a character in the alien alphabet, but the decoding is complex.\n\n    The decoding rules are as follows:\n    1. Each character is represented by the difference between two consecutive integers.\n    2. If the difference is negative, it wraps around (e.g., -1 becomes 25, -2 becomes 24, etc.).\n    3. The alphabet has 26 characters, mapped to 0-25 (like English, A=0, B=1, ..., Z=25).\n\n    Decode the alien transmission and return the message as a string of uppercase letters.\n\n\n    [EXAMPLES]\n    \n    assert candidate([25, 24, 23, 22, 21, 20]) == 'ZZZZZ'\n    assert candidate([5, 31, 57, 83, 109, 135, 161]) == 'AAAAAA'\n\n    [/EXAMPLES]\n    \"\"\"\n```\n", "entry_point": "decode_alien_transmission", "solution": "from typing import List\n\ndef decode_alien_transmission(signal: List[int]) -> str:\n    \"\"\"\n    Scientists have intercepted an alien transmission in the form of a list of integers.\n    They believe each integer represents a character in the alien alphabet, but the decoding is complex.\n\n    The decoding rules are as follows:\n    1. Each character is represented by the difference between two consecutive integers.\n    2. If the difference is negative, it wraps around (e.g., -1 becomes 25, -2 becomes 24, etc.).\n    3. The alphabet has 26 characters, mapped to 0-25 (like English, A=0, B=1, ..., Z=25).\n\n    Decode the alien transmission and return the message as a string of uppercase letters.\n\n\n    [EXAMPLES]\n    \n    assert candidate([25, 24, 23, 22, 21, 20]) == 'ZZZZZ'\n    assert candidate([5, 31, 57, 83, 109, 135, 161]) == 'AAAAAA'\n\n    [/EXAMPLES]\n    \"\"\"\n    def decode_char(diff: int) -> str:\n        # Ensure the difference is positive and within 0-25 range\n        adjusted_diff = (diff + 26) % 26\n        # Convert to uppercase letter\n        return chr(adjusted_diff + ord('A'))\n\n    message = []\n    for i in range(1, len(signal)):\n        diff = signal[i] - signal[i-1]\n        message.append(decode_char(diff))\n\n    return ''.join(message)\n\n", "test": "def check(candidate):\n    assert candidate([100, 101, 102, 103, 104]) == 'BBBB'\n    assert candidate([1000, 974, 948, 922, 896]) == 'AAAA'\n    assert candidate([1, 27, 53, 79, 105, 131]) == 'AAAAA'\n    assert candidate([1, 1, 1, 1, 1]) == 'AAAA'\n    assert candidate([100, 74, 48, 22]) == 'AAA'\n    assert candidate([25, 24, 23, 22, 21, 20]) == 'ZZZZZ'\n    assert candidate([999, 1000, 1001, 1002, 1003]) == 'BBBB'\n    assert candidate([5, 7, 2, 15, 11, 13, 4]) == 'CVNWCR'\n    assert candidate([5, 31, 57, 83, 109, 135, 161]) == 'AAAAAA'\n    assert candidate([0, 1, 2, 3, 4, 5]) == 'BBBBB'\n", "language": "python"}
{"task_id": "fbf87a36-2a60-4993-9dff-6686a325575e-4962523171713545560", "prompt": "Please provide a full implementation of the requested function that can be executed as-is. Stay within the function block and only use libraries imported in the problem. Any auxiliary functions or classes should be defined within the main function scope.\n\n```python\nimport math\nfrom typing import List\n\ndef analyze_cat_behavior(sleeping_hours: List[int], play_times: List[float]) -> float:\n    \"\"\"\n    A cat behaviorist is studying the daily routine of a domestic cat. The researcher wants to understand the relationship between the cat's sleeping patterns and its play activities.\n\n    This function takes two lists as input:\n    - sleeping_hours: A list of integers representing the number of hours the cat slept each day for a week.\n    - play_times: A list of floats representing the amount of time (in hours) the cat spent playing each day for the same week.\n\n    The function should calculate and return the correlation coefficient between sleeping hours and play times.\n\n\n    [EXAMPLES]\n    \n    assert candidate([12, 14, 11, 13, 10, 15, 12], [2.5, 1.8, 3.2, 2.1, 3.7, 1.5, 2.8]) == -0.9852953638757097\n    assert candidate([12, 13, 14, 15, 16, 17, 18], [2.5, 2.3, 2.1, 1.9, 1.7, 1.5, 1.3]) == -1.0\n\n    [/EXAMPLES]\n    \"\"\"\n```\n", "entry_point": "analyze_cat_behavior", "solution": "import math\nfrom typing import List\n\ndef analyze_cat_behavior(sleeping_hours: List[int], play_times: List[float]) -> float:\n    \"\"\"\n    A cat behaviorist is studying the daily routine of a domestic cat. The researcher wants to understand the relationship between the cat's sleeping patterns and its play activities.\n\n    This function takes two lists as input:\n    - sleeping_hours: A list of integers representing the number of hours the cat slept each day for a week.\n    - play_times: A list of floats representing the amount of time (in hours) the cat spent playing each day for the same week.\n\n    The function should calculate and return the correlation coefficient between sleeping hours and play times.\n\n\n    [EXAMPLES]\n    \n    assert candidate([12, 14, 11, 13, 10, 15, 12], [2.5, 1.8, 3.2, 2.1, 3.7, 1.5, 2.8]) == -0.9852953638757097\n    assert candidate([12, 13, 14, 15, 16, 17, 18], [2.5, 2.3, 2.1, 1.9, 1.7, 1.5, 1.3]) == -1.0\n\n    [/EXAMPLES]\n    \"\"\"\n    def mean(x):\n        return sum(x) / len(x)\n    \n    def std_dev(x):\n        x_mean = mean(x)\n        return math.sqrt(sum((xi - x_mean) ** 2 for xi in x) / len(x))\n\n    n = len(sleeping_hours)\n    if n != len(play_times) or n == 0:\n        raise ValueError(\"Input lists must have the same non-zero length\")\n\n    sleep_mean = mean(sleeping_hours)\n    play_mean = mean(play_times)\n\n    sleep_std = std_dev(sleeping_hours)\n    play_std = std_dev(play_times)\n\n    if sleep_std == 0 or play_std == 0:\n        return 0  # No correlation if there's no variation in one or both variables\n\n    covariance = sum((sleeping_hours[i] - sleep_mean) * (play_times[i] - play_mean) for i in range(n)) / n\n\n    correlation = covariance / (sleep_std * play_std)\n\n    return correlation\n\n", "test": "def check(candidate):\n    assert candidate([12, 14, 11, 13, 10, 15, 12], [2.5, 1.8, 3.2, 2.1, 3.7, 1.5, 2.8]) == -0.9852953638757097\n    assert candidate([8, 16, 8, 16, 8, 16, 8], [3.5, 1.5, 3.5, 1.5, 3.5, 1.5, 3.5]) == -1.0\n    assert candidate([18, 20, 16, 22, 17, 19, 21], [1.2, 0.8, 1.5, 0.5, 1.3, 1.0, 0.7]) == -0.9971764649527379\n    assert candidate([14, 13, 15, 12, 16, 11, 17], [2.0, 2.2, 1.8, 2.4, 1.6, 2.6, 1.4]) == -0.9999999999999999\n    assert candidate([12, 13, 14, 15, 16, 17, 18], [2.5, 2.3, 2.1, 1.9, 1.7, 1.5, 1.3]) == -1.0\n    assert candidate([10, 20, 10, 20, 10, 20, 10], [4.0, 0.5, 4.0, 0.5, 4.0, 0.5, 4.0]) == -1.0\n    assert candidate([13, 13, 13, 13, 13, 13, 13], [2.1, 2.2, 2.3, 2.4, 2.5, 2.6, 2.7]) == 0\n    assert candidate([11, 13, 12, 14, 11, 15, 10], [2.5, 2.0, 2.3, 1.8, 2.7, 1.5, 3.0]) == -0.9894505666960285\n    assert candidate([15, 12, 18, 10, 20, 8, 22], [1.5, 2.5, 1.0, 3.0, 0.5, 3.5, 0.0]) == -0.9974281997711063\n    assert candidate([15, 14, 13, 12, 11, 10, 9], [1.0, 1.2, 1.4, 1.6, 1.8, 2.0, 2.2]) == -1.0\n", "language": "python"}
{"task_id": "379e15ee-1c4d-4633-aaaf-a6375204fb0e-2347558976520102792", "prompt": "As a coding assistant, your role is to finish the given function in a way that it's directly executable in a code block. Don't add code outside the function scope. Only use libraries that appear in the imports section of the problem. If you need to create helper functions or classes, define them within the main function.\n\n```python\ndef binary_search_recursive(arr: list, target: int, low: int, high: int) -> int:\n    \"\"\"\n    Performs a binary search on a sorted list to find the index of a target value.\n\n    This function uses recursion to implement the binary search algorithm.\n    It searches for the target value in the given sorted list and returns\n    its index if found, or -1 if not found.\n\n    Args:\n        arr (list): A sorted list of integers to search in.\n        target (int): The value to search for.\n        low (int): The lower bound of the search range.\n        high (int): The upper bound of the search range.\n\n    Returns:\n        int: The index of the target value if found, or -1 if not found.\n\n\n    [EXAMPLES]\n    \n    assert candidate([1, 2], 3, 0, 1) == -1\n    assert candidate([10, 20, 30, 40, 50], 30, 0, 4) == 2\n\n    [/EXAMPLES]\n    \"\"\"\n```\n", "entry_point": "binary_search_recursive", "solution": "def binary_search_recursive(arr: list, target: int, low: int, high: int) -> int:\n    \"\"\"\n    Performs a binary search on a sorted list to find the index of a target value.\n\n    This function uses recursion to implement the binary search algorithm.\n    It searches for the target value in the given sorted list and returns\n    its index if found, or -1 if not found.\n\n    Args:\n        arr (list): A sorted list of integers to search in.\n        target (int): The value to search for.\n        low (int): The lower bound of the search range.\n        high (int): The upper bound of the search range.\n\n    Returns:\n        int: The index of the target value if found, or -1 if not found.\n\n\n    [EXAMPLES]\n    \n    assert candidate([1, 2], 3, 0, 1) == -1\n    assert candidate([10, 20, 30, 40, 50], 30, 0, 4) == 2\n\n    [/EXAMPLES]\n    \"\"\"\n    # Base case: if the search range is invalid, target is not found\n    if low > high:\n        return -1\n\n    # Calculate the middle index\n    mid = (low + high) // 2\n\n    # If the middle element is the target, return its index\n    if arr[mid] == target:\n        return mid\n    \n    # If the target is less than the middle element, search the left half\n    elif target < arr[mid]:\n        return binary_search_recursive(arr, target, low, mid - 1)\n    \n    # If the target is greater than the middle element, search the right half\n    else:\n        return binary_search_recursive(arr, target, mid + 1, high)\n\n", "test": "def check(candidate):\n    assert candidate([-5, -2, 0, 3, 7], 0, 0, 4) == 2\n    assert candidate([1, 2, 3, 4, 5], 0, 0, 4) == -1\n    assert candidate([-5, -2, 0, 3, 7], -5, 0, 4) == 0\n    assert candidate([-100, -50, 0, 50, 100], 100, 0, 4) == 4\n    assert candidate([10, 20, 30, 40, 50], 30, 0, 4) == 2\n    assert candidate([1, 2, 3, 4, 5], 6, 0, 4) == -1\n    assert candidate([], 1, 0, -1) == -1\n    assert candidate([1, 2], 1, 0, 1) == 0\n    assert candidate([1, 2], 3, 0, 1) == -1\n    assert candidate([1, 2], 2, 0, 1) == 1\n", "language": "python"}
{"task_id": "74e216ac-b613-4fba-be26-659fb4e32083-1796219016597613808", "prompt": "Write a complete implementation for the specified function. Use only the libraries mentioned in the requirements. Your code should be fully executable within the provided function signature without requiring any external definitions. If you need helper functions or classes, define them within the main function.\n\n```python\nfrom collections import defaultdict\n\ndef word_pattern(pattern: str, sentence: str) -> bool:\n    \"\"\"\n    In a cryptography class, students are learning about word patterns. A word pattern is a\n    string of lowercase letters where each letter represents a word. The pattern matches a\n    sentence if there's a bijection between letters in the pattern and words in the sentence.\n\n    This function determines if a given pattern matches a given sentence.\n\n\n    [EXAMPLES]\n    \n    assert candidate(\"a\", \"dog\") == True\n    assert candidate(\"abcde\", \"one two three four five\") == True\n\n    [/EXAMPLES]\n    \"\"\"\n```\n", "entry_point": "word_pattern", "solution": "from collections import defaultdict\n\ndef word_pattern(pattern: str, sentence: str) -> bool:\n    \"\"\"\n    In a cryptography class, students are learning about word patterns. A word pattern is a\n    string of lowercase letters where each letter represents a word. The pattern matches a\n    sentence if there's a bijection between letters in the pattern and words in the sentence.\n\n    This function determines if a given pattern matches a given sentence.\n\n\n    [EXAMPLES]\n    \n    assert candidate(\"a\", \"dog\") == True\n    assert candidate(\"abcde\", \"one two three four five\") == True\n\n    [/EXAMPLES]\n    \"\"\"\n    words = sentence.split()\n    \n    if len(pattern) != len(words):\n        return False\n    \n    letter_to_word = {}\n    word_to_letter = {}\n    \n    for letter, word in zip(pattern, words):\n        if letter in letter_to_word:\n            if letter_to_word[letter] != word:\n                return False\n        else:\n            if word in word_to_letter:\n                return False\n            letter_to_word[letter] = word\n            word_to_letter[word] = letter\n    \n    return True\n\n", "test": "def check(candidate):\n    assert candidate(\"abcde\", \"one two three four five\") == True\n    assert candidate(\"aaaaaa\", \"the the the the the the\") == True\n    assert candidate(\"abba\", \"dog cat cat fish\") == False\n    assert candidate(\"abba\", \"dog cat cat\") == False\n    assert candidate(\"abcabc\", \"dog cat fish dog cat fish\") == True\n    assert candidate(\"a\", \"dog\") == True\n    assert candidate(\"abc\", \"dog cat\") == False\n    assert candidate(\"abba\", \"dog cat cat dog\") == True\n", "language": "python"}
{"task_id": "ed5c8817-d968-4bf2-9514-5a0f6d63b45f-643888148768882642", "prompt": "Let me complete that function for you based on the documentation. The full implementation will be in one code block.\n\n```python\nfrom typing import List, Tuple\n\ndef analyze_stock_trends(prices: List[float], window_size: int) -> List[Tuple[str, float, float]]:\n    \"\"\"\n    A financial analyst needs to identify trends in stock prices over time.\n    This function analyzes a list of daily closing prices and identifies bullish (upward)\n    and bearish (downward) trends over a specified window size.\n\n    Args:\n    prices (List[float]): A list of daily closing prices for a stock.\n    window_size (int): The number of days to consider for each trend analysis.\n\n    Returns:\n    List[Tuple[str, float, float]]: A list of tuples, each containing:\n        - Trend type (\"bullish\" or \"bearish\")\n        - Start price of the trend\n        - End price of the trend\n\n\n    [EXAMPLES]\n    \n    assert candidate([50.0, 49.5, 49.0, 48.5, 48.0], 2) == [('bearish', 50.0, 49.5), ('bearish', 49.5, 49.0), ('bearish', 49.0, 48.5), ('bearish', 48.5, 48.0)]\n    assert candidate([1000, 950, 900, 850, 800, 750], 6) == [('bearish', 1000, 750)]\n\n    [/EXAMPLES]\n    \"\"\"\n```\n", "entry_point": "analyze_stock_trends", "solution": "from typing import List, Tuple\n\ndef analyze_stock_trends(prices: List[float], window_size: int) -> List[Tuple[str, float, float]]:\n    \"\"\"\n    A financial analyst needs to identify trends in stock prices over time.\n    This function analyzes a list of daily closing prices and identifies bullish (upward)\n    and bearish (downward) trends over a specified window size.\n\n    Args:\n    prices (List[float]): A list of daily closing prices for a stock.\n    window_size (int): The number of days to consider for each trend analysis.\n\n    Returns:\n    List[Tuple[str, float, float]]: A list of tuples, each containing:\n        - Trend type (\"bullish\" or \"bearish\")\n        - Start price of the trend\n        - End price of the trend\n\n\n    [EXAMPLES]\n    \n    assert candidate([50.0, 49.5, 49.0, 48.5, 48.0], 2) == [('bearish', 50.0, 49.5), ('bearish', 49.5, 49.0), ('bearish', 49.0, 48.5), ('bearish', 48.5, 48.0)]\n    assert candidate([1000, 950, 900, 850, 800, 750], 6) == [('bearish', 1000, 750)]\n\n    [/EXAMPLES]\n    \"\"\"\n    trends = []\n\n    if len(prices) < window_size:\n        return trends\n\n    for i in range(len(prices) - window_size + 1):\n        window = prices[i:i + window_size]\n        start_price = window[0]\n        end_price = window[-1]\n\n        if end_price > start_price:\n            trend_type = \"bullish\"\n        elif end_price < start_price:\n            trend_type = \"bearish\"\n        else:\n            continue  # Skip if there's no change\n\n        trends.append((trend_type, start_price, end_price))\n\n    return trends\n\n", "test": "def check(candidate):\n    assert candidate([25.5, 25.5, 25.5, 25.5, 25.5], 3) == []\n    assert candidate([200, 205, 210, 215, 220, 225, 230], 7) == [('bullish', 200, 230)]\n    assert candidate([1000, 950, 900, 850, 800, 750], 6) == [('bearish', 1000, 750)]\n    assert candidate([100, 90, 80, 70, 60, 50], 1) == []\n    assert candidate([10, 11, 9, 12, 8, 13, 7], 2) == [('bullish', 10, 11), ('bearish', 11, 9), ('bullish', 9, 12), ('bearish', 12, 8), ('bullish', 8, 13), ('bearish', 13, 7)]\n    assert candidate([1.0, 2.0, 3.0, 2.0, 1.0], 2) == [('bullish', 1.0, 2.0), ('bullish', 2.0, 3.0), ('bearish', 3.0, 2.0), ('bearish', 2.0, 1.0)]\n    assert candidate([1.1, 1.2, 1.3, 1.2, 1.1, 1.0, 0.9], 3) == [('bullish', 1.1, 1.3), ('bearish', 1.3, 1.1), ('bearish', 1.2, 1.0), ('bearish', 1.1, 0.9)]\n    assert candidate([500, 510, 505, 515, 520, 518, 525], 4) == [('bullish', 500, 515), ('bullish', 510, 520), ('bullish', 505, 518), ('bullish', 515, 525)]\n    assert candidate([100.5, 101.2, 100.8, 101.5, 102.0], 1) == []\n    assert candidate([50.0, 49.5, 49.0, 48.5, 48.0], 2) == [('bearish', 50.0, 49.5), ('bearish', 49.5, 49.0), ('bearish', 49.0, 48.5), ('bearish', 48.5, 48.0)]\n", "language": "python"}
{"task_id": "83cc62de-cd3d-4478-b0b2-407ab3754cd5-7339914708636133086", "prompt": "Here's the implementation of the function according to the specified documentation. The complete code will be in one block, with edge cases considered.\n\n```python\ndef language_evolution(words: list, rules: dict, generations: int) -> list:\n    \"\"\"\n    Simulate the evolution of a set of words in a language over multiple generations based on phonetic change rules.\n    This function uses recursion and string manipulation to model language change over time.\n    \n    Parameters:\n    words (list): A list of initial words in the language\n    rules (dict): A dictionary of phonetic change rules, where keys are original sounds and values are new sounds\n    generations (int): The number of generations to simulate\n    \n    Returns:\n    list: A list of evolved words after the specified number of generations\n    \n\n    [EXAMPLES]\n    \n    assert candidate(['cat', 'dog', 'bird'], {'a': 'e', 't': 'd'}, 1) == ['ced', 'dog', 'bird']\n    assert candidate([''], {}, 5) == ['']\n\n    [/EXAMPLES]\n    \"\"\"\n```\n", "entry_point": "language_evolution", "solution": "def language_evolution(words: list, rules: dict, generations: int) -> list:\n    \"\"\"\n    Simulate the evolution of a set of words in a language over multiple generations based on phonetic change rules.\n    This function uses recursion and string manipulation to model language change over time.\n    \n    Parameters:\n    words (list): A list of initial words in the language\n    rules (dict): A dictionary of phonetic change rules, where keys are original sounds and values are new sounds\n    generations (int): The number of generations to simulate\n    \n    Returns:\n    list: A list of evolved words after the specified number of generations\n    \n\n    [EXAMPLES]\n    \n    assert candidate(['cat', 'dog', 'bird'], {'a': 'e', 't': 'd'}, 1) == ['ced', 'dog', 'bird']\n    assert candidate([''], {}, 5) == ['']\n\n    [/EXAMPLES]\n    \"\"\"\n    def apply_rules(word):\n        for old, new in rules.items():\n            word = word.replace(old, new)\n        return word\n    \n    def evolve(current_words, remaining_generations):\n        if remaining_generations == 0:\n            return current_words\n        \n        evolved_words = [apply_rules(word) for word in current_words]\n        return evolve(evolved_words, remaining_generations - 1)\n    \n    return evolve(words, generations)\n\n", "test": "def check(candidate):\n    assert candidate(['ocean', 'river', 'lake'], {'oc': 'ak', 'r': 'l'}, 3) == ['akean', 'livel', 'lake']\n    assert candidate(['python', 'java', 'rust'], {'p': 'b', 'j': 'y', 'r': 'w'}, 2) == ['bython', 'yava', 'wust']\n    assert candidate(['code', 'program', 'algorithm'], {'o': 'u', 'a': 'e'}, 4) == ['cude', 'prugrem', 'elgurithm']\n    assert candidate(['pizza', 'pasta', 'burger'], {'zz': 'ts', 'er': 'ar'}, 2) == ['pitsa', 'pasta', 'burgar']\n    assert candidate(['one', 'two', 'three'], {'on': 'un', 'tw': 'to'}, 4) == ['une', 'too', 'three']\n    assert candidate(['cat', 'dog', 'bird'], {'a': 'e', 't': 'd'}, 1) == ['ced', 'dog', 'bird']\n    assert candidate(['elephant', 'lion', 'tiger'], {'ph': 'f', 'on': 'un'}, 3) == ['elefant', 'liun', 'tiger']\n    assert candidate(['supercalifragilisticexpialidocious'], {'super': 'hyper', 'fragil': 'strong', 'doc': 'teach'}, 1) == ['hypercalistrongisticexpialiteachious']\n    assert candidate([''], {}, 5) == ['']\n    assert candidate(['car', 'bus', 'train'], {'ar': 'or', 'us': 'is'}, 4) == ['cor', 'bis', 'train']\n", "language": "python"}
{"task_id": "be6a34e9-bac6-4f23-afab-93805556ba162163604382833111044", "prompt": "I'll implement the full function according to the documentation string. The solution will be in one complete code block, with careful attention to edge cases.\n\n```python\nfrom typing import List\n\ndef decode_ancient_script(symbols: List[str], codex: dict) -> str:\n    \"\"\"\n    As an archaeologist, you've discovered an ancient script and a partial codex for decoding it.\n    Your task is to decipher the message using the known symbol-to-letter mappings in the codex.\n\n    This function takes a list of symbols representing the encoded message and a dictionary\n    containing the known symbol-to-letter mappings. It returns the decoded message as a string,\n    replacing unknown symbols with underscores.\n\n\n    [EXAMPLES]\n    \n    assert candidate(['\u03b1', '\u03b2', '\u03b3'], {'\u03b1': 'A', '\u03b2': 'B', '\u03b3': 'C'}) == 'ABC'\n    assert candidate(['A', 'B', 'C'], {'A': 'x', 'B': 'y', 'C': 'z'}) == 'xyz'\n\n    [/EXAMPLES]\n    \"\"\"\n```\n", "entry_point": "decode_ancient_script", "solution": "from typing import List\n\ndef decode_ancient_script(symbols: List[str], codex: dict) -> str:\n    \"\"\"\n    As an archaeologist, you've discovered an ancient script and a partial codex for decoding it.\n    Your task is to decipher the message using the known symbol-to-letter mappings in the codex.\n\n    This function takes a list of symbols representing the encoded message and a dictionary\n    containing the known symbol-to-letter mappings. It returns the decoded message as a string,\n    replacing unknown symbols with underscores.\n\n\n    [EXAMPLES]\n    \n    assert candidate(['\u03b1', '\u03b2', '\u03b3'], {'\u03b1': 'A', '\u03b2': 'B', '\u03b3': 'C'}) == 'ABC'\n    assert candidate(['A', 'B', 'C'], {'A': 'x', 'B': 'y', 'C': 'z'}) == 'xyz'\n\n    [/EXAMPLES]\n    \"\"\"\n    decoded_message = []\n    for symbol in symbols:\n        if symbol in codex:\n            decoded_message.append(codex[symbol])\n        else:\n            decoded_message.append('_')\n    \n    return ''.join(decoded_message)\n\n", "test": "def check(candidate):\n    assert candidate(['1', '2', '3', '4', '5'], {'1': 'O', '2': 'N', '3': 'E', '4': 'T', '5': 'W'}) == 'ONETW'\n    assert candidate([' ', '!', '@'], {' ': 'S', '!': 'O', '@': 'S'}) == 'SOS'\n    assert candidate(['@', '#', '$', '^', '&'], {'@': 'W', '#': 'O', '$': 'R', '&': 'D'}) == 'WOR_D'\n    assert candidate(['A', 'B', 'C'], {'A': 'x', 'B': 'y', 'C': 'z'}) == 'xyz'\n    assert candidate([], {}) == ''\n    assert candidate(['@', '@', '@'], {'@': 'A'}) == 'AAA'\n    assert candidate(['\u03b1', '\u03b2', '\u03b3'], {'\u03b1': 'A', '\u03b2': 'B', '\u03b3': 'C'}) == 'ABC'\n    assert candidate(['!', '@', '#', '$', '%'], {'!': 'T', '@': 'E', '#': 'S', '$': 'T', '%': 'S'}) == 'TESTS'\n", "language": "python"}
{"task_id": "9d1b19a6-b404-466e-8dc3-d00d5c7881508934207453653881410", "prompt": "I'll provide the complete code solution in one code block below.\n\n```python\ndef earthquake_impact(buildings: list, magnitude: float) -> int:\n    \"\"\"\n    In urban planning, it's crucial to estimate the potential impact of earthquakes on buildings.\n    Each building has a resistance level, and an earthquake of a certain magnitude will damage\n    buildings with lower resistance.\n\n    This function takes a list of buildings (where each building is represented by its resistance level)\n    and the magnitude of an earthquake. It returns the number of buildings that would be damaged.\n\n\n    [EXAMPLES]\n    \n    assert candidate([5.0, 5.1, 5.2, 5.3, 5.4], 5.25) == 3\n    assert candidate([10.0, 9.0, 8.0, 7.0, 6.0], 8.5) == 3\n\n    [/EXAMPLES]\n    \"\"\"\n```\n", "entry_point": "earthquake_impact", "solution": "def earthquake_impact(buildings: list, magnitude: float) -> int:\n    \"\"\"\n    In urban planning, it's crucial to estimate the potential impact of earthquakes on buildings.\n    Each building has a resistance level, and an earthquake of a certain magnitude will damage\n    buildings with lower resistance.\n\n    This function takes a list of buildings (where each building is represented by its resistance level)\n    and the magnitude of an earthquake. It returns the number of buildings that would be damaged.\n\n\n    [EXAMPLES]\n    \n    assert candidate([5.0, 5.1, 5.2, 5.3, 5.4], 5.25) == 3\n    assert candidate([10.0, 9.0, 8.0, 7.0, 6.0], 8.5) == 3\n\n    [/EXAMPLES]\n    \"\"\"\n    def is_damaged(resistance: float) -> bool:\n        return resistance < magnitude\n\n    return sum(1 for building in buildings if is_damaged(building))\n\n", "test": "def check(candidate):\n    assert candidate([3.0, 3.0, 3.0, 3.0, 3.0], 4.0) == 5\n    assert candidate([1.0, 10.0, 100.0, 1000.0, 10000.0], 100.0) == 2\n    assert candidate([10.0, 9.0, 8.0, 7.0, 6.0], 8.5) == 3\n    assert candidate([9.9, 9.8, 9.7, 9.6, 9.5], 9.7) == 2\n    assert candidate([0.1, 0.2, 0.3, 0.4, 0.5], 0.3) == 2\n    assert candidate([0.1, 0.01, 0.001, 0.0001, 0.00001], 0.001) == 2\n    assert candidate([8.1, 8.2, 8.3, 8.4, 8.5], 8.3) == 2\n    assert candidate([7.0, 6.5, 8.0, 7.5, 6.0], 7.2) == 3\n    assert candidate([5.0, 5.1, 5.2, 5.3, 5.4], 5.25) == 3\n    assert candidate([3.14, 2.71, 1.41, 1.73, 2.24], 2.0) == 2\n", "language": "python"}
{"task_id": "8bea95d4-614e-4a2e-8d90-ae1a4a22ba273111893375300708447", "prompt": "Your job is to fill in the body of the given function so that it's immediately executable. All code must remain within the function scope - don't add any external code. Limit yourself to the libraries that are already imported. Any auxiliary functions or classes should be nested within the main function definition.\n\n```python\nfrom typing import List\nimport functools\n\ndef decode_alien_message(symbols: List[str], key: dict) -> str:\n    \"\"\"\n    A cryptographer has intercepted an alien message consisting of strange symbols.\n    They've also obtained a partial decryption key. The task is to decode the message\n    using the provided key and return the decrypted text.\n\n    This function takes a list of symbols and a decryption key (dictionary mapping symbols to letters).\n    It should use functools.reduce to efficiently process the symbols and return the decoded message.\n\n\n    [EXAMPLES]\n    \n    assert candidate([':', ';', '\"'], {':': 'S', ';': 'M', '\"': 'I'}) == 'SMI'\n    assert candidate(['<', '>', '?'], {'<': 'L', '>': 'O', '?': 'L'}) == 'LOL'\n\n    [/EXAMPLES]\n    \"\"\"\n```\n", "entry_point": "decode_alien_message", "solution": "from typing import List\nimport functools\n\ndef decode_alien_message(symbols: List[str], key: dict) -> str:\n    \"\"\"\n    A cryptographer has intercepted an alien message consisting of strange symbols.\n    They've also obtained a partial decryption key. The task is to decode the message\n    using the provided key and return the decrypted text.\n\n    This function takes a list of symbols and a decryption key (dictionary mapping symbols to letters).\n    It should use functools.reduce to efficiently process the symbols and return the decoded message.\n\n\n    [EXAMPLES]\n    \n    assert candidate([':', ';', '\"'], {':': 'S', ';': 'M', '\"': 'I'}) == 'SMI'\n    assert candidate(['<', '>', '?'], {'<': 'L', '>': 'O', '?': 'L'}) == 'LOL'\n\n    [/EXAMPLES]\n    \"\"\"\n    def decrypt_symbol(decoded_message: str, symbol: str) -> str:\n        return decoded_message + key.get(symbol, symbol)\n    \n    return functools.reduce(decrypt_symbol, symbols, \"\")\n\n", "test": "def check(candidate):\n    assert candidate(['@', '#', '$', '%', '&'], {'@': 'H', '#': 'E', '$': 'L', '%': 'O', '&': '!'}) == 'HELO!'\n    assert candidate(['<', '>', '?'], {'<': 'L', '>': 'O', '?': 'L'}) == 'LOL'\n    assert candidate(['^', '&', '*', '(', ')'], {'^': 'H', '&': 'E', '*': 'L', '(': 'L', ')': 'O'}) == 'HELLO'\n    assert candidate(['1', '2', '3', '4', '5'], {'1': 'A', '2': 'B', '3': 'C', '4': 'D', '5': 'E'}) == 'ABCDE'\n    assert candidate(['~', '`', '|'], {'~': 'C', '`': 'A', '|': 'T'}) == 'CAT'\n    assert candidate(['/', '\\\\', '|'], {'/': 'U', '\\\\': 'F', '|': 'O'}) == 'UFO'\n    assert candidate([':', ';', '\"'], {':': 'S', ';': 'M', '\"': 'I'}) == 'SMI'\n    assert candidate(['[', ']', '{', '}'], {'[': 'C', ']': 'O', '{': 'D', '}': 'E'}) == 'CODE'\n    assert candidate(['.', ',', '?', '!'], {'.': 'W', ',': 'O', '?': 'W', '!': '!'}) == 'WOW!'\n    assert candidate(['Q', 'W', 'E', 'R', 'T', 'Y'], {'Q': 'A', 'W': 'L', 'E': 'I', 'R': 'E', 'T': 'N', 'Y': 'S'}) == 'ALIENS'\n", "language": "python"}
{"task_id": "83cc62de-cd3d-4478-b0b2-407ab3754cd5-7085256971711275779", "prompt": "Provide a complete implementation of the requested function in a self-contained code block. The function should be executable without modification, utilizing only the imported libraries. Any auxiliary functions or classes must be defined within the scope of the given function.\n\n```python\nfrom typing import List\n\ndef analyze_trading_patterns(stock_prices: List[int], window_size: int) -> List[str]:\n    \"\"\"\n    A financial analyst wants to identify trading patterns in a series of stock prices.\n    This function analyzes the stock prices and identifies bullish (increasing) or bearish (decreasing) trends.\n\n    The function takes two parameters:\n    - stock_prices: A list of integers representing daily closing prices of a stock\n    - window_size: An integer representing the number of days to consider for each pattern\n\n    The function should return a list of strings, where each string is either \"BULLISH\", \"BEARISH\", or \"NEUTRAL\",\n    representing the trend for each window of consecutive days.\n\n\n    [EXAMPLES]\n    \n    assert candidate([100], 1) == ['NEUTRAL']\n    assert candidate([105, 104, 103, 102, 101, 100], 3) == ['BEARISH', 'BEARISH', 'BEARISH', 'BEARISH']\n\n    [/EXAMPLES]\n    \"\"\"\n```\n", "entry_point": "analyze_trading_patterns", "solution": "from typing import List\n\ndef analyze_trading_patterns(stock_prices: List[int], window_size: int) -> List[str]:\n    \"\"\"\n    A financial analyst wants to identify trading patterns in a series of stock prices.\n    This function analyzes the stock prices and identifies bullish (increasing) or bearish (decreasing) trends.\n\n    The function takes two parameters:\n    - stock_prices: A list of integers representing daily closing prices of a stock\n    - window_size: An integer representing the number of days to consider for each pattern\n\n    The function should return a list of strings, where each string is either \"BULLISH\", \"BEARISH\", or \"NEUTRAL\",\n    representing the trend for each window of consecutive days.\n\n\n    [EXAMPLES]\n    \n    assert candidate([100], 1) == ['NEUTRAL']\n    assert candidate([105, 104, 103, 102, 101, 100], 3) == ['BEARISH', 'BEARISH', 'BEARISH', 'BEARISH']\n\n    [/EXAMPLES]\n    \"\"\"\n    def analyze_window(window: List[int]) -> str:\n        if window[-1] > window[0]:\n            return \"BULLISH\"\n        elif window[-1] < window[0]:\n            return \"BEARISH\"\n        else:\n            return \"NEUTRAL\"\n\n    patterns = []\n    for i in range(len(stock_prices) - window_size + 1):\n        window = stock_prices[i:i + window_size]\n        patterns.append(analyze_window(window))\n\n    return patterns\n\n", "test": "def check(candidate):\n    assert candidate([100], 1) == ['NEUTRAL']\n    assert candidate([5, 5, 5, 5, 5, 5, 5, 5, 5, 5], 3) == ['NEUTRAL', 'NEUTRAL', 'NEUTRAL', 'NEUTRAL', 'NEUTRAL', 'NEUTRAL', 'NEUTRAL', 'NEUTRAL']\n    assert candidate([10, 20, 30, 20, 10, 20, 30], 3) == ['BULLISH', 'NEUTRAL', 'BEARISH', 'NEUTRAL', 'BULLISH']\n    assert candidate([100, 101, 99, 102, 98, 103, 97], 4) == ['BULLISH', 'BEARISH', 'BULLISH', 'BEARISH']\n    assert candidate([100, 101, 102, 103, 104, 105], 3) == ['BULLISH', 'BULLISH', 'BULLISH', 'BULLISH']\n    assert candidate([1, 2, 3, 4, 5, 6, 7, 8, 9, 10], 2) == ['BULLISH', 'BULLISH', 'BULLISH', 'BULLISH', 'BULLISH', 'BULLISH', 'BULLISH', 'BULLISH', 'BULLISH']\n    assert candidate([1, 2, 3, 4, 5, 4, 3, 2, 1], 4) == ['BULLISH', 'BULLISH', 'BULLISH', 'BEARISH', 'BEARISH', 'BEARISH']\n    assert candidate([100, 200, 300, 200, 100, 200, 300, 200, 100], 3) == ['BULLISH', 'NEUTRAL', 'BEARISH', 'NEUTRAL', 'BULLISH', 'NEUTRAL', 'BEARISH']\n    assert candidate([100, 100, 100, 100, 100], 2) == ['NEUTRAL', 'NEUTRAL', 'NEUTRAL', 'NEUTRAL']\n    assert candidate([105, 104, 103, 102, 101, 100], 3) == ['BEARISH', 'BEARISH', 'BEARISH', 'BEARISH']\n", "language": "python"}
{"task_id": "00810d69-c505-4272-bd97-5dc0b862d5a5-1090429940097445389", "prompt": "I need to provide a complete, self-contained function implementation that can be executed as-is. I'll only use libraries mentioned in the problem description and keep all additional helper functions or classes inside the main function definition.\n\n```python\nfrom typing import List\n\ndef quantum_entanglement(n: int, m: int, state1: List[List[int]], state2: List[List[int]]) -> int:\n    \"\"\"\n    In a quantum computer, two quantum states are represented by matrices. To achieve quantum entanglement,\n    these states must be identical. You can apply quantum operations to modify the states. Each operation\n    can increment all values in a row or column of a matrix by 1. Determine the minimum number of operations\n    needed to make the two quantum states identical, or return -1 if it's impossible.\n\n    :param n: Number of rows in the matrices\n    :param m: Number of columns in the matrices\n    :param state1: The first quantum state matrix\n    :param state2: The second quantum state matrix\n    :return: Minimum number of operations to make states identical, or -1 if impossible\n\n\n    [EXAMPLES]\n    \n    assert candidate(3, 2, [[0,0],[0,0],[0,0]], [[1,1],[1,1],[1,1]]) == 2\n    assert candidate(3, 2, [[1,2],[3,4],[5,6]], [[2,3],[4,5],[6,7]]) == 2\n\n    [/EXAMPLES]\n    \"\"\"\n```\n", "entry_point": "quantum_entanglement", "solution": "from typing import List\n\ndef quantum_entanglement(n: int, m: int, state1: List[List[int]], state2: List[List[int]]) -> int:\n    \"\"\"\n    In a quantum computer, two quantum states are represented by matrices. To achieve quantum entanglement,\n    these states must be identical. You can apply quantum operations to modify the states. Each operation\n    can increment all values in a row or column of a matrix by 1. Determine the minimum number of operations\n    needed to make the two quantum states identical, or return -1 if it's impossible.\n\n    :param n: Number of rows in the matrices\n    :param m: Number of columns in the matrices\n    :param state1: The first quantum state matrix\n    :param state2: The second quantum state matrix\n    :return: Minimum number of operations to make states identical, or -1 if impossible\n\n\n    [EXAMPLES]\n    \n    assert candidate(3, 2, [[0,0],[0,0],[0,0]], [[1,1],[1,1],[1,1]]) == 2\n    assert candidate(3, 2, [[1,2],[3,4],[5,6]], [[2,3],[4,5],[6,7]]) == 2\n\n    [/EXAMPLES]\n    \"\"\"\n    def calculate_differences():\n        return [[state2[i][j] - state1[i][j] for j in range(m)] for i in range(n)]\n\n    differences = calculate_differences()\n    \n    # Check if it's possible to make the states identical\n    if any(len(set(row)) > 1 for row in differences) or \\\n       any(len(set(col)) > 1 for col in zip(*differences)):\n        return -1\n\n    # Count non-zero rows and columns\n    non_zero_rows = sum(1 for row in differences if any(row))\n    non_zero_cols = sum(1 for col in zip(*differences) if any(col))\n\n    # Return the minimum of non-zero rows and columns\n    return min(non_zero_rows, non_zero_cols)\n\n", "test": "def check(candidate):\n    assert candidate(2, 2, [[0,0],[0,0]], [[1,1],[1,1]]) == 2\n    assert candidate(3, 3, [[0,0,0],[0,0,0],[0,0,0]], [[1,1,1],[1,1,1],[1,1,1]]) == 3\n    assert candidate(1, 5, [[1,2,3,4,5]], [[5,4,3,2,1]]) == -1\n    assert candidate(2, 4, [[0,1,2,3],[4,5,6,7]], [[7,6,5,4],[3,2,1,0]]) == -1\n    assert candidate(3, 2, [[1,2],[3,4],[5,6]], [[2,3],[4,5],[6,7]]) == 2\n    assert candidate(2, 3, [[0,0,0],[0,0,0]], [[1,1,1],[1,1,1]]) == 2\n    assert candidate(2, 2, [[100,100],[100,100]], [[0,0],[0,0]]) == 2\n    assert candidate(1, 1, [[1000000]], [[0]]) == 1\n    assert candidate(3, 2, [[0,0],[0,0],[0,0]], [[1,1],[1,1],[1,1]]) == 2\n    assert candidate(2, 2, [[1,1],[1,1]], [[1,1],[1,1]]) == 0\n", "language": "python"}
{"task_id": "16706cb7-e992-4d78-9f56-a0b00c7831bf-3141423069448957337", "prompt": "My role is to help you with coding tasks by completing functions you share. I'll ensure the code I provide works within the function boundaries you've established, using only the libraries that are already imported in your problem. Any additional functions or classes I create will be nested within your main function.\n\n```python\nfrom typing import List\n\ndef find_minimum_platforms(arrival: List[int], departure: List[int]) -> int:\n    \"\"\"\n    A railway station manager needs to determine the minimum number of platforms\n    required for the station so that no train has to wait. Given the arrival and\n    departure times of all trains (in 24-hour format as integers), this function\n    calculates the minimum number of platforms needed.\n\n    The arrival and departure lists are sorted in ascending order.\n\n\n    [EXAMPLES]\n    \n    assert candidate([0, 100, 200, 300, 400], [50, 150, 250, 350, 450]) == 1\n    assert candidate([800, 830, 850, 900, 910], [840, 870, 890, 920, 960]) == 2\n\n    [/EXAMPLES]\n    \"\"\"\n```\n", "entry_point": "find_minimum_platforms", "solution": "from typing import List\n\ndef find_minimum_platforms(arrival: List[int], departure: List[int]) -> int:\n    \"\"\"\n    A railway station manager needs to determine the minimum number of platforms\n    required for the station so that no train has to wait. Given the arrival and\n    departure times of all trains (in 24-hour format as integers), this function\n    calculates the minimum number of platforms needed.\n\n    The arrival and departure lists are sorted in ascending order.\n\n\n    [EXAMPLES]\n    \n    assert candidate([0, 100, 200, 300, 400], [50, 150, 250, 350, 450]) == 1\n    assert candidate([800, 830, 850, 900, 910], [840, 870, 890, 920, 960]) == 2\n\n    [/EXAMPLES]\n    \"\"\"\n    n = len(arrival)\n    events = []\n    \n    # Create a list of events, where each event is a tuple (time, is_arrival)\n    # is_arrival is 1 for arrival and 0 for departure\n    for i in range(n):\n        events.append((arrival[i], 1))\n        events.append((departure[i], 0))\n    \n    # Sort events based on time\n    events.sort(key=lambda x: (x[0], -x[1]))\n    \n    platforms_needed = 0\n    max_platforms = 0\n    \n    for event in events:\n        if event[1] == 1:  # Arrival\n            platforms_needed += 1\n            max_platforms = max(max_platforms, platforms_needed)\n        else:  # Departure\n            platforms_needed -= 1\n    \n    return max_platforms\n\n", "test": "def check(candidate):\n    assert candidate([0, 100, 200, 300, 400], [50, 150, 250, 350, 450]) == 1\n    assert candidate([500, 510, 520, 530, 540], [550, 560, 570, 580, 590]) == 5\n    assert candidate([1, 2, 3, 4, 5], [6, 7, 8, 9, 10]) == 5\n    assert candidate([100, 200, 300, 400, 500], [600, 700, 800, 900, 1000]) == 5\n    assert candidate([0, 100, 200, 300, 400, 500], [50, 150, 250, 350, 450, 550]) == 1\n    assert candidate([100, 200, 300], [101, 201, 301]) == 1\n    assert candidate([800, 830, 850, 900, 910], [840, 870, 890, 920, 960]) == 2\n    assert candidate([100, 100, 100], [200, 200, 200]) == 3\n    assert candidate([1000, 1010, 1020, 1030, 1040, 1050], [1015, 1025, 1035, 1045, 1055, 1100]) == 2\n    assert candidate([1, 2, 3, 4, 5], [10, 9, 8, 7, 6]) == 5\n", "language": "python"}
{"task_id": "326a334b-7050-423a-9ef7-cf5894ffa5a62612006888876291047", "prompt": "Looking at the docstring, implement the entire function in a single code block. Make sure your solution is robust and handles all potential edge cases.\n\n```python\nfrom typing import List\n\ndef calculate_word_score(word: str, letter_values: dict) -> int:\n    \"\"\"\n    In a fantasy word game, each letter has a specific point value. This function calculates the total score for a given word based on these letter values.\n\n    The function takes two parameters:\n    - word: A string representing the word to be scored.\n    - letter_values: A dictionary where keys are letters and values are their corresponding point values.\n\n    Returns the total score for the word.\n\n\n    [EXAMPLES]\n    \n    assert candidate(\"Q\", {'Q': 10}) == 10\n    assert candidate(\"HELLO\", {'H': 4, 'E': 1, 'L': 1, 'O': 1}) == 8\n\n    [/EXAMPLES]\n    \"\"\"\n```\n", "entry_point": "calculate_word_score", "solution": "from typing import List\n\ndef calculate_word_score(word: str, letter_values: dict) -> int:\n    \"\"\"\n    In a fantasy word game, each letter has a specific point value. This function calculates the total score for a given word based on these letter values.\n\n    The function takes two parameters:\n    - word: A string representing the word to be scored.\n    - letter_values: A dictionary where keys are letters and values are their corresponding point values.\n\n    Returns the total score for the word.\n\n\n    [EXAMPLES]\n    \n    assert candidate(\"Q\", {'Q': 10}) == 10\n    assert candidate(\"HELLO\", {'H': 4, 'E': 1, 'L': 1, 'O': 1}) == 8\n\n    [/EXAMPLES]\n    \"\"\"\n    total_score = 0\n    for letter in word.upper():\n        if letter in letter_values:\n            total_score += letter_values[letter]\n    return total_score\n\n", "test": "def check(candidate):\n    assert candidate(\"Q\", {'Q': 10}) == 10\n    assert candidate(\"PYTHON\", {'P': 3, 'Y': 4, 'T': 1, 'H': 4, 'O': 1, 'N': 1}) == 14\n    assert candidate(\"MiXeD\", {'M': 3, 'i': 1, 'X': 8, 'e': 1, 'D': 2}) == 13\n    assert candidate(\"HELLO\", {'H': 4, 'E': 1, 'L': 1, 'O': 1}) == 8\n", "language": "python"}
{"task_id": "a727f0bb-f16b-457a-a477-b50b5a9dc599-98480475300704740", "prompt": "You function as a coding assistant. Your role involves completing functions provided to you, ensuring they are executable within a code block as is. Stick to using only the libraries that are imported in the problem statement. Any additional functions or classes should be defined inside the given function, not outside of it.\n\n```python\nfrom typing import List, Tuple\n\ndef treasure_map(map_grid: List[List[int]]) -> Tuple[int, List[Tuple[int, int]]]:\n    \"\"\"\n    You've discovered an ancient treasure map represented as a grid. Each cell contains a clue value.\n    Your task is to find the path with the highest total clue value, moving only right or down.\n    The function should return the maximum clue value sum and the path taken.\n\n\n    [EXAMPLES]\n    \n    assert candidate([[1, 3, 1], [2, 5, 1], [4, 2, 1]]) == (12, [(0, 0), (0, 1), (1, 1), (2, 1), (2, 2)])\n    assert candidate([[1, 2, 3], [4, 5, 6]]) == (16, [(0, 0), (1, 0), (1, 1), (1, 2)])\n\n    [/EXAMPLES]\n    \"\"\"\n```\n", "entry_point": "treasure_map", "solution": "from typing import List, Tuple\n\ndef treasure_map(map_grid: List[List[int]]) -> Tuple[int, List[Tuple[int, int]]]:\n    \"\"\"\n    You've discovered an ancient treasure map represented as a grid. Each cell contains a clue value.\n    Your task is to find the path with the highest total clue value, moving only right or down.\n    The function should return the maximum clue value sum and the path taken.\n\n\n    [EXAMPLES]\n    \n    assert candidate([[1, 3, 1], [2, 5, 1], [4, 2, 1]]) == (12, [(0, 0), (0, 1), (1, 1), (2, 1), (2, 2)])\n    assert candidate([[1, 2, 3], [4, 5, 6]]) == (16, [(0, 0), (1, 0), (1, 1), (1, 2)])\n\n    [/EXAMPLES]\n    \"\"\"\n    if not map_grid or not map_grid[0]:\n        return (0, [])\n\n    rows, cols = len(map_grid), len(map_grid[0])\n    \n    # Initialize dp grid and path grid\n    dp = [[0] * cols for _ in range(rows)]\n    path = [[None] * cols for _ in range(rows)]\n    \n    # Initialize first cell\n    dp[0][0] = map_grid[0][0]\n    path[0][0] = (0, 0)\n    \n    # Initialize first row\n    for j in range(1, cols):\n        dp[0][j] = dp[0][j-1] + map_grid[0][j]\n        path[0][j] = (0, j-1)\n    \n    # Initialize first column\n    for i in range(1, rows):\n        dp[i][0] = dp[i-1][0] + map_grid[i][0]\n        path[i][0] = (i-1, 0)\n    \n    # Fill dp and path grids\n    for i in range(1, rows):\n        for j in range(1, cols):\n            if dp[i-1][j] > dp[i][j-1]:\n                dp[i][j] = dp[i-1][j] + map_grid[i][j]\n                path[i][j] = (i-1, j)\n            else:\n                dp[i][j] = dp[i][j-1] + map_grid[i][j]\n                path[i][j] = (i, j-1)\n    \n    # Backtrack to find the path\n    max_sum = dp[-1][-1]\n    current = (rows-1, cols-1)\n    result_path = [current]\n    \n    while current != (0, 0):\n        current = path[current[0]][current[1]]\n        result_path.append(current)\n    \n    result_path.reverse()\n    \n    return (max_sum, result_path)\n\n", "test": "def check(candidate):\n    assert candidate([[100, 1, 1], [1, 1, 1], [1, 1, 1]]) == (104, [(0, 0), (1, 0), (2, 0), (2, 1), (2, 2)])\n    assert candidate([[1], [2], [3], [4], [5]]) == (15, [(0, 0), (1, 0), (2, 0), (3, 0), (4, 0)])\n    assert candidate([[1, 1, 1], [1, 1, 1], [1, 1, 100]]) == (104, [(0, 0), (1, 0), (2, 0), (2, 1), (2, 2)])\n    assert candidate([[5, 4, 3], [2, 1, 0]]) == (12, [(0, 0), (0, 1), (0, 2), (1, 2)])\n    assert candidate([[1]]) == (1, [(0, 0)])\n    assert candidate([[1, 3, 1], [2, 5, 1], [4, 2, 1]]) == (12, [(0, 0), (0, 1), (1, 1), (2, 1), (2, 2)])\n    assert candidate([[0] * 10 for _ in range(10)]) == (0, [(0, 0), (1, 0), (2, 0), (3, 0), (4, 0), (5, 0), (6, 0), (7, 0), (8, 0), (9, 0), (9, 1), (9, 2), (9, 3), (9, 4), (9, 5), (9, 6), (9, 7), (9, 8), (9, 9)])\n    assert candidate([[1, 1], [1, 1], [1, 1], [1, 1], [1, 1]]) == (6, [(0, 0), (1, 0), (2, 0), (3, 0), (4, 0), (4, 1)])\n    assert candidate([[0, 0], [0, 0]]) == (0, [(0, 0), (1, 0), (1, 1)])\n    assert candidate([[1, 2, 3], [4, 5, 6]]) == (16, [(0, 0), (1, 0), (1, 1), (1, 2)])\n", "language": "python"}
{"task_id": "9dee401a-dffb-4083-a528-d9236d45b05d7309058040715460506", "prompt": "I'm a coding assistant here to help you complete functions. I'll provide code solutions that are ready to execute directly within the given function boundaries. I won't add any code outside the function scope. I'll work exclusively with libraries that are imported in the problem, and if I need helper functions or classes, I'll define them inside the main function.\n\n```python\ndef calculate_restaurant_bill(orders: dict, tax_rate: float, tip_percentage: float) -> float:\n    \"\"\"\n    Calculate the total bill for a restaurant order including tax and tip.\n\n    This function takes a dictionary of menu items and their quantities, along with\n    the tax rate and tip percentage, and returns the total bill amount.\n\n\n    [EXAMPLES]\n    \n    assert candidate({}, 0.1, 15) == 0.0\n    assert candidate({}, 0.1, 10) == 0.0\n\n    [/EXAMPLES]\n    \"\"\"\n```\n", "entry_point": "calculate_restaurant_bill", "solution": "def calculate_restaurant_bill(orders: dict, tax_rate: float, tip_percentage: float) -> float:\n    \"\"\"\n    Calculate the total bill for a restaurant order including tax and tip.\n\n    This function takes a dictionary of menu items and their quantities, along with\n    the tax rate and tip percentage, and returns the total bill amount.\n\n\n    [EXAMPLES]\n    \n    assert candidate({}, 0.1, 15) == 0.0\n    assert candidate({}, 0.1, 10) == 0.0\n\n    [/EXAMPLES]\n    \"\"\"\n    # Define a dictionary of menu items and their prices\n    menu_prices = {\n        \"burger\": 8.99,\n        \"fries\": 3.99,\n        \"drink\": 1.99,\n        \"pizza\": 12.99,\n        \"salad\": 7.99,\n        \"dessert\": 5.99\n    }\n\n    # Calculate the subtotal\n    subtotal = sum(menu_prices[item] * quantity for item, quantity in orders.items())\n\n    # Calculate the tax amount\n    tax_amount = subtotal * tax_rate\n\n    # Calculate the tip amount\n    tip_amount = subtotal * (tip_percentage / 100)\n\n    # Calculate the total bill\n    total_bill = subtotal + tax_amount + tip_amount\n\n    # Round the total bill to two decimal places\n    return round(total_bill, 2)\n\n", "test": "def check(candidate):\n    assert candidate({\"drink\": 1}, 0, 100) == 3.98\n    assert candidate({}, 0.1, 10) == 0.0\n    assert candidate({}, 0.1, 15) == 0.0\n    assert candidate({\"burger\": 1, \"fries\": 1}, 0.1, 15) == 16.23\n    assert candidate({}, 0.06, 0) == 0.0\n    assert candidate({\"burger\": 10}, 0.15, 25) == 125.86\n    assert candidate({\"pizza\": 10}, 0.08, 20) == 166.27\n    assert candidate({\"pizza\": 2, \"salad\": 1}, 0.08, 20) == 43.48\n    assert candidate({\"salad\": 1}, 0.11, 22) == 10.63\n    assert candidate({\"burger\": 10, \"fries\": 10, \"drink\": 10}, 0.10, 0) == 164.67\n", "language": "python"}
{"task_id": "1720ea85-0b51-45c6-b49e-71a6ba0afdb83686908705248679632", "prompt": "I'll complete the code in a single block, making sure to keep all supplementary functions or classes defined inside the main function rather than outside it.\n\n```python\nfrom typing import List\nfrom collections import deque, defaultdict\nfrom collections import deque\nimport string\n\ndef word_ladder(start: str, end: str, dictionary: List[str]) -> List[str]:\n    \"\"\"\n    Find the shortest transformation sequence from start word to end word.\n\n    This function takes a start word, an end word, and a dictionary of valid words.\n    It returns the shortest sequence of words that transforms the start word into\n    the end word, changing only one letter at a time. Each intermediate word must\n    exist in the given dictionary.\n\n    Args:\n    start (str): The starting word.\n    end (str): The target word to transform into.\n    dictionary (List[str]): A list of valid words that can be used in the transformation.\n\n    Returns:\n    List[str]: The shortest sequence of words from start to end.\n               Returns an empty list if no valid transformation is possible.\n\n\n    [EXAMPLES]\n    \n    assert candidate(\"play\", \"work\", [\"play\", \"pray\", \"bray\", \"brat\", \"boat\", \"boot\", \"book\", \"work\"]) == []\n    assert candidate(\"cat\", \"dog\", [\"cat\", \"cot\", \"cog\", \"dog\"]) == ['cat', 'cot', 'cog', 'dog']\n\n    [/EXAMPLES]\n    \"\"\"\n```\n", "entry_point": "word_ladder", "solution": "from typing import List\nfrom collections import deque, defaultdict\nfrom collections import deque\nimport string\n\ndef word_ladder(start: str, end: str, dictionary: List[str]) -> List[str]:\n    \"\"\"\n    Find the shortest transformation sequence from start word to end word.\n\n    This function takes a start word, an end word, and a dictionary of valid words.\n    It returns the shortest sequence of words that transforms the start word into\n    the end word, changing only one letter at a time. Each intermediate word must\n    exist in the given dictionary.\n\n    Args:\n    start (str): The starting word.\n    end (str): The target word to transform into.\n    dictionary (List[str]): A list of valid words that can be used in the transformation.\n\n    Returns:\n    List[str]: The shortest sequence of words from start to end.\n               Returns an empty list if no valid transformation is possible.\n\n\n    [EXAMPLES]\n    \n    assert candidate(\"play\", \"work\", [\"play\", \"pray\", \"bray\", \"brat\", \"boat\", \"boot\", \"book\", \"work\"]) == []\n    assert candidate(\"cat\", \"dog\", [\"cat\", \"cot\", \"cog\", \"dog\"]) == ['cat', 'cot', 'cog', 'dog']\n\n    [/EXAMPLES]\n    \"\"\"\n    # Add start and end words to the dictionary\n    word_set = set(dictionary + [start, end])\n    \n    # Create a graph of words that differ by one letter\n    graph = defaultdict(list)\n    word_len = len(start)\n    \n    for word in word_set:\n        for i in range(word_len):\n            pattern = word[:i] + '*' + word[i+1:]\n            graph[pattern].append(word)\n    \n    # Perform BFS\n    queue = deque([(start, [start])])\n    visited = set([start])\n    \n    while queue:\n        current_word, path = queue.popleft()\n        \n        if current_word == end:\n            return path\n        \n        for i in range(word_len):\n            pattern = current_word[:i] + '*' + current_word[i+1:]\n            for neighbor in graph[pattern]:\n                if neighbor not in visited:\n                    visited.add(neighbor)\n                    queue.append((neighbor, path + [neighbor]))\n    \n    # If no path is found\n    return []\n\n", "test": "def check(candidate):\n    assert candidate(\"big\", \"small\", [\"big\", \"bag\", \"bug\", \"bum\", \"sum\", \"sam\", \"sam\", \"small\"]) == []\n    assert candidate(\"day\", \"night\", [\"day\", \"hay\", \"hat\", \"hit\", \"hint\", \"hunt\", \"hurt\", \"hurl\", \"hull\", \"null\", \"nult\", \"nigh\", \"night\"]) == []\n    assert candidate(\"hit\", \"cog\", [\"hot\", \"dot\", \"dog\", \"lot\", \"log\", \"cog\"]) == ['hit', 'hot', 'lot', 'log', 'cog']\n    assert candidate(\"happy\", \"angry\", [\"happy\", \"handy\", \"hardy\", \"harpy\", \"harms\", \"harms\", \"arms\", \"army\", \"angry\"]) == []\n    assert candidate(\"a\", \"z\", [\"b\", \"c\", \"d\", \"e\", \"f\", \"g\", \"h\", \"i\", \"j\", \"k\", \"l\", \"m\", \"n\", \"o\", \"p\", \"q\", \"r\", \"s\", \"t\", \"u\", \"v\", \"w\", \"x\", \"y\", \"z\"]) == ['a', 'z']\n    assert candidate(\"cat\", \"dog\", [\"cat\", \"cot\", \"cog\", \"dog\"]) == ['cat', 'cot', 'cog', 'dog']\n    assert candidate(\"love\", \"hate\", [\"love\", \"lose\", \"hose\", \"hote\", \"hate\"]) == ['love', 'lose', 'hose', 'hote', 'hate']\n    assert candidate(\"earth\", \"mars\", [\"earth\", \"earsh\", \"marsh\", \"marse\", \"masse\", \"marse\", \"mars\"]) == ['earth', 'earsh', 'marsh', 'mars']\n    assert candidate(\"play\", \"work\", [\"play\", \"pray\", \"bray\", \"brat\", \"boat\", \"boot\", \"book\", \"work\"]) == []\n    assert candidate(\"abc\", \"def\", [\"abd\", \"abe\", \"abf\", \"aef\", \"bef\", \"def\"]) == ['abc', 'abf', 'aef', 'def']\n", "language": "python"}
{"task_id": "b468df4e-3ce6-4d09-8cc9-f0f5121a16011069989161698694623", "prompt": "Your role is to serve as a coding assistant. Complete the provided function in a way that it's executable directly within a code block. Refrain from adding code outside the function. Only use libraries that are already imported in the problem. If additional functions or classes are needed, define them inside the given function.\n\n```python\nimport re\nfrom typing import List, Tuple\n\ndef analyze_dna_sequences(sequences: List[str]) -> List[Tuple[str, float, List[str]]]:\n    \"\"\"\n    You are a bioinformatician working on a genomics project. Your task is to analyze\n    a set of DNA sequences for their GC content and identify potential regulatory motifs.\n\n    This function takes a list of DNA sequences, calculates the GC content for each sequence,\n    and finds all occurrences of the motif 'TATA' (a common regulatory element) within the sequences.\n\n    Parameters:\n    sequences (List[str]): A list of DNA sequences to analyze\n\n    Returns:\n    List[Tuple[str, float, List[str]]]: A list of tuples, each containing:\n        - The original DNA sequence\n        - Its GC content (as a percentage)\n        - A list of all 'TATA' motif positions in the sequence\n\n\n    [EXAMPLES]\n    \n    assert candidate(['ATCGTATA', 'GCGCTATACG']) == [('ATCGTATA', 25.0, ['4']), ('GCGCTATACG', 60.0, ['4'])]\n    assert candidate(['CCCC']) == [('CCCC', 100.0, [])]\n\n    [/EXAMPLES]\n    \"\"\"\n```\n", "entry_point": "analyze_dna_sequences", "solution": "import re\nfrom typing import List, Tuple\n\ndef analyze_dna_sequences(sequences: List[str]) -> List[Tuple[str, float, List[str]]]:\n    \"\"\"\n    You are a bioinformatician working on a genomics project. Your task is to analyze\n    a set of DNA sequences for their GC content and identify potential regulatory motifs.\n\n    This function takes a list of DNA sequences, calculates the GC content for each sequence,\n    and finds all occurrences of the motif 'TATA' (a common regulatory element) within the sequences.\n\n    Parameters:\n    sequences (List[str]): A list of DNA sequences to analyze\n\n    Returns:\n    List[Tuple[str, float, List[str]]]: A list of tuples, each containing:\n        - The original DNA sequence\n        - Its GC content (as a percentage)\n        - A list of all 'TATA' motif positions in the sequence\n\n\n    [EXAMPLES]\n    \n    assert candidate(['ATCGTATA', 'GCGCTATACG']) == [('ATCGTATA', 25.0, ['4']), ('GCGCTATACG', 60.0, ['4'])]\n    assert candidate(['CCCC']) == [('CCCC', 100.0, [])]\n\n    [/EXAMPLES]\n    \"\"\"\n    def calculate_gc_content(seq: str) -> float:\n        gc_count = seq.count('G') + seq.count('C')\n        return round(gc_count / len(seq) * 100, 2)\n\n    def find_tata_motifs(seq: str) -> List[str]:\n        return [str(match.start()) for match in re.finditer('TATA', seq)]\n\n    results = []\n    for seq in sequences:\n        gc_content = calculate_gc_content(seq)\n        tata_positions = find_tata_motifs(seq)\n        results.append((seq, gc_content, tata_positions))\n\n    return results\n\n", "test": "def check(candidate):\n    assert candidate(['ATCGTATA', 'GCGCTATACG']) == [('ATCGTATA', 25.0, ['4']), ('GCGCTATACG', 60.0, ['4'])]\n    assert candidate(['CGCGCGCGCGCGCGCG']) == [('CGCGCGCGCGCGCGCG', 100.0, [])]\n    assert candidate(['AAAA']) == [('AAAA', 0.0, [])]\n    assert candidate(['A' * 1000, 'C' * 1000, 'G' * 1000, 'T' * 1000]) == [('AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA', 0.0, []), ('CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC', 100.0, []), ('GGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGG', 100.0, []), ('TTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTT', 0.0, [])]\n    assert candidate(['CCCC']) == [('CCCC', 100.0, [])]\n    assert candidate(['TATATATA']) == [('TATATATA', 0.0, ['0', '4'])]\n    assert candidate(['ATATATATCGCGCGCG']) == [('ATATATATCGCGCGCG', 50.0, ['1'])]\n    assert candidate(['ATCG']) == [('ATCG', 50.0, [])]\n    assert candidate(['AAATTTCCC', 'TATATATAGG']) == [('AAATTTCCC', 33.33, []), ('TATATATAGG', 20.0, ['0', '4'])]\n    assert candidate(['TATA' * 10]) == [('TATATATATATATATATATATATATATATATATATATATA', 0.0, ['0', '4', '8', '12', '16', '20', '24', '28', '32', '36'])]\n", "language": "python"}
{"task_id": "34e0bb93-2bd2-49a0-a2dc-8c4188e806558554027175166870598", "prompt": "Finish the function implementation based on the documentation provided. Retain the same function name and parameter list. Present the complete function as a single code block.\n\n```python\nfrom typing import List\n\ndef terrain_water_trap(heights: List[int]) -> int:\n    \"\"\"\n    In a 2D terrain modeling system, elevation data is represented as a list of integers.\n    Each integer represents the height of a 1-unit wide section of land. When it rains,\n    water can get trapped between higher sections of land.\n\n    This function calculates the total amount of water that can be trapped in the terrain\n    after a rainstorm. It takes a list of integers representing land heights and returns\n    the total units of water trapped.\n\n\n    [EXAMPLES]\n    \n    assert candidate([10, 0, 10]) == 10\n    assert candidate([0, 1, 0, 2, 1, 0, 1, 3, 2, 1, 2, 1]) == 6\n\n    [/EXAMPLES]\n    \"\"\"\n```\n", "entry_point": "terrain_water_trap", "solution": "from typing import List\n\ndef terrain_water_trap(heights: List[int]) -> int:\n    \"\"\"\n    In a 2D terrain modeling system, elevation data is represented as a list of integers.\n    Each integer represents the height of a 1-unit wide section of land. When it rains,\n    water can get trapped between higher sections of land.\n\n    This function calculates the total amount of water that can be trapped in the terrain\n    after a rainstorm. It takes a list of integers representing land heights and returns\n    the total units of water trapped.\n\n\n    [EXAMPLES]\n    \n    assert candidate([10, 0, 10]) == 10\n    assert candidate([0, 1, 0, 2, 1, 0, 1, 3, 2, 1, 2, 1]) == 6\n\n    [/EXAMPLES]\n    \"\"\"\n    if not heights:\n        return 0\n\n    n = len(heights)\n    left_max = [0] * n\n    right_max = [0] * n\n    \n    # Calculate maximum height to the left of each element\n    left_max[0] = heights[0]\n    for i in range(1, n):\n        left_max[i] = max(left_max[i-1], heights[i])\n    \n    # Calculate maximum height to the right of each element\n    right_max[n-1] = heights[n-1]\n    for i in range(n-2, -1, -1):\n        right_max[i] = max(right_max[i+1], heights[i])\n    \n    # Calculate trapped water\n    total_water = 0\n    for i in range(n):\n        water_level = min(left_max[i], right_max[i])\n        if water_level > heights[i]:\n            total_water += water_level - heights[i]\n    \n    return total_water\n\n", "test": "def check(candidate):\n    assert candidate([1, 0, 1, 0, 1, 0, 1]) == 3\n    assert candidate([5, 5, 5, 5]) == 0\n    assert candidate([0, 1, 2, 3, 4, 5, 6, 7, 8, 9]) == 0\n    assert candidate([0, 1, 0, 2, 1, 0, 1, 3, 2, 1, 2, 1]) == 6\n    assert candidate([10, 0, 10]) == 10\n    assert candidate([0, 0, 0, 0]) == 0\n    assert candidate([1, 2, 3, 2, 1]) == 0\n    assert candidate([9, 8, 7, 6, 5, 4, 3, 2, 1, 0]) == 0\n    assert candidate([4, 2, 0, 3, 2, 5]) == 9\n    assert candidate([]) == 0\n", "language": "python"}
{"task_id": "f891f2ff-8282-4a2d-85ee-32ef07d50f643041909496925039864", "prompt": "I'll complete the code within one comprehensive code block.\n\n```python\nfrom typing import Dict\nimport re\n\ndef analyze_text_sentiment(text: str) -> Dict[str, int]:\n    \"\"\"\n    Analyze the sentiment of a given text by counting positive and negative words.\n\n    This function takes a string of text, splits it into words, and counts the\n    occurrences of positive and negative words based on predefined lists. It \n    uses regular expressions for word splitting and dictionary comprehension\n    for counting.\n\n    Args:\n    text (str): The input text to analyze.\n\n    Returns:\n    Dict[str, int]: A dictionary containing counts of positive and negative words.\n\n\n    [EXAMPLES]\n    \n    assert candidate(\"LovE Is AmAzInG bUt HaTe Is TeRrIbLe\") == {'positive': 2, 'negative': 2}\n    assert candidate(\"\") == {'positive': 0, 'negative': 0}\n\n    [/EXAMPLES]\n    \"\"\"\n```\n", "entry_point": "analyze_text_sentiment", "solution": "from typing import Dict\nimport re\n\ndef analyze_text_sentiment(text: str) -> Dict[str, int]:\n    \"\"\"\n    Analyze the sentiment of a given text by counting positive and negative words.\n\n    This function takes a string of text, splits it into words, and counts the\n    occurrences of positive and negative words based on predefined lists. It \n    uses regular expressions for word splitting and dictionary comprehension\n    for counting.\n\n    Args:\n    text (str): The input text to analyze.\n\n    Returns:\n    Dict[str, int]: A dictionary containing counts of positive and negative words.\n\n\n    [EXAMPLES]\n    \n    assert candidate(\"LovE Is AmAzInG bUt HaTe Is TeRrIbLe\") == {'positive': 2, 'negative': 2}\n    assert candidate(\"\") == {'positive': 0, 'negative': 0}\n\n    [/EXAMPLES]\n    \"\"\"\n    \n    # Predefined lists of positive and negative words\n    positive_words = [\n        \"good\", \"great\", \"excellent\", \"wonderful\", \"amazing\", \"fantastic\",\n        \"terrific\", \"outstanding\", \"superb\", \"lovely\", \"delightful\", \"love\"\n    ]\n    \n    negative_words = [\n        \"bad\", \"terrible\", \"awful\", \"horrible\", \"disappointing\", \"poor\",\n        \"unpleasant\", \"dreadful\", \"lousy\", \"hate\", \"dislike\", \"unfortunate\"\n    ]\n    \n    # Convert text to lowercase and split into words\n    words = re.findall(r'\\b\\w+\\b', text.lower())\n    \n    # Count occurrences of positive and negative words\n    sentiment_counts = {\n        'positive': sum(1 for word in words if word in positive_words),\n        'negative': sum(1 for word in words if word in negative_words)\n    }\n    \n    return sentiment_counts\n\n", "test": "def check(candidate):\n    assert candidate(\"This is terrible. I hate it. So disappointing.\") == {'positive': 0, 'negative': 3}\n    assert candidate(\"LovE Is AmAzInG bUt HaTe Is TeRrIbLe\") == {'positive': 2, 'negative': 2}\n    assert candidate(\"Awful. Horrible. Terrible. Disgusting. Dreadful.\") == {'positive': 0, 'negative': 4}\n    assert candidate(\"!@#$%^&*()\") == {'positive': 0, 'negative': 0}\n    assert candidate(\"I like it, but it could be better.\") == {'positive': 0, 'negative': 0}\n    assert candidate(\"Fantastic! Amazing! Disappointing. Horrible.\") == {'positive': 2, 'negative': 2}\n    assert candidate(\"Not bad, but not great either.\") == {'positive': 1, 'negative': 1}\n    assert candidate(\"Very very very very very good!\") == {'positive': 1, 'negative': 0}\n    assert candidate(\"This sentence has no real sentiment words.\") == {'positive': 0, 'negative': 0}\n    assert candidate(\"\") == {'positive': 0, 'negative': 0}\n", "language": "python"}
{"task_id": "56330b1c-bef1-44bd-8af3-665ded11676c4908406511058762949", "prompt": "I'll complete the given function with executable code that can run as is. My solution will be contained in a single code block, using only the imported libraries specified in the problem. Any auxiliary functions or classes will be defined within the main function. I'll provide just the code implementation without additional commentary.\n\n```python\nfrom typing import List\n\ndef earthquake_risk(magnitudes: List[float], locations: List[tuple]) -> List[str]:\n    \"\"\"\n    As a seismologist, you're analyzing earthquake data to determine risk levels for different areas.\n    This function takes a list of earthquake magnitudes and their corresponding locations (as latitude-longitude tuples),\n    and returns a list of risk assessments for each location.\n\n    The risk levels are determined as follows:\n    - \"High Risk\" for magnitudes >= 7.0\n    - \"Medium Risk\" for magnitudes >= 5.0 and < 7.0\n    - \"Low Risk\" for magnitudes < 5.0\n\n\n    [EXAMPLES]\n    \n    assert candidate([3.5, 4.9, 5.0, 6.9, 7.0, 8.1], [(10.0, 20.0), (20.0, 30.0), (30.0, 40.0), (40.0, 50.0), (50.0, 60.0), (60.0, 70.0)]) == ['Low Risk', 'Low Risk', 'Medium Risk', 'Medium Risk', 'High Risk', 'High Risk']\n    assert candidate([5.5, 5.5, 5.5], [(0.0, 0.0), (1.0, 1.0), (2.0, 2.0)]) == ['Medium Risk', 'Medium Risk', 'Medium Risk']\n\n    [/EXAMPLES]\n    \"\"\"\n```\n", "entry_point": "earthquake_risk", "solution": "from typing import List\n\ndef earthquake_risk(magnitudes: List[float], locations: List[tuple]) -> List[str]:\n    \"\"\"\n    As a seismologist, you're analyzing earthquake data to determine risk levels for different areas.\n    This function takes a list of earthquake magnitudes and their corresponding locations (as latitude-longitude tuples),\n    and returns a list of risk assessments for each location.\n\n    The risk levels are determined as follows:\n    - \"High Risk\" for magnitudes >= 7.0\n    - \"Medium Risk\" for magnitudes >= 5.0 and < 7.0\n    - \"Low Risk\" for magnitudes < 5.0\n\n\n    [EXAMPLES]\n    \n    assert candidate([3.5, 4.9, 5.0, 6.9, 7.0, 8.1], [(10.0, 20.0), (20.0, 30.0), (30.0, 40.0), (40.0, 50.0), (50.0, 60.0), (60.0, 70.0)]) == ['Low Risk', 'Low Risk', 'Medium Risk', 'Medium Risk', 'High Risk', 'High Risk']\n    assert candidate([5.5, 5.5, 5.5], [(0.0, 0.0), (1.0, 1.0), (2.0, 2.0)]) == ['Medium Risk', 'Medium Risk', 'Medium Risk']\n\n    [/EXAMPLES]\n    \"\"\"\n    def assess_risk(magnitude: float) -> str:\n        if magnitude >= 7.0:\n            return \"High Risk\"\n        elif magnitude >= 5.0:\n            return \"Medium Risk\"\n        else:\n            return \"Low Risk\"\n\n    risk_assessments = []\n    for magnitude in magnitudes:\n        risk_assessments.append(assess_risk(magnitude))\n\n    return risk_assessments\n\n", "test": "def check(candidate):\n    assert candidate([0.1, 9.9], [(90.0, 180.0), (-90.0, -180.0)]) == ['Low Risk', 'High Risk']\n    assert candidate([5.0, 6.0, 7.0], [(90.0, 180.0), (0.0, 0.0), (-90.0, -180.0)]) == ['Medium Risk', 'Medium Risk', 'High Risk']\n    assert candidate([3.5, 4.9, 5.0, 6.9, 7.0, 8.1], [(10.0, 20.0), (20.0, 30.0), (30.0, 40.0), (40.0, 50.0), (50.0, 60.0), (60.0, 70.0)]) == ['Low Risk', 'Low Risk', 'Medium Risk', 'Medium Risk', 'High Risk', 'High Risk']\n    assert candidate([4.99, 5.0, 6.99, 7.0], [(1.0, 1.0), (2.0, 2.0), (3.0, 3.0), (4.0, 4.0)]) == ['Low Risk', 'Medium Risk', 'Medium Risk', 'High Risk']\n    assert candidate([4.9, 4.9, 4.9, 4.9, 4.9], [(i, i) for i in range(5)]) == ['Low Risk', 'Low Risk', 'Low Risk', 'Low Risk', 'Low Risk']\n    assert candidate([], []) == []\n    assert candidate([1.0, 2.0, 3.0, 4.0, 5.0, 6.0, 7.0, 8.0], [(i, i) for i in range(8)]) == ['Low Risk', 'Low Risk', 'Low Risk', 'Low Risk', 'Medium Risk', 'Medium Risk', 'High Risk', 'High Risk']\n    assert candidate([7.5], [(0.0, 0.0)]) == ['High Risk']\n    assert candidate([7.0, 7.0, 7.0, 7.0], [(0.0, 0.0), (1.0, 1.0), (2.0, 2.0), (3.0, 3.0)]) == ['High Risk', 'High Risk', 'High Risk', 'High Risk']\n    assert candidate([5.5, 5.5, 5.5], [(0.0, 0.0), (1.0, 1.0), (2.0, 2.0)]) == ['Medium Risk', 'Medium Risk', 'Medium Risk']\n", "language": "python"}
{"task_id": "25fb44b1-1156-41b6-8d7e-c04ccf1e4905-6352676023120285398", "prompt": "Following the docstring instructions, complete the function implementation. Present the entire function in one code block without modifying the function name or parameters.\n\n```python\nfrom typing import List\n\ndef calculate_delivery_route(addresses: List[str], start_point: str) -> List[str]:\n    \"\"\"\n    A food delivery service needs to optimize their delivery routes. This function takes a list of\n    delivery addresses and a starting point, and returns the optimal route for the delivery person to take.\n\n    The function should return a list of addresses in the order they should be visited, starting and ending\n    with the start_point. The route should minimize the total distance traveled.\n\n    Note: For simplicity, assume that the \"distance\" between addresses is determined by their order in the input list.\n\n\n    [EXAMPLES]\n    \n    assert candidate([\"Red\", \"Orange\", \"Yellow\", \"Green\", \"Blue\", \"Indigo\", \"Violet\"], \"White\") == ['White', 'Red', 'Orange', 'Yellow', 'Green', 'Blue', 'Indigo', 'Violet', 'White']\n    assert candidate([\"Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"], \"Sun\") == ['Sun', 'Mercury', 'Venus', 'Earth', 'Mars', 'Jupiter', 'Saturn', 'Uranus', 'Neptune', 'Sun']\n\n    [/EXAMPLES]\n    \"\"\"\n```\n", "entry_point": "calculate_delivery_route", "solution": "from typing import List\n\ndef calculate_delivery_route(addresses: List[str], start_point: str) -> List[str]:\n    \"\"\"\n    A food delivery service needs to optimize their delivery routes. This function takes a list of\n    delivery addresses and a starting point, and returns the optimal route for the delivery person to take.\n\n    The function should return a list of addresses in the order they should be visited, starting and ending\n    with the start_point. The route should minimize the total distance traveled.\n\n    Note: For simplicity, assume that the \"distance\" between addresses is determined by their order in the input list.\n\n\n    [EXAMPLES]\n    \n    assert candidate([\"Red\", \"Orange\", \"Yellow\", \"Green\", \"Blue\", \"Indigo\", \"Violet\"], \"White\") == ['White', 'Red', 'Orange', 'Yellow', 'Green', 'Blue', 'Indigo', 'Violet', 'White']\n    assert candidate([\"Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"], \"Sun\") == ['Sun', 'Mercury', 'Venus', 'Earth', 'Mars', 'Jupiter', 'Saturn', 'Uranus', 'Neptune', 'Sun']\n\n    [/EXAMPLES]\n    \"\"\"\n    # Create the optimal route by starting with the start_point\n    optimal_route = [start_point]\n    \n    # Add all addresses in the order they appear in the input list\n    optimal_route.extend(addresses)\n    \n    # Add the start_point again at the end to complete the route\n    optimal_route.append(start_point)\n    \n    return optimal_route\n\n", "test": "def check(candidate):\n    assert candidate([\"Genesis\", \"Exodus\", \"Leviticus\", \"Numbers\", \"Deuteronomy\"], \"Prologue\") == ['Prologue', 'Genesis', 'Exodus', 'Leviticus', 'Numbers', 'Deuteronomy', 'Prologue']\n    assert candidate([\"Breakfast\", \"Lunch\", \"Dinner\"], \"Midnight Snack\") == ['Midnight Snack', 'Breakfast', 'Lunch', 'Dinner', 'Midnight Snack']\n    assert candidate([\"Apple St\", \"Banana Ave\", \"Cherry Blvd\"], \"Fruit Central\") == ['Fruit Central', 'Apple St', 'Banana Ave', 'Cherry Blvd', 'Fruit Central']\n    assert candidate([\"North Pole\", \"South Pole\"], \"Equator\") == ['Equator', 'North Pole', 'South Pole', 'Equator']\n    assert candidate([\"Infancy\", \"Childhood\", \"Adolescence\", \"Adulthood\", \"Senior\"], \"Birth\") == ['Birth', 'Infancy', 'Childhood', 'Adolescence', 'Adulthood', 'Senior', 'Birth']\n    assert candidate([\"Do\", \"Re\", \"Mi\", \"Fa\", \"So\", \"La\", \"Ti\"], \"Start\") == ['Start', 'Do', 'Re', 'Mi', 'Fa', 'So', 'La', 'Ti', 'Start']\n    assert candidate([\"Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"], \"Sun\") == ['Sun', 'Mercury', 'Venus', 'Earth', 'Mars', 'Jupiter', 'Saturn', 'Uranus', 'Neptune', 'Sun']\n    assert candidate([\"123 Main St\", \"456 Elm St\", \"789 Oak St\"], \"100 Center St\") == ['100 Center St', '123 Main St', '456 Elm St', '789 Oak St', '100 Center St']\n    assert candidate([\"1st Floor\", \"2nd Floor\", \"3rd Floor\", \"4th Floor\", \"5th Floor\"], \"Ground Floor\") == ['Ground Floor', '1st Floor', '2nd Floor', '3rd Floor', '4th Floor', '5th Floor', 'Ground Floor']\n    assert candidate([\"Red\", \"Orange\", \"Yellow\", \"Green\", \"Blue\", \"Indigo\", \"Violet\"], \"White\") == ['White', 'Red', 'Orange', 'Yellow', 'Green', 'Blue', 'Indigo', 'Violet', 'White']\n", "language": "python"}
{"task_id": "126a0cb1-7fab-4134-93d7-8571e744d318450834369888448758", "prompt": "Write the complete function implementation that fulfills the requirements in the docstring. Provide your solution as a single code block and ensure you've addressed all edge cases.\n\n```python\nfrom typing import List, Tuple\nfrom collections import defaultdict\nimport heapq\n\ndef optimize_delivery_route(n: int, roads: List[Tuple[int, int, int]]) -> int:\n    \"\"\"\n    A delivery company wants to optimize their route in a city with 'n' intersections.\n    The roads in the city are represented by a list of tuples, where each tuple\n    (a, b, c) represents a road from intersection 'a' to intersection 'b' with a\n    traffic congestion level of 'c'.\n    \n    The company wants to find the route from intersection 1 to intersection 'n'\n    that minimizes the maximum congestion level encountered on any single road.\n    \n    Return the minimum possible maximum congestion level for the optimal route.\n    If no route exists, return -1.\n\n\n    [EXAMPLES]\n    \n    assert candidate(5, [(1, 2, 1), (2, 3, 2), (3, 4, 3), (4, 5, 4)]) == 4\n    assert candidate(2, [(1, 2, 10)]) == 10\n\n    [/EXAMPLES]\n    \"\"\"\n```\n", "entry_point": "optimize_delivery_route", "solution": "from typing import List, Tuple\nfrom collections import defaultdict\nimport heapq\n\ndef optimize_delivery_route(n: int, roads: List[Tuple[int, int, int]]) -> int:\n    \"\"\"\n    A delivery company wants to optimize their route in a city with 'n' intersections.\n    The roads in the city are represented by a list of tuples, where each tuple\n    (a, b, c) represents a road from intersection 'a' to intersection 'b' with a\n    traffic congestion level of 'c'.\n    \n    The company wants to find the route from intersection 1 to intersection 'n'\n    that minimizes the maximum congestion level encountered on any single road.\n    \n    Return the minimum possible maximum congestion level for the optimal route.\n    If no route exists, return -1.\n\n\n    [EXAMPLES]\n    \n    assert candidate(5, [(1, 2, 1), (2, 3, 2), (3, 4, 3), (4, 5, 4)]) == 4\n    assert candidate(2, [(1, 2, 10)]) == 10\n\n    [/EXAMPLES]\n    \"\"\"\n    def build_graph(roads):\n        graph = {i: [] for i in range(1, n + 1)}\n        for a, b, c in roads:\n            graph[a].append((b, c))\n            graph[b].append((a, c))  # Assuming roads are bidirectional\n        return graph\n\n    graph = build_graph(roads)\n    \n    # Priority queue to store (max_congestion, node) pairs\n    pq = [(0, 1)]  # Start from intersection 1 with 0 initial congestion\n    visited = set()\n\n    while pq:\n        max_congestion, node = heapq.heappop(pq)\n        \n        if node == n:\n            return max_congestion\n        \n        if node in visited:\n            continue\n        \n        visited.add(node)\n        \n        for neighbor, congestion in graph[node]:\n            if neighbor not in visited:\n                new_max_congestion = max(max_congestion, congestion)\n                heapq.heappush(pq, (new_max_congestion, neighbor))\n    \n    return -1  # No route exists\n\n\n", "test": "def check(candidate):\n    assert candidate(2, []) == -1\n    assert candidate(3, [(1, 2, 100), (2, 3, 100)]) == 100\n    assert candidate(4, [(1, 2, 3), (2, 3, 2), (1, 3, 5), (3, 4, 1)]) == 3\n    assert candidate(5, [(1, 2, 1), (2, 3, 2), (3, 4, 3), (4, 5, 4)]) == 4\n    assert candidate(1, []) == 0\n    assert candidate(2, [(1, 2, 10)]) == 10\n    assert candidate(5, [(1, 2, 1), (2, 3, 2), (3, 4, 3), (4, 5, 4), (1, 5, 5)]) == 4\n    assert candidate(4, [(1, 2, 5), (2, 3, 5), (3, 4, 5)]) == 5\n    assert candidate(4, [(1, 2, 1), (2, 3, 1), (3, 4, 1), (1, 3, 2), (2, 4, 2)]) == 1\n    assert candidate(4, [(1, 2, 1), (2, 3, 1), (3, 4, 1), (1, 4, 2)]) == 1\n", "language": "python"}
{"task_id": "04a45b0e-0b4c-4f5a-96e6-c66d1217cb14-1753105438569397419", "prompt": "Please develop the body of the provided function to make it executable within one code block. Restrict yourself to using only the imported libraries. If you need additional functionality, define helper functions or classes inside the given function.\n\n```python\nfrom typing import List, Tuple\n\ndef network_latency(nodes: int, connections: List[Tuple[int, int, int]]) -> float:\n    \"\"\"\n    Calculate the average network latency in a computer network.\n\n    In a distributed computing system, we need to analyze the network latency between\n    connected nodes. This function helps in determining the average latency across all\n    direct connections in the network.\n\n    Parameters:\n    - nodes: The total number of nodes in the network (numbered from 0 to nodes-1)\n    - connections: A list of tuples, where each tuple (a, b, l) represents a connection\n                   from node 'a' to node 'b' with a latency of 'l' milliseconds\n\n    Returns:\n    The average latency across all connections as a float.\n\n\n    [EXAMPLES]\n    \n    assert candidate(6, [(0, 1, 5), (1, 2, 5), (2, 3, 5), (3, 4, 5), (4, 5, 5), (5, 0, 5)]) == 5.0\n    assert candidate(1, []) == 0.0\n\n    [/EXAMPLES]\n    \"\"\"\n```\n", "entry_point": "network_latency", "solution": "from typing import List, Tuple\n\ndef network_latency(nodes: int, connections: List[Tuple[int, int, int]]) -> float:\n    \"\"\"\n    Calculate the average network latency in a computer network.\n\n    In a distributed computing system, we need to analyze the network latency between\n    connected nodes. This function helps in determining the average latency across all\n    direct connections in the network.\n\n    Parameters:\n    - nodes: The total number of nodes in the network (numbered from 0 to nodes-1)\n    - connections: A list of tuples, where each tuple (a, b, l) represents a connection\n                   from node 'a' to node 'b' with a latency of 'l' milliseconds\n\n    Returns:\n    The average latency across all connections as a float.\n\n\n    [EXAMPLES]\n    \n    assert candidate(6, [(0, 1, 5), (1, 2, 5), (2, 3, 5), (3, 4, 5), (4, 5, 5), (5, 0, 5)]) == 5.0\n    assert candidate(1, []) == 0.0\n\n    [/EXAMPLES]\n    \"\"\"\n    if not connections:\n        return 0.0\n\n    total_latency = sum(latency for _, _, latency in connections)\n    total_connections = len(connections)\n    \n    return total_latency / total_connections\n\n", "test": "def check(candidate):\n    assert candidate(3, [(0, 1, 10), (1, 2, 20), (2, 0, 30), (0, 2, 40), (2, 1, 50), (1, 0, 60)]) == 35.0\n    assert candidate(5, [(0, 1, 5), (1, 2, 10), (2, 3, 15), (3, 4, 20), (4, 0, 25)]) == 15.0\n    assert candidate(3, [(0, 1, 5), (1, 2, 15), (2, 0, 10)]) == 10.0\n    assert candidate(2, [(0, 1, 10), (1, 0, 20)]) == 15.0\n    assert candidate(6, [(0, 1, 5), (1, 2, 5), (2, 3, 5), (3, 4, 5), (4, 5, 5), (5, 0, 5)]) == 5.0\n    assert candidate(3, [(0, 1, 100), (1, 2, 200)]) == 150.0\n    assert candidate(1, []) == 0.0\n    assert candidate(3, [(0, 1, 1), (1, 0, 2), (1, 2, 3), (2, 1, 4)]) == 2.5\n    assert candidate(5, [(0, 1, 10), (1, 2, 10), (2, 3, 10), (3, 4, 10), (4, 0, 10)]) == 10.0\n    assert candidate(4, [(0, 1, 10), (1, 2, 20), (2, 3, 30), (3, 0, 40)]) == 25.0\n", "language": "python"}
{"task_id": "ba22c62a-7f50-47d1-98f3-d973215f8537-3896663771539725500", "prompt": "I serve as a coding assistant that completes functions to be immediately executable. My solutions will stay within the provided function block, using only the libraries already imported. Any additional functions or classes will be defined inside the main function scope.\n\n```python\nfrom typing import List\n\ndef simulate_ecosystem(initial_populations: List[int], years: int) -> List[List[int]]:\n    \"\"\"\n    In a virtual wildlife reserve, we want to simulate the population dynamics of\n    different species over time. This function models the complex interactions\n    between predators and prey, as well as environmental factors.\n\n    The function takes an initial population count for each species in the ecosystem\n    and the number of years to simulate. It returns a list of population counts for\n    each species at the end of each year.\n\n    This simulation uses both recursion (to model generational changes) and\n    dynamic programming (to optimize calculations of population interactions).\n\n\n    [EXAMPLES]\n    \n    assert candidate([200, 75, 400], 6) == [[200, 75, 400], [232, 69, 384], [271, 64, 369], [318, 60, 355], [375, 57, 342], [444, 55, 330], [527, 53, 319]]\n    assert candidate([1, 1000000, 1], 3) == [[1, 1000000, 1], [0, 900000, 0], [0, 810000, 0], [0, 729000, 0]]\n\n    [/EXAMPLES]\n    \"\"\"\n```\n", "entry_point": "simulate_ecosystem", "solution": "from typing import List\n\ndef simulate_ecosystem(initial_populations: List[int], years: int) -> List[List[int]]:\n    \"\"\"\n    In a virtual wildlife reserve, we want to simulate the population dynamics of\n    different species over time. This function models the complex interactions\n    between predators and prey, as well as environmental factors.\n\n    The function takes an initial population count for each species in the ecosystem\n    and the number of years to simulate. It returns a list of population counts for\n    each species at the end of each year.\n\n    This simulation uses both recursion (to model generational changes) and\n    dynamic programming (to optimize calculations of population interactions).\n\n\n    [EXAMPLES]\n    \n    assert candidate([200, 75, 400], 6) == [[200, 75, 400], [232, 69, 384], [271, 64, 369], [318, 60, 355], [375, 57, 342], [444, 55, 330], [527, 53, 319]]\n    assert candidate([1, 1000000, 1], 3) == [[1, 1000000, 1], [0, 900000, 0], [0, 810000, 0], [0, 729000, 0]]\n\n    [/EXAMPLES]\n    \"\"\"\n    \n    def calculate_next_generation(populations: List[int]) -> List[int]:\n        \"\"\"\n        Calculates the next generation's population based on current populations.\n        \"\"\"\n        prey, predator, plant = populations\n        \n        # Prey population dynamics\n        new_prey = int(prey * 1.2 - predator * 0.1)\n        new_prey = max(0, new_prey)  # Ensure population doesn't go negative\n        \n        # Predator population dynamics\n        new_predator = int(predator * 0.9 + prey * 0.01)\n        new_predator = max(0, new_predator)\n        \n        # Plant population dynamics\n        new_plant = int(plant * 0.9 + plant * 0.1 * (1 - plant / 1000))  # Logistic growth\n        new_plant = max(0, new_plant)\n        \n        return [new_prey, new_predator, new_plant]\n    \n    def simulate_years(populations: List[int], remaining_years: int, memo: dict) -> List[List[int]]:\n        \"\"\"\n        Recursively simulates the ecosystem for the given number of years.\n        Uses memoization to optimize repeated calculations.\n        \"\"\"\n        if remaining_years == 0:\n            return [populations]\n        \n        # Check if this state has been calculated before\n        state = (tuple(populations), remaining_years)\n        if state in memo:\n            return memo[state]\n        \n        next_gen = calculate_next_generation(populations)\n        result = [populations] + simulate_years(next_gen, remaining_years - 1, memo)\n        \n        # Memoize the result\n        memo[state] = result\n        return result\n    \n    # Initialize memoization dictionary\n    memo = {}\n    \n    # Start the simulation\n    return simulate_years(initial_populations, years, memo)\n\n", "test": "def check(candidate):\n    assert candidate([1000, 500, 2000], 10) == [[1000, 500, 2000], [1150, 460, 1600], [1334, 425, 1344], [1558, 395, 1163], [1830, 371, 1027], [2158, 352, 921], [2554, 338, 836], [3030, 329, 766], [3603, 326, 707], [4290, 329, 657], [5115, 339, 613]]\n    assert candidate([1, 1, 1], 9) == [[1, 1, 1], [1, 0, 0], [1, 0, 0], [1, 0, 0], [1, 0, 0], [1, 0, 0], [1, 0, 0], [1, 0, 0], [1, 0, 0], [1, 0, 0]]\n    assert candidate([1, 2, 3], 10) == [[1, 2, 3], [1, 1, 2], [1, 0, 1], [1, 0, 0], [1, 0, 0], [1, 0, 0], [1, 0, 0], [1, 0, 0], [1, 0, 0], [1, 0, 0], [1, 0, 0]]\n    assert candidate([1000, 0, 2000], 4) == [[1000, 0, 2000], [1200, 10, 1600], [1439, 21, 1344], [1724, 33, 1163], [2065, 46, 1027]]\n    assert candidate([999, 999, 999], 3) == [[999, 999, 999], [1098, 909, 899], [1226, 829, 818], [1388, 758, 751]]\n    assert candidate([500, 100, 1000], 3) == [[500, 100, 1000], [590, 95, 900], [698, 91, 819], [828, 88, 751]]\n    assert candidate([1, 1000000, 1], 3) == [[1, 1000000, 1], [0, 900000, 0], [0, 810000, 0], [0, 729000, 0]]\n    assert candidate([200, 75, 400], 6) == [[200, 75, 400], [232, 69, 384], [271, 64, 369], [318, 60, 355], [375, 57, 342], [444, 55, 330], [527, 53, 319]]\n    assert candidate([50, 25, 100], 4) == [[50, 25, 100], [57, 23, 99], [66, 21, 98], [77, 19, 97], [90, 17, 96]]\n", "language": "python"}
{"task_id": "cc7b20df-2b1f-4215-8848-a4fa73f0b280-634111685821321850", "prompt": "You need to implement a function that can be executed directly without modifications. Do not include any code outside the function. Use only the libraries that are already imported in the problem statement. If you need additional functions or classes, define them inside the given function. Provide your solution in a single code block.\n\n```python\nfrom typing import List, Tuple\nfrom collections import defaultdict\n\ndef calculate_tournament_standings(results: List[Tuple[str, str, str]]) -> List[Tuple[str, int, int, int]]:\n    \"\"\"\n    A chess tournament organizer needs to calculate the final standings based on match results.\n    Each match result is represented as a tuple containing (player1, player2, outcome).\n    The outcome is either \"win\", \"loss\", or \"draw\" from player1's perspective.\n    Calculate the total points and number of wins for each player, then return the standings.\n    Points are awarded as follows: win = 1 point, draw = 0.5 points, loss = 0 points.\n    The standings should be sorted by total points (descending), then by number of wins (descending).\n\n\n    [EXAMPLES]\n    \n    assert candidate([(\"Player\", \"Opponent\", \"win\")] * 10) == [('Player', 10, 10, 0), ('Opponent', 0, 0, 10)]\n    assert candidate([(\"Alice\", \"Bob\", \"loss\")]) == [('Bob', 1, 1, 0), ('Alice', 0, 0, 1)]\n\n    [/EXAMPLES]\n    \"\"\"\n```\n", "entry_point": "calculate_tournament_standings", "solution": "from typing import List, Tuple\nfrom collections import defaultdict\n\ndef calculate_tournament_standings(results: List[Tuple[str, str, str]]) -> List[Tuple[str, int, int, int]]:\n    \"\"\"\n    A chess tournament organizer needs to calculate the final standings based on match results.\n    Each match result is represented as a tuple containing (player1, player2, outcome).\n    The outcome is either \"win\", \"loss\", or \"draw\" from player1's perspective.\n    Calculate the total points and number of wins for each player, then return the standings.\n    Points are awarded as follows: win = 1 point, draw = 0.5 points, loss = 0 points.\n    The standings should be sorted by total points (descending), then by number of wins (descending).\n\n\n    [EXAMPLES]\n    \n    assert candidate([(\"Player\", \"Opponent\", \"win\")] * 10) == [('Player', 10, 10, 0), ('Opponent', 0, 0, 10)]\n    assert candidate([(\"Alice\", \"Bob\", \"loss\")]) == [('Bob', 1, 1, 0), ('Alice', 0, 0, 1)]\n\n    [/EXAMPLES]\n    \"\"\"\n    player_stats = defaultdict(lambda: [0, 0, 0])  # [total_points, wins, losses]\n\n    for player1, player2, outcome in results:\n        if outcome == \"win\":\n            player_stats[player1][0] += 1\n            player_stats[player1][1] += 1\n            player_stats[player2][0] += 0\n            player_stats[player2][2] += 1\n        elif outcome == \"loss\":\n            player_stats[player1][0] += 0\n            player_stats[player1][2] += 1\n            player_stats[player2][0] += 1\n            player_stats[player2][1] += 1\n        else:  # draw\n            player_stats[player1][0] += 0.5\n            player_stats[player2][0] += 0.5\n\n    # Convert defaultdict to list of tuples and sort\n    standings = [(player, stats[0], stats[1], stats[2]) for player, stats in player_stats.items()]\n    standings.sort(key=lambda x: (-x[1], -x[2]))\n\n    return standings\n\n", "test": "def check(candidate):\n    assert candidate([(\"A\", \"B\", \"win\"), (\"B\", \"C\", \"win\"), (\"C\", \"D\", \"win\"), (\"D\", \"E\", \"win\"), (\"E\", \"A\", \"win\")]) == [('A', 1, 1, 1), ('B', 1, 1, 1), ('C', 1, 1, 1), ('D', 1, 1, 1), ('E', 1, 1, 1)]\n    assert candidate([(\"X\", \"Y\", \"win\"), (\"Y\", \"Z\", \"win\"), (\"Z\", \"W\", \"win\"), (\"W\", \"V\", \"win\"), (\"V\", \"U\", \"win\"), (\"U\", \"T\", \"win\"), (\"T\", \"X\", \"win\")]) == [('X', 1, 1, 1), ('Y', 1, 1, 1), ('Z', 1, 1, 1), ('W', 1, 1, 1), ('V', 1, 1, 1), ('U', 1, 1, 1), ('T', 1, 1, 1)]\n    assert candidate([(\"A\", \"B\", \"win\"), (\"B\", \"C\", \"win\"), (\"C\", \"D\", \"win\"), (\"D\", \"E\", \"win\"), (\"E\", \"F\", \"win\"), (\"F\", \"G\", \"win\"), (\"G\", \"H\", \"win\"), (\"H\", \"A\", \"win\")]) == [('A', 1, 1, 1), ('B', 1, 1, 1), ('C', 1, 1, 1), ('D', 1, 1, 1), ('E', 1, 1, 1), ('F', 1, 1, 1), ('G', 1, 1, 1), ('H', 1, 1, 1)]\n    assert candidate([(\"Alice\", \"Bob\", \"win\"), (\"Alice\", \"Charlie\", \"win\"), (\"Alice\", \"David\", \"win\")]) == [('Alice', 3, 3, 0), ('Bob', 0, 0, 1), ('Charlie', 0, 0, 1), ('David', 0, 0, 1)]\n    assert candidate([(\"Alice\", \"Bob\", \"win\"), (\"Bob\", \"Charlie\", \"win\"), (\"Charlie\", \"David\", \"win\"), (\"David\", \"Eve\", \"win\"), (\"Eve\", \"Frank\", \"win\"), (\"Frank\", \"Alice\", \"win\")]) == [('Alice', 1, 1, 1), ('Bob', 1, 1, 1), ('Charlie', 1, 1, 1), ('David', 1, 1, 1), ('Eve', 1, 1, 1), ('Frank', 1, 1, 1)]\n    assert candidate([(\"Alice\", \"Bob\", \"win\"), (\"Bob\", \"Charlie\", \"win\"), (\"Charlie\", \"Alice\", \"win\")]) == [('Alice', 1, 1, 1), ('Bob', 1, 1, 1), ('Charlie', 1, 1, 1)]\n    assert candidate([(\"A\", \"B\", \"loss\"), (\"A\", \"C\", \"loss\"), (\"A\", \"D\", \"loss\"), (\"A\", \"E\", \"loss\")]) == [('B', 1, 1, 0), ('C', 1, 1, 0), ('D', 1, 1, 0), ('E', 1, 1, 0), ('A', 0, 0, 4)]\n    assert candidate([(\"Player\", \"Opponent\", \"win\")] * 10) == [('Player', 10, 10, 0), ('Opponent', 0, 0, 10)]\n    assert candidate([(\"X\", \"Y\", \"win\"), (\"Y\", \"Z\", \"win\"), (\"Z\", \"X\", \"win\")]) == [('X', 1, 1, 1), ('Y', 1, 1, 1), ('Z', 1, 1, 1)]\n    assert candidate([(\"Alice\", \"Bob\", \"loss\")]) == [('Bob', 1, 1, 0), ('Alice', 0, 0, 1)]\n", "language": "python"}
{"task_id": "99f8865b-5037-40fd-a36b-906122fadb18-1821870820152492036", "prompt": "You are a coding assistant. Your role is to complete provided functions so they are ready to be executed. The completed function should be enclosed in a code block. Please refrain from providing code outside the function. Use only the libraries that are imported in the problem statement. If you need to define additional functions or classes, make sure they are defined within the given function.\n\n```python\nfrom typing import List\nimport math\n\ndef asteroid_collision(asteroids: List[int]) -> List[int]:\n    \"\"\"\n    In a distant galaxy, asteroids are hurtling through space. Each asteroid is represented by an integer,\n    where the absolute value represents its size and the sign represents its direction (positive moving right,\n    negative moving left). When two asteroids collide, the smaller one will explode. If both are the same size,\n    both will explode. Two asteroids moving in the same direction will never meet.\n\n    This function simulates the asteroid collisions and returns the state of the asteroids after all collisions.\n\n    Args:\n    asteroids (List[int]): A list of integers representing the asteroids.\n\n    Returns:\n    List[int]: The state of the asteroids after all collisions.\n\n\n    [EXAMPLES]\n    \n    assert candidate([-1, 1, -1, 1]) == [-1, 1]\n    assert candidate([8, -8]) == []\n\n    [/EXAMPLES]\n    \"\"\"\n```\n", "entry_point": "asteroid_collision", "solution": "from typing import List\nimport math\n\ndef asteroid_collision(asteroids: List[int]) -> List[int]:\n    \"\"\"\n    In a distant galaxy, asteroids are hurtling through space. Each asteroid is represented by an integer,\n    where the absolute value represents its size and the sign represents its direction (positive moving right,\n    negative moving left). When two asteroids collide, the smaller one will explode. If both are the same size,\n    both will explode. Two asteroids moving in the same direction will never meet.\n\n    This function simulates the asteroid collisions and returns the state of the asteroids after all collisions.\n\n    Args:\n    asteroids (List[int]): A list of integers representing the asteroids.\n\n    Returns:\n    List[int]: The state of the asteroids after all collisions.\n\n\n    [EXAMPLES]\n    \n    assert candidate([-1, 1, -1, 1]) == [-1, 1]\n    assert candidate([8, -8]) == []\n\n    [/EXAMPLES]\n    \"\"\"\n    stack = []\n\n    for asteroid in asteroids:\n        while stack and asteroid < 0 < stack[-1]:\n            if stack[-1] < -asteroid:\n                stack.pop()\n                continue\n            elif stack[-1] == -asteroid:\n                stack.pop()\n            break\n        else:\n            stack.append(asteroid)\n\n    return stack\n\n", "test": "def check(candidate):\n    assert candidate([-5, -4, -3, -2, -1]) == [-5, -4, -3, -2, -1]\n    assert candidate([1]) == [1]\n    assert candidate([8, -8]) == []\n    assert candidate([]) == []\n    assert candidate([-1]) == [-1]\n    assert candidate([-100, 1, 2, 3, -100]) == [-100, -100]\n    assert candidate([10, -5, 5, -10]) == []\n    assert candidate([-1, 1, -1, 1]) == [-1, 1]\n", "language": "python"}
{"task_id": "b31eb8aa-603e-4fed-a570-e62147dc9ace-7385038241334483332", "prompt": "Please complete the function implementation based on the provided documentation. Keep the function signature intact, including the name and parameters. Return the code in a single code block.\n\n```python\nfrom typing import List\n\ndef cosmic_sequence(seed: int, length: int) -> List[int]:\n    \"\"\"\n    In a distant galaxy, astronomers have discovered a peculiar sequence of numbers\n    that seems to govern the formation of star clusters. Each number in this sequence\n    is derived from the previous one using a cosmic algorithm:\n    If the number is even, divide it by 2.\n    If it's odd, multiply it by 3 and add 1.\n\n    This function generates the cosmic sequence starting from a given 'seed' number\n    and continues for 'length' iterations.\n\n\n    [EXAMPLES]\n    \n    assert candidate(2147483647, 10) == [2147483647, 6442450942, 3221225471, 9663676414, 4831838207, 14495514622, 7247757311, 21743271934, 10871635967, 32614907902]\n    assert candidate(1000, 30) == [1000, 500, 250, 125, 376, 188, 94, 47, 142, 71, 214, 107, 322, 161, 484, 242, 121, 364, 182, 91, 274, 137, 412, 206, 103, 310, 155, 466, 233, 700]\n\n    [/EXAMPLES]\n    \"\"\"\n```\n", "entry_point": "cosmic_sequence", "solution": "from typing import List\n\ndef cosmic_sequence(seed: int, length: int) -> List[int]:\n    \"\"\"\n    In a distant galaxy, astronomers have discovered a peculiar sequence of numbers\n    that seems to govern the formation of star clusters. Each number in this sequence\n    is derived from the previous one using a cosmic algorithm:\n    If the number is even, divide it by 2.\n    If it's odd, multiply it by 3 and add 1.\n\n    This function generates the cosmic sequence starting from a given 'seed' number\n    and continues for 'length' iterations.\n\n\n    [EXAMPLES]\n    \n    assert candidate(2147483647, 10) == [2147483647, 6442450942, 3221225471, 9663676414, 4831838207, 14495514622, 7247757311, 21743271934, 10871635967, 32614907902]\n    assert candidate(1000, 30) == [1000, 500, 250, 125, 376, 188, 94, 47, 142, 71, 214, 107, 322, 161, 484, 242, 121, 364, 182, 91, 274, 137, 412, 206, 103, 310, 155, 466, 233, 700]\n\n    [/EXAMPLES]\n    \"\"\"\n    sequence = [seed]\n    current = seed\n\n    for _ in range(length - 1):  # -1 because we already have the seed\n        if current % 2 == 0:  # If even\n            current = current // 2\n        else:  # If odd\n            current = current * 3 + 1\n        sequence.append(current)\n\n    return sequence\n\n", "test": "def check(candidate):\n    assert candidate(5, 20) == [5, 16, 8, 4, 2, 1, 4, 2, 1, 4, 2, 1, 4, 2, 1, 4, 2, 1, 4, 2]\n    assert candidate(-10, 8) == [-10, -5, -14, -7, -20, -10, -5, -14]\n    assert candidate(2, 10) == [2, 1, 4, 2, 1, 4, 2, 1, 4, 2]\n    assert candidate(-1, 5) == [-1, -2, -1, -2, -1]\n    assert candidate(100, 15) == [100, 50, 25, 76, 38, 19, 58, 29, 88, 44, 22, 11, 34, 17, 52]\n    assert candidate(1000, 30) == [1000, 500, 250, 125, 376, 188, 94, 47, 142, 71, 214, 107, 322, 161, 484, 242, 121, 364, 182, 91, 274, 137, 412, 206, 103, 310, 155, 466, 233, 700]\n    assert candidate(1, 1) == [1]\n    assert candidate(15, 8) == [15, 46, 23, 70, 35, 106, 53, 160]\n    assert candidate(10, 12) == [10, 5, 16, 8, 4, 2, 1, 4, 2, 1, 4, 2]\n    assert candidate(2147483647, 10) == [2147483647, 6442450942, 3221225471, 9663676414, 4831838207, 14495514622, 7247757311, 21743271934, 10871635967, 32614907902]\n", "language": "python"}
{"task_id": "2c555cce-1956-40ec-8f45-4fad40cf4a66-6058061561033721486", "prompt": "Following the documentation, I'll implement the rest of the function. The complete code will be in one block, with careful consideration of edge cases.\n\n```python\nfrom typing import List\n\ndef longest_arithmetic_subsequence(nums: List[int]) -> int:\n    \"\"\"As a data analyst, you've encountered an interesting problem in a time series dataset.\n    You need to find the length of the longest arithmetic subsequence within a given list of numbers.\n\n    An arithmetic subsequence is a sequence that has a common difference between every two consecutive elements.\n    The subsequence must contain at least two elements.\n\n    Write a function that takes a list of integers and returns the length of the longest arithmetic subsequence.\n\n\n    [EXAMPLES]\n    \n    assert candidate([]) == 0\n    assert candidate([100, 90, 80, 70, 60, 50]) == 6\n\n    [/EXAMPLES]\n    \"\"\"\n```\n", "entry_point": "longest_arithmetic_subsequence", "solution": "from typing import List\n\ndef longest_arithmetic_subsequence(nums: List[int]) -> int:\n    \"\"\"As a data analyst, you've encountered an interesting problem in a time series dataset.\n    You need to find the length of the longest arithmetic subsequence within a given list of numbers.\n\n    An arithmetic subsequence is a sequence that has a common difference between every two consecutive elements.\n    The subsequence must contain at least two elements.\n\n    Write a function that takes a list of integers and returns the length of the longest arithmetic subsequence.\n\n\n    [EXAMPLES]\n    \n    assert candidate([]) == 0\n    assert candidate([100, 90, 80, 70, 60, 50]) == 6\n\n    [/EXAMPLES]\n    \"\"\"\n    n = len(nums)\n    if n <= 2:\n        return n\n\n    # dp[i][d] represents the length of arithmetic subsequence ending at index i with difference d\n    dp = [{} for _ in range(n)]\n    max_length = 2\n\n    for i in range(1, n):\n        for j in range(i):\n            diff = nums[i] - nums[j]\n            if diff in dp[j]:\n                dp[i][diff] = dp[j][diff] + 1\n            else:\n                dp[i][diff] = 2\n            max_length = max(max_length, dp[i][diff])\n\n    return max_length\n\n", "test": "def check(candidate):\n    assert candidate([0, 0, 1, 1, 2, 2, 3, 3]) == 4\n    assert candidate([1, 3, 5, 7, 2, 4, 6, 8]) == 4\n    assert candidate([2, 4, 6, 8, 10, 12, 14, 16, 18, 20]) == 10\n    assert candidate([100, 90, 80, 70, 60, 50]) == 6\n    assert candidate([1, 2, 3, 5, 8, 13, 21]) == 3\n    assert candidate([3, 6, 9, 12]) == 4\n    assert candidate([1, 1, 1, 1, 1, 1]) == 6\n    assert candidate([10, 8, 6, 4, 2, 0, -2, -4]) == 8\n    assert candidate([0]) == 1\n    assert candidate([]) == 0\n", "language": "python"}
{"task_id": "a727f0bb-f16b-457a-a477-b50b5a9dc599-6825828662649401624", "prompt": "Could you please complete this function following the requirements in the docstring? Please provide the full implementation in one cohesive code block.\n\n```python\nfrom typing import List\n\ndef optimize_factory_layout(machines: List[int]) -> int:\n    \"\"\"\n    An industrial engineer is tasked with optimizing the layout of machines in a factory.\n    The machines are arranged in a circular formation, and each machine has a productivity\n    score. The engineer can perform any number of rotations on the entire arrangement,\n    where a single rotation moves the last machine to the front.\n\n    The goal is to maximize the sum of the products of each machine's productivity score\n    and its new position (1-indexed) after the rotations.\n\n    This function takes a list of integers representing the productivity scores of the\n    machines in their initial arrangement and returns the maximum sum achievable through\n    any number of rotations.\n\n\n    [EXAMPLES]\n    \n    assert candidate([10]) == 10\n    assert candidate([1, 1, 1, 1, 1, 1000000]) == 6000015\n\n    [/EXAMPLES]\n    \"\"\"\n```\n", "entry_point": "optimize_factory_layout", "solution": "from typing import List\n\ndef optimize_factory_layout(machines: List[int]) -> int:\n    \"\"\"\n    An industrial engineer is tasked with optimizing the layout of machines in a factory.\n    The machines are arranged in a circular formation, and each machine has a productivity\n    score. The engineer can perform any number of rotations on the entire arrangement,\n    where a single rotation moves the last machine to the front.\n\n    The goal is to maximize the sum of the products of each machine's productivity score\n    and its new position (1-indexed) after the rotations.\n\n    This function takes a list of integers representing the productivity scores of the\n    machines in their initial arrangement and returns the maximum sum achievable through\n    any number of rotations.\n\n\n    [EXAMPLES]\n    \n    assert candidate([10]) == 10\n    assert candidate([1, 1, 1, 1, 1, 1000000]) == 6000015\n\n    [/EXAMPLES]\n    \"\"\"\n    n = len(machines)\n    \n    # Calculate the initial sum of products\n    initial_sum = sum(score * (i + 1) for i, score in enumerate(machines))\n    \n    # Calculate the sum of all productivity scores\n    total_score = sum(machines)\n    \n    # Initialize the maximum sum with the initial sum\n    max_sum = initial_sum\n    \n    # Iterate through all possible rotations\n    current_sum = initial_sum\n    for i in range(1, n):\n        # Calculate the change in sum after one rotation\n        current_sum = current_sum - total_score + n * machines[i - 1]\n        \n        # Update the maximum sum if necessary\n        max_sum = max(max_sum, current_sum)\n    \n    return max_sum\n\n", "test": "def check(candidate):\n    assert candidate([10]) == 10\n    assert candidate([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15]) == 1240\n    assert candidate([1000000, 1, 1, 1, 1, 1]) == 6000015\n    assert candidate([1, 1, 1, 1, 1, 1000000]) == 6000015\n    assert candidate([1, 1, 1, 1, 100]) == 510\n    assert candidate([1, 2, 3]) == 14\n    assert candidate([2, 1]) == 5\n    assert candidate([5, 4, 3, 2, 1]) == 50\n", "language": "python"}
{"task_id": "5eb37f9e-a401-4a3f-a8d5-7419aeb382e56265217282355735574", "prompt": "Acting as a coding assistant, you'll complete provided functions in code blocks to ensure they're executable as is. Restrict your code to within the function only. Utilize exclusively the libraries imported in the problem statement. Place any helper functions or classes inside the main function definition.\n\n```python\nfrom typing import List, Dict\nfrom typing import List, Dict, Tuple\n\ndef analyze_dna_sequences(sequences: List[str], motif: str) -> Dict[str, Tuple[float, List[int]]]:\n    \"\"\"As a bioinformatician, you're tasked with analyzing a set of DNA sequences for a specific motif.\n    Given a list of DNA sequences and a motif, calculate the GC content and find all starting positions\n    of the motif in each sequence.\n\n    The GC content is the percentage of guanine (G) and cytosine (C) bases in the DNA sequence.\n    Return a dictionary where the keys are the DNA sequences and the values are tuples containing\n    the GC content (as a percentage rounded to two decimal places) and a list of starting positions\n    of the motif in the sequence (0-indexed).\n\n\n    [EXAMPLES]\n    \n    assert candidate([\"AAAAA\", \"CCCCC\", \"GGGGG\", \"TTTTT\"], \"AA\") == {'AAAAA': (0.0, [0, 1, 2, 3]), 'CCCCC': (100.0, []), 'GGGGG': (100.0, []), 'TTTTT': (0.0, [])}\n    assert candidate([\"ACGTACGTACGTACGT\", \"TGCATGCATGCATGCA\"], \"ACGTACGT\") == {'ACGTACGTACGTACGT': (50.0, [0, 4, 8]), 'TGCATGCATGCATGCA': (50.0, [])}\n\n    [/EXAMPLES]\n    \"\"\"\n```\n", "entry_point": "analyze_dna_sequences", "solution": "from typing import List, Dict\nfrom typing import List, Dict, Tuple\n\ndef analyze_dna_sequences(sequences: List[str], motif: str) -> Dict[str, Tuple[float, List[int]]]:\n    \"\"\"As a bioinformatician, you're tasked with analyzing a set of DNA sequences for a specific motif.\n    Given a list of DNA sequences and a motif, calculate the GC content and find all starting positions\n    of the motif in each sequence.\n\n    The GC content is the percentage of guanine (G) and cytosine (C) bases in the DNA sequence.\n    Return a dictionary where the keys are the DNA sequences and the values are tuples containing\n    the GC content (as a percentage rounded to two decimal places) and a list of starting positions\n    of the motif in the sequence (0-indexed).\n\n\n    [EXAMPLES]\n    \n    assert candidate([\"AAAAA\", \"CCCCC\", \"GGGGG\", \"TTTTT\"], \"AA\") == {'AAAAA': (0.0, [0, 1, 2, 3]), 'CCCCC': (100.0, []), 'GGGGG': (100.0, []), 'TTTTT': (0.0, [])}\n    assert candidate([\"ACGTACGTACGTACGT\", \"TGCATGCATGCATGCA\"], \"ACGTACGT\") == {'ACGTACGTACGTACGT': (50.0, [0, 4, 8]), 'TGCATGCATGCATGCA': (50.0, [])}\n\n    [/EXAMPLES]\n    \"\"\"\n    def calculate_gc_content(sequence: str) -> float:\n        gc_count = sequence.count('G') + sequence.count('C')\n        return round((gc_count / len(sequence)) * 100, 2)\n    \n    def find_motif_positions(sequence: str, motif: str) -> List[int]:\n        positions = []\n        start = 0\n        while True:\n            pos = sequence.find(motif, start)\n            if pos == -1:\n                break\n            positions.append(pos)\n            start = pos + 1\n        return positions\n    \n    result = {}\n    for sequence in sequences:\n        gc_content = calculate_gc_content(sequence)\n        motif_positions = find_motif_positions(sequence, motif)\n        result[sequence] = (gc_content, motif_positions)\n    \n    return result\n\n", "test": "def check(candidate):\n    assert candidate([\"ACGT\" * 10, \"TGCA\" * 10], \"ACGT\") == {'ACGTACGTACGTACGTACGTACGTACGTACGTACGTACGT': (50.0, [0, 4, 8, 12, 16, 20, 24, 28, 32, 36]), 'TGCATGCATGCATGCATGCATGCATGCATGCATGCATGCA': (50.0, [])}\n    assert candidate([\"ATCG\", \"GCTA\", \"AAAA\"], \"AT\") == {'ATCG': (50.0, [0]), 'GCTA': (50.0, []), 'AAAA': (0.0, [])}\n    assert candidate([\"ATCGATCG\", \"GCTAGCTAGCT\", \"AAATTTCCCGGG\"], \"CG\") == {'ATCGATCG': (50.0, [2, 6]), 'GCTAGCTAGCT': (54.55, []), 'AAATTTCCCGGG': (50.0, [8])}\n    assert candidate([\"ATCGATCGATCG\", \"CGCGCGCGCGCG\"], \"CGA\") == {'ATCGATCGATCG': (50.0, [2, 6]), 'CGCGCGCGCGCG': (100.0, [])}\n    assert candidate([\"AAAAA\", \"CCCCC\", \"GGGGG\", \"TTTTT\"], \"AA\") == {'AAAAA': (0.0, [0, 1, 2, 3]), 'CCCCC': (100.0, []), 'GGGGG': (100.0, []), 'TTTTT': (0.0, [])}\n    assert candidate([\"A\" * 100, \"C\" * 100, \"G\" * 100, \"T\" * 100], \"AA\") == {'AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA': (0.0, [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98]), 'CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC': (100.0, []), 'GGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGG': (100.0, []), 'TTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTT': (0.0, [])}\n    assert candidate([\"AGTCAGTC\", \"TTAAGGCC\", \"CGCGCGCG\"], \"AGT\") == {'AGTCAGTC': (50.0, [0, 4]), 'TTAAGGCC': (50.0, []), 'CGCGCGCG': (100.0, [])}\n    assert candidate([\"AAAACCCCGGGGTTTT\"], \"ACGT\") == {'AAAACCCCGGGGTTTT': (50.0, [])}\n    assert candidate([\"ATATATATATATAT\", \"CGCGCGCGCGCGCG\"], \"ATAT\") == {'ATATATATATATAT': (0.0, [0, 2, 4, 6, 8, 10]), 'CGCGCGCGCGCGCG': (100.0, [])}\n    assert candidate([\"ACGTACGTACGTACGT\", \"TGCATGCATGCATGCA\"], \"ACGTACGT\") == {'ACGTACGTACGTACGT': (50.0, [0, 4, 8]), 'TGCATGCATGCATGCA': (50.0, [])}\n", "language": "python"}
{"task_id": "c63cd23d-8dc8-4d91-9dac-31a9ac4419cd-2817844791624071644", "prompt": "I serve as your code completion assistant. When you give me a function to complete, I'll provide executable code that fits within the given function block. I'll respect the constraints by only using imported libraries and defining any additional components inside the main function scope.\n\n```python\nfrom typing import List\n\ndef calculate_water_flow(heights: List[int]) -> int:\n    \"\"\"\n    A hydrologist is studying water flow over a series of walls. Given an array of wall heights,\n    calculate the total amount of water that can be trapped between the walls after a rainstorm.\n\n    The function takes a list of integers representing the height of each wall and returns\n    the total volume of water that can be trapped.\n\n\n    [EXAMPLES]\n    \n    assert candidate([2, 0, 2]) == 2\n    assert candidate([1, 0, 1, 0, 1, 0, 1]) == 3\n\n    [/EXAMPLES]\n    \"\"\"\n```\n", "entry_point": "calculate_water_flow", "solution": "from typing import List\n\ndef calculate_water_flow(heights: List[int]) -> int:\n    \"\"\"\n    A hydrologist is studying water flow over a series of walls. Given an array of wall heights,\n    calculate the total amount of water that can be trapped between the walls after a rainstorm.\n\n    The function takes a list of integers representing the height of each wall and returns\n    the total volume of water that can be trapped.\n\n\n    [EXAMPLES]\n    \n    assert candidate([2, 0, 2]) == 2\n    assert candidate([1, 0, 1, 0, 1, 0, 1]) == 3\n\n    [/EXAMPLES]\n    \"\"\"\n    if not heights:\n        return 0\n\n    total_water = 0\n    left, right = 0, len(heights) - 1\n    left_max, right_max = 0, 0\n\n    while left < right:\n        if heights[left] < heights[right]:\n            if heights[left] >= left_max:\n                left_max = heights[left]\n            else:\n                total_water += left_max - heights[left]\n            left += 1\n        else:\n            if heights[right] >= right_max:\n                right_max = heights[right]\n            else:\n                total_water += right_max - heights[right]\n            right -= 1\n\n    return total_water\n\n", "test": "def check(candidate):\n    assert candidate([5, 4, 3, 2, 1, 0]) == 0\n    assert candidate([1, 0, 1, 0, 1, 0, 1]) == 3\n    assert candidate([5, 2, 1, 2, 1, 5]) == 14\n    assert candidate([1]) == 0\n    assert candidate([0, 1, 2, 3, 4, 5]) == 0\n    assert candidate([0, 0, 0, 0]) == 0\n    assert candidate([2, 0, 2]) == 2\n    assert candidate([7, 0, 4, 2, 5, 0, 6, 4, 0, 5]) == 25\n    assert candidate([1, 2, 3, 4, 3, 2, 1]) == 0\n    assert candidate([0, 1, 0, 2, 1, 0, 1, 3, 2, 1, 2, 1]) == 6\n", "language": "python"}
{"task_id": "e0aa0175-5fce-4276-a67c-8377b3799bc7-2136409343900343309", "prompt": "Your job is to implement a function that can be executed within a single code block without modifications. Don't include code outside the function. Restrict yourself to libraries that are already imported in the problem statement. Any supplementary functions or classes should be defined within the scope of the main function.\n\n```python\nfrom typing import List, Dict\nfrom collections import defaultdict\nfrom typing import List, Dict, Tuple\n\ndef analyze_social_network(connections: List[Tuple[str, str]], interests: Dict[str, List[str]]) -> Dict[str, List[str]]:\n    \"\"\"\n    Analyze a social network to suggest new connections based on shared interests.\n\n    This function takes a list of existing connections between users and a dictionary\n    of user interests. It then suggests new potential connections for each user based\n    on shared interests with users they are not already connected to.\n\n    Args:\n    connections (List[Tuple[str, str]]): A list of tuples representing existing connections between users.\n    interests (Dict[str, List[str]]): A dictionary where keys are user IDs and values are lists of their interests.\n\n    Returns:\n    Dict[str, List[str]]: A dictionary where keys are user IDs and values are lists of suggested new connections.\n\n\n    [EXAMPLES]\n    \n    assert candidate([(\"1\", \"2\"), (\"2\", \"3\"), (\"3\", \"4\"), (\"4\", \"5\")], {\"1\": [\"a\"], \"2\": [\"b\"], \"3\": [\"c\"], \"4\": [\"d\"], \"5\": [\"e\"], \"6\": [\"a\", \"b\", \"c\", \"d\", \"e\"]}) == {'1': ['6'], '6': ['1', '2', '3', '4', '5'], '2': ['6'], '3': ['6'], '4': ['6'], '5': ['6']}\n    assert candidate([(\"X\", \"Y\")], {\"X\": [\"red\", \"green\"], \"Y\": [\"blue\", \"yellow\"], \"Z\": [\"green\", \"blue\"]}) == {'X': ['Z'], 'Z': ['X', 'Y'], 'Y': ['Z']}\n\n    [/EXAMPLES]\n    \"\"\"\n```\n", "entry_point": "analyze_social_network", "solution": "from typing import List, Dict\nfrom collections import defaultdict\nfrom typing import List, Dict, Tuple\n\ndef analyze_social_network(connections: List[Tuple[str, str]], interests: Dict[str, List[str]]) -> Dict[str, List[str]]:\n    \"\"\"\n    Analyze a social network to suggest new connections based on shared interests.\n\n    This function takes a list of existing connections between users and a dictionary\n    of user interests. It then suggests new potential connections for each user based\n    on shared interests with users they are not already connected to.\n\n    Args:\n    connections (List[Tuple[str, str]]): A list of tuples representing existing connections between users.\n    interests (Dict[str, List[str]]): A dictionary where keys are user IDs and values are lists of their interests.\n\n    Returns:\n    Dict[str, List[str]]: A dictionary where keys are user IDs and values are lists of suggested new connections.\n\n\n    [EXAMPLES]\n    \n    assert candidate([(\"1\", \"2\"), (\"2\", \"3\"), (\"3\", \"4\"), (\"4\", \"5\")], {\"1\": [\"a\"], \"2\": [\"b\"], \"3\": [\"c\"], \"4\": [\"d\"], \"5\": [\"e\"], \"6\": [\"a\", \"b\", \"c\", \"d\", \"e\"]}) == {'1': ['6'], '6': ['1', '2', '3', '4', '5'], '2': ['6'], '3': ['6'], '4': ['6'], '5': ['6']}\n    assert candidate([(\"X\", \"Y\")], {\"X\": [\"red\", \"green\"], \"Y\": [\"blue\", \"yellow\"], \"Z\": [\"green\", \"blue\"]}) == {'X': ['Z'], 'Z': ['X', 'Y'], 'Y': ['Z']}\n\n    [/EXAMPLES]\n    \"\"\"\n    # Create a set of existing connections for each user\n    existing_connections = defaultdict(set)\n    for user1, user2 in connections:\n        existing_connections[user1].add(user2)\n        existing_connections[user2].add(user1)\n\n    # Create a dictionary to store suggested connections\n    suggested_connections = defaultdict(list)\n\n    # Iterate through all users\n    for user in interests:\n        user_interests = set(interests[user])\n        \n        # Compare with other users\n        for other_user in interests:\n            if user != other_user and other_user not in existing_connections[user]:\n                other_interests = set(interests[other_user])\n                \n                # If there are shared interests, add as a suggested connection\n                if user_interests.intersection(other_interests):\n                    suggested_connections[user].append(other_user)\n\n    # Sort the suggested connections for each user\n    for user in suggested_connections:\n        suggested_connections[user].sort()\n\n    return dict(suggested_connections)\n\n", "test": "def check(candidate):\n    assert candidate([(\"1\", \"2\"), (\"2\", \"3\"), (\"3\", \"4\"), (\"4\", \"1\")], {\"1\": [\"sport\"], \"2\": [\"music\"], \"3\": [\"art\"], \"4\": [\"dance\"], \"5\": [\"sport\", \"music\"]}) == {'1': ['5'], '2': ['5'], '5': ['1', '2']}\n    assert candidate([(\"User1\", \"User2\"), (\"User2\", \"User3\"), (\"User3\", \"User4\"), (\"User4\", \"User1\")], {\"User1\": [\"cooking\"], \"User2\": [\"sports\"], \"User3\": [\"reading\"], \"User4\": [\"gaming\"], \"User5\": [\"cooking\", \"sports\", \"reading\", \"gaming\"]}) == {'User1': ['User5'], 'User5': ['User1', 'User2', 'User3', 'User4'], 'User2': ['User5'], 'User3': ['User5'], 'User4': ['User5']}\n    assert candidate([(\"X\", \"Y\"), (\"Y\", \"Z\")], {\"X\": [\"red\", \"blue\"], \"Y\": [\"blue\", \"green\"], \"Z\": [\"green\", \"yellow\"], \"W\": [\"red\", \"yellow\"]}) == {'X': ['W'], 'W': ['X', 'Z'], 'Z': ['W']}\n    assert candidate([(\"A\", \"B\"), (\"B\", \"C\"), (\"C\", \"D\"), (\"D\", \"E\"), (\"E\", \"A\")], {\"A\": [\"1\", \"2\"], \"B\": [\"2\", \"3\"], \"C\": [\"3\", \"4\"], \"D\": [\"4\", \"5\"], \"E\": [\"5\", \"1\"], \"F\": [\"1\", \"3\", \"5\"]}) == {'A': ['F'], 'F': ['A', 'B', 'C', 'D', 'E'], 'B': ['F'], 'C': ['F'], 'D': ['F'], 'E': ['F']}\n    assert candidate([(\"1\", \"2\"), (\"2\", \"3\"), (\"3\", \"4\"), (\"4\", \"5\")], {\"1\": [\"a\"], \"2\": [\"b\"], \"3\": [\"c\"], \"4\": [\"d\"], \"5\": [\"e\"], \"6\": [\"a\", \"b\", \"c\", \"d\", \"e\"]}) == {'1': ['6'], '6': ['1', '2', '3', '4', '5'], '2': ['6'], '3': ['6'], '4': ['6'], '5': ['6']}\n    assert candidate([(\"User1\", \"User2\"), (\"User3\", \"User4\")], {\"User1\": [\"hobby1\", \"hobby2\"], \"User2\": [\"hobby2\", \"hobby3\"], \"User3\": [\"hobby3\", \"hobby4\"], \"User4\": [\"hobby4\", \"hobby5\"], \"User5\": [\"hobby1\", \"hobby5\"]}) == {'User1': ['User5'], 'User2': ['User3'], 'User3': ['User2'], 'User4': ['User5'], 'User5': ['User1', 'User4']}\n    assert candidate([(\"User1\", \"User2\"), (\"User2\", \"User3\")], {\"User1\": [\"a\", \"b\", \"c\"], \"User2\": [\"b\", \"c\", \"d\"], \"User3\": [\"c\", \"d\", \"e\"], \"User4\": [\"d\", \"e\", \"f\"]}) == {'User1': ['User3'], 'User2': ['User4'], 'User3': ['User1', 'User4'], 'User4': ['User2', 'User3']}\n    assert candidate([(\"1\", \"2\"), (\"2\", \"3\"), (\"3\", \"4\"), (\"4\", \"1\")], {\"1\": [\"sport\"], \"2\": [\"music\"], \"3\": [\"art\"], \"4\": [\"dance\"], \"5\": [\"sport\", \"music\"]}) == {'1': ['5'], '5': ['1', '2'], '2': ['5']}\n    assert candidate([(\"X\", \"Y\")], {\"X\": [\"red\", \"green\"], \"Y\": [\"blue\", \"yellow\"], \"Z\": [\"green\", \"blue\"]}) == {'X': ['Z'], 'Z': ['X', 'Y'], 'Y': ['Z']}\n    assert candidate([(\"User1\", \"User2\"), (\"User2\", \"User3\"), (\"User3\", \"User4\"), (\"User4\", \"User1\")], {\"User1\": [\"cooking\"], \"User2\": [\"sports\"], \"User3\": [\"reading\"], \"User4\": [\"gaming\"], \"User5\": [\"cooking\", \"sports\", \"reading\", \"gaming\"]}) == {'User1': ['User5'], 'User2': ['User5'], 'User3': ['User5'], 'User4': ['User5'], 'User5': ['User1', 'User2', 'User3', 'User4']}\n", "language": "python"}
{"task_id": "0e49638f-8d31-47bc-9df1-6c47d51c6658-7873798942441947966", "prompt": "I'll complete the provided function to ensure it's executable as-is. All supporting code will be contained inside the function definition, and I'll only use libraries that are already imported in the problem statement. No external code will be added.\n\n```python\ndef encrypt_message(message: str, key: str) -> str:\n    \"\"\"\n    A secret agent needs to encrypt a message using a custom encryption algorithm.\n    The encryption works as follows:\n    1. Convert each character in the message to its ASCII value.\n    2. XOR each ASCII value with the corresponding ASCII value of the key (repeating the key if necessary).\n    3. Convert the result back to characters.\n\n    This function takes a message string and a key string as input.\n    It should return the encrypted message as a string.\n\n    Use bitwise operations and string manipulation to implement this encryption algorithm.\n\n\n    [EXAMPLES]\n    \n    assert candidate(\"Unicode: \u4f60\u597d\", \"test\") == '!\\x0b\\x1a\\x17\\x1b\\x01\\x16NT\u4f05\u590e'\n    assert candidate(\"Hello, World!\", \"secret\") == ';\\x00\\x0f\\x1e\\nXS2\\x0c\\x00\\t\\x10R'\n\n    [/EXAMPLES]\n    \"\"\"\n```\n", "entry_point": "encrypt_message", "solution": "def encrypt_message(message: str, key: str) -> str:\n    \"\"\"\n    A secret agent needs to encrypt a message using a custom encryption algorithm.\n    The encryption works as follows:\n    1. Convert each character in the message to its ASCII value.\n    2. XOR each ASCII value with the corresponding ASCII value of the key (repeating the key if necessary).\n    3. Convert the result back to characters.\n\n    This function takes a message string and a key string as input.\n    It should return the encrypted message as a string.\n\n    Use bitwise operations and string manipulation to implement this encryption algorithm.\n\n\n    [EXAMPLES]\n    \n    assert candidate(\"Unicode: \u4f60\u597d\", \"test\") == '!\\x0b\\x1a\\x17\\x1b\\x01\\x16NT\u4f05\u590e'\n    assert candidate(\"Hello, World!\", \"secret\") == ';\\x00\\x0f\\x1e\\nXS2\\x0c\\x00\\t\\x10R'\n\n    [/EXAMPLES]\n    \"\"\"\n    def xor_encrypt(char: str, key_char: str) -> str:\n        return chr(ord(char) ^ ord(key_char))\n\n    key_length = len(key)\n    encrypted_chars = []\n\n    for i, char in enumerate(message):\n        key_char = key[i % key_length]\n        encrypted_char = xor_encrypt(char, key_char)\n        encrypted_chars.append(encrypted_char)\n\n    return ''.join(encrypted_chars)\n\n", "test": "def check(candidate):\n    assert candidate(\"Unicode: \u4f60\u597d\", \"test\") == '!\\x0b\\x1a\\x17\\x1b\\x01\\x16NT\u4f05\u590e'\n    assert candidate(\"Unicode: \u4f60\u597d\", \"Key\") == '\\x1e\\x0b\\x10(\\n\\x1d._Y\u4f2b\u5918'\n    assert candidate(\"LongMessage\"*1000, \"ShortKey\") == '\\x1f\\x07\\x01\\x159.\\x16\\n2\\x0f\\n>\\x1b%\\x0246\\x1b\\x1c\\x13\\x13.)\\x16=\\x0f\"\\x17\\x078\\x04\\x1e6$\\x00\\x1c\\x13\\x06\\x00\\n \\t\\x08\\x178$\\x0b\\x1e\\x1e\\r\\x1c\\x01\\x15,\\x005<\\x06\\x08?\\x118\\x16\\x184\\r#\\x1d\\x1a,(\\x1c \\x1b\\x0e\\x15\\x11\\x07\\n\\x174%\\n\\x01\\x07*\\x02\\x1c\\x1f\\x07\\x01\\x159.\\x16\\n2\\x0f\\n>\\x1b%\\x0246\\x1b\\x1c\\x13\\x13.)\\x16=\\x0f\"\\x17\\x078\\x04\\x1e6$\\x00\\x1c\\x13\\x06\\x00\\n \\t\\x08\\x178$\\x0b\\x1e\\x1e\\r\\x1c\\x01\\x15,\\x005<\\x06\\x08?\\x118\\x16\\x184\\r#\\x1d\\x1a,(\\x1c \\x1b\\x0e\\x15\\x11\\x07\\n\\x174%\\n\\x01\\x07*\\x02\\x1c\\x1f\\x07\\x01\\x159.\\x16\\n2\\x0f\\n>\\x1b%\\x0246\\x1b\\x1c\\x13\\x13.)\\x16=\\x0f\"\\x17\\x078\\x04\\x1e6$\\x00\\x1c\\x13\\x06\\x00\\n \\t\\x08\\x178$\\x0b\\x1e\\x1e\\r\\x1c\\x01\\x15,\\x005<\\x06\\x08?\\x118\\x16\\x184\\r#\\x1d\\x1a,(\\x1c \\x1b\\x0e\\x15\\x11\\x07\\n\\x174%\\n\\x01\\x07*\\x02\\x1c\\x1f\\x07\\x01\\x159.\\x16\\n2\\x0f\\n>\\x1b%\\x0246\\x1b\\x1c\\x13\\x13.)\\x16=\\x0f\"\\x17\\x078\\x04\\x1e6$\\x00\\x1c\\x13\\x06\\x00\\n \\t\\x08\\x178$\\x0b\\x1e\\x1e\\r\\x1c\\x01\\x15,\\x005<\\x06\\x08?\\x118\\x16\\x184\\r#\\x1d\\x1a,(\\x1c \\x1b\\x0e\\x15\\x11\\x07\\n\\x174%\\n\\x01\\x07*\\x02\\x1c\\x1f\\x07\\x01\\x159.\\x16\\n2\\x0f\\n>\\x1b%\\x0246\\x1b\\x1c\\x13\\x13.)\\x16=\\x0f\"\\x17\\x078\\x04\\x1e6$\\x00\\x1c\\x13\\x06\\x00\\n \\t\\x08\\x178$\\x0b\\x1e\\x1e\\r\\x1c\\x01\\x15,\\x005<\\x06\\x08?\\x118\\x16\\x184\\r#\\x1d\\x1a,(\\x1c \\x1b\\x0e\\x15\\x11\\x07\\n\\x174%\\n\\x01\\x07*\\x02\\x1c\\x1f\\x07\\x01\\x159.\\x16\\n2\\x0f\\n>\\x1b%\\x0246\\x1b\\x1c\\x13\\x13.)\\x16=\\x0f\"\\x17\\x078\\x04\\x1e6$\\x00\\x1c\\x13\\x06\\x00\\n \\t\\x08\\x178$\\x0b\\x1e\\x1e\\r\\x1c\\x01\\x15,\\x005<\\x06\\x08?\\x118\\x16\\x184\\r#\\x1d\\x1a,(\\x1c \\x1b\\x0e\\x15\\x11\\x07\\n\\x174%\\n\\x01\\x07*\\x02\\x1c\\x1f\\x07\\x01\\x159.\\x16\\n2\\x0f\\n>\\x1b%\\x0246\\x1b\\x1c\\x13\\x13.)\\x16=\\x0f\"\\x17\\x078\\x04\\x1e6$\\x00\\x1c\\x13\\x06\\x00\\n \\t\\x08\\x178$\\x0b\\x1e\\x1e\\r\\x1c\\x01\\x15,\\x005<\\x06\\x08?\\x118\\x16\\x184\\r#\\x1d\\x1a,(\\x1c \\x1b\\x0e\\x15\\x11\\x07\\n\\x174%\\n\\x01\\x07*\\x02\\x1c\\x1f\\x07\\x01\\x159.\\x16\\n2\\x0f\\n>\\x1b%\\x0246\\x1b\\x1c\\x13\\x13.)\\x16=\\x0f\"\\x17\\x078\\x04\\x1e6$\\x00\\x1c\\x13\\x06\\x00\\n \\t\\x08\\x178$\\x0b\\x1e\\x1e\\r\\x1c\\x01\\x15,\\x005<\\x06\\x08?\\x118\\x16\\x184\\r#\\x1d\\x1a,(\\x1c \\x1b\\x0e\\x15\\x11\\x07\\n\\x174%\\n\\x01\\x07*\\x02\\x1c\\x1f\\x07\\x01\\x159.\\x16\\n2\\x0f\\n>\\x1b%\\x0246\\x1b\\x1c\\x13\\x13.)\\x16=\\x0f\"\\x17\\x078\\x04\\x1e6$\\x00\\x1c\\x13\\x06\\x00\\n \\t\\x08\\x178$\\x0b\\x1e\\x1e\\r\\x1c\\x01\\x15,\\x005<\\x06\\x08?\\x118\\x16\\x184\\r#\\x1d\\x1a,(\\x1c \\x1b\\x0e\\x15\\x11\\x07\\n\\x174%\\n\\x01\\x07*\\x02\\x1c\\x1f\\x07\\x01\\x159.\\x16\\n2\\x0f\\n>\\x1b%\\x0246\\x1b\\x1c\\x13\\x13.)\\x16=\\x0f\"\\x17\\x078\\x04\\x1e6$\\x00\\x1c\\x13\\x06\\x00\\n \\t\\x08\\x178$\\x0b\\x1e\\x1e\\r\\x1c\\x01\\x15,\\x005<\\x06\\x08?\\x118\\x16\\x184\\r#\\x1d\\x1a,(\\x1c \\x1b\\x0e\\x15\\x11\\x07\\n\\x174%\\n\\x01\\x07*\\x02\\x1c\\x1f\\x07\\x01\\x159.\\x16\\n2\\x0f\\n>\\x1b%\\x0246\\x1b\\x1c\\x13\\x13.)\\x16=\\x0f\"\\x17\\x078\\x04\\x1e6$\\x00\\x1c\\x13\\x06\\x00\\n \\t\\x08\\x178$\\x0b\\x1e\\x1e\\r\\x1c\\x01\\x15,\\x005<\\x06\\x08?\\x118\\x16\\x184\\r#\\x1d\\x1a,(\\x1c \\x1b\\x0e\\x15\\x11\\x07\\n\\x174%\\n\\x01\\x07*\\x02\\x1c\\x1f\\x07\\x01\\x159.\\x16\\n2\\x0f\\n>\\x1b%\\x0246\\x1b\\x1c\\x13\\x13.)\\x16=\\x0f\"\\x17\\x078\\x04\\x1e6$\\x00\\x1c\\x13\\x06\\x00\\n \\t\\x08\\x178$\\x0b\\x1e\\x1e\\r\\x1c\\x01\\x15,\\x005<\\x06\\x08?\\x118\\x16\\x184\\r#\\x1d\\x1a,(\\x1c \\x1b\\x0e\\x15\\x11\\x07\\n\\x174%\\n\\x01\\x07*\\x02\\x1c\\x1f\\x07\\x01\\x159.\\x16\\n2\\x0f\\n>\\x1b%\\x0246\\x1b\\x1c\\x13\\x13.)\\x16=\\x0f\"\\x17\\x078\\x04\\x1e6$\\x00\\x1c\\x13\\x06\\x00\\n \\t\\x08\\x178$\\x0b\\x1e\\x1e\\r\\x1c\\x01\\x15,\\x005<\\x06\\x08?\\x118\\x16\\x184\\r#\\x1d\\x1a,(\\x1c \\x1b\\x0e\\x15\\x11\\x07\\n\\x174%\\n\\x01\\x07*\\x02\\x1c\\x1f\\x07\\x01\\x159.\\x16\\n2\\x0f\\n>\\x1b%\\x0246\\x1b\\x1c\\x13\\x13.)\\x16=\\x0f\"\\x17\\x078\\x04\\x1e6$\\x00\\x1c\\x13\\x06\\x00\\n \\t\\x08\\x178$\\x0b\\x1e\\x1e\\r\\x1c\\x01\\x15,\\x005<\\x06\\x08?\\x118\\x16\\x184\\r#\\x1d\\x1a,(\\x1c \\x1b\\x0e\\x15\\x11\\x07\\n\\x174%\\n\\x01\\x07*\\x02\\x1c\\x1f\\x07\\x01\\x159.\\x16\\n2\\x0f\\n>\\x1b%\\x0246\\x1b\\x1c\\x13\\x13.)\\x16=\\x0f\"\\x17\\x078\\x04\\x1e6$\\x00\\x1c\\x13\\x06\\x00\\n \\t\\x08\\x178$\\x0b\\x1e\\x1e\\r\\x1c\\x01\\x15,\\x005<\\x06\\x08?\\x118\\x16\\x184\\r#\\x1d\\x1a,(\\x1c \\x1b\\x0e\\x15\\x11\\x07\\n\\x174%\\n\\x01\\x07*\\x02\\x1c\\x1f\\x07\\x01\\x159.\\x16\\n2\\x0f\\n>\\x1b%\\x0246\\x1b\\x1c\\x13\\x13.)\\x16=\\x0f\"\\x17\\x078\\x04\\x1e6$\\x00\\x1c\\x13\\x06\\x00\\n \\t\\x08\\x178$\\x0b\\x1e\\x1e\\r\\x1c\\x01\\x15,\\x005<\\x06\\x08?\\x118\\x16\\x184\\r#\\x1d\\x1a,(\\x1c \\x1b\\x0e\\x15\\x11\\x07\\n\\x174%\\n\\x01\\x07*\\x02\\x1c\\x1f\\x07\\x01\\x159.\\x16\\n2\\x0f\\n>\\x1b%\\x0246\\x1b\\x1c\\x13\\x13.)\\x16=\\x0f\"\\x17\\x078\\x04\\x1e6$\\x00\\x1c\\x13\\x06\\x00\\n \\t\\x08\\x178$\\x0b\\x1e\\x1e\\r\\x1c\\x01\\x15,\\x005<\\x06\\x08?\\x118\\x16\\x184\\r#\\x1d\\x1a,(\\x1c \\x1b\\x0e\\x15\\x11\\x07\\n\\x174%\\n\\x01\\x07*\\x02\\x1c\\x1f\\x07\\x01\\x159.\\x16\\n2\\x0f\\n>\\x1b%\\x0246\\x1b\\x1c\\x13\\x13.)\\x16=\\x0f\"\\x17\\x078\\x04\\x1e6$\\x00\\x1c\\x13\\x06\\x00\\n \\t\\x08\\x178$\\x0b\\x1e\\x1e\\r\\x1c\\x01\\x15,\\x005<\\x06\\x08?\\x118\\x16\\x184\\r#\\x1d\\x1a,(\\x1c \\x1b\\x0e\\x15\\x11\\x07\\n\\x174%\\n\\x01\\x07*\\x02\\x1c\\x1f\\x07\\x01\\x159.\\x16\\n2\\x0f\\n>\\x1b%\\x0246\\x1b\\x1c\\x13\\x13.)\\x16=\\x0f\"\\x17\\x078\\x04\\x1e6$\\x00\\x1c\\x13\\x06\\x00\\n \\t\\x08\\x178$\\x0b\\x1e\\x1e\\r\\x1c\\x01\\x15,\\x005<\\x06\\x08?\\x118\\x16\\x184\\r#\\x1d\\x1a,(\\x1c \\x1b\\x0e\\x15\\x11\\x07\\n\\x174%\\n\\x01\\x07*\\x02\\x1c\\x1f\\x07\\x01\\x159.\\x16\\n2\\x0f\\n>\\x1b%\\x0246\\x1b\\x1c\\x13\\x13.)\\x16=\\x0f\"\\x17\\x078\\x04\\x1e6$\\x00\\x1c\\x13\\x06\\x00\\n \\t\\x08\\x178$\\x0b\\x1e\\x1e\\r\\x1c\\x01\\x15,\\x005<\\x06\\x08?\\x118\\x16\\x184\\r#\\x1d\\x1a,(\\x1c \\x1b\\x0e\\x15\\x11\\x07\\n\\x174%\\n\\x01\\x07*\\x02\\x1c\\x1f\\x07\\x01\\x159.\\x16\\n2\\x0f\\n>\\x1b%\\x0246\\x1b\\x1c\\x13\\x13.)\\x16=\\x0f\"\\x17\\x078\\x04\\x1e6$\\x00\\x1c\\x13\\x06\\x00\\n \\t\\x08\\x178$\\x0b\\x1e\\x1e\\r\\x1c\\x01\\x15,\\x005<\\x06\\x08?\\x118\\x16\\x184\\r#\\x1d\\x1a,(\\x1c \\x1b\\x0e\\x15\\x11\\x07\\n\\x174%\\n\\x01\\x07*\\x02\\x1c\\x1f\\x07\\x01\\x159.\\x16\\n2\\x0f\\n>\\x1b%\\x0246\\x1b\\x1c\\x13\\x13.)\\x16=\\x0f\"\\x17\\x078\\x04\\x1e6$\\x00\\x1c\\x13\\x06\\x00\\n \\t\\x08\\x178$\\x0b\\x1e\\x1e\\r\\x1c\\x01\\x15,\\x005<\\x06\\x08?\\x118\\x16\\x184\\r#\\x1d\\x1a,(\\x1c \\x1b\\x0e\\x15\\x11\\x07\\n\\x174%\\n\\x01\\x07*\\x02\\x1c\\x1f\\x07\\x01\\x159.\\x16\\n2\\x0f\\n>\\x1b%\\x0246\\x1b\\x1c\\x13\\x13.)\\x16=\\x0f\"\\x17\\x078\\x04\\x1e6$\\x00\\x1c\\x13\\x06\\x00\\n \\t\\x08\\x178$\\x0b\\x1e\\x1e\\r\\x1c\\x01\\x15,\\x005<\\x06\\x08?\\x118\\x16\\x184\\r#\\x1d\\x1a,(\\x1c \\x1b\\x0e\\x15\\x11\\x07\\n\\x174%\\n\\x01\\x07*\\x02\\x1c\\x1f\\x07\\x01\\x159.\\x16\\n2\\x0f\\n>\\x1b%\\x0246\\x1b\\x1c\\x13\\x13.)\\x16=\\x0f\"\\x17\\x078\\x04\\x1e6$\\x00\\x1c\\x13\\x06\\x00\\n \\t\\x08\\x178$\\x0b\\x1e\\x1e\\r\\x1c\\x01\\x15,\\x005<\\x06\\x08?\\x118\\x16\\x184\\r#\\x1d\\x1a,(\\x1c \\x1b\\x0e\\x15\\x11\\x07\\n\\x174%\\n\\x01\\x07*\\x02\\x1c\\x1f\\x07\\x01\\x159.\\x16\\n2\\x0f\\n>\\x1b%\\x0246\\x1b\\x1c\\x13\\x13.)\\x16=\\x0f\"\\x17\\x078\\x04\\x1e6$\\x00\\x1c\\x13\\x06\\x00\\n \\t\\x08\\x178$\\x0b\\x1e\\x1e\\r\\x1c\\x01\\x15,\\x005<\\x06\\x08?\\x118\\x16\\x184\\r#\\x1d\\x1a,(\\x1c \\x1b\\x0e\\x15\\x11\\x07\\n\\x174%\\n\\x01\\x07*\\x02\\x1c\\x1f\\x07\\x01\\x159.\\x16\\n2\\x0f\\n>\\x1b%\\x0246\\x1b\\x1c\\x13\\x13.)\\x16=\\x0f\"\\x17\\x078\\x04\\x1e6$\\x00\\x1c\\x13\\x06\\x00\\n \\t\\x08\\x178$\\x0b\\x1e\\x1e\\r\\x1c\\x01\\x15,\\x005<\\x06\\x08?\\x118\\x16\\x184\\r#\\x1d\\x1a,(\\x1c \\x1b\\x0e\\x15\\x11\\x07\\n\\x174%\\n\\x01\\x07*\\x02\\x1c\\x1f\\x07\\x01\\x159.\\x16\\n2\\x0f\\n>\\x1b%\\x0246\\x1b\\x1c\\x13\\x13.)\\x16=\\x0f\"\\x17\\x078\\x04\\x1e6$\\x00\\x1c\\x13\\x06\\x00\\n \\t\\x08\\x178$\\x0b\\x1e\\x1e\\r\\x1c\\x01\\x15,\\x005<\\x06\\x08?\\x118\\x16\\x184\\r#\\x1d\\x1a,(\\x1c \\x1b\\x0e\\x15\\x11\\x07\\n\\x174%\\n\\x01\\x07*\\x02\\x1c\\x1f\\x07\\x01\\x159.\\x16\\n2\\x0f\\n>\\x1b%\\x0246\\x1b\\x1c\\x13\\x13.)\\x16=\\x0f\"\\x17\\x078\\x04\\x1e6$\\x00\\x1c\\x13\\x06\\x00\\n \\t\\x08\\x178$\\x0b\\x1e\\x1e\\r\\x1c\\x01\\x15,\\x005<\\x06\\x08?\\x118\\x16\\x184\\r#\\x1d\\x1a,(\\x1c \\x1b\\x0e\\x15\\x11\\x07\\n\\x174%\\n\\x01\\x07*\\x02\\x1c\\x1f\\x07\\x01\\x159.\\x16\\n2\\x0f\\n>\\x1b%\\x0246\\x1b\\x1c\\x13\\x13.)\\x16=\\x0f\"\\x17\\x078\\x04\\x1e6$\\x00\\x1c\\x13\\x06\\x00\\n \\t\\x08\\x178$\\x0b\\x1e\\x1e\\r\\x1c\\x01\\x15,\\x005<\\x06\\x08?\\x118\\x16\\x184\\r#\\x1d\\x1a,(\\x1c \\x1b\\x0e\\x15\\x11\\x07\\n\\x174%\\n\\x01\\x07*\\x02\\x1c\\x1f\\x07\\x01\\x159.\\x16\\n2\\x0f\\n>\\x1b%\\x0246\\x1b\\x1c\\x13\\x13.)\\x16=\\x0f\"\\x17\\x078\\x04\\x1e6$\\x00\\x1c\\x13\\x06\\x00\\n \\t\\x08\\x178$\\x0b\\x1e\\x1e\\r\\x1c\\x01\\x15,\\x005<\\x06\\x08?\\x118\\x16\\x184\\r#\\x1d\\x1a,(\\x1c \\x1b\\x0e\\x15\\x11\\x07\\n\\x174%\\n\\x01\\x07*\\x02\\x1c\\x1f\\x07\\x01\\x159.\\x16\\n2\\x0f\\n>\\x1b%\\x0246\\x1b\\x1c\\x13\\x13.)\\x16=\\x0f\"\\x17\\x078\\x04\\x1e6$\\x00\\x1c\\x13\\x06\\x00\\n \\t\\x08\\x178$\\x0b\\x1e\\x1e\\r\\x1c\\x01\\x15,\\x005<\\x06\\x08?\\x118\\x16\\x184\\r#\\x1d\\x1a,(\\x1c \\x1b\\x0e\\x15\\x11\\x07\\n\\x174%\\n\\x01\\x07*\\x02\\x1c\\x1f\\x07\\x01\\x159.\\x16\\n2\\x0f\\n>\\x1b%\\x0246\\x1b\\x1c\\x13\\x13.)\\x16=\\x0f\"\\x17\\x078\\x04\\x1e6$\\x00\\x1c\\x13\\x06\\x00\\n \\t\\x08\\x178$\\x0b\\x1e\\x1e\\r\\x1c\\x01\\x15,\\x005<\\x06\\x08?\\x118\\x16\\x184\\r#\\x1d\\x1a,(\\x1c \\x1b\\x0e\\x15\\x11\\x07\\n\\x174%\\n\\x01\\x07*\\x02\\x1c\\x1f\\x07\\x01\\x159.\\x16\\n2\\x0f\\n>\\x1b%\\x0246\\x1b\\x1c\\x13\\x13.)\\x16=\\x0f\"\\x17\\x078\\x04\\x1e6$\\x00\\x1c\\x13\\x06\\x00\\n \\t\\x08\\x178$\\x0b\\x1e\\x1e\\r\\x1c\\x01\\x15,\\x005<\\x06\\x08?\\x118\\x16\\x184\\r#\\x1d\\x1a,(\\x1c \\x1b\\x0e\\x15\\x11\\x07\\n\\x174%\\n\\x01\\x07*\\x02\\x1c\\x1f\\x07\\x01\\x159.\\x16\\n2\\x0f\\n>\\x1b%\\x0246\\x1b\\x1c\\x13\\x13.)\\x16=\\x0f\"\\x17\\x078\\x04\\x1e6$\\x00\\x1c\\x13\\x06\\x00\\n \\t\\x08\\x178$\\x0b\\x1e\\x1e\\r\\x1c\\x01\\x15,\\x005<\\x06\\x08?\\x118\\x16\\x184\\r#\\x1d\\x1a,(\\x1c \\x1b\\x0e\\x15\\x11\\x07\\n\\x174%\\n\\x01\\x07*\\x02\\x1c\\x1f\\x07\\x01\\x159.\\x16\\n2\\x0f\\n>\\x1b%\\x0246\\x1b\\x1c\\x13\\x13.)\\x16=\\x0f\"\\x17\\x078\\x04\\x1e6$\\x00\\x1c\\x13\\x06\\x00\\n \\t\\x08\\x178$\\x0b\\x1e\\x1e\\r\\x1c\\x01\\x15,\\x005<\\x06\\x08?\\x118\\x16\\x184\\r#\\x1d\\x1a,(\\x1c \\x1b\\x0e\\x15\\x11\\x07\\n\\x174%\\n\\x01\\x07*\\x02\\x1c\\x1f\\x07\\x01\\x159.\\x16\\n2\\x0f\\n>\\x1b%\\x0246\\x1b\\x1c\\x13\\x13.)\\x16=\\x0f\"\\x17\\x078\\x04\\x1e6$\\x00\\x1c\\x13\\x06\\x00\\n \\t\\x08\\x178$\\x0b\\x1e\\x1e\\r\\x1c\\x01\\x15,\\x005<\\x06\\x08?\\x118\\x16\\x184\\r#\\x1d\\x1a,(\\x1c \\x1b\\x0e\\x15\\x11\\x07\\n\\x174%\\n\\x01\\x07*\\x02\\x1c\\x1f\\x07\\x01\\x159.\\x16\\n2\\x0f\\n>\\x1b%\\x0246\\x1b\\x1c\\x13\\x13.)\\x16=\\x0f\"\\x17\\x078\\x04\\x1e6$\\x00\\x1c\\x13\\x06\\x00\\n \\t\\x08\\x178$\\x0b\\x1e\\x1e\\r\\x1c\\x01\\x15,\\x005<\\x06\\x08?\\x118\\x16\\x184\\r#\\x1d\\x1a,(\\x1c \\x1b\\x0e\\x15\\x11\\x07\\n\\x174%\\n\\x01\\x07*\\x02\\x1c\\x1f\\x07\\x01\\x159.\\x16\\n2\\x0f\\n>\\x1b%\\x0246\\x1b\\x1c\\x13\\x13.)\\x16=\\x0f\"\\x17\\x078\\x04\\x1e6$\\x00\\x1c\\x13\\x06\\x00\\n \\t\\x08\\x178$\\x0b\\x1e\\x1e\\r\\x1c\\x01\\x15,\\x005<\\x06\\x08?\\x118\\x16\\x184\\r#\\x1d\\x1a,(\\x1c \\x1b\\x0e\\x15\\x11\\x07\\n\\x174%\\n\\x01\\x07*\\x02\\x1c\\x1f\\x07\\x01\\x159.\\x16\\n2\\x0f\\n>\\x1b%\\x0246\\x1b\\x1c\\x13\\x13.)\\x16=\\x0f\"\\x17\\x078\\x04\\x1e6$\\x00\\x1c\\x13\\x06\\x00\\n \\t\\x08\\x178$\\x0b\\x1e\\x1e\\r\\x1c\\x01\\x15,\\x005<\\x06\\x08?\\x118\\x16\\x184\\r#\\x1d\\x1a,(\\x1c \\x1b\\x0e\\x15\\x11\\x07\\n\\x174%\\n\\x01\\x07*\\x02\\x1c\\x1f\\x07\\x01\\x159.\\x16\\n2\\x0f\\n>\\x1b%\\x0246\\x1b\\x1c\\x13\\x13.)\\x16=\\x0f\"\\x17\\x078\\x04\\x1e6$\\x00\\x1c\\x13\\x06\\x00\\n \\t\\x08\\x178$\\x0b\\x1e\\x1e\\r\\x1c\\x01\\x15,\\x005<\\x06\\x08?\\x118\\x16\\x184\\r#\\x1d\\x1a,(\\x1c \\x1b\\x0e\\x15\\x11\\x07\\n\\x174%\\n\\x01\\x07*\\x02\\x1c\\x1f\\x07\\x01\\x159.\\x16\\n2\\x0f\\n>\\x1b%\\x0246\\x1b\\x1c\\x13\\x13.)\\x16=\\x0f\"\\x17\\x078\\x04\\x1e6$\\x00\\x1c\\x13\\x06\\x00\\n \\t\\x08\\x178$\\x0b\\x1e\\x1e\\r\\x1c\\x01\\x15,\\x005<\\x06\\x08?\\x118\\x16\\x184\\r#\\x1d\\x1a,(\\x1c \\x1b\\x0e\\x15\\x11\\x07\\n\\x174%\\n\\x01\\x07*\\x02\\x1c\\x1f\\x07\\x01\\x159.\\x16\\n2\\x0f\\n>\\x1b%\\x0246\\x1b\\x1c\\x13\\x13.)\\x16=\\x0f\"\\x17\\x078\\x04\\x1e6$\\x00\\x1c\\x13\\x06\\x00\\n \\t\\x08\\x178$\\x0b\\x1e\\x1e\\r\\x1c\\x01\\x15,\\x005<\\x06\\x08?\\x118\\x16\\x184\\r#\\x1d\\x1a,(\\x1c \\x1b\\x0e\\x15\\x11\\x07\\n\\x174%\\n\\x01\\x07*\\x02\\x1c\\x1f\\x07\\x01\\x159.\\x16\\n2\\x0f\\n>\\x1b%\\x0246\\x1b\\x1c\\x13\\x13.)\\x16=\\x0f\"\\x17\\x078\\x04\\x1e6$\\x00\\x1c\\x13\\x06\\x00\\n \\t\\x08\\x178$\\x0b\\x1e\\x1e\\r\\x1c\\x01\\x15,\\x005<\\x06\\x08?\\x118\\x16\\x184\\r#\\x1d\\x1a,(\\x1c \\x1b\\x0e\\x15\\x11\\x07\\n\\x174%\\n\\x01\\x07*\\x02\\x1c\\x1f\\x07\\x01\\x159.\\x16\\n2\\x0f\\n>\\x1b%\\x0246\\x1b\\x1c\\x13\\x13.)\\x16=\\x0f\"\\x17\\x078\\x04\\x1e6$\\x00\\x1c\\x13\\x06\\x00\\n \\t\\x08\\x178$\\x0b\\x1e\\x1e\\r\\x1c\\x01\\x15,\\x005<\\x06\\x08?\\x118\\x16\\x184\\r#\\x1d\\x1a,(\\x1c \\x1b\\x0e\\x15\\x11\\x07\\n\\x174%\\n\\x01\\x07*\\x02\\x1c\\x1f\\x07\\x01\\x159.\\x16\\n2\\x0f\\n>\\x1b%\\x0246\\x1b\\x1c\\x13\\x13.)\\x16=\\x0f\"\\x17\\x078\\x04\\x1e6$\\x00\\x1c\\x13\\x06\\x00\\n \\t\\x08\\x178$\\x0b\\x1e\\x1e\\r\\x1c\\x01\\x15,\\x005<\\x06\\x08?\\x118\\x16\\x184\\r#\\x1d\\x1a,(\\x1c \\x1b\\x0e\\x15\\x11\\x07\\n\\x174%\\n\\x01\\x07*\\x02\\x1c\\x1f\\x07\\x01\\x159.\\x16\\n2\\x0f\\n>\\x1b%\\x0246\\x1b\\x1c\\x13\\x13.)\\x16=\\x0f\"\\x17\\x078\\x04\\x1e6$\\x00\\x1c\\x13\\x06\\x00\\n \\t\\x08\\x178$\\x0b\\x1e\\x1e\\r\\x1c\\x01\\x15,\\x005<\\x06\\x08?\\x118\\x16\\x184\\r#\\x1d\\x1a,(\\x1c \\x1b\\x0e\\x15\\x11\\x07\\n\\x174%\\n\\x01\\x07*\\x02\\x1c\\x1f\\x07\\x01\\x159.\\x16\\n2\\x0f\\n>\\x1b%\\x0246\\x1b\\x1c\\x13\\x13.)\\x16=\\x0f\"\\x17\\x078\\x04\\x1e6$\\x00\\x1c\\x13\\x06\\x00\\n \\t\\x08\\x178$\\x0b\\x1e\\x1e\\r\\x1c\\x01\\x15,\\x005<\\x06\\x08?\\x118\\x16\\x184\\r#\\x1d\\x1a,(\\x1c \\x1b\\x0e\\x15\\x11\\x07\\n\\x174%\\n\\x01\\x07*\\x02\\x1c\\x1f\\x07\\x01\\x159.\\x16\\n2\\x0f\\n>\\x1b%\\x0246\\x1b\\x1c\\x13\\x13.)\\x16=\\x0f\"\\x17\\x078\\x04\\x1e6$\\x00\\x1c\\x13\\x06\\x00\\n \\t\\x08\\x178$\\x0b\\x1e\\x1e\\r\\x1c\\x01\\x15,\\x005<\\x06\\x08?\\x118\\x16\\x184\\r#\\x1d\\x1a,(\\x1c \\x1b\\x0e\\x15\\x11\\x07\\n\\x174%\\n\\x01\\x07*\\x02\\x1c\\x1f\\x07\\x01\\x159.\\x16\\n2\\x0f\\n>\\x1b%\\x0246\\x1b\\x1c\\x13\\x13.)\\x16=\\x0f\"\\x17\\x078\\x04\\x1e6$\\x00\\x1c\\x13\\x06\\x00\\n \\t\\x08\\x178$\\x0b\\x1e\\x1e\\r\\x1c\\x01\\x15,\\x005<\\x06\\x08?\\x118\\x16\\x184\\r#\\x1d\\x1a,(\\x1c \\x1b\\x0e\\x15\\x11\\x07\\n\\x174%\\n\\x01\\x07*\\x02\\x1c\\x1f\\x07\\x01\\x159.\\x16\\n2\\x0f\\n>\\x1b%\\x0246\\x1b\\x1c\\x13\\x13.)\\x16=\\x0f\"\\x17\\x078\\x04\\x1e6$\\x00\\x1c\\x13\\x06\\x00\\n \\t\\x08\\x178$\\x0b\\x1e\\x1e\\r\\x1c\\x01\\x15,\\x005<\\x06\\x08?\\x118\\x16\\x184\\r#\\x1d\\x1a,(\\x1c \\x1b\\x0e\\x15\\x11\\x07\\n\\x174%\\n\\x01\\x07*\\x02\\x1c\\x1f\\x07\\x01\\x159.\\x16\\n2\\x0f\\n>\\x1b%\\x0246\\x1b\\x1c\\x13\\x13.)\\x16=\\x0f\"\\x17\\x078\\x04\\x1e6$\\x00\\x1c\\x13\\x06\\x00\\n \\t\\x08\\x178$\\x0b\\x1e\\x1e\\r\\x1c\\x01\\x15,\\x005<\\x06\\x08?\\x118\\x16\\x184\\r#\\x1d\\x1a,(\\x1c \\x1b\\x0e\\x15\\x11\\x07\\n\\x174%\\n\\x01\\x07*\\x02\\x1c\\x1f\\x07\\x01\\x159.\\x16\\n2\\x0f\\n>\\x1b%\\x0246\\x1b\\x1c\\x13\\x13.)\\x16=\\x0f\"\\x17\\x078\\x04\\x1e6$\\x00\\x1c\\x13\\x06\\x00\\n \\t\\x08\\x178$\\x0b\\x1e\\x1e\\r\\x1c\\x01\\x15,\\x005<\\x06\\x08?\\x118\\x16\\x184\\r#\\x1d\\x1a,(\\x1c \\x1b\\x0e\\x15\\x11\\x07\\n\\x174%\\n\\x01\\x07*\\x02\\x1c\\x1f\\x07\\x01\\x159.\\x16\\n2\\x0f\\n>\\x1b%\\x0246\\x1b\\x1c\\x13\\x13.)\\x16=\\x0f\"\\x17\\x078\\x04\\x1e6$\\x00\\x1c\\x13\\x06\\x00\\n \\t\\x08\\x178$\\x0b\\x1e\\x1e\\r\\x1c\\x01\\x15,\\x005<\\x06\\x08?\\x118\\x16\\x184\\r#\\x1d\\x1a,(\\x1c \\x1b\\x0e\\x15\\x11\\x07\\n\\x174%\\n\\x01\\x07*\\x02\\x1c\\x1f\\x07\\x01\\x159.\\x16\\n2\\x0f\\n>\\x1b%\\x0246\\x1b\\x1c\\x13\\x13.)\\x16=\\x0f\"\\x17\\x078\\x04\\x1e6$\\x00\\x1c\\x13\\x06\\x00\\n \\t\\x08\\x178$\\x0b\\x1e\\x1e\\r\\x1c\\x01\\x15,\\x005<\\x06\\x08?\\x118\\x16\\x184\\r#\\x1d\\x1a,(\\x1c \\x1b\\x0e\\x15\\x11\\x07\\n\\x174%\\n\\x01\\x07*\\x02\\x1c\\x1f\\x07\\x01\\x159.\\x16\\n2\\x0f\\n>\\x1b%\\x0246\\x1b\\x1c\\x13\\x13.)\\x16=\\x0f\"\\x17\\x078\\x04\\x1e6$\\x00\\x1c\\x13\\x06\\x00\\n \\t\\x08\\x178$\\x0b\\x1e\\x1e\\r\\x1c\\x01\\x15,\\x005<\\x06\\x08?\\x118\\x16\\x184\\r#\\x1d\\x1a,(\\x1c \\x1b\\x0e\\x15\\x11\\x07\\n\\x174%\\n\\x01\\x07*\\x02\\x1c\\x1f\\x07\\x01\\x159.\\x16\\n2\\x0f\\n>\\x1b%\\x0246\\x1b\\x1c\\x13\\x13.)\\x16=\\x0f\"\\x17\\x078\\x04\\x1e6$\\x00\\x1c\\x13\\x06\\x00\\n \\t\\x08\\x178$\\x0b\\x1e\\x1e\\r\\x1c\\x01\\x15,\\x005<\\x06\\x08?\\x118\\x16\\x184\\r#\\x1d\\x1a,(\\x1c \\x1b\\x0e\\x15\\x11\\x07\\n\\x174%\\n\\x01\\x07*\\x02\\x1c\\x1f\\x07\\x01\\x159.\\x16\\n2\\x0f\\n>\\x1b%\\x0246\\x1b\\x1c\\x13\\x13.)\\x16=\\x0f\"\\x17\\x078\\x04\\x1e6$\\x00\\x1c\\x13\\x06\\x00\\n \\t\\x08\\x178$\\x0b\\x1e\\x1e\\r\\x1c\\x01\\x15,\\x005<\\x06\\x08?\\x118\\x16\\x184\\r#\\x1d\\x1a,(\\x1c \\x1b\\x0e\\x15\\x11\\x07\\n\\x174%\\n\\x01\\x07*\\x02\\x1c\\x1f\\x07\\x01\\x159.\\x16\\n2\\x0f\\n>\\x1b%\\x0246\\x1b\\x1c\\x13\\x13.)\\x16=\\x0f\"\\x17\\x078\\x04\\x1e6$\\x00\\x1c\\x13\\x06\\x00\\n \\t\\x08\\x178$\\x0b\\x1e\\x1e\\r\\x1c\\x01\\x15,\\x005<\\x06\\x08?\\x118\\x16\\x184\\r#\\x1d\\x1a,(\\x1c \\x1b\\x0e\\x15\\x11\\x07\\n\\x174%\\n\\x01\\x07*\\x02\\x1c\\x1f\\x07\\x01\\x159.\\x16\\n2\\x0f\\n>\\x1b%\\x0246\\x1b\\x1c\\x13\\x13.)\\x16=\\x0f\"\\x17\\x078\\x04\\x1e6$\\x00\\x1c\\x13\\x06\\x00\\n \\t\\x08\\x178$\\x0b\\x1e\\x1e\\r\\x1c\\x01\\x15,\\x005<\\x06\\x08?\\x118\\x16\\x184\\r#\\x1d\\x1a,(\\x1c \\x1b\\x0e\\x15\\x11\\x07\\n\\x174%\\n\\x01\\x07*\\x02\\x1c\\x1f\\x07\\x01\\x159.\\x16\\n2\\x0f\\n>\\x1b%\\x0246\\x1b\\x1c\\x13\\x13.)\\x16=\\x0f\"\\x17\\x078\\x04\\x1e6$\\x00\\x1c\\x13\\x06\\x00\\n \\t\\x08\\x178$\\x0b\\x1e\\x1e\\r\\x1c\\x01\\x15,\\x005<\\x06\\x08?\\x118\\x16\\x184\\r#\\x1d\\x1a,(\\x1c \\x1b\\x0e\\x15\\x11\\x07\\n\\x174%\\n\\x01\\x07*\\x02\\x1c\\x1f\\x07\\x01\\x159.\\x16\\n2\\x0f\\n>\\x1b%\\x0246\\x1b\\x1c\\x13\\x13.)\\x16=\\x0f\"\\x17\\x078\\x04\\x1e6$\\x00\\x1c\\x13\\x06\\x00\\n \\t\\x08\\x178$\\x0b\\x1e\\x1e\\r\\x1c\\x01\\x15,\\x005<\\x06\\x08?\\x118\\x16\\x184\\r#\\x1d\\x1a,(\\x1c \\x1b\\x0e\\x15\\x11\\x07\\n\\x174%\\n\\x01\\x07*\\x02\\x1c\\x1f\\x07\\x01\\x159.\\x16\\n2\\x0f\\n>\\x1b%\\x0246\\x1b\\x1c\\x13\\x13.)\\x16=\\x0f\"\\x17\\x078\\x04\\x1e6$\\x00\\x1c\\x13\\x06\\x00\\n \\t\\x08\\x178$\\x0b\\x1e\\x1e\\r\\x1c\\x01\\x15,\\x005<\\x06\\x08?\\x118\\x16\\x184\\r#\\x1d\\x1a,(\\x1c \\x1b\\x0e\\x15\\x11\\x07\\n\\x174%\\n\\x01\\x07*\\x02\\x1c\\x1f\\x07\\x01\\x159.\\x16\\n2\\x0f\\n>\\x1b%\\x0246\\x1b\\x1c\\x13\\x13.)\\x16=\\x0f\"\\x17\\x078\\x04\\x1e6$\\x00\\x1c\\x13\\x06\\x00\\n \\t\\x08\\x178$\\x0b\\x1e\\x1e\\r\\x1c\\x01\\x15,\\x005<\\x06\\x08?\\x118\\x16\\x184\\r#\\x1d\\x1a,(\\x1c \\x1b\\x0e\\x15\\x11\\x07\\n\\x174%\\n\\x01\\x07*\\x02\\x1c\\x1f\\x07\\x01\\x159.\\x16\\n2\\x0f\\n>\\x1b%\\x0246\\x1b\\x1c\\x13\\x13.)\\x16=\\x0f\"\\x17\\x078\\x04\\x1e6$\\x00\\x1c\\x13\\x06\\x00\\n \\t\\x08\\x178$\\x0b\\x1e\\x1e\\r\\x1c\\x01\\x15,\\x005<\\x06\\x08?\\x118\\x16\\x184\\r#\\x1d\\x1a,(\\x1c \\x1b\\x0e\\x15\\x11\\x07\\n\\x174%\\n\\x01\\x07*\\x02\\x1c\\x1f\\x07\\x01\\x159.\\x16\\n2\\x0f\\n>\\x1b%\\x0246\\x1b\\x1c\\x13\\x13.)\\x16=\\x0f\"\\x17\\x078\\x04\\x1e6$\\x00\\x1c\\x13\\x06\\x00\\n \\t\\x08\\x178$\\x0b\\x1e\\x1e\\r\\x1c\\x01\\x15,\\x005<\\x06\\x08?\\x118\\x16\\x184\\r#\\x1d\\x1a,(\\x1c \\x1b\\x0e\\x15\\x11\\x07\\n\\x174%\\n\\x01\\x07*\\x02\\x1c\\x1f\\x07\\x01\\x159.\\x16\\n2\\x0f\\n>\\x1b%\\x0246\\x1b\\x1c\\x13\\x13.)\\x16=\\x0f\"\\x17\\x078\\x04\\x1e6$\\x00\\x1c\\x13\\x06\\x00\\n \\t\\x08\\x178$\\x0b\\x1e\\x1e\\r\\x1c\\x01\\x15,\\x005<\\x06\\x08?\\x118\\x16\\x184\\r#\\x1d\\x1a,(\\x1c \\x1b\\x0e\\x15\\x11\\x07\\n\\x174%\\n\\x01\\x07*\\x02\\x1c\\x1f\\x07\\x01\\x159.\\x16\\n2\\x0f\\n>\\x1b%\\x0246\\x1b\\x1c\\x13\\x13.)\\x16=\\x0f\"\\x17\\x078\\x04\\x1e6$\\x00\\x1c\\x13\\x06\\x00\\n \\t\\x08\\x178$\\x0b\\x1e\\x1e\\r\\x1c\\x01\\x15,\\x005<\\x06\\x08?\\x118\\x16\\x184\\r#\\x1d\\x1a,(\\x1c \\x1b\\x0e\\x15\\x11\\x07\\n\\x174%\\n\\x01\\x07*\\x02\\x1c\\x1f\\x07\\x01\\x159.\\x16\\n2\\x0f\\n>\\x1b%\\x0246\\x1b\\x1c\\x13\\x13.)\\x16=\\x0f\"\\x17\\x078\\x04\\x1e6$\\x00\\x1c\\x13\\x06\\x00\\n \\t\\x08\\x178$\\x0b\\x1e\\x1e\\r\\x1c\\x01\\x15,\\x005<\\x06\\x08?\\x118\\x16\\x184\\r#\\x1d\\x1a,(\\x1c \\x1b\\x0e\\x15\\x11\\x07\\n\\x174%\\n\\x01\\x07*\\x02\\x1c\\x1f\\x07\\x01\\x159.\\x16\\n2\\x0f\\n>\\x1b%\\x0246\\x1b\\x1c\\x13\\x13.)\\x16=\\x0f\"\\x17\\x078\\x04\\x1e6$\\x00\\x1c\\x13\\x06\\x00\\n \\t\\x08\\x178$\\x0b\\x1e\\x1e\\r\\x1c\\x01\\x15,\\x005<\\x06\\x08?\\x118\\x16\\x184\\r#\\x1d\\x1a,(\\x1c \\x1b\\x0e\\x15\\x11\\x07\\n\\x174%\\n\\x01\\x07*\\x02\\x1c\\x1f\\x07\\x01\\x159.\\x16\\n2\\x0f\\n>\\x1b%\\x0246\\x1b\\x1c\\x13\\x13.)\\x16=\\x0f\"\\x17\\x078\\x04\\x1e6$\\x00\\x1c\\x13\\x06\\x00\\n \\t\\x08\\x178$\\x0b\\x1e\\x1e\\r\\x1c\\x01\\x15,\\x005<\\x06\\x08?\\x118\\x16\\x184\\r#\\x1d\\x1a,(\\x1c \\x1b\\x0e\\x15\\x11\\x07\\n\\x174%\\n\\x01\\x07*\\x02\\x1c\\x1f\\x07\\x01\\x159.\\x16\\n2\\x0f\\n>\\x1b%\\x0246\\x1b\\x1c\\x13\\x13.)\\x16=\\x0f\"\\x17\\x078\\x04\\x1e6$\\x00\\x1c\\x13\\x06\\x00\\n \\t\\x08\\x178$\\x0b\\x1e\\x1e\\r\\x1c\\x01\\x15,\\x005<\\x06\\x08?\\x118\\x16\\x184\\r#\\x1d\\x1a,(\\x1c \\x1b\\x0e\\x15\\x11\\x07\\n\\x174%\\n\\x01\\x07*\\x02\\x1c\\x1f\\x07\\x01\\x159.\\x16\\n2\\x0f\\n>\\x1b%\\x0246\\x1b\\x1c\\x13\\x13.)\\x16=\\x0f\"\\x17\\x078\\x04\\x1e6$\\x00\\x1c\\x13\\x06\\x00\\n \\t\\x08\\x178$\\x0b\\x1e\\x1e\\r\\x1c\\x01\\x15,\\x005<\\x06\\x08?\\x118\\x16\\x184\\r#\\x1d\\x1a,(\\x1c \\x1b\\x0e\\x15\\x11\\x07\\n\\x174%\\n\\x01\\x07*\\x02\\x1c\\x1f\\x07\\x01\\x159.\\x16\\n2\\x0f\\n>\\x1b%\\x0246\\x1b\\x1c\\x13\\x13.)\\x16=\\x0f\"\\x17\\x078\\x04\\x1e6$\\x00\\x1c\\x13\\x06\\x00\\n \\t\\x08\\x178$\\x0b\\x1e\\x1e\\r\\x1c\\x01\\x15,\\x005<\\x06\\x08?\\x118\\x16\\x184\\r#\\x1d\\x1a,(\\x1c \\x1b\\x0e\\x15\\x11\\x07\\n\\x174%\\n\\x01\\x07*\\x02\\x1c\\x1f\\x07\\x01\\x159.\\x16\\n2\\x0f\\n>\\x1b%\\x0246\\x1b\\x1c\\x13\\x13.)\\x16=\\x0f\"\\x17\\x078\\x04\\x1e6$\\x00\\x1c\\x13\\x06\\x00\\n \\t\\x08\\x178$\\x0b\\x1e\\x1e\\r\\x1c\\x01\\x15,\\x005<\\x06\\x08?\\x118\\x16\\x184\\r#\\x1d\\x1a,(\\x1c \\x1b\\x0e\\x15\\x11\\x07\\n\\x174%\\n\\x01\\x07*\\x02\\x1c\\x1f\\x07\\x01\\x159.\\x16\\n2\\x0f\\n>\\x1b%\\x0246\\x1b\\x1c\\x13\\x13.)\\x16=\\x0f\"\\x17\\x078\\x04\\x1e6$\\x00\\x1c\\x13\\x06\\x00\\n \\t\\x08\\x178$\\x0b\\x1e\\x1e\\r\\x1c\\x01\\x15,\\x005<\\x06\\x08?\\x118\\x16\\x184\\r#\\x1d\\x1a,(\\x1c \\x1b\\x0e\\x15\\x11\\x07\\n\\x174%\\n\\x01\\x07*\\x02\\x1c\\x1f\\x07\\x01\\x159.\\x16\\n2\\x0f\\n>\\x1b%\\x0246\\x1b\\x1c\\x13\\x13.)\\x16=\\x0f\"\\x17\\x078\\x04\\x1e6$\\x00\\x1c\\x13\\x06\\x00\\n \\t\\x08\\x178$\\x0b\\x1e\\x1e\\r\\x1c\\x01\\x15,\\x005<\\x06\\x08?\\x118\\x16\\x184\\r#\\x1d\\x1a,(\\x1c \\x1b\\x0e\\x15\\x11\\x07\\n\\x174%\\n\\x01\\x07*\\x02\\x1c\\x1f\\x07\\x01\\x159.\\x16\\n2\\x0f\\n>\\x1b%\\x0246\\x1b\\x1c\\x13\\x13.)\\x16=\\x0f\"\\x17\\x078\\x04\\x1e6$\\x00\\x1c\\x13\\x06\\x00\\n \\t\\x08\\x178$\\x0b\\x1e\\x1e\\r\\x1c\\x01\\x15,\\x005<\\x06\\x08?\\x118\\x16\\x184\\r#\\x1d\\x1a,(\\x1c \\x1b\\x0e\\x15\\x11\\x07\\n\\x174%\\n\\x01\\x07*\\x02\\x1c\\x1f\\x07\\x01\\x159.\\x16\\n2\\x0f\\n>\\x1b%\\x0246\\x1b\\x1c\\x13\\x13.)\\x16=\\x0f\"\\x17\\x078\\x04\\x1e6$\\x00\\x1c\\x13\\x06\\x00\\n \\t\\x08\\x178$\\x0b\\x1e\\x1e\\r\\x1c\\x01\\x15,\\x005<\\x06\\x08?\\x118\\x16\\x184\\r#\\x1d\\x1a,(\\x1c \\x1b\\x0e\\x15\\x11\\x07\\n\\x174%\\n\\x01\\x07*\\x02\\x1c\\x1f\\x07\\x01\\x159.\\x16\\n2\\x0f\\n>\\x1b%\\x0246\\x1b\\x1c\\x13\\x13.)\\x16=\\x0f\"\\x17\\x078\\x04\\x1e6$\\x00\\x1c\\x13\\x06\\x00\\n \\t\\x08\\x178$\\x0b\\x1e\\x1e\\r\\x1c\\x01\\x15,\\x005<\\x06\\x08?\\x118\\x16\\x184\\r#\\x1d\\x1a,(\\x1c \\x1b\\x0e\\x15\\x11\\x07\\n\\x174%\\n\\x01\\x07*\\x02\\x1c\\x1f\\x07\\x01\\x159.\\x16\\n2\\x0f\\n>\\x1b%\\x0246\\x1b\\x1c\\x13\\x13.)\\x16=\\x0f\"\\x17\\x078\\x04\\x1e6$\\x00\\x1c\\x13\\x06\\x00\\n \\t\\x08\\x178$\\x0b\\x1e\\x1e\\r\\x1c\\x01\\x15,\\x005<\\x06\\x08?\\x118\\x16\\x184\\r#\\x1d\\x1a,(\\x1c \\x1b\\x0e\\x15\\x11\\x07\\n\\x174%\\n\\x01\\x07*\\x02\\x1c\\x1f\\x07\\x01\\x159.\\x16\\n2\\x0f\\n>\\x1b%\\x0246\\x1b\\x1c\\x13\\x13.)\\x16=\\x0f\"\\x17\\x078\\x04\\x1e6$\\x00\\x1c\\x13\\x06\\x00\\n \\t\\x08\\x178$\\x0b\\x1e\\x1e\\r\\x1c\\x01\\x15,\\x005<\\x06\\x08?\\x118\\x16\\x184\\r#\\x1d\\x1a,(\\x1c \\x1b\\x0e\\x15\\x11\\x07\\n\\x174%\\n\\x01\\x07*\\x02\\x1c\\x1f\\x07\\x01\\x159.\\x16\\n2\\x0f\\n>\\x1b%\\x0246\\x1b\\x1c\\x13\\x13.)\\x16=\\x0f\"\\x17\\x078\\x04\\x1e6$\\x00\\x1c\\x13\\x06\\x00\\n \\t\\x08\\x178$\\x0b\\x1e\\x1e\\r\\x1c\\x01\\x15,\\x005<\\x06\\x08?\\x118\\x16\\x184\\r#\\x1d\\x1a,(\\x1c \\x1b\\x0e\\x15\\x11\\x07\\n\\x174%\\n\\x01\\x07*\\x02\\x1c\\x1f\\x07\\x01\\x159.\\x16\\n2\\x0f\\n>\\x1b%\\x0246\\x1b\\x1c\\x13\\x13.)\\x16=\\x0f\"\\x17\\x078\\x04\\x1e6$\\x00\\x1c\\x13\\x06\\x00\\n \\t\\x08\\x178$\\x0b\\x1e\\x1e\\r\\x1c\\x01\\x15,\\x005<\\x06\\x08?\\x118\\x16\\x184\\r#\\x1d\\x1a,(\\x1c \\x1b\\x0e\\x15\\x11\\x07\\n\\x174%\\n\\x01\\x07*\\x02\\x1c\\x1f\\x07\\x01\\x159.\\x16\\n2\\x0f\\n>\\x1b%\\x0246\\x1b\\x1c\\x13\\x13.)\\x16=\\x0f\"\\x17\\x078\\x04\\x1e6$\\x00\\x1c\\x13\\x06\\x00\\n \\t\\x08\\x178$\\x0b\\x1e\\x1e\\r\\x1c\\x01\\x15,\\x005<\\x06\\x08?\\x118\\x16\\x184\\r#\\x1d\\x1a,(\\x1c \\x1b\\x0e\\x15\\x11\\x07\\n\\x174%\\n\\x01\\x07*\\x02\\x1c\\x1f\\x07\\x01\\x159.\\x16\\n2\\x0f\\n>\\x1b%\\x0246\\x1b\\x1c\\x13\\x13.)\\x16=\\x0f\"\\x17\\x078\\x04\\x1e6$\\x00\\x1c\\x13\\x06\\x00\\n \\t\\x08\\x178$\\x0b\\x1e\\x1e\\r\\x1c\\x01\\x15,\\x005<\\x06\\x08?\\x118\\x16\\x184\\r#\\x1d\\x1a,(\\x1c \\x1b\\x0e\\x15\\x11\\x07\\n\\x174%\\n\\x01\\x07*\\x02\\x1c\\x1f\\x07\\x01\\x159.\\x16\\n2\\x0f\\n>\\x1b%\\x0246\\x1b\\x1c\\x13\\x13.)\\x16=\\x0f\"\\x17\\x078\\x04\\x1e6$\\x00\\x1c\\x13\\x06\\x00\\n \\t\\x08\\x178$\\x0b\\x1e\\x1e\\r\\x1c\\x01\\x15,\\x005<\\x06\\x08?\\x118\\x16\\x184\\r#\\x1d\\x1a,(\\x1c \\x1b\\x0e\\x15\\x11\\x07\\n\\x174%\\n\\x01\\x07*\\x02\\x1c\\x1f\\x07\\x01\\x159.\\x16\\n2\\x0f\\n>\\x1b%\\x0246\\x1b\\x1c\\x13\\x13.)\\x16=\\x0f\"\\x17\\x078\\x04\\x1e6$\\x00\\x1c\\x13\\x06\\x00\\n \\t\\x08\\x178$\\x0b\\x1e\\x1e\\r\\x1c\\x01\\x15,\\x005<\\x06\\x08?\\x118\\x16\\x184\\r#\\x1d\\x1a,(\\x1c \\x1b\\x0e\\x15\\x11\\x07\\n\\x174%\\n\\x01\\x07*\\x02\\x1c\\x1f\\x07\\x01\\x159.\\x16\\n2\\x0f\\n>\\x1b%\\x0246\\x1b\\x1c\\x13\\x13.)\\x16=\\x0f\"\\x17\\x078\\x04\\x1e6$\\x00\\x1c\\x13\\x06\\x00\\n \\t\\x08\\x178$\\x0b\\x1e\\x1e\\r\\x1c\\x01\\x15,\\x005<\\x06\\x08?\\x118\\x16\\x184\\r#\\x1d\\x1a,(\\x1c \\x1b\\x0e\\x15\\x11\\x07\\n\\x174%\\n\\x01\\x07*\\x02\\x1c\\x1f\\x07\\x01\\x159.\\x16\\n2\\x0f\\n>\\x1b%\\x0246\\x1b\\x1c\\x13\\x13.)\\x16=\\x0f\"\\x17\\x078\\x04\\x1e6$\\x00\\x1c\\x13\\x06\\x00\\n \\t\\x08\\x178$\\x0b\\x1e\\x1e\\r\\x1c\\x01\\x15,\\x005<\\x06\\x08?\\x118\\x16\\x184\\r#\\x1d\\x1a,(\\x1c \\x1b\\x0e\\x15\\x11\\x07\\n\\x174%\\n\\x01\\x07*\\x02\\x1c\\x1f\\x07\\x01\\x159.\\x16\\n2\\x0f\\n>\\x1b%\\x0246\\x1b\\x1c\\x13\\x13.)\\x16=\\x0f\"\\x17\\x078\\x04\\x1e6$\\x00\\x1c\\x13\\x06\\x00\\n \\t\\x08\\x178$\\x0b\\x1e\\x1e\\r\\x1c\\x01\\x15,\\x005<\\x06\\x08?\\x118\\x16\\x184\\r#\\x1d\\x1a,(\\x1c \\x1b\\x0e\\x15\\x11\\x07\\n\\x174%\\n\\x01\\x07*\\x02\\x1c\\x1f\\x07\\x01\\x159.\\x16\\n2\\x0f\\n>\\x1b%\\x0246\\x1b\\x1c\\x13\\x13.)\\x16=\\x0f\"\\x17\\x078\\x04\\x1e6$\\x00\\x1c\\x13\\x06\\x00\\n \\t\\x08\\x178$\\x0b\\x1e\\x1e\\r\\x1c\\x01\\x15,\\x005<\\x06\\x08?\\x118\\x16\\x184\\r#\\x1d\\x1a,(\\x1c \\x1b\\x0e\\x15\\x11\\x07\\n\\x174%\\n\\x01\\x07*\\x02\\x1c\\x1f\\x07\\x01\\x159.\\x16\\n2\\x0f\\n>\\x1b%\\x0246\\x1b\\x1c\\x13\\x13.)\\x16=\\x0f\"\\x17\\x078\\x04\\x1e6$\\x00\\x1c\\x13\\x06\\x00\\n \\t\\x08\\x178$\\x0b\\x1e\\x1e\\r\\x1c\\x01\\x15,\\x005<\\x06\\x08?\\x118\\x16\\x184\\r#\\x1d\\x1a,(\\x1c \\x1b\\x0e\\x15\\x11\\x07\\n\\x174%\\n\\x01\\x07*\\x02\\x1c\\x1f\\x07\\x01\\x159.\\x16\\n2\\x0f\\n>\\x1b%\\x0246\\x1b\\x1c\\x13\\x13.)\\x16=\\x0f\"\\x17\\x078\\x04\\x1e6$\\x00\\x1c\\x13\\x06\\x00\\n \\t\\x08\\x178$\\x0b\\x1e\\x1e\\r\\x1c\\x01\\x15,\\x005<\\x06\\x08?\\x118\\x16\\x184\\r#\\x1d\\x1a,(\\x1c \\x1b\\x0e\\x15\\x11\\x07\\n\\x174%\\n\\x01\\x07*\\x02\\x1c\\x1f\\x07\\x01\\x159.\\x16\\n2\\x0f\\n>\\x1b%\\x0246\\x1b\\x1c\\x13\\x13.)\\x16=\\x0f\"\\x17\\x078\\x04\\x1e6$\\x00\\x1c\\x13\\x06\\x00\\n \\t\\x08\\x178$\\x0b\\x1e\\x1e\\r\\x1c\\x01\\x15,\\x005<\\x06\\x08?\\x118\\x16\\x184\\r#\\x1d\\x1a,(\\x1c \\x1b\\x0e\\x15\\x11\\x07\\n\\x174%\\n\\x01\\x07*\\x02\\x1c\\x1f\\x07\\x01\\x159.\\x16\\n2\\x0f\\n>\\x1b%\\x0246\\x1b\\x1c\\x13\\x13.)\\x16=\\x0f\"\\x17\\x078\\x04\\x1e6$\\x00\\x1c\\x13\\x06\\x00\\n \\t\\x08\\x178$\\x0b\\x1e\\x1e\\r\\x1c\\x01\\x15,\\x005<\\x06\\x08?\\x118\\x16\\x184\\r#\\x1d\\x1a,(\\x1c \\x1b\\x0e\\x15\\x11\\x07\\n\\x174%\\n\\x01\\x07*\\x02\\x1c\\x1f\\x07\\x01\\x159.\\x16\\n2\\x0f\\n>\\x1b%\\x0246\\x1b\\x1c\\x13\\x13.)\\x16=\\x0f\"\\x17\\x078\\x04\\x1e6$\\x00\\x1c\\x13\\x06\\x00\\n \\t\\x08\\x178$\\x0b\\x1e\\x1e\\r\\x1c\\x01\\x15,\\x005<\\x06\\x08?\\x118\\x16\\x184\\r#\\x1d\\x1a,(\\x1c \\x1b\\x0e\\x15\\x11\\x07\\n\\x174%\\n\\x01\\x07*\\x02\\x1c\\x1f\\x07\\x01\\x159.\\x16\\n2\\x0f\\n>\\x1b%\\x0246\\x1b\\x1c\\x13\\x13.)\\x16=\\x0f\"\\x17\\x078\\x04\\x1e6$\\x00\\x1c\\x13\\x06\\x00\\n \\t\\x08\\x178$\\x0b\\x1e\\x1e\\r\\x1c\\x01\\x15,\\x005<\\x06\\x08?\\x118\\x16\\x184\\r#\\x1d\\x1a,(\\x1c \\x1b\\x0e\\x15\\x11\\x07\\n\\x174%\\n\\x01\\x07*\\x02\\x1c\\x1f\\x07\\x01\\x159.\\x16\\n2\\x0f\\n>\\x1b%\\x0246\\x1b\\x1c\\x13\\x13.)\\x16=\\x0f\"\\x17\\x078\\x04\\x1e6$\\x00\\x1c\\x13\\x06\\x00\\n \\t\\x08\\x178$\\x0b\\x1e\\x1e\\r\\x1c\\x01\\x15,\\x005<\\x06\\x08?\\x118\\x16\\x184\\r#\\x1d\\x1a,(\\x1c \\x1b\\x0e\\x15\\x11\\x07\\n\\x174%\\n\\x01\\x07*\\x02\\x1c\\x1f\\x07\\x01\\x159.\\x16\\n2\\x0f\\n>\\x1b%\\x0246\\x1b\\x1c\\x13\\x13.)\\x16=\\x0f\"\\x17\\x078\\x04\\x1e6$\\x00\\x1c\\x13\\x06\\x00\\n \\t\\x08\\x178$\\x0b\\x1e\\x1e\\r\\x1c\\x01\\x15,\\x005<\\x06\\x08?\\x118\\x16\\x184\\r#\\x1d\\x1a,(\\x1c \\x1b\\x0e\\x15\\x11\\x07\\n\\x174%\\n\\x01\\x07*\\x02\\x1c\\x1f\\x07\\x01\\x159.\\x16\\n2\\x0f\\n>\\x1b%\\x0246\\x1b\\x1c\\x13\\x13.)\\x16=\\x0f\"\\x17\\x078\\x04\\x1e6$\\x00\\x1c\\x13\\x06\\x00\\n \\t\\x08\\x178$\\x0b\\x1e\\x1e\\r\\x1c\\x01\\x15,\\x005<\\x06\\x08?\\x118\\x16\\x184\\r#\\x1d\\x1a,(\\x1c \\x1b\\x0e\\x15\\x11\\x07\\n\\x174%\\n\\x01\\x07*\\x02\\x1c\\x1f\\x07\\x01\\x159.\\x16\\n2\\x0f\\n>\\x1b%\\x0246\\x1b\\x1c\\x13\\x13.)\\x16=\\x0f\"\\x17\\x078\\x04\\x1e6$\\x00\\x1c\\x13\\x06\\x00\\n \\t\\x08\\x178$\\x0b\\x1e\\x1e\\r\\x1c\\x01\\x15,\\x005<\\x06\\x08?\\x118\\x16\\x184\\r#\\x1d\\x1a,(\\x1c \\x1b\\x0e\\x15\\x11\\x07\\n\\x174%\\n\\x01\\x07*\\x02\\x1c\\x1f\\x07\\x01\\x159.\\x16\\n2\\x0f\\n>\\x1b%\\x0246\\x1b\\x1c\\x13\\x13.)\\x16=\\x0f\"\\x17\\x078\\x04\\x1e6$\\x00\\x1c\\x13\\x06\\x00\\n \\t\\x08\\x178$\\x0b\\x1e\\x1e\\r\\x1c\\x01\\x15,\\x005<\\x06\\x08?\\x118\\x16\\x184\\r#\\x1d\\x1a,(\\x1c \\x1b\\x0e\\x15\\x11\\x07\\n\\x174%\\n\\x01\\x07*\\x02\\x1c\\x1f\\x07\\x01\\x159.\\x16\\n2\\x0f\\n>\\x1b%\\x0246\\x1b\\x1c\\x13\\x13.)\\x16=\\x0f\"\\x17\\x078\\x04\\x1e6$\\x00\\x1c\\x13\\x06\\x00\\n \\t\\x08\\x178$\\x0b\\x1e\\x1e\\r\\x1c\\x01\\x15,\\x005<\\x06\\x08?\\x118\\x16\\x184\\r#\\x1d\\x1a,(\\x1c \\x1b\\x0e\\x15\\x11\\x07\\n\\x174%\\n\\x01\\x07*\\x02\\x1c\\x1f\\x07\\x01\\x159.\\x16\\n2\\x0f\\n>\\x1b%\\x0246\\x1b\\x1c\\x13\\x13.)\\x16=\\x0f\"\\x17\\x078\\x04\\x1e6$\\x00\\x1c\\x13\\x06\\x00\\n \\t\\x08\\x178$\\x0b\\x1e\\x1e\\r\\x1c\\x01\\x15,\\x005<\\x06\\x08?\\x118\\x16\\x184\\r#\\x1d\\x1a,(\\x1c \\x1b\\x0e\\x15\\x11\\x07\\n\\x174%\\n\\x01\\x07*\\x02\\x1c\\x1f\\x07\\x01\\x159.\\x16\\n2\\x0f\\n>\\x1b%\\x0246\\x1b\\x1c\\x13\\x13.)\\x16=\\x0f\"\\x17\\x078\\x04\\x1e6$\\x00\\x1c\\x13\\x06\\x00\\n \\t\\x08\\x178$\\x0b\\x1e\\x1e\\r\\x1c\\x01\\x15,\\x005<\\x06\\x08?\\x118\\x16\\x184\\r#\\x1d\\x1a,(\\x1c \\x1b\\x0e\\x15\\x11\\x07\\n\\x174%\\n\\x01\\x07*\\x02\\x1c\\x1f\\x07\\x01\\x159.\\x16\\n2\\x0f\\n>\\x1b%\\x0246\\x1b\\x1c\\x13\\x13.)\\x16=\\x0f\"\\x17\\x078\\x04\\x1e6$\\x00\\x1c\\x13\\x06\\x00\\n \\t\\x08\\x178$\\x0b\\x1e\\x1e\\r\\x1c\\x01\\x15,\\x005<\\x06\\x08?\\x118\\x16\\x184\\r#\\x1d\\x1a,(\\x1c \\x1b\\x0e\\x15\\x11\\x07\\n\\x174%\\n\\x01\\x07*\\x02\\x1c\\x1f\\x07\\x01\\x159.\\x16\\n2\\x0f\\n>\\x1b%\\x0246\\x1b\\x1c\\x13\\x13.)\\x16=\\x0f\"\\x17\\x078\\x04\\x1e6$\\x00\\x1c\\x13\\x06\\x00\\n \\t\\x08\\x178$\\x0b\\x1e\\x1e\\r\\x1c\\x01\\x15,\\x005<\\x06\\x08?\\x118\\x16\\x184\\r#\\x1d\\x1a,(\\x1c \\x1b\\x0e\\x15\\x11\\x07\\n\\x174%\\n\\x01\\x07*\\x02\\x1c\\x1f\\x07\\x01\\x159.\\x16\\n2\\x0f\\n>\\x1b%\\x0246\\x1b\\x1c\\x13\\x13.)\\x16=\\x0f\"\\x17\\x078\\x04\\x1e6$\\x00\\x1c\\x13\\x06\\x00\\n \\t\\x08\\x178$\\x0b\\x1e\\x1e\\r\\x1c\\x01\\x15,\\x005<\\x06\\x08?\\x118\\x16\\x184\\r#\\x1d\\x1a,(\\x1c \\x1b\\x0e\\x15\\x11\\x07\\n\\x174%\\n\\x01\\x07*\\x02\\x1c\\x1f\\x07\\x01\\x159.\\x16\\n2\\x0f\\n>\\x1b%\\x0246\\x1b\\x1c\\x13\\x13.)\\x16=\\x0f\"\\x17\\x078\\x04\\x1e6$\\x00\\x1c\\x13\\x06\\x00\\n \\t\\x08\\x178$\\x0b\\x1e\\x1e\\r\\x1c\\x01\\x15,\\x005<\\x06\\x08?\\x118\\x16\\x184\\r#\\x1d\\x1a,(\\x1c \\x1b\\x0e\\x15\\x11\\x07\\n\\x174%\\n\\x01\\x07*\\x02\\x1c\\x1f\\x07\\x01\\x159.\\x16\\n2\\x0f\\n>\\x1b%\\x0246\\x1b\\x1c\\x13\\x13.)\\x16=\\x0f\"\\x17\\x078\\x04\\x1e6$\\x00\\x1c\\x13\\x06\\x00\\n \\t\\x08\\x178$\\x0b\\x1e\\x1e\\r\\x1c\\x01\\x15,\\x005<\\x06\\x08?\\x118\\x16\\x184\\r#\\x1d\\x1a,(\\x1c \\x1b\\x0e\\x15\\x11\\x07\\n\\x174%\\n\\x01\\x07*\\x02\\x1c\\x1f\\x07\\x01\\x159.\\x16\\n2\\x0f\\n>\\x1b%\\x0246\\x1b\\x1c\\x13\\x13.)\\x16=\\x0f\"\\x17\\x078\\x04\\x1e6$\\x00\\x1c\\x13\\x06\\x00\\n \\t\\x08\\x178$\\x0b\\x1e\\x1e\\r\\x1c\\x01\\x15,\\x005<\\x06\\x08?\\x118\\x16\\x184\\r#\\x1d\\x1a,(\\x1c \\x1b\\x0e\\x15\\x11\\x07\\n\\x174%\\n\\x01\\x07*\\x02\\x1c\\x1f\\x07\\x01\\x159.\\x16\\n2\\x0f\\n>\\x1b%\\x0246\\x1b\\x1c\\x13\\x13.)\\x16=\\x0f\"\\x17\\x078\\x04\\x1e6$\\x00\\x1c\\x13\\x06\\x00\\n \\t\\x08\\x178$\\x0b\\x1e\\x1e\\r\\x1c\\x01\\x15,\\x005<\\x06\\x08?\\x118\\x16\\x184\\r#\\x1d\\x1a,(\\x1c \\x1b\\x0e\\x15\\x11\\x07\\n\\x174%\\n\\x01\\x07*\\x02\\x1c\\x1f\\x07\\x01\\x159.\\x16\\n2\\x0f\\n>\\x1b%\\x0246\\x1b\\x1c\\x13\\x13.)\\x16=\\x0f\"\\x17\\x078\\x04\\x1e6$\\x00\\x1c\\x13\\x06\\x00\\n \\t\\x08\\x178$\\x0b\\x1e\\x1e\\r\\x1c\\x01\\x15,\\x005<\\x06\\x08?\\x118\\x16\\x184\\r#\\x1d\\x1a,(\\x1c \\x1b\\x0e\\x15\\x11\\x07\\n\\x174%\\n\\x01\\x07*\\x02\\x1c\\x1f\\x07\\x01\\x159.\\x16\\n2\\x0f\\n>\\x1b%\\x0246\\x1b\\x1c\\x13\\x13.)\\x16=\\x0f\"\\x17\\x078\\x04\\x1e6$\\x00\\x1c\\x13\\x06\\x00\\n \\t\\x08\\x178$\\x0b\\x1e\\x1e\\r\\x1c\\x01\\x15,\\x005<\\x06\\x08?\\x118\\x16\\x184\\r#\\x1d\\x1a,(\\x1c \\x1b\\x0e\\x15\\x11\\x07\\n\\x174%\\n\\x01\\x07*\\x02\\x1c\\x1f\\x07\\x01\\x159.\\x16\\n2\\x0f\\n>\\x1b%\\x0246\\x1b\\x1c\\x13\\x13.)\\x16=\\x0f\"\\x17\\x078\\x04\\x1e6$\\x00\\x1c\\x13\\x06\\x00\\n \\t\\x08\\x178$\\x0b\\x1e\\x1e\\r\\x1c\\x01\\x15,\\x005<\\x06\\x08?\\x118\\x16\\x184\\r#\\x1d\\x1a,(\\x1c \\x1b\\x0e\\x15\\x11\\x07\\n\\x174%\\n\\x01\\x07*\\x02\\x1c\\x1f\\x07\\x01\\x159.\\x16\\n2\\x0f\\n>\\x1b%\\x0246\\x1b\\x1c\\x13\\x13.)\\x16=\\x0f\"\\x17\\x078\\x04\\x1e6$\\x00\\x1c\\x13\\x06\\x00\\n \\t\\x08\\x178$\\x0b\\x1e\\x1e\\r\\x1c\\x01\\x15,\\x005<\\x06\\x08?\\x118\\x16\\x184\\r#\\x1d\\x1a,(\\x1c \\x1b\\x0e\\x15\\x11\\x07\\n\\x174%\\n\\x01\\x07*\\x02\\x1c\\x1f\\x07\\x01\\x159.\\x16\\n2\\x0f\\n>\\x1b%\\x0246\\x1b\\x1c\\x13\\x13.)\\x16=\\x0f\"\\x17\\x078\\x04\\x1e6$\\x00\\x1c\\x13\\x06\\x00\\n \\t\\x08\\x178$\\x0b\\x1e\\x1e\\r\\x1c\\x01\\x15,\\x005<\\x06\\x08?\\x118\\x16\\x184\\r#\\x1d\\x1a,(\\x1c \\x1b\\x0e\\x15\\x11\\x07\\n\\x174%\\n\\x01\\x07*\\x02\\x1c\\x1f\\x07\\x01\\x159.\\x16\\n2\\x0f\\n>\\x1b%\\x0246\\x1b\\x1c\\x13\\x13.)\\x16=\\x0f\"\\x17\\x078\\x04\\x1e6$\\x00\\x1c\\x13\\x06\\x00\\n \\t\\x08\\x178$\\x0b\\x1e\\x1e\\r\\x1c\\x01\\x15,\\x005<\\x06\\x08?\\x118\\x16\\x184\\r#\\x1d\\x1a,(\\x1c \\x1b\\x0e\\x15\\x11\\x07\\n\\x174%\\n\\x01\\x07*\\x02\\x1c\\x1f\\x07\\x01\\x159.\\x16\\n2\\x0f\\n>\\x1b%\\x0246\\x1b\\x1c\\x13\\x13.)\\x16=\\x0f\"\\x17\\x078\\x04\\x1e6$\\x00\\x1c\\x13\\x06\\x00\\n \\t\\x08\\x178$\\x0b\\x1e\\x1e\\r\\x1c\\x01\\x15,\\x005<\\x06\\x08?\\x118\\x16\\x184\\r#\\x1d\\x1a,(\\x1c \\x1b\\x0e\\x15\\x11\\x07\\n\\x174%\\n\\x01\\x07*\\x02\\x1c\\x1f\\x07\\x01\\x159.\\x16\\n2\\x0f\\n>\\x1b%\\x0246\\x1b\\x1c\\x13\\x13.)\\x16=\\x0f\"\\x17\\x078\\x04\\x1e6$\\x00\\x1c\\x13\\x06\\x00\\n \\t\\x08\\x178$\\x0b\\x1e\\x1e\\r\\x1c\\x01\\x15,\\x005<\\x06\\x08?\\x118\\x16\\x184\\r#\\x1d\\x1a,(\\x1c \\x1b\\x0e\\x15\\x11\\x07\\n\\x174%\\n\\x01\\x07*\\x02\\x1c\\x1f\\x07\\x01\\x159.\\x16\\n2\\x0f\\n>\\x1b%\\x0246\\x1b\\x1c\\x13\\x13.)\\x16=\\x0f\"\\x17\\x078\\x04\\x1e6$\\x00\\x1c\\x13\\x06\\x00\\n \\t\\x08\\x178$\\x0b\\x1e\\x1e\\r\\x1c\\x01\\x15,\\x005<\\x06\\x08?\\x118\\x16\\x184\\r#\\x1d\\x1a,(\\x1c \\x1b\\x0e\\x15\\x11\\x07\\n\\x174%\\n\\x01\\x07*\\x02\\x1c\\x1f\\x07\\x01\\x159.\\x16\\n2\\x0f\\n>\\x1b%\\x0246\\x1b\\x1c\\x13\\x13.)\\x16=\\x0f\"\\x17\\x078\\x04\\x1e6$\\x00\\x1c\\x13\\x06\\x00\\n \\t\\x08\\x178$\\x0b\\x1e\\x1e\\r\\x1c\\x01\\x15,\\x005<\\x06\\x08?\\x118\\x16\\x184\\r#\\x1d\\x1a,(\\x1c \\x1b\\x0e\\x15\\x11\\x07\\n\\x174%\\n\\x01\\x07*\\x02\\x1c\\x1f\\x07\\x01\\x159.\\x16\\n2\\x0f\\n>\\x1b%\\x0246\\x1b\\x1c\\x13\\x13.)\\x16=\\x0f\"\\x17\\x078\\x04\\x1e6$\\x00\\x1c\\x13\\x06\\x00\\n \\t\\x08\\x178$\\x0b\\x1e\\x1e\\r\\x1c\\x01\\x15,\\x005<\\x06\\x08?\\x118\\x16\\x184\\r#\\x1d\\x1a,(\\x1c \\x1b\\x0e\\x15\\x11\\x07\\n\\x174%\\n\\x01\\x07*\\x02\\x1c\\x1f\\x07\\x01\\x159.\\x16\\n2\\x0f\\n>\\x1b%\\x0246\\x1b\\x1c\\x13\\x13.)\\x16=\\x0f\"\\x17\\x078\\x04\\x1e6$\\x00\\x1c\\x13\\x06\\x00\\n \\t\\x08\\x178$\\x0b\\x1e\\x1e\\r\\x1c\\x01\\x15,\\x005<\\x06\\x08?\\x118\\x16\\x184\\r#\\x1d\\x1a,(\\x1c \\x1b\\x0e\\x15\\x11\\x07\\n\\x174%\\n\\x01\\x07*\\x02\\x1c\\x1f\\x07\\x01\\x159.\\x16\\n2\\x0f\\n>\\x1b%\\x0246\\x1b\\x1c\\x13\\x13.)\\x16=\\x0f\"\\x17\\x078\\x04\\x1e6$\\x00\\x1c\\x13\\x06\\x00\\n \\t\\x08\\x178$\\x0b\\x1e\\x1e\\r\\x1c\\x01\\x15,\\x005<\\x06\\x08?\\x118\\x16\\x184\\r#\\x1d\\x1a,(\\x1c \\x1b\\x0e\\x15\\x11\\x07\\n\\x174%\\n\\x01\\x07*\\x02\\x1c'\n    assert candidate(\"   \", \"   \") == '\\x00\\x00\\x00'\n    assert candidate(\"\\n\\t\\r\", \"abc\") == 'kkn'\n    assert candidate(\"Encrypt me!\", \"1234567890\") == 't\\\\PFLFC\\x18TU\\x10'\n    assert candidate(\"Line\\nBreak\", \"Key\") == '\\x07\\x0c\\x17.o;9\\x00\\x18 '\n    assert candidate(\"a\"*10000, \"b\") == '\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03'\n    assert candidate(\"Hello, World!\", \"secret\") == ';\\x00\\x0f\\x1e\\nXS2\\x0c\\x00\\t\\x10R'\n    assert candidate(\"Tab\\tCharacter\", \"TabKey\") == '\\x00\\x00\\x00B&\\x115\\x13\\x03(\\x11\\x1c&'\n", "language": "python"}
{"task_id": "43d84e7b-d0b5-4c39-a4c2-52ee64fdb1184670511728276680437", "prompt": "I'm your coding assistant. I'll finish the function you provide so it's immediately executable in a code block. I'll work strictly within the function boundaries and use only the imported libraries. Any additional components will be nested within the main function.\n\n```python\ndef decode_alien_message(message: str) -> int:\n    \"\"\"\n    You are a cryptographer working for SETI (Search for Extraterrestrial Intelligence).\n    An alien transmission has been received, encoded as a string of digits.\n    Your task is to decode the message and find out how many different ways it can be translated\n    to human-readable text.\n\n    The decoding rule is:\n    'A' -> 1, 'B' -> 2, 'C' -> 3, ..., 'Z' -> 26\n\n    A message can be decoded in multiple ways. For example, \"11\" could be decoded as \"AA\" (1,1) or \"K\" (11).\n    Implement a function that takes the alien message as a string and returns the number of possible decodings.\n\n    Note: The input string may contain leading zero(s). An empty string is considered to have one decoding.\n\n\n    [EXAMPLES]\n    \n    assert candidate(\"06\") == 0\n    assert candidate(\"10\") == 1\n\n    [/EXAMPLES]\n    \"\"\"\n```\n", "entry_point": "decode_alien_message", "solution": "def decode_alien_message(message: str) -> int:\n    \"\"\"\n    You are a cryptographer working for SETI (Search for Extraterrestrial Intelligence).\n    An alien transmission has been received, encoded as a string of digits.\n    Your task is to decode the message and find out how many different ways it can be translated\n    to human-readable text.\n\n    The decoding rule is:\n    'A' -> 1, 'B' -> 2, 'C' -> 3, ..., 'Z' -> 26\n\n    A message can be decoded in multiple ways. For example, \"11\" could be decoded as \"AA\" (1,1) or \"K\" (11).\n    Implement a function that takes the alien message as a string and returns the number of possible decodings.\n\n    Note: The input string may contain leading zero(s). An empty string is considered to have one decoding.\n\n\n    [EXAMPLES]\n    \n    assert candidate(\"06\") == 0\n    assert candidate(\"10\") == 1\n\n    [/EXAMPLES]\n    \"\"\"\n    if not message:\n        return 1\n\n    n = len(message)\n    dp = [0] * (n + 1)\n    dp[0] = 1\n    dp[1] = 1 if message[0] != '0' else 0\n\n    for i in range(2, n + 1):\n        # Check if the current digit is valid (not zero)\n        if message[i - 1] != '0':\n            dp[i] += dp[i - 1]\n\n        # Check if the last two digits form a valid letter (10-26)\n        two_digit = int(message[i - 2:i])\n        if 10 <= two_digit <= 26:\n            dp[i] += dp[i - 2]\n\n    return dp[n]\n\n", "test": "def check(candidate):\n    assert candidate(\"111111\") == 13\n    assert candidate(\"0\") == 0\n    assert candidate(\"30\") == 0\n    assert candidate(\"9999999999\") == 1\n    assert candidate(\"123\") == 3\n    assert candidate(\"226\") == 3\n    assert candidate(\"01\") == 0\n    assert candidate(\"2611055518\") == 4\n    assert candidate(\"10\") == 1\n    assert candidate(\"06\") == 0\n", "language": "python"}
{"task_id": "f0633437-a579-4617-a49d-58088bad69ec7816054031441633802", "prompt": "As a coding assistant, you'll need to complete functions that are ready to execute within code blocks. Only code within the specified function should be provided, and you should utilize only the libraries referenced in the problem. Any additional functions or classes must be defined within the main function being completed.\n\n```python\nfrom typing import List, Tuple\n\ndef organize_bookshelf(books: List[Tuple[str, str, int]]) -> List[Tuple[str, str, int]]:\n    \"\"\"\n    A librarian needs to organize a bookshelf based on specific criteria. Each book is represented by a tuple\n    containing (title, author, publication_year). The books need to be sorted first by author's last name,\n    then by publication year, and finally by title.\n\n    Parameters:\n    books (List[Tuple[str, str, int]]): A list of tuples, each representing a book with\n                                        (title, author, publication_year)\n\n    Returns:\n    List[Tuple[str, str, int]]: A sorted list of books according to the specified criteria\n\n\n    [EXAMPLES]\n    \n    assert candidate([(\"Animal Farm\", \"George Orwell\", 1945), (\"1984\", \"George Orwell\", 1949), (\"Down and Out in Paris and London\", \"George Orwell\", 1933)]) == [('Down and Out in Paris and London', 'George Orwell', 1933), ('Animal Farm', 'George Orwell', 1945), ('1984', 'George Orwell', 1949)]\n    assert candidate([(\"The Da Vinci Code\", \"Dan Brown\", 2003), (\"Angels & Demons\", \"Dan Brown\", 2000), (\"Inferno\", \"Dan Brown\", 2013)]) == [('Angels & Demons', 'Dan Brown', 2000), ('The Da Vinci Code', 'Dan Brown', 2003), ('Inferno', 'Dan Brown', 2013)]\n\n    [/EXAMPLES]\n    \"\"\"\n```\n", "entry_point": "organize_bookshelf", "solution": "from typing import List, Tuple\n\ndef organize_bookshelf(books: List[Tuple[str, str, int]]) -> List[Tuple[str, str, int]]:\n    \"\"\"\n    A librarian needs to organize a bookshelf based on specific criteria. Each book is represented by a tuple\n    containing (title, author, publication_year). The books need to be sorted first by author's last name,\n    then by publication year, and finally by title.\n\n    Parameters:\n    books (List[Tuple[str, str, int]]): A list of tuples, each representing a book with\n                                        (title, author, publication_year)\n\n    Returns:\n    List[Tuple[str, str, int]]: A sorted list of books according to the specified criteria\n\n\n    [EXAMPLES]\n    \n    assert candidate([(\"Animal Farm\", \"George Orwell\", 1945), (\"1984\", \"George Orwell\", 1949), (\"Down and Out in Paris and London\", \"George Orwell\", 1933)]) == [('Down and Out in Paris and London', 'George Orwell', 1933), ('Animal Farm', 'George Orwell', 1945), ('1984', 'George Orwell', 1949)]\n    assert candidate([(\"The Da Vinci Code\", \"Dan Brown\", 2003), (\"Angels & Demons\", \"Dan Brown\", 2000), (\"Inferno\", \"Dan Brown\", 2013)]) == [('Angels & Demons', 'Dan Brown', 2000), ('The Da Vinci Code', 'Dan Brown', 2003), ('Inferno', 'Dan Brown', 2013)]\n\n    [/EXAMPLES]\n    \"\"\"\n    def get_sort_key(book: Tuple[str, str, int]) -> Tuple[str, int, str]:\n        title, author, year = book\n        last_name = author.split()[-1]  # Get the last name\n        return (last_name, year, title)\n\n    return sorted(books, key=get_sort_key)\n\n", "test": "def check(candidate):\n    assert candidate([(\"Animal Farm\", \"George Orwell\", 1945), (\"1984\", \"George Orwell\", 1949), (\"Down and Out in Paris and London\", \"George Orwell\", 1933)]) == [('Down and Out in Paris and London', 'George Orwell', 1933), ('Animal Farm', 'George Orwell', 1945), ('1984', 'George Orwell', 1949)]\n    assert candidate([(\"The Shining\", \"Stephen King\", 1977), (\"It\", \"Stephen King\", 1986), (\"The Stand\", \"Stephen King\", 1978)]) == [('The Shining', 'Stephen King', 1977), ('The Stand', 'Stephen King', 1978), ('It', 'Stephen King', 1986)]\n    assert candidate([(\"The Great Gatsby\", \"F. Scott Fitzgerald\", 1925), (\"Moby-Dick\", \"Herman Melville\", 1851), (\"The Catcher in the Rye\", \"J.D. Salinger\", 1951), (\"Jane Eyre\", \"Charlotte Bront\u00eb\", 1847)]) == [('Jane Eyre', 'Charlotte Bront\u00eb', 1847), ('The Great Gatsby', 'F. Scott Fitzgerald', 1925), ('Moby-Dick', 'Herman Melville', 1851), ('The Catcher in the Rye', 'J.D. Salinger', 1951)]\n    assert candidate([(\"The Da Vinci Code\", \"Dan Brown\", 2003), (\"Angels & Demons\", \"Dan Brown\", 2000), (\"Inferno\", \"Dan Brown\", 2013)]) == [('Angels & Demons', 'Dan Brown', 2000), ('The Da Vinci Code', 'Dan Brown', 2003), ('Inferno', 'Dan Brown', 2013)]\n    assert candidate([(\"The Fellowship of the Ring\", \"J.R.R. Tolkien\", 1954), (\"The Two Towers\", \"J.R.R. Tolkien\", 1954), (\"The Return of the King\", \"J.R.R. Tolkien\", 1955)]) == [('The Fellowship of the Ring', 'J.R.R. Tolkien', 1954), ('The Two Towers', 'J.R.R. Tolkien', 1954), ('The Return of the King', 'J.R.R. Tolkien', 1955)]\n    assert candidate([(\"Dune\", \"Frank Herbert\", 1965), (\"Dune Messiah\", \"Frank Herbert\", 1969), (\"Children of Dune\", \"Frank Herbert\", 1976)]) == [('Dune', 'Frank Herbert', 1965), ('Dune Messiah', 'Frank Herbert', 1969), ('Children of Dune', 'Frank Herbert', 1976)]\n    assert candidate([(\"Harry Potter and the Philosopher's Stone\", \"J.K. Rowling\", 1997), (\"Harry Potter and the Chamber of Secrets\", \"J.K. Rowling\", 1998), (\"Harry Potter and the Prisoner of Azkaban\", \"J.K. Rowling\", 1999)]) == [(\"Harry Potter and the Philosopher's Stone\", 'J.K. Rowling', 1997), ('Harry Potter and the Chamber of Secrets', 'J.K. Rowling', 1998), ('Harry Potter and the Prisoner of Azkaban', 'J.K. Rowling', 1999)]\n    assert candidate([]) == []\n    assert candidate([(\"The Hobbit\", \"J.R.R. Tolkien\", 1937), (\"The Lord of the Rings\", \"J.R.R. Tolkien\", 1954), (\"The Silmarillion\", \"J.R.R. Tolkien\", 1977)]) == [('The Hobbit', 'J.R.R. Tolkien', 1937), ('The Lord of the Rings', 'J.R.R. Tolkien', 1954), ('The Silmarillion', 'J.R.R. Tolkien', 1977)]\n    assert candidate([(\"Single Book\", \"Only Author\", 2000)]) == [('Single Book', 'Only Author', 2000)]\n", "language": "python"}
{"task_id": "9c777979-d756-4f53-b1ed-b28eb8a352ce-341195952092440465", "prompt": "You're interacting with a coding assistant today. Your assistant's job is to complete functions so they're ready for execution within a code block. The assistant sticks to using only the imported libraries and avoids adding any code outside the target function. If additional functions or classes are needed, they'll be defined inside the main function.\n\n```python\nfrom typing import List\n\ndef decode_alien_message(signal: List[int]) -> str:\n    \"\"\"As a SETI scientist, you've received a mysterious signal from space.\n    The signal is a list of integers, where each integer represents an ASCII \n    character code. However, the aliens have encoded their message: each character \n    code is the sum of its position (1-indexed) in the list and the actual character code.\n    Decode the message and return the alien communication as a string.\n\n    This function combines list comprehension and character conversion.\n\n\n    [EXAMPLES]\n    \n    assert candidate([]) == ''\n    assert candidate([ord('a') + i for i in range(26)]) == '``````````````````````````'\n\n    [/EXAMPLES]\n    \"\"\"\n```\n", "entry_point": "decode_alien_message", "solution": "from typing import List\n\ndef decode_alien_message(signal: List[int]) -> str:\n    \"\"\"As a SETI scientist, you've received a mysterious signal from space.\n    The signal is a list of integers, where each integer represents an ASCII \n    character code. However, the aliens have encoded their message: each character \n    code is the sum of its position (1-indexed) in the list and the actual character code.\n    Decode the message and return the alien communication as a string.\n\n    This function combines list comprehension and character conversion.\n\n\n    [EXAMPLES]\n    \n    assert candidate([]) == ''\n    assert candidate([ord('a') + i for i in range(26)]) == '``````````````````````````'\n\n    [/EXAMPLES]\n    \"\"\"\n    decoded = [chr(code - (index + 1)) for index, code in enumerate(signal)]\n    return ''.join(decoded)\n\n", "test": "def check(candidate):\n    assert candidate([ord('a') + i for i in range(26)]) == '``````````````````````````'\n    assert candidate([66, 67]) == 'AA'\n    assert candidate([65, 66, 67, 68, 69]) == '@@@@@'\n    assert candidate([i * 10 for i in range(1, 11)]) == '\\t\\x12\\x1b$-6?HQZ'\n    assert candidate([255, 254, 253, 252, 251]) == '\u00fe\u00fc\u00fa\u00f8\u00f6'\n    assert candidate([]) == ''\n    assert candidate([32, 33, 34, 35, 36, 37, 38, 39, 40, 41]) == '\\x1f\\x1f\\x1f\\x1f\\x1f\\x1f\\x1f\\x1f\\x1f\\x1f'\n    assert candidate([ord(c) + i for i, c in enumerate(\"Hello, World!\", 1)]) == 'Hello, World!'\n    assert candidate([ord('A') + i for i in range(26)]) == '@@@@@@@@@@@@@@@@@@@@@@@@@@'\n    assert candidate([32, 33, 34, 35, 36]) == '\\x1f\\x1f\\x1f\\x1f\\x1f'\n", "language": "python"}
{"task_id": "0c4a5b22-407a-436d-b19f-7bf514b678f97339836856274937992", "prompt": "Complete the given function by implementing the logic as described in the docstring. Make sure to wrap the entire solution in a single code block.\n\n```python\nfrom typing import List, Tuple\n\ndef decode_ancient_script(symbols: List[str], key: List[Tuple[str, str]]) -> str:\n    \"\"\"\n    An archaeologist has discovered an ancient script and a partial key to decipher it. \n    This function takes a list of symbols from the script and a key mapping some symbols \n    to their corresponding letters, then attempts to decode the message.\n\n    Args:\n    symbols (List[str]): A list of symbols from the ancient script.\n    key (List[Tuple[str, str]]): A list of tuples mapping symbols to letters.\n\n    Returns:\n    str: The decoded message, with unknown symbols represented by '_'.\n\n\n    [EXAMPLES]\n    \n    assert candidate(['\u03b1', '\u03b2', '\u03b3'], [('\u03b1', 'a'), ('\u03b2', 'b'), ('\u03b3', 'c')]) == 'abc'\n    assert candidate(['\ud83c\udf1f', '\ud83c\udf19', '\u2600\ufe0f'], [('\ud83c\udf1f', 'S'), ('\ud83c\udf19', 'M'), ('\u2600\ufe0f', 'N')]) == 'SMN'\n\n    [/EXAMPLES]\n    \"\"\"\n```\n", "entry_point": "decode_ancient_script", "solution": "from typing import List, Tuple\n\ndef decode_ancient_script(symbols: List[str], key: List[Tuple[str, str]]) -> str:\n    \"\"\"\n    An archaeologist has discovered an ancient script and a partial key to decipher it. \n    This function takes a list of symbols from the script and a key mapping some symbols \n    to their corresponding letters, then attempts to decode the message.\n\n    Args:\n    symbols (List[str]): A list of symbols from the ancient script.\n    key (List[Tuple[str, str]]): A list of tuples mapping symbols to letters.\n\n    Returns:\n    str: The decoded message, with unknown symbols represented by '_'.\n\n\n    [EXAMPLES]\n    \n    assert candidate(['\u03b1', '\u03b2', '\u03b3'], [('\u03b1', 'a'), ('\u03b2', 'b'), ('\u03b3', 'c')]) == 'abc'\n    assert candidate(['\ud83c\udf1f', '\ud83c\udf19', '\u2600\ufe0f'], [('\ud83c\udf1f', 'S'), ('\ud83c\udf19', 'M'), ('\u2600\ufe0f', 'N')]) == 'SMN'\n\n    [/EXAMPLES]\n    \"\"\"\n    # Create a dictionary from the key for efficient lookup\n    symbol_to_letter = dict(key)\n    \n    # Initialize an empty list to store decoded characters\n    decoded_chars = []\n    \n    # Iterate through each symbol in the input\n    for symbol in symbols:\n        # If the symbol is in our key, append its corresponding letter\n        # Otherwise, append '_' for unknown symbols\n        decoded_chars.append(symbol_to_letter.get(symbol, '_'))\n    \n    # Join the decoded characters into a single string and return\n    return ''.join(decoded_chars)\n\n", "test": "def check(candidate):\n    assert candidate(['\u0398', '\u03a9', '\u0394'], [('\u0398', 'T'), ('\u03a9', 'O'), ('\u0394', 'D')]) == 'TOD'\n    assert candidate([], []) == ''\n    assert candidate(['!', '@', '#', '$', '%'], [('!', '1'), ('@', '2'), ('#', '3'), ('$', '4'), ('%', '5')]) == '12345'\n    assert candidate(['@', '#', '$', '%', '&'], [('@', 'A'), ('#', 'B'), ('$', 'C'), ('%', 'D'), ('&', 'E')]) == 'ABCDE'\n    assert candidate([], [('@', 'A')]) == ''\n    assert candidate(['\u2660', '\u2665', '\u2666', '\u2663'], [('\u2660', 'S'), ('\u2665', 'H'), ('\u2666', 'D'), ('\u2663', 'C')]) == 'SHDC'\n    assert candidate(['A', 'B', 'C'], [('A', '1'), ('B', '2'), ('C', '3')]) == '123'\n    assert candidate(['A', 'B', 'C', 'D', 'E'], [('A', '1'), ('C', '3'), ('E', '5')]) == '1_3_5'\n    assert candidate(['\ud83c\udf1f', '\ud83c\udf19', '\u2600\ufe0f'], [('\ud83c\udf1f', 'S'), ('\ud83c\udf19', 'M'), ('\u2600\ufe0f', 'N')]) == 'SMN'\n    assert candidate(['\u03b1', '\u03b2', '\u03b3'], [('\u03b1', 'a'), ('\u03b2', 'b'), ('\u03b3', 'c')]) == 'abc'\n", "language": "python"}
{"task_id": "7e6aa1ef-9e6c-4f59-af2b-2e65659bd5315149848162567719094", "prompt": "I'll implement the function according to the docstring. The function name and arguments will remain as specified, and I'll provide the complete implementation in one code block.\n\n```python\nfrom typing import List\n\ndef optimize_warehouse(items: List[int], max_weight: int) -> int:\n    \"\"\"You are managing a warehouse and need to optimize the storage of items on shelves.\n    Each item has a weight, represented by the list 'items'. You have a special shelf that can hold\n    a maximum weight 'max_weight'. Your task is to find the maximum number of consecutive items\n    that can be placed on this shelf without exceeding the weight limit.\n\n    The function should return the length of the longest consecutive sequence of items that can\n    be stored on the shelf.\n\n\n    [EXAMPLES]\n    \n    assert candidate([1, 2, 3, 4, 5], 10) == 4\n    assert candidate([1, 1, 1, 1, 1], 5) == 5\n\n    [/EXAMPLES]\n    \"\"\"\n```\n", "entry_point": "optimize_warehouse", "solution": "from typing import List\n\ndef optimize_warehouse(items: List[int], max_weight: int) -> int:\n    \"\"\"You are managing a warehouse and need to optimize the storage of items on shelves.\n    Each item has a weight, represented by the list 'items'. You have a special shelf that can hold\n    a maximum weight 'max_weight'. Your task is to find the maximum number of consecutive items\n    that can be placed on this shelf without exceeding the weight limit.\n\n    The function should return the length of the longest consecutive sequence of items that can\n    be stored on the shelf.\n\n\n    [EXAMPLES]\n    \n    assert candidate([1, 2, 3, 4, 5], 10) == 4\n    assert candidate([1, 1, 1, 1, 1], 5) == 5\n\n    [/EXAMPLES]\n    \"\"\"\n    max_consecutive = 0\n    current_sum = 0\n    start = 0\n\n    for end in range(len(items)):\n        current_sum += items[end]\n        \n        while current_sum > max_weight:\n            current_sum -= items[start]\n            start += 1\n        \n        max_consecutive = max(max_consecutive, end - start + 1)\n\n    return max_consecutive\n\n", "test": "def check(candidate):\n    assert candidate([1, 2, 3, 4, 5], 10) == 4\n    assert candidate([1, 1, 1, 1, 1], 5) == 5\n    assert candidate([50, 50, 50, 50], 200) == 4\n    assert candidate([1, 10, 1, 10, 1], 11) == 2\n    assert candidate([9, 8, 7, 6, 5, 4, 3, 2, 1], 20) == 5\n    assert candidate([7, 8, 9, 10, 11], 20) == 2\n    assert candidate([], 100) == 0\n    assert candidate([5, 4, 3, 2, 1], 9) == 3\n    assert candidate([5, 5, 5, 5, 5], 25) == 5\n    assert candidate([10, 10, 10, 10, 10], 30) == 3\n", "language": "python"}
{"task_id": "724690d7-9da4-4017-a10e-9a7ab37ea11a-146063063091710236", "prompt": "I'll implement the function according to the provided documentation. Please share the code in a single block, ensuring that edge cases are properly addressed.\n\n```python\nfrom typing import List\n\ndef balance_seesaw(weights: List[int], positions: List[int]) -> bool:\n    \"\"\"\n    Determine if a seesaw can be balanced given a set of weights and their positions.\n\n    A group of children are playing on a seesaw in a park. Each child has a different\n    weight and sits at a specific position on the seesaw. The seesaw is balanced if\n    the sum of the products of weights and their distances from the center on one side\n    equals the sum on the other side.\n\n    Args:\n    weights (List[int]): A list of integers representing the weights of the children.\n    positions (List[int]): A list of integers representing the positions of the children\n                           on the seesaw. Positive values indicate right side, negative\n                           values indicate left side. Zero is the center.\n\n    Returns:\n    bool: True if the seesaw can be balanced, False otherwise.\n\n\n    [EXAMPLES]\n    \n    assert candidate([10, 10, 10, 10], [-3, -1, 1, 3]) == True\n    assert candidate([15, 30, 45], [-2, 0, 2]) == False\n\n    [/EXAMPLES]\n    \"\"\"\n```\n", "entry_point": "balance_seesaw", "solution": "from typing import List\n\ndef balance_seesaw(weights: List[int], positions: List[int]) -> bool:\n    \"\"\"\n    Determine if a seesaw can be balanced given a set of weights and their positions.\n\n    A group of children are playing on a seesaw in a park. Each child has a different\n    weight and sits at a specific position on the seesaw. The seesaw is balanced if\n    the sum of the products of weights and their distances from the center on one side\n    equals the sum on the other side.\n\n    Args:\n    weights (List[int]): A list of integers representing the weights of the children.\n    positions (List[int]): A list of integers representing the positions of the children\n                           on the seesaw. Positive values indicate right side, negative\n                           values indicate left side. Zero is the center.\n\n    Returns:\n    bool: True if the seesaw can be balanced, False otherwise.\n\n\n    [EXAMPLES]\n    \n    assert candidate([10, 10, 10, 10], [-3, -1, 1, 3]) == True\n    assert candidate([15, 30, 45], [-2, 0, 2]) == False\n\n    [/EXAMPLES]\n    \"\"\"\n    if len(weights) != len(positions):\n        return False\n    \n    left_torque = 0\n    right_torque = 0\n    \n    for weight, position in zip(weights, positions):\n        if position < 0:\n            left_torque += weight * abs(position)\n        elif position > 0:\n            right_torque += weight * position\n        # If position is 0, it doesn't affect the balance\n    \n    return left_torque == right_torque\n\n", "test": "def check(candidate):\n    assert candidate([33, 33, 33], [-1, 0, 1]) == True\n    assert candidate([30, 40, 50], [-2, 1, 3]) == False\n    assert candidate([10, 20], [-1, 1]) == False\n    assert candidate([15, 30, 45], [-2, 0, 2]) == False\n    assert candidate([60, 45, 75], [-3, 2, 1]) == False\n    assert candidate([1, 1, 1, 1, 1], [-2, -1, 0, 1, 2]) == True\n    assert candidate([25, 25, 25, 25], [-2, -1, 1, 2]) == True\n    assert candidate([99, 1], [-1, 99]) == True\n    assert candidate([10, 10, 10, 10], [-3, -1, 1, 3]) == True\n    assert candidate([10, 20, 30, 40, 50], [-5, -3, 0, 3, 5]) == False\n", "language": "python"}
{"task_id": "719bb498-22e6-4778-ac01-1aee78fa1efc4833590817667942074", "prompt": "You are a coding assistant. I'll complete any given function in an executable code block using only the libraries imported in the problem. I'll define any additional functions or classes inside the main function without adding external code.\n\n```python\nfrom itertools import product\nimport itertools\nfrom typing import List\n\ndef genetic_mutation_analyzer(dna_sequence: str, mutation_sites: List[int]) -> List[str]:\n    \"\"\"\n    Analyze the potential impact of genetic mutations on a DNA sequence.\n\n    Given a DNA sequence and a list of mutation sites, generate all possible\n    mutated sequences and evaluate their potential effects.\n\n    This problem involves string manipulation and combinatorial analysis.\n\n    Parameters:\n    dna_sequence (str): Original DNA sequence\n    mutation_sites (List[int]): List of indices where mutations can occur\n\n    Returns:\n    List[str]: List of potentially mutated DNA sequences\n\n\n    [EXAMPLES]\n    \n    assert candidate(\"TGCA\", [0, 1, 2, 3]) == ['TGCA', 'TGCC', 'TGCG', 'TGCT', 'TGAA', 'TGAC', 'TGAG', 'TGAT', 'TGGA', 'TGGC', 'TGGG', 'TGGT', 'TGTA', 'TGTC', 'TGTG', 'TGTT', 'TACA', 'TACC', 'TACG', 'TACT', 'TAAA', 'TAAC', 'TAAG', 'TAAT', 'TAGA', 'TAGC', 'TAGG', 'TAGT', 'TATA', 'TATC', 'TATG', 'TATT', 'TCCA', 'TCCC', 'TCCG', 'TCCT', 'TCAA', 'TCAC', 'TCAG', 'TCAT', 'TCGA', 'TCGC', 'TCGG', 'TCGT', 'TCTA', 'TCTC', 'TCTG', 'TCTT', 'TTCA', 'TTCC', 'TTCG', 'TTCT', 'TTAA', 'TTAC', 'TTAG', 'TTAT', 'TTGA', 'TTGC', 'TTGG', 'TTGT', 'TTTA', 'TTTC', 'TTTG', 'TTTT', 'AGCA', 'AGCC', 'AGCG', 'AGCT', 'AGAA', 'AGAC', 'AGAG', 'AGAT', 'AGGA', 'AGGC', 'AGGG', 'AGGT', 'AGTA', 'AGTC', 'AGTG', 'AGTT', 'AACA', 'AACC', 'AACG', 'AACT', 'AAAA', 'AAAC', 'AAAG', 'AAAT', 'AAGA', 'AAGC', 'AAGG', 'AAGT', 'AATA', 'AATC', 'AATG', 'AATT', 'ACCA', 'ACCC', 'ACCG', 'ACCT', 'ACAA', 'ACAC', 'ACAG', 'ACAT', 'ACGA', 'ACGC', 'ACGG', 'ACGT', 'ACTA', 'ACTC', 'ACTG', 'ACTT', 'ATCA', 'ATCC', 'ATCG', 'ATCT', 'ATAA', 'ATAC', 'ATAG', 'ATAT', 'ATGA', 'ATGC', 'ATGG', 'ATGT', 'ATTA', 'ATTC', 'ATTG', 'ATTT', 'CGCA', 'CGCC', 'CGCG', 'CGCT', 'CGAA', 'CGAC', 'CGAG', 'CGAT', 'CGGA', 'CGGC', 'CGGG', 'CGGT', 'CGTA', 'CGTC', 'CGTG', 'CGTT', 'CACA', 'CACC', 'CACG', 'CACT', 'CAAA', 'CAAC', 'CAAG', 'CAAT', 'CAGA', 'CAGC', 'CAGG', 'CAGT', 'CATA', 'CATC', 'CATG', 'CATT', 'CCCA', 'CCCC', 'CCCG', 'CCCT', 'CCAA', 'CCAC', 'CCAG', 'CCAT', 'CCGA', 'CCGC', 'CCGG', 'CCGT', 'CCTA', 'CCTC', 'CCTG', 'CCTT', 'CTCA', 'CTCC', 'CTCG', 'CTCT', 'CTAA', 'CTAC', 'CTAG', 'CTAT', 'CTGA', 'CTGC', 'CTGG', 'CTGT', 'CTTA', 'CTTC', 'CTTG', 'CTTT', 'GGCA', 'GGCC', 'GGCG', 'GGCT', 'GGAA', 'GGAC', 'GGAG', 'GGAT', 'GGGA', 'GGGC', 'GGGG', 'GGGT', 'GGTA', 'GGTC', 'GGTG', 'GGTT', 'GACA', 'GACC', 'GACG', 'GACT', 'GAAA', 'GAAC', 'GAAG', 'GAAT', 'GAGA', 'GAGC', 'GAGG', 'GAGT', 'GATA', 'GATC', 'GATG', 'GATT', 'GCCA', 'GCCC', 'GCCG', 'GCCT', 'GCAA', 'GCAC', 'GCAG', 'GCAT', 'GCGA', 'GCGC', 'GCGG', 'GCGT', 'GCTA', 'GCTC', 'GCTG', 'GCTT', 'GTCA', 'GTCC', 'GTCG', 'GTCT', 'GTAA', 'GTAC', 'GTAG', 'GTAT', 'GTGA', 'GTGC', 'GTGG', 'GTGT', 'GTTA', 'GTTC', 'GTTG', 'GTTT']\n    assert candidate(\"ACTGACTG\", [1, 5]) == ['ACTGACTG', 'ACTGAATG', 'ACTGAGTG', 'ACTGATTG', 'AATGACTG', 'AATGAATG', 'AATGAGTG', 'AATGATTG', 'AGTGACTG', 'AGTGAATG', 'AGTGAGTG', 'AGTGATTG', 'ATTGACTG', 'ATTGAATG', 'ATTGAGTG', 'ATTGATTG']\n\n    [/EXAMPLES]\n    \"\"\"\n```\n", "entry_point": "genetic_mutation_analyzer", "solution": "from itertools import product\nimport itertools\nfrom typing import List\n\ndef genetic_mutation_analyzer(dna_sequence: str, mutation_sites: List[int]) -> List[str]:\n    \"\"\"\n    Analyze the potential impact of genetic mutations on a DNA sequence.\n\n    Given a DNA sequence and a list of mutation sites, generate all possible\n    mutated sequences and evaluate their potential effects.\n\n    This problem involves string manipulation and combinatorial analysis.\n\n    Parameters:\n    dna_sequence (str): Original DNA sequence\n    mutation_sites (List[int]): List of indices where mutations can occur\n\n    Returns:\n    List[str]: List of potentially mutated DNA sequences\n\n\n    [EXAMPLES]\n    \n    assert candidate(\"TGCA\", [0, 1, 2, 3]) == ['TGCA', 'TGCC', 'TGCG', 'TGCT', 'TGAA', 'TGAC', 'TGAG', 'TGAT', 'TGGA', 'TGGC', 'TGGG', 'TGGT', 'TGTA', 'TGTC', 'TGTG', 'TGTT', 'TACA', 'TACC', 'TACG', 'TACT', 'TAAA', 'TAAC', 'TAAG', 'TAAT', 'TAGA', 'TAGC', 'TAGG', 'TAGT', 'TATA', 'TATC', 'TATG', 'TATT', 'TCCA', 'TCCC', 'TCCG', 'TCCT', 'TCAA', 'TCAC', 'TCAG', 'TCAT', 'TCGA', 'TCGC', 'TCGG', 'TCGT', 'TCTA', 'TCTC', 'TCTG', 'TCTT', 'TTCA', 'TTCC', 'TTCG', 'TTCT', 'TTAA', 'TTAC', 'TTAG', 'TTAT', 'TTGA', 'TTGC', 'TTGG', 'TTGT', 'TTTA', 'TTTC', 'TTTG', 'TTTT', 'AGCA', 'AGCC', 'AGCG', 'AGCT', 'AGAA', 'AGAC', 'AGAG', 'AGAT', 'AGGA', 'AGGC', 'AGGG', 'AGGT', 'AGTA', 'AGTC', 'AGTG', 'AGTT', 'AACA', 'AACC', 'AACG', 'AACT', 'AAAA', 'AAAC', 'AAAG', 'AAAT', 'AAGA', 'AAGC', 'AAGG', 'AAGT', 'AATA', 'AATC', 'AATG', 'AATT', 'ACCA', 'ACCC', 'ACCG', 'ACCT', 'ACAA', 'ACAC', 'ACAG', 'ACAT', 'ACGA', 'ACGC', 'ACGG', 'ACGT', 'ACTA', 'ACTC', 'ACTG', 'ACTT', 'ATCA', 'ATCC', 'ATCG', 'ATCT', 'ATAA', 'ATAC', 'ATAG', 'ATAT', 'ATGA', 'ATGC', 'ATGG', 'ATGT', 'ATTA', 'ATTC', 'ATTG', 'ATTT', 'CGCA', 'CGCC', 'CGCG', 'CGCT', 'CGAA', 'CGAC', 'CGAG', 'CGAT', 'CGGA', 'CGGC', 'CGGG', 'CGGT', 'CGTA', 'CGTC', 'CGTG', 'CGTT', 'CACA', 'CACC', 'CACG', 'CACT', 'CAAA', 'CAAC', 'CAAG', 'CAAT', 'CAGA', 'CAGC', 'CAGG', 'CAGT', 'CATA', 'CATC', 'CATG', 'CATT', 'CCCA', 'CCCC', 'CCCG', 'CCCT', 'CCAA', 'CCAC', 'CCAG', 'CCAT', 'CCGA', 'CCGC', 'CCGG', 'CCGT', 'CCTA', 'CCTC', 'CCTG', 'CCTT', 'CTCA', 'CTCC', 'CTCG', 'CTCT', 'CTAA', 'CTAC', 'CTAG', 'CTAT', 'CTGA', 'CTGC', 'CTGG', 'CTGT', 'CTTA', 'CTTC', 'CTTG', 'CTTT', 'GGCA', 'GGCC', 'GGCG', 'GGCT', 'GGAA', 'GGAC', 'GGAG', 'GGAT', 'GGGA', 'GGGC', 'GGGG', 'GGGT', 'GGTA', 'GGTC', 'GGTG', 'GGTT', 'GACA', 'GACC', 'GACG', 'GACT', 'GAAA', 'GAAC', 'GAAG', 'GAAT', 'GAGA', 'GAGC', 'GAGG', 'GAGT', 'GATA', 'GATC', 'GATG', 'GATT', 'GCCA', 'GCCC', 'GCCG', 'GCCT', 'GCAA', 'GCAC', 'GCAG', 'GCAT', 'GCGA', 'GCGC', 'GCGG', 'GCGT', 'GCTA', 'GCTC', 'GCTG', 'GCTT', 'GTCA', 'GTCC', 'GTCG', 'GTCT', 'GTAA', 'GTAC', 'GTAG', 'GTAT', 'GTGA', 'GTGC', 'GTGG', 'GTGT', 'GTTA', 'GTTC', 'GTTG', 'GTTT']\n    assert candidate(\"ACTGACTG\", [1, 5]) == ['ACTGACTG', 'ACTGAATG', 'ACTGAGTG', 'ACTGATTG', 'AATGACTG', 'AATGAATG', 'AATGAGTG', 'AATGATTG', 'AGTGACTG', 'AGTGAATG', 'AGTGAGTG', 'AGTGATTG', 'ATTGACTG', 'ATTGAATG', 'ATTGAGTG', 'ATTGATTG']\n\n    [/EXAMPLES]\n    \"\"\"\n    def generate_mutations(base):\n        return [b for b in 'ACGT' if b != base]\n\n    # Create a list to store all possible mutations\n    mutation_options = []\n    for site in mutation_sites:\n        original_base = dna_sequence[site]\n        mutations = generate_mutations(original_base)\n        mutation_options.append([original_base] + mutations)\n\n    # Generate all possible combinations of mutations\n    mutated_sequences = []\n    for mutation_combination in product(*mutation_options):\n        mutated_seq = list(dna_sequence)\n        for site, new_base in zip(mutation_sites, mutation_combination):\n            mutated_seq[site] = new_base\n        mutated_sequences.append(''.join(mutated_seq))\n\n    return mutated_sequences\n\n", "test": "def check(candidate):\n    assert candidate(\"ATATATATAT\", [0, 2, 4, 6, 8]) == ['ATATATATAT', 'ATATATATCT', 'ATATATATGT', 'ATATATATTT', 'ATATATCTAT', 'ATATATCTCT', 'ATATATCTGT', 'ATATATCTTT', 'ATATATGTAT', 'ATATATGTCT', 'ATATATGTGT', 'ATATATGTTT', 'ATATATTTAT', 'ATATATTTCT', 'ATATATTTGT', 'ATATATTTTT', 'ATATCTATAT', 'ATATCTATCT', 'ATATCTATGT', 'ATATCTATTT', 'ATATCTCTAT', 'ATATCTCTCT', 'ATATCTCTGT', 'ATATCTCTTT', 'ATATCTGTAT', 'ATATCTGTCT', 'ATATCTGTGT', 'ATATCTGTTT', 'ATATCTTTAT', 'ATATCTTTCT', 'ATATCTTTGT', 'ATATCTTTTT', 'ATATGTATAT', 'ATATGTATCT', 'ATATGTATGT', 'ATATGTATTT', 'ATATGTCTAT', 'ATATGTCTCT', 'ATATGTCTGT', 'ATATGTCTTT', 'ATATGTGTAT', 'ATATGTGTCT', 'ATATGTGTGT', 'ATATGTGTTT', 'ATATGTTTAT', 'ATATGTTTCT', 'ATATGTTTGT', 'ATATGTTTTT', 'ATATTTATAT', 'ATATTTATCT', 'ATATTTATGT', 'ATATTTATTT', 'ATATTTCTAT', 'ATATTTCTCT', 'ATATTTCTGT', 'ATATTTCTTT', 'ATATTTGTAT', 'ATATTTGTCT', 'ATATTTGTGT', 'ATATTTGTTT', 'ATATTTTTAT', 'ATATTTTTCT', 'ATATTTTTGT', 'ATATTTTTTT', 'ATCTATATAT', 'ATCTATATCT', 'ATCTATATGT', 'ATCTATATTT', 'ATCTATCTAT', 'ATCTATCTCT', 'ATCTATCTGT', 'ATCTATCTTT', 'ATCTATGTAT', 'ATCTATGTCT', 'ATCTATGTGT', 'ATCTATGTTT', 'ATCTATTTAT', 'ATCTATTTCT', 'ATCTATTTGT', 'ATCTATTTTT', 'ATCTCTATAT', 'ATCTCTATCT', 'ATCTCTATGT', 'ATCTCTATTT', 'ATCTCTCTAT', 'ATCTCTCTCT', 'ATCTCTCTGT', 'ATCTCTCTTT', 'ATCTCTGTAT', 'ATCTCTGTCT', 'ATCTCTGTGT', 'ATCTCTGTTT', 'ATCTCTTTAT', 'ATCTCTTTCT', 'ATCTCTTTGT', 'ATCTCTTTTT', 'ATCTGTATAT', 'ATCTGTATCT', 'ATCTGTATGT', 'ATCTGTATTT', 'ATCTGTCTAT', 'ATCTGTCTCT', 'ATCTGTCTGT', 'ATCTGTCTTT', 'ATCTGTGTAT', 'ATCTGTGTCT', 'ATCTGTGTGT', 'ATCTGTGTTT', 'ATCTGTTTAT', 'ATCTGTTTCT', 'ATCTGTTTGT', 'ATCTGTTTTT', 'ATCTTTATAT', 'ATCTTTATCT', 'ATCTTTATGT', 'ATCTTTATTT', 'ATCTTTCTAT', 'ATCTTTCTCT', 'ATCTTTCTGT', 'ATCTTTCTTT', 'ATCTTTGTAT', 'ATCTTTGTCT', 'ATCTTTGTGT', 'ATCTTTGTTT', 'ATCTTTTTAT', 'ATCTTTTTCT', 'ATCTTTTTGT', 'ATCTTTTTTT', 'ATGTATATAT', 'ATGTATATCT', 'ATGTATATGT', 'ATGTATATTT', 'ATGTATCTAT', 'ATGTATCTCT', 'ATGTATCTGT', 'ATGTATCTTT', 'ATGTATGTAT', 'ATGTATGTCT', 'ATGTATGTGT', 'ATGTATGTTT', 'ATGTATTTAT', 'ATGTATTTCT', 'ATGTATTTGT', 'ATGTATTTTT', 'ATGTCTATAT', 'ATGTCTATCT', 'ATGTCTATGT', 'ATGTCTATTT', 'ATGTCTCTAT', 'ATGTCTCTCT', 'ATGTCTCTGT', 'ATGTCTCTTT', 'ATGTCTGTAT', 'ATGTCTGTCT', 'ATGTCTGTGT', 'ATGTCTGTTT', 'ATGTCTTTAT', 'ATGTCTTTCT', 'ATGTCTTTGT', 'ATGTCTTTTT', 'ATGTGTATAT', 'ATGTGTATCT', 'ATGTGTATGT', 'ATGTGTATTT', 'ATGTGTCTAT', 'ATGTGTCTCT', 'ATGTGTCTGT', 'ATGTGTCTTT', 'ATGTGTGTAT', 'ATGTGTGTCT', 'ATGTGTGTGT', 'ATGTGTGTTT', 'ATGTGTTTAT', 'ATGTGTTTCT', 'ATGTGTTTGT', 'ATGTGTTTTT', 'ATGTTTATAT', 'ATGTTTATCT', 'ATGTTTATGT', 'ATGTTTATTT', 'ATGTTTCTAT', 'ATGTTTCTCT', 'ATGTTTCTGT', 'ATGTTTCTTT', 'ATGTTTGTAT', 'ATGTTTGTCT', 'ATGTTTGTGT', 'ATGTTTGTTT', 'ATGTTTTTAT', 'ATGTTTTTCT', 'ATGTTTTTGT', 'ATGTTTTTTT', 'ATTTATATAT', 'ATTTATATCT', 'ATTTATATGT', 'ATTTATATTT', 'ATTTATCTAT', 'ATTTATCTCT', 'ATTTATCTGT', 'ATTTATCTTT', 'ATTTATGTAT', 'ATTTATGTCT', 'ATTTATGTGT', 'ATTTATGTTT', 'ATTTATTTAT', 'ATTTATTTCT', 'ATTTATTTGT', 'ATTTATTTTT', 'ATTTCTATAT', 'ATTTCTATCT', 'ATTTCTATGT', 'ATTTCTATTT', 'ATTTCTCTAT', 'ATTTCTCTCT', 'ATTTCTCTGT', 'ATTTCTCTTT', 'ATTTCTGTAT', 'ATTTCTGTCT', 'ATTTCTGTGT', 'ATTTCTGTTT', 'ATTTCTTTAT', 'ATTTCTTTCT', 'ATTTCTTTGT', 'ATTTCTTTTT', 'ATTTGTATAT', 'ATTTGTATCT', 'ATTTGTATGT', 'ATTTGTATTT', 'ATTTGTCTAT', 'ATTTGTCTCT', 'ATTTGTCTGT', 'ATTTGTCTTT', 'ATTTGTGTAT', 'ATTTGTGTCT', 'ATTTGTGTGT', 'ATTTGTGTTT', 'ATTTGTTTAT', 'ATTTGTTTCT', 'ATTTGTTTGT', 'ATTTGTTTTT', 'ATTTTTATAT', 'ATTTTTATCT', 'ATTTTTATGT', 'ATTTTTATTT', 'ATTTTTCTAT', 'ATTTTTCTCT', 'ATTTTTCTGT', 'ATTTTTCTTT', 'ATTTTTGTAT', 'ATTTTTGTCT', 'ATTTTTGTGT', 'ATTTTTGTTT', 'ATTTTTTTAT', 'ATTTTTTTCT', 'ATTTTTTTGT', 'ATTTTTTTTT', 'CTATATATAT', 'CTATATATCT', 'CTATATATGT', 'CTATATATTT', 'CTATATCTAT', 'CTATATCTCT', 'CTATATCTGT', 'CTATATCTTT', 'CTATATGTAT', 'CTATATGTCT', 'CTATATGTGT', 'CTATATGTTT', 'CTATATTTAT', 'CTATATTTCT', 'CTATATTTGT', 'CTATATTTTT', 'CTATCTATAT', 'CTATCTATCT', 'CTATCTATGT', 'CTATCTATTT', 'CTATCTCTAT', 'CTATCTCTCT', 'CTATCTCTGT', 'CTATCTCTTT', 'CTATCTGTAT', 'CTATCTGTCT', 'CTATCTGTGT', 'CTATCTGTTT', 'CTATCTTTAT', 'CTATCTTTCT', 'CTATCTTTGT', 'CTATCTTTTT', 'CTATGTATAT', 'CTATGTATCT', 'CTATGTATGT', 'CTATGTATTT', 'CTATGTCTAT', 'CTATGTCTCT', 'CTATGTCTGT', 'CTATGTCTTT', 'CTATGTGTAT', 'CTATGTGTCT', 'CTATGTGTGT', 'CTATGTGTTT', 'CTATGTTTAT', 'CTATGTTTCT', 'CTATGTTTGT', 'CTATGTTTTT', 'CTATTTATAT', 'CTATTTATCT', 'CTATTTATGT', 'CTATTTATTT', 'CTATTTCTAT', 'CTATTTCTCT', 'CTATTTCTGT', 'CTATTTCTTT', 'CTATTTGTAT', 'CTATTTGTCT', 'CTATTTGTGT', 'CTATTTGTTT', 'CTATTTTTAT', 'CTATTTTTCT', 'CTATTTTTGT', 'CTATTTTTTT', 'CTCTATATAT', 'CTCTATATCT', 'CTCTATATGT', 'CTCTATATTT', 'CTCTATCTAT', 'CTCTATCTCT', 'CTCTATCTGT', 'CTCTATCTTT', 'CTCTATGTAT', 'CTCTATGTCT', 'CTCTATGTGT', 'CTCTATGTTT', 'CTCTATTTAT', 'CTCTATTTCT', 'CTCTATTTGT', 'CTCTATTTTT', 'CTCTCTATAT', 'CTCTCTATCT', 'CTCTCTATGT', 'CTCTCTATTT', 'CTCTCTCTAT', 'CTCTCTCTCT', 'CTCTCTCTGT', 'CTCTCTCTTT', 'CTCTCTGTAT', 'CTCTCTGTCT', 'CTCTCTGTGT', 'CTCTCTGTTT', 'CTCTCTTTAT', 'CTCTCTTTCT', 'CTCTCTTTGT', 'CTCTCTTTTT', 'CTCTGTATAT', 'CTCTGTATCT', 'CTCTGTATGT', 'CTCTGTATTT', 'CTCTGTCTAT', 'CTCTGTCTCT', 'CTCTGTCTGT', 'CTCTGTCTTT', 'CTCTGTGTAT', 'CTCTGTGTCT', 'CTCTGTGTGT', 'CTCTGTGTTT', 'CTCTGTTTAT', 'CTCTGTTTCT', 'CTCTGTTTGT', 'CTCTGTTTTT', 'CTCTTTATAT', 'CTCTTTATCT', 'CTCTTTATGT', 'CTCTTTATTT', 'CTCTTTCTAT', 'CTCTTTCTCT', 'CTCTTTCTGT', 'CTCTTTCTTT', 'CTCTTTGTAT', 'CTCTTTGTCT', 'CTCTTTGTGT', 'CTCTTTGTTT', 'CTCTTTTTAT', 'CTCTTTTTCT', 'CTCTTTTTGT', 'CTCTTTTTTT', 'CTGTATATAT', 'CTGTATATCT', 'CTGTATATGT', 'CTGTATATTT', 'CTGTATCTAT', 'CTGTATCTCT', 'CTGTATCTGT', 'CTGTATCTTT', 'CTGTATGTAT', 'CTGTATGTCT', 'CTGTATGTGT', 'CTGTATGTTT', 'CTGTATTTAT', 'CTGTATTTCT', 'CTGTATTTGT', 'CTGTATTTTT', 'CTGTCTATAT', 'CTGTCTATCT', 'CTGTCTATGT', 'CTGTCTATTT', 'CTGTCTCTAT', 'CTGTCTCTCT', 'CTGTCTCTGT', 'CTGTCTCTTT', 'CTGTCTGTAT', 'CTGTCTGTCT', 'CTGTCTGTGT', 'CTGTCTGTTT', 'CTGTCTTTAT', 'CTGTCTTTCT', 'CTGTCTTTGT', 'CTGTCTTTTT', 'CTGTGTATAT', 'CTGTGTATCT', 'CTGTGTATGT', 'CTGTGTATTT', 'CTGTGTCTAT', 'CTGTGTCTCT', 'CTGTGTCTGT', 'CTGTGTCTTT', 'CTGTGTGTAT', 'CTGTGTGTCT', 'CTGTGTGTGT', 'CTGTGTGTTT', 'CTGTGTTTAT', 'CTGTGTTTCT', 'CTGTGTTTGT', 'CTGTGTTTTT', 'CTGTTTATAT', 'CTGTTTATCT', 'CTGTTTATGT', 'CTGTTTATTT', 'CTGTTTCTAT', 'CTGTTTCTCT', 'CTGTTTCTGT', 'CTGTTTCTTT', 'CTGTTTGTAT', 'CTGTTTGTCT', 'CTGTTTGTGT', 'CTGTTTGTTT', 'CTGTTTTTAT', 'CTGTTTTTCT', 'CTGTTTTTGT', 'CTGTTTTTTT', 'CTTTATATAT', 'CTTTATATCT', 'CTTTATATGT', 'CTTTATATTT', 'CTTTATCTAT', 'CTTTATCTCT', 'CTTTATCTGT', 'CTTTATCTTT', 'CTTTATGTAT', 'CTTTATGTCT', 'CTTTATGTGT', 'CTTTATGTTT', 'CTTTATTTAT', 'CTTTATTTCT', 'CTTTATTTGT', 'CTTTATTTTT', 'CTTTCTATAT', 'CTTTCTATCT', 'CTTTCTATGT', 'CTTTCTATTT', 'CTTTCTCTAT', 'CTTTCTCTCT', 'CTTTCTCTGT', 'CTTTCTCTTT', 'CTTTCTGTAT', 'CTTTCTGTCT', 'CTTTCTGTGT', 'CTTTCTGTTT', 'CTTTCTTTAT', 'CTTTCTTTCT', 'CTTTCTTTGT', 'CTTTCTTTTT', 'CTTTGTATAT', 'CTTTGTATCT', 'CTTTGTATGT', 'CTTTGTATTT', 'CTTTGTCTAT', 'CTTTGTCTCT', 'CTTTGTCTGT', 'CTTTGTCTTT', 'CTTTGTGTAT', 'CTTTGTGTCT', 'CTTTGTGTGT', 'CTTTGTGTTT', 'CTTTGTTTAT', 'CTTTGTTTCT', 'CTTTGTTTGT', 'CTTTGTTTTT', 'CTTTTTATAT', 'CTTTTTATCT', 'CTTTTTATGT', 'CTTTTTATTT', 'CTTTTTCTAT', 'CTTTTTCTCT', 'CTTTTTCTGT', 'CTTTTTCTTT', 'CTTTTTGTAT', 'CTTTTTGTCT', 'CTTTTTGTGT', 'CTTTTTGTTT', 'CTTTTTTTAT', 'CTTTTTTTCT', 'CTTTTTTTGT', 'CTTTTTTTTT', 'GTATATATAT', 'GTATATATCT', 'GTATATATGT', 'GTATATATTT', 'GTATATCTAT', 'GTATATCTCT', 'GTATATCTGT', 'GTATATCTTT', 'GTATATGTAT', 'GTATATGTCT', 'GTATATGTGT', 'GTATATGTTT', 'GTATATTTAT', 'GTATATTTCT', 'GTATATTTGT', 'GTATATTTTT', 'GTATCTATAT', 'GTATCTATCT', 'GTATCTATGT', 'GTATCTATTT', 'GTATCTCTAT', 'GTATCTCTCT', 'GTATCTCTGT', 'GTATCTCTTT', 'GTATCTGTAT', 'GTATCTGTCT', 'GTATCTGTGT', 'GTATCTGTTT', 'GTATCTTTAT', 'GTATCTTTCT', 'GTATCTTTGT', 'GTATCTTTTT', 'GTATGTATAT', 'GTATGTATCT', 'GTATGTATGT', 'GTATGTATTT', 'GTATGTCTAT', 'GTATGTCTCT', 'GTATGTCTGT', 'GTATGTCTTT', 'GTATGTGTAT', 'GTATGTGTCT', 'GTATGTGTGT', 'GTATGTGTTT', 'GTATGTTTAT', 'GTATGTTTCT', 'GTATGTTTGT', 'GTATGTTTTT', 'GTATTTATAT', 'GTATTTATCT', 'GTATTTATGT', 'GTATTTATTT', 'GTATTTCTAT', 'GTATTTCTCT', 'GTATTTCTGT', 'GTATTTCTTT', 'GTATTTGTAT', 'GTATTTGTCT', 'GTATTTGTGT', 'GTATTTGTTT', 'GTATTTTTAT', 'GTATTTTTCT', 'GTATTTTTGT', 'GTATTTTTTT', 'GTCTATATAT', 'GTCTATATCT', 'GTCTATATGT', 'GTCTATATTT', 'GTCTATCTAT', 'GTCTATCTCT', 'GTCTATCTGT', 'GTCTATCTTT', 'GTCTATGTAT', 'GTCTATGTCT', 'GTCTATGTGT', 'GTCTATGTTT', 'GTCTATTTAT', 'GTCTATTTCT', 'GTCTATTTGT', 'GTCTATTTTT', 'GTCTCTATAT', 'GTCTCTATCT', 'GTCTCTATGT', 'GTCTCTATTT', 'GTCTCTCTAT', 'GTCTCTCTCT', 'GTCTCTCTGT', 'GTCTCTCTTT', 'GTCTCTGTAT', 'GTCTCTGTCT', 'GTCTCTGTGT', 'GTCTCTGTTT', 'GTCTCTTTAT', 'GTCTCTTTCT', 'GTCTCTTTGT', 'GTCTCTTTTT', 'GTCTGTATAT', 'GTCTGTATCT', 'GTCTGTATGT', 'GTCTGTATTT', 'GTCTGTCTAT', 'GTCTGTCTCT', 'GTCTGTCTGT', 'GTCTGTCTTT', 'GTCTGTGTAT', 'GTCTGTGTCT', 'GTCTGTGTGT', 'GTCTGTGTTT', 'GTCTGTTTAT', 'GTCTGTTTCT', 'GTCTGTTTGT', 'GTCTGTTTTT', 'GTCTTTATAT', 'GTCTTTATCT', 'GTCTTTATGT', 'GTCTTTATTT', 'GTCTTTCTAT', 'GTCTTTCTCT', 'GTCTTTCTGT', 'GTCTTTCTTT', 'GTCTTTGTAT', 'GTCTTTGTCT', 'GTCTTTGTGT', 'GTCTTTGTTT', 'GTCTTTTTAT', 'GTCTTTTTCT', 'GTCTTTTTGT', 'GTCTTTTTTT', 'GTGTATATAT', 'GTGTATATCT', 'GTGTATATGT', 'GTGTATATTT', 'GTGTATCTAT', 'GTGTATCTCT', 'GTGTATCTGT', 'GTGTATCTTT', 'GTGTATGTAT', 'GTGTATGTCT', 'GTGTATGTGT', 'GTGTATGTTT', 'GTGTATTTAT', 'GTGTATTTCT', 'GTGTATTTGT', 'GTGTATTTTT', 'GTGTCTATAT', 'GTGTCTATCT', 'GTGTCTATGT', 'GTGTCTATTT', 'GTGTCTCTAT', 'GTGTCTCTCT', 'GTGTCTCTGT', 'GTGTCTCTTT', 'GTGTCTGTAT', 'GTGTCTGTCT', 'GTGTCTGTGT', 'GTGTCTGTTT', 'GTGTCTTTAT', 'GTGTCTTTCT', 'GTGTCTTTGT', 'GTGTCTTTTT', 'GTGTGTATAT', 'GTGTGTATCT', 'GTGTGTATGT', 'GTGTGTATTT', 'GTGTGTCTAT', 'GTGTGTCTCT', 'GTGTGTCTGT', 'GTGTGTCTTT', 'GTGTGTGTAT', 'GTGTGTGTCT', 'GTGTGTGTGT', 'GTGTGTGTTT', 'GTGTGTTTAT', 'GTGTGTTTCT', 'GTGTGTTTGT', 'GTGTGTTTTT', 'GTGTTTATAT', 'GTGTTTATCT', 'GTGTTTATGT', 'GTGTTTATTT', 'GTGTTTCTAT', 'GTGTTTCTCT', 'GTGTTTCTGT', 'GTGTTTCTTT', 'GTGTTTGTAT', 'GTGTTTGTCT', 'GTGTTTGTGT', 'GTGTTTGTTT', 'GTGTTTTTAT', 'GTGTTTTTCT', 'GTGTTTTTGT', 'GTGTTTTTTT', 'GTTTATATAT', 'GTTTATATCT', 'GTTTATATGT', 'GTTTATATTT', 'GTTTATCTAT', 'GTTTATCTCT', 'GTTTATCTGT', 'GTTTATCTTT', 'GTTTATGTAT', 'GTTTATGTCT', 'GTTTATGTGT', 'GTTTATGTTT', 'GTTTATTTAT', 'GTTTATTTCT', 'GTTTATTTGT', 'GTTTATTTTT', 'GTTTCTATAT', 'GTTTCTATCT', 'GTTTCTATGT', 'GTTTCTATTT', 'GTTTCTCTAT', 'GTTTCTCTCT', 'GTTTCTCTGT', 'GTTTCTCTTT', 'GTTTCTGTAT', 'GTTTCTGTCT', 'GTTTCTGTGT', 'GTTTCTGTTT', 'GTTTCTTTAT', 'GTTTCTTTCT', 'GTTTCTTTGT', 'GTTTCTTTTT', 'GTTTGTATAT', 'GTTTGTATCT', 'GTTTGTATGT', 'GTTTGTATTT', 'GTTTGTCTAT', 'GTTTGTCTCT', 'GTTTGTCTGT', 'GTTTGTCTTT', 'GTTTGTGTAT', 'GTTTGTGTCT', 'GTTTGTGTGT', 'GTTTGTGTTT', 'GTTTGTTTAT', 'GTTTGTTTCT', 'GTTTGTTTGT', 'GTTTGTTTTT', 'GTTTTTATAT', 'GTTTTTATCT', 'GTTTTTATGT', 'GTTTTTATTT', 'GTTTTTCTAT', 'GTTTTTCTCT', 'GTTTTTCTGT', 'GTTTTTCTTT', 'GTTTTTGTAT', 'GTTTTTGTCT', 'GTTTTTGTGT', 'GTTTTTGTTT', 'GTTTTTTTAT', 'GTTTTTTTCT', 'GTTTTTTTGT', 'GTTTTTTTTT', 'TTATATATAT', 'TTATATATCT', 'TTATATATGT', 'TTATATATTT', 'TTATATCTAT', 'TTATATCTCT', 'TTATATCTGT', 'TTATATCTTT', 'TTATATGTAT', 'TTATATGTCT', 'TTATATGTGT', 'TTATATGTTT', 'TTATATTTAT', 'TTATATTTCT', 'TTATATTTGT', 'TTATATTTTT', 'TTATCTATAT', 'TTATCTATCT', 'TTATCTATGT', 'TTATCTATTT', 'TTATCTCTAT', 'TTATCTCTCT', 'TTATCTCTGT', 'TTATCTCTTT', 'TTATCTGTAT', 'TTATCTGTCT', 'TTATCTGTGT', 'TTATCTGTTT', 'TTATCTTTAT', 'TTATCTTTCT', 'TTATCTTTGT', 'TTATCTTTTT', 'TTATGTATAT', 'TTATGTATCT', 'TTATGTATGT', 'TTATGTATTT', 'TTATGTCTAT', 'TTATGTCTCT', 'TTATGTCTGT', 'TTATGTCTTT', 'TTATGTGTAT', 'TTATGTGTCT', 'TTATGTGTGT', 'TTATGTGTTT', 'TTATGTTTAT', 'TTATGTTTCT', 'TTATGTTTGT', 'TTATGTTTTT', 'TTATTTATAT', 'TTATTTATCT', 'TTATTTATGT', 'TTATTTATTT', 'TTATTTCTAT', 'TTATTTCTCT', 'TTATTTCTGT', 'TTATTTCTTT', 'TTATTTGTAT', 'TTATTTGTCT', 'TTATTTGTGT', 'TTATTTGTTT', 'TTATTTTTAT', 'TTATTTTTCT', 'TTATTTTTGT', 'TTATTTTTTT', 'TTCTATATAT', 'TTCTATATCT', 'TTCTATATGT', 'TTCTATATTT', 'TTCTATCTAT', 'TTCTATCTCT', 'TTCTATCTGT', 'TTCTATCTTT', 'TTCTATGTAT', 'TTCTATGTCT', 'TTCTATGTGT', 'TTCTATGTTT', 'TTCTATTTAT', 'TTCTATTTCT', 'TTCTATTTGT', 'TTCTATTTTT', 'TTCTCTATAT', 'TTCTCTATCT', 'TTCTCTATGT', 'TTCTCTATTT', 'TTCTCTCTAT', 'TTCTCTCTCT', 'TTCTCTCTGT', 'TTCTCTCTTT', 'TTCTCTGTAT', 'TTCTCTGTCT', 'TTCTCTGTGT', 'TTCTCTGTTT', 'TTCTCTTTAT', 'TTCTCTTTCT', 'TTCTCTTTGT', 'TTCTCTTTTT', 'TTCTGTATAT', 'TTCTGTATCT', 'TTCTGTATGT', 'TTCTGTATTT', 'TTCTGTCTAT', 'TTCTGTCTCT', 'TTCTGTCTGT', 'TTCTGTCTTT', 'TTCTGTGTAT', 'TTCTGTGTCT', 'TTCTGTGTGT', 'TTCTGTGTTT', 'TTCTGTTTAT', 'TTCTGTTTCT', 'TTCTGTTTGT', 'TTCTGTTTTT', 'TTCTTTATAT', 'TTCTTTATCT', 'TTCTTTATGT', 'TTCTTTATTT', 'TTCTTTCTAT', 'TTCTTTCTCT', 'TTCTTTCTGT', 'TTCTTTCTTT', 'TTCTTTGTAT', 'TTCTTTGTCT', 'TTCTTTGTGT', 'TTCTTTGTTT', 'TTCTTTTTAT', 'TTCTTTTTCT', 'TTCTTTTTGT', 'TTCTTTTTTT', 'TTGTATATAT', 'TTGTATATCT', 'TTGTATATGT', 'TTGTATATTT', 'TTGTATCTAT', 'TTGTATCTCT', 'TTGTATCTGT', 'TTGTATCTTT', 'TTGTATGTAT', 'TTGTATGTCT', 'TTGTATGTGT', 'TTGTATGTTT', 'TTGTATTTAT', 'TTGTATTTCT', 'TTGTATTTGT', 'TTGTATTTTT', 'TTGTCTATAT', 'TTGTCTATCT', 'TTGTCTATGT', 'TTGTCTATTT', 'TTGTCTCTAT', 'TTGTCTCTCT', 'TTGTCTCTGT', 'TTGTCTCTTT', 'TTGTCTGTAT', 'TTGTCTGTCT', 'TTGTCTGTGT', 'TTGTCTGTTT', 'TTGTCTTTAT', 'TTGTCTTTCT', 'TTGTCTTTGT', 'TTGTCTTTTT', 'TTGTGTATAT', 'TTGTGTATCT', 'TTGTGTATGT', 'TTGTGTATTT', 'TTGTGTCTAT', 'TTGTGTCTCT', 'TTGTGTCTGT', 'TTGTGTCTTT', 'TTGTGTGTAT', 'TTGTGTGTCT', 'TTGTGTGTGT', 'TTGTGTGTTT', 'TTGTGTTTAT', 'TTGTGTTTCT', 'TTGTGTTTGT', 'TTGTGTTTTT', 'TTGTTTATAT', 'TTGTTTATCT', 'TTGTTTATGT', 'TTGTTTATTT', 'TTGTTTCTAT', 'TTGTTTCTCT', 'TTGTTTCTGT', 'TTGTTTCTTT', 'TTGTTTGTAT', 'TTGTTTGTCT', 'TTGTTTGTGT', 'TTGTTTGTTT', 'TTGTTTTTAT', 'TTGTTTTTCT', 'TTGTTTTTGT', 'TTGTTTTTTT', 'TTTTATATAT', 'TTTTATATCT', 'TTTTATATGT', 'TTTTATATTT', 'TTTTATCTAT', 'TTTTATCTCT', 'TTTTATCTGT', 'TTTTATCTTT', 'TTTTATGTAT', 'TTTTATGTCT', 'TTTTATGTGT', 'TTTTATGTTT', 'TTTTATTTAT', 'TTTTATTTCT', 'TTTTATTTGT', 'TTTTATTTTT', 'TTTTCTATAT', 'TTTTCTATCT', 'TTTTCTATGT', 'TTTTCTATTT', 'TTTTCTCTAT', 'TTTTCTCTCT', 'TTTTCTCTGT', 'TTTTCTCTTT', 'TTTTCTGTAT', 'TTTTCTGTCT', 'TTTTCTGTGT', 'TTTTCTGTTT', 'TTTTCTTTAT', 'TTTTCTTTCT', 'TTTTCTTTGT', 'TTTTCTTTTT', 'TTTTGTATAT', 'TTTTGTATCT', 'TTTTGTATGT', 'TTTTGTATTT', 'TTTTGTCTAT', 'TTTTGTCTCT', 'TTTTGTCTGT', 'TTTTGTCTTT', 'TTTTGTGTAT', 'TTTTGTGTCT', 'TTTTGTGTGT', 'TTTTGTGTTT', 'TTTTGTTTAT', 'TTTTGTTTCT', 'TTTTGTTTGT', 'TTTTGTTTTT', 'TTTTTTATAT', 'TTTTTTATCT', 'TTTTTTATGT', 'TTTTTTATTT', 'TTTTTTCTAT', 'TTTTTTCTCT', 'TTTTTTCTGT', 'TTTTTTCTTT', 'TTTTTTGTAT', 'TTTTTTGTCT', 'TTTTTTGTGT', 'TTTTTTGTTT', 'TTTTTTTTAT', 'TTTTTTTTCT', 'TTTTTTTTGT', 'TTTTTTTTTT']\n    assert candidate(\"TGCA\", [0, 1, 2, 3]) == ['TGCA', 'TGCC', 'TGCG', 'TGCT', 'TGAA', 'TGAC', 'TGAG', 'TGAT', 'TGGA', 'TGGC', 'TGGG', 'TGGT', 'TGTA', 'TGTC', 'TGTG', 'TGTT', 'TACA', 'TACC', 'TACG', 'TACT', 'TAAA', 'TAAC', 'TAAG', 'TAAT', 'TAGA', 'TAGC', 'TAGG', 'TAGT', 'TATA', 'TATC', 'TATG', 'TATT', 'TCCA', 'TCCC', 'TCCG', 'TCCT', 'TCAA', 'TCAC', 'TCAG', 'TCAT', 'TCGA', 'TCGC', 'TCGG', 'TCGT', 'TCTA', 'TCTC', 'TCTG', 'TCTT', 'TTCA', 'TTCC', 'TTCG', 'TTCT', 'TTAA', 'TTAC', 'TTAG', 'TTAT', 'TTGA', 'TTGC', 'TTGG', 'TTGT', 'TTTA', 'TTTC', 'TTTG', 'TTTT', 'AGCA', 'AGCC', 'AGCG', 'AGCT', 'AGAA', 'AGAC', 'AGAG', 'AGAT', 'AGGA', 'AGGC', 'AGGG', 'AGGT', 'AGTA', 'AGTC', 'AGTG', 'AGTT', 'AACA', 'AACC', 'AACG', 'AACT', 'AAAA', 'AAAC', 'AAAG', 'AAAT', 'AAGA', 'AAGC', 'AAGG', 'AAGT', 'AATA', 'AATC', 'AATG', 'AATT', 'ACCA', 'ACCC', 'ACCG', 'ACCT', 'ACAA', 'ACAC', 'ACAG', 'ACAT', 'ACGA', 'ACGC', 'ACGG', 'ACGT', 'ACTA', 'ACTC', 'ACTG', 'ACTT', 'ATCA', 'ATCC', 'ATCG', 'ATCT', 'ATAA', 'ATAC', 'ATAG', 'ATAT', 'ATGA', 'ATGC', 'ATGG', 'ATGT', 'ATTA', 'ATTC', 'ATTG', 'ATTT', 'CGCA', 'CGCC', 'CGCG', 'CGCT', 'CGAA', 'CGAC', 'CGAG', 'CGAT', 'CGGA', 'CGGC', 'CGGG', 'CGGT', 'CGTA', 'CGTC', 'CGTG', 'CGTT', 'CACA', 'CACC', 'CACG', 'CACT', 'CAAA', 'CAAC', 'CAAG', 'CAAT', 'CAGA', 'CAGC', 'CAGG', 'CAGT', 'CATA', 'CATC', 'CATG', 'CATT', 'CCCA', 'CCCC', 'CCCG', 'CCCT', 'CCAA', 'CCAC', 'CCAG', 'CCAT', 'CCGA', 'CCGC', 'CCGG', 'CCGT', 'CCTA', 'CCTC', 'CCTG', 'CCTT', 'CTCA', 'CTCC', 'CTCG', 'CTCT', 'CTAA', 'CTAC', 'CTAG', 'CTAT', 'CTGA', 'CTGC', 'CTGG', 'CTGT', 'CTTA', 'CTTC', 'CTTG', 'CTTT', 'GGCA', 'GGCC', 'GGCG', 'GGCT', 'GGAA', 'GGAC', 'GGAG', 'GGAT', 'GGGA', 'GGGC', 'GGGG', 'GGGT', 'GGTA', 'GGTC', 'GGTG', 'GGTT', 'GACA', 'GACC', 'GACG', 'GACT', 'GAAA', 'GAAC', 'GAAG', 'GAAT', 'GAGA', 'GAGC', 'GAGG', 'GAGT', 'GATA', 'GATC', 'GATG', 'GATT', 'GCCA', 'GCCC', 'GCCG', 'GCCT', 'GCAA', 'GCAC', 'GCAG', 'GCAT', 'GCGA', 'GCGC', 'GCGG', 'GCGT', 'GCTA', 'GCTC', 'GCTG', 'GCTT', 'GTCA', 'GTCC', 'GTCG', 'GTCT', 'GTAA', 'GTAC', 'GTAG', 'GTAT', 'GTGA', 'GTGC', 'GTGG', 'GTGT', 'GTTA', 'GTTC', 'GTTG', 'GTTT']\n    assert candidate(\"TACGTACG\", [2, 6]) == ['TACGTACG', 'TACGTAAG', 'TACGTAGG', 'TACGTATG', 'TAAGTACG', 'TAAGTAAG', 'TAAGTAGG', 'TAAGTATG', 'TAGGTACG', 'TAGGTAAG', 'TAGGTAGG', 'TAGGTATG', 'TATGTACG', 'TATGTAAG', 'TATGTAGG', 'TATGTATG']\n    assert candidate(\"GATTACA\", [1, 3, 5]) == ['GATTACA', 'GATTAAA', 'GATTAGA', 'GATTATA', 'GATAACA', 'GATAAAA', 'GATAAGA', 'GATAATA', 'GATCACA', 'GATCAAA', 'GATCAGA', 'GATCATA', 'GATGACA', 'GATGAAA', 'GATGAGA', 'GATGATA', 'GCTTACA', 'GCTTAAA', 'GCTTAGA', 'GCTTATA', 'GCTAACA', 'GCTAAAA', 'GCTAAGA', 'GCTAATA', 'GCTCACA', 'GCTCAAA', 'GCTCAGA', 'GCTCATA', 'GCTGACA', 'GCTGAAA', 'GCTGAGA', 'GCTGATA', 'GGTTACA', 'GGTTAAA', 'GGTTAGA', 'GGTTATA', 'GGTAACA', 'GGTAAAA', 'GGTAAGA', 'GGTAATA', 'GGTCACA', 'GGTCAAA', 'GGTCAGA', 'GGTCATA', 'GGTGACA', 'GGTGAAA', 'GGTGAGA', 'GGTGATA', 'GTTTACA', 'GTTTAAA', 'GTTTAGA', 'GTTTATA', 'GTTAACA', 'GTTAAAA', 'GTTAAGA', 'GTTAATA', 'GTTCACA', 'GTTCAAA', 'GTTCAGA', 'GTTCATA', 'GTTGACA', 'GTTGAAA', 'GTTGAGA', 'GTTGATA']\n    assert candidate(\"TTTTTTTT\", [0, 7]) == ['TTTTTTTT', 'TTTTTTTA', 'TTTTTTTC', 'TTTTTTTG', 'ATTTTTTT', 'ATTTTTTA', 'ATTTTTTC', 'ATTTTTTG', 'CTTTTTTT', 'CTTTTTTA', 'CTTTTTTC', 'CTTTTTTG', 'GTTTTTTT', 'GTTTTTTA', 'GTTTTTTC', 'GTTTTTTG']\n    assert candidate(\"AGCT\", []) == ['AGCT']\n    assert candidate(\"ACTGACTG\", [1, 5]) == ['ACTGACTG', 'ACTGAATG', 'ACTGAGTG', 'ACTGATTG', 'AATGACTG', 'AATGAATG', 'AATGAGTG', 'AATGATTG', 'AGTGACTG', 'AGTGAATG', 'AGTGAGTG', 'AGTGATTG', 'ATTGACTG', 'ATTGAATG', 'ATTGAGTG', 'ATTGATTG']\n", "language": "python"}
{"task_id": "3836291c-347b-41c9-9cac-6e906c374333-5249603073178647827", "prompt": "Implement the function as specified, making it executable without modification. Only use libraries that were imported in the original problem. Define any helper functions or classes within the main function scope.\n\n```python\nfrom typing import List, Tuple\n\ndef efficiency_analyzer(processes: List[Tuple[str, int, int]]) -> List[str]:\n    \"\"\"\n    In a futuristic factory, robots perform various tasks. Each robot has a unique name, energy consumption rate, and output rate. The factory manager wants to analyze the efficiency of these robots.\n\n    This function takes a list of tuples, where each tuple contains (robot_name, energy_consumption, output_rate). It returns a list of strings describing the efficiency of each robot, sorted from most to least efficient.\n\n    Efficiency is calculated as (output_rate / energy_consumption). The function should use list comprehension and lambda functions to perform the calculations and sorting.\n\n\n    [EXAMPLES]\n    \n    assert candidate([(\"!@#$%^&*()\", 5, 10)]) == ['!@#$%^&*() has an efficiency of 2.00']\n    assert candidate([(\"Long\" + \"Name\" * 100, 1, 1)]) == ['LongNameNameNameNameNameNameNameNameNameNameNameNameNameNameNameNameNameNameNameNameNameNameNameNameNameNameNameNameNameNameNameNameNameNameNameNameNameNameNameNameNameNameNameNameNameNameNameNameNameNameNameNameNameNameNameNameNameNameNameNameNameNameNameNameNameNameNameNameNameNameNameNameNameNameNameNameNameNameNameNameNameNameNameNameNameNameNameNameNameNameNameNameNameNameNameNameNameNameNameName has an efficiency of 1.00']\n\n    [/EXAMPLES]\n    \"\"\"\n```\n", "entry_point": "efficiency_analyzer", "solution": "from typing import List, Tuple\n\ndef efficiency_analyzer(processes: List[Tuple[str, int, int]]) -> List[str]:\n    \"\"\"\n    In a futuristic factory, robots perform various tasks. Each robot has a unique name, energy consumption rate, and output rate. The factory manager wants to analyze the efficiency of these robots.\n\n    This function takes a list of tuples, where each tuple contains (robot_name, energy_consumption, output_rate). It returns a list of strings describing the efficiency of each robot, sorted from most to least efficient.\n\n    Efficiency is calculated as (output_rate / energy_consumption). The function should use list comprehension and lambda functions to perform the calculations and sorting.\n\n\n    [EXAMPLES]\n    \n    assert candidate([(\"!@#$%^&*()\", 5, 10)]) == ['!@#$%^&*() has an efficiency of 2.00']\n    assert candidate([(\"Long\" + \"Name\" * 100, 1, 1)]) == ['LongNameNameNameNameNameNameNameNameNameNameNameNameNameNameNameNameNameNameNameNameNameNameNameNameNameNameNameNameNameNameNameNameNameNameNameNameNameNameNameNameNameNameNameNameNameNameNameNameNameNameNameNameNameNameNameNameNameNameNameNameNameNameNameNameNameNameNameNameNameNameNameNameNameNameNameNameNameNameNameNameNameNameNameNameNameNameNameNameNameNameNameNameNameNameNameNameNameNameNameName has an efficiency of 1.00']\n\n    [/EXAMPLES]\n    \"\"\"\n    # Calculate efficiency for each robot using list comprehension\n    efficiencies = [(robot[0], robot[2] / robot[1]) for robot in processes]\n    \n    # Sort the efficiencies list from most to least efficient using a lambda function\n    sorted_efficiencies = sorted(efficiencies, key=lambda x: x[1], reverse=True)\n    \n    # Create the output list using list comprehension\n    return [f\"{robot[0]} has an efficiency of {robot[1]:.2f}\" for robot in sorted_efficiencies]\n\n", "test": "def check(candidate):\n    assert candidate([(\"Single\", 1, 1)]) == ['Single has an efficiency of 1.00']\n    assert candidate([(\"R2D2\", 50, 100), (\"C3PO\", 75, 80), (\"BB8\", 30, 90)]) == ['BB8 has an efficiency of 3.00', 'R2D2 has an efficiency of 2.00', 'C3PO has an efficiency of 1.07']\n    assert candidate([(\"!@#$%^&*()\", 5, 10)]) == ['!@#$%^&*() has an efficiency of 2.00']\n    assert candidate([(\"Max\", 2**31-1, 2**31-1), (\"Min\", 1, 1)]) == ['Max has an efficiency of 1.00', 'Min has an efficiency of 1.00']\n    assert candidate([(\"A\", 1, 1), (\"B\", 2, 2), (\"C\", 3, 3), (\"D\", 4, 4), (\"E\", 5, 5)]) == ['A has an efficiency of 1.00', 'B has an efficiency of 1.00', 'C has an efficiency of 1.00', 'D has an efficiency of 1.00', 'E has an efficiency of 1.00']\n    assert candidate([(\"Unicode\u2764\", 42, 42)]) == ['Unicode\u2764 has an efficiency of 1.00']\n    assert candidate([(\"A\", 1, 100), (\"B\", 100, 1)]) == ['A has an efficiency of 100.00', 'B has an efficiency of 0.01']\n    assert candidate([(\"Neg1\", -1, 1), (\"Neg2\", 1, -1), (\"Neg3\", -1, -1)]) == ['Neg3 has an efficiency of 1.00', 'Neg1 has an efficiency of -1.00', 'Neg2 has an efficiency of -1.00']\n    assert candidate([(\"Robot\", 1, 1)] * 10) == ['Robot has an efficiency of 1.00', 'Robot has an efficiency of 1.00', 'Robot has an efficiency of 1.00', 'Robot has an efficiency of 1.00', 'Robot has an efficiency of 1.00', 'Robot has an efficiency of 1.00', 'Robot has an efficiency of 1.00', 'Robot has an efficiency of 1.00', 'Robot has an efficiency of 1.00', 'Robot has an efficiency of 1.00']\n    assert candidate([(\"Long\" + \"Name\" * 100, 1, 1)]) == ['LongNameNameNameNameNameNameNameNameNameNameNameNameNameNameNameNameNameNameNameNameNameNameNameNameNameNameNameNameNameNameNameNameNameNameNameNameNameNameNameNameNameNameNameNameNameNameNameNameNameNameNameNameNameNameNameNameNameNameNameNameNameNameNameNameNameNameNameNameNameNameNameNameNameNameNameNameNameNameNameNameNameNameNameNameNameNameNameNameNameNameNameNameNameNameNameNameNameNameNameName has an efficiency of 1.00']\n", "language": "python"}
